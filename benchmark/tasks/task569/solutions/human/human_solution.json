[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(r)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\n\nobject Main {\n  def right(m:scala.collection.immutable.Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i+1)).updated(i+1,0)\n  def left(m:Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i-1)).updated(i-1,0)\n  def up(m:Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i-3)).updated(i-3,0)\n  def down(m:Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i+3)).updated(i+3,0)\n  def end(m:Map[Int,Int]) = m == Map(0->1,1->2,2->3,3->4,4->5,5->6,6->7,7->8,8->0)\n\n  def main(args:Array[String]) = {\n    val p = new HashMap[Int,Int]\n    val hist= new HashMap[scala.collection.immutable.Map[Int,Int], Int]\n    var found = false\n    var count = 0\n    var idx = 0\n    var k = 0\n    var l = 0\n    for(i<-1 to 3) {\n      readLine.split(\" \").map(_.toInt).foreach{ x=>\n        p += (k->x)\n        if(x==0) l = k\n        k+=1\n      }\n    }\n\n    hist += (p.toMap->l)\n    while(!found) {\n      val hist2 = new HashMap[scala.collection.immutable.Map[Int,Int], Int]\n      for((m,i)<-hist if !found) {\n        if(i % 3 != 2) {\n          val r = right(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i+1))\n        }\n        if(!found && i % 3 != 0) {\n          val r = left(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i-1))\n        }\n        if(!found && i / 3 != 0) {\n          val r = up(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i-3))\n        }\n        if(!found && i / 3 != 2) {\n          val r = down(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i+3))\n        }\n      }\n      if(!found) hist ++= hist2\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos+1\n          }\n        }\n\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util\nobject Main extends App {\n  import scala.io.StdIn._\n  val goal = new Square(Array(Array(1,2,3), Array(4,5,6), Array(7,8,0)))\n  val goalHash = goal.hashCode()\n  val start = new Square((0 until 3).map{_ => readLine().trim().split(' ').map(_.toInt).toArray}.toArray)\n  println(search(start))\n  def search(start:Square):Int = {\n    val memo = Array.tabulate(362880){_ => -1}\n    var count = 0\n    val queue:util.Deque[Square] = new util.LinkedList()\n    memo(start.hashCode()) = 0\n    queue.addLast(start)\n    while (memo(goalHash) < 0){\n      count += 1\n      for (i <- 0 until queue.size()){\n        for (s <- queue.peek().nextCases){\n          if (memo(s.hashCode()) < 0){\n            memo(s.hashCode()) = count\n            queue.addLast(s)\n          }\n        }\n        queue.pop()\n      }\n    }\n    memo(goalHash)\n  }\n  class Square(private val array:Array[Array[Int]]){\n    override def hashCode(): Int = Square.factorial.foldLeft((0, (0 until 3).flatMap{a => (0 until 3).map{b => array(a)(b)}}.toList)){\n      case ((s, h::t), f) => (s + f * h, t.map{n => if (n > h) n - 1 else n})\n      case (s, f) => s\n    }._1\n    lazy val zeroPoint:Point = (0 until 3).flatMap{x => (0 until 3).map{y => Point(x, y)}}.filter{case Point(x, y) => array(x)(y) == 0}.head\n    def copy:Square = new Square(array.map(_.clone()))\n    def nextCases:List[Square] = zeroPoint.neighbors.filter(Square.isValidPoint(_)).map{\n      case Point(x, y) =>\n        val r = copy\n        r.array(zeroPoint.x)(zeroPoint.y) = array(x)(y)\n        r.array(x)(y) = 0\n        r\n    }\n  }\n  case class Point(x:Int, y:Int){\n    def neighbors:List[Point] = List(Point(x - 1, y), Point(x + 1, y), Point(x, y - 1), Point(x, y + 1))\n  }\n  object Square{\n    val factorial = List(40320, 5040, 720, 120, 24, 6, 2, 1, 1)\n    def isValidPoint(other:Point):Boolean = (0 until 3).contains(other.x) && (0 until 3).contains(other.y)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def right(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+1); b(i+1) = 0;b }\n  def left(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-1); b(i-1) = 0;b }\n  def up(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-3); b(i-3) = 0;b }\n  def down(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+3); b(i+3) = 0;b }\n  def end(a:Array[Int], i:Int ) =\n    a(0)==1 && a(1)==2 && a(2)==3 && a(3)==4 &&\n    a(4)==5 && a(5)==6 && a(6)==7 && a(7)==8 && a(8)==0\n  def contains(list:ArrayBuffer[(Int,Array[Int])], a:Array[Int]) =\n    list.exists( _._2.sameElements(a) )\n\n  def main(args:Array[String]) = { val p = new ArrayBuffer[Int]\n    val hist= new ArrayBuffer[(Int,Array[Int])]\n    var found = false\n    var count = 0\n    var idx = 0\n    var result:Array[Int] = null\n    for(i<-1 to 3) readLine.split(\" \").map(_.toInt).foreach( p += _ )\n\n    hist += ((p.indexWhere( _ == 0 ), p.toArray))\n\n    while(!found && count<5) {\n      val len = hist.length\n      for(k<-idx until hist.length if !found) {\n        val (i,e) = hist(k)\n        if(i % 3 != 2) {\n          val r = right(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+1,r))\n        }\n        if(!found && i % 3 != 0) {\n          val r = left(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-1,r))\n        }\n        if(!found && i / 3 != 0) {\n          val r = up(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-3,r))\n        }\n        if(!found && i / 3 != 2) {\n          val r = down(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+3,r))\n        }\n      }\n      idx += (len-idx)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m+(9+x)(d2-d1)\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def right(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+1); b(i+1) = 0;b }\n  def left(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-1); b(i-1) = 0;b }\n  def up(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-3); b(i-3) = 0;b }\n  def down(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+3); b(i+3) = 0;b }\n  def end(a:Array[Int], i:Int ) =\n    a(0)==1 && a(1)==2 && a(2)==3 && a(3)==4 &&\n    a(4)==5 && a(5)==6 && a(6)==7 && a(7)==8 && a(8)==0\n  def contains(list:ArrayBuffer[(Int,Array[Int])], a:Array[Int]) =\n    list.exists( _._2.sameElements(a) )\n\n  def main(args:Array[String]) = { val p = new ArrayBuffer[Int]\n    val hist= new ArrayBuffer[(Int,Array[Int])]\n    var found = false\n    var count = 0\n    var idx = 0\n    var result:Array[Int] = null\n    for(i<-1 to 3) readLine.split(\" \").map(_.toInt).foreach( p += _ )\n\n    hist += ((p.indexWhere( _ == 0 ), p.toArray))\n\n    while(!found) {\n      val len = hist.length\n      for(k<-idx until hist.length if !found) {\n        val (i,e) = hist(k)\n        if(i % 3 != 2) {\n          val r = right(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+1,r))\n        }\n        if(!found && i % 3 != 0) {\n          val r = left(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-1,r))\n        }\n        if(!found && i / 3 != 0) {\n          val r = up(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-3,r))\n        }\n        if(!found && i / 3 != 2) {\n          val r = down(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+3,r))\n        }\n      }\n      idx += (len-idx)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m + (9+x) * (d2-d1)\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\nusing namespace std;\n\n#define U 1\n#define D 2\n#define R 3 \n#define L 4\n\n\nconst int ans = 123456780;\nset<int> leaf;\n\n\nvoid print(int s){\n  int board[9];\n  for(int i=0; i<9; i++){\n    board[8-i] = s%10;\n    s /= 10;\n  }\n  for(int i=0; i<9; i++){\n    cout << board[i] << ' ';\n    if(i%3 == 2)cout << endl;\n  }\n}\n\nint  moveSpace(int state, int dir){\n  int board[9];\n\n  //int --> matrix\n  for(int i=0; i<9; i++){\n    board[8-i] = state%10;\n    state /= 10;\n  }\n\n  //find space\n  int pos = 0;\n  while(board[pos]!=0)pos++;\n  \n\n  //move space up\n  if(dir==U && pos > 2){\n    int tmp = board[pos];\n    board[pos] = board[pos-3];\n    board[pos-3] = tmp;\n  }\n  else if(dir==D && pos < 6){\n    int tmp = board[pos];\n    board[pos] = board[pos+3];\n    board[pos+3] = tmp;\n  }\n  else if(dir==R && pos != 2 && pos != 5 && pos != 8){\n    int tmp = board[pos];\n    board[pos] = board[pos+1];\n    board[pos+1] = tmp;\n  }\n  else if(dir==L && pos != 0 && pos != 3 && pos != 6){\n    int tmp = board[pos];\n    board[pos] = board[pos-1];\n    board[pos-1] = tmp;\n  }\n  else{\n    return -1;\n  }\n\n  //matrix --> int\n  state = board[0];\n  for(int i=1; i<9; i++){\n    state *= 10;\n    state += board[i];\n  }\n\n  return state;\n}\n//@end moveSpace\n\n\n\nint solve(int state, int step, int depth){\n  if(state == ans)return step;\n  if(step == depth){\n    leaf.insert(state);\n\n    //cout << \"Step:\" << step << endl;\n    //print(state); cout << endl;\n    \n    return -1;\n  }\n  //if(searched.find(state)!=searched.end())return -1;\n  \n  int next;\n  next = moveSpace(state, U);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n  next = moveSpace(state, D);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n  next = moveSpace(state, R);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n  next = moveSpace(state, L);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n\n  return -1;\n}\n\n\nint main(){\n\n  /*\n    Index of array\n    0 1 2\n    3 4 5 \n    6 7 8\n   */\n  int init_state;\n\n  //input\n  cin >> init_state;\n  for(int i=1; i<9; i++){\n    int tmp;\n    cin >> tmp;\n    init_state*=10; init_state+=tmp;\n  }\n  \n\n  int step = 0;\n \n  //solve\n  int depth = 1;\n  leaf.insert(init_state);\n  while(1){\n\n    //test\n    //cout << \"===================================\" << endl;\n    //cout << \"Depth: \" << depth << endl;\n\n    \n    set<int> next = leaf;\n    leaf.clear();\n    step = 0;\n    \n    for(int state : next){\n      step = solve(state ,depth-1, depth);\n      if(step != -1)break;\n    }\n    if(step != -1)break;\n\n    \n    depth++;\n  }\n  \n  cout << step << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n    int S = 100000000;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            table[i][k] = x/S;\n            x = x%S;\n            S /= 10;\n        }\n    }\n}\n\nint getNUM(int x){\n    switch(x){\n    case 0:return 1;\n    case 1:return 1;\n    case 2:return 2;\n    case 3:return 6;\n    case 4:return 24;\n    case 5:return 120;\n    case 6:return 720;\n    case 7:return 5040;\n    case 8:return 40320;\n    }\n    return -1;\n}\n\nlong long makeLong(int Table[3][3]){\n    return 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n    long long x = makeLong(Table);\n    int checkTable[9] = {0};\n    long long S = 100000000;\n    int ret = 0,small_num_appear_count,limit;\n    for(int i=8; i >= 0; i--){\n        small_num_appear_count=0;\n\tlimit = x/S;\n        for(int k = 0; k < limit;k++){\n            if(checkTable[k] == 1)small_num_appear_count++;\n        }\n        ret += ((x/S)-small_num_appear_count)*getNUM(i);\n        checkTable[(x/S)]=1;\n        x %= S;\n        S /= 10;\n    }\n\n    return ret;\n}\n\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nstruct Info{\n    Info(){ zero_loc=data = count = 0;}\n    Info(long long arg_data,int arg_count,short arg_loc){\n        data = arg_data;\n        count = arg_count;\n        zero_loc = arg_loc;\n    }\n    long long data;\n    int count;\n    short zero_loc;\n};\n\nclass LongQ{\npublic:\n    LongQ(){\n        Q = new Info[362880];\n        head = tail = num_of_data=0;\n    }\n\n    void enqueue(long long arg_data,int arg_count,short arg_loc){\n        Q[tail].count = arg_count;\n        Q[tail].data = arg_data;\n        Q[tail].zero_loc = arg_loc;\n        num_of_data++;\n        tail = (tail+1)%362880;\n    }\n\n    Info dequeue(){\n        Info ret = Q[head];\n        head = (head+1)%362880;\n        num_of_data--;\n        return ret;\n    }\n\n    bool isEmpty(){\n        return num_of_data == 0;\n    }\n\nprivate:\n    Info* Q;\n    int head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo,short zero_loc){\n    if(checkTable[translateORDER(table)] == -1){\n        checkTable[translateORDER(table)]=tmpInfo.count;\n        queue.enqueue(makeLong(table),tmpInfo.count+1,zero_loc);\n    }\n    return queue;\n}\n\nint main(){\n\n    for(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n    int table[3][3];\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n\n    checkTable[translateORDER(table)]=0;\n    LongQ queue;\n\n    queue.enqueue(makeLong(table),0,zeroLoc(table));\n\n    Info tmpInfo;\n\n    while(queue.isEmpty()==false){\n        tmpInfo=queue.dequeue();\n\n        int tmpTable[3][3];\n        setNUM(tmpTable,tmpInfo.data);\n        if(tmpTable[0][0]==1&&tmpTable[0][1]==2&&tmpTable[0][2]==3&&tmpTable[1][0]==4&&\n        \t\ttmpTable[1][1]==5&&tmpTable[1][2]==6&&tmpTable[2][0]==7&&tmpTable[2][1]==8){\n            printf(\"%d\\n\",tmpInfo.count);\n            break;\n        }\n\n        int next_table[4][3][3];\n\n        for(int a=0;a<4;a++){\n            for(int b=0;b<3;b++){\n                for(int c=0;c<3;c++){\n                    next_table[a][b][c] = tmpTable[b][c];\n                }\n            }\n        }\n\n        switch(tmpInfo.zero_loc){\n        case 0:\n            swap(next_table[0][0][0],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][0],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n            break;\n        case 1:\n            swap(next_table[0][0][1],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][0][1],next_table[1][0][2]);\n            queue = func(queue,next_table[1],tmpInfo,2);\n\n            swap(next_table[2][0][1],next_table[2][1][1]);\n            queue = func(queue,next_table[2],tmpInfo,11);\n            break;\n        case 2:\n            swap(next_table[0][0][2],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][2],next_table[1][1][2]);\n            queue = func(queue,next_table[1],tmpInfo,12);\n\n            break;\n        case 10:\n            swap(next_table[0][1][0],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][1][0],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][0],next_table[2][2][0]);\n            queue = func(queue,next_table[2],tmpInfo,20);\n\n            break;\n        case 11:\n            swap(next_table[0][1][1],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][1][1],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n\n            swap(next_table[2][1][1],next_table[2][1][2]);\n            queue = func(queue,next_table[2],tmpInfo,12);\n\n            swap(next_table[3][1][1],next_table[3][2][1]);\n            queue = func(queue,next_table[3],tmpInfo,21);\n            break;\n        case 12:\n            swap(next_table[0][1][2],next_table[0][0][2]);\n            queue = func(queue,next_table[0],tmpInfo,2);\n\n            swap(next_table[1][1][2],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][2],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 20:\n            swap(next_table[0][2][0],next_table[0][1][0]);\n            queue = func(queue,next_table[0],tmpInfo,10);\n\n            swap(next_table[1][2][0],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        case 21:\n            swap(next_table[0][2][1],next_table[0][2][0]);\n            queue = func(queue,next_table[0],tmpInfo,20);\n\n            swap(next_table[1][2][1],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][2][1],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 22:\n            swap(next_table[0][2][2],next_table[0][1][2]);\n            queue = func(queue,next_table[0],tmpInfo,12);\n\n            swap(next_table[1][2][2],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n  \nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n  \nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n  \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n  \nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n  \nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n  \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"\";\n}\n  \nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n  \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 20\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define NPANEL 9\n\nclass State {\npublic:\n  int panels[9];\n  int empty;\n  State(int p[]) {\n    for (int i = 0; i < NPANEL; i++) {\n      panels[i] = p[i];\n      if (p[i] == 0)\n        empty = i;\n    }\n  }\n  void print() {\n    for (int i = 0; i < NPANEL; i++) {\n      if (i != 0 && i % 3 == 0)\n        printf(\"\\n\");\n      printf(\"%d \", panels[i]);\n    }\n  }\n  bool is_completed() {\n    for (int i = 1; i < NPANEL; i++)\n      if (panels[i - 1] != i)\n        return false;\n    return true;\n  }\n  State left() { return slide(empty, empty - 1); }\n  State above() { return slide(empty, empty - 3); }\n  State right() { return slide(empty, empty + 1); }\n  State bottom() { return slide(empty, empty + 3); }\n  State slide(int x, int y) {\n    auto s = State(panels);\n    swap(s.panels[x], s.panels[y]);\n    s.empty = y;\n    return s;\n  }\n\n  vector<State> nexts() {\n    vector<State> v;\n    if (empty % 3 != 0)\n      v.push_back(left());\n    if (empty >= 3)\n      v.push_back(above());\n    if (empty % 3 != 2)\n      v.push_back(right());\n    if (empty <= 5)\n      v.push_back(bottom());\n    return v;\n  }\n};\n\nbool store(State st) {\n  return true;\n  static set<int> pool;\n  int hash = 0;\n  for (int i = 0; i < NPANEL; i++) {\n    hash *= 10;\n    hash += st.panels[i];\n  }\n  bool exists = (pool.find(hash) != pool.end());\n  if (!exists)\n    pool.insert(hash);\n  return !exists;\n}\n\nstruct Node {\n  State state;\n  int depth;\n};\n\nvoid solve(State init) {\n  queue<Node> que;\n  que.push(Node{init, 0});\n\n  while (!que.empty()) {\n    Node node = que.front();\n    for (auto s : node.state.nexts()) {\n      if (s.is_completed()) {\n        cout << node.depth + 1 << endl;\n        return;\n      }\n      if (store(s)) {\n        que.push(Node{s, node.depth + 1});\n      }\n    }\n    que.pop();\n  }\n}\n\nint main() {\n  int data[NPANEL];\n  for (int i = 0; i < NPANEL; i++)\n    cin >> data[i];\n\n  auto s = State(data);\n  solve(s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<cassert>\n#include<cmath>\n\nusing namespace std;\n\n#define N 3\n#define PN 9\n#define LIMIT 100\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\n\nint MDT[PN][PN];\n\nstruct Puzzle{\n  int f[PN], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint sumMD(Puzzle pzl){\n  int sum = 0;\n  for(int i=0 ; i<PN ; ++i){\n    if(pzl.f[i] == PN) continue;\n    sum += MDT[i][pzl.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0 ; i<PN ; ++i) if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n  if(depth + state.MD > limit) return false;\n\n  int sx = state.space/N;\n  int sy = state.space%N;\n  Puzzle tmp;\n\n  for(int r=0 ; r<4 ; ++r){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx<0 || ty<0|| tx>=N || ty >= N) continue;\n    if(max(prev, r)-min(prev, r) == 2) continue;\n    tmp = state;\n\n    state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n    state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n    swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n    state.space = tx*N+ty;\n    if(dfs(depth+1, r)){\n      path[depth] = r;\n      return true;\n    }\n    state = tmp;\n  }\n  return false;\n}\n\nstring iterative_deeping(Puzzle in){\n  in.MD = sumMD(in);\n\n  for(limit = in.MD ; limit<=LIMIT ; ++limit){\n    state = in;\n    if(dfs(0, -100)){\n      string ans = \"\";\n      for(int i=0 ; i<limit ; ++i) ans += dir[path[i]];\n      return ans;\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0 ; i<PN ; ++i){\n    for(int j=0 ; j<PN ; ++j){\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n    }\n  }\n  Puzzle in;\n  for(int i=0 ; i<PN ; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = PN;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deeping(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define SIDE 3\n#define N 9\n\ntypedef struct board {\n  int state[N];\n  int zero_pos;\n  vector<int> path;\n\n  bool operator < (const board &t) const {\n    for (int i = 0; i < N; i++) {\n      if (state[i] == t.state[i]) continue;\n      else if (state[i] < t.state[i]) return true;\n      else return false;\n    }\n    return false;\n  }\n} Board;\n\nint BOARD[N] = { -1 };\nint DX[4] = { 0, 1, 0, -1 };\nint DY[4] = { 1, 0, -1, 0 };\n\nbool is_goal(Board b) {\n  for (int i = 0; i < N-1; i ++)\n    if (b.state[i] != i+1) return false;\n\n  return true;\n}\n\nvoid solve(Board b) {\n  map<Board, bool> visited;\n  queue<Board> q;\n  q.push(b);\n\n  while (!q.empty()) {\n    Board cur_b = q.front(); q.pop();\n    visited[cur_b] = true;\n\n    if (is_goal(cur_b)) {\n      cout << cur_b.path.size() << endl;\n      return;\n    }\n\n    for (int i = 0; i < 4; i ++) {\n      Board new_b = cur_b;\n      int new_x = (cur_b.zero_pos / SIDE) + DX[i];\n      int new_y = (cur_b.zero_pos % SIDE) + DY[i];\n\n      if (new_x < 0 || new_x > 2 || new_y < 0 || new_y > 2) continue;\n\n      new_b.zero_pos = new_x * SIDE + new_y;\n      swap(new_b.state[new_b.zero_pos], new_b.state[cur_b.zero_pos]);\n\n      if (visited[new_b]) continue;\n\n      new_b.path.push_back(new_b.zero_pos);\n      q.push(new_b);\n    }\n  }\n}\n\nint main() {\n  Board b;\n\n  for (int i = 0; i < N; i++) {\n    cin >> b.state[i];\n    if (b.state[i] == 0) b.zero_pos = i;\n  }\n\n  solve(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n#define N 3\n#define N2 9\n\nint main()\n{\n    8puzzle in;\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\nstruct 8puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const 8puzzle & p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n\nbool isTarget(8puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(8puzzle s)\n{\n    queue<8puzzle> Q;\n    map<8puzzle, bool> V;\n    8puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for (int i = x; i < n; i++)\n#define OP(m) cout << m << endl\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct puzzle\n{\n    int f[9];\n    int space;\n    int cnt;\n\n    bool operator<(const puzzle &p) const\n    {\n        rep(i, 9)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return 0;\n    }\n};\n\npair<int, int> d[4] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\n\nint bfs(puzzle s)\n{\n    queue<puzzle> q;\n    map<puzzle, bool> mp;\n    mp[s] = 1;\n    s.cnt = 0;\n    q.push(s);\n\n    while (!q.empty())\n    {\n        puzzle u = q.front();\n        q.pop();\n\n        auto check = [](puzzle p) -> bool {\n            rep(i, 9) if (p.f[i] != i + 1) return 0;\n            return 1;\n        };\n\n        if (check(u))\n            return u.cnt;\n\n        int x = u.space / 3, y = u.space % 3;\n        rep(i, 4)\n        {\n            int nx = x + d[i].first, ny = y + d[i].second;\n            if (!((0 <= nx && nx < 3) && (0 <= ny && ny < 3)))\n                continue;\n            puzzle u_copy = u;\n\n            swap(u_copy.f[u.space], u_copy.f[3 * nx + ny]);\n            u_copy.space = 3 * nx + ny;\n\n            if (!mp[u_copy])\n            {\n                mp[u_copy] = 1;\n                u_copy.cnt++;\n                q.push(u_copy);\n            }\n        }\n    }\n\n    return 0;\n}\n\nint main()\n{\n    puzzle in;\n    rep(i, 9)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = 9;\n            in.space = i;\n        }\n    }\n\n    OP(bfs(in));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0;i < N2;i++)if(p.f[i] != (i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) )return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N )continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<stdio.h>\n#include<stdlib.h>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        \n        for (int i = 0 ; i<N2 ; i++) {\n            if (f[i]==p.f[i]){\n                continue;\n                \n            }\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p){\n    \n    for (int i =0 ; i<N2 ; i++){\n        if (p.f[i]!=(i + 1)){\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic const char dir[4] = {'u', 'l', 'd', 'r'\n};\nstatic const int dx[4] = {-1, 0, 1, 0\n};\nstatic const int dy[4] = {0, -1, 0, 1\n};\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i =0 ; i<N2 ; i++){\n        cin >> in.f[i];\n        if (in.f[i]==0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    \n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) {\n                    swap(tmp[p], tmp[q]);\n                    wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n                } else {\n                    swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                    wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                    + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n                }\n                if (s.count(tmp)) continue; // already search\n\n                if (wrong_place == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        steps = h1();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2,t3;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\n//ll n = 3;\n//vector<ll> vec(9),vec_init(9);\n//vector<ll> move_vec[9];\n//bool can = false;\n//\n//void init(){\n//  rep(i,9){\n//    vec[i] = vec_init[i];\n//  }\n//}\n//\n//void dfs(ll piv,ll pre, ll depth,ll maxi){\n//  if(depth > maxi){\n//    //cout << depth << endl;\n//    return;\n//  }\n//  bool eq = true;\n//  rep(i,9){\n//    if(vec[i] != (i+1) % 9){\n//      eq = false;\n//      break;\n//    }\n//  }\n//  if(eq){\n//    can = true;\n//    return;\n//  }\n//  for(auto itr:move_vec[piv]){\n//    if(itr != pre){\n//      swap(vec[piv],vec[itr]);\n//      dfs(itr,piv,depth+1,maxi);\n//      swap(vec[piv],vec[itr]);\n//    }\n//  }\n//}\n//\n//int main(){\n//  ll piv = 0;\n//  rep(i,n*n){\n//    cin >> vec_init[i];\n//    if(vec_init[i] == 0){\n//      piv = i;\n//    }\n//  }\n//  rep(i,n*n){\n//    if(i % 3 != 2){\n//      move_vec[i].push_back(i+1);\n//    }\n//    if(i % 3 != 0){\n//      move_vec[i].push_back(i-1);\n//    }\n//    if(i / 3 != 0){\n//      move_vec[i].push_back(i-3);\n//    }\n//    if(i / 3 != 2){\n//      move_vec[i].push_back(i+3);\n//    }\n//  }\n//\n//  ll ans = 0;\n//  rep(i,100){\n//    init();\n//    dfs(piv,-1,0,i);\n//    if(can){\n//      ans = i;\n//      break;\n//    }\n//  }\n//  cout << ans << endl;\n//}\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    ll f[N2];\n    ll space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n      rep(i,N2){\n        if(f[i] == p.f[i])continue;\n        return f[i] > p.f[i];\n      }\n      return false;\n    }\n};\n\nstatic const ll dx[4] = {-1,0,1,0};\nstatic const ll dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  rep(i,N2){\n    if(p.f[i] != (i+1) ) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    ll sx = u.space / N;\n    ll sy = u.space % N;\n    rep(r,4){\n      ll tx = sx + dx[r];\n      ll ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  rep(i,N2){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<set>\n#include<map>\n#include<utility>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define LL long long\nconst int dx[4] = { 1,-1,0,0 };\nconst int dy[4] = { 0,0,1,-1 };\nbool OOA(int x, int y, int H, int W) { return (0 <= x && x<H) && (0 <= y && y<W); }\n\nint main(){\n\tstring f=\"\";\n\tfor(int i=0;i<9;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tf+=c;\n\t}\n\n\tmap<string,int>d;\n\tstring g=\"123456780\";\n\n\tqueue<string>q;\n\tq.push(f);\n\td[f]=0;\n\t\n\twhile(!q.empty()){\n\t\tstring n=q.front();\n\t\tq.pop();\n\t\tif(n==g){\n\t\t\tcout<<d[n]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint nd=d[n];\n\t\tfor(int i=0;i<9;i++){\n\t\t\tif((i/3)&&(n[i]=='0'||n[i-3]=='0')){\n\t\t\t\tswap(n[i],n[i-3]);\n\t\t\t\tif(!d.count(n)){\n\t\t\t\t\td[n]=nd+1;\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t\tswap(n[i],n[i-3]);\n\t\t\t}\n\t\t\tif((i%3)&&(n[i]=='0'||n[i-1]=='0')){\n\t\t\t\tswap(n[i],n[i-1]);\n\t\t\t\tif(!d.count(n)){\n\t\t\t\t\td[n]=nd+1;\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t\tswap(n[i],n[i-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 28\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 15\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] != p.f[i]) {\n\t\t\t\treturn f[i] > p.f[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\nstring bfs(Puzzle p) {\n\tp.path = \"\";\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\tqueue<Puzzle> Q;\n\tQ.push(p);\n\tfor (int i = 0; i < N2; ++i) {\n\t\twhile (!Q.empty()) {\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (isComplete(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u;\n\t\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!M[v]) {\n\t\t\t\t\tM[v] = true;\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n\nusing namespace std;\n\nint minimum = -1;\n\nint calcDiffSum(int table[3][3]) {\n    int sum = 0;\n    \n    for(int row = 0; row < 3; row++) {\n        for(int col = 0; col < 3; col++) {\n            if(table[row][col] != 0) {\n                sum += abs((table[row][col] - 1) / 3 - row) + abs((table[row][col] - 1) % 3 - col);\n            }\n        }\n    }\n    return sum;\n}\n\nint zeroLoc(int table[3][3]) {\n    int zero_loc;\n    \n    for(int i = 0; i < 3; i++) {\n        for(int k = 0; k < 3; k++) {\n            if(table[i][k] == 0) {\n                zero_loc = 10 * i + k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nvoid recursive(int table[3][3], int max_depth, int count, int pre_loc, int zero_loc) {\n    int diffSum = calcDiffSum(table);\n    if(count == max_depth && diffSum == 0) {\n        minimum = max_depth;\n        return;\n    }\n    \n    if(minimum != -1) return;\n    \n    int next_table[4][3][3], tmp_row, tmp_col, pre_row, pre_col;\n    int dif1, dif2, dif3, dif4;\n    \n    switch(zero_loc) {\n        case 0:\n            for(int a = 0; a < 2; a++) {\n                for(int b = 0; b < 3; b++) {\n                    for(int c = 0;  c < 3; c++) {\n                        next_table[a][b][c] = table[b][c];\n                    }\n                }\n            }\n            if(pre_loc != 1) {\n                if((table[0][1] - 1) % 3 == 0) {\n                    dif1 = diffSum - 1;\n                }else {\n                    dif1 = diffSum + 1;\n                }\n                swap(next_table[0][0][0], next_table[0][0][1]);\n                if(count < max_depth && dif1 <= max_depth - count) {\n                    recursive(next_table[0], max_depth, count + 1, zero_loc, 1);\n                }\n            }\n            if(pre_loc != 10) {\n                if((table[1][0] - 1) / 3 == 0) {\n                    dif2 = diffSum - 1;\n                }else {\n                    dif2 = diffSum + 1;\n                }\n                swap(next_table[1][0][0], next_table[1][1][0]);\n                if(count < max_depth && dif2 <= max_depth - count) {\n                    recursive(next_table[1], max_depth, count + 1, zero_loc, 10);\n                }\n            }\n            break;\n            \n        case 1:\n            for(int a = 0; a < 3; a++) {\n                for(int b = 0; b < 3; b++) {\n                    for(int c = 0; c < 3; c++) {\n                        next_table[a][b][c] = table[b][c];\n                    }\n                }\n            }\n            \n            if(pre_loc != 0) {\n                if((table[0][0] - 1) % 3 >= 1) {\n                    dif1 = diffSum - 1;\n                }else {\n                    dif1 = diffSum + 1;\n                }\n                swap(next_table[0][0][1], next_table[0][0][0]);\n                if(count < max_depth && dif1 <= max_depth - count) {\n                    recursive(next_table[0], max_depth, count + 1, zero_loc, 0);\n                }\n            }\n            if(pre_loc != 11) {\n                if((table[1][1] - 1) / 3 == 0) {\n                    dif2 = diffSum - 1;\n                }else {\n                    dif2 = diffSum + 1;\n                }\n                swap(next_table[1][0][1], next_table[1][1][1]);\n                if(count < max_depth && dif2 <= max_depth - count) {\n                    recursive(next_table[1], max_depth, count + 1, zero_loc, 11);\n                }\n            }\n            if(pre_loc != 2) {\n                if((table[0][2] - 1) % 3 <= 1) {\n                    dif3 = diffSum - 1;\n                }else {\n                    dif3 = diffSum + 1;\n                }\n                \n                swap(next_table[2][0][1], next_table[2][0][2]);\n                if(count < max_depth && dif3 <= max_depth - count) {\n                    recursive(next_table[2], max_depth, count + 1, zero_loc, 2);\n                }\n            }\n            break;\n        \n        case 2:\n            for(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)%3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 0){\n\t\t\tif((table[0][0]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,0);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 11:\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)%3>=1){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)/3<=1){\n\t\t\t\tdif4 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif4 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tif(count < max_depth && dif4 <= max_depth-count){\n\t\t\t\trecursive(next_table[3],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 2){\n\t\t\tif((table[0][2]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,2);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 20:\n\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 21:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)%3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)/3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 22:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t}\n}\n\n\nvoid func(int table[3][3],int max_depth){\n\twhile(minimum == -1){\n\t\trecursive(table,max_depth,0,-1,zeroLoc(table));\n\t\tmax_depth += 2;\n\t}\n}\n\n\nint main(){\n\n    int table[3][3],start_count;\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n    start_count = calcDiffSum(table);\n\n    func(table,start_count);\n\n    printf(\"%d\\n\",minimum);\n\n    return 0;\n}\n\n    \n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// AC\n// ??????????????????????????????????????????AC??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 40;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\nint limit;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nbool bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return true;\n    }\n    if (ms[in] || limit < i + getAllMD(in)) {\n        return false;\n    }\n\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        if(bfs(i+1)) return true;\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n    return false;\n}\n\nstring iterative_deepening()\n{\n    limit = getAllMD(in);\n    for ( ; limit <= INF; limit++) {\n        if (bfs(0)) {\n            return in.path;\n        }\n    }\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    string ans = iterative_deepening();\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n \nstruct Puzzle {\n  int f[N*N];\n  int space;\n  string path;\n \n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i < N*N; i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n \nbool isTarget(Puzzle p){\n  for(int i=0;i<N*N;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n \n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n    V[v]=true;\n    v.path+=dir[r];\n    Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n \nint main()\n{\n  Puzzle in;\n \n  for(int i=0;i<N*N;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N*N;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define N 9\n\nint ans[N];\nint cur[N];\nint anspos[N];\nint movepos[4] = {-3, 1, 3, -1};\n\n// int trace[1000][N];\nint ti=0;\n\nint checkAns() {\n  for (int i = 0; i < N; i++) {\n    if (ans[i] != cur[i]) return 0;\n  }\n  return 1;\n}\n\nint calcEst() {\n  int total = 0, t;\n  for (int i = 0; i < N; i++) {\n    t = (i % 3) - (anspos[cur[i]] % 3);\n    if (t >= 0)\n      total += t;\n    else\n      total -= t;\n\n    t = (i / 3) - (anspos[cur[i]] / 3);\n    if (t >= 0)\n      total += t;\n    else\n      total -= t;\n  }\n  return total;\n}\n\nint dfs(int x, int px,int lim) {\n  int res = -1, minres = -1;\n\n  int mark[N];\n\n  if (checkAns()) return 0;\n  if (lim == 0) return -1;\n  if (calcEst() > lim) return -1;\nti++;\n  for (int i = 0; i < 4; i++) {\n    if (x + movepos[i]==px)continue;\n    if ((x%3==0&&movepos[i]==-1)||(x%3==2&&movepos[i]==1)) continue;\n    if (x + movepos[i] >= N || x +movepos[i] < 0) continue;\n    swap(cur[x], cur[x + movepos[i]]);\n    res = dfs(x + movepos[i],x, lim - 1);\n    if (res != -1) {\n      // return res+1;\n      if (minres == -1){\n\n        minres = res + 1;\n                // for (int i = 0; i < N; i++) trace[ti][i] = cur[i];\n      }\n\n      else {\n        minres = min(minres, res + 1);\n        // for (int i = 0; i < N; i++) trace[ti][i] = cur[i];\n      }\n    }\n    swap(cur[x], cur[x + movepos[i]]);\n  }\n\n\nti--;\n  return minres;\n}\n\nint main() {\n  int x, lim = 0, res;\n\n  for (int i = 0; i < N; i++) ans[i] = i + 1;\n  ans[N - 1] = 0;\n  for (int i = 0; i < N; i++) anspos[i] = i - 1;\n  anspos[0] = N - 1;\n\n  for (int i = 0; i < N; i++) {\n    cin >> cur[i];\n    if (cur[i] == 0) x = i;\n  }\n\n  while (true) {\n    res = dfs(x,x, lim);\n    if (res >= 0) break;\n    lim++;\n  }\n//           for (int i = 0; i < res+2; i++) {\n//             for (int j = 0; j < N;j++){ cout << trace[i][j]<<\" \" ;if (j%3==2)cout <<endl;}\n// cout <<\"----------\" <<endl;\n//           }\n\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????Â¨?????????24????????Â±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nint getAllMD(Puzzle p)\n{\n\tint dist = 0;\n\tint x, y;\n\tint ux, uy;\n\tfor (int i = 0; i < N2; i++) {\n\t\tx = p.f[i] / N;\n\t\ty = p.f[i] % N;\n\t\tux = i / N;\n\t\tuy = i % N;\n\t\tdist += abs(x - ux) + abs(y - uy);\n\t}\n\treturn dist;\n}\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++) if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  //cout<<ans<<endl;\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    //cout<<x<<endl;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(p[i][j]==0) zy=i,zx=j;\n    //cout<<zy<<\" \"<<zx<<endl;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      //cout<<t<<endl;\n      if(!m.count(t)){\n\tm[t]=m[x]+1;\n\tq.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n#define N1 3\n#define N2 9\n#define LIMITMAX 100\n//#define false 0\n//#define true 1\n\nstruct PUZZLE\n{\n    int f[N2], kuuhaku, MD; /*ãã³ããã¿ã³è·é¢*/\n                            //int cost;\n};\n\nstatic const int dx_123[4] = {0, -1, 0, 1};         //ï¼æ¹å\nstatic const int dy_123[4] = {1, 0, -1, 0};         //ï¼æ¹å\nstatic const char houkou[4] = {'r', 'u', 'l', 'd'}; //å³:right,ãä¸:up,ãå·¦:left,ãä¸:down\n\nint ManhattanDistance[N2][N2];\nPUZZLE jyoutai;\nint limit; //æ·±ãã®limit\nint miti[LIMITMAX];\n\nint GetallManhattanDistance(PUZZLE);\nbool dfs(int, int);\n//int max(int, int);\n//int min(int, int);\nstring iterative_deepning(PUZZLE); //åå¾©æ·±å\n\nint main()\n{\n\n    int i, j, k;\n    PUZZLE in;\n\n    for (i = 0; i < N2; i++)\n    {\n        for (j = 0; j < N2; j++)\n        {\n            ManhattanDistance[i][j] = abs(i / N1 - j / N1) + abs(i % N1 - j % N1);\n        }\n    }\n\n    for (i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.kuuhaku = i;\n        }\n    }\n\n    string kotae = iterative_deepning(in);\n\n    cout << kotae.size();\n    cout << endl;\n\n    return 0;\n}\n\n/*\n  void  swap(int *a , int *b){\n  int *tmp;\n  \n  tmp = a;\n  a = b ;\n  b = tmp;\n  \n  }\n*/\nint GetallManhattanDistance(PUZZLE p)\n{ //å¨ã¦ã®ãã³ããã¿ã³è·é¢ãåå¾ãã\n\n    int goukei = 0;\n    int i, j, k;\n\n    for (i = 0; i < N2; i++)\n    {\n        if (p.f[i] == N2)\n            continue;\n        goukei += ManhattanDistance[i][p.f[i] - 1];\n    }\n\n    return goukei;\n}\n\nbool dfs(int depth, int prev)\n{\n\n    int i, j, k;\n    int r;\n    int sx, sy;\n    PUZZLE tmp;\n    int tx, ty;\n\n    if (jyoutai.MD == 0)\n        return true;\n    //ç¾å¨ã®æ·±ãã«ãã¥ã¼ãªã¹ãã£ãã¯ãè¶³ãã¦å¶éãè¶ãããæãåã\n\n    if (depth + jyoutai.MD > limit)\n        return false;\n\n    sx = jyoutai.kuuhaku / N1;\n    sy = jyoutai.kuuhaku % N1;\n\n    for (r = 0; r < 4; r++)\n    {\n        tx = sx + dx_123[r];\n        ty = sy + dy_123[r];\n\n        if (tx < 0 || tx >= N1 || ty < 0 || ty >= N1)\n            continue;\n        if (max(prev, r) - min(prev, r) == 2)\n            continue;\n        tmp = jyoutai;\n        //ãã³ããã¿ã³è·é¢ã®å·®åãè¨ç®ãã¤ã¤ããã¼ã¹ãã¹ã¯ãã\n        jyoutai.MD -= ManhattanDistance[tx * N1 + ty][jyoutai.f[tx * N1 + ty] - 1];\n        jyoutai.MD += ManhattanDistance[sx * N1 + sy][jyoutai.f[tx * N1 + ty] - 1];\n        swap(jyoutai.f[tx * N1 + ty], jyoutai.f[sx * N1 + sy]);\n        jyoutai.kuuhaku = tx * N1 + ty;\n        if (dfs(depth + 1, r))\n        {\n            miti[depth] = r;\n            return true;\n        }\n        jyoutai = tmp;\n    }\n\n    return false;\n}\n/*\n  int max(int a, int b){\n  if(a<b) return b;\n  return a;\n  }\n\n  int min(int a, int b){\n  if(a<b) return a;\n  return b;\n  }\n*/\n\nstring iterative_deepning(PUZZLE in)\n{ //åå¾©æ·±å\n\n    int i, j, k;\n    //string  kotae = \"\";\n    //char kotae2[] = \"unsolvable\";\n\n    in.MD = GetallManhattanDistance(in); //åæã®ãã³ããã¿ã³è·é¢\n\n    for (limit = in.MD; limit <= LIMITMAX; limit++)\n    {\n        jyoutai = in;\n        if (dfs(0, -100))\n        {\n            string kotae = \"\";\n            for (i = 0; i < limit; i++)\n                kotae += houkou[miti[i]];\n            return kotae;\n        }\n    }\n\n    return \"ã§ãã¾ããã§ãã\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nset<int> dp;\n\nclass eightPuzzle {\n public:\n    int table[3][3];\n    int x, y;\n};\n\nint UP = 0, LEFT = 1, RIGHT = 2, DOWN = 3;\neightPuzzle move(eightPuzzle p, int dir) {\n    eightPuzzle newp;\n    for (int i = 0; i < 3; i++) {\n        memcpy(newp.table[i], p.table[i], sizeof(p.table[i]));\n    }\n    newp.x = p.x;\n    newp.y = p.y;\n\n    if (dir == UP && newp.y + 1 < 3) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y + 1][newp.x]);\n        newp.y++;\n    } else if (dir == LEFT && newp.x + 1 < 3) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y][newp.x + 1]);\n        newp.x++;\n    } else if (dir == RIGHT && newp.x - 1 >= 0) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y][newp.x - 1]);\n        newp.x--;\n    } else if (dir == DOWN && newp.y - 1 >= 0) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y - 1][newp.x]);\n        newp.y--;\n    }\n    return newp;\n}\n\n// 8ããºã«ãããã·ã¥åããé¢æ°\nint eightHash(eightPuzzle p) {\n    int ret = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            ret += p.table[i][j] * pow(10, 3 * i + j);\n        }\n    }\n    return ret;\n}\n\n// ã´ã¼ã«ã«å°éããããå¤å®ãã\nbool goal(eightPuzzle p) {\n    bool flag = true;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (p.table[i][j] != (3 * i + j + 1) % 9) flag = false;\n            if (!flag) break;\n        }\n        if (!flag) break;\n    }\n    return flag;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    eightPuzzle p;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> p.table[i][j];\n            if (p.table[i][j] == 0) {\n                p.x = j;\n                p.y = i;\n            }\n        }\n    }\n    if (goal(p)) {\n        cout << 0 << endl;\n        return 0;\n    }\n    int ehash = eightHash(p);\n    dp.insert(ehash);\n    queue<pair<eightPuzzle, int>> q;\n    q.push(make_pair(p, 0));\n    while (true) {\n        int cnt;\n        eightPuzzle ep;\n        tie(ep, cnt) = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            eightPuzzle np = move(ep, i);\n            if (goal(np)) {\n                cout << cnt + 1 << endl;\n                return 0;\n            }\n            int h = eightHash(np);\n            if (dp.find(h) == dp.end()) {\n                q.push(make_pair(np, cnt + 1));\n                dp.insert(h);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\nint i,j;;\n//?Â§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define PER(i,n) for(int i=n-1;i>=0;--i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9+5)\n#define INFLL ((LL)4e18)\n#define ALL(x) (x).begin(),(x).end()\n#define BIT(x) (1LL << (x))\n#define SIZE 3\nusing namespace std;\n\nclass board{\npublic:\n\tvector<vector<int>> data;\n\tint ncost;\n\tint hcost;\n\tPII zpoint;\n\n\tint culonecost(int i, int j){\n\t\tif(data[i][j]==0){\n\t\t\treturn abs(SIZE-1-i) + abs(SIZE-1-j);\n\t\t}\n\t\tint x = (data[i][j]-1)%SIZE;\n\t\tint y = (data[i][j]-1)/SIZE;\n\t\treturn abs(i-y) + abs(j-x);\n\t}\n\n\tvoid setup(){\n\t\thcost = 0;\n\t\tREP(i, SIZE){\n\t\t\tREP(j, SIZE){\n\t\t\t\thcost+=culonecost(i, j);\n\t\t\t\tif(data[i][j]==0){\n\t\t\t\t\tzpoint=PII(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tboard(vector<vector<int>> d){\n\t\tREP(i, SIZE){\n\t\t\tREP(j, SIZE){\n\t\t\t\tdata[i][j]=d[i][j];\n\t\t\t}\n\t\t}\n\t\thcost = 0;\n\t\tsetup();\n\t}\n\n\tboard(){\n\t\tdata.resize(SIZE, vector<int>(SIZE));\n\t}\n\n\tvoid swap(int i, int j, int k, int l){\n\t\thcost -= culonecost(i, j);\n\t\thcost -= culonecost(k, l);\n\t\tstd::swap(data[i][j], data[k][l]);\n\t\thcost += culonecost(i, j);\n\t\thcost += culonecost(k, l);\n\t\tif(data[i][j]==0){\n\t\t\tzpoint=PII(i, j);\n\t\t}else{\n\t\t\tzpoint=PII(k, l);\n\t\t}\n\t}\n\n\tbool onboard(int i, int j){\n\t\treturn 0<=i&&0<=j&&i<SIZE&&j<SIZE;\n\t}\n\t\n};\n\nint mx[]={1, 0, -1, 0}, my[]={0, 1, 0, -1};\n\nbool func(board &boa, int time, int lx, int ly){\n\tif(boa.hcost - boa.culonecost(boa.zpoint.first, boa.zpoint.second) > time * 1)return false;\n\tif(boa.hcost==0)return true;\n\tbool res = false;\n\tREP(i, 4){\n\t\tint y = boa.zpoint.first;\n\t\tint x = boa.zpoint.second;\n\t\tint ny = y + my[i];\n\t\tint nx = x + mx[i];\n\t\tif(lx==nx&&ly==ny)continue;\n\t\tif(!boa.onboard(ny, nx))continue;\n\t\tboa.swap(y, x, ny, nx);\n\t\tres |= func(boa, time-1, x, y);\n\t\tboa.swap(y, x, ny, nx);\n\t\tif(res)return true;\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tboard boa;\n\tREP(i, SIZE)\n\t\tREP(j, SIZE)cin>>boa.data[i][j];\n\tboa.setup();\n\tREP(i, 1000){\n\t\tif(func(boa, i, -1, -1)){\n\t\t\tcout << i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<unordered_set>\nusing namespace std;\n\nconst int D_x[4] = { 0,1,0,-1 };\nconst int D_y[4] = { 1,0,-1,0 };\nconst int ANS = 123456780;\n\nvoid setNum(int puzzle[3][3],int n) {\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\tpuzzle[i][j] = n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t}\n}\n\nint getNum(int puzzle[3][3]) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tres *= 10;\n\t\t\tres += puzzle[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid find_0(int puzzle[3][3], int& x, int& y) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (puzzle[i][j] == 0) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int puzzle[3][3]) {\n\tqueue<int> q;\n\tunordered_set<int> table;\n\tint cnt = 1;\n\n\tq.push(getNum(puzzle));\n\tif (q.front() == ANS)return 0;\n\twhile (true) {\n\t\tint s = q.size();\n\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint x, y;\n\t\t\tfind_0(puzzle, x, y);\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint X = x + D_x[j];\n\t\t\t\tint Y = y + D_y[j];\n\t\t\t\tif (X < 0 || Y < 0 || X >= 3 || y >= 3)continue;\n\t\t\t\tsetNum(puzzle, q.front());\n\t\t\t\tswap(puzzle[y][x], puzzle[Y][X]);\n\n\t\t\t\tint n = getNum(puzzle);\n\t\t\t\tif (n == ANS) {\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t\tif (table.count(n) == 0) {\n\t\t\t\t\ttable.insert(n);\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcnt++;\n\t}\n}\n\nint main() {\n\tint puzzle[3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> puzzle[i][j];\n\t\t}\n\t}\n\n\tcout << solve(puzzle) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, -1, 0, 1 };\nconst char dir[4] = { 'u', 'l', 'd', 'r' };\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????Â¨?????????24????????Â±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 30;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<string>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstatic const int dx[4] = {-1, 0, 1, 0}; //??Â£??\\???{}\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n\tint p[N2], space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p1) const { //????????Â§?????????\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (p[i] == p1.p[i]) continue;\n\t\t\treturn p[i] > p1.p[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle u) {\n\tfor (int i = 0; i < N2; i++) {\n\t\tif (u.p[i] != i + 1) return false; \n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V; //????????Â´???Puzzle??Â§????????????????????Â§ < ????????????????????Â¨????????????\n\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u)) return u.path; //????????????????????????????????Â§??????\n\t\tint sx = u.space / N; //space??????\n\t\tint sy = u.space % N; //space??????\n\t\tfor (int r = 0; r < 4; r++)\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.p[u.space], v.p[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\n\nint main() {\n\tPuzzle in;\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.p[i];\n\t\tif (!in.p[i]) {\n\t\t\tin.p[i] = N2; //isTarget?????????\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n//    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  //cout<<ans<<endl;\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    //cout<<x<<endl;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(p[i][j]==0) zy=i,zx=j;\n    //cout<<zy<<\" \"<<zx<<endl;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      //cout<<t<<endl;\n      if(!m.count(t)){\n\tm[t]=m[x]+1;\n\tq.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 3\n#define MAX2 9\n\nusing namespace std;\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n  int i;\n    for(i = 0; i < MAX2; i++){\n      if( f[i] == p.f[i] ){\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstring bfs(Puzzle);\nbool isTarget(Puzzle);\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for(i = 0; i < MAX2; i++){\n    if( p.f[i] != (i+1) ){\n      return false;\n    }\n  }\n  return true;\n}//end of isTarget func\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i = 0; i < MAX2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}//end of main func\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  int r,tx,ty;\n  int sx,sy;\n  int tmp;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ){\n      return u.path;\n    }\n    sx = u.space / MAX;\n    sy = u.space % MAX;\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX){\n        continue;\n      }\n      v = u;\n      /*swap*/\n      tmp = v.f[u.space];\n      v.f[u.space] = v.f[tx * MAX + ty];\n      v.f[tx * MAX + ty] = tmp;\n\n      v.space = tx * MAX + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator <(const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u=Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n    \n    \n    \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans[3][3] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (f[i][j] != ans[i][j])\n                return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int f[3][3], int x, int y, int d, int l) {\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> f[i][j];\n            if (f[i][j] == 0) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 100; ++i) {\n        if ((res = dfs(f, x, y, 0, i)) >= 0) {\n            break;\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<algorithm>\nusing namespace std;\nstruct Status{\n        int a[3][3];\n        int c,i,j;\n        bool isTarget(){\n                for(int i=0;i<8;i++){\n                        if(a[i/3][i%3]!=i+1) return false;\n                }\n                return true;\n        }\n};\n\nbool operator< (const Status &s, const Status &t){\n        for(int i=0;i<9;i++){\n                if(s.a[i/3][i%3]==t.a[i/3][i%3]) continue;\n                return s.a[i/3][i%3] < t.a[i/3][i%3];\n        }\n        return false;\n}\n\nqueue<Status> que;\nset<Status> visited;\n\n\nint solve(){\n        while(1){\n                Status s = que.front();que.pop();\n                if(visited.find(s)!=visited.end()) continue;\n                if(s.isTarget()) return s.c;\n                visited.insert(s);\n                s.c++;\n                if(s.i!=0) {\n                        swap(s.a[s.i][s.j], s.a[s.i-1][s.j]);\n                        s.i = s.i-1;\n                        que.push(s);\n                        s.i = s.i+1;\n                        swap(s.a[s.i][s.j], s.a[s.i-1][s.j]);\n                }\n                if(s.j!=0) {\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j-1]);\n                        s.j = s.j-1;\n                        que.push(s);\n                        s.j = s.j+1;\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j-1]);\n                }\n                if(s.i!=2) {\n                        swap(s.a[s.i][s.j], s.a[s.i+1][s.j]);\n                        s.i = s.i+1;\n                        que.push(s);\n                        s.i = s.i-1;\n                        swap(s.a[s.i][s.j], s.a[s.i+1][s.j]);\n                }\n                if(s.j!=2) {\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j+1]);\n                        s.j = s.j+1;\n                        que.push(s);\n                        s.j = s.j-1;\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j+1]);\n                }\n        }\n}\nint main(){\n        Status s;\n        s.c=0;\n        for(int i=0;i<9;i++) {\n                cin>>s.a[i/3][i%3];\n                if(s.a[i/3][i%3]==0){\n                        s.i=i/3;\n                        s.j=i%3;\n                }\n        }\n        que.push(s);\n\n        cout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* \n * I used # 1687007 as a refference. Thx. \n */\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\n//const int PATTERN = 181440;       // NG; 9! / 2;\nconst int PATTERN = 362880;         // OK; 9!\nconst Board GOAL = 0x123456780LL;\nconst int DX[] = { -1, 0, 1,  0 },\n          DY[] = {  0, 1, 0, -1 };\n\nint history[PATTERN];\nqueue<Board> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline Board swap(int numpos, int zeropos, Board board) {\n    long long num = (board >> (numpos * 4)) & 0xF;\n    return (board | (num << zeropos * 4)) & ~(0xFLL << numpos * 4);\n}\n\ninline int check(Board newboad, Board board) {\n    int hash = change_number(newboad);\n    int direction = history[change_number(board)];\n    if (history[hash] == 0) {\n        q.push(newboad);\n        history[hash] = direction + (direction > 0 ? 1 : -1);\n    }\n    else if ((history[hash] > 0 && direction < 0)\n            || (history[hash] < 0 && direction > 0)) {\n        return abs(history[hash]) + abs(direction) - 1;\n    }\n    return 0;\n}\n\nvoid print(Board b) {\n    for (int i = N - 1; i >= 0; --i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = N - 1, num; i >= 0; --i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i * 4);\n    }\n//    print(board);\n//    print(GOAL);\n\n    int count = 0;\n    if (board == GOAL)\n        goto END;\n\n    history[change_number(board)] =  1;     // forward\n    history[change_number(GOAL)]  = -1;     // backward\n\n    q.push(board);\n    q.push(GOAL);\n    while (!q.empty()) {\n        board = q.front();\n        q.pop();\n\n        int zeropos = -1;\n        while (++zeropos < N)\n            if (((board >> (zeropos * 4)) & 0xF) == 0)\n                break;\n\n        int zx = zeropos % 3, zy = zeropos / 3;\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + DX[i], ny = zy + DY[i];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n                continue;\n            int numpos = nx + ny * 3;\n            Board newboard = swap(numpos, zeropos, board);\n            if ((count = check(newboard, board)))\n                goto END;\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                if (tmp == ans_str) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h0();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tmap<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const char dir[4] = {'u','l','d','r'};\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\n \nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n \nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n \nint main() {\n  Puzzle in;\n \n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.f[i]=N2;\n      in.space = i;\n    }\n  }\n \n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include<algorithm>\nusing namespace std;\n\nint d_x[4] = { -1,0,1,0 };\nint d_y[4] = { 0,1,0,-1 };\n\nint t[3][3];\nint px, py, level=0;\n\nint countpath() {\n\tint ret=0;\n\tint tmp;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (t[i][j] != 0) {\n\t\t\t\ttmp = t[i][j] - 1;\n\t\t\t\tret += abs(tmp / 3 - i) + abs(tmp % 3 - j);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool check(int depth, int pre) {\n\tint w = countpath();\n\tif (w + depth > level) return false;\n\tif (w == 0)return true;\n\tint dx, dy;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) != 2) {\n\t\t\tdx = px + d_x[i];\n\t\t\tdy = py + d_y[i];\n\t\t\tif (dx < 0 || dx == 3 || dy < 0 || dy == 3) continue;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t\tif (check(depth + 1, i)) return true;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t}\n\n\t}\n}\n\nvoid solution() {\n\tfor (level = 0;; level++) {\n\t\tif (check(0, 9)) {\n\t\t\tcout << level << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> t[i][j];\n\t\t\tif (t[i][j] == 0) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans[3][3] =\n{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (f[i][j] != ans[i][j])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l) {\n\tif (match(f))\n\t\treturn d;\n\tif (d > l)\n\t\treturn -1;\n\tfor (int i = 0, res; i < 4; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n\t\t\tcontinue;\n\t\tf[y][x] = f[ny][nx];\n\t\tf[ny][nx] = 0;\n\t\tif ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n\t\t\treturn res;\n\t\tf[ny][nx] = f[y][x];\n\t\tf[y][x] = 0;\n\t}\n\treturn -1;\n}\n\nint main() {\n\tint f[3][3], x, y;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tcin >> f[i][j];\n\t\t\tif (f[i][j] == 0) {\n\t\t\t\ty = i;\n\t\t\t\tx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tint res;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tif ((res = dfs(f, x, y, -1, 0, i)) >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint max;\n\tint cnt = 0;\n\n\tint f(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint c = a[i][j];\n\t\t\t\tif (c == 0)\n\t\t\t\t\tc = size * size - 1;\n\t\t\t\telse\n\t\t\t\t\tc--;\n\t\t\t\tl += abs(i - c / 3) + abs(j - c % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tmax = f(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\n\tint solver() {\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n\t\t\t//a.print();\n\t\t\tint dis = f(a.b);\n\t\t\tif (dis > max * 2.1 - a.cnt)\n\t\t\t\tcontinue;\n\t\t\t//out(dis, \"\\n\");\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!dis)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef long long ll;\n\nstruct P{\n  int x,y;\n  P(int x,int y) : x(x),y(y) {}\n};\n\nll getValue(vector<int> &v){\n  ll res = 0LL;\n  for(auto x : v){\n    res *= 10LL;\n    res += x;\n  }\n  return res;\n}\n\nvector<int> getState(ll x){\n  vector<int> res;\n  while(x > 0LL){\n    res.push_back(x%10LL);\n    x /= 10LL;\n  }\n  if(res.size() == 8){ res.push_back(0); }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nP getPos(int x){\n  x--;\n  return P(x%3,x/3);\n}\n\nint getMD(ll x){\n  vector<int> v = getState(x);\n  int res = 0;\n  for(int i = 0 ; i < 9 ; i++){\n    if(v[i] == 0){ continue; }\n    P tp = getPos(v[i]);\n    res += abs(i%3-tp.x) + abs(i/3-tp.y);\n  }\n  return res;\n}\n\nint LIMIT;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < 3 && 0 <= y && y < 3);\n}\n\nbool solve(int sp,ll st,int step,int prev){\n  int md = getMD(st);\n  if(md == 0){ return true; }\n  if(md + step > LIMIT){\n    return false;\n  }\n  int x = sp%3,y = sp/3;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i],ny = y + dy[i];\n    if(abs(i-prev) == 2){ continue; }\n    if(!inField(nx,ny)){ continue; }\n    vector<int> v = getState(st);\n    int nsp = ny*3 + nx;\n    swap(v[sp],v[nsp]);\n    if(solve(nsp,getValue(v),step+1,i)){\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int sp = -1;\n  vector<int> v(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> v[i];\n    if(v[i] == 0){ sp = i; }\n  }\n  ll st = getValue(v);\n  for(LIMIT = 0 ; LIMIT < 35 ; LIMIT++){\n    if(solve(sp,st,0,INF)){\n      cout << LIMIT << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap<string,int> mp;\n\nint dr[4]={-1,1,0,0},dc[4]={0,0,-1,1};\n\nvoid bfs()\n{\n    queue<string> q;\n    mp[\"123456780\"]=0;\n    q.push(\"123456780\");\n\n    while(!q.empty())\n    {\n        string s=q.front();q.pop();\n        //cout<<s<<\" \"<<mp[s]<<endl;\n        int idx;\n        for(idx=0;idx<s.length()&&s[idx]!='0';idx++);\n\n        int r=idx/3,c=idx%3;\n        for(int i=0;i<4;i++)\n        {\n            int rr=r+dr[i],cc=c+dc[i];\n\n            if(rr<0||rr>=3||cc<0||cc>=3) continue;\n\n            int idx1=rr*3+cc;\n            string s1=s;\n            swap(s1[idx],s1[idx1]);\n            if(mp.find(s1)==mp.end())\n            {\n                mp[s1]=mp[s]+1;\n                q.push(s1);\n            }\n        }\n    }\n}\n\nchar mat[3][3];\n\nint main()\n{\n    bfs();\n\n    string s;\n\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            char ch;\n            scanf(\"%c%c\",&mat[i][j],&ch);\n            s+=mat[i][j];\n        }\n    }\n\n    printf(\"%d\\n\",mp[s]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N > 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n        pos = st.find(\"0\");\n        Q.pop();\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            if (mp.count(tmp)) {\n                if (mp[tmp] == FLG) {\n                    continue;\n                } else if (mp[tmp] == GOAL) {\n                    return cnt + 1;\n                } else\n                    printf(\"ERROR: %d\\n\", __LINE__);\n            }\n            mp[tmp] = FLG;\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <set>\n#include <queue>\n\n\nusing namespace std;\n\nconst int N = 3;\n\nstruct Puzzle {\n    array<array<int, N>, N> board;\n    array<int, 2> empty;\n    int turn;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (board[i][j] != p.board[i][j])\n                    return board[i][j] < p.board[i][j];\n            }\n        }\n        return false;\n    }\n};\n\n\nvector<array<int, 2>> dir = {\n    {-1, 0}, // left\n    {0, -1}, // up\n    {1, 0},  // right\n    {0, 1},  // down\n};\n\nbool solved(const Puzzle& p) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x = i == 2 && j == 2 ? 0 : i * 3 + j + 1;\n            if (p.board[i][j] != x) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    Puzzle start;\n    start.turn = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x;\n            cin >> x;\n            if (x == 0) {\n                start.empty = {i, j};\n            }\n            start.board[i][j] = x;\n        }\n    }\n\n    Puzzle ans;\n    set<Puzzle> visited;\n    queue<Puzzle> Q;\n    Q.push(start);\n    while (!Q.empty()) {\n        auto u = Q.front();\n        Q.pop();\n        if (solved(u)) {\n            ans = u;\n            break;\n        }\n        for (auto& d : dir) {\n            auto tx = u.empty[0] + d[0];\n            auto ty = u.empty[1] + d[1];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            auto v = u;\n            swap(v.board[v.empty[0]][v.empty[1]], v.board[tx][ty]);\n            v.empty = {tx, ty};\n            if (visited.find(v) == visited.end()) {\n                ++v.turn;\n                visited.insert(v);\n                Q.push(v);\n            }\n        }\n    }\n    cout << ans.turn << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct P{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const P&p) const{\n    int i;\n    for(i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1, 0, 1, 0};\nstatic const int dy[4]={0, -1, 0, 1};\nstatic const char dir[4]={'u', 'l', 'd', 'r'};\n\nbool isT(P p){\n  int i;\n  for(i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n    return true;\n}\n\nstring bfs(P s){\n  queue<P> Q;\n  map<P, bool> V;\n  P u, v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  int sx, sy, tx, ty, r;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isT(u)) return u.path;\n    sx=u.space/N;\n    sy=u.space%N;\n    for(r=0;r<4;r++){\n      tx=sx+dx[r];\n      ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path+=dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return\"unsolvable\";\n}\n\nint main(){\n  P in;\n  int i;\n\n  for(i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 35\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????Â¨?????????24????????Â±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N >= 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n//        cout << st << \" \" << cnt << endl;\n        pos = st.find(\"0\");\n        Q.pop();\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            if (mp.count(tmp)) {\n                if (mp[tmp] == FLG) {\n                    continue;\n                } else if (mp[tmp] == GOAL) {\n                    return cnt + 1;\n                } else\n                    printf(\"ERROR: %d\\n\", __LINE__);\n            }\n            mp[tmp] = FLG;\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[st] = FLG; mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for (int i = 0; i < N2; i++)\n  if(p.f[i] != (i + 1)) return false;\n\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()){\n    u = Q.front(); Q.pop();\n    if (isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\nint main() {\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\nbool rec(string v,int c_index,int p_index,int step,int limit){\n  if(limit<step)return false;\n  if(v==ans)return true;\n  FOR(i,0,4){\n    if(c_index%3==0 && d[i]==-1)continue;\n    if((c_index+1)%3==0 && d[i]==1)continue;\n    if(c_index<=2 && d[i]==-3)continue;\n    if(6<=c_index && d[i]==3)continue;\n    int n_index = c_index+d[i];\n    if(n_index==p_index)continue;\n    string u = v;\n    swap(u[c_index],u[n_index]);\n    if(rec(u,n_index,c_index,step+1,limit))return true;\n  }\n  return false;  \n}\n\nint solve(){\n  int res = 0;\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  while(!rec(s,ind,-1,0,res))res++;\n  return res;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tbool operator <( const Puzzle p ) const\n\t{\n\t\tfor( int i = 0; i < N2; i++ ) {\n\t\t\tif( f[i] == p.f[i] ) continue;\n\t\t\treturn f[i] < p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget( Puzzle &u )\n{\n\tfor( int i = 0; i < N2; i++ ) {\n\t\tif( u.f[i] != i + 1 ) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tPuzzle s;\n\tfor( int i = 0; i < N2; i++ ) {\n\t\tcin >> s.f[i];\n\t\tif( s.f[i] == 0 ) {\n\t\t\ts.space = i;\n\t\t\ts.f[i] = N2;\n\t\t}\n\t}\n\n\tint dirh[] = { 0, 0, -1, 1 };\n\tint dirv[] = { -1, 1, 0, 0 };\n\tqueue<pair<Puzzle, int>> que;\n\tmap<Puzzle, int> m;\n\tint ans;\n\tque.push( make_pair( s, 0 ) );\n\tm[s] = 1;\n\twhile( !que.empty() ) {\n\t\tPuzzle u;\n\t\tint cnt;\n\t\ttie( u, cnt ) = que.front();\n\t\tque.pop();\n\t\tif( isTarget( u ) ) {\n\t\t\tans = cnt;\n\t\t\tbreak;\n\t\t}\n\t\tint sy = u.space / N;\n\t\tint sx = u.space % N;\n\t\tfor( int i = 0; i < 4; i++ ) {\n\t\t\tint nx = sx + dirh[i];\n\t\t\tint ny = sy + dirv[i];\n\t\t\tif( nx < 0 || N <= nx || ny < 0 || N <= ny ) continue;\n\t\t\tint ni = ny * N + nx;\n\t\t\tPuzzle v;\n\t\t\tv = u;\n\t\t\tswap( v.f[ni], v.f[v.space] );\n\t\t\tv.space = ni;\n\t\t\tif( m.find( v ) == m.end() ) {\n\t\t\t\tque.push( make_pair( v, cnt + 1 ) );\n\t\t\t\tm[v] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\n  int i,f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const{\n\n    for(i = 0;i < N2;i ++)\n      {\n\tif(f[i] == p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n \n \nint main(){\n\n  Puzzle in;\n\n  int i;\n\n  string ans;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      cin >> in.f[i];\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n  ans = bfs(in);\n\n  cout << ans.size() << endl;\n \n  return 0;\n}\n\nbool isTarget(Puzzle p){\n\n  int i;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      if(p.f[i] != (i + 1)) return false;\n    }\n  \n  return true;\n}\n \nstring bfs(Puzzle s){\n\n  int sx,sy,tx,ty,r;\n  \n  queue<Puzzle> Q;\n\n  map<Puzzle, bool> V;\n\n  Puzzle u, v;\n\n  s.path = \"\";\n\n  Q.push(s);\n\n  V[s] = true;\n \n  while(!Q.empty()){\n\n    u = Q.front();\n\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for(r = 0;r < 4;r ++)\n      {\n\ttx = sx + dx[r];\n\tty = sy + dy[r];\n\n\tif(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n       \n\tv = u;\n      \n\tswap(v.f[u.space], v.f[tx * N + ty]);\n      \n\tv.space = tx * N + ty;\n      \n\tif(!V[v]){\n\t  V[v] = true;\n\t  v.path += dir[r];\n\t  Q.push(v);\n\t}\n      }\n  }\n \n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle {\nint f[N2];\n\nint space;\nstring path;\nbool operator < (const Puzzle &p) const{\nfor (int i=0; i<N2; i++ ){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nbool isTarget (Puzzle p) {\nfor (int i = 0; i< N2; i++ )\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\nstring bfs (Puzzle s) {\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile (!Q.empty()){\nu = Q. front(); Q.pop();\nif (isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor (int r= 0; r< 4;r++ ){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif (tx<0 || ty <0 || tx >= N || ty >= N) continue;\n\nv=u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif (!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n\n\n}\n}\n}\n\n\nreturn \"unsolvable\";\n}\nint main(){\nPuzzle in;\nfor (int i = 0; i < N2; i++ ){\ncin >> in.f[i];\nif (in.f[i] == 0){\nin.f[i] = N2; // set space\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAXN 363000  //9!==326880\nstruct node\n{\n    int s[9];\n    int a;\n    int b;\n    int step;\n};\nint fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};//åå«å­å¨1--9çé¶ä¹å¼\nint dir[4][2]= {-1,0,1,0,0,-1,0,1};\nint aim=322561;//123456780å¯¹åºçhashå¼\nbool vis[MAXN];\nnode str,now,next;\n\nint cantor(const int *s)\n{\n    int sum=0;\n    for(int i=0; i<9; i++)\n    {\n        int num=0;\n        for(int j=0; j<i; j++)\n            if(s[j]>s[i])\n                num++;\n        sum+=(num*fac[i]);\n    }\n    return (sum+1);\n}\nbool bfs()\n{\n    memset(vis,0,sizeof(vis));\n    queue<node>q;\n    q.push(str);\n    vis[str.b]=1;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        int x=now.a/3;\n        int y=now.a%3;\n        for(int i=0; i<4; i++)\n        {\n            int tx=x+dir[i][0],ty=y+dir[i][1];\n            if(tx<0||tx>=3||ty<0||ty>=3)\n                continue;\n            next=now;\n            next.a=tx*3+ty;\n            next.s[now.a]=next.s[next.a];\n            next.s[next.a]=0;\n            next.b=cantor(next.s);\n            if(!vis[next.b])\n            {\n                vis[next.b]=1;\n                if(next.b==aim)\n                {\n                    return true;\n                }\n                next.step=now.step+1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\nchar sss[3];\nint main()\n{\n    char q[10];\n    for(int i=0; i<9; i++)\n    {\n        scanf(\"%s\",sss);\n        q[i]=sss[0];\n    }\n    int len=strlen(q);\n    int num=0;\n    for(int i=0; i<len; i++)\n    {\n        if(q[i]>='1'&&q[i]<='9')\n        {\n            str.s[num++]=q[i]-'0';\n        }\n        else if(q[i]=='0')\n        {\n            str.s[num]=0;\n            str.a=num++;\n        }\n    }\n    str.b=cantor(str.s);\n    if(str.b==aim)\n        printf(\"%d\\n\",0);\n    else if(bfs())\n        printf(\"%d\\n\",next.step+1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <fstream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=3; // N x N board\n\nstruct Node{\n    unsigned long long int id;  // hash key\n    int mat[N][N];              // to save the N x N board\n    int x0, y0;                 // location of the blank square\n    int cost;                   // minimum number of movements to reach the destination Node\n    int level;                  // no. of movements so far to reach this Node\n    Node(){}                    // construction function #1\n    Node(int matrix_[N][N], int x0_, int y0_, int cost_, int level_);    // construction function #2\n};\n\nint calCostUtil(int mat[N][N], int i, int j) {\n    int cost  = 0;\n    if (mat[i][j] != 0) {\n        int x1 = (int) (mat[i][j]-1) / N;\n        int y1 = (int) (mat[i][j]-1) - N*x1;\n        cost = abs(i-x1) + abs(j-y1);\n    }\n    return cost;\n}\n\nint calCost(int mat[N][N]) {\n    int cost = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j=0; j<N; j++) {\n            if (mat[i][j] != 0) {\n                cost += calCostUtil(mat, i, j);\n            }\n        }\n    }\n    return cost;\n}\n\n//Node getInput(string fn) {\n//    ifstream infile(fn);\n//    int tmp, x0, y0;\n//    int mat[N][N];\n//    for (int i = 0; i < N; i++) {\n//        for (int j = 0; j < N; j++) {\n//            infile >> tmp;\n//            mat[i][j] = tmp;\n//            if (tmp==0) {x0=i; y0=j;}\n//        }\n//    }\n//    Node root(mat, x0, y0, calCost(mat), 0);\n//    infile.close();\n//    return root;\n//}\n\nNode getInput() {\n    int tmp, x0, y0;\n    int mat[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> tmp;\n            mat[i][j] = tmp;\n            if (tmp==0) {x0=i; y0=j;}\n        }\n    }\n    Node root(mat, x0, y0, calCost(mat), 0);\n    return root;\n}\n\nvoid printNode(Node nd) {\n    for (int i=0; i<N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << nd.mat[i][j] <<\"  \";\n        }\n        cout << \"\\n\";\n    }\n    cout << \"(\" << nd.x0 << \", \" << nd.y0 << \")\\n\";\n    cout << \"cost: \" << nd.cost << \"\\n\";\n    cout << \"level: \" << nd.level << \"\\n\";\n}\n\nunsigned long long int genHashKey(int mat[N][N]) {\n    unsigned long long int tmp = 0;\n    for (int i=0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            tmp += mat[i][j]*pow(10, i*N+j);\n        }\n    }\n    return tmp;\n}\n\nbool isMoveValid(int x0, int y0, int mrow, int mcol) {\n    if ((x0+mrow>=0) && (x0+mrow<N) && (y0+mcol>=0) && (y0+mcol<N)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n//              up      down    left    right\nint mrow[] = {  1,      -1,     0,      0       };\nint mcol[] = {  0,      0,      -1,     1       };\n\n// flag\nbool isSolved = false;\nset<unsigned long long int> mylist;     // save all hash keys of nodes visited\n\nbool solveUtil(Node* node, int limit) {\n    if (!isSolved) {\n        // if destination node is reached: print current node's level\n        if (node->cost==0) {\n            cout << node->level << \"\\n\";  // minimum no. of steps to reach the goal\n            isSolved = true;\n            return true;\n        }\n\n        // else: visit children nodes (depth-first search)\n        for (int imove = 0; imove < 4; imove++) {\n            if(isMoveValid(node->x0, node->y0, mrow[imove], mcol[imove])) {\n                int x0_new = node->x0 + mrow[imove];\n                int y0_new = node->y0 + mcol[imove];\n                int mat[N][N];\n                memcpy(mat, node->mat, sizeof(mat));\n                swap(mat[node->x0][node->y0], mat[x0_new][y0_new]);\n                int cost = calCost(mat);\n                // check whether depth limit is reached\n                if (node->level + cost <= limit) {\n                    //check whether the node is visited before\n                    unsigned long long int id = genHashKey(mat);\n                    if (mylist.find(id)==mylist.end()) {\n                        Node newNode(mat, x0_new, y0_new, cost, node->level+1);\n                        mylist.insert(id);\n                        solveUtil(&newNode, limit);\n                        // if cannot reach the goal -> erase the node from list for backtracking\n                        mylist.erase(id);\n                    }\n                }\n            }\n        }\n\n        // after visiting all children nodes but the goal has not reached\n        return false;\n    }\n}\n\nvoid solve(Node* root, int depth_limit) {\n    // iterative deepening DFS\n    for (int i = root->cost; i < depth_limit; i++) {\n        mylist.clear();\n        mylist.insert(genHashKey(root->mat));\n        if (solveUtil(root, i)) {return;};\n    }\n}\n\nint main() {\n    //Node root = getInput(\"in.txt\");  // root node\n    Node root = getInput();  // root node\n    solve(&root, 45);\n    return 0;\n}\n\nNode::Node(int matrix_[N][N], int x0_, int y0_, int cost_, int level_) {\n    memcpy(mat, matrix_, sizeof(mat));\n    x0 = x0_;  y0 = y0_;\n    cost = cost_;\n    level = level_;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAXN 363000  //9!==326880\nstruct node\n{\n    int s[9];\n    int a;\n    int b;\n    int step;\n};\nint fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};//åå«å­å¨1--9çé¶ä¹å¼\nint dir[4][2]= {-1,0,1,0,0,-1,0,1};\nint aim=322561;//123456780å¯¹åºçhashå¼\nbool vis[MAXN];\nnode str,now,next;\nint cantor(const int *s)\n{\n    int sum=0;\n    for(int i=0; i<9; i++)\n    {\n        int num=0;\n        for(int j=0; j<i; j++)\n            if(s[j]>s[i])\n                num++;\n        sum+=(num*fac[i]);\n    }\n    return (sum+1);\n}\nbool bfs()\n{\n    memset(vis,0,sizeof(vis));\n    queue<node>q;\n    q.push(str);\n    vis[str.b]=1;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        int x=now.a/3;\n        int y=now.a%3;\n        for(int i=0; i<4; i++)\n        {\n            int tx=x+dir[i][0],ty=y+dir[i][1];\n            if(tx<0||tx>=3||ty<0||ty>=3)\n                continue;\n            next=now;\n            next.a=tx*3+ty;\n            next.s[now.a]=next.s[next.a];\n            next.s[next.a]=0;\n            next.b=cantor(next.s);\n            if(!vis[next.b])\n            {\n                vis[next.b]=1;\n                if(next.b==aim)\n                {\n                    return true;\n                }\n                next.step=now.step+1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\nchar sss[3];\nint main()\n{\n    char q[10];\n    for(int i=0; i<9; i++)\n    {\n        scanf(\"%s\",sss);\n        q[i]=sss[0];\n    }\n    int len=strlen(q);\n    int num=0;\n    for(int i=0; i<len; i++)\n    {\n        if(q[i]>='1'&&q[i]<='9')\n        {\n            str.s[num++]=q[i]-'0';\n        }\n        else if(q[i]=='0')\n        {\n            str.s[num]=0;\n            str.a=num++;\n        }\n    }\n    str.b=cantor(str.s);\n    if(str.b==aim)\n        printf(\"%d\\n\",0);\n    else if(bfs())\n        printf(\"%d\\n\",next.step+1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nstruct state {\n    state(vector<int> vec, int z, int c, int n) : board {vec}, zero {z}, correct {c}, num {n} {};\n    vector<int> board;\n    int zero;\n    int correct;\n    int num;\n    void print(){\n        cout << \"board\" << endl;\n        for(int i = 0; i < 9; ++i){\n            cout << board[i] << ' ';\n            if(i%3 == 2){\n                cout << endl;\n            }\n        }\n        cout << \"correct = \" << correct << \", zero = \" << zero << \", n = \" << num << endl;\n    }\n};\n\nmultiset<vector<int>> memo {};\n\nbool correct_pos(vector<int>& vec, int id){\n    return (id+1)%9 == vec[id];\n}\n\nvoid push_queue(queue<state>& states, state now, int pos){\n    if(pos >= 0 && pos < 9){\n        int nc = now.correct;\n        if(correct_pos(now.board, pos)){\n            --nc;\n        }\n        if(correct_pos(now.board, now.zero)){\n            --nc;\n        }\n        swap(now.board[pos], now.board[now.zero]);\n        if(correct_pos(now.board, pos)){\n            ++nc;\n        }\n        if(correct_pos(now.board, now.zero)){\n            ++nc;\n        }\n        bool pushed = memo.find(now.board) != memo.end();\n        if(pushed){\n        //    cout << \"already searched, pos = \" << pos << endl;\n            return;\n        } else {\n            memo.insert(now.board);\n        }\n        state next_st = state(vector<int>(now.board), pos, nc, now.num+1);\n        //cout << \"pushing\" << endl;\n        //next_st.print();\n        states.push(next_st);\n        swap(now.board[pos], now.board[now.zero]);\n    }\n}\n\nint bfs(queue<state>& states){\n    int ret = 0;\n    while(states.size()){\n        state s = states.front();\n        states.pop();\n        if(s.correct == 9){\n            ret = s.num;\n            break;\n        }\n        int up = s.zero - 3;\n        int down = s.zero + 3;\n        int left = s.zero%3 ? s.zero - 1 : -1;\n        int right = s.zero%3 != 2 ? s.zero + 1 : -1;\n        //cout << up << \" \" << down << \" \" << left << \" \" << right << endl;\n        push_queue(states, s, up);\n        push_queue(states, s, down);\n        push_queue(states, s, left);\n        push_queue(states, s, right);\n    }\n    return ret;\n}\n\nint find_minimum(vector<int>& vec){\n    int zero = 0;\n    int correct = 0;\n    for(auto it = vec.begin(); it != vec.end(); ++it){\n        int i = it - vec.begin();\n        if(*it == 0){\n            zero = i;\n        }\n        if(correct_pos(vec, i)){\n            ++correct;\n        }\n    }\n    auto st = queue<state>();\n    st.push(state(vec, zero, correct, 0));\n    return bfs(st);\n}\n\nint main(){\n    vector<int> board {};\n    for(int i = 0; i < 9; ++i){\n        int v;\n        cin >> v;\n        board.push_back(v);\n    }\n    cout << find_minimum(board) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nvll x(9);\nlli y;\n\nset<vll> vis;\nqueue<vll> q;\nqueue<lli> d;\n\nvll ans{1,2,3,4,5,6,7,8,0};\n\nint main(){\n    for(lli i = 0;i < 9;i++) cin >> x[i];\n    q.push(x);\n    d.push(0);\n    while(!q.empty()){\n        x = q.front();\n        y = d.front();\n        q.pop();\n        d.pop();\n        if(vis.count(x)) continue;\n        vis.insert(x);\n        if(x == ans){\n            cout << y << endl;\n            return 0;\n        }\n        for(lli i = 0;i < 9;i++){\n            if(x[i] == 0){\n                if(i+3 < 9){\n                    swap(x[i],x[i+3]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i+3]);\n                }\n                if(i-3 >= 0){\n                    swap(x[i],x[i-3]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i-3]);\n                }\n                if(i%3 != 0){\n                    swap(x[i],x[i-1]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i-1]);\n                }\n                if(i%3 != 2){\n                    swap(x[i],x[i+1]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i+1]);\n                }\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int dx[4] = { 0,-1, 0, 1};\nconst int dy[4] = {-1, 0, 1, 0};\nconst char dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] < p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (isTarget(u)) return u.path;\n\n        int sx = u.space % N;\n        int sy = u.space / N;\n        for (int r = 0; r < 4; r++) {\n            int nx = sx + dx[r];\n            int ny = sy + dy[r];\n            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;\n\n            v = u;\n            swap(v.f[u.space], v.f[ny*N + nx]);\n            v.space = ny*N + nx;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) {\n                swap(tmp[p], tmp[q]);\n                wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n            } else {\n                swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n            }\n\n            if (wrong_place == 0) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 + wrong_place > boundary) continue; // estimate value is over boundary\n            find = h1_dfs(boundary, State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break; // find an answer\n        }\n    }\n\n    return find;\n}\n\nint ids_h1(string state, int wrong_place, P blank) {\n    int i = wrong_place, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h1_dfs(i, State{0, wrong_place, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h1(state, wrong_place, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconstexpr int N = 3, N_2D = 9;\n\nstruct Puzzle {\n    int location[N_2D];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle& puzzle) const {\n        for(int i = 0; i < N_2D; ++i){\n            if(location[i] == puzzle.location[i]){\n                continue;\n            }\n            return location[i] > puzzle.location[i];\n        }\n        return false;\n    }\n};\n\n/**\n *  ä½ç½®ããã£ã¦ãããã©ããå¤å®ãã\n */\nbool isTarget(const Puzzle& puzzle){\n    for(int i = 0; i < N_2D; ++i){\n        if(puzzle.location[i] != i+1){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n *  å¹åªåæ¢ç´¢\n */\nstring bfs(const Puzzle& origin){\n    queue<Puzzle> que;\n    map<Puzzle, bool> mp;    // éç½®ãè¨é²ãã¦ãã\n    que.push(origin);\n    mp[origin] = true;\n\n    constexpr int dx[] = {-1, 0, 1, 0};\n    constexpr int dy[] = {0, -1, 0, 1};\n    constexpr char direction[] = {'u', 'l', 'd', 'r'};\n                                 // up, left, down, right\n    while(!que.empty()){\n        Puzzle parent = que.front();\n        que.pop();\n        if(isTarget(parent)){    // ããããºã«uãã¿ã¼ã²ããã¨åè´ãã¦ããã°çµãã\n            return parent.path;\n        }\n        int sx = parent.space / N;   // space x\n        int sy = parent.space % N;   // space y\n\n        for(int i = 0; i < 4; ++i){\n            int tx = sx + dx[i];    // transfer x\n            int ty = sy + dy[i];    // transfer y\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n                continue;    // ç§»ååãããºã«ã®æ ãè¶ãã¦ãã¾ããªãããã«ãã\n            }\n\n            Puzzle child = parent;\n            swap(child.location[parent.space], child.location[tx * N + ty]);\n            child.space = tx * N + ty;    // spaceã®ä½ç½®ãç§»å\n\n            if(!mp[child]){    // æ¢ã«åãéç½®ã®ããºã«ãåããæ¸ã¿ã®å ´åã¯ã¹ã«ã¼ãã\n                mp[child] = true;\n                child.path += direction[i];\n                que.push(child);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\n\nint main(){\n\n    Puzzle puzzle;\n\n    for(int i = 0; i < N_2D; ++i){\n        cin >> puzzle.location[i];\n        if(puzzle.location[i] == 0){\n            // spaceã®å ´æãã»ãããã\n            puzzle.location[i] = N_2D;\n            puzzle.space = i;\n        }\n    }\n    puzzle.path = \"\";\n\n    string ans = bfs(puzzle);\n    if(ans != \"unsolvable\"){\n    \tcout << ans.size() << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[40000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>26) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n/* å¤§æå­ãå°æå­ã«å¤æ */\nchar tolower(char c) {return (c + 0x20);}\n/* å°æå­ãå¤§æå­ã«å¤æ */\nchar toupr(char c) {return (c - 0x20);}\n\n// if('A'<=s[i] && s[i]<='Z') s[i] += 'a'-'A';\n\n/*\nstring s = \"abcdefg\"\ns.substr(4) \"efg\"\ns.substr(0,3) \"abc\"\ns.substr(2,4) \"cdef\"\n*/\nstatic const int N = 3, N2 = 9;\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n        rep(i, N2){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    rep(i,N2){\n        if(p.f[i] != i+1) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;    // èªä½ããæ§é ä½ã«é¢ããmapãå®ç¾©\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        // ããããºã«uãã¿ã¼ã²ããã¨åè´ãã¦ããã°\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;   // space x\n        int sy = u.space % N;   // space y\n        rep(r, 4){\n            int tx = sx + dx[r];    // transfer x\n            int ty = sy + dy[r];    // transfer y\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;    // ç§»ååãããºã«ã®æ ãè¶ãã¦ãã¾ããªãããã«ãã\n            v = u;\n            swap(v.f[u.space], v.f[tx*N + ty]);\n            v.space = tx*N + ty;    // spaceã®ä½ç½®ãç§»å\n            if( !V[v] ){    // æ¢ã«åãéç½®ã®ããºã«ãåããæ¸ã¿ã®å ´åã¯ã¹ã«ã¼ãã\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\n\nint main()\n{\n    Puzzle in;\n\n    rep(i,N2){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;   // set space\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    // cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n/*\n1 2 3\n4 5 6\n7 0 8\n????????Â¶????????????????????????3???????????????\n????????????8??????????????????1?????Â§??????\n\n1 2 3\n4 0 6\n7 5 8\n????????Â¶?????????5??????????????Â°1?????Â§??????????????Â¢????????????\n\n*/\ntypedef long long int TBoard;\nconst static TBoard Answer = 123456780;\ntypedef std::vector<bool> TTable;\nTBoard InputBoard(std::istream& in)\n{\n    TBoard Board = 0;\n    for(int i = 8; i >= 0; --i){\n        int n;\n        std::cin >> n;\n        Board += std::pow(10, i) * n;\n    }\n    return Board;\n}\nint Encode(const TBoard& Board)\n{\n    return Board / 10;\n}\nTBoard Decode(int Code)\n{\n    int n = 0;\n    while(Code){\n        n += Code % 10;\n        Code /= 10;\n    }\n    int a = 36 - n;\n    return Code * 10 + a;\n    \n}\nstd::vector<TBoard> GetMoved(const TBoard& Board)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    assert(s.length() == 9);\n    int i = s.find('0');\n    assert(i >= 0);\n    assert(i <= 9);\n    \n    std::vector<TBoard> Result;\n    if(i > 2){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if(i < 6){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 0 || i == 3 || i == 6) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 2 || i == 5 || i == 8) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n\n    return Result;\n}\nvoid Print(const TBoard& Board, char c)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    std::cerr << c << s[0] << \" \" << s[1] << \" \" << s[2] << std::endl;\n    std::cerr << c << s[3] << \" \" << s[4] << \" \" << s[5] << std::endl;\n    std::cerr << c << s[6] << \" \" << s[7] << \" \" << s[8] << std::endl;\n    std::cerr << std::endl;\n}\nint Solve(const TBoard& Board)\n{\n    std::vector<bool> Table(87654321, false);\n    int Cost = 0;\n    std::queue<TBoard> q;\n    q.push(Board);\n    Table[Encode(Board)] = true;\n\n    std::queue<TBoard> temp;\n    while(!q.empty()){\n        TBoard B = q.front();\n        q.pop();\n        // Print(B, ' ');\n        if(B == Answer) return Cost;\n        std::vector<TBoard> Boards = GetMoved(B);\n        for(std::size_t i = 0; i < Boards.size(); ++i){\n            if(Table[Encode(Boards[i])]) continue;\n            temp.push(Boards[i]);\n            Table[Encode(Boards[i])] = true;\n            // Print(Boards[i], '\\t');\n        }\n        if(q.empty()){\n            std::swap(q, temp);\n            ++Cost;\n            // std::cerr << \"Cost\" << Cost << std::endl;\n        }\n    }\n    assert(false);\n}\nint main()\n{\n    TBoard Board = InputBoard(std::cin);\n    std::cout << Solve(Board) << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#include<map>\n#include<queue>\n#define Max 9\nint gg[Max]={1,2,3,4,5,6,7,8,0}, s[Max];\n\nint ff[4][2] = {0,-1,1,0,0,1,-1,0};\nint sum;\nstruct node\n{\n\tint a[Max];\n\tint step;\n};\nmap<int ,int >m;\n\n\nint bfs()\n{\n\tnode tt;\n\tmemcpy(tt.a,s,sizeof(s));\n\ttt.step = 0;\n\tqueue<node > q;\n\tq.push(tt);\n\twhile(!q.empty())\n\t{\n\t\tnode star = q.front();\n\t\tq.pop();\n\t\tint i;\n\t\tfor(i = 0;i<9;i++)\n\t\t\tif(star.a[i]==0)\n\t\t\t\tbreak;\n\t\tint y = i/3;\n\t\tint x = i%3;\n\t\tfor(i = 0;i<4;i++)\n\t\t{\n\t\t\tint tx = x + ff[i][0];\n\t\t\tint ty = y + ff[i][1];\n\t\t\tif(tx >= 0&&ty>=0&&ty<3&&tx<3)\n\t\t\t{\n\t\t\t\tnode end;\n\t\t\t\tmemcpy(end.a,star.a,sizeof(star.a));\n\t\t\t\tint k = ty*3+tx;\n\t\t\t\tswap(end.a[k],end.a[y*3+x]);\n\t\t\t\tint sum1 = 0;\n\t\t\t\tfor(int j = 0;j<9;j++)\n\t\t\t\t\tsum1 = sum1*10+end.a[j];\n\t\t\t\tif(!m[sum1])\n\t\t\t\t{\n\t\t\t\t\tm[sum1] = sum++;\n\t\t\t\t\tend.step = star.step+1;\n\t\t\t\t\tif(memcmp(end.a,gg,sizeof(gg))==0)\n\t\t\t\t\t\treturn end.step;\n\t\t\t\t\tq.push(end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j;\n\n\twhile(~scanf(\"%d\",&s[0]))\n\t{\n\t\tm.clear();\n\t\tint k = s[0];\n\t\tsum = 1;\n\t\tfor(i = 1;i<9;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tk = k*10+s[i];\n\t\t}\n\t\tm[k] = sum++;\n\t\tif(memcmp(s,gg,sizeof(gg))==0)\n\t\t\tprintf(\"0\\n\");\n\t\telse printf(\"%d\\n\",bfs());\n\t\t\n\t}\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "// 8 puzzle\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < (const Puzzle &p) const\n    {\n        for (int i = 0; i < N2; ++i)\n        {\n            if (f[i] == p.f[i]) continue;\n            return f[i] < p.f[i];            \n        }\n        return false;\n    }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n \nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; ++i)\n    {\n        if (p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n \nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    while(!Q.empty())\n    {\n        u = Q.front(); Q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; ++r)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n \n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n \nint main()\n{\n    Puzzle in;\n    for (int i = 0; i < N2; ++i)\n    {\n        cin>>in.f[i];\n        if (in.f[i]==0) {\n            in.space = i;\n                in.f[i] = 9;\n        }\n    }\n    string ans = bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAXN 363000  //9!==326880\nstruct node\n{\n    int s[9];\n    int a;\n    int b;\n    int step;\n};\nint fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};//åå«å­å¨1--9çé¶ä¹å¼\nint dir[4][2]= {-1,0,1,0,0,-1,0,1};\nint aim=322561;//123456780å¯¹åºçhashå¼\nbool vis[MAXN];\nnode str,now,next\nint cantor(const int *s)\n{\n    int sum=0;\n    for(int i=0; i<9; i++)\n    {\n        int num=0;\n        for(int j=0; j<i; j++)\n            if(s[j]>s[i])\n                num++;\n        sum+=(num*fac[i]);\n    }\n    return (sum+1);\n}\nbool bfs()\n{\n    memset(vis,0,sizeof(vis));\n    queue<node>q;\n    q.push(str);\n    vis[str.b]=1;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        int x=now.a/3;\n        int y=now.a%3;\n        for(int i=0; i<4; i++)\n        {\n            int tx=x+dir[i][0],ty=y+dir[i][1];\n            if(tx<0||tx>=3||ty<0||ty>=3)\n                continue;\n            next=now;\n            next.a=tx*3+ty;\n            next.s[now.a]=next.s[next.a];\n            next.s[next.a]=0;\n            next.b=cantor(next.s);\n            if(!vis[next.b])\n            {\n                vis[next.b]=1;\n                if(next.b==aim)\n                {\n                    return true;\n                }\n                next.step=now.step+1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\nchar sss[3];\nint main()\n{\n    char q[10];\n    for(int i=0; i<9; i++)\n    {\n        scanf(\"%s\",sss);\n        q[i]=sss[0];\n    }\n    int len=strlen(q);\n    int num=0;\n    for(int i=0; i<len; i++)\n    {\n        if(q[i]>='1'&&q[i]<='9')\n        {\n            str.s[num++]=q[i]-'0';\n        }\n        else if(q[i]=='0')\n        {\n            str.s[num]=0;\n            str.a=num++;\n        }\n    }\n    str.b=cantor(str.s);\n    if(str.b==aim)\n        printf(\"%d\\n\",0);\n    else if(bfs())\n        printf(\"%d\\n\",next.step+1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n \nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n \nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"unsolvable\";\n}\n \nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#include<map>\n#include<queue>\n#define Max 9\nint gg[Max]={1,2,3,4,5,6,7,8,0}, s[Max];\n\nint ff[4][2] = {0,-1,1,0,0,1,-1,0};\nint sum;\nstruct node\n{\n\tint a[Max];\n\tint step;\n};\nmap<int ,int >m;\n\n\nint bfs()\n{\n\tnode tt;\n\tmemcpy(tt.a,s,sizeof(s));\n\ttt.step = 0;\n\tqueue<node > q;\n\tq.push(tt);\n\twhile(!q.empty())\n\t{\n\t\tnode star = q.front();\n\t\tq.pop();\n\t\tint i;\n\t\tfor(i = 0;i<9;i++)\n\t\t\tif(star.a[i]==0)\n\t\t\t\tbreak;\n\t\tint y = i/3;\n\t\tint x = i%3;\n\t\tfor(i = 0;i<4;i++)\n\t\t{\n\t\t\tint tx = x + ff[i][0];\n\t\t\tint ty = y + ff[i][1];\n\t\t\tif(tx >= 0&&ty>=0&&ty<3&&tx<3)\n\t\t\t{\n\t\t\t\tnode end;\n\t\t\t\tmemcpy(end.a,star.a,sizeof(star.a));\n\t\t\t\tint k = ty*3+tx;\n\t\t\t\tswap(end.a[k],end.a[y*3+x]);\n\t\t\t\tint sum1 = 0;\n\t\t\t\tfor(int j = 0;j<9;j++)\n\t\t\t\t\tsum1 = sum1*10+end.a[j];\n\t\t\t\tif(!m[sum1])\n\t\t\t\t{\n\t\t\t\t\tm[sum1] = sum++;\n\t\t\t\t\tend.step = star.step+1;\n\t\t\t\t\tif(memcmp(end.a,gg,sizeof(gg))==0)\n\t\t\t\t\t\treturn end.step;\n\t\t\t\t\tq.push(end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j;\n\n\twhile(~scanf(\"%d\",&s[0]))\n\t{\n\t\tm.clear();\n\t\tint k = s[0];\n\t\tsum = 1;\n\t\tfor(i = 1;i<9;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tk = k*10+s[i];\n\t\t}\n\t\tm[k] = sum++;\n\t\tif(memcmp(s,gg,sizeof(gg))==0)\n\t\t\tprintf(\"0\\n\");\n\t\telse printf(\"%d\\n\",bfs());\n\t\t\n\t}\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\n#include<queue>\n\n// åèãhttps://qiita.com/exrd/items/8bc0be17a15ff77d3754\n//      http://www.nct9.ne.jp/m_hiroi/puzzle/eight.html\n\n#define N 9 // ãã¹ç®ã®æ°\n#define INF 1000\n#define FORWARD 2\n#define BACKWARD -2\n\nint sqrtN;\n\ntypedef struct {\n    int b[N];\n    int space;\n    int path; // ããã£ãææ°\n    int prenum; // åã®ãã¼ãã®ç¶æ\n    int from; // åæ¹åæ¢ç´¢ã®ããã®å¤\n    int hur; // ãã¥ã¼ãªã¹ãã£ãã¯å¤\n}Puzzle;\n\ntypedef struct s{\n    int num;\n    struct s *left;\n    struct s *right;\n}BoardState;\n\n\nvoid t(){\n    printf(\"\\ntest\\n\");\n}\n\nvoid swap(int *x, int *y){\n    int tmp;\n    tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\n// ç¤é¢ãããªã³ã\nvoid printBoard(Puzzle p){\n    for(int i = 0; i < N; i++){\n        printf(\"%d\", p.b[i]);\n        if ((i+1) % sqrtN == 0) {\n            printf(\"\\n\");\n        }else{\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}\n\nint kaijou(int x){\n    int kaijou = x;\n    for(int i = x-1; i > 0; i--){\n        kaijou *= i;\n    }\n    return kaijou;\n}\n\n// ç¤é¢ã®ç¶æãæ°å­ã«å¤æãåè:http://www.nct9.ne.jp/m_hiroi/puzzle/eight.html\nint culcBoardNum(Puzzle p){\n    for (int i = 0; i < N-1; i++) {\n        for (int j = i+1; j < N; j++) {\n            //printf(\"%d %d\\n\", p.b[i], p.b[j]);\n            if(p.b[i] < p.b[j]){\n                p.b[j]--;\n            }\n        }\n    }\n    //printBoard(p);\n    int num = 0;\n    for(int i = 0; i < N-1; i++){\n        num += p.b[i] * kaijou(N-1-i);\n    }\n    \n    return num;\n}\n\n// ç©ºããã¹ãã¼ã¹ã®ä¸ä¸å·¦å³ããããç¢ºãããé¢æ°ãã¡\nint left(Puzzle p){\n    if(p.space % sqrtN == 0){\n        return 0;\n    }else{\n        return p.b[p.space-1];\n    }\n}\n\nint right(Puzzle p){\n    if((p.space+1) % sqrtN == 0){\n        return 0;\n    }else{\n        return p.b[p.space+1];\n    }\n}\n\nint up(Puzzle p){\n    if(p.space < sqrtN){\n        return 0;\n    }else{\n        return p.b[p.space-sqrtN];\n    }\n}\n\nint down(Puzzle p){\n    if(p.space + 1 + sqrtN > N){\n        return 0;\n    }else{\n        return p.b[p.space+sqrtN];\n    }\n}\n\n// å®æããç¤é¢ãªãtrueãè¿ã\nbool isDone(Puzzle p){\n    for(int i = 1; i < N; i++){\n        if(p.b[i-1] != i){\n            return false;\n        }\n    }\n    return true;\n}\n\n//   0 1 2\n//   -----   N = 9ã®ã¨ã\n//0 |1 2 3\n//1 |4 5 6\n//2 |7 8 0\nint x(int i){\n    if(i == 0){\n        return sqrtN-1;\n    }else{\n        return (i-1) % sqrtN;\n    }\n}\nint y(int i){\n    if(i == 0){\n        return sqrtN-1;\n    }else{\n        return ( (i-1) - (i-1)%sqrtN ) / sqrtN;\n    }\n}\n\n// ãã¥ã¼ãªã¹ãã£ãã¯å¤è¿ã xã®å·®å+yã®å·®å\nint h(Puzzle p){\n    int sum = 0;\n    for(int i = 1; i < N; i++){\n        sum += abs(x(i) - x(p.b[i-1])) + abs(y(i) - y(p.b[i-1]));\n    }\n    sum += abs(x(0) - x(p.b[N-1])) + abs(y(0) - y(p.b[N-1]));\n    return -1;\n}\n\n// ãã§ã«ã§ã¦ããç¤é¢ãªãtrueãè¿ã\nint *allboard; // ã§ã§ããç¤é¢ãæ°å­ã«ãã¦æ ¼ç´ mainã§malloc [1]ããã¹ã¿ã¼ã\nint *fromwhere; // ã©ã£ã¡ãããããè¨é²ãallbaordã¨å¯¾å¿\nint *paths; // allboardã¨å¯¾å¿\nint curboardNum = 0; // ä»ã®allboardã®è¦ç´ æ°\nBoardState bs_root;\nint isAlready(Puzzle p){\n    //printf(\"isAlready\\n\");\n    int nump = culcBoardNum(p);\n    \n    // ç·å½¢æ¢ç´¢\n    /*\n    for(int i = 0; i < curboardNum; i++){\n        //printf(\"%d: %d to %d\\n\", i, allboard[i], nump);\n        if (nump == allboard[i]) {\n            return true;\n        }\n    }\n    allboard[curboardNum] = nump;\n    curboardNum++;\n    return false;*/\n    \n    // ããä½ã£ãç¤é¢ã§æ¥ãæ¹åãéããã°ä¸è´ããæ¹ã®pathãè¿ã\n    for(int i = 0; i < curboardNum; i++){\n        if (nump == allboard[i] && p.from != fromwhere[i]) {\n            //printf(\"%dçªç®\\n\", i);\n            return paths[i] + p.path;\n        }\n    }\n    allboard[curboardNum] = nump;\n    fromwhere[curboardNum] = p.from;\n    paths[curboardNum] = p.path;\n    /*for(int i = 0; i < curboardNum+1; i++){\n        printf(\"%d \", paths[i]);\n    }\n    printf(\"\\n\");*/\n    curboardNum++;\n    return 0;\n    \n    // äºåæ¢ç´¢æ¨\n    /*while (1) {\n     if(allboard[i] == -1){\n     allboard[i] = nump;\n     return false;\n     }else if(allboard[i] == nump){\n     return true;\n     }else if(allboard[i] < nump){\n     i = 2*i;\n     }else{\n     i = 2*i + 1;\n     }\n     }*/\n    // é£çµãªã¹ãã®äºåæ¨\n    /*\n    BoardState bs, newly;\n    bs = bs_root;\n    while (1) {\n        if (bs.num == nump) {\n            return true;\n        }else if(bs.num > nump){\n            if(bs.left == NULL){\n                bs.left = &newly;\n                bs.left->num = nump;\n                return false;\n            }else{\n                bs = *(bs.left);\n            }\n        }else if(bs.num < nump){\n            if(bs.right == NULL){\n                bs.right = &newly;\n                bs.right->num = nump;\n                return false;\n            }else{\n                bs = *(bs.right);\n            }\n        }\n    }*/\n\n}\nint whilecount = 0;\n// ---- // ---- //\n// æç­ææ°ãè¿ã\nint bfs(Puzzle p){\n    if(isDone(p)){\n        return 0;\n    }\n    std::queue<Puzzle> Q;\n    \n    Puzzle v, goal, l, r, u, d;\n    int minpath;\n    \n    p.path = 0;\n    //p.hur = h(p);\n    p.prenum = -1;\n    p.from = FORWARD;\n    // goalåæå\n    for (int i = 1; i < N; i++) {\n        goal.b[i-1] = i;\n    }\n    goal.b[N-1] = 0;\n    goal.path = 0;\n    goal.prenum = -1;\n    goal.from = BACKWARD;\n    goal.space = N-1;\n    \n    Q.push(p);\n    Q.push(goal);\n    allboard[0] = culcBoardNum(p);\n    allboard[1] = culcBoardNum(goal);\n    fromwhere[0] = FORWARD;\n    fromwhere[1] = BACKWARD;\n    paths[0] = 0;\n    paths[1] = 0;\n    curboardNum += 2;\n    bs_root.num = culcBoardNum(p);\n    while (1) {\n        v = Q.front();\n        Q.pop();\n        int hurv = h(v);\n        int numv = culcBoardNum(v);\n        /*printf(\"dequeue %s\\n\", v.from == FORWARD ? \"FORWARD\" : \"BACKWARD\");\n        printBoard(v);*/\n        // ã­ã¥ã¼ã®åé ­ã«å¥ã£ã¦ããç¤é¢ããä¸æåããã¦ãããã¾ãã­ã¥ã¼ã«å¥ãããå®æãããããã§return\n        if (left(v)) { // spaceã¨ãã®leftãå¥ãæ¿ãããããªã\n            l = v; // ã³ãã¼\n            swap(&l.b[l.space], &l.b[l.space-1]); // å¥ãæ¿ã\n            l.space--; // spaceä½ç½®å¤æ´\n            l.path = v.path + 1;\n            /*if (isDone(l)) { // å®æãã¦ããçµãã\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(l) && h(l) <= hurv){\n                l.prenum = numv;\n                l.path = v.path + 1;\n                Q.push(l);\n            }*/\n            /*if(isAlready(l)){\n                return l.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(l)){\n                l.prenum = numv;\n                l.from = v.from;\n                Q.push(l);\n                printf(\"left path:%d\\n\", l.path);\n                printBoard(l);\n            }*/\n            if(v.prenum != culcBoardNum(l)){\n                minpath = isAlready(l); // ï¼ãå¸°ã£ã¦æ¥ããã¾ã çµäºã§ãªã\n                if (minpath) {\n                    return minpath;\n                }else{\n                    l.prenum = numv;\n                    l.from = v.from;\n                    Q.push(l);\n                    /*printf(\"left path:%d\\n\", l.path);\n                    printBoard(l);*/\n                }\n            }\n        }\n        // ä»¥ä¸åæ§\n        if (right(v)) {\n            r = v;\n            swap(&r.b[r.space], &r.b[r.space+1]);\n            r.space++;\n            r.path = v.path + 1;\n            /*if (isDone(r)) {\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(r) && h(r) <= hurv){\n                r.prenum = numv;\n                r.path = v.path + 1;\n                Q.push(r);\n            }*/\n            /*if(isAlready(r)){\n                return r.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(r)){\n                r.prenum = numv;\n                r.from = v.from;\n                Q.push(r);\n                printf(\"right path:%d\\n\", r.path);\n                printBoard(r);\n            }*/\n            if(v.prenum != culcBoardNum(r)){\n                minpath = isAlready(r);\n                if (minpath) {\n                    return minpath;\n                }else{\n                    r.prenum = numv;\n                    r.from = v.from;\n                    Q.push(r);\n                    /*printf(\"right path:%d\\n\", r.path);\n                    printBoard(r);*/\n                }\n            }\n        }\n        if (up(v)) {\n            u = v;\n            swap(&u.b[u.space], &u.b[u.space-sqrtN]);\n            u.space -= sqrtN;\n            u.path = v.path + 1;\n            /*if (isDone(u)) {\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(u) && h(u) <= hurv){\n                u.prenum = numv;\n                u.path = v.path + 1;\n                Q.push(u);\n            }*/\n            /*if(isAlready(u)){\n                return u.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(u)){\n                u.prenum = numv;\n                u.from = v.from;\n                Q.push(u);\n                printf(\"up path:%d\\n\", u.path);\n                printBoard(u);\n            }*/\n            if (v.prenum != culcBoardNum(u)) {\n                minpath = isAlready(u);\n                if (minpath) {\n                    return minpath;\n                }else{\n                    u.prenum = numv;\n                    u.from = v.from;\n                    Q.push(u);\n                    /*printf(\"up path:%d\\n\", u.path);\n                    printBoard(u);*/\n                }\n            }\n        }\n        if (down(v)) {\n            d = v;\n            swap(&d.b[d.space], &d.b[d.space+sqrtN]);\n            d.space += sqrtN;\n            d.path = v.path + 1;\n            /*if (isDone(d)) {\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(d) && h(d) <= hurv){\n                d.prenum = numv;\n                d.path = v.path + 1;\n                Q.push(d);\n            }*/\n            /*if(isAlready(d)){\n                return d.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(d)){\n                d.prenum = numv;\n                d.from = v.from;\n                Q.push(d);\n                printf(\"down path:%d\\n\", d.path);\n                printBoard(d);\n            }*/\n            if (v.prenum != culcBoardNum(d)) {\n                minpath = isAlready(d);\n                if (minpath) {\n                    return minpath;\n                }else{\n                    d.prenum = numv;\n                    d.from = v.from;\n                    Q.push(d);\n                    /*printf(\"down path:%d\\n\", d.path);\n                    printBoard(d);*/\n                }\n            }\n        }\n        \n        whilecount++;\n    }\n    return -1;\n}\n\nint main(){\n    int board;\n    Puzzle p;\n    \n    int kaijouN = kaijou(N);\n    allboard = (int *)malloc(sizeof(int) * 30000);\n    fromwhere = (int *)malloc(sizeof(int) * 30000);\n    paths = (int *)malloc(sizeof(int) * 30000);\n    \n    bs_root.right = NULL;\n    bs_root.left = NULL;\n    \n    sqrtN = sqrt(N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &board);\n        if(board == 0){\n            p.space = i;\n        }\n        p.b[i] = board;\n        p.path = -1;\n    }\n    \n    //printBoard(p);\n    printf(\"%d\\n\", bfs(p));\n    \n    free(allboard);\n    free(fromwhere);\n    free(paths);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\n//vector<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//    for (vector<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N29\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Pizzle p){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!=Q.empty()){\n    u=Q.front();Q.pop();\n    is(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\n \nbool in(int a,int b){\n  if(a<0 || b<0 || 3<=a || 3<=b)return false;\n  return true;\n}\n \nint main()\n{\n  int a;\n  string start=\"\",goal=\"123456780\";\n \n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n   \n  queue<string> q;\n  map<string,int> mp;\n  mp[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    int s=-1,cost=mp[u];\n    if(u==goal){\n      cout<<mp[u]<<endl;\n      break;\n    }\n \n    for(int i=0;i<u.length();i++){\n      if(u[i]=='0')s=i;\n    }\n \n    int y=s/3,x=s%3;\n \n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int index=ny*3+nx;\n      string t=u;\n      swap(t[s],t[index]);\n      if(mp.find(t)==mp.end()){\n    mp[t]=cost+1;\n    q.push(t);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,ull> P;\ntypedef pair<int,int>Pii;\n#define F first\n#define S second\n \n \nint dep=0;;\nint X[]={0,3,2,1,0,3,2,1,0,3,2,1,0,3,2,1};\nint Y[]={0,3,3,3,3,2,2,2,2,1,1,1,1,0,0,0};\nint dy[]={1,0,-1,0};\nint dx[]={0,-1,0,1};\null mask[3][3],bit[3][3];\n\nconst int MAX = 333333;\null G=4886718336 , x , s , M=((ull)1<<(4*9))-1;\n\nPii pos(ull A){\n    r(y,3)r(x,3){\n        if(!((A>>bit[y][x])&15)){\n            return Pii(y,x);\n        }\n    }\n\n}\n\nint cost(ull A,int y2,int x2){\n\tint sum=0;\n\tr(y,3){\n        r(x,3){\n            int k=((A>>bit[y][x])&15);\n            int t = abs(X[k]-x) + abs(Y[k]-y);\n    \t\tsum += t ;\n        }\n\t}\n\treturn sum;\n}\n\n\nsigned main(){\n\n    ull init = 0;\n    unordered_set<ull>st;\n\n    for(int i=2;i>=0;i--){\n        for(int j=2;j>=0;j--){\n            ull x;\n            cin>>x;\n            init|=(x<<((i*3+j)*4));\n            mask[i][j] = (ull)15<<((i*3+j)*4);\n            bit[i][j] = (i*3+j)*4;\n        }\n    }\n\n\n\n    priority_queue<P> Q[2];\n    Q[0].push(P(0,init));\n    st.insert(init);\n \n    while( !Q[dep%2].empty() ){\n        while( !Q[dep%2].empty() ){\n            P A=Q[dep%2].top(); Q[dep%2].pop();\n\n            if(A.S==G){\n                cout<<dep<<endl;\n                return 0;\n            }\n\n            Pii p=pos(A.S);\n            int x=p.S, y=p.F;\n            ull a = (A.S>>bit[y][x])&15;\n\n            r(i,4){\n            \tint ny=p.F+dy[i];\n            \tint nx=p.S+dx[i];\n            \tif( ny<0 || nx<0 || 3<=ny || 3<=nx ) continue;\n\n                ull b = ( A.S>>bit[ny][nx] )&15;\n                ull c = ( A.S & ( M - mask[y][x] - mask[ny][nx] ) );\n                ull nex = (c | ( b<<bit[y][x] ) | ( a<<bit[ny][nx] ) );\n\n                if(st.count(nex)) continue;\n                st.insert(nex);\n\n\n                Q[(dep+1)%2].push(P(cost(nex,y,x),nex));\n                if(Q[(dep+1)%2].size()>=MAX) Q[(dep+1)%2].pop();\n\n            }\n        }\n        if(dep>=90)break;\n        //cout<<(Q[(dep+1)%2].size())<<endl;\n        dep++;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) std::cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<std::endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\n \ntemplate<typename T>\nclass Deque{\npublic:\n  T *val;\n  int sz;\n  int length;\n  int head, tail;\n   \n  Deque(){sz = 0, length = 0, val = new T[0];}\n  Deque(int size, T init = T()){\n    length = 1;\n    while(length < size) length *= 2;\n    val = new T[length];\n    sz = size;\n    head = 0;\n    tail = 0;\n    for(int i=0;i<size;i++) val[tail++] = init;\n  }\n   \n  Deque(const Deque &t){\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n  }\n \n  ~Deque(){\n    delete [] val;\n  }\n   \n  Deque<T> operator = (const Deque<T> t){\n    delete [] val;\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n    return t;\n  };\n   \n  T& operator [] (int i){\n    assert(0 <= i && i < sz);\n    return head+i<length? val[head+i]:val[head+i - length];\n  }\n  T& operator [] (int i)const{\n   assert(0 <= i && i < sz);\n    return head+i<length? val[head+i]:val[head+i - length];\n  }\n   \n  bool operator == (const Deque<T> &a)const{\n    if(size() != a.size()) return 0;\n    for(int i=0;i<size();i++)\n      if(!((*this)[i] == a[i])) return 0;\n    return 1;\n  }\n   \n  T& front(){return val[head];}\n  T& back(){return val[(head + sz - 1) % length];}\n   \n  int size()const{return sz;}\n  int empty()const{return sz == 0;}\n   \n  void resize(int n, T v=T()){\n    while(n < size()) pop_back();\n    while(n > size()) push_back_fast(v);\n  }\n \n \n  void increaseMemory(){\n    int length_ = length;\n    length = length * 2;\n    if(length == 0) length = 1;\n    T *val2 = new T[length];\n    for(int i=0;i<sz;i++) val2[i] = val[(head + i)%length_];\n    head = 0;\n    tail = sz;\n    delete [] val;\n    val = val2;\n  };\n   \n  void push_back(T v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n \n  void push_back_fast(T &v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n     \n  void push_front(int v){\n    if(sz == length) increaseMemory();\n    sz++;\n    head--;\n    if(head == -1) head = length - 1;\n    val[head] = v;\n  }\n \n  void pop_back(){\n    assert(sz > 0);\n    sz--;\n    tail--;\n    if(tail == -1) tail = length - 1;\n  }\n   \n  void pop_front(){\n    assert(sz > 0);\n    sz--;\n    head++;\n    if(head == length) head = 0;\n  }\n \n  friend std::ostream& operator << (std::ostream& os,const Deque<T> a){\n    os<<\"[\";\n    for(int i=0;i<a.size();i++){\n      if(i) os<<\" \";\n      os<<a[i];\n    }\n    os<<\"]\";\n    return os;\n  }\n};\ntemplate <typename T>\nusing vector = Deque<T>;\n \ntemplate <typename T>\nusing queue = Deque<T>;\n \ntemplate <typename T, typename D>\nclass Pair{\npublic:\n  T first;\n  D second;\n  Pair(){first = T(),second = D();}\n  Pair(const T &first, const D &second):first(first), second(second){}\n   \n  bool operator < (const Pair t)const{\n    return first != t.first? (first < t.first):(second < t.second);\n  }\n  bool operator > (const Pair t)const{\n    return first != t.first? (first > t.first):(second > t.second);\n  }\n   \n  friend std::ostream& operator << (std::ostream& os,const Pair<T, D> a){\n    os<<\"(\"<<a.first<<\", \"<<a.second<<\")\";\n    return os;\n  }\n};\n \ntemplate<class T, class D>\nclass HashTable{\npublic:\n  using ull = unsigned int;\n  ull tableSize;\n  vector<vector<T> > tableKey;\n  vector<vector<D> > tableVal;\n   \n  HashTable(ull tableSize = 500009){\n    for(int i=2;i*i<=tableSize;i++)\n      assert(tableSize % i != 0 && \"tableSize have to be prime number\");\n    this->tableSize = tableSize;\n    tableKey.resize(tableSize);\n    tableVal.resize(tableSize);\n \n  }\n \n  void push(T key, D val, ull hash){\n    hash %= tableSize;\n    tableKey[hash].push_back_fast(key);\n    tableVal[hash].push_back_fast(val);\n  }\n \n  bool count(T key, ull hash){\n    hash %= tableSize;\n    int count = 0;\n    for(int i=0;i<tableKey[hash].size();i++)\n      if(tableKey[hash][i] == key) count++;\n    return count;\n  }\n \n  D getVal(T key, ull hash){\n    hash %= tableSize;\n    for(int i=0;i<tableKey[hash].size();i++)\n      if(tableKey[hash][i] == key) return tableVal[hash][i];\n    assert(!\"key not exists\");\n  }\n};\n \ntemplate<class T>\nvoid swap(T &a, T &b){\n  T tmp = a;\n  a = b;\n  b = tmp;\n}\n \nusing D = vector<vector<int> >;\nusing P = Pair<int, D>;\nconst int N = 3;\nusing ull = unsigned int;\n \null toHash(D &mp){\n  const ull B = 1777771;\n  ull hash = 0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) hash = hash * B + mp[i][j];\n  return hash;\n}\n \nHashTable<D, int> bfs(D start, D goal, int limit){\n  queue <P> Q;\n  Q.push_back(P(0,start));\n  HashTable <D, int> memo(100019);\n  memo.push(start, 0, toHash(start));\n   \n  while(!Q.empty()){\n    int cost = Q.front().first;\n    D mp = Q.front().second;\n    Q.pop_front();\n    if(cost == limit) continue;\n     \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++){\n    if(j+1<N && (mp[i][j] == 0 || mp[i][j+1] == 0)){\n      D key = mp; swap(key[i][j], key[i][j+1]);\n      int val = cost + 1;\n      ull hash = toHash(key);\n      if(!memo.count(key, hash)){ \n        memo.push(key, val, hash);\n        Q.push_back(P(val, key));\n      }\n    }\n \n    if(i+1<N && (mp[i][j] == 0 || mp[i+1][j] == 0)){\n      D key = mp; swap(key[i][j], key[i+1][j]);\n      int val = cost + 1;\n      ull hash = toHash(key);\n      if(!memo.count(key, hash)){\n        memo.push(key, val, hash);\n        Q.push_back(P(val, key));\n      }\n    }\n      }\n  }\n  return memo;\n}\n \nsigned main(){\n \n  D goal(N, vector<int>(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) goal[i][j] = i*N + j + 1;\n  goal[N-1][N-1] = 0;\n \n  D start(N, vector<int>(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) std::cin>>start[i][j];\n \n   \n  auto A = bfs(start, goal, 20);\n  auto B = bfs(goal, start, 15);\n \n  int ans = 1000000;\n  for(int i=0;i<(int)B.tableSize;i++)\n    for(int j=0;j<(int)B.tableKey[i].size();j++){\n      auto key = B.tableKey[i][j];\n      auto costB = B.tableVal[i][j];\n      int costA = 10000000;\n      if(A.count(key, i)) costA = A.getVal(key, i);\n      if(ans > costA + costB) ans = costA + costB;\n     \n \n    }\n   \n  std::cout<<ans<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// using A star algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int N = 9;\nconst int XY = 3;\nconst int LIMIT = 100;\n\nstruct state {\n  vector<int> board;\n  int g;\n  state(vector<int> &board) {\n    this->board = board;\n    this->g = 0;\n  }\n};\nstruct compare_state {\n  int h_func(state &s) {\n    // using Manhattan distance\n    int distance = 0;\n    vector<int> solve(N,0);\n    for(int i=0;i<N;i++) {\n      solve[i] = i+1;\n    }\n    solve[N-1] = 0;\n    vector<int> board = s.board;\n    int solve_x,solve_y;\n    int board_x,board_y;\n    for(int i=0;i<N;i++) {\n      for(int j=0;j<N;j++) {\n        if(solve[i] == board[j]) {\n          solve_x = i % XY; solve_y = i / XY;\n          board_x = j % XY; board_y = j / XY;\n          distance += abs(solve_x - board_x) + abs(solve_y - board_y);\n          break;\n        }\n      }\n    }\n    return distance;\n  }\n  bool operator() (state &a,state &b) {\n    return (a.g + h_func(a)) > (b.g + h_func(b));\n  }\n};\npriority_queue<state,vector<state>,compare_state> que;\nmap<vector<int>,bool> exist_table;\n\nbool check(state &current,state &end) {\n  for(int i=0;i<N;i++) {\n    if(current.board[i] != end.board[i])\n      return false;\n  }\n  return true;\n}\n\nbool is_infield(int x,int y) {\n  return (x < XY && y < XY && x >= 0 && y >= 0);\n}\n\nint search(state &start,state &end) {\n  // initialize process\n  que.push(start);\n  exist_table[start.board] = true;\n  while(!que.empty()) {\n    state current = que.top(); que.pop();\n    // approach goal\n    if(check(current,end)) {\n      return current.g;\n    }\n    // not find goal\n    if(current.g > LIMIT) {\n      break;\n    }\n    // find zero brocks\n    int zero_pos;\n    for(int i=0;i<N;i++)\n      if(current.board[i] == 0)\n        zero_pos = i;\n    int x = zero_pos % XY;\n    int y = zero_pos / XY;\n    // swap zero brocks and update cost tables\n    int dx[] = {0,-1,1,0};\n    int dy[] = {-1,0,0,1};\n    for(int d=0;d<4;d++) {\n      if(!is_infield(x+dx[d],y+dy[d])) continue;\n      vector<int> next_board = current.board;\n      swap(next_board[x+y*XY],next_board[(x+dx[d])+(y+dy[d])*XY]);\n      if(!exist_table.count(next_board)) {\n        exist_table[next_board] = true;\n        state next = *(new state(next_board));\n        next.g = current.g + 1;\n        que.push(next);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  vector<int> start_vec(N,-1);\n  vector<int> end_vec(N,-1);\n  for(int i=0;i<N;i++) {\n    cin >> start_vec[i];\n    end_vec[i] = i+1;\n  }\n  end_vec[N-1] = 0;\n\n  state start = *(new state(start_vec));\n  state end = *(new state(end_vec));\n\n  cout << search(start,end) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\nclass state{\npublic:\n  static constexpr int size = 3;\n  int sx, sy;\n  int n[size*size];\n\n  bool operator < (const state&a) const{\n    for(int i=0; i<size*size; i++){\n      if(n[i]==a.n[i]) continue;\n      return n[i] < a.n[i];\n    }\n    return false;\n  }\n};\n\nclass board : public state{\npublic:\n  int cnt;\n  int dis;\n  board(): state(){\n    cnt = 0;\n    dis = 0;\n  }\n\n  bool check(){\n    for(int i=0; i<size*size; i++){\n      if(n[i] != i) return false;\n    }\n    return true;\n  }\n\n  board sswap(int x1, int y1, int x2, int y2){\n    board next(*this);\n\n    next.sx = x2; next.sy = y2;\n    swap(next.n[y1 * size + x1], next.n[y2 * size + x2]);\n    next.cnt = cnt+1;\n\n    return next;\n  }\n\n  void print(){\n    for(int i=0; i<size*size; i++){\n      cout << n[i] << \" \";\n      if(i%size == size-1) cout << endl;\n    }\n  }\n};\n\ntypedef pair<int, board> np;\n\nint main(){\n  board s;\n\n  for(int i=0; i<board::size*board::size; i++) {\n    cin >> s.n[i];\n    if(s.n[i] == 0){\n      s.sx = i % board::size;\n      s.sy = i / board::size;\n    }\n  }\n\n  queue<board> q;\n  map<state, bool> mp;\n  mp[s] = true;\n  q.push(s);\n\n  int c=0;\n  while(!q.empty()){\n    board now = q.front();\n\n    q.pop();\n    c++;\n\n    if(now.check()){\n      cout << now.cnt << endl;\n      cout << c << endl;\n      return 0;\n    }\n\n    int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\n    for(int i=0; i<4; i++){\n      int nx = now.sx + dx[i], ny = now.sy + dy[i];\n\n      if(nx < 0 || nx >= board::size || ny < 0 || ny >= board::size) continue;\n      board next = now.sswap(now.sx, now.sy, nx, ny);\n\n      if(!mp[next]){\n        mp[next] = true;\n        q.push(next);\n      }\n    }\n  }\n\n  cout << \"not found\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1<<30;\n\nvector<int> board( 9 );\nint completeState;\nset<int> reachedState;\n\nvoid PrintBoard() {\n    for ( int row=0; row<3; ++row ) {\n\tfor ( int col=0; col<3; ++col ) cout << board[row*3+col];\n\tcout << endl;\n    }\n}\n\nbool IsReachedState( int state ) {\n    return reachedState.find( state ) != reachedState.end();\n}\n\nint TranslateIntoState( const vector<int>& b ) {\n    int state = b[8] + 1;\n    for ( int i=7; i>=0; --i ) state = state*10 + (b[i]+1);\n    return state;\n}\n\nvoid RegisterState( int state ) {\n    reachedState.insert( state );\n}\n\nbool IsCompleted( int state ) {\n    return state == completeState;\n}\n\nint Try( int x, int y, int moves ) {\n\n    return 100;\n}\n\nint main() {\n\n    const int dx[4] = { -1, 0, 1,  0 };\n    const int dy[4] = {  0, 1, 0, -1 };\n    \n    int x, y;\n    for ( int i=0; i<3; ++i ) {\n\tfor ( int j=0; j<3; ++j ) {\n\t    cin >> board[i*3+j];\n\t    if ( board[i*3+j] == 0 ) {\n\t\ty = i;\n\t\tx = j;\n\t    }\n\t}\n    }\n\n    completeState = 1;\n    for ( int i=9; i>=2; --i ) completeState = completeState*10 + i;\n\n    /*\n    vector<int> b(9);\n    b[0] = 1; b[1] = 2; b[2] = 3;\n    b[3] = 4; b[4] = 5; b[5] = 6;\n    b[6] = 7; b[7] = 8; b[8] = 0;\n    cout << completeState << \" \" << TranslateIntoState( b ) << endl;\n    */\n    \n    //    PrintBoard();\n\n    queue< pair<vector<int>,int> > stateQue;\n    stateQue.push( make_pair(board, 0) );\n\n    int minStep = INF;\n    while ( !stateQue.empty() ) {\n\n\tvector<int> state = stateQue.front().first;\n\tint step = stateQue.front().second;\n\tstateQue.pop();\n\n\tint s = TranslateIntoState( state );\n\tif ( IsCompleted( s ) ) {\n\t    cout << step << endl;\n\t    board = state;\n\t    //\t    PrintBoard();\n\t    break;\n\t}\n\n\tif ( IsReachedState( s ) ) continue;\n\tRegisterState( s );\n\n\tint x, y;\n\tfor ( int i=0; i<9; ++i ) {\n\t    if ( state[i] == 0 ) {\n\t\tx = i%3;\n\t\ty = i/3;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tfor ( int i=0; i<4; ++i ) {\n\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\n\t    if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue;\n\n\t    vector<int> next = state;\n\t    swap( next[3*y+x], next[3*ny+nx] );\n\t    stateQue.push( make_pair( next, step+1 ) );\n\t    \n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\nstruct Graph{\n\tchar r, c;\n\tstring m;\n\tint cnt;\n\tbool ok(){\n\t\tbool ans = 1;\n\t\tfor(int i=0; i<N*N; i++)\n\t\t\tans &= (m[i] == (i+1) % (N*N));\n\t\treturn ans;\n\t}\n\tvoid get(){\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++){\n\t\t\tcin >> cnt;\n\t\t\tm.push_back(cnt);\n\t\t\tif(cnt == 0) r = i, c = j;\n\t\t}\n\t\tcnt = 0;\n\t}\n\tbool go(int i, int j){\n\t\tint r1=i+r, c1=j+c;\n\t\tif(!legal(r1, c1)) return 0;\n\t\tm[r*N+c] = m[r1*N+c1];\n\t\tm[r1*N+c1] = 0;\n\t\tr = r1, c = c1;\n\t\tcnt++;\n\t\treturn 1;\n\t}\n\tbool legal(int r1, int c1){\n\t\treturn (r1>=0 && r1<N && c1>=0 && c1<N);\n\t}\n};\nqueue <Graph> Q;\nmap <string , bool> V;\nint bfs(){\n\tint cmd[4][2]={{1,0}, {-1,0}, {0,1}, {0,-1}};\n\tGraph t0,t1;\n\twhile(!Q.empty()){\n\t\tt0 = Q.front();\n\t\tQ.pop();\n\t\tif(t0.ok()) return t0.cnt;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tt1 = t0;\n\t\t\tif(t1.go(cmd[i][0], cmd[i][1]))\n\t\t\t\tif(!V[t1.m])\n\t\t\t\t\tQ.push(t1), V[t1.m] = 1;\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\t\n\tGraph a; a.get();\n\tQ.push(a);\n\tV[a.m] = 1;\n\tcout << bfs() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n//goal\nint final[N][N] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    solve(initial, x, y, final);\n    path -= 1;\n    cout << path << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        }\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (n.f[i] == f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] < n.f[i];\n\t\t}\n\t\treturn true;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{  \n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map> //I'm sorry to use map\n#include<algorithm>\nusing namespace std;\n\nstruct Puz{\n  int board[3][3];\n  int zx, zy; //coodinate of zero\n  int cnt;\n\n  bool operator < (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] == p.board[i][j]) continue;\n        return board[i][j] > p.board[i][j];\n      }\n    }\n    return false;\n  }\n\n  bool operator == (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] != p.board[i][j]) return false;\n      }\n    }\n    return true;\n  }\n};\n\n\n\nint d[5] = {0, -1, 0, 1, 0}; //direction\nPuz g = {{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}}; //goal\nmap<Puz, int> mem; //memory\n\n//queue\nint head, tail;\nPuz Q[30000];\n\nvoid enqueue(Puz x){\n\n  Q[tail] = x;\n\n  if(tail + 1 == 30000) tail = 0;\n  else tail++;\n}\n\nPuz dequeue(){\n\n  Puz x = Q[head];\n\n  if(head + 1 == 30000) head = 0;\n  else head++;\n\n  return x;\n}\n\n//solve\nint bfs(Puz s){\n\n  enqueue(s);\n  mem[s] = 1;\n\n  while(head != tail){\n    Puz p = dequeue(), q;\n\n    if(p == g) return p.cnt;\n\n    for(int i = 0;i < 4;i++){\n      int x = p.zx + d[i], y = p.zy + d[i + 1];\n\n      if(0 <= x && x < 3 && 0 <= y && y < 3){\n        q = p;\n        swap(q.board[q.zy][q.zx], q.board[y][x]);\n        q.zy = y;\n        q.zx = x;\n        q.cnt++;\n        if(!mem[q]++) enqueue(q); //memorizing\n      }\n    }\n  }\n\n  return 0;\n}\n\nint main(){\n\n  Puz s;\n\n  //input\n  for(int i = 0;i < 3;i++){\n    for(int j = 0;j < 3;j++){\n      cin >> s.board[i][j];\n      if(s.board[i][j] == 0){\n        s.zy = i;\n        s.zx = j;\n      }\n    }\n  }\n  s.cnt = 0;\n\n  //output\n  cout << bfs(s) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n\nusing namespace std;\n\nclass Board {\n    friend bool operator==(const Board &b1, const Board &b2);\n    friend bool operator!=(const Board &b1, const Board &b2);\n\nprivate:\n    uint64_t board;\n\npublic:\n    Board() {\n        board = 0;\n    }\n\n    void set(int32_t r, int32_t c, int64_t v) {\n        uint32_t shift = 4 * (r * 3 + c);\n        uint64_t mask = 0xf;\n        board = (board & ~(mask << shift)) | (v << shift);\n        return;\n    }\n\n    int32_t get(int32_t r, int32_t c) const {\n        int32_t shift = 4 * (r * 3 + c);\n        return (board >> shift) & 0xf;\n    }\n\n    void swap(int32_t r1, int32_t c1, int32_t r2, int32_t c2) {\n        int32_t temp = get(r1, c1);\n        set(r1, c1, get(r2, c2));\n        set(r2, c2, temp);\n        return;\n    }\n\n    void show() const {\n        cout << hex << board << endl;\n    }\n};\n\nbool operator==(const Board &b1, const Board &b2) {return b1.board == b2.board;};\nbool operator!=(const Board &b1, const Board &b2) {return !(b1 == b2);}\n\nint32_t manhattan(const Board &board) {\n    int32_t d = 0;\n\n    for (int32_t r = 0; r < 3; r++) {\n        for (int32_t c = 0; c < 3; c++) {\n            int32_t v = board.get(r, c);\n            if (v != 0) d += abs(r - (v-1) / 3) + abs(c - (v-1) % 3);\n        }\n    }\n\n    return d;\n}\n\nvector<Board> children(const Board &board) {\n    vector<Board> c;\n    int32_t zr, zc;\n\n    for (int32_t z = 0; z < 9; z++) {\n        if (board.get(z/3, z%3) == 0) {\n            zr = z/3;\n            zc = z%3;\n            break;\n        }\n    }\n\n    array<int32_t, 4> dr = {1, 0, -1, 0}, dc = {0, 1, 0, -1};\n\n    for (int32_t i = 0; i < 4; i++) {\n        if (0 <= zr+dr[i] && zr+dr[i] < 3 && 0 <= zc+dc[i] && zc+dc[i] < 3) {\n            Board board_new = board;\n            board_new.swap(zr, zc, zr+dr[i], zc+dc[i]);\n            c.push_back(board_new);\n        }\n    }\n\n    return c;\n}\n\nbool dfs(const Board &board, const Board &parent, int32_t depth, int32_t dist, int32_t limit) {\n    if (dist == 0) {\n        cout << depth << endl;\n        return true;\n    }\n\n    if (depth + dist > limit) return false;\n\n    bool flag = false;\n    for (Board child : children(board)) {\n        if (child != parent) {\n            if (dfs(child, board, depth + 1, manhattan(child), limit)) {\n                flag = true;\n                break;\n            }\n        }\n    }\n\n    return flag;\n}\n\n\nint main() {\n    Board board;\n\n    for (int32_t r = 0; r < 3; r++) {\n        for (int32_t c = 0; c < 3; c++) {\n            int32_t v;\n            cin >> v;\n            board.set(r, c, v);\n        }\n    }\n\n    int32_t limit = 0;\n\n    while (!dfs(board, board, 0, manhattan(board), limit)) limit++;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ã§ãã­ãï¼\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"è¡ç®ã ãã¼ããã»ã»\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" âãªãã ãã¼ãã®æ°å­ï¼\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nvvi pz0(3,vi(3,0));\nint ans=32;\nmap <vvi,int> tf;\n\nint find0(vvi pz){\n\n  REP(i,3) REP(j,3) if(pz[i][j]==0) return i*3+j;\n\n}\n\nvoid print(vvi pz){\n\n  REP(i,3){\n    REP(j,3){\n      if(j) cout<<\" \";\n      cout<<pz[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\nvoid dfs(vvi pz,int how){\n\n  if(tf[pz]) return;\n  tf[pz]=1;\n\n  if(how>31) return;\n  if(pz0==pz){\n\n    ans=min(ans,how);\n    return;\n\n  }\n\n  int x=find0(pz)%3;\n  int y=find0(pz)/3;\n\n  /*\n  deb(find0(pz));\n  print(pz);\n  cout<<endl;\n  */\n\n  REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(pz[y][x],pz[y0][x0]);\n    dfs(pz,how+1);\n    swap(pz[y][x],pz[y0][x0]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  vvi pz(3,vi(3,0));\n\n  REP(i,9) pz0[i/3][i%3]=(i+1)%9;\n  REP(i,9) cin>>pz[i/3][i%3];\n\n  dfs(pz,0);\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nset<long long> s;\nint map1[10][10];\nint k[10];\nint t;\nqueue<long long> x,y;\nvoid input(){\n\tint g=0;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map1[i][j];\n\t\t\tg=g*10+map1[i][j];\n\t\t}\n\t}\n\ts.insert(g);\n\tx.push(g);\n\ty.push(0);\n}\nvoid syf(){\n\twhile(!x.empty()){\n\t\tif(x.front()==123456780){\n\t\t\tcout<<y.front()<<endl;\n\t\t\treturn;\n\t\t}\n\t\tint g=x.front(),tot=0,kl=-1;\n\t\twhile(g!=0){\n\t\t\tif(g%10==0) kl=tot;\n\t\t\tk[tot++]=g%10;\n\t\t    g/=10;\n\t\t}\n\t\tif(kl==-1) {\n\t\t\tkl=tot;\n\t\t\tk[tot++]=0;\n\t\t}\n\t\tif(kl%3>0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t}\n\t\tif(kl%3<2){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\t\t\t\n\t\t}\n\t\tif(kl+3<=8){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\t\t\n\t\t}\n\t\tif(kl-3>=0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\t\t\t\n\t\t}\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}\nint main(){\n\tinput();\n\tsyf();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const char dir[4] = {'u','l','d','r'};\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\n\nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.f[i]=N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tint val=calc(v);\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3;\nconst int LIMIT = 100;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nint limit;\nint puz[N*N];\nint zero;\nint esti;\nint MDT[N*N][N*N];\n\nint dfs(int dep, int pre) {\n\tif ( esti == 0 ) return dep;\n\tif ( dep+esti >= limit ) return LIMIT;\t\n\n\tint ret = LIMIT;\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tif ( (i+2)%4 == pre ) continue;\n\t\tint y = zero/N, x = zero%N;\n\t\tint ny = y+dy[i], nx = x+dx[i];\n\t\tif ( ny < 0 || nx < 0 || ny >= N || nx >= N ) continue;\n\t\tint tmp[N*N];\n\t\tint tmp_zero  = zero;\n\t\tint tmp_esti = esti;\t\t\n\t\tfor ( int j = 0; j < N*N; j++ ) tmp[j] = puz[j];\n\t\tint ch_id = ny*N+nx;\n\t\tint ch_dat = puz[ch_id];\t\t\n\t\testi -= MDT[zero][N*N-1];\n\t\testi -= MDT[ny*N+nx][ch_dat];\n\t\testi += MDT[zero][ch_dat];\n\t\testi += MDT[ny*N+nx][N*N-1];\n\t\tswap(puz[zero], puz[ch_id]);\n\t\tzero = ch_id;\t\t\n\t\tret = min(ret, dfs(dep+1, i));\n\t\tfor ( int j = 0; j < N*N; j++ ) puz[j] = tmp[j];\n\t\tzero = tmp_zero;\n\t\testi = tmp_esti;\t\t\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tfor ( int i = 0; i < N*N; i++ ) {\n\t\tfor ( int j = 0; j < N*N; j++ ) {\n\t\t\tMDT[i][j] = abs(i/N-j/N) + abs(i%N-j%N);            \n\t\t}\n\t}\n\n\tfor ( int i = 0; i < N*N; i++ ) {\t\t\n\t\tcin >> puz[i];\n\t\tif ( puz[i] == 0 ) {\n\t\t\tzero = i;\n\t\t\tpuz[i] = N*N-1;\t\t\t\n\t\t} else {\n\t\t\tpuz[i]--;\n\t\t}\n\t\testi += abs(i/N-puz[i]/N) + abs(i%N-puz[i]%N);        \n\t}\n\n\tfor ( int i = esti; i <= LIMIT; i++ ) {\n\t\tlimit = i;\n\t\tint ans = dfs(0, -1);\n\t\tif ( ans < 100 ) {\n\t\t\tcout << ans << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????Â¨?????????24????????Â±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = p.f[i] / N;\n        y = p.f[i] % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nclass state{\npublic:\n  int* num;\n  int time;\n\n  state(){\n    num = new int[9];\n  }\n\n  state(int time){\n    num = new int[9];\n    this->time = time;\n  }\n\n  state(const state &st){\n    num = new int[9];\n    for(int i=0; i<9; i++) num[i]=st.num[i];\n    time = st.time;\n  }\n\n  ~state(){\n    delete[] num;\n  }\n\n  bool check(){\n    bool flag=true;\n    for(int i=0; i<8; i++){\n      if(num[i]!=i+1) flag=false;\n    }\n    return flag&&(num[8]==0);\n  }\n\n  //ã³ã¼ã1~12ãæå®ãã¦ãããºã«ãç§»åããã\n  state operate(int i){\n    state ns=*this;\n    assert(1<=i && i<=12);\n    switch (i) {\n      case 1: ns.swap(0, 1); break;\n      case 2: ns.swap(1, 2); break;\n      case 3: ns.swap(3, 4); break;\n      case 4: ns.swap(4, 5); break;\n      case 5: ns.swap(6, 7); break;\n      case 6: ns.swap(7, 8); break;\n      case 7: ns.swap(0, 4); break;\n      case 8: ns.swap(1, 5); break;\n      case 9: ns.swap(2, 6); break;\n      case 10: ns.swap(3, 6); break;\n      case 11: ns.swap(4, 7); break;\n      case 12: ns.swap(5, 8); break;\n    }\n    ns.time=time+1;\n    return ns;\n  }\n\nprivate:\n  //numã®n1çªç®ã®è¦ç´ ã¨n2çªç®ã®è¦ç´ ãå¥ãæ¿ãã\n  void swap(int n1, int n2){\n    int temp=num[n1];\n    num[n1]=num[n2];\n    num[n2]=temp;\n  }\n};\nint main(){\n  state start(0);//åæç¶æã®çæ\n  for(int i=0; i<9; i++) cin >> start.num[i];\n\n  //bfsç¨ã®queueçæ\n  queue<state> q; q.push(start);\n\n  //queueãç©ºã«ãªãã¾ã§\n  while(!q.empty()){\n    state now=q.front(); q.pop();\n\n    //ããåãåºããç¶æãææã®ç¶æãªãããã£ãåæ°ãè¡¨ç¤ºãã¦çµäº\n    if(now.check()){\n      cout << now.time << endl;\n      break;\n    }\n\n    for(int i=1; i<=12; i++){\n      q.push(now.operate(i));\n    }\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\nusing LL=long long;\nusing VI=vector<int>;      using VL=vector<LL>;\nusing VS=vector<string>;   using VD=vector<double>;\nusing VVI=vector<VI>;      using VVL=vector<VL>;\nusing PII=pair<int, int>;  using PLL=pair<LL, LL>;\nconst int inf = (int)1e9;  const double pi = acos(-1.0);\nconst LL MOD = 1000000007; const string Snum = \"0123456789\";\nconst int dx[] = { -1,0,1,0,-1,-1,1,1 }, dy[] = { 0,1,0,-1,-1,1,-1,1 };\n\ntemplate<class T>void Sort(T& a) { sort(all(a)); }\ntemplate<class T>void RSort(T& a) { sort(rall(a)); }\ntemplate<class T>void Reverse(T& a) { reverse(all(a)); }\ntemplate<class T>void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>auto Max(const T& a) { return *max_element(all(a)); }\ntemplate<class T>auto Min(const T& a) { return *min_element(all(a)); }\ntemplate<class T>int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>int Count(const T& a, U v) { return count(all(a), v); }\ntemplate<class T, class U>int Find(const T& a, U v) { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>U Sum(const T& a, U v) { return accumulate(all(a), v); }\ntemplate<class T, class U>int Lower(const T& a, U v) { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>int Upper(const T& a, U v) { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>int CountIf(const T& a, P f) { return count_if(all(a), f); }\ntemplate<class T, class P>void RemoveIf(T& a, P f) { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>T Age(T n, T m) { return (n + m - 1) / m; }\ntemplate<class T>T Gcd(T n, T m) { return m == 0 ? n : Gcd(m, n % m); }\ntemplate<class T>T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\ntemplate<class T>T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>T Powmod(T a, T n, T m = MOD) { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\nstring operator*(string s, int n) { string ret; rep(i, n)ret += s; return ret; }\n\n/* INPUT */\ntemplate<class T>T InputF() { T o; cin >> o; return o; }\ntemplate<> char InputF() {\n\tchar ret = '\\0', c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n' && c != '\\t' && c != ' ') { ret = c; c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<> string InputF() {\n\tstring ret; char c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n' && c != '\\t' && c != ' ') { ret.push_back(c); c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<> int InputF() {\n\tint ret = 0; bool neg = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile ('0' <= c && c <= '9') { ret = ret * 10 + (c - '0'); c = getchar_unlocked(); }\n\treturn neg ? -ret : ret;\n}\ntemplate<> LL InputF() {\n\tLL ret = 0; bool neg = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile ('0' <= c && c <= '9') { ret = ret * 10LL + (LL(c) - LL('0')); c = getchar_unlocked(); }\n\treturn neg ? -ret : ret;\n}\ntemplate<> double InputF() {\n\tdouble ret = 0, dp = 1; bool neg = false, adp = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile (('0' <= c && c <= '9') || c == '.') {\n\t\tif (c == '.') { adp = true; }\n\t\telse if (adp) { dp *= 0.1; ret += (c - '0') * dp; }\n\t\telse { ret = ret * 10.0 + (c - '0'); }\n\t\tc = getchar_unlocked();\n\t}\n\treturn neg ? -ret : ret;\n}\nstring GetLine() {\n\tstring ret; char c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n') { ret.push_back(c); c = getchar_unlocked(); }\n\treturn ret;\n}\n\ntemplate<class T>T StoT(string s) { return s; }\ntemplate<> char StoT(string s) { return s.front(); }\ntemplate<> string StoT(string s) { return s; }\ntemplate<> int StoT(string s) { return stoi(s); }\ntemplate<> LL StoT(string s) { return stoll(s); }\ntemplate<> double StoT(string s) { return stod(s); }\n\nVS InputB;\ntemplate<class T>struct InputC {\n\toperator T() { return InputF<T>(); }\n\tvector<T> operator[](int h) {\n\t\tvector<T> ret(h);\n\t\trep(i, h)ret[i] = InputF<T>();\n\t\treturn ret;\n\t}\n\tvector<vector<T>> operator[](PII p) {\n\t\tint h, w; tie(h, w) = p;\n\t\tvector<vector<T>> ret(h, vector<T>(w));\n\t\trep(i, h)rep(j, w)ret[i][j] = InputF<T>();\n\t\treturn ret;\n\t}\n\tT at(int n) {\n\t\twhile (sz(InputB) <= n)InputB.pb(InputF<string>());\n\t\treturn StoT<T>(InputB[n]);\n\t}\n\tvector<T> at(int n, int h) {\n\t\tvector<T> ret(h);\n\t\trep(i, h)ret[i] = at(i + n);\n\t\treturn ret;\n\t}\n\tvector<vector<T>> at(int n, int h, int w) {\n\t\tvector<vector<T>> ret(h, vector<T>(w));\n\t\trep(i, h)rep(j, w)ret[i][j] = at(n + i * w + j);\n\t\treturn ret;\n\t}\n};\nInputC<char> inc; InputC<string> ins; InputC<int> ini; InputC<LL> inl; InputC<double> ind;\n\n/* OUTPUT */\nclass ostreamfbuff : public basic_streambuf<char, char_traits<char>> {\nprotected:int overflow(int nCh = EOF) { putchar_unlocked(nCh); return 0; }\n};\nclass ostreamf : public basic_iostream<char, char_traits<char>> {\npublic:ostreamf(void) : basic_iostream<char, char_traits<char>>(new ostreamfbuff()) {}\n};\nostreamf coutf; ostream& operator<<(ostream& ostr, InputC<string> i) { ostr << string(i); return ostr; }\nstruct BoolStr { string t, f; BoolStr(string _t, string _f) :t(_t), f(_f) {} }yes(\"yes\", \"no\"), Yes(\"Yes\", \"No\"), YES(\"YES\", \"NO\"), Yay(\"Yay!\", \":(\");\nstruct Divizer { string s; Divizer(string _s) :s(_s) {} }spc(\" \"), nosp(\"\"), comma(\",\"), lin(\"\\n\");\nstruct Output {\n\tbool flag = false; BoolStr bs; Divizer di;\n\tOutput(bool f, BoolStr b, Divizer d) :flag(f), bs(b), di(d) {}\n\ttemplate<class T>void print(T o) { coutf << o; }\n\tvoid print(double o) { printf(\"%.20f\", o); }\n\tvoid print(bool o) { coutf << (o ? bs.t : bs.f); }\n\ttemplate<class T, class U>void print(const pair<T, U>& o) {\n\t\tprint(o.first); coutf << di.s; print(o.second);\n\t}\n\ttemplate<class T>void print(const vector<T>& o) {\n\t\tfor (int i = 0; i < (int)o.size(); ++i) { if (i != 0)coutf << di.s; print(o[i]); }\n\t}\n\ttemplate<class T>void print(const vector<vector<T>>& o) {\n\t\tfor (int i = 0; i < (int)o.size(); ++i) { if (i != 0)coutf << '\\n'; print(o[i]); }\n\t}\n\ttemplate<class T, class U>void print(const map<T, U>& o) {\n\t\tcoutf << \"Map\"; for (auto a : o) { coutf << \" {\"; print(a); coutf << \"},\"; } coutf << '\\n';\n\t}\n\ttemplate<class T>void print(const set<T>& o) {\n\t\tcoutf << \"Set {\"; for (auto a : o) { print(a); coutf << \",\"; } coutf << \"}\\n\";\n\t}\n\ttemplate<class T>Output operator ,(T o) {\n\t\tif (flag)coutf << di.s; print(o); Output t(true, bs, di); return t;\n\t}\n\tOutput operator,(Output o) { coutf << '\\n'; return o; }\n\tOutput operator,(BoolStr b) { Output t(flag, b, di); return t; }\n\tOutput operator,(Divizer d) { Output t(flag, bs, d); return t; }\n}out(false, Yes, spc);\n\n/* ANSWER */\nstruct Answer {\n\tint mini = INT_MAX, maxi = INT_MIN, sumi = 0;\n\tLL minl = LLONG_MAX, maxl = LLONG_MIN, suml = 0;\n\tdouble mind = DBL_MAX, maxd = DBL_MIN, sumd = 0; int cnt = 0;\n\tvoid operator=(int n) { mini = min(mini, n); maxi = max(maxi, n); sumi += n; cnt++; }\n\tvoid operator=(LL n) { minl = min(minl, n); maxl = max(maxl, n); suml += n; cnt++; }\n\tvoid operator=(double n) { mind = min(mind, n); maxd = max(maxd, n); sumd += n; cnt++; }\n}ans;\n\n\nstruct Point {\n\tint x, y;\n\tPoint() :x(-1), y(-1) {}\n\tPoint(int _x, int _y) :x(_x), y(_y) {}\n\tPoint operator+() { return *this; }\n\tPoint operator-() { return { -x,-y }; }\n\tPoint operator+(const Point& p) { return { x + p.x,y + p.y }; }\n\tPoint operator-(const Point& p) { return { x - p.x,y - p.y }; }\n\tPoint operator*(const Point& p) { return { x * p.x,y * p.y }; }\n\tPoint operator/(const Point& p) { return { x / p.x,y / p.y }; }\n\tPoint operator+(int d) { return { x + d,y + d }; }\n\tPoint operator-(int d) { return { x - d,y - d }; }\n\tPoint operator*(int d) { return { x * d,y * d }; }\n\tPoint operator/(int d) { return { x / d,y / d }; }\n\tPoint& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tPoint& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tPoint& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tPoint& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tbool operator==(const Point& p) { return x == p.x && y == p.y; }\n\tbool operator!=(const Point& p) { return x != p.x || y != p.y; }\n\tPoint& set(int _x, int _y) { x = _x; y = _y; return *this; }\n\tPoint& set(const Point& p) { return *this = p; }\n\tint Dist(const Point& p) { return abs(x - p.x) + abs(y - p.y); }\n\tbool inBound(int H, int W) { return 0 <= x && x < W && 0 <= y && y < H; }\n\tarray<Point, 4> Adjacent4() {\n\t\tarray<Point, 4> ret = { Point(x,y + 1),Point(x,y + -1),Point(x + 1,y),Point(x + -1,y) };\n\t\treturn ret;\n\t}\n\tarray<Point, 8> Adjacent8() {\n\t\tarray<Point, 8> ret = { Point(x,y + 1),Point(x,y - 1),Point(x + 1,y),Point(x - 1,y),\n\t\t\tPoint(x + 1,y + 1),Point(x + 1,y + -1),Point(x - 1,y + 1),Point(x - 1,y - 1) };\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tVVI Map = ini[{3, 3}];\n\n\tqueue<VVI> q;\n\tq.push(Map);\n\tmap<VVI, int> flag;\n\tflag[Map] = 0;\n\n\tauto Check = [](VVI v) {\n\t\tbool flag = true;\n\t\trep(i, 3)rep(j, 3) {\n\t\t\tif (i == 2 && j == 2) {\n\t\t\t\tif (v[i][j] != 0)flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (v[i][j] != i * 3 + j + 1)flag = false;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t};\n\n\tint Ans;\n\n\twhile (!q.empty()) {\n\t\tauto Fro = q.front(); q.pop();\n\t\tPoint Fro0; rep(i, 3)rep(j, 3)if (Fro[i][j] == 0)Fro0.set(j, i);\n\t\tif (Check(Fro)) {\n\t\t\tAns = flag[Fro]; break;\n\t\t}\n\n\t\tfor (auto P : Fro0.Adjacent4())if (P.inBound(3, 3)) {\n\t\t\tauto Next = Fro; swap(Next[Fro0.y][Fro0.x], Next[P.y][P.x]);\n\t\t\tif (!flag.count(Next)) {\n\t\t\t\tq.push(Next);\n\t\t\t\tflag[Next] = flag[Fro] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tout, Ans, out;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 50\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p) const{\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i]==p.f[i]) continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\n\nstatic const int dy[4]={0,-1,0,1};\n\nstatic const char dir[4]={'u','a','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i<N2;i++){\n\t\tif(p.f[i]!=(i+1)) return false;\n\t}\n\treturn true;\n}\n\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\n\nint main(){\n\tPuzzle in;\n\t\n\tfor(int i=0;i<N2;i++){\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0){\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\t\n\tstring ans = bfs(in);\n\t\n\tcout<<ans.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const{\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i<N2;i++)\n\t\tif(p.f[i] != (i+1)) return false;\n\treturn  true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile(!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor(int i=0;i<N2;i++){\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct puzzle{\n    int F[N2];\n    int space;\n    string path;\n    \n    bool operator < (const puzzle &p) const{\n        for(int i=0; i<N2;i++){\n            if(F[i]==p.F[i])continue;\n            return F[i] > p.F[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool Target(puzzle p){\n    for(int i=0; i<N2; i++)\n    if(p.F[i]!=(i+1)) return false;\n    return true;\n}\n\nstring bfs(puzzle s){\n    queue<puzzle> Q;\n    map<puzzle,bool> V;\npuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\n\nwhile(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(Target(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    \n    for(int r=0; r<4; r++){\n        int tx=sx+dx[r];\n        int ty=sy+dy[r];\n        if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n        v=u;\n        swap(v.F[u.space],v.F[tx*N+ty]);\n        v.space=tx*N+ty;\n        if(!V[v]){\n            V[v]=true;\n            v.path +=dir[r];\n            Q.push(v);\n        }\n    }\n}\n\nreturn \"unsolvable\";\n}\n\nint main(){\n    puzzle in;\n    for(int i=0;i<N2;i++){\n        cin >> in.F[i];\n        if(in.F[i]==0){\n            in.F[i]=N2;\n                in.space=i;\n            }\n        }\n        string ans = bfs(in);\n        cout << ans.size() << endl;\n        \n        return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000;\nint mapp[3+2][3+2],dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nbool used[3+2][3+2];\nint x0,y0,ans(INF);\nvoid otpt(){\n\tfor(int i=0;i<3;i++){\n\t    for(int j=0;j<3;j++)\n\t        cout<<mapp[i][j]<<' ';\n\t    cout<<endl;\n\t}\n\tcout<<endl;\n\tcin.get();\n}\nvoid init(){\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++){\n\t    \tcin>>mapp[i][j];\n\t    \tif(!mapp[i][j]){\n\t    \t\tx0=i;\n\t    \t\ty0=j;\n\t    \t}\n\t    }\n}\nbool ook(){\n\tint a(1);\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(mapp[i][j]!=a&&mapp[i][j]) return false;\n\t\t\telse ++a;\n\t\t}\n\t}\n\t//otpt();cout<<\"!!!!!!\"<<endl;\n\treturn true;\n}\nvoid dfs(int x,int y,int bs){\n\tint bf[3+2][3+2];\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++)\n\t        bf[i][j]=mapp[i][j];\n\tif(bs>ans) return;\n\telse{\n\t\tif(ook()){\n\t\t\t//cout<<\"233?\"<<endl;\n\t\t\tans=min(bs,ans);\n\t\t\treturn;\n\t\t} \n\t\t//cout<<'#'<<bs<<':'<<endl;otpt();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx(x+dx[i]),yy(y+dy[i]);\n\t\t\tif(xx>=0&&yy>=0&&xx<3&&yy<3&&!used[xx][yy]){\n\t\t\t\tswap(mapp[x][y],mapp[xx][yy]);\n\t\t\t\tused[xx][yy]=1;\n\t\t\t\tdfs(xx,yy,bs+1);\n\t            for(int i=0;i<3;i++)\n\t                for(int j=0;j<3;j++)\n\t                    mapp[i][j]=bf[i][j];\n\t\t\t\tused[xx][yy]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sol(){\n\tdfs(x0,y0,0);\n\tcout<<ans<<endl;\n}\nint main(){\n\tinit();\n\tsol();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N  3\n#define N2 9\n\nstatic const int dx[4]   = {-1,0,1,0};\nstatic const int dy[4]   = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const {\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\n\n\nbool isTarget(Puzzle x){\n  for(int i=0;i<N2;i++)\n    if(x.f[i]!=(i+1))   return false;\n    return true;\n}\n\nstring bfs(Puzzle start){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  start.path = \"\";\n  Q.push(start);\n  V[start] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u))return u.path;\n    int xStart = u.space / N;\n    int yStart = u.space % N;\n\n    for(int k=0;k<4;k++){\n\t    int xTarget = xStart + dx[k];\n\t    int yTarget = yStart + dy[k];\n\t    if(xTarget<0 || yTarget<0 || xTarget >=N || yTarget>=N) continue;\n\t    v = u;\n\t    swap(v.f[u.space],v.f[xTarget*N+yTarget]);\n\t    v.space = xTarget*N+yTarget;\n\t    if(!V[v]){\n\t      V[v] = true;\n\t      v.path += dir[k];\n\t      Q.push(v);\n\t    }\n    }\n  }\n  return NULL;\n}\n  \n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]  = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout<<ans.size()<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t\tin.f[i] = N2;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define N 3\n#define N2 9\n  \nstruct 8puzzle{\nint f[N2];\nint space;\nstring path;\n  \nbool operator < (const 8puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n  \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n  \nbool isTarget(8puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n  \nstring bfs(8puzzle s){\nqueue<8puzzle> Q;\nmap<8puzzle, bool> V;\n8puzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n  \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"\";\n}\n  \nint main(){\n8puzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n  \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint max;\n\tint cnt = 0;\n\n\tint f(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint c = a[i][j];\n\t\t\t\tif (c == 0)\n\t\t\t\t\tc = size * size - 1;\n\t\t\t\telse\n\t\t\t\t\tc--;\n\t\t\t\tl += abs(i - c / 3) + abs(j - c % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tmax = f(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\n\tint solver() {\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n//\t\t\ta.print();\n\t\t\tint dis = f(a.b);\n\t\t\tif (dis > max * 2.1 - a.cnt)\n\t\t\t\tcontinue;\n//\t\t\tout(dis, \"\\n\");\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!dis)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost();\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \n#define tate 3\n#define yoko 3\n#define total 9\n#define TryCnt 45\n \nextern inline void down_0(void);    \nextern inline void up_0(void);      \nextern inline void right_0(void);   \nextern inline void left_0(void);    \n \nextern int  serch(int x, int y, int MaxCnt, int pre);\n \nint num = 0;        \nint val[total] ={}; \n \n \nint main( void )\n{\n  int i = 0;\n  int x,y = 0;\n     \n    \n  for(i=0; i<total; i++)\n    {\n      scanf(\"%d\",&val[i]);\n         \n      if(val[i] == 0)\n        {\n\t  num = i;\n        }\n    }\n     \n   \n  x = tate - (num/yoko) -1;\n  y = yoko - (num%yoko) -1;\n     \n  for(i=0; i<TryCnt; i++)\n    {\n      if( serch(x,y,i,4) == 1 )\n        {\n\t  printf(\"%d\\n\",i);\n\t  break;\n        }\n    }     \n     \n  return 0;\n}\n \nint serch(int x, int y, int MaxCnt, int pre)\n{\n  int result;\n  int i=0;\n     \n  if(MaxCnt < (x + y) )\n    {\n      return 0;\n    }\n     \n   \n  if(MaxCnt==0)\n    {\n      for(i=0; i<total-1; i++)\n        {\n\t  if(val[i] != (i+1))\n            {      \n\t      return 0;\n            }\n        }\n      return 1;\n    }\n     \n     \n  \n  for(i=0; i<4; i++)\n    {\n      result = 0;\n         \n      switch(i)\n        {\n\tcase 0:\n\t  if( (x > 0) && (pre != 3) )\n\t    {\n\t      down_0();\n                     \n\t      result = serch(x-1, y, MaxCnt-1, 0);\n                     \n\t      up_0();\n\t    }\n\t  break;\n                 \n\tcase 1:\n\t  if( (y > 0) && (pre != 2) )\n\t    {\n\t      right_0();\n                     \n\t      result = serch(x, y-1, MaxCnt-1, 1);\n                     \n\t      left_0();\n\t    }\n\t  break;\n                 \n\tcase 2:\n\t  if( (y < yoko -1 ) && (pre != 1) )\n\t    {\n\t      left_0();\n                     \n\t      result = serch(x, y+1, MaxCnt-1, 2);\n                     \n\t      right_0();\n\t    }\n\t  break;\n                 \n\tcase 3:\n\t  if( (x < tate -1 ) && (pre != 0) )\n\t    {\n\t      up_0();\n                     \n\t      result = serch(x+1, y, MaxCnt-1, 3);\n                     \n\t      down_0();\n\t    }\n\t  break;\n                 \n\tdefault:\n\t  break;\n        }\n         \n      if(result)\n        {\n\t  return 1;\n        }\n    }\n     \n  return 0;\n}\n \n \ninline void down_0()\n{\n  val[num] = val[num + yoko];\n  num = num + yoko;\n}\n  \ninline void up_0()\n{\n  val[num] = val[num - yoko];\n  num = num - yoko;\n}\n  \ninline void right_0()\n{\n  val[num] = val[num +1];\n  num = num + 1;\n}\n  \ninline void left_0()\n{\n  val[num] = val[num -1];\n  num = num - 1;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p)const{\nfor(int i=0;i<N2;i++){\nif(f[i]==p.f[i])continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1))return false;\nreturn true;\n}\nstring bfs(Puzzle s){\nqueue<Puzzle>Q;\nmap<Puzzle,bool>V;\nPuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\nwhile(!Q.empty()){\n  u=Q.front();\n  Q.pop();\n  if(isTarget(u))return u.path;\n  int sx=u.space/N;\n  int sy=u.space%N;\n  for(int r=0 ; r<4 ; r++){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n    v=u;\n    swap(v.f[u.space], v.f[tx*N+ty]);\n    v.space=tx*N+ty;\n    if(!V[v]){\n      V[v]=true;\n      v.path+=dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0 ; i<N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n    in.f[i]=N2;\n    in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nconst bool direction[9][4] = {{false, false, true, true},\n                              {true, false, true, true},\n                              {true, false, true, false},\n                              {false, true, true, true},\n                              {true, true, true, true},\n                              {true, true, true, false},\n                              {false, true, false, true},\n                              {true, true, false, true},\n                              {true, true, false, false},\n                              {true, true, false, false}}\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    bool dir[4] = dir[zero];\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nint main()\n{\n    8puzzle in;\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\nstruct 8puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const 8puzzle & p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(8puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(8puzzle s)\n{\n    queue<8puzzle> Q;\n    map<8puzzle, bool> V;\n    8puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n\n#define DIVN 3\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint PtoI(std::vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nstd::vector<int> ItoP(int ii){\n\tstd::vector<int> tmp, result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (x == -1){\n\t\t\tresult[curindex] = -1;\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(std::vector<int> P){\n\tstd::list<int> Que;\n\tQue.push_back(PtoI(P));\n\tint answer;\n\tstd::vector<int> Puzzles(fact(DIVN*DIVN), -1);\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tstd::vector<int> Q = ItoP(Que.front());\n\t\tQue.pop_front();\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1 ){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tstd::vector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// äºé ä¿æ°è¨ç®\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nint n;\nvector<pii> es[100010];\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode *parent, *left, *right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node *t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node *t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node *t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node *t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]){\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H/2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\nll lcs(string s1, string s2) {\n\tll dp[1010][1010];\n\tmemset(dp, 0, sizeof(dp));\n\tint s1l = s1.size();\n\tint s2l = s2.size();\n\tfor (size_t i = 1; i <= s1l; i++)\n\t{\n\t\tfor (size_t j = 1; j <= s2l; j++)\n\t\t{\n\t\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s1l][s2l];\n}\nstruct edge {\n\tll to, cap, rev;\n\tedge(int to,int cap,int rev) : to(to),cap(cap),rev(rev){}\n};\nvector<edge> ed[100010];\nvoid addedge(int f, int t, int c) {\n\ted[f].push_back(edge(t, c, ed[t].size()));\n\ted[t].push_back(edge(f, 0, ed[f].size() - 1));\n}\nvector<int> es2[100010];\n\nll d[100010];\nvoid dij(int x) {\n\n\td[x] = 0;\n\tpriority_queue<pll, vector<pll>, greater<pll>> q;\n\tq.push(pll(0, x));\n\twhile (!q.empty())\n\t{\n\t\tpll p = q.top();\n\t\tq.pop();\n\t\tif (d[p.second] < p.first) continue;\n\t\tfor (auto v : ed[p.second]) {\n\t\t\tif (d[v.to] > d[p.second] + v.cap) {\n\t\t\t\td[v.to] = d[p.second] + v.cap;\n\t\t\t\tq.push(pll(d[v.to], v.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check(vector<vector<int>> tb) {\n\tint p = 1;\n\n\tfor (size_t i = 0; i < 3; i++)\n\t{\n\t\tfor (size_t j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (tb[i][j] != p) return false;\n\t\t\tp++;\n\t\t\tp %= 9;\n\t\t}\n\t}\n\treturn true;\n}\nint dx[] = { 0, -1, 0, 1 };\nint dy[] = { 1, 0, -1, 0 };\nmap<vector<vector<int>>, int> mp;\nint rec(vector<vector<int>> tb) {\n\tif (check(tb)) \n\t\treturn 0;\n\tpriority_queue<pair<int, vector<vector<int>>>, vector< pair<int, vector<vector<int>>>>, greater< pair<int, vector<vector<int>>>>> q;\n\tq.push(make_pair(0, tb));\n\tint res = INF;\n\twhile (!q.empty())\n\t{\n\t\tauto p = q.top();\n\t\tq.pop();\n\t\tif (mp.count(p.second) && mp[p.second] <= p.first) continue;\n\t\tmp[p.second] = p.first;\n\t\tauto tt = p.second;\n\t\tint x = -1, y;\n\t\tfor (size_t i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j  < 3; j ++)\n\t\t\t{\n\t\t\t\tif (tt[i][j] == 0) {\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x != -1) break;\n\t\t}\n\n\t\tfor (size_t i = 0; i < 4; i++)\n\t\t{\n\t\t\tint tx, ty;\n\t\t\ttx = x + dx[i];\n\t\t\tty = y + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || ty >= 3 || tx >= 3) continue;\n\t\t\tswap(tt[x][y], tt[tx][ty]);\n\t\t\tq.push(make_pair(p.first + 1, tt));\n\t\t\tif (check(tt)) {\n\t\t\t\treturn p.first + 1;\n\t\t\t}\n\t\t\tswap(tt[tx][ty],tt[x][y]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid solv() {\n\n\tint sx, sy;\n\tauto tb = vector<vector<int>>(3, vector<int>(3, 0));\n\tfor (size_t i = 0; i < 3; i++)\n\t{\n\t\tfor (size_t j = 0; j < 3; j++)\n\t\t{\n\t\t\tcin >> tb[i][j];\n\t\t\tif (tb[i][j] == 0) {\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << rec(tb) << endl;\n}\n\nint main() {\n\t//\tCOMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Pizzle p){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!=Q.empty()){\n    u=Q.front();Q.pop();\n    is(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(wrongs + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstruct Puzzle {\n\tint f[N2], space;\n\tstring path;\n\tbool operator <(const Puzzle p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || tx >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\nbool rec(string v,int index,int step,int limit){\n  if(limit<step)return false;\n  if(v==ans)return true;\n  FOR(i,0,4){\n    if(index%3==0 && d[i]==-1)continue;\n    if((index+1)%3==0 && d[i]==1)continue;\n    if(index<=2 && d[i]==-3)continue;\n    if(6<=index && d[i]==3)continue;\n    string u = v;\n    swap(u[index],u[index+d[i]]);\n    if(rec(u,index+d[i],step+1,limit))return true;\n  }\n  return false;  \n}\n\nint solve(){\n  int ans = 0;\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  while(!rec(s,ind,0,ans))ans++;\n  return ans;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false);\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define M 9\n#define O 4\n\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for(int i = 0;i < M;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[O] = {-1, 0, 1, 0};\nstatic const int dy[O] = {0, -1, 0, 1};\nstatic const int dir[O] = {'u', 'l', 'd', 'r'};\n\nbool isTarget (Puzzle p){\n  int i;\n  for(i = 0;i < M;i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < O;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 ||ty < 0 ||tx >= N ||ty >= N)continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if( !V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  int i;\n\n  for(i = 0;i < M;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = M;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(char a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tchar board[3][3];\n\tchar distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tcin >> start.board[i][j];\n\n\t\t\tstart.board[i][j] -= 48;\n\t\t}\n\t}\n\n\tqueue<puzzle> que; que.push(start);\n\n\tchar Ans = 0, x, y, i, j, dir;\n\n\tpuzzle p, q;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tp = que.front(); que.pop();\n\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tq = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << (int)Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tTPuzzle Result = Puzzle;\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Result[Row][Col], Result[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Result[Row][Col], Result[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Result[Row][Col], Result[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Result[Row][Col], Result[Row][Col + 1]);break;\n\tdefault : break;\n\t}\n\treturn Result;\n}\n\nint CountMove(const std::set<TPuzzle>& Before, const TPuzzle& Goal, int Count)\n{\n\tif(Before.find(Goal) != Before.end()) return Count;\n\tstd::set<TPuzzle> Next;\n\tfor(std::set<TPuzzle>::const_iterator It = Before.begin(); It != Before.end(); ++It){\n\t\tconst TPuzzle& Puzzle = *It;\n\t\tif(Movable(Puzzle, mpUp))    Next.insert(Move(Puzzle, mpUp));\n\t\tif(Movable(Puzzle, mpDown))  Next.insert(Move(Puzzle, mpDown));\n\t\tif(Movable(Puzzle, mpLeft))  Next.insert(Move(Puzzle, mpLeft));\n\t\tif(Movable(Puzzle, mpRight)) Next.insert(Move(Puzzle, mpRight));\n\t}\n\treturn CountMove(Next, Goal, 1 + Count);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> Start;\n\tStart.insert(Puzzle);\n\treturn CountMove(Start, Goal, 0);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int MAXN=1000010;\nconst int MOD=1000007;\nstring st;\nstring en=\"123456780\";\nint head[MAXN],nex[MAXN];\nint f[MAXN],top;\nstring ss[MAXN];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nqueue<string> q;\nqueue<int> qs;\nvoid input()\n{\n\tmemset(head,-1,sizeof(head));\n\tmemset(nex,-1,sizeof(nex));\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++){\n\t    \tchar c;\n\t        cin>>c;\n\t        st+=c;\n\t    }\n\t//cout<<st<<endl;\n}\n\nint has(string s){\n\tint sum(0);\n\tfor(int i=0;i<9;i++){\n\t\tsum*=10;\n\t\tsum+=s[i]-'0';\n\t}\n\treturn sum;\n}\n\nvoid add(string tt){\n\tint tmp=has(tt);\n\tnex[top]=head[tmp%MOD];\n\thead[tmp%MOD]=top;\n\tss[top++]=tt;\n}\n\nbool ff(string tt){\n\tint tmp=has(tt);\n\tint u=head[tmp%MOD];\n\twhile(u!=-1){\n\t\tstring ttt=ss[u];u=nex[u];\n\t\tif(ttt==tt) return true;\n\t}\n\treturn false;\n}\n\nvoid xxj()\n{\n\tq.push(st);\n\tadd(st);\n\tqs.push(0);\n\twhile(!q.empty()){\n\t\tstring tmp=q.front();q.pop();\n\t\tint ts=qs.front();qs.pop();\n\t\t//if(ts==4) cout<<tmp<<' '<<ts<<endl;\n\t\tif(tmp==en) {cout<<ts<<endl;return;}\n\t\tint pos=tmp.find('0');\n\t\tint x=pos/3,y=pos%3;\n\t\t//cout<<x<<' '<<y<<endl;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint xx=x+dx[k];\n\t\t\tint yy=y+dy[k];\n\t\t\tif(xx<0 || yy<0 || xx>=3 || yy>=3) continue;\n\t\t\tstring tt=tmp;\n\t\t\tswap(tt[xx*3+yy],tt[pos]);\n\t\t\tif(!ff(tt)){\n\t\t\t\tq.push(tt);\n\t\t\t\tqs.push(ts+1);\n\t\t\t\tadd(tt);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinput();\n\txxj();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 9\n\nstruct data{\n  int f[N];\n  int move;\n  string path;\n\n  bool operator < (const data &p) const {\n    for(int i = 0;i < N;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char where[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(data);\nstring bfs(data);\n\nint main(){\n  data a;\n  int i;\n  string c;\n\n  for(i = 0;i < N;i++){\n    cin >> a.f[i];\n    if(a.f[i] == 0){\n      a.f[i] = N;\n      a.move = i;\n    }\n  }\n  c = bfs(a);\n  cout << c.size() << endl;\n\n  return 0;\n}\n\nbool isTarget(data p){\n  int i;\n  \n  for(i = 0;i < N;i++){\n    if(p.f[i] != (i + 1)) return 0;\n  }\n    return 1;\n}\n\nstring bfs(data p){\n  queue<data> Q;\n  map<data,bool> V;\n  data x,y;\n  int px,py,tx,ty,i;\n  p.path = \"\";\n  Q.push(p);\n  V[p] = 1;\n\n  while(!Q.empty()){\n    x = Q.front(); Q.pop();\n    if(isTarget(x)) return x.path;\n    px = x.move / (N/3);\n    py = x.move % (N/3);\n    for(i = 0;i < 4;i++){\n      tx = px + dx[i];\n      ty = py + dy[i];\n      if(tx < 0 || ty < 0 || tx >= (N/3) || ty >= (N/3)) continue;\n      y = x;\n      swap(y.f[x.move],y.f[tx * (N/3) + ty]);\n      y.move = tx * (N/3) + ty;\n      if(!V[y]){\n\tV[y] = 1;\n\ty.path += where[i];\n\tQ.push(y);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define NN 9\n \nstruct Puzzle {\n  int f[NN];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const {\n    for(int i=0; i<NN; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const int x[4] = {-1, 0, 1, 0};\nstatic const int y[4] = {0, -1, 0, 1};\nstatic const char dr[4] = {'u', 'l', 'd','r'};\n \nbool isTarget(Puzzle p) {\n  for(int i=0; i<NN; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n string bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n   while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0; r<4; r++){\n      int tx = sx+x[r];\n      int ty = sy+y[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dr[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n \nint main(){\n  Puzzle p;\n for(int i=0; i<NN; i++){\n    cin >> p.f[i];\n    if(p.f[i] == 0){\n      p.f[i] = NN;\n      p .space = i;\n    }\n  }\n  string ans = bfs(p);\n  cout << ans.size() << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ref : https://book.mynavi.jp/ec/products/detail/id=35408\n\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2]; // 9ãã¹ã®ç¶æ\n\tint space; // é·ç§»ã®èµ·ç¹ã¨ãªãã¹ãã¼ã¹ä½ç½®\n\tstring path; // ã¹ãã¼ã¹ã®ç§»åæ¹åãæå­ï¼dir[4]ï¼ã®çµã¿åããã§è¨é²\n\n\t// mapã«ããäºåæ¢ç´¢æ¨ãä½¿ãããã®è¦ç´ ã®å¤§å°é¢ä¿ã®å®ç¾©\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// ã¹ãã¼ã¹ã¨é£ãåãä½ç½®ã¸ã®åº§æ¨ç§»å\nstatic const int dx[4] = { -1, 0, 1, 0 };\nstatic const int dy[4] = {  0,-1, 0, 1 };\nstatic const char dir[4] = { 'u', 'l', 'd', 'r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++)\n\t\tif (p.f[i] != (i + 1)) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N; // ã¹ãã¼ã¹ã®xåº§æ¨ã«å¤æ\n\t\tint sy = u.space % N; // ã¹ãã¼ã¹ã®yåº§æ¨ã«å¤æ\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r]; // äº¤æå¯¾è±¡ã®xåº§æ¨\n\t\t\tint ty = sy + dy[r]; // äº¤æå¯¾è±¡ã®xåº§æ¨\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue; // ãã¹å¤ã®ç¡å¹åº§æ¨\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]); // ã¹ãã¼ã¹ã¨äº¤æå¯¾è±¡ãäº¤æ\n\t\t\tv.space = tx * N + ty; // ã¹ãã¼ã¹ã®ä½ç½®ãæ´æ°\n\t\t\tif ( !V[v] ) { // äº¤æå¾ã®ç¶æãå­å¨ããªããã°èªåçã«falseã§è¦ç´ ãæ°è¦ä½æããã\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r]; \n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2; // ã¹ãã¼ã¹ã¯0ããN2ã«å½¢å¼å¤æ´\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl; // ç§»åæ¹åã®è¨é²ã®æå­æ°ããã¹ãã¼ã¹ã®äº¤æåæ°ãåå¾\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 25\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 50\n\n#define MAX 500000000\nbool passed[MAX];\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\nint rtnindex(STATUS in){\n    \n    int ret = 0;\n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            ret += val*in.board[i][j];\n            val *= 9;\n        }\n    }\n    return ret;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            int rtn = rtnindex(out);\n            if (passed[rtn] == true) {\n                continue;\n            }\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n            passed[rtn] = true;\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    for (int i = 0; i < MAX; i++) passed[i] = false;\n    \n    passed[rtnindex(init)] = true;\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<utility>\nusing namespace std;\n#define TxT for(int i = 0; i < 3; i++)for(int j = 0; j < 3; j++)\n\ntypedef struct tep{\n\tint e[3][3];\n\tint c;\n\tbool operator  < (const tep& r) const{\n\t\tTxT if(e[i][j] > r.e[i][j]) return true;\n\t\treturn false;\n\t}\n\t// bool operator  == (const tep& r) const{\n\t\t// TxT if(e[i][j] != r.e[i][j]) return false;\n\t\t// return true;\n\t// }\n} EP;\n\nmap<int,bool> z;\nEP e;\nint dxy[] = {1,-1,0,0};\n\nint hogefuga(EP hoge){\n\tint ten = 1, re = 0;\n\tTxT re += ten*hoge.e[i][j],ten*=10;\n\treturn re;\n}\n\nint fugafuga(EP hoge){\n\tint count = 1, count2 = 0;\n\tTxT{ if(hoge.e[i][j] != (count++)%9) count2++;}\n\treturn count2;\n}\n\nvoid print(EP hoge){\t\n\tcout<<hoge.c<<\" +++++ \"<<endl;;\n\tcout<<hogefuga(hoge)<<endl;\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++) cout<<hoge.e[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n\tstring hogehogehoge;\n\tcin>>hogehogehoge;\n}\n\nbool hogehoge(EP hoge){\n\tint count = 1;\n\tTxT{ if(hoge.e[i][j] != (count++)%9) return false;}\n\treturn true;\n}\n\nvoid fuga(queue<EP> &Q, EP hoge){\n\tint x, y, mi = 10, t, ti;\n\t\n\tTxT if(hoge.e[i][j] == 0)y = i, x = j;\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tint ny = y + dxy[i], nx = x + dxy[3-i];\n\t\tif(ny < 0 || ny >= 3 || nx < 0 || nx >= 3) continue;\n\t\tEP fuga = hoge;\n\t\tswap(fuga.e[y][x],fuga.e[ny][nx]);\n\t\t\n\t\tif(z[hogefuga(fuga)]) continue;\n\t\telse z[hogefuga(fuga)] = true;\n\t\tfuga.c = hoge.c+1;\n\t\tQ.push(fuga);\n\t\t\n\t\t// if((t = fugafuga(fuga)) < mi){\n\t\t\t// mi = t, ti = i;\n\t\t// }\n\t\t\n\t\t\n\t\t// fuga.c = hoge.c+1;\n\t\t// Q.push(fuga);\n\t}\n\t// if(mi != 10){\n\t\t// int ny = y + dxy[ti], nx = x + dxy[3-ti];\n\t\t// EP fuga = hoge;\n\t\t// swap(fuga.e[y][x],fuga.e[ny][nx]);\n\t\t// fuga.c = hoge.c+1;\n\t\t// Q.push(fuga);\n\t\t// z[hogefuga(fuga)] = true;\n\t// }\n}\n\nint solve(){\n\tqueue<EP> Q;\n\t\n\te.c = 0;\n\t\n\tQ.push(e);\n\t\n\twhile(!Q.empty()){\n\t\tEP hoge = Q.front(); Q.pop();//print(hoge);\n\t\tfuga(Q,hoge);\n\t\tif(hogehoge(hoge)) return hoge.c;\n\t}\n}\n\nint main(){\n\t\n\tTxT cin>>e.e[i][j];\n\t\n\t//z[hogefuga(e)] = true;\n\t\n\tcout<<solve()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> > Q;\n \nvoid Sw(string st,int x)\n{\n    int i;\n    int pos,npos;\n    int d[4]={-3,3,-1,1};\n    string st1;\n     \n    for(i=0;i<=8;i++)\n    {\n        if(st[i]=='0')\n        {\n            pos=i;\n            break;\n        }\n    }\n    for(i=0;i<=3;i++)\n    {\n        st1=st;\n        if(i==2 && pos%3==0) continue;\n        if(i==3 && pos%3==2) continue;\n        npos=pos+d[i];\n        if(npos>=9 || npos<=-1) continue;\n        swap(st1[pos],st1[npos]);\n        Q.push(pair<string,int>(st1,x+1));\n    }\n}\n \nint main()\n{\n    string puzzle=\"\";\n    string goal=\"123456780\";\n    map<string,bool> M;\n    int i,x;\n    string P;\n     \n    for(i=0;i<=8;i++)\n    {\n        cin >> x;\n        puzzle+='0'+x;\n    }\n    Q.push(pair<string,int>(puzzle,0));\n    while(1)\n    {\n        pair<string,int> p=Q.front();\n        Q.pop();\n        P=p.first;\n        x=p.second;\n        if(P==goal)\n        {\n            cout << x << endl;\n            break;\n        }\n        if(M[P]) continue;\n        else M[P]=1;\n        Sw(P,x);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < ( const Puzzle &p ) const {\n    for( int i = 0 ; i <  N2 ; i++ ){\n      if( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const int dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for( int i = 0 ; i < N2 ; i++ )\n    if(p.f[i] != (i + 1) ) return false;\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for( int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if( tx < 0 || ty < 0 ||tx>=N ||ty>=N ) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n\n  for( int i =0 ; i < N2 ; i++ ){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000;\nint mapp[3+2][3+2],dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nint x0,y0,ans(INF);\nstruct edge{\n\tint xa,ya;\n}s[35];\nvoid otpt(int x,int y,int nn){\n\tfor(int i=0;i<3;i++){\n\t    for(int j=0;j<3;j++)\n\t        cout<<mapp[i][j]<<' ';\n\t    cout<<endl;\n\t}\n\tcout<<endl;\n\tfor(int i=0;i<nn;i++) cout<<s[i].xa<<' '<<s[i].ya<<endl;\n\tcin.get();\n}\nvoid init(){\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++){\n\t    \tcin>>mapp[i][j];\n\t    \tif(!mapp[i][j]){\n\t    \t\tx0=i;\n\t    \t\ty0=j;\n\t    \t}\n\t    }\n}\nbool ook(){\n\tint a(1);\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(mapp[i][j]!=a&&mapp[i][j]) return false;\n\t\t\telse ++a;\n\t\t}\n\t}\n\t//otpt();cout<<\"!!!!!!\"<<endl;\n\treturn true;\n}\nbool f(int x,int y,int nn){\n\tfor(int i=0;i<nn;i++)\n\t\tif(x==s[i].xa&&y==s[i].ya){\n\t\t\t//cout<<\"x=\"<<x<<\" y=\"<<y<<endl;\n\t\t\treturn false;\n\t\t} \n\treturn true;\n}\nvoid dfs(int x,int y,int bs){\n\tint bf[3+2][3+2];\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++)\n\t        bf[i][j]=mapp[i][j];\n\tif(bs>ans) return;\n\telse{\n\t\tif(ook()){\n\t\t\t//cout<<\"233?\"<<endl;\n\t\t\tans=min(bs,ans);\n\t\t\treturn;\n\t\t} \n\t\t//cout<<'#'<<bs<<':'<<endl;otpt(x,y,bs);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx(x+dx[i]),yy(y+dy[i]);\n\t\t\tif(xx>=0&&yy>=0&&xx<3&&yy<3&&f(xx,yy,bs)){\n\t\t\t\ts[bs].xa=xx;\n\t\t\t\ts[bs].ya=yy;\n\t\t\t\tswap(mapp[x][y],mapp[xx][yy]);\n\t\t\t\t//used[xx][yy]=1;\n\t\t\t\tdfs(xx,yy,bs+1);\n\t            for(int i=0;i<3;i++)\n\t                for(int j=0;j<3;j++)\n\t                    mapp[i][j]=bf[i][j];\n\t\t\t\t//used[xx][yy]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sol(){\n\tdfs(x0,y0,0);\n\tcout<<ans<<endl;\n}\nint main(){\n\tinit();\n\tsol();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * b.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int N = 3;\nconst int NN = N * N;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\ntypedef unsigned long long ull;\ntypedef pair<int,ull> piul;\ntypedef map<ull,int> muli;\n\n/* global variables */\n\nmuli dists;\n\n/* subroutines */\n\ninline int zeropos(ull bits) {\n  for (int i = 0; i < NN; i++)\n    if (((bits >> (i * 4)) & 0xf) == 0) return i;\n  return -1;\n}\n\ninline ull move(ull u, int p0, int p1) {\n  ull x = (u >> (4 * p1)) & 0xfULL;\n  return ((u | (x << (4 * p0))) & ~(0xfULL << (4 * p1)));\n}\n\n/* main */\n\nint main() {\n  ull st = 0, gl = 0;\n\n  for (int i = 0; i < NN; i++) {\n    ull ai;\n    cin >> ai;\n    st |= (ai << (i * 4));\n  }\n\n  for (int i = 0; i < NN - 1; i++)\n    gl |= ((ull)(i + 1) << (i * 4));\n  //printf(\"st=%09llx, gl=%09llx\\n\", st, gl);\n\n  if (st == gl) {\n    puts(\"0\");\n    return 0;\n  }\n  \n  dists[st] = 1;\n  dists[gl] = -1;\n\n  queue<piul> q;\n  q.push(piul(1, st));\n  q.push(piul(-1, gl));\n\n  int mind = -1;\n\n  while (! q.empty()) {\n    piul u = q.front(); q.pop();\n    int &ud = u.first;\n    ull &ui = u.second;\n\n    int upos = zeropos(ui);\n    int ux = upos % N, uy = upos / N;\n\n    for (int di = 0; di < 4; di++) {\n      int vx = ux + dxs[di], vy = uy + dys[di];\n      if (vx >= 0 && vx < N && vy >= 0 && vy < N) {\n\tint vpos = vy * N + vx;\n\tull vi = move(ui, upos, vpos);\n\n\tint vd = ud + ((ud >= 0) ? 1 : -1);\n\tmuli::iterator mit = dists.find(vi);\n\tif (mit == dists.end()) {\n\t  dists[vi] = vd;\n\t  q.push(piul(vd, vi));\n\t}\n\telse {\n\t  if (ud * mit->second < 0) {\n\t    int d = abs(mit->second - ud) - 1;\n\t    printf(\"%d\\n\", d);\n\t    exit(0);\n\t  }\n\n\t  if ((ud > 0 && mit->second > vd) || (ud < 0 && mit->second < vd)) {\n\t    mit->second = vd;\n\t    q.push(piul(vd, vi));\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n#define H 3\n#define W 3\n#define begin 1\n#define end 4\nstruct BOARD{\n        int board[10][10],y,x,count;\n        bool operator<(const BOARD &other)const{\n                for(int i=begin ; i<end ; i++ )\n                        for(int j=begin ; j<end ; j++ )\n                                if(board[i][j]!=other.board[i][j])\n                                        return true;\n                return true;\n        }\n};\nmap <BOARD,bool> past;\nint direction[5]={-1,0,1,0,-1};\nbool check(BOARD now){\n        int s=1;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        if(now.board[i][j]==s){\n                                s++;\n                                s%=9;\n                        }else return false;\n                }\n        }\n}\nint main(){\n        BOARD board;\n        for(int i=0 ; i<=H+1 ; i++ ){\n                board.board[i][0]=-1;\n                board.board[0][i]=-1;\n                board.board[H+1][i]=-1;\n                board.board[i][W+1]=-1;\n        }\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        cin >> board.board[i][j] ;\n                        if(board.board[i][j]==0){\n                                board.y=i;\n                                board.x=j;\n                        }\n                }\n        }\n        queue<BOARD> circle;\n        board.count=0;\n        circle.push(board);\n        int count=0;\n        while(circle.size()!=0){\n                board=circle.front();circle.pop();\n                if(past[board])continue;\n                past[board]=true;\n                if(board.y<1 || board.y>=4 )continue;\n                if(board.x<1 || board.x>=4 )continue;\n                if(check(board)){\n                        cout << board.count << endl;\n                        break;\n                }\n                for(int i=0 ; i<4 ; i++ ){\n                        int y=board.y+direction[i];\n                        int x=board.x+direction[i+1];\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                        board.count++;\n                        circle.push(board);\n                        board.count--;\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//lec04\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define n 3\n#define n1 9\n\n\nstruct puzz{\n  int m[n1];\n  int space;\n  string path;\n  int operator < (const puzz &p)const{\n    for(int i=0;i<n1;i++){\n      if(m[i]==p.m[i])continue;\n      return m[i] > p.m[i];\n    }\n    return false;\n  }\n};\n\n\nstatic const int x[4]={-1,0,1,0};\nstatic const int y[4]={0,-1,0,1};\nstatic const char c[4]={'u','l','d','r'};\n\nint target(puzz p){\n  for(int i=0;i<n1;i++){\n    if(p.m[i]!=(i+1))return false;\n  }\n  return true;\n}\n\nstring am(puzz p){\n  queue<puzz> Q;\n  map<puzz, int> V;\n  puzz a,b;\n  int tmp;\n  p.path=\"\";\n  Q.push(p);\n  V[p]=true;\n\n  while(!Q.empty()){\n    a=Q.front();\n    Q.pop();\n    if(target(a))return a.path;\n    int xx=a.space/n;\n    int yy=a.space%n;\n    for(int k=0;k<4;k++){\n      int xc=xx+x[k];\n      int yc=yy+y[k];\n      if(xc<0||yc<0||xc>=n||yc>=n)continue;\n      b=a;\n      tmp=b.m[a.space];\n      b.m[a.space]=b.m[xc*n+yc];\n      b.m[xc*n+yc]=tmp;\n      b.space=xc*n+yc;\n      if(!V[b]){\n\tV[b]=true;\n\tb.path+=c[k];\n\tQ.push(b);\n\t\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  puzz input;\n  for(int i=0;i<n1;i++){\n    cin>>input.m[i];\n    if(input.m[i]==0){\n      input.m[i]=n1;\n      input.space=i;\n    }\n  }\n  string ans =am(input);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle& p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= || ty >= N) {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N >= 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n        pos = st.find(\"0\");\n        Q.pop();\n        if (mp.count(st)) {\n            if (mp[st] == FLG) {\n                continue;\n            } else if (mp[st] == GOAL) {\n                return cnt;\n            } else\n                printf(\"ERROR: %d\\n\", __LINE__);\n        }\n        mp[st] = FLG;\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef long long ll;\n\nstruct P{\n  int x,y;\n  P(int x,int y) : x(x),y(y) {}\n};\n\nll getValue(vector<int> &v){\n  ll res = 0LL;\n  for(auto x : v){\n    res *= 10LL;\n    res += x;\n  }\n  return res;\n}\n\nvector<int> getState(ll x){\n  vector<int> res;\n  while(x > 0LL){\n    res.push_back(x%10LL);\n    x /= 10LL;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nP getPos(int x){\n  x--;\n  return P(x%3,x/3);\n}\n\nint getMD(ll x){\n  vector<int> v = getState(x);\n  int res = 0;\n  for(int i = 0 ; i < 9 ; i++){\n    if(v[i] == 0){ continue; }\n    P tp = getPos(v[i]);\n    res += abs(i%3-tp.x) + abs(i/3-tp.y);\n  }\n  return res;\n}\n\nint LIMIT;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < 3 && 0 <= y && y < 3);\n}\n\nvoid print(vector<int> &v){\n  for(int i = 0 ; i < 3 ; i++){\n    for(int j = 0 ; j < 3 ; j++){\n      cout << v[i*3+j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nbool solve(int sp,ll st,int step,int prev){\n  int md = getMD(st);\n  if(md == 0){ return true; }\n  if(md + step > LIMIT){\n    return false;\n  }\n  int x = sp%3, y = sp/3;\n  bool res = false;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!inField(nx,ny)){ continue; }\n    if(abs(i-prev) == 2){ continue; }\n    vector<int> v = getState(st);\n    int nsp = ny*3 + nx;\n    swap(v[sp],v[nsp]);\n    res |= solve(nsp,getValue(v),step+1,i);\n  }\n  return res;\n}\n\nint main(){\n  int sp = -1;\n  vector<int> v(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> v[i];\n    if(v[i] == 0){ sp = i; }\n  }\n  ll st = getValue(v);\n  for(LIMIT = 0 ; LIMIT < 35 ; LIMIT++){\n    if(solve(sp,st,0,INF)){\n      cout << LIMIT << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>  // use \"abs\" function.\n\n// non-recursive algorithm.\n#define N 3\n#define N2 9\n\nint main()\n{\n    int MDT[N2][N2];   // Manhattan Distance Table.\n    int dx[4] = {0, -1, 0, 1};  // move.\n    int dy[4] = {1, 0, -1, 0};\n\n    int i, j;\n    for(i = 0; i < N2; i++){\n        for(j = 0; j < N2; j++){\n            MDT[i][j] = abs((i / N) - (j / N)) + abs((i % N) - (j % N));\n        }\n    }\n    int pre_f[N2], f[N2], pre_space, space, pre_MD, MD, depth;\n    for(i = 0; i < N2; i++){\n        scanf(\"%d\", &pre_f[i]);\n        if(pre_f[i] == 0) pre_space = i;\n    }\n\n    pre_MD = 0;\n    for(i = 0; i < N2; i++){\n        if(pre_f[i] != 0){\n            pre_MD += MDT[i][pre_f[i] - 1];\n        }\n    }\n\n    int level, sx, sy, tx, ty, diff, trail[101], s, r, rev_sp;\n\n    for(level = pre_MD; level < 100; level++, level++){  // DFS.\n        for(i = 0; i < N2; i++) f[i] = pre_f[i];\n        space = pre_space;\n        MD = pre_MD;\n        depth = 0;\n        trail[0] = 4;\n        s = 0;\n\n        while(depth >= 0 && MD > 0)\n        {\n            sx = space / N;\n            sy = space % N;\n            for(r = s; r < 4; r++){\n                if((trail[depth] ^ r) == 2) continue;  // go forward.\n                tx = sx + dx[r];\n                ty = sy + dy[r];\n\n                if(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n                diff = MDT[sx * N + sy][f[tx * N + ty] - 1] - MDT[tx * N + ty][f[tx * N + ty] - 1];\n                if(depth + 1 + MD + diff > level) continue;  // branch cut.\n\n                break;\n            }\n            if(r < 4){  // next direction.\n                swap(f[sx * N + sy], f[tx * N + ty]);\n                space = tx * N + ty;\n                MD += diff;\n                depth++;\n                trail[depth] = r;\n                s = 0;\n            }else{\n                // back-track.\n                r = trail[depth] ^ 2;\n                s = trail[depth] + 1;\n                depth--;\n                if(depth >= 0){\n                    rev_sp = space + N * dx[r] + dy[r];\n                    MD += MDT[space][f[rev_sp] - 1] - MDT[rev_sp][f[rev_sp] - 1];\n                    swap(f[space], f[rev_sp]);\n                    space = rev_sp;\n                }\n            }\n        };\n        if(depth >= 0) break;\n    }\n    printf(\"%d\\n\", depth);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue> \n#include <map>\n\nusing namespace std;\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \ntypedef struct Puzzle {\n\tint M[9];\n\tint space;\n\tstring path;\n\tbool operator<(const Puzzle & p) const {\n\t\tfor (int i=0;i<9;i++) {\n\t\t\tif (M[i] == p.M[i]) continue;\n\t\t\treturn M[i] > p.M[i];\n\t\t}\n\t\treturn false;\n\t}\n} Puzzle;\n\nbool check(Puzzle & p) {\n\tfor (int i=0;i<8;i++) {\n\t\tif (p.M[i] != i+1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle & p) { //å¹¿åº¦ä¼åæç´¢ \n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V; //æ è®°è¯¥ç¶ææ¯å¦è¢«è®¿é®\n\tPuzzle u,v;\n\tp.path = \"\";\n\tQ.push(p);\n\tV[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (check(u)) return u.path;\n\t\t\n\t\tint sx = u.space / 3;\n\t\tint sy = u.space % 3;\n\t\t\n\t\tfor (int r = 0;r<4;r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\t\t\t\n\t\t\tv = u;\n\t\t\tswap(v.M[u.space],v.M[tx * 3 + ty]);\n\t\t\tv.space = tx*3 + ty;\n\t\t\t\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\t\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\tfor (int i=0;i<9;i++) {\n\t\tcin >> in.M[i];\n\t\tif (in.M[i] == 0) {\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[40000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>28) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1e9\n#define LIMIT 16\ntypedef vector<int> Vec;\n \nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\nint res;\nbool flg;\n \nbool inField(int y,int x){\n  return 0 <= y && y < 3 && 0 <= x && x < 3; \n}\n \nbool check(Vec &vec){\n  for(int i = 0 ; i < 8 ; i++){\n    if(vec[i] != i+1) return false;\n  }\n  return true;\n}\n \nvoid solve(Vec &start,int z,map<Vec,int> &cost){\n  queue<Vec> Q;\n  queue<int> zero;\n  Q.push(start); zero.push(z);\n  cost[start] = 0;\n   \n  while(!Q.empty()){\n    Vec now = Q.front(); Q.pop();\n    int pos = zero.front(); zero.pop();\n    int x = pos % 3, y = pos / 3;\n    if(!flg && check(now)){\n      res = cost[now];\n      return;\n    }\n    if(cost[now] == LIMIT) break;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      vector<int> next = now;\n      swap(next[pos],next[ny*3+nx]);\n      if(!cost.count(next)){\n        cost[next] = cost[now] + 1;\n        Q.push(next);\n        zero.push(ny*3+nx);\n      }\n    }\n  }\n}\n \nint main(){\n  int z = -1;\n  vector<int> start(9),goal(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> start[i];\n    goal[i] = i+1;\n    if(start[i] == 0) z = i;\n  }\n  goal[8] = 0;\n  res = INF; flg = false;\n  map<Vec,int> s2v,g2v;\n  solve(start,z,s2v);\n  if(res == INF){\n    flg = true;\n    solve(goal,8,g2v);\n  }\n  map<Vec,int>::iterator s,g;\n  for(s = s2v.begin() ; s != s2v.end() ; ++s){\n    if(g2v[s->first]){\n      res = min(res,s->second+g2v[s->first]);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  //cout<<ans<<endl;\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    //cout<<x<<endl;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(p[i][j]==0) zy=i,zx=j;\n    //cout<<zy<<\" \"<<zx<<endl;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      //cout<<t<<endl;\n      if(!m.count(t)){\n\tm[t]=m[x]+1;\n\tq.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tint val=calc(v);\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tstring s;\n\tstring path;\n\tint k;\n\tint i;\n};\nstring s;\nunordered_map<string,bool>vis;\nqueue<point> q;\nint jb;\nvoid solve(){\n\tpoint p;\n\tp.s=s;p.i=jb;p.k=0;\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tp=q.front();q.pop();\n\t\tstring path=p.path;\n\t\tif(vis[p.s])continue;\n\t\tif(p.s==\"123456780\"){\n\t\t\tcout<<p.k<<\"\\n\";\n//\t\t\tcout<<p.path<<\"\\n\";\n\t\t\texit(0);\n\t\t}\n//\t\tcout<<p.s<<endl;\n\t\tvis[p.s]=1;\n\t\tp.k+=1;\n\t\tif(p.k==5){\n\t\t\tp.k=p.k;\n\t\t}\n\t\tint i=p.i;\n\t\tif(i-3>=0){\n\t\t\tswap(p.s[i],p.s[i-3]);\n\t\t\tp.i=i-3;\n\t\t\tp.path=path+\"u\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i-3]);\n\t\t}\n\t\tif(i-1>=0&&i%3!=0){\n\t\t\tswap(p.s[i],p.s[i-1]);\n\t\t\tp.i=i-1;\n\t\t\tp.path=path+\"l\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i-1]);\n\t\t}\n\t\tif(i+3<9){\n\t\t\tswap(p.s[i],p.s[i+3]);\n\t\t\tp.i=i+3;\n\t\t\tp.path=path+\"d\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i+3]);\n\t\t}\n\t\tif(i+1<9&&(i+1)%3!=0){\n\t\t\tswap(p.s[i],p.s[i+1]);\n\t\t\tp.i=i+1;\n\t\t\tp.path=path+\"r\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i+1]);\n\t\t}\n\t}\t\n}\nint main(){\n//\tfreopen(\"a.txt\",\"r\",stdin);\n//\tfreopen(\"b.txt\",\"w\",stdout);\n\tchar tc;\n\tfor(int i=0;i<9;i++){\n\t\tcin>>tc;\n\t\tif(tc=='0')jb=i;\n\t\ts+=tc;\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst static int N = 3;\nconst static int N2 = 9;\nconst static int dx[4] = {-1, 0, 1, 0};\nconst static int dy[4] = {0, -1, 0, 1};\nconst static char dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    std::string path;\n\n    bool operator <(const Puzzle &p) const{\n        for(int i = 0; i < N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p){\n    for(int i = 0; i < N2; i++){\n        if(p.f[i] != i+1) return false;\n    }\n    return true;\n}\n\n\n\nstd::string bfs(Puzzle s){\n    std::queue<Puzzle> Q;\n    std::map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            std::swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n\n}\n\nint main(void){\n    Puzzle in;\n\n    for(int i = 0; i < N2; i++){\n        std::cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    std::string ans = bfs(in);\n    std::cout << ans.size() << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define M 9\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<M;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\nbool kansuu(Puzzle p){\n  for(int i=0;i<M;i++){\n    if(p.f[i]!=(i+1))return false;\n  }\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(kansuu(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n    \tV[v]=true;\n    \tv.path+=dir[r];\n    \tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n  for(int i=0;i<M;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst vector<int> dx = {-1, 0, 1, 0};\nconst vector<int> dy = {0, -1, 0, 1};\n\nll to_id(const vector<vector<int>> &board) {\n    ll acc = 0;\n    for (int i = 0; i < 9; i++) {\n        int row = i / 3;\n        int col = i % 3;\n        acc = acc * 10 + board[row][col];\n    }\n    return acc;\n}\n\nvector<vector<int>> to_board(ll id) {\n    vector<vector<int>> board(3, vector<int>(3));\n    for (int i = 2; i >= 0; i--) {\n        for (int j = 2; j >= 0; j--) {\n            board[i][j] = id % 10;\n            id /= 10;\n        }\n    }\n    return board;\n}\n\n// {row, col}\npair<int, int> find(const int v, const vector<vector<int>> &board) {\n    int row;\n    int col;\n    for (int i = 0; i < 9; i++) {\n        row = i / 3;\n        col = i % 3;\n        if (board[row][col] == v) break;\n    }\n    return {row, col};\n}\n\nvoid print_board(const vector<vector<int>> &board) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", board[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nset<ll> visited;\n\nint main(void) {\n    vector<vector<int>> start(3, vector<int>(3));\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> start[i][j];\n        }\n    }\n\n    const vector<vector<int>> goal = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 0}\n    };\n    const auto goal_id = to_id(goal);\n\n    // {id, dist}\n    queue<pair<ll, int>> q;\n    auto start_id = to_id(start);\n    q.push({start_id, 0});\n    visited.insert(start_id);\n\n    if (start_id == goal_id) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int ans = -1;\n    while (!q.empty()) {\n        const auto node = q.front();\n        q.pop();\n        const auto cur_board_id = node.first;\n        const auto cur_board = to_board(cur_board_id);\n        const auto cur_dist = node.second;\n        const auto zero_pos = find(0, cur_board);\n        // print_board(cur_board);\n\n        for (int i = 0; i < 4; i++) {\n            auto b = cur_board;\n            const int next_row = zero_pos.first + dy[i];\n            const int next_col = zero_pos.second + dx[i];\n            if (next_row < 0 || next_row > 2 || next_col < 0 || next_col > 2) continue;\n\n            swap(b[zero_pos.first][zero_pos.second], b[next_row][next_col]);\n            auto id = to_id(b);\n            auto dist = cur_dist + 1;\n            if (visited.find(id) != visited.end()) continue;\n            visited.insert(id);\n            if (id == goal_id) {\n                ans = dist;\n                break;\n            }\n            q.push({id, dist});\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\nconst int N = 3;\nconst int NN = N * N;\nstruct Puzzle{\n    int num[NN] = {};\n    int space = NIL;\n    string path;\n\n    bool operator<(const Puzzle &b) const{\n        REP(i, NN){\n            if(num[i] == b.num[i]) continue;\n            return num[i] < b.num[i];\n        }\n        return false;\n    }\n};\n\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, -1, 1, 0};\nchar dir[4] = {'u', 'l', 'r', 'd'};\n\nbool isGoal(Puzzle& p){\n    REP(i, NN)\n        if(p.num[i] != i+1) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> que;\n    map<Puzzle, bool> mp;\n    s.path = \"\";\n    que.push(s);\n    mp[s] = true;\n\n    while(!que.empty()){\n        Puzzle p = que.front(); que.pop();\n        if(isGoal(p)) return p.path;\n        int px = p.space / N;\n        int py = p.space % N;\n        REP(i, 4){\n            int nx = px + dx[i];\n            int ny = py + dy[i];\n            if(nx<0 || ny<0 || nx>=N || ny>=N)\n                continue;\n            Puzzle q = p;\n            swap(q.num[q.space], q.num[nx*N + ny]);\n            q.space = nx*N + ny;\n            if(!mp[q]){\n                mp[q] = true;\n                q.path += dir[i];\n                que.push(q);\n            }\n        }\n    }\n    return \"\";\n}\n\nint main(){\n    Puzzle in;\n    REP(i, NN){\n        cin >> in.num[i];\n        if(in.num[i] == 0){\n            in.num[i] = NN;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.length() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i = 0;i < N2;i++){\n      if(f[i] == p.f[i])\n\t{\n\t  continue;\n\t}\n      \n      return f[i] > p.f[i];\n    }\n    \n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p);\nstring bfs(Puzzle s);\n\nint main(void){\n  int i;\n  Puzzle in;\n  string ans;\n  \n  for(i = 0;i < N2;i++){\n    cin >> in.f[i];\n      \n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n      \n  }\n  \n  ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\nbool isTarget(Puzzle p){\n  for(int i = 0;i < N2;i++){\n    if(p.f[i] != (i+1)){\n      return false;\n    }\n  }\n  \n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool>V;\n  Puzzle u,v;\n  \n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n      \n    if(isTarget(u)){\n      return u.path;\n    }\n    \n    int sx = u.space/N;\n    int sy = u.space%N;\n    \n    for(int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      \n      if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n\tcontinue;\n      }\n      v = u;\n      \n      swap(v.f[u.space] , v.f[tx*N + ty]);\n      \n      v.space = tx*N + ty;\n      \n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) {\n                    swap(tmp[p], tmp[q]);\n                    wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n                } else {\n                    swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                    wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                    + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n                }\n                if (s.count(tmp)) continue; // already search\n\n                if (wrong_place == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = h1();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2]; int space; string path;\n    bool operator<(const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n        if(f[i]==p.f[i]) continue;\n        return f[i]>p.f[i];\n    }\n    return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n     return true;    \n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n\n    while (!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\n//vector<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//    for (vector<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n    int S = 100000000;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            table[i][k] = x/S;\n            x = x%S;\n            S /= 10;\n        }\n    }\n}\n\nint getNUM(int x){\n    switch(x){\n    case 0:return 1;\n    case 1:return 1;\n    case 2:return 2;\n    case 3:return 6;\n    case 4:return 24;\n    case 5:return 120;\n    case 6:return 720;\n    case 7:return 5040;\n    case 8:return 40320;\n    }\n    return -1;\n}\n\nlong long makeLong(int Table[3][3]){\n    return 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n    long long x = makeLong(Table);\n    int checkTable[9] = {0};\n    long long S = 100000000;\n    int ret = 0,small_num_appear_count;\n    for(int i=8; i >= 0; i--){\n        small_num_appear_count=0;\n        for(int k = 0; k < (x/S);k++){\n            if(checkTable[k] == 1)small_num_appear_count++;\n        }\n        ret += ((x/S)-small_num_appear_count)*getNUM(i);\n        checkTable[(x/S)]=1;\n        x %= S;\n        S /= 10;\n    }\n\n    return ret;\n}\n\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nstruct Info{\n    Info(){ zero_loc=data = count = 0;}\n    Info(long long arg_data,int arg_count,short arg_loc){\n        data = arg_data;\n        count = arg_count;\n        zero_loc = arg_loc;\n    }\n    long long data;\n    int count;\n    short zero_loc;\n};\n\nclass LongQ{\npublic:\n    LongQ(){\n        Q = new Info[362880];\n        head = tail = num_of_data=0;\n    }\n\n    void enqueue(long long arg_data,int arg_count,short arg_loc){\n        Q[tail].count = arg_count;\n        Q[tail].data = arg_data;\n        Q[tail].zero_loc = arg_loc;\n        num_of_data++;\n        tail = (tail+1)%362880;\n    }\n\n    Info dequeue(){\n        Info ret = Q[head];\n        head = (head+1)%362880;\n        num_of_data--;\n        return ret;\n    }\n\n    bool isEmpty(){\n        return num_of_data == 0;\n    }\n\nprivate:\n    Info* Q;\n    int head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo,short zero_loc){\n    if(checkTable[translateORDER(table)] == -1){\n        checkTable[translateORDER(table)]=tmpInfo.count;\n        queue.enqueue(makeLong(table),tmpInfo.count+1,zero_loc);\n    }\n    return queue;\n}\n\nint main(){\n\n    for(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n    int table[3][3];\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n\n    checkTable[translateORDER(table)]=0;\n    LongQ queue;\n\n    queue.enqueue(makeLong(table),0,zeroLoc(table));\n\n    Info tmpInfo;\n\n    while(queue.isEmpty()==false){\n        tmpInfo=queue.dequeue();\n\n        int tmpTable[3][3];\n        setNUM(tmpTable,tmpInfo.data);\n        if(tmpTable[0][0]==1&&tmpTable[0][1]==2&&tmpTable[0][2]==3&&tmpTable[1][0]==4&&\n        \t\ttmpTable[1][1]==5&&tmpTable[1][2]==6&&tmpTable[2][0]==7&&tmpTable[2][1]==8){\n            printf(\"%d\\n\",tmpInfo.count);\n            break;\n        }\n\n        int next_table[4][3][3];\n\n        for(int a=0;a<4;a++){\n            for(int b=0;b<3;b++){\n                for(int c=0;c<3;c++){\n                    next_table[a][b][c] = tmpTable[b][c];\n                }\n            }\n        }\n\n        switch(tmpInfo.zero_loc){\n        case 0:\n            swap(next_table[0][0][0],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][0],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n            break;\n        case 1:\n            swap(next_table[0][0][1],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][0][1],next_table[1][0][2]);\n            queue = func(queue,next_table[1],tmpInfo,2);\n\n            swap(next_table[2][0][1],next_table[2][1][1]);\n            queue = func(queue,next_table[2],tmpInfo,11);\n            break;\n        case 2:\n            swap(next_table[0][0][2],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][2],next_table[1][1][2]);\n            queue = func(queue,next_table[1],tmpInfo,12);\n\n            break;\n        case 10:\n            swap(next_table[0][1][0],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][1][0],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][0],next_table[2][2][0]);\n            queue = func(queue,next_table[2],tmpInfo,20);\n\n            break;\n        case 11:\n            swap(next_table[0][1][1],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][1][1],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n\n            swap(next_table[2][1][1],next_table[2][1][2]);\n            queue = func(queue,next_table[2],tmpInfo,12);\n\n            swap(next_table[3][1][1],next_table[3][2][1]);\n            queue = func(queue,next_table[3],tmpInfo,21);\n            break;\n        case 12:\n            swap(next_table[0][1][2],next_table[0][0][2]);\n            queue = func(queue,next_table[0],tmpInfo,2);\n\n            swap(next_table[1][1][2],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][2],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 20:\n            swap(next_table[0][2][0],next_table[0][1][0]);\n            queue = func(queue,next_table[0],tmpInfo,10);\n\n            swap(next_table[1][2][0],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        case 21:\n            swap(next_table[0][2][1],next_table[0][2][0]);\n            queue = func(queue,next_table[0],tmpInfo,20);\n\n            swap(next_table[1][2][1],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][2][1],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 22:\n            swap(next_table[0][2][2],next_table[0][1][2]);\n            queue = func(queue,next_table[0],tmpInfo,12);\n\n            swap(next_table[1][2][2],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 20\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Puzzle {\n    int f[9];\n    int space;\n    string path = \"\";\n\n    bool operator < (const Puzzle& p) const {\n        for(int i = 0; i < 9; i++) {\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nconst int nxt[][2] = {{-1,0},{0,-1},{1,0},{0,1} };\nconst char dir[] = {'u','l','d','r'};\n\ninline bool isTarget(Puzzle p) {\n    for(int i = 0; i < 9; i++) {\n        if(p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V; //K-Vå¯¹è¡¨ç¤ºåªä¸ªè¿·å®«(ç¶æ)æ¯å·²ç»æç´¢è¿çäº\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()) {\n        Puzzle u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / 3;\n        int sy = u.space % 3; // å¾å°ç©ºä½æå¨çè¡å\n        for(int i = 0; i < 4; i++) {\n            int tx = sx + nxt[i][0];\n            int ty = sy + nxt[i][1]; // ç©ºä½æè¾¹æææ¼å¾ç\n            if(tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n            Puzzle v = u;\n            swap(v.f[u.space],v.f[tx*3 + ty]);\n            v.space = tx * 3 + ty;\n            if(!V[v]) {\n                V[v] = true;\n                v.path += dir[i];\n                Q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    Puzzle in;\n    for(int i =0; i < 9; i++) {\n        cin >> in.f[i];\n        if(in.f[i] == 0) {\n            in.f[i] = 9;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????Â¨?????????24????????Â±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 40;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n        printf(\"[swap&check] s.count = %d\\n\", s.count);\n        return s.count * 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#define N 3\n\nint map[N][N];\nint x0,y0;\nint lim;\nbool check(void){\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==N-1&&j==N-1) break;\n\t\t\tif(map[i][j]!=i*N+j+1) return false;\n\t\t}\n\t}\n\tif(map[N-1][N-1]!=0)return false;\n\treturn true;\n}\n\nbool swapping(int x,int y,int dep){\n\tint temp=map[x0+x][y0+y];\n\tmap[x0+x][y0+y]=map[x0][y0];\n\tmap[x0][y0]=temp;\n\tx0+=x;\n\ty0+=y;\n\tif(check()){\n\t\tprintf(\"%d\\n\",dep);\n\t\texit(0);\n\t\treturn true;\n\t}\n\tif(dep<=lim){\n\t\tif(x!=1&&x0-1!=-1) swapping(-1,0,dep+1);\n\t\tif(x!=-1&&x0+1!=N) swapping(1,0,dep+1);\n\t\tif(y!=1&&y0-1!=-1) swapping(0,-1,dep+1);\n\t\tif(y!=-1&&y0+1!=N) swapping(0,1,dep+1);\n\t}\n\ttemp=map[x0-x][y0-y];\n\tmap[x0-x][y0-y]=map[x0][y0];\n\tmap[x0][y0]=temp;\n\tx0-=x;\n\ty0-=y;\n\treturn false;\n}\nint main(void){\n\ttime_t t;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx0=i;\n\t\t\t\ty0=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(check()){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\ttime_t t0=time(NULL);\n\tfor(lim=1;lim<46;lim++){\n\t\tt=time(NULL);\n//\t\tprintf(\"lim:%d:%lld\\n\",lim,t-t0);\n\t\tt0=t;\n\t\tif(x0-1!=-1) swapping(-1,0,1);\n\t\tif(x0+1!=N) swapping(1,0,1);\n\t\tif(y0-1!=-1) swapping(0,-1,1);\n\t\tif(y0+1!=N) swapping(0,1,1);\n\t}\n//\tprintf(\"Unsolved\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define A 3\n#define AB 9\n\nstruct pazzle{\n  int f[AB];\n  int space;\n  string path;\n\n  bool operator < (const pazzle &p) const{\n    for(int i=0;i<AB;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(pazzle p){\n  for(int i=0;i<AB;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(pazzle s){\n  queue<pazzle> Q;\n  map<pazzle,bool> V;\n  pazzle u,v;\n   s.path = \"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    int sx = u.space/A;\n    int sy = u.space%A;\n\n    for(int r=0;r<4;r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n\n      if(tx<0 || ty<0 || tx>=A || ty>=A)continue;\n\n      v=u;\n      swap(v.f[u.space],v.f[tx*A+ty]);\n      v.space = tx*A+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  pazzle in;\n\n  for(int i=0;i<AB;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=AB;\n      in.space =i;\n    }\n  }\n string ans = bfs(in);\n cout << ans.size() << endl;\n return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <stdio.h>\n\nusing namespace std;\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\nint main() {\n\tarray<array<int,3>,3> pz;\n\tqueue<pair<array<array<int,3>,3> ,int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n\nint search(int);\nint translate(std::array<int, 9>);\n\nstruct BoardStatus {\n\tstd::array<int, 9> arrange = {};\n\tint distance = 0;\n\tint zero_position = 8;\n};\n\nint main()\n{\n\tstd::array<int, 9> board;\n\tfor (int i = 0; i < 9; ++i)\n\t\tstd::cin >> board[i];\n\n\tstd::cout << search(translate(board)) << std::endl;\n\n\treturn 0;\n}\n\nint search(int dest_num)\n{\n    if (dest_num == 46233) return 0;\n\tBoardStatus board = { { 1, 2, 3, 4, 5, 6, 7, 8, 0}, 0, 8 };\n\tstd::vector<BoardStatus> queue;\n\tqueue.push_back(board);\n\tint pre_size = 0;\n\tint table[362880] = { };\n\n\tint move_direction[4] = { 1, -1, 3, -3 };\n\n\twhile (pre_size != queue.size())\n\t{\n\t\tint now_size = queue.size();\n\t\tfor (int queue_i = pre_size; queue_i < now_size; ++queue_i)\n\t\t{\n\t\t\tint zero_pos = queue[queue_i].zero_position;\n\t\t\tbool can_move[4] = {\n\t\t\t\tzero_pos % 3 != 2, zero_pos % 3 != 0,\n\t\t\t\tzero_pos / 3 != 2, zero_pos / 3 != 0\n\t\t\t};\n\t\t\tfor (int condi_i = 0; condi_i < 4; ++condi_i)\n\t\t\t{\n\t\t\t\tif (!can_move[condi_i]) continue;\n\n\t\t\t\tboard = queue[queue_i];\n\t\t\t\tint next_zero = zero_pos + move_direction[condi_i];\n\n\t\t\t\tboard.arrange[board.zero_position] = board.arrange[next_zero];\n\t\t\t\tboard.arrange[next_zero] = 0;\n\t\t\t\tboard.zero_position = next_zero;\n\t\t\t\tboard.distance++;\n\n\t\t\t\tint num_board = translate(board.arrange);\n\t\t\t\tif (!table[num_board] && num_board != 46233)\n\t\t\t\t{\n\t\t\t\t\ttable[num_board] = board.distance;\n\t\t\t\t\tqueue.push_back(board);\n\t\t\t\t}\n\t\t\t\tif (num_board == dest_num)\n\t\t\t\t\treturn board.distance;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint translate(std::array<int , 9> board)\n{\n\tbool used[9]{};\n\tint count = 0, tmp, ret = 0, fac = 362880;\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tcount = 0;\n\t\ttmp = board[i];\n\t\tfor (int j = 0; j < tmp; ++j)\n\t\t\tif (!used[j])\n\t\t\t\tcount++;\n\t\tused[tmp] = true;\n\t\tfac /= 9 - i;\n\t\tret += fac * count;\n\t}\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n/*\n1 2 3\n4 5 6\n7 0 8\n????????Â¶????????????????????????3???????????????\n????????????8??????????????????1?????Â§??????\n\n1 2 3\n4 0 6\n7 5 8\n????????Â¶?????????5??????????????Â°1?????Â§??????????????Â¢????????????\n\n*/\ntypedef long long int TBoard;\nconst static TBoard Answer = 123456780;\ntypedef std::vector<bool> TTable;\nTBoard InputBoard(std::istream& in)\n{\n    TBoard Board = 0;\n    for(int i = 8; i >= 0; --i){\n        int n;\n        std::cin >> n;\n        Board += std::pow(10, i) * n;\n    }\n    return Board;\n}\nint Encode(const TBoard& Board)\n{\n    return Board / 10;\n}\nTBoard Decode(int Code)\n{\n    int n = 0;\n    while(Code){\n        n += Code % 10;\n        Code /= 10;\n    }\n    int a = 36 - n;\n    return Code * 10 + a;\n    \n}\nstd::vector<TBoard> GetMoved(const TBoard& Board)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    assert(s.length() == 9);\n    int i = s.find('0');\n    assert(i >= 0);\n    assert(i <= 9);\n    \n    std::vector<TBoard> Result;\n    if(i > 2){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if(i < 6){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 0 || i == 3 || i == 6) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 2 || i == 5 || i == 8) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n\n    return Result;\n}\nvoid Print(const TBoard& Board, char c)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    std::cerr << c << s[0] << \" \" << s[1] << \" \" << s[2] << std::endl;\n    std::cerr << c << s[3] << \" \" << s[4] << \" \" << s[5] << std::endl;\n    std::cerr << c << s[6] << \" \" << s[7] << \" \" << s[8] << std::endl;\n    std::cerr << std::endl;\n}\nint Solve(const TBoard& Board)\n{\n    std::vector<bool> Table(87654321, false);\n    int Cost = 0;\n    std::queue<TBoard> q;\n    q.push(Board);\n    Table[Encode(Board)] = true;\n\n    std::queue<TBoard> temp;\n    while(!q.empty()){\n        TBoard B = q.front();\n        q.pop();\n        // Print(B, ' ');\n        if(B == Answer) return Cost;\n        std::vector<TBoard> Boards = GetMoved(B);\n        for(std::size_t i = 0; i < Boards.size(); ++i){\n            if(Table[Encode(Boards[i])]) continue;\n            temp.push(Boards[i]);\n            Table[Encode(Boards[i])] = true;\n            // Print(Boards[i], '\\t');\n        }\n        if(q.empty()){\n            std::swap(q, temp);\n            ++Cost;\n            // std::cerr << \"Cost\" << Cost << std::endl;\n        }\n    }\n    assert(false);\n}\nint main()\n{\n    TBoard Board = InputBoard(std::cin);\n    std::cout << Solve(Board) << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define MOD 1000007\n\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<set>\n\nusing namespace std;\n\nconst int AIM=87654321;\nconst int inic[]={2,0,1,2,0,1,2,0,1};\nconst int inir[]={2,0,0,0,1,1,1,2,2};\nconst int incr[]={-1,0,1,0};\nconst int incc[]={0,-1,0,1};\n\nint gragh[3][3];\nint zeror,zeroc;\nint dis(0);\n\nset<int> hash;\n\nint maxdep(0);\n\ninline int trans()\n{\n\tint mpow(1);\n\tint data(0);\n\tfor(int i=0;i<3;++i)\n\t\tfor(int j=0;j<3;++j)\n\t\t{\n\t\t\tdata+=mpow*gragh[i][j];\n\t\t\tmpow*=10;\n\t\t}\n\treturn data;\n}\ninline int calu()\n{\n\tint ans(0);\n\tfor(int i=0;i<=2;++i)\n\t\tfor(int j=0;j<=2;++j)\n\t\t\tans+=abs(inir[gragh[i][j]]-i)+abs(inic[gragh[i][j]]-j);\n\treturn ans;\n}\ninline int swap(int &a,int &b)\n{\n\ta^=b;b^=a;a^=b;\n}\nbool dfs(int dep)\n{\n\tif(trans()==AIM)\n\t{\n\t\tcout<<maxdep<<endl;\n\t\treturn 1;\n\t}\n\tif(dep>=maxdep)\n\t\treturn false;\n\tif(dis>(maxdep-dep)*2)\n\t\treturn false;\n\tint nr,nc;\n\tfor(int i=0;i<4;++i)\n\t{\n\t\tnr=zeror+incr[i];\n\t\tnc=zeroc+incc[i];\n\t\tif(nr<0||nc<0||nr>2||nc>2)\n\t\t\tcontinue;\n\t\tint olddis=dis;\n\t\tswap(nr,zeror);swap(nc,zeroc);\n\t\tswap(gragh[nr][nc],gragh[zeror][zeroc]);\n\t\tint data=trans();dis=calu();\n\t\tif(!hash.count(data))\n\t\t{\n\t\t\thash.insert(data);\n\t\t\tif(dfs(dep+1))\n\t\t\t\treturn 1;\n\t\t\thash.erase(data);\n\t\t}\n\t\tdis=olddis;\n\t\tswap(nr,zeror);swap(nc,zeroc);\n\t\tswap(gragh[nr][nc],gragh[zeror][zeroc]);\n\t}\n\treturn false;\n}\n\t\nint main()\n{\n\tfor(int i=0;i<3;++i)\n\t\tfor(int j=0;j<3;++j)\n\t\t{\n\t\t\tcin>>gragh[i][j];\n\t\t\tif(!gragh[i][j])\n\t\t\t\tzeror=i,zeroc=j;\n\t\t}\n\tdis=calu();\n\twhile(!dfs(0))\n\t{\n\t\thash.clear();\n\t\thash.insert(trans());\n\t\t++maxdep;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i=0; i<N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0; i<N2; i++)\n        if(p.f[i] != (i+1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r=0; r<4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N + ty]);\n            v.space = tx*N + ty;\n            if( !V[v] ){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for(int i=0; i<N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nstruct Node{\n\tvector<int> arr;\n\tint step;\n};\nconst int tx[]={1,0,-1,0};\nconst int ty[]={0,1,0,-1};\nvector<int> start,end;\nqueue<Node> sq;\nset<int> pan;\n\nvoid input()\n{\n\tint tmp;\n\tfor(int i=0;i!=3;++i)\n\t\tfor(int j=0;j!=3;++j)\n\t\t{\n\t\t\tcin>>tmp;\n\t\t\tstart.push_back(tmp);\n\t\t}\n\tfor(int i=0;i!=8;++i)\n\t\tend.push_back(i+1);\n\tend.push_back(0);\n}\n\nNode makenod(vector<int> tmp,int step)\n{\n\tNode res;\n\tres.arr=tmp;\n\tres.step=step;\n\treturn res;\n}\n\nint vton(vector<int> tmp)\n{\n\tint res=0;\n\tfor(int i=0;i!=9;++i)\n\t\tres=res*10+tmp[i];\n\treturn res;\n}\n\n/*\nvoid print(vector<int> tmp)\n{\n\tfor(int i=1;i!=10;++i)\n\t{\n\t\tcout<<tmp[i-1]<<' ';\n\t\tif(i%3==0)\tcout<<endl;\n\t}\n\tcout<<endl;\n}\n*/\nint main()\n{\n\tinput();\n\n\tsq.push(makenod(start,0));\n\tpan.insert(vton(start));\n\n\tint ans;\n\twhile(!sq.empty())\n\t{\n\t\tNode now=sq.front();\tsq.pop();\n\n\t\t//print(now.arr);\n\n\t\tif(now.arr==end)\n\t\t{\n\t\t\tans=now.step;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ith;\n\t\tfor(int i=0;i!=9;++i)\n\t\t\tif(now.arr[i]==0)\n\t\t\t{\n\t\t\t\tith=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x=ith/3,y=ith%3;\n\n\t\tfor(int i=0;i!=4;++i)\n\t\t{\n\t\t\tint nx=x+tx[i],ny=y+ty[i];\n\t\t\tif(nx>=0 && nx<3 && ny>=0 && ny<3)\n\t\t\t{\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t\tint num=vton(now.arr);\n\t\t\t\tif(pan.count(num)==0)\n\t\t\t\t{\n\t\t\t\t\tsq.push(makenod(now.arr,now.step+1));\n\t\t\t\t\tpan.insert(num);\n\t\t\t\t}\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#define N 9\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nstruct Puzzle{\n  int field[N];\n  int blank;\n  int num;\n\n  bool operator < (const Puzzle& a) const{\n    for(int i = 0; i < N; i++){\n      if(a.field[i] == field[i]) continue;\n      return field[i] >  a.field[i];\n    }\n    return false;\n  }\n};\n\nbool check(Puzzle puz){\n  for(int i = 0; i < N; i++){\n    if(puz.field[i] != i+1) return false;\n  }\n  return true;\n}\n\nint bfs(Puzzle puz){\n  queue<Puzzle> que;\n  map<Puzzle, bool> mp;\n\n  que.push(puz);\n  mp[puz] = true;\n\n  while(!que.empty()){\n    Puzzle p = que.front(); que.pop();\n    if(check(p) == true) return p.num;\n    int x = p.blank % 3;\n    int y = p.blank / 3;\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || 2 < nx || ny < 0 || 2 < ny) continue;\n      Puzzle tmp = p;\n      swap(tmp.field[p.blank], tmp.field[3 * ny + nx]);\n      tmp.blank = 3 * ny + nx;\n      if(mp[tmp] == false){\n    mp[tmp] = true;\n    tmp.num++;\n    que.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main(){\n  Puzzle puz;\n\n  for(int i = 0; i < N; i++){\n    cin >> puz.field[i];\n    if(puz.field[i] == 0){\n      puz.field[i] = N;\n      puz.blank = i;\n    }\n  }\n\n  puz.num = 0;\n  int b = bfs(puz);\n  cout << b << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n  bool operator<(const Puzzle &p) const\n  {\n    for (int i = 0; i < N2; i++)\n    {\n      if (f[i] == p.f[i])\n      {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n  for (int i = 0; i < N2; i++)\n  {\n    if (p.f[i] != (i + 1))\n    {\n\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty())\n  {\n    u = Q.front();\n    Q.pop();\n    if (isTarget(u))\n    {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++)\n    {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n      {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v])\n      {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++)\n  {\n    cin >> in.f[i];\n    if (in.f[i] == 0)\n    {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 30;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstatic const int LINE = 3;\nstatic const int N = 9;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans[LINE][LINE];\nint in[LINE][LINE];\n\nint check(){\n\n    for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            if(in[i][j] != ans[i][j])\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint dfs(int x, int y, int d,int u,int k){\n    if(check()) return d;\n    if(d > k) return -1;\n    for(int i=0; i<4; i++){\n        int vx,vy,val;\n        vx = x+dx[i];\n        vy = y+dy[i];\n\n        if(vx > 2 || vx < 0 || vy > 2 || vy < 0 || (i + 2) % 4 == u ){\n            continue;\n        }\n        in[y][x] = in[vy][vx];\n        in[vy][vx] = 0;\n        val  = dfs(vx,vy,d+1,i,k);\n        if(val > 0) return val;\n        in[vy][vx] = in[y][x];\n        in[y][x] = 0;\n    }\n    return -1;\n}\n\n\nint main(){\n    int x,y,sol,cnt=0;\n\n    for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            ans[i][j] = ++cnt;\n            if(i == LINE-1 && j == LINE -1) ans[i][j] = 0;\n        }\n    }\n\n    for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            cin>>in[i][j];\n            if(in[i][j] == 0){\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    cnt = 1;\n\n    while(1){\n        sol = dfs(x,y,0,-1,cnt);\n        if(sol >= 0) break;\n        cnt++;\n    }\n\n    /*for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            cout<<in[i][j];\n        }\n        cout<<endl;\n    }*/ //åºåç¢ºèª\n\n\n    cout<<sol<<endl;\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// using A star algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int N = 9;\nconst int XY = 3;\nconst int LIMIT = 100;\n\nstruct state {\n  vector<int> board;\n  int g;\n  state(vector<int> &board) {\n    this->board = board;\n    this->g = 0;\n  }\n};\nstruct compare_state {\n  int h_func(state &s) {\n    // using Manhattan distance\n    int distance = 0;\n    vector<int> solve(N,0);\n    for(int i=0;i<N;i++) {\n      solve[i] = i+1;\n    }\n    solve[N-1] = 0;\n    vector<int> board = s.board;\n    int solve_x,solve_y;\n    int board_x,board_y;\n    for(int i=0;i<N;i++) {\n      for(int j=0;j<N;j++) {\n        if(solve[i] == board[j]) {\n          solve_x = i % XY; solve_y = i / XY;\n          board_x = j % XY; board_y = j / XY;\n          distance += abs(solve_x - board_x) + abs(solve_y - board_y);\n          break;\n        }\n      }\n    }\n    return distance;\n  }\n  bool operator() (state &a,state &b) {\n    return (a.g + h_func(a)) > (b.g + h_func(b));\n  }\n};\npriority_queue<state,vector<state>,compare_state> que;\nmap<vector<int>,int> cost_table;\n\nbool check(state &current,state &end) {\n  for(int i=0;i<N;i++) {\n    if(current.board[i] != end.board[i])\n      return false;\n  }\n  return true;\n}\n\nbool is_infield(int x,int y) {\n  return (x < XY && y < XY && x >= 0 && y >= 0);\n}\n\nint search(state &start,state &end) {\n  // initialize process\n  que.push(start);\n  cost_table[start.board] = 0;\n  while(!que.empty()) {\n    state current = que.top(); que.pop();\n    // approach goal\n    if(check(current,end)) {\n      return current.g;\n    }\n    // not find goal\n    if(current.g > LIMIT) {\n      break;\n    }\n    // find zero brocks\n    int zero_pos;\n    for(int i=0;i<N;i++)\n      if(current.board[i] == 0)\n        zero_pos = i;\n    int x = zero_pos % XY;\n    int y = zero_pos / XY;\n    // swap zero brocks and find next state\n    int dx[] = {0,-1,1,0};\n    int dy[] = {-1,0,0,1};\n    for(int d=0;d<4;d++) {\n      if(!is_infield(x+dx[d],y+dy[d])) continue;\n      vector<int> next_board = current.board;\n      swap(next_board[x+y*XY],next_board[(x+dx[d])+(y+dy[d])*XY]);\n      // make and update cost table\n      if(!cost_table.count(next_board)) {\n        cost_table[next_board] = current.g + 1;\n        state next = *(new state(next_board));\n        next.g = current.g + 1;\n        que.push(next);\n      }\n      else {\n        if((current.g+1) < cost_table[next_board]) {\n          cost_table[next_board] = current.g + 1;\n          state next = *(new state(next_board));\n          next.g = current.g + 1;\n          que.push(next);\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  vector<int> start_vec(N,-1);\n  vector<int> end_vec(N,-1);\n  for(int i=0;i<N;i++) {\n    cin >> start_vec[i];\n    end_vec[i] = i+1;\n  }\n  end_vec[N-1] = 0;\n\n  state start = *(new state(start_vec));\n  state end = *(new state(end_vec));\n\n  cout << search(start,end) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nbool frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\nset<Board> history;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\nint change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = true;\n    }\n//    if (history.insert(s.board).second) {\n//        ++s.count;\n//    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, steps = 0, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        if (a.f == f) return a.steps < steps;\n        else return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    node LAST;\n    while (!pq.empty()) {\n        node u = LAST = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return LAST.steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur));\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1001001001;\ntypedef unsigned long long ll;\n\nstruct Puzzle{\n  int f[9];\n  int space;\n  int cnt;\n\n  bool operator < (const Puzzle &p) const {\n    rep(i, 9){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\n\nstatic const int dx[4] = {1, 0, -1, 0};\nstatic const int dy[4] = {0, 1, 0, -1};\n\nbool isTarget(Puzzle p){\n  rep(i, 9) if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nint main(){\n  Puzzle in;\n\n  rep(i, 9){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = 9;\n      in.space = i;\n    }\n  }\n  in.cnt = 0;\n\n  V[in] = true;\n  Q.push(in);\n  int ans;\n  while(!Q.empty()){\n    Puzzle u = Q.front(); Q.pop();\n    if(isTarget(u)){\n      ans = u.cnt;\n      break;\n    } \n    int sx = u.space / 3;\n    int sy = u.space % 3;\n    rep(i, 4){\n      int tx = sx + dx[i];\n      int ty = sy + dy[i];\n      if(tx<0 || ty<0 || 3<=tx || 3<=ty) continue;\n      Puzzle v = u;\n      v.space = tx * 3 + ty;\n      swap(v.f[u.space], v.f[v.space]);\n      v.cnt++;\n      if(!V[v]){\n        V[v] = true;\n        Q.push(v);\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nconst int Max = 3;\nint a[4][2]= {0,-1,1,0,0,1,-1,0};\nint last[9][2]= {{2,2},{0,0},{0,1},{0,2},{1,0},{1,1},{1,2},{2,0},{2,1}}; // ç®æ ç¶æçæ°å­æå¨ä½ç½®\nint k[Max][Max],k2[Max*Max],flag=0,limit,Mi;   // kç¨æ¥ä¿å­å«æ°ç ç¶æï¼k2ç¨æ¥è®¡ç®æ¼å·´é¡¿è·ç¦»\nint add(int k[Max][Max])       // æ¼åé¡¿è·ç¦»ä¸º ææçæ°å­è¦èµ°å°ç®æ ç¶æï¼æå°è¦å0æ¢çæ¬¡æ°ï¼\n{\n    int i,j;\n    int sum = 0;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n        {\n            if(k[i][j]!=0)     //å¤æ­æ¼åé¡¿è·ç¦»ä¸è½å¤æ­0ï¼\n                sum += abs(i-last[k[i][j]][0])+abs(j - last[k[i][j]][1]);  //æ±æ¼åé¡¿è·ç¦»\n        }\n    return sum;\n}\nvoid dfs(int y,int x,int len,int f)     // x,yå½å0çåæ  len ä¸ºå·²ç»èµ°äºå æ­¥äºï¼fä¸ºå½ä¸ä¸æ¬¡çæç´¢æ¹å\n{\n    int s = add(k);                     // æ±å½åç¶æçæ¼åé¡¿è·ç¦»\n    if(flag) return;                    // å¦ææ¾å°ç¬¦åçç»æï¼ä¸å¨æç´¢\n    if(len<=limit)\n    {\n        if(s==0)                        //æ¼åé¡¿è·ç¦»ä¸ºé¶ï¼ä¸ºç®æ ç¶æ\n        {\n            flag=1;\n            Mi=len;\n            return ;\n        }\n        if(len==limit) return;          //éå½å°äºæ¬è½®ç»ç¹ï¼ç»æ\n    }\n    for(int i=0; i<4; i++)\n    {\n        int tx = x + a[i][0];\n        int ty = y + a[i][1];\n        if(tx>=0&&ty>=0&&ty<3&&tx<3&&((f==-1)||i!=(f+2)%4))\n        {\n            swap(k[y][x],k[ty][tx]);    // è®©ä¸ä¸ä¸ªæ°ä¸ 0 äº¤æ¢ä½ç½®\n            if(len+add(k)<=limit)       // IDA* å¼åå°ï¼å½åèµ°çæ­¥æ° å ä¸ å½åç¶æå°è¾¾æ ç¶æçæå°æ­¥æ°ï¼\n            {\n                // è¦å°äºç­äºå½åæä¸¾å°çæå°ç ä»èµ·å§ç¶æå°è¾¾ç®æ ç¶æçæ­¥æ°ï¼ä¸è½è¶è¿ï¼\n                dfs(ty,tx,len+1,i);\n                if(flag) return ;\n            }\n            swap(k[y][x],k[ty][tx]);    //è¿å\n        }\n    }\n}\nint main()\n{\n    int i,j;\n    while(~scanf(\"%d\",&k2[0]))\n    {\n        int y,x;\n        k[0][0] = k2[0];\n        if(k2[0]==0)    //è®°å½ 0 æå¨çä½ç½®\n        {\n            y = 0;\n            x = 0;\n        }\n        for(i=1; i<Max*Max; i++)\n        {\n            scanf(\"%d\",&k2[i]);\n            k[i/3][i%3] = k2[i];//æè¾å¥çæ°å­å°äºç»´æ°ç»\n            if(k2[i]==0)        //è®°å½ 0 æå¨çä½ç½®\n            {\n                y = i/3;\n                x = i%3;\n            }\n        }\n        flag = 0;\n        limit = add(k);        // å½åè¦è¾¾å°ç®æ ç¶æçæå°æ­¥æ°ï¼\n        while(!flag&&limit<=36)\n        {\n            dfs(y,x,0,-1);\n            if(!flag)          //å¦ææ¬è½®æ²¡ææ»¡è¶³çæ¡ä»¶ï¼æ©å¤§æç´¢èå´\n                limit ++;      // æ·±æåºçº¿ +1\n        }\n        if(flag)\n            printf(\"%d\\n\",Mi);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n      return res;\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstruct Puzzle {\n\tint f[N2], space;\n\tstring path;\n\tbool operator <(const Puzzle p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n     for(int i=0;i<N2;i++)\n         if(p.f[i]!=(i+1)) return false;\n         return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx = sx +dx[r];\n            int ty = sy +dy[r];\n            if(tx<0 || ty <0 || tx >=N || ty >=N) continue;\n            v =u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N+ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    \n    for(int i=0;i<N2;i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <stack>\n#include <tuple>\n#include <vector>\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nconst int dr[4] = {0, 1, 0, -1};\nconst int dc[4] = {1, 0, -1, 0};\n\ntemplate <typename T> class Board {\npublic:\n  static const int L = 3;\n  static const int N = L*L;\n\n  Board() : prohibited_dir(-1) {}\n  Board(T *board) : prohibited_dir(-1) {\n    for (int i = 0; i < N; i++) {\n      this->board[i] = board[i];\n    }\n  }\n  Board(const Board &b) : prohibited_dir(b.prohibited_dir) {\n    for (int i = 0; i < N; i++) {\n      this->board[i] = b.board[i];\n    }\n  }\n\n  const T &operator[](std::size_t i) const { return board[i]; }\n  T &operator[](std::size_t i) { return board[i]; }\n\n  const T &as_plane(std::size_t r, std::size_t c) const {\n    return board[plane2line(r, c)];\n  }\n\n  bool operator==(const Board &b) const {\n    if (prohibited_dir != b.prohibited_dir)\n      return false;\n    for (int i = 0; i < N; i++) {\n      if (board[i] != b.board[i])\n        return false;\n    }\n    return true;\n  }\n\n  std::tuple<int, int> line2plane(int i) {\n    return std::make_pair(i / L, i % L);\n  }\n\n  int plane2line(int r, int c) { return r * L + c; }\n\n  int L1(int sr, int sc, int dr, int dc) {\n    int r = std::abs(sr - dr);\n    int c = std::abs(sc - dc);\n    return r + c;\n  }\n\n  bool is_goal() {\n    for (int i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return false;\n    }\n    return board[N - 1] == 0;\n  }\n\n  int h() {\n    int res = 0;\n    for (int src = 0; src < N; src++) {\n      int sr, sc;\n      std::tie(sr, sc) = line2plane(src);\n      int dr, dc;\n      std::tie(dr, dc) = line2plane(board[src] - 1);\n      res += L1(sr, sc, dr, dc);\n    }\n    return res;\n  }\n\n  bool is_in(int r, int c) { return 0 <= r && r < L && 0 <= c && c < L; }\n\n  std::vector<Board<T>> neighbor() {\n    std::vector<Board<T>> res;\n    int zero;\n    int zr, zc;\n    for (int i = 0; i < N; i++) {\n      if (board[i] == 0) {\n        std::tie(zr, zc) = line2plane(i);\n        zero = i;\n      }\n    }\n\n    for (int i = 0; i < 4; i++) {\n      if (prohibited_dir == i)\n        continue;\n      int nr = zr + dr[i], nc = zc + dc[i];\n      int nxt = plane2line(nr, nc);\n      if (!is_in(nr, nc))\n        continue;\n      Board next(*this);\n      std::swap(next.board[zero], next.board[nxt]);\n      next.prohibited_dir = (i + 2) % 4;\n      res.push_back(next);\n    }\n    return res;\n  }\n\n#ifdef EBUG\n  void print() {\n    for (int r = 0; r < L; r++) {\n      for (int c = 0; c < L; c++) {\n        int idx = plane2line(r, c);\n        cout << std::setw(3) << std::right << board[idx] << \" \";\n        ;\n      }\n      cout << endl;\n    }\n  }\n#endif\n\nprotected:\n  int prohibited_dir;\n\nprivate:\n  T board[N];\n};\n\nBoard<int> board;\nconst int FOUND = (1 << 30) + 1;\nconst int INF = (1 << 30);\n\nstd::vector<Board<int>> ida_star(Board<int> root);\nint search(std::vector<Board<int>> &path, int g, int bound);\n\nint main(void) {\n  int tmp[Board<int>::N];\n  for (int i = 0; i < Board<int>::N; i++) {\n    cin >> tmp[i];\n  }\n  board = Board<int>(tmp);\n\n  std::vector<Board<int>> path = ida_star(board);\n  cout << path.size() - 1 << endl;\n\n#ifdef EBUG\n  for (auto &p : path) {\n    p.print();\n  }\n#endif\n}\n\nstd::vector<Board<int>> ida_star(Board<int> root) {\n  int bound = root.h();\n  std::vector<Board<int>> path;\n  path.push_back(root);\n  while (1) {\n    int t = search(path, 0, bound);\n    if (t == FOUND)\n      return path;\n    if (t == INF)\n      assert(false);\n    bound = t;\n  }\n}\n\nint search(std::vector<Board<int>> &path, int g, int bound) {\n  Board<int> node = path.back();\n  int f = g + node.h();\n  if (f > bound)\n    return f;\n  if (node.is_goal())\n    return FOUND;\n  int minv = INF;\n  for (const auto &succ : node.neighbor()) {\n    if (std::find(path.begin(), path.end(), succ) == path.end()) {\n      path.push_back(succ);\n      int t = search(path, g + 1, bound);\n      if (t == FOUND)\n        return FOUND;\n      if (t < minv)\n        minv = t;\n      path.pop_back();\n    }\n  }\n  return minv;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define N 3\n#define TRUE 1\n#define FALSE 0\n\nint x[4]={0,-1,0,1};\nint y[4]={1,0,-1,0};\nint l;\nint puzzle[N][N];\n\nvoid swap(int *,int *);\nint abc();\nint dfs(int,int,int,int);\nvoid Solved(int,int);\n\nint main()\n{\n  int i,j,sx,sy;\n   \n   for(i=0;i<N;i++){\n     for(j=0;j<N;j++){\n       scanf(\"%d\",&puzzle[i][j]);\n        if(puzzle[i][j]==0){\n            sy=i;sx=j;\n        }\n     }\n   }\n   Solved(sy,sx);\n   return 0;\n}\n\n\nvoid swap(int *x,int *y)\n{\n  int tmp;\n  tmp=*x;\n  *x=*y;\n  *y=tmp;\n}\n\n\nint abc()\n{\n  int i,j,s=0,r;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n        \n        if(puzzle[i][j]==0)continue;\n        \n        r=puzzle[i][j]-1;\n        s+=abs(r/N-i)+abs(r%N-j);\n    }\n  }\n  return s;\n}\n\n\nint dfs(int d,int p,int sy,int sx)\n{\n  int i,m;\n  int tx,ty;\n\n  m=abc();\n  \n  if(m==0)return TRUE;\n  if(d+m>l)return FALSE;\n  \n  for(i=0;i<4;i++){\n    if(abs(i-p)==2)continue;\n    \n    tx=sx+x[i],ty=sy+y[i];\n    \n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    \n    swap(&puzzle[ty][tx],&puzzle[sy][sx]);\n    \n    if(dfs(d+1,i,ty,tx))return TRUE;\n    \n    swap(&puzzle[ty][tx],&puzzle[sy][sx]);\n  }\n    return FALSE;\n}\n\n\nvoid Solved(int sy,int sx)\n{\n  for(l=0;;l++){\n    if(dfs(0,99,sy,sx)){\n      printf(\"%d\\n\",l);\n      return ;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n//goal\nint final[N][N] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    solve(initial, x, y, final);\n    path -= 1;\n    cout << path;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    int i;\n\n    for( i=0; i<N2; i++){\n      if( f[i] == p.f[i] ) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1, 0, 1, 0};\nstatic const int dy[4]={0, -1, 0, 1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for( i=0; i<N2; i++)\n    if( p.f[i] != (i+1) )\n      return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  \n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while( !Q.empty() ){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))\n      return u.path;\n    int sx=u.space / N;\n    int sy=u.space % N;\n    int r;\n\n    for( r=0; r<4; r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N )\n\tcontinue;\n      v=u;\n      swap( v.f[u.space], v.f[tx*N+ty] );\n      v.space = tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  int i;\n\n  for(i=0;i<N2;i++){\n    cin>>in.f[i];\n    \n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\nusing T=array<array<int,4>,4>;\n\nusing ul=unsigned long long;\nstruct hoge{\n\tul ban;\n\tint x;\n\tint y;\n\tint ato;\n\tint ima;\n\tbool operator<(const hoge& p) const{\n\t\treturn ato+ima>p.ato+p.ima;\n\t}\n};\n\nqueue<hoge> qu[10000];\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint h=3,w=3;\n\t\n\t//cin>>h>>w;\n\tT a;\n\tint sx,sy;\n\t\n\tint dis=0;\n\tul state=0ull;\n\t\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\ta[i][j]--;\n\t\tif(a[i][j]>=0){\n\t\tdis+=abs(j-a[i][j]%w);\n\t\tdis+=abs(i-a[i][j]/w);\n\t\t}\n\t\tif(a[i][j]==-1)sx=i,sy=j,a[i][j]=8;\n\t}\n\tfor(int i=2;i>=0;i--)for(int j=2;j>=0;j--){\n\t\tstate<<=4;\n\t\tstate|=a[i][j];\n\t}\n\tif(dis==0){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tqu[dis].push({state,sx,sy,dis,0});\n\t//set<T> se;\n\t//se.insert(a);\n\tmap<ul,int> ma;\n\tma[state]=0;\n\tint it=0;\n\tint cnt=0;\n\tul zen=0;\n\tfor(int i=0;i<9;i++){\n\t\tzen*=16ull;\n\t\tzen+=15ull;\n\t}\n\t\n\twhile(1){\n\t\twhile(qu[it].size()==0){\n\t\t\tit++;\n\t//\t\tcout<<it<<\" \"<<cnt<<endl;\n\t\t}\n\n\t\thoge Z=qu[it].front();\n\t\tqu[it].pop();\n\t\tif(ma[Z.ban]<Z.ima)continue;\n\t\tcnt++;\n\t\t\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint x=Z.x+dx[r];\n\t\t\tint y=Z.y+dy[r];\n\t\t\tif(x<0 ||x>=h ||y<0 ||y>=w)continue;\n\t\t\t\n\t\t\tint t0=Z.x*3+Z.y;\n\t\t\tint t1=x*3+y;\n\t\t\tul g0=(Z.ban>>(4*t0))&15ull;\n\t\t\tul g1=(Z.ban>>(4*t1))&15ull;\n\t\t\tstate=Z.ban;\n\t\t\tstate&=(zen^(15ull<<(4*t0)));\n\t\t\tstate&=(zen^(15ull<<(4*t1)));\n\n\t\t\tstate|=g1<<(4*t0);\n\t\t\tstate|=g0<<(4*t1);\n\t\t\t\n\t\t\tint zou=abs(Z.y-(int)(g1%3))+abs(Z.x-(int)(g1/3))-abs(y-(int)(g1%3))-abs(x-(int)(g1/3));\n\t\t\t\n\t\t\t\n\t\t\t//if(Z.ima+1+Z.ato+zou>45)continue;\n\t\t\n\t\t\tif(Z.ato+zou==0){\n\t\t\t\tcout<<Z.ima+1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tif(!ma.count(state) || ma[state]>Z.ima+1){\n\t\t\t\tma[state]=Z.ima+1;\n\t\t\t\tqu[Z.ato+zou+Z.ima+1].push({state,x,y,Z.ato+zou,Z.ima+1});\n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i=0;i<N2;i++)\n      {\n\tif(f[i]==p.f[i]) continue;\n\treturn f[i]>p.f[i];\n      }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const int dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n    {\n      u=Q.front();Q.pop();\n      if(isTarget(u))return u.path;\n      int sx=u.space/N;\n      int sy=u.space%N;\n      for(int r=0;r<4;r++)\n\t{\n\t  int tx=sx+dx[r];\n\t  int ty=sy+dy[r];\n\t  if(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t  v=u;\n\t  swap(v.f[u.space],v.f[tx*N+ty]);\n\t  v.space=tx*N+ty;\n\t  if(!V[v])\n\t    {\n\t      V[v]=true;\n\t      v.path+=dir[r];\n\t      Q.push(v);\n\t    }\n\t}\n    }\n\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n    {\n      cin>>in.f[i];\n      if(in.f[i]==0)\n\t{\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n    }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_13_B\n// Heuristic Search - 8 Puzzle\n// status:\n// tag: [bfs]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct puzzle {\n    int p[N2];\n    string path;\n    int space;\n\n    bool is_complete() {\n        // complete pattern is:\n        // 1 2 3\n        // 4 5 6\n        // 7 8 9\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] != i + 1) return false;\n        }\n\n        return true;\n    }\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char direction[] = {'l', 'd', 'r', 'u'};\n\nint to_index(int x, int y) { return y * N + x; }\nint to_x(int index) { return index % N; }\nint to_y(int index) { return index / N; }\n\nqueue<puzzle> pq;\n\nstring bfs() {\n    while (!pq.empty()) {\n        auto curr_puzzle = pq.front();\n        pq.pop();\n\n        int curr_x = to_x(curr_puzzle.space), curr_y = to_y(curr_puzzle.space);\n        for (int r = 0; r < 4; ++r) {\n            int next_x = curr_x + dx[r], next_y = curr_y + dy[r];\n            if (next_x < 0 || N <= next_x || next_y < 0 || N <= next_y) continue;\n\n            auto next_puzzle = curr_puzzle;\n            next_puzzle.path += direction[r];\n            next_puzzle.space = to_index(next_x, next_y);\n\n            swap(next_puzzle.p[curr_puzzle.space], next_puzzle.p[next_puzzle.space]);\n\n            if (next_puzzle.is_complete()) return next_puzzle.path;\n            pq.push(next_puzzle);\n        }\n    }\n\n    // fail\n    return \"\";\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(1 3 0\n4 2 5\n7 8 6\n)\";\n    stringstream stream(program_input_str);\n#endif\n    puzzle start_puzzle;\n    start_puzzle.path = \"\";\n\n    int value;\n    for (int y = 0; y < N; ++y) {\n        for (int x = 0; x < N; ++x) {\n            auto index = to_index(x, y);\n            stream >> value;\n            start_puzzle.p[index] = value;\n            if (value == 0) {\n                start_puzzle.p[index] = N2;\n                start_puzzle.space = index;\n            }\n        }\n    }\n\n    pq.push(start_puzzle);\n    auto ans = bfs();\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN) / DIVN - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned && Puzzles[PtoI(Q)] < answer){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct paz{\n\tint in2[3][3];\n\tint cnt;\n\tpair<int, int> s;\n};\n\nint main(){\n\tint ok[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } }; int flag = 0; int answer;\n\tpaz in;\n\tqueue<paz> pp;\n \tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tcin >> in.in2[i][j];\n\t\t\tif (in.in2[i][j] == 0) {\n\t\t\t\tin.s.first = i;\n\t\t\t\tin.s.second = j;\n\t\t\t}\n\t\t}\n\t}\n\tin.cnt = 0;\n\tpp.push(in);\n\twhile (1){\n\t\tflag = 0;\n\t\tpaz temp = pp.front();\n\t\tpp.pop();\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tif (temp.in2[i][j] != ok[i][j]) flag = 1;\n\t\t\t}\n\t\t}if (flag == 0) {\n\t\t\tanswer = temp.cnt;\n\t\t\tbreak;\n\t\t}\n\t\tint dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 };\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (temp.in2[temp.s.first + dy[i]][temp.s.second + dx[i]] >= 0){\n\t\t\t\tpaz a = temp;\n\t\t\t\tswap(a.in2[a.s.first][a.s.second], a.in2[a.s.first + dy[i]][a.s.second + dx[i]]);\n\t\t\t\ta.cnt++;\n\t\t\t\ta.s.first += dy[i]; a.s.second += dx[i];\n\t\t\t\tpp.push(a);\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int H=3,W=3;\nconst int SIZE=H*W;\n\nclass State\n{\n public:\n    string str;\n    int space,distFromS,distToG;\n    State(string str,int space,int dist):str(str),space(space),distFromS(dist),distToG(0){\n        for(int i=0;i<SIZE;i++) if(i!=space){\n            int y=i/W,x=i%W;\n            int gy=(str[i]-'a')/W,gx=(str[i]-'a')%W;\n            distToG+=abs(y-gy)+abs(x-gx);\n        }\n    }\n    bool operator<(const State& s) const{\n        return distFromS+distToG>s.distFromS+s.distToG;\n    }\n};\n\nint d[4]={-W,-1,1,W};\n\nint main()\n{  \n    string s(SIZE,' '),goal(SIZE,' ');\n    for(int i=0;i<SIZE;i++) goal[i]=(char)('a'+i);\n    for(int i=0;i<SIZE;i++){\n        int t; cin>>t;\n        if(t==0) s[i]=goal[SIZE-1];\n        else s[i]=goal[t-1];\n    }\n\n    State start(s,s.find(goal[SIZE-1]),0);\n    priority_queue<State> Q; Q.push(start);\n    set<string> visited; visited.insert(s);\n    while(!Q.empty()){\n        auto cur=Q.top(); Q.pop();\n        if(cur.str==goal){\n            cout<<cur.distFromS<<endl;\n            return 0;\n        }\n        for(int i=0;i<4;i++){\n            int nxtspace=cur.space+d[i];\n            if(nxtspace<0 or nxtspace>=SIZE) continue;\n            if(d[i]==1 and nxtspace%W==0) continue;\n            if(d[i]==-1 and nxtspace%W==W-1) continue;\n            string nxtstr=cur.str;\n            swap(nxtstr[cur.space],nxtstr[nxtspace]);\n            if(!visited.count(nxtstr)){\n                visited.insert(nxtstr);\n                State nxt(nxtstr,nxtspace,cur.distFromS+1);\n                Q.push(nxt);\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\nclass Board {\npublic:\n  int board[3][3];\n  Board() {}\n  Board(int b[3][3]) {\n    REP(i, 3) {\n      REP(j, 3) {\n        board[i][j] = b[i][j];\n      }\n    }\n  }\n\n  int hash() {\n    int accum = 0;\n    int digit = 1;\n    REP(i, 3) {\n      REP(j, 3) {\n        accum += board[i][j] * digit;\n        digit *= 10;\n      }\n    }\n    return accum;\n  }\n  string to_str() {\n    string str = \"\";\n    REP(i, 3) {\n      REP(j, 3) {\n        str += \" \" + to_string(board[i][j]);\n      }\n      str += \"\\n\";\n    }\n    return str;\n  }\n  bool operator==( const Board& other) {\n    REP(i, 3) {\n      REP(j, 3) {\n        if (board[i][j] != other.board[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n};\n\nclass Nully;\nstatic Board Nully;\n\nBoard swap_with_upper(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i - 1][pos_j]);\n  return next;\n}\nBoard swap_with_lower(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i + 1][pos_j]);\n  return next;\n}\nBoard swap_with_left(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j - 1]);\n  return next;\n}\nBoard swap_with_right(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j + 1]);\n  return next;\n}\n\nint main() {\n  // int b[3][3] = {{1, 3, 0}, {4, 2, 5}, {7, 8, 6}};\n  int b[3][3];\n  REP(i, 3) {\n    REP(j, 3) {\n      cin >> b[i][j];\n    }\n  }\n\n  int g[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n  Board init(b);\n  Board goal(g);\n  // cout << init.to_str() << endl;\n\n  int depth = 0;\n  queue<pair<Board, int> > Q;\n  set<int> S;\n  Q.push(make_pair(init, depth));\n  S.insert(init.hash());\n\n  while (!Q.empty()) {\n    Board current = Q.front().first;\n    Board next;\n    int dpt = Q.front().second;\n    Q.pop();\n\n    if (goal == current) {\n      cout << dpt << endl;\n      return 0;\n    }\n\n    next = swap_with_upper(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n    next = swap_with_lower(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n    next = swap_with_left(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n    next = swap_with_right(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t        //in.f[i] = N2;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int MAXN = 100005;\nconst int MAXE = 200005;\nconst int NIL = -1;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nconst char dir[4] = { 'u', 'r', 'd', 'l' };\nstruct Puzzle {\n\tint Sudoku[3][3];\n\tint space;\n\tstring path;\n\tbool operator<(const Puzzle& p) const\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tif (Sudoku[i][j] == p.Sudoku[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn Sudoku[i][j] < p.Sudoku[i][j];\n\t\treturn false;\n\t}\n};\n\nbool ok(const Puzzle &p)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tif (p.Sudoku[i][j] != i * 3 + j + 1)\n\t\t\t\treturn false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> vis;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tvis[s] = true;\n\twhile (!q.empty())\n\t{\n\t\tu = q.front();\n\t\tq.pop();\n\t\tif (ok(u))\n\t\t\treturn u.path;\n\t\tint x = (u.space - 1) / 3;\n\t\tint y = (u.space - 1) % 3;\n\t\t//cout << \"space == \" << u.space << \" x == \" << x << \" y == \" << y << endl;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.Sudoku[x][y], v.Sudoku[tx][ty]);\n\t\t\tv.space = tx * 3 + ty + 1;\n\t\t\tif (!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = true;\n\t\t\t\tv.path += dir[i];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tPuzzle s;\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tcin >> s.Sudoku[i][j];\n\t\t\tif (s.Sudoku[i][j] == 0)\n\t\t\t\ts.Sudoku[i][j] = 9, s.space = i * 3 + j + 1;\n\t\t}\n\tcout << s.space << endl;\n\tcout << bfs(s).size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n        return s.count * 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // äºè¦ç´ éã®è·é¢\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const {\n    rep(i, 0, N2) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = { -1, 0, 1, 0};\nstatic const int dy[4] = { 0, -1, 0, 1};\nstatic const char dir[4] = { 'u', 'l', 'd', 'r'}; // up, left, down, right\n\nbool isTarget(Puzzle p) {\n  rep(i, 0, N2) {\n    if (p.f[i] != (i+1)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) return u.path;\n    int sx = u.space / N; // row\n    int sy = u.space % N; // column\n\n    rep(r, 0, 4) {\n      // tx, ty äº¤æããåã®row, column\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n};\n\nint main() {\n  Puzzle in;\n  rep(i, 0, N2) {\n    cin >> in.f[i];\n\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\treturn true;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// AC\n// ??????????????????????????????????????????AC??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 40;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\nint limit;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nbool bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return true;\n    }\n    if (ms[in] || limit < i + getAllMD(in)) {\n        return false;\n    }\n\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        if(bfs(i+1)) return true;\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n    return false;\n}\n\nstring iterative_deepening()\n{\n    limit = getAllMD(in);\n    for ( ; limit <= INF; limit++) {\n        if (bfs(0)) {\n            return in.path;\n        }\n    }\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    string ans = iterative_deepening();\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool istarget(Puzzle p){\n  for(int i=0;i<N2;i++){\n    if(p.f[i]!=(i+1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(istarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int i=0;i<4;i++){\n      int tx=sx+dx[i];\n      int ty=sy+dy[i];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[i];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle& p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nint dx[5] = {0, 0, 1, -1};\nint dy[5] = {1, -1, 0, 0};\n//string dir[5] = {\"r\", \"l\", \"d\", \"u\"};//å³ãå·¦ãä¸ãä¸\nchar dir[5] = {'r', 'l', 'd', 'u'};//å³ãå·¦ãä¸ãä¸\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i=0; i<N2; i++)\n        {\n            if(f[i]==p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nPuzzle P;\nbool isTarget(Puzzle s)\n{\n    for(int i=0; i<N2-1; i++)\n    {\n        if(s.f[i]!=i+1) return 0;\n    }\n    return 1;\n}\nint bfs(Puzzle P)\n{\n    map<Puzzle, bool> V;\n    queue<Puzzle> Q;\n    Q.push(P);\n    V[P] = true;\n    Puzzle u, v;\n    while(!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path.size();\n        int sx = u.space/N, sy = u.space%N;\n        //cout << 1 << endl;\n        for(int i=0; i<4; i++)\n        {\n            int tx = sx + dx[i], ty = sy + dy[i];\n            if(tx>=N || tx<0 || ty>=N || ty<0) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N+ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[i];\n                Q.push(v);\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    for(int i=0; i<N2; i++)\n    {\n        cin >> P.f[i];\n        if(P.f[i]==0)\n        {\n            P.space = i;\n        }\n    }\n    P.path = \"\";\n    cout << bfs(P) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tconst int ansval = 123456780;\n\tconst int ansarray[N*N] = {1,2,3,4,5,6,7,8,0};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid valuetoarray(uint t,int *table){\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tuint getscore(uint t){\n\t\tint table[N*N];\n\t\tuint score = 0;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tfor(int j=0;j<N*N;++j){\n\t\t\t\tif(ansarray[i]==table[j]){\n\t\t\t\t\tscore += (i/N-j/N)*(i/N-j/N)+(i%N-j%N)*(i%N-j%N);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t\tscore = getscore(table);\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool operator<(const State& s) const{\n\t\t\treturn score < s.score;\n\t\t}\n\t\tbool operator>(const State& s) const{\n\t\t\treturn score > s.score;\n\t\t}\n\t\tbool isfinished() const{\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t\tuint score;\n\t};\n\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tif(table[i]==0){\n\t\t\t\tzi = i/N;\n\t\t\t\tzj = i%N;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::map<uint, bool> visited;\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\tif(init.isfinished()){\n\t\tstd::cout<<0<<std::endl;\n\t\treturn 0;\n\t}\n//\tstd::priority_queue<State,std::vector<State>,std::greater<State> > Q;\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(visited.find(states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_13_B\n// Heuristic Search - 8 Puzzle\n// status:\n// tag: [bfs]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <map>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct puzzle {\n    int p[N2];\n    string path;\n    int space;\n\n    bool is_complete() {\n        // complete pattern is:\n        // 1 2 3\n        // 4 5 6\n        // 7 8 9\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] != i + 1) return false;\n        }\n\n        return true;\n    }\n\n    bool operator<(const puzzle& other) const {\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] == other.p[i]) continue;\n            return other.p[i] < p[i];\n        }\n\n        // equal\n        return false;\n    }\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char direction[] = {'l', 'd', 'r', 'u'};\n\nint to_index(int x, int y) { return y * N + x; }\nint to_x(int index) { return index % N; }\nint to_y(int index) { return index / N; }\n\nqueue<puzzle> pq;\n\nstring bfs() {\n    map<puzzle, bool> puzzle_memory;\n\n    while (!pq.empty()) {\n        auto curr_puzzle = pq.front();\n        pq.pop();\n\n        int curr_x = to_x(curr_puzzle.space), curr_y = to_y(curr_puzzle.space);\n        for (int r = 0; r < 4; ++r) {\n            int next_x = curr_x + dx[r], next_y = curr_y + dy[r];\n            if (next_x < 0 || N <= next_x || next_y < 0 || N <= next_y) continue;\n\n            auto next_puzzle = curr_puzzle;\n            next_puzzle.space = to_index(next_x, next_y);\n            swap(next_puzzle.p[curr_puzzle.space], next_puzzle.p[next_puzzle.space]);\n            // æ¢ã«åºç¾ããç¤é¢ãªãcontinue\n            if (puzzle_memory[next_puzzle]) continue;\n\n            next_puzzle.path += direction[r];\n            if (next_puzzle.is_complete()) return next_puzzle.path;\n\n            puzzle_memory[next_puzzle] = true;\n            pq.push(next_puzzle);\n        }\n    }\n\n    // fail\n    return \"\";\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(1 3 0\n4 2 5\n7 8 6\n)\";\n    stringstream stream(program_input_str);\n#endif\n    puzzle start_puzzle;\n    start_puzzle.path = \"\";\n\n    int value;\n    for (int y = 0; y < N; ++y) {\n        for (int x = 0; x < N; ++x) {\n            auto index = to_index(x, y);\n            stream >> value;\n            start_puzzle.p[index] = value;\n            if (value == 0) {\n                start_puzzle.p[index] = N2;\n                start_puzzle.space = index;\n            }\n        }\n    }\n\n    if (start_puzzle.is_complete()) {\n        cout << \"0\" << endl;\n    }\n    else {\n        pq.push(start_puzzle);\n        auto ans = bfs();\n        cout << ans.size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tif(used[v.men[0][0]][v.men[0][1]][v.men[0][2]][v.men[1][0]][v.men[1][1]][v.men[1][2]][v.men[2][0]][v.men[2][1]][v.men[2][2]]==false){\n\t\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t\tif(b==1)break;\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <stdio.h>\n\nusing namespace std;\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\nint main() {\n\tarray<array<int,3>,3> pz;\n\tqueue<pair<typeof(pz),int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst char answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<char> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<char> tiles;\n\npublic:\n    explicit board(vector<char> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(int moves, int cutoff){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > cutoff)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int ii;\n    REP(i, 9){\n        cin >> ii;\n        original[i] = ii;\n    }\n    int move = 0;\n    move = dfs(0, 100);\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<list>\n#include<queue>\n#define mm(a,b) memset(a,b,sizeof(a))\n#define ACCELERATE (ios::sync_with_stdio(false),cin.tie(0))\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n#define MAXN 0x3f3f3f3f3f3f3f3f\n#define PI acos(-1.0)\n#define E exp(1.0)\nusing namespace std;\n\n//#define debug\n\nstruct Puzzle{\n    int e[10];\n    int space;\n    int ans;\n};\n\nPuzzle tmp;\n\nbool state[362880];\n\nint kangtuo(int x[])  //åº·æå±å¼è¿è¡å¤é\n{\n    int fac[]={1,1,2,6,24,120,720,5040,40320};\n    int i,j,t,sum;\n    sum = 0;\n    for(i=0;i<9;i++)\n    {\n        t = 0;\n        for(j=i+1;j<9;j++)\n        {\n            if(x[j]<x[i])\n                t++;\n        }\n        sum = sum+t*fac[8-i];\n    }\n    if(state[sum]==1)\n        return 0;\n    else\n    {\n        state[sum] = 1;\n        return 1;\n    }\n}\n\nbool judge(Puzzle t){\n    for(int i=0;i<=8;i++){\n        if(t.e[i]!=i+1) return false;\n    }\n    return true;\n}\n\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={1,0,-1,0};\n\nint bfs(){\n    queue<Puzzle> q;\n    q.push(tmp);\n    while(!q.empty()){\n        Puzzle t=q.front();\n        q.pop();\n        kangtuo(t.e);\n        if(judge(t)) return t.ans;\n        for(int i=0;i<4;i++){\n            int sx=t.space/3+dx[i];\n            int sy=t.space%3+dy[i];\n            if(sx>=3||sy>=3||sx<0||sy<0){\n                continue;\n            }\n            Puzzle f;\n            f.ans=t.ans+1;\n            f.space=sx*3+sy;\n//            cout<<sx<<\" \"<<sy<<endl;\n            memcpy(f.e,t.e,sizeof(t.e));\n            swap(f.e[sx*3+sy],f.e[t.space]);\n            if(!kangtuo(f.e)) continue;\n\n            q.push(f);\n        }\n    }\n}\n\nint main()\n{\n    #ifdef debug\n    freopen(\"in.txt\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n    #endif // debug\n\n    ACCELERATE;\n    mm(state,0);\n    for(int i=0;i<9;i++){\n        cin>>tmp.e[i];\n        if(tmp.e[i]==0){\n            tmp.e[i]=9;\n            tmp.space=i;\n            tmp.ans=0;\n        }\n    }\n    int ans=bfs();\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans[3][3] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]){\n    for (int i = 0; i < 3; i++){\n        for (int j = 0; j < 3; j++){\n            if (f[i][j] != ans[i][j])\n                return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l){\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; i++){\n        for (int j = 0; j < 3; j++){\n            cin >> f[i][j];\n            if (f[i][j] == 0){\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 50; i++){\n        if ((res = dfs(f, x, y, -1, 0, i)) >= 0){\n            break;\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <istream>\n#include <ostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <random>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\ninline int abs(int i) {return i > 0 ? i : -i;}\n\nconstexpr int W = 3;\nconstexpr int H = 3;\nconstexpr int WH = W * H;\n\nenum class Direction {Left, Right, Up, Down};\n\nstruct Position\n{\n    int row;\n    int col;\n    bool slide(Direction d);\n};\n\ninline int pos2idx(const Position & pos) {return pos.row * W + pos.col;}\n\nusing Board = vector<int>;\n\nint calc_MHD(Board & board);\n\nPosition find_blank(Board & board);\n\n\nclass Status\n{\npublic:\n    // ctor\n    Status() = default;\n    Status(Board & board_, Position & blank_): board{board_}, blank{blank_} {mhd = calc_MHD(board_);};\n    Status(Board & board_): board{board_} {blank = find_blank(board_); mhd = calc_MHD(board_);};\n    // copy, move ctor\n    Status(const Status & status) = default;\n    Status(Status && status) = default;\n    // copy, move assignment\n    Status& operator=(const Status & status) = default;\n    Status& operator=(Status && status) = default;\n    //detor\n    ~Status() = default;\n    \n    friend istream & operator>>(istream & is, Status & st);\n    \n    bool operator==(const Status & rhs) const {return board == rhs.board;};\n    bool operator<(const Status & rhs) const {return board < rhs.board;};\n    bool operator>(const Status & rhs) const {return board > rhs.board;};\n    \n    bool slide(Direction d);\n    \n    int get_mhd() const {return mhd;};\n    Board get_board() const {return board;};\n\nprivate:\n    Board board = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    Position blank = {2, 2};\n    int mhd = 0;\n    void _update();\n    void _update_after_slide(const Position & prev_blank);\n};\n\nistream & operator>>(istream & is, Board & board);\n\nint solve(Status status);\n\n////////////////////////////////////////////////\n// main function\n////////////////////////////////////////////////\nint main()\n{\n    Status status;\n    cin >> status;\n    cout << solve(status) << endl;\n    return 0;\n}\n\n\n////////////////////////////////////////////////\n\nint solve(Status status){\n    priority_queue< pair<int, Status>, vector< pair<int, Status> >, greater< pair<int, Status> > > pq;\n    map<Board, int> b2s;\n    \n    pq.emplace(0 + status.get_mhd(), status);\n    b2s[status.get_board()] = 0;\n    while (not pq.empty()){\n        int p;\n        Status st;\n        tie(p, st) = pq.top();\n        pq.pop();\n        if (st.get_mhd() == 0) return p;\n        int steps = p - st.get_mhd();\n        auto bd = st.get_board();\n        if (b2s[bd] < steps) continue;\n        for (auto d : {Direction::Left, Direction::Right, Direction::Up, Direction::Down}){\n            Status new_st{st};\n            if (new_st.slide(d)){\n                auto new_bd = new_st.get_board();\n                auto it = b2s.find(new_bd);\n                if (it == b2s.end() or it->second > steps + 1){\n                    b2s[new_bd] = steps + 1;\n                    pq.emplace(steps + 1 + new_st.get_mhd(), new_st);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint calc_MHD(Board & board){\n    // Calculates the sum of Manhattan distances\n    // from current position to goal position \n    // for all panels except blank (=0) panel. \n    int mhdist = 0;\n    int src = 0;\n    for (auto dst : board){\n        if (dst == 0){\n            ++src;\n            continue;\n        }\n        dst = (dst + WH - 1) % WH;\n        int drow = abs(src / W - dst / W);\n        int dcol = abs(src % W - dst % W);\n        mhdist += drow + dcol;\n        ++src;\n    }\n    return mhdist;\n}\n\n\nPosition find_blank(Board & board){\n    // Find a blank (=0) panel on a board with width=W and height=H\n    // and return its position (row, col).\n    for(int i = 0; i != WH; ++i){\n        if (board[i]) continue;\n        return {i / W, i % W};\n    }\n}\n\n\nistream & operator>>(istream & is, Board & board){\n    for (int i = 0; i != WH; ++i){\n        cin >> board[i];\n    }\n    return is;\n}\n\n\nistream & operator>>(istream & is, Status & st){\n    is >> st.board;\n    st._update();\n    return is;\n}\n\nbool Position::slide(Direction d){\n    switch(d){\n        case Direction::Left:\n            if (col <= 0) return false;\n            --col;\n            break;\n        case Direction::Right:\n            if (col >= W - 1) return false;\n            ++col;\n            break;\n        case Direction::Up:\n            if (row <= 0) return false;\n            --row;\n            break;\n        case Direction::Down:\n            if (row >= H - 1) return false;\n            ++row;\n            break;\n    }\n    return true;\n}\n\nbool Status::slide(Direction d){\n    Position prev_blank = blank;\n    if (blank.slide(d)){\n        // post_process\n        _update_after_slide(prev_blank);\n        return true;\n    }else{\n        // can't slide\n        return false;\n    }\n}\n\nvoid Status::_update(){\n    blank = find_blank(board);\n    mhd = calc_MHD(board);\n}\n\nvoid Status::_update_after_slide(const Position & prev_blank){\n    auto prev_idx = pos2idx(prev_blank);\n    auto new_idx = pos2idx(blank);\n    auto panel_val = board[new_idx];\n    // update Manhattan disntance\n    // panel_val has moved from prev_blank to blank.\n    int row_final = (panel_val - 1) / W;\n    int col_final = (panel_val - 1) % W;\n    // subtract the Manhattan distance from the previous position of panel_val,\n    // which is the same as the current position of blank, to the final position of panel_val.\n    mhd -= abs(row_final - blank.row) + abs(col_final - blank.col);\n    // add the Manhattan distance from the current position of panel_val,\n    // which is the same as the previous position of blank, to the final position of panel_val.\n    mhd += abs(row_final - prev_blank.row) + abs(col_final - prev_blank.col);\n    \n    // swap 0 and panel_val\n    board[prev_idx] = panel_val;\n    board[new_idx] = 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char dir[4] = {'u','l','d','r'};\n\n\ntypedef struct Puzzle {\n\tint M[N2]; //ç¶æ \n\tint space; //ç©ºæ ¼ä½ç½® \n\tstring path; //è®°å½ç©ºæ ¼çç§»å¨è·¯å¾ \n\t\n\tbool operator<(const Puzzle & p) const {\n\t\tfor (int i=0;i<N2;i++) {\n\t\t\tif (M[i] == p.M[i]) continue;\n\t\t\treturn M[i] > p.M[i]; //ä¸ºäºè®©åé¢çæçç¶æé å \n\t\t}\n\t\treturn false;\n\t}\n\t\n} Puzzle;\n\nbool isTarget(Puzzle & p) {\n\tfor (int i=0;i<N2-1;i++) {\n\t\tif (p.M[i] != i+1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) { //å¹¿åº¦ä¼åæç´¢ \n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\tp.path = \"\";\n\tQ.push(p);\n\tV[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u)) {\n\t\t\treturn u.path;\n\t\t}\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\t//æç´¢åä¸ªæ¹å \n\t\tfor (int r=0;r<4;r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue; //ä¸å­å¨çæåµ\n\t\t\tint tspace = tx * N + ty; //æ°çç©ºæ ¼ä½ç½®\n\t\t\tv = u;//æ·è´ä¸ä»½\n\t\t\tv.space = tspace; //æ¹åæ°æ®\n\t\t\tswap(v.M[u.space],v.M[v.space]);\n\t\t\t//æ£æ¥æ°çæçç¶ææ¯å¦å·²ç»å­å¨ \n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\tfor (int i=0;i<N2;i++) {\n\t\tcin >> in.M[i];\n\t\tif (in.M[i] == 0) {\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl; \n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n        return s.count * 2 - s.count % 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\nconst ll MAX = 3;\nll LIMIT = 35;\n\nll A[MAX][MAX];\nll x[4] = {0, 1, 0, -1};\nll y[4] = {1, 0, -1, 0};\n\nll dfs(pll s, ll match, pll prev = pll(-1, -1), ll cnt = 0) {\n    if (match == MAX * MAX - 1) {\n        return cnt;\n    }\n    if (LIMIT <= cnt)\n        return INF;\n    if (LIMIT < cnt + (MAX - s.first - 1) + (MAX - s.second - 1))\n        return INF;\n\n    ll ret = INF;\n    REP(i, 4) {\n        ll nx = x[i] + s.first, ny = y[i] + s.second;\n        if (nx < 0 || ny < 0 || nx >= MAX || ny >= MAX)\n            continue;\n        if (prev.first == nx && prev.second == ny)\n            continue;\n        ll m = match;\n        if (A[nx][ny] == nx * MAX + ny + 1)\n            m--;\n        else if (A[nx][ny] == s.first * MAX + s.second + 1)\n            m++;\n        swap(A[s.first][s.second], A[nx][ny]);\n        ret = std::min(ret, dfs(pll(nx, ny), m, s, cnt + 1));\n        swap(A[s.first][s.second], A[nx][ny]);\n    }\n    LIMIT = std::min(LIMIT, ret);\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    pll s;\n    REP(i, MAX) {\n        REP(j, MAX) {\n            cin >> A[i][j];\n            if (A[i][j] == 0)\n                s = pll(i, j);\n        }\n    }\n\n    ll match = 0;\n    REP(i, MAX) {\n        REP(j, MAX) {\n            ll num = i * MAX + j + 1;\n            if (A[i][j] == num)\n                match++;\n        }\n    }\n\n    cout << dfs(s, match) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,int> P;\nqueue<P > que;\nvoid move(string st,int x){\n  int pos;\n  int look[4]={-3,3,-1,1};//up do le ri\n  for(int i=0;i<9;i++){\n    if(st[i]=='0'){\n      pos=i;\n      break;\n    }\n  }\n  for(int i=0;i<4;i++){\n    string str=st;\n    if(i==2&&pos%3==0)continue;\n    if(i==3&&pos%3==2)continue;\n    int npos=pos+look[i];\n    if(npos>8||npos<0)continue;\n    swap(str[pos],str[npos]);\n    que.push(P(str,x+1));\n  }\n}\nint main(){\n  string puzzle=\"\";\n  string goal=\"123456780\";\n  map<string,bool> ma;\n  for(int i=0;i<9;i++){\n    int x;\n    cin >> x;\n    puzzle+='0'+x;\n  }\n  que.push(P(puzzle,0));\n  while(1){\n    P p=que.front();que.pop();\n    string puz=p.first;\n    int x=p.second;\n    if(puz==goal){\n      cout << x << endl;\n      break;\n    }\n    if(ma[puz])continue;\n    else ma[puz]=1;\n    move(puz,x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//8 Puzzle\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i = 0; i < N2; i++) {\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p) {\n    for(int i = 0; i < N2; i++) {\n        if(p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle p) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    p.path = \"\";\n    Q.push(p);\n    V[p] = true;\n    while(!Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space % N;\n        int sy = u.space / N;\n        for(int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            v.space = tx + N * ty;\n            swap(v.f[v.space], v.f[u.space]);\n            if(!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    for(int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if(in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    cout << bfs(in).size() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst int n = 3;\n\nstruct Puzzle {\n\tint f[n*n];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p)const {\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t};\n};\n\nbool istarget(Puzzle p) {\n\tfor (int i = 0; i < n*n; i++) {\n\t\tif (p.f[i] != (i + 1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tV[s] = true;\n\n\twhile (!q.empty()) {\n\t\tu = q.front();\n\t\tq.pop();\n\t\tif (istarget(u))return u.path;\n\t\tint sx = u.space / n;\n\t\tint sy = u.space % n;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= n)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*n + ty]);\n\t\t\tv.space = tx*n + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < n*n; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = n*n;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nconst static int N = 3;\nconst static int N2 = 9;\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0; i<N2; ++i){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nconst static int dx[4] = {-1, 0, 1, 0};\nconst static int dy[4] = {0, -1, 0, 1};\nconst static char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0; i<N2; ++i)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0; r<4; ++r){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space =i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n//    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for(int i=0;i<n;i++)\n#define N 9\n#define SQRTN 3\n#define LIMIT 100\nusing namespace std;\n\nint limit;\nint searchV[4][2] = {{0, 1},{1, 0},{0, -1},{-1, 0}};\n\nstruct Board{\n  int b[N], h;\n  int calcHeust(void){\n    h = 0;\n    for(int i = 0; i < SQRTN; i++){\n      for(int j = 0; j < SQRTN; j++){\n        if(b[i*SQRTN + j] == N-1) continue;\n        h += abs(b[i*SQRTN + j]/SQRTN-i) + abs(b[i*SQRTN + j]%SQRTN-j);\n      }\n    }\n    return h;\n  }\n};\n\nvoid printBoard(Board b){\n    rep(i, SQRTN){\n     rep(j, SQRTN){\n       cout << b.b[i*SQRTN + j];\n     }\n     cout << endl;\n    }\n}\n\n\nBoard currentState;\n\nbool dfs(int depth, int prev, int cbX, int cbY){\n  currentState.calcHeust();\n  if ( currentState.h == 0) return true;\n  if ( depth + currentState.h > limit ) return false;\n  \n  for (int d = 0 ; d < 4 ; d++ ){\n    int sx = cbX + searchV[d][0];\n    int sy = cbY + searchV[d][1];\n    if ( abs(d - prev) == 2 ) continue;\n    if ( sx < 0 || sy < 0 || sx >= SQRTN || sy >= SQRTN) continue;\n\n    swap(currentState.b[cbY*SQRTN + cbX], currentState.b[sy*SQRTN + sx]);\n    if (dfs(depth+1, d, sx, sy)) return true;\n    swap(currentState.b[cbY*SQRTN + cbX], currentState.b[sy*SQRTN + sx]);\n  }\n  \n  return false;\n}\n\nint idastar(Board in, int px, int py){\n  for (limit=0;limit < LIMIT;limit++){\n    currentState = in;\n    if (dfs(0, 100, px, py)) return limit;\n  }\n  return -1;\n}\n\nint main(void){\n  Board init;\n  int p0x, p0y;\n  rep(i, N){\n    cin >> init.b[i];\n    if (init.b[i]==0){\n      init.b[i] = N;\n      p0y = i/SQRTN;\n      p0x = i%SQRTN;\n    }\n    init.b[i]--;\n  }\n  cout << idastar(init, p0x, p0y) << endl;;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n\nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"unsolvable\";\n}\n\nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.sizu() << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<string>\n#include<queue>\n#include<iostream>\n#define N 3\n#define N2 9\nusing namespace std;\nstatic const char c[4] = {'u', 'd', 'l', 'r'};\nstatic const int x[4] = {-1, 1, 0, 0};\nstatic const int y[4] = {0, 0, -1, 1};\nstruct Puzzle\n{\n  int f[N2];  int space; // f[] to record number sequence, space to record the location of number '0';\n  string path;\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i=0; i<N2; i++)\n    {\n      if(f[i] == p.f[i])  continue;\n      else return f[i] < p.f[i];\n    }\n    return false;\n  }\n};\n\nbool istarget(Puzzle p)\n{\n  for(int i=0; i<N2; i++)\n  {\n    if(p.f[i] == i+1)\n      continue;\n    else return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle& p)\n{\n  queue<Puzzle> PQ;\n  Puzzle u, v;\n  p.path = \"\";\n  map<Puzzle, bool> V;\n  V[p] = true;\n  PQ.push(p);\n  while(!PQ.empty())\n  {\n    u = PQ.front(); PQ.pop();\n    if(istarget(u)) {return u.path;}\n    int sx, sy, tx, ty;\n    sx = u.space/N; sy = u.space % N;\n    for(int r=0; r<4; r++)\n    {\n      tx = sx + x[r]; ty = sy + y[r];\n      if(tx>=N || tx<0 || ty>=N || ty<0) continue;\n      v = u; v.space = tx*N + ty;v.path += c[r];\n      swap(v.f[sx*N + sy], v.f[tx*N + ty]);\n\n      if(V.find(v) == V.end())\n      {\n        V[v] = true;PQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main()\n{\n  Puzzle input;\n  for(int i=0; i<N2; i++)\n  {\n    scanf(\"%d\", &input.f[i]);\n    if(input.f[i] == 0)\n    {\n      input.f[i] = N2;\n      input.space = i;\n    }\n  }\n  string ans = bfs(input);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    if(check() == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(check() + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    return dfs(moves, cutoff+1);\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = dfs(0, check());\n\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p)const{\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif(p.f[i]!=(i+1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\nint main(){\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0){\n\t\t\tin.f[i]=N2;//set space\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int MAXN = 100005;\nconst int MAXE = 200005;\nconst int NIL = -1;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nconst char dir[4] = { 'u', 'r', 'd', 'l' };\nstruct Puzzle {\n\tint Sudoku[3][3];\n\tint space;\n\tstring path;\n\tbool operator<(const Puzzle& p) const\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tif (Sudoku[i][j] == p.Sudoku[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn Sudoku[i][j] < p.Sudoku[i][j];\n\t\treturn false;\n\t}\n};\n\nbool ok(const Puzzle &p)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tif (p.Sudoku[i][j] != i * 3 + j + 1)\n\t\t\t\treturn false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> vis;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tvis[s] = true;\n\twhile (!q.empty())\n\t{\n\t\tu = q.front();\n\t\tq.pop();\n\t\tif (ok(u))\n\t\t\treturn u.path;\n\t\tint x = (u.space - 1) / 3;\n\t\tint y = (u.space - 1) % 3;\n\t\t//cout << \"space == \" << u.space << \" x == \" << x << \" y == \" << y << endl;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.Sudoku[x][y], v.Sudoku[tx][ty]);\n\t\t\tv.space = tx * 3 + ty + 1;\n\t\t\tif (!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = true;\n\t\t\t\tv.path += dir[i];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tPuzzle s;\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tcin >> s.Sudoku[i][j];\n\t\t\tif (s.Sudoku[i][j] == 0)\n\t\t\t\ts.Sudoku[i][j] = 9, s.space = i * 3 + j + 1;\n\t\t}\n\tcout << bfs(s).size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < ( const Puzzle &p ) const {\n        for ( int i = 0; i < N2; i++ ) {\n            if ( f[i] == p.f[i] ) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if (isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for ( int r =0; r < 4; r++ ) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >=N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for ( int i = 0; i < N2; i++ ){\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define floot10 cout<<fixed<<setprecision(10);\n//#define int long long\n\nint goal,ans=INF;\nset<int> s;\ndecltype(s)::iterator it;\nint fh[3][3];\n\nint tohash(){\n\tint hash=0;\n\tlp(i,3){\n\t\tlp(j,3){\n\t\t\thash*=10;\n\t\t\thash+=fh[i][j];\n\t\t}\n\t}\n\treturn hash;\n}\n\nvoid fromhash(int h){\n\tlp(i,3){\n\t\tlp(j,3){\n\t\t\tfh[2-i][2-j]=h%10;\n\t\t\th/=10;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid solve(){\n\tlp(i,3)lp(j,3){\n\t\tfh[i][j]=i*3+j+1;\n\t}\n\tfh[2][2]=0;\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(tohash(),0));\n\tif(tohash()==goal){\n\t\tans=0;\n\t\treturn;\n\t}\n\tint cost;\n\tint x,y;\n\twhile(!q.empty()){\n\t\tcost=q.front().second;\n\t\tfromhash(q.front().first);\n\t\tq.pop();\n\t\tlp(i,3){\n\t\t\tlp(j,3){\n\t\t\t\tif(fh[i][j]==0){\n\t\t\t\t\tx=i;y=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x!=0){\n\t\t\tswap(fh[x][y],fh[x-1][y]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x-1][y]);\n\t\t}\n\t\tif(y!=0){\n\t\t\tswap(fh[x][y],fh[x][y-1]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x][y-1]);\n\t\t}\n\t\tif(x!=2){\n\t\t\tswap(fh[x][y],fh[x+1][y]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x+1][y]);\n\t\t}\n\t\tif(y!=2){\n\t\t\tswap(fh[x][y],fh[x][y+1]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x][y+1]);\n\t\t}\n\t}\n}\n\nsigned main(){\n\tlp(i,3){\n\t\tlp(j,3){\n\t\t\tcin>>fh[i][j];\n\t\t}\n\t}\n\tgoal=tohash();\n\ts.insert(goal);\n\tsolve();\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        \n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nset<Board> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    if (history.insert(s.board).second) {\n        ++s.count;\n        q.push_back(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push_back({ board, 0 });\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nusing board = vector<int>;\n \nint h, w, n;\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n \nstruct state{\n    int score, dist;\n    board b;\n \n    state(int s, int d, board b): score(s), dist(d), b(b){}\n};\n \nint xy_to_id(int x, int y){\n    return x*w + y;\n}\n \npair<int, int> id_to_xy(int i){\n    return {i/w, i%w};\n}\n \npair<int, int> blank(board &b){\n    for(int i=0; i<n; ++i){\n        if(b[i] == n-1) return id_to_xy(i);\n    }\n}\n \nbool check(board &b){\n    for(int i=0; i<n; ++i){\n        if(b[i] != i) return false;\n    }\n    return true;\n}\n \nint heuristic_func(board &b){\n    int ret = 0;\n    for(int i=0; i<n; ++i)if(b[i] != n-1) ret += (b[i] != i);\n    return ret;\n}\n \nint main(){\n    h = w = 3;\n    n = h * w;\n \n    board b(n);\n    for(int i=0; i<n; ++i){\n        int c;\n        cin >> c;\n        b[i] = (c == 0 ? n-1 : c-1);\n    }\n \n    auto cmp = [](const state &s1, const state &s2){\n        if(s1.score == s2.score){\n            if(s1.dist == s2.dist) return s1.b < s2.b;\n            return s1.dist < s2.dist;\n        }\n        return s1.score < s2.score;\n    };\n    map<board, int> min_score;\n    set<state, decltype(cmp)> open_list(cmp);\n    state init_state = {heuristic_func(b), 0, b};\n    open_list.insert(init_state);\n    min_score[init_state.b] = init_state.score;\n \n    while(!open_list.empty()){\n        auto cur_state = *open_list.begin();\n        open_list.erase(cur_state);\n        if(cur_state.score > 45 ||  cur_state.score > min_score[cur_state.b]) continue;\n \n        auto bxy = blank(cur_state.b);\n        for(int i=0; i<4; ++i){\n            int nx = bxy.first + dx[i], ny = bxy.second + dy[i];\n            if(0<=nx && nx<h && 0<=ny && ny<w){\n                auto nxt_state = cur_state;\n                swap(nxt_state.b[xy_to_id(nx, ny)], nxt_state.b[xy_to_id(bxy.first, bxy.second)]);\n                nxt_state.dist = cur_state.dist + 1;\n                nxt_state.score = nxt_state.dist + heuristic_func(nxt_state.b);\n                if(nxt_state.score > 45) continue;\n                if(min_score.find(nxt_state.b) == min_score.end() || min_score[nxt_state.b] > nxt_state.score){\n                    min_score[nxt_state.b] = nxt_state.score;\n                    open_list.insert(nxt_state);\n                }\n            }\n        }\n    }\n    \n    board cur_board(n);\n    for(int i=0; i<n; ++i) cur_board[i] = i;\n    cout << min_score[cur_board] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <istream>\n#include <ostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <random>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\ninline int abs(int i) {return i > 0 ? i : -i;}\n\nconstexpr int W = 3;\nconstexpr int H = 3;\nconstexpr int WH = W * H;\n\nenum class Direction {Left, Right, Up, Down};\n\nstruct Position\n{\n    int row;\n    int col;\n    bool slide(Direction d);\n};\n\ninline int pos2idx(const Position & pos) {return pos.row * W + pos.col;}\n\nusing Board = vector<int>;\n\nint calc_MHD(Board & board);\n\nPosition find_blank(Board & board);\n\n\nclass Status\n{\npublic:\n    // ctor\n    Status() = default;\n    Status(Board & board_, Position & blank_): board{board_}, blank{blank_} {mhd = calc_MHD(board_);};\n    Status(Board & board_): board{board_} {blank = find_blank(board_); mhd = calc_MHD(board_);};\n    // copy, move ctor\n    Status(const Status & status) = default;\n    Status(Status && status) = default;\n    // copy, move assignment\n    Status& operator=(const Status & status) = default;\n    Status& operator=(Status && status) = default;\n    //detor\n    ~Status() = default;\n    \n    friend istream & operator>>(istream & is, Status & st);\n    \n    bool operator==(const Status & rhs) const {return board == rhs.board;};\n    bool operator<(const Status & rhs) const {return board < rhs.board;};\n    bool operator>(const Status & rhs) const {return board > rhs.board;};\n    \n    bool slide(Direction d);\n    \n    int get_mhd() const {return mhd;};\n    Board get_board() const {return board;};\n\nprivate:\n    Board board = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    Position blank = {2, 2};\n    int mhd = 0;\n    void _update();\n    void _update_after_slide(const Position & prev_blank);\n};\n\nistream & operator>>(istream & is, Board & board);\n\nint solve(Status status);\n\n////////////////////////////////////////////////\n// main function\n////////////////////////////////////////////////\nint main()\n{\n    Status status;\n    cin >> status;\n    cout << solve(status);\n    return 0;\n}\n\n\n////////////////////////////////////////////////\n\nint solve(Status status){\n    priority_queue< pair<int, Status>, vector< pair<int, Status> >, greater< pair<int, Status> > > pq;\n    map<Board, int> b2s;\n    \n    pq.emplace(0 + status.get_mhd(), status);\n    b2s[status.get_board()] = 0;\n    while (not pq.empty()){\n        int p;\n        Status st;\n        tie(p, st) = pq.top();\n        pq.pop();\n        if (st.get_mhd() == 0) return p;\n        int steps = p - st.get_mhd();\n        auto bd = st.get_board();\n        if (b2s[bd] < steps) continue;\n        for (auto d : {Direction::Left, Direction::Right, Direction::Up, Direction::Down}){\n            Status new_st{st};\n            if (new_st.slide(d)){\n                auto new_bd = new_st.get_board();\n                auto it = b2s.find(new_bd);\n                if (it == b2s.end() or it->second > steps + 1){\n                    b2s[new_bd] = steps + 1;\n                    pq.emplace(steps + 1 + new_st.get_mhd(), new_st);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint calc_MHD(Board & board){\n    // Calculates the sum of Manhattan distances\n    // from current position to goal position \n    // for all panels except blank (=0) panel. \n    int mhdist = 0;\n    int src = 0;\n    for (auto dst : board){\n        if (dst == 0){\n            ++src;\n            continue;\n        }\n        dst = (dst + WH - 1) % WH;\n        int drow = abs(src / W - dst / W);\n        int dcol = abs(src % W - dst % W);\n        mhdist += drow + dcol;\n        ++src;\n    }\n    return mhdist;\n}\n\n\nPosition find_blank(Board & board){\n    // Find a blank (=0) panel on a board with width=W and height=H\n    // and return its position (row, col).\n    for(int i = 0; i != WH; ++i){\n        if (board[i]) continue;\n        return {i / W, i % W};\n    }\n}\n\n\nistream & operator>>(istream & is, Board & board){\n    for (int i = 0; i != WH; ++i){\n        cin >> board[i];\n    }\n    return is;\n}\n\n\nistream & operator>>(istream & is, Status & st){\n    is >> st.board;\n    st._update();\n    return is;\n}\n\nbool Position::slide(Direction d){\n    switch(d){\n        case Direction::Left:\n            if (col <= 0) return false;\n            --col;\n            break;\n        case Direction::Right:\n            if (col >= W - 1) return false;\n            ++col;\n            break;\n        case Direction::Up:\n            if (row <= 0) return false;\n            --row;\n            break;\n        case Direction::Down:\n            if (row >= H - 1) return false;\n            ++row;\n            break;\n    }\n    return true;\n}\n\nbool Status::slide(Direction d){\n    Position prev_blank = blank;\n    if (blank.slide(d)){\n        // post_process\n        _update_after_slide(prev_blank);\n        return true;\n    }else{\n        // can't slide\n        return false;\n    }\n}\n\nvoid Status::_update(){\n    blank = find_blank(board);\n    mhd = calc_MHD(board);\n}\n\nvoid Status::_update_after_slide(const Position & prev_blank){\n    auto prev_idx = pos2idx(prev_blank);\n    auto new_idx = pos2idx(blank);\n    auto panel_val = board[new_idx];\n    // update Manhattan disntance\n    // panel_val has moved from prev_blank to blank.\n    int row_final = (panel_val - 1) / W;\n    int col_final = (panel_val - 1) % W;\n    // subtract the Manhattan distance from the previous position of panel_val,\n    // which is the same as the current position of blank, to the final position of panel_val.\n    mhd -= abs(row_final - blank.row) + abs(col_final - blank.col);\n    // add the Manhattan distance from the current position of panel_val,\n    // which is the same as the previous position of blank, to the final position of panel_val.\n    mhd += abs(row_final - prev_blank.row) + abs(col_final - prev_blank.col);\n    \n    // swap 0 and panel_val\n    board[prev_idx] = panel_val;\n    board[new_idx] = 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \nqueue<char>Q[3][3];\nqueue<char>R[3][3];\n \nint main() {\n    int a, b, c, d, e, sum=0;\n    int x[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> a;\n            Q[i][j].push(a);\n        }\n    }\n    while (true) {\n        while (!Q[0][0].empty()) {\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (Q[i][j].front() == 0) {\n                        b = i;\n                        c = j;\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (x[0][0] == 1 && x[0][1] == 2 && x[0][2] == 3 && x[1][0] == 4 && x[1][1] == 5 && x[1][2] == 6 && x[2][0] == 7 && x[2][1] == 8) {\n                goto owata;\n            }\n            if (b >= 1) {\n                d = x[b][c];\n                e = x[b - 1][c];\n                x[b][c] = e;\n                x[b - 1][c] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (b <= 1) {\n                d = x[b][c];\n                e = x[b + 1][c];\n                x[b][c] = e;\n                x[b + 1][c] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (c >= 1) {\n                d = x[b][c];\n                e = x[b][c - 1];\n                x[b][c] = e;\n                x[b][c - 1] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (c <= 1) {\n                d = x[b][c];\n                e = x[b][c + 1];\n                x[b][c] = e;\n                x[b][c + 1] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    Q[i][j].pop();\n                }\n            }\n        }\n        while (!R[0][0].empty()) {\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    Q[i][j].push(R[i][j].front());\n                    R[i][j].pop();\n                }\n            }\n        }\n        sum++;\n    }\nowata:;\n    cout << sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\ntypedef long long ll;\n\nP Dir[4] = {\n\tP(-1, 0),\n\tP(0, -1),\n\tP(1, 0),\n\tP(0, 1),\n};\n\nll pow17[15];\n\nvoid Init() {\n\tpow17[0] = 1;\n\tfor (int i = 1; i < 15; ++i) {\n\t\tpow17[i] = pow17[i-1]*17;\n\t}\n}\n\nclass Puzzle {\nprivate:\n\tint W, H;\n\tint holes;\n\tint board[4][4];\n\tint coe[4][4];\n\tmap<int, P> rboard;\n\tll hash, gHash;\n\npublic:\n\tPuzzle(int W, int H) : W(W), H(H) {\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tholes = 0;\n\t\trboard.clear();\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tboard[y][x] = k;\n\t\t\t}\n\t\t}\n\t\tinitCoe();\n\t\tinitHash();\n\t}\n\tvoid setTile(int x, int y, int v) {\n\t\tint pv = board[y][x];\n\t\tif (pv < 0) --holes;\n\t\tif (v < 0) ++holes;\n\t\tboard[y][x] = v;\n\t\trboard[v] = P(x, y);\n\t\thash += ((v < 0 ? 0 : v) - (pv < 0 ? 0 : pv)) * pow17[coe[y][x]];\n\t}\n\tvoid initCoe() {\n\t\tfor (int y = 0, k = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tcoe[y][x] = k++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoe[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgHash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint x = (v-1)%W, y = (v-1)/W;\n\t\t\t\t\tgHash += v * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getTile(int x, int y) {\n\t\treturn board[y][x];\n\t}\n\tbool swap(int x1, int y1, int x2, int y2) {\n\t\tint v1 = getTile(x1, y1), v2 = getTile(x2, y2);\n\t\tif (v1 == 0 || v2 == 0 || (v1 < 0 && v2 == 0)) return false;\n\t\tsetTile(x1, y1, v2);\n\t\tsetTile(x2, y2, v1);\n\t\treturn true;\n\t}\n\tbool isComplete() {\n\t\treturn hash == gHash;\n/*\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tint v = board[y][x];\n\t\t\t\tif (v > 0 && k != v) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n*/\n\t}\n\tbool isOut(int x, int y ) {\n\t\treturn x < 0 || x >= W || y < 0 || y >= H;\n\t}\n\tvoid move(int dir) {\n\t\tdir = (dir + 2) % 4;\n\t\tvector< pair<P, int> > v;\n\t\tfor (int i = 0; i < holes; ++i) {\n\t\t\tP& p = rboard[-(i+1)];\n\t\t\tint x = p.real(), y = p.imag();\n\t\t\tint nx = x + Dir[dir].real(), ny = y + Dir[dir].imag();\n\t\t\tif (isOut(nx, ny)) continue;\n\t\t\tif (getTile(nx, ny) < 0) continue;\n\t\t\tv.push_back( pair<P, int>(p, getTile(nx, ny)) );\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tint x = v[i].first.real(), y = v[i].first.imag();\n\t\t\tP p = rboard[v[i].second];\n\t\t\tswap(x, y, p.real(), p.imag());\n\t\t}\n\t}\n\tvoid draw() {\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (x) cout << \" \";\n\t\t\t\tprintf(\"%2d\", getTile(x, y));\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tll getHash() {\n\t\treturn hash;\n\t}\n\tvoid initHash() {\n\t\thash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v != 0) {\n\t\t\t\t\thash += (v < 0 ? 0 : v) * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid setHash(ll h) {\n\t\tint k = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tint v = h%17; if (v == 0) v = --k;\n\t\t\t\t\tsetTile(x, y, v);\n\t\t\t\t\th /= 17;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getH() {\n\t\tint res = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint gx = (v-1)%W, gy = (v-1)/W;\n\t\t\t\t\tres += abs(gx-x) + abs(gy-y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint getHoles() {\n\t\treturn holes;\n\t}\n\tll getGHash() {\n\t\treturn gHash;\n\t}\n};\n\nstruct Node {\n\tll hash;\n\tint step, h;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.h > n2.h;\n}\n\nint main() {\n\tInit();\n\n//\tint W, H; cin >> W >> H;\n\tint W = 3, H = 3;\n\tPuzzle puzzle(W, H);\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tint v; cin >> v;\n\t\t\tif (v == 0) v = -1;\n\t\t\tpuzzle.setTile(x, y, v);\n\t\t}\n\t}\n\tpuzzle.initCoe();\n\tpuzzle.initHash();\n\n\tint s = 0;\n\n\tset<ll> gone;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push((Node){puzzle.getHash(), 0, puzzle.getH()});\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tll hash = node.hash;\n\t\tint step = node.step;\n\n\t\tif (step > s) {\n//\t\t\ts = step;\n//\t\t\tcout << s << endl;\n\t\t}\n\n\t\tif (gone.count(hash)) continue;\n\t\tgone.insert(hash);\n\n\t\tif (puzzle.getGHash() == hash) {\n\t\t\tcout << step << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tpuzzle.setHash(hash);\n\t\t\tpuzzle.move(i);\n\t\t\tll h = puzzle.getHash();\n\t\t\tif (gone.count(h) == 0) {\n\t\t\t\tQ.push((Node){h, step+1, step*puzzle.getHoles()+puzzle.getH()});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (n.f[i] == f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > n.f[i];\n\t\t}\n\t\treturn false;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{  \n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nstruct Info{\n\tInfo(){data = count = 0;}\n\tInfo(long long arg_data,int arg_count){\n\t\tdata = arg_data;\n\t\tcount = arg_count;\n\t}\n\tlong long data;\n\tint count;\n};\n\nclass LongQ{\npublic:\n\tLongQ(){\n\t\tQ = new Info[362880];\n\t\thead = tail = num_of_data=0;\n\t}\n\n\tvoid enqueue(long long arg_data,int arg_count){\n\t\tQ[tail].count = arg_count;\n\t\tQ[tail].data = arg_data;\n\t\tnum_of_data++;\n\t\ttail = (tail+1)%362880;\n\t}\n\n\tInfo dequeue(){\n\t\tInfo ret = Q[head];\n\t\thead = (head+1)%362880;\n\t\tnum_of_data--;\n\t\treturn ret;\n\t}\n\n\tbool isEmpty(){\n\t\treturn num_of_data == 0;\n\t}\n\nprivate:\n\tInfo* Q;\n\tint head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo){\n\tif(checkTable[translateORDER(table)] == -1){\n\t\tcheckTable[translateORDER(table)]=tmpInfo.count;\n\t\tqueue.enqueue(makeLong(table),tmpInfo.count+1);\n\t}\n\treturn queue;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tLongQ queue;\n\n\tqueue.enqueue(makeLong(table),0);\n\n\tInfo tmpInfo;\n\n\twhile(queue.isEmpty()==false){\n\t\ttmpInfo=queue.dequeue();\n\n\t\tint tmpTable[3][3];\n\t\tsetNUM(tmpTable,tmpInfo.data);\n\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\tprintf(\"%d\\n\",tmpInfo.count);\n\t\t\tbreak;\n\t\t}\n\n\t\tint next_table[4][3][3];\n\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(zeroLoc(tmpTable)){\n\t\tcase 0: //??????\n\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\t\t\tbreak;\n\t\tcase 2:\t//??????\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tqueue = func(queue,next_table[3],tmpInfo);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\t\t\tbreak;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator<(const Puzzle &p)const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic const char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++)\n\t\tif (p.f[i] != (i + 1))return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space%N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N + ty]);\n\t\t\tv.space = tx*N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] == N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_D 3\n#define MAX_N 9\n#define MAX_C 362880\nint fact1[MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][2];\nvector<int> fact2[MAX_C]; int MAP[MAX_D][MAX_D]; int DP[MAX_C], K;\nvoid FACT() {\n\tint a[MAX_N]; for (int i = 0; i < MAX_N; i++) { a[i] = i; }int cnt = 0;\n\tdo {\n\t\tif (a[MAX_N - 2] < a[MAX_N - 1]) { fact1[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][0] = cnt; }\n\t\tvector<int>vec; for (int i = 0; i < MAX_N; i++) { vec.push_back(a[i]); }fact2[cnt] = vec; cnt++;\n\t} while (next_permutation(a, a + MAX_N));\n}\nint main() {\n\tfor (int i = 0; i < MAX_D; i++) {\n\t\tfor (int j = 0; j < MAX_D; j++) { cin >> MAP[i][j]; }\n\t}FACT(); for (int i = 0; i < MAX_C; i++) { DP[i] = MAX_C; }\n\tif (MAP[2][1] < MAP[2][2]) { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][0]; }\n\telse { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][1]; }DP[K] = 0;\n\twhile (DP[0] == MAX_C) {\n\t\tfor (int i = 0; i < MAX_C; i++) {\n\t\t\tif (DP[i] >= MAX_C) { continue; }vector<int>X = fact2[i]; int y[MAX_D][MAX_D], z[MAX_D][MAX_D], cx, cy; int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int j = 0; j < X.size(); j++) { y[j / 3][j % 3] = X[j]; if (X[j] == 0) { cx = j / 3; cy = j % 3; } }\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) { z[k / 3][k % 3] = y[k / 3][k % 3]; }int ex = cx + dx[j], ey = cy + dy[j];\n\t\t\t\tswap(z[cx][cy], z[ex][ey]);\n\t\t\t\tif (z[2][1] < z[2][2]) { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][0]; }\n\t\t\t\telse { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][1]; }DP[K] = min(DP[K], DP[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[0] << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst long double EPS = 1e-10;\n\nstruct Puzzle {\n  int f[9];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    rep(i, 9) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nconst char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  rep(i, 9) {\n    if (p.f[i] != i + 1) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    if (isTarget(u)) return u.path;\n    int sx = u.space / 3;\n    int sy = u.space % 3;\n    rep(r, 4) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * 3 + ty]);\n      v.space = tx * 3 + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n}\n\nint main() {\n  Puzzle in;\n\n  rep(i, 9) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = 9;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 50){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0() {\n    int find = -1;\n    while(next_state.size()) {\n        auto end = chrono::system_clock::now();\n        auto dur = end - start;\n        auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n        if (msec > LIMIT_TIME) break;\n\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                if (tmp == ans_str) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h0();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n    int S = 100000000;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            table[i][k] = x/S;\n            x = x%S;\n            S /= 10;\n        }\n    }\n}\n\nint getNUM(int x){\n    switch(x){\n    case 0:return 1;\n    case 1:return 1;\n    case 2:return 2;\n    case 3:return 6;\n    case 4:return 24;\n    case 5:return 120;\n    case 6:return 720;\n    case 7:return 5040;\n    case 8:return 40320;\n    }\n    return -1;\n}\n\nlong long makeLong(int Table[3][3]){\n    return 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n    long long x = makeLong(Table);\n    int checkTable[9] = {0};\n    long long S = 100000000;\n    int ret = 0,small_num_appear_count;\n    for(int i=8; i >= 0; i--){\n        small_num_appear_count=0;\n        for(int k = 0; k < (x/S);k++){\n            if(checkTable[k] == 1)small_num_appear_count++;\n        }\n        ret += ((x/S)-small_num_appear_count)*getNUM(i);\n        checkTable[(x/S)]=1;\n        x %= S;\n        S /= 10;\n    }\n\n    return ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n    int sum = 0;\n    for(int row=0;row<3;row++){\n        for(int col=0;col<3;col++){\n            if(table[row][col] != 0){\n                sum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n            }\n        }\n    }\n    return sum;\n}\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nstruct Info{\n    Info(){ zero_loc=data = count = 0;}\n    Info(long long arg_data,int arg_count,short arg_loc){\n        data = arg_data;\n        count = arg_count;\n        zero_loc = arg_loc;\n    }\n    long long data;\n    int count;\n    short zero_loc;\n};\n\nclass LongQ{\npublic:\n    LongQ(){\n        Q = new Info[362880];\n        head = tail = num_of_data=0;\n    }\n\n    void enqueue(long long arg_data,int arg_count,short arg_loc){\n        Q[tail].count = arg_count;\n        Q[tail].data = arg_data;\n        Q[tail].zero_loc = arg_loc;\n        num_of_data++;\n        tail = (tail+1)%362880;\n    }\n\n    Info dequeue(){\n        Info ret = Q[head];\n        head = (head+1)%362880;\n        num_of_data--;\n        return ret;\n    }\n\n    bool isEmpty(){\n        return num_of_data == 0;\n    }\n\nprivate:\n    Info* Q;\n    int head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo,short zero_loc){\n    if(checkTable[translateORDER(table)] == -1){\n        checkTable[translateORDER(table)]=tmpInfo.count;\n        queue.enqueue(makeLong(table),tmpInfo.count+1,zero_loc);\n    }\n    return queue;\n}\n\nint main(){\n\n    for(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n    int table[3][3];\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n\n    checkTable[translateORDER(table)]=0;\n    LongQ queue;\n\n    queue.enqueue(makeLong(table),0,zeroLoc(table));\n\n    Info tmpInfo;\n\n    while(queue.isEmpty()==false){\n        tmpInfo=queue.dequeue();\n\n        int tmpTable[3][3];\n        setNUM(tmpTable,tmpInfo.data);\n        if(calcDiffSum(tmpTable)==0){\n            printf(\"%d\\n\",tmpInfo.count);\n            break;\n        }\n\n        int next_table[4][3][3];\n\n        for(int a=0;a<4;a++){\n            for(int b=0;b<3;b++){\n                for(int c=0;c<3;c++){\n                    next_table[a][b][c] = tmpTable[b][c];\n                }\n            }\n        }\n\n        switch(tmpInfo.zero_loc){\n        case 0:\n            swap(next_table[0][0][0],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][0],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n            break;\n        case 1:\n            swap(next_table[0][0][1],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][0][1],next_table[1][0][2]);\n            queue = func(queue,next_table[1],tmpInfo,2);\n\n            swap(next_table[2][0][1],next_table[2][1][1]);\n            queue = func(queue,next_table[2],tmpInfo,11);\n            break;\n        case 2:\n            swap(next_table[0][0][2],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][2],next_table[1][1][2]);\n            queue = func(queue,next_table[1],tmpInfo,12);\n\n            break;\n        case 10:\n            swap(next_table[0][1][0],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][1][0],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][0],next_table[2][2][0]);\n            queue = func(queue,next_table[2],tmpInfo,20);\n\n            break;\n        case 11:\n            swap(next_table[0][1][1],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][1][1],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n\n            swap(next_table[2][1][1],next_table[2][1][2]);\n            queue = func(queue,next_table[2],tmpInfo,12);\n\n            swap(next_table[3][1][1],next_table[3][2][1]);\n            queue = func(queue,next_table[3],tmpInfo,21);\n            break;\n        case 12:\n            swap(next_table[0][1][2],next_table[0][0][2]);\n            queue = func(queue,next_table[0],tmpInfo,2);\n\n            swap(next_table[1][1][2],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][2],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 20:\n            swap(next_table[0][2][0],next_table[0][1][0]);\n            queue = func(queue,next_table[0],tmpInfo,10);\n\n            swap(next_table[1][2][0],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        case 21:\n            swap(next_table[0][2][1],next_table[0][2][0]);\n            queue = func(queue,next_table[0],tmpInfo,20);\n\n            swap(next_table[1][2][1],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][2][1],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 22:\n            swap(next_table[0][2][2],next_table[0][1][2]);\n            queue = func(queue,next_table[0],tmpInfo,12);\n\n            swap(next_table[1][2][2],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p)const\n\t{\n\t\tREP(i,N2)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool istgt(Puzzle p)\n{\n\tREP(i,N2)\n\t{\n\t\tif(p.f[i]!=(i+1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(istgt(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tREP(r,4)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tREP(i,N2)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    queue<int> que;\n    que.push(start);\n    visited[start] = 0;\n    while(visited[goal]==-1){\n        int now = que.front();\n        que.pop();\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            visited[adj] = visited[now]+1;\n            que.push(adj);\n        }\n    }\n    cout << visited[goal] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nusing Weight=int;\nusing Encoded=int;\n\nstruct State {\n    Weight hcost, acost;\n    Encoded encoded;\n    State() {}\n    State(Weight h, Weight a, Encoded e): hcost(h), acost(a), encoded(e) {}\n    bool operator>(const State & state2) const {\n        if (hcost+acost != state2.hcost+state2.acost) {\n            return hcost+acost > state2.hcost+state2.acost;\n        } else {\n            return acost > state2.acost;\n        }\n    }\n};\n\nconst Weight INF=1<<29;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nEncoded encode(vector<int> d) {\n    int cur=0;\n    Encoded enc=0;\n    for (size_t i=0; i<d.size()-1; ++i) {\n        cur = d[i];\n        for (size_t j=i+1; j<d.size(); ++j)\n            if (cur < d[j])\n                --d[j];\n\n        (enc += d[i]) *= d.size()-i-1;\n    }\n\n    return enc;\n}\n\nvector<int> decode(Encoded e) {\n    vector<int> d(9);\n    for (size_t i=1; i<=9; ++i) {\n        d[9-i] = e % i;\n        e /= i;\n    }\n\n    for (size_t i=9; i--;)\n        for (size_t j=i+1; j<9; ++j)\n            if (d[i] <= d[j])\n                ++d[j];\n\n    return d;\n}\n\nWeight heucost(Encoded start, Encoded end) {\n    static const vector<int> dend=decode(end);\n    vector<int> dstart=decode(start);\n\n    Weight h=0;\n    for (size_t i=0; i<9; ++i)\n        for (size_t j=0; j<9; ++j)\n            if (dstart[i] == dend[j]) {\n                h += abs(i/3-j/3)+abs(i%3-j%3);\n                break;\n            }\n\n    return h;\n}\n\nvector<pair<Weight, Encoded>> pmoves(Encoded cur) {\n    vector<int> d=decode(cur);\n    size_t i;\n    for (i=0; d[i]; ++i);\n\n    vector<pair<Weight, Encoded>> p;\n    if (i/3 < 2) {\n        swap(d[i], d[i+3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+3]);\n    }\n    if (i/3 > 0) {\n        swap(d[i], d[i-3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-3]);\n    }\n    if (i%3 < 2) {\n        swap(d[i], d[i+1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+1]);\n    }\n    if (i%3 > 0) {\n        swap(d[i], d[i-1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-1]);\n    }\n    return p;\n}\n\nWeight astar(Encoded start, Encoded end) {\n    lp_queue<State> q;\n    q.push(State(heucost(start, end), 0, start));\n\n    Weight opt=INF;\n    set<Encoded> visited;\n    while (!q.empty()) {\n        State p=q.top(); q.pop();\n        Weight cur_cost=p.acost;\n        Encoded cur_state=p.encoded;\n        visited.insert(cur_state);\n\n        if (opt < cur_cost) continue;\n        if (cur_state == end)\n            if (opt > cur_cost)\n                opt = cur_cost;\n\n        vector<pair<Weight, Encoded>> ms=pmoves(cur_state);\n        for (pair<Weight, Encoded> m: ms) {\n            if (visited.count(m.second)) continue;\n\n            q.push(State(heucost(m.second, end), cur_cost+m.first, m.second));\n        }\n    }\n\n    return opt;\n}\n\nint main() {\n    vector<int> d(9);\n    for (size_t i=0; i<9; ++i)\n        scanf(\"%d\", &d[i]);\n\n    Encoded e=encode(d);\n\n    Weight c=astar(e, 46233);\n    printf(\"%d\\n\", c);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 13B.cpp : ãã®ãã¡ã¤ã«ã«ã¯ 'main' é¢æ°ãå«ã¾ãã¦ãã¾ãããã­ã°ã©ã å®è¡ã®éå§ã¨çµäºãããã§è¡ããã¾ãã\n//\n\n#include <iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle& p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i])continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n\n};\n\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic const char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1))return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n\n    queue<Puzzle> Q;\n    map<Puzzle, bool>V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (isTarget(u))return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n\n\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#include<cassert>\nusing namespace std;\n#define MAX 3\n#define MAX2 9\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const{\n    for ( int i = 0; i < MAX2; i++ ){\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool trush(Puzzle);\nstring bfs(Puzzle);\n\nint main(){\n  Puzzle in;\n  int i;\n  for (i=0;i<MAX2;i++){\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\nbool trush(Puzzle p){\n  for ( int i = 0; i < MAX2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  int sx,sy,r,tx,ty;\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( trush(u) ) return u.path;\n    sx = u.space/MAX;\n    sy = u.space%MAX;\n    for ( r = 0; r < 4; r++ ){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*MAX+ty]);\n      v.space = tx*MAX+ty;\n      if ( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,a,n) for(int i = a; i < (int)n; i++)\n\nusing namespace std;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nstruct Puzzle{\n  int field[9];\n  int space;\n  int turn;\n\n\n  bool operator < (const Puzzle& a) const{\n    rep(i,9){\n      if(a.field[i] == field[i]) continue;\n      return field[i] > a.field[i];\n  }\n    return false;\n  }\n};\n\nbool check(Puzzle p){\n  rep(i,9){\n    if(p.field[i] != i+1) return false;\n  }\n  return true;\n}\n\nint solve(Puzzle in){\n  queue<Puzzle> q;\n  map<Puzzle, bool> mp;\n\n  q.push(in);\n  mp[in] = true;\n\n  while(!q.empty()){\n    Puzzle p = q.front(); q.pop();\n    if(check(p)) return p.turn;\n    int x = p.space % 3;\n    int y = p.space / 3;\n    rep(i, 4){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || 2 < nx || ny < 0 || 2 < ny) continue;\n      Puzzle tmp = p;\n      swap(tmp.field[p.space], tmp.field[3 * ny + nx]);\n      tmp.space = 3 * ny + nx;\n      if(mp[tmp] == false){\n    mp[tmp] = true;\n    tmp.turn++;\n    q.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\n\n\nsigned main(){\n  Puzzle in;\n\n  rep(i,9){\n    cin >> in.field[i];\n    if(in.field[i] == 0){\n      in.field[i] = 9;\n      in.space = i;\n    }\n  }\n\n  in.turn = 0;\n  cout << solve(in) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <map>\n#define N 3\n#define N2 9\n#define ANS \"123456780\"\n\nusing namespace std;\n\n// ä¸ãå·¦ãå³ãä¸\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\nstruct Puzzle {\n  string f;\n  int space;\n  int step;\n};\n\nvoid bfs (Puzzle p) {\n  Puzzle cur;\n  queue<Puzzle> Q;\n  map<string, bool> M;\n\n  Q.push(p);\n\n  while (Q.size()) {\n    cur = Q.front(); Q.pop();\n    if (cur.f == ANS) {\n      cout << cur.step << endl;\n      break;\n    }\n    int sx = cur.space / N;\n    int sy = cur.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      Puzzle next;\n      next.f = cur.f;\n      swap(next.f[cur.space], next.f[tx * N + ty]);\n      next.space = tx * N + ty;\n      if (!M[next.f]) {\n        M[next.f] = true;\n        next.step = cur.step + 1;\n        Q.push(next);\n      }\n    }\n  }\n}\n\nint main () {\n  Puzzle p;\n  char c;\n  \n  p.step = 0;\n  \n  for (int i = 0; i < N2; i++) {\n    cin >> c;\n    p.f += c;\n    if (c == '0') {\n      p.space = i;\n    }\n  }\n\n  bfs(p);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p)const\n\t{\n\t\tREP(i,N2)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool istgt(Puzzle p)\n{\n\tREP(i,N2)\n\t{\n\t\tif(p.f[i]!=(i+1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(istgt(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tREP(r,4)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tREP(i,N2)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n#include <map>\n#include <string>\n#include <valarray>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> Coordinate;\n\nclass PuzzleStatus\n{\n    // enum Direction {up, down, left, right};    \n\n    public:\n    friend ostream & operator<<(ostream & os, PuzzleStatus & ps);\n    friend istream & operator>>(istream & is, PuzzleStatus & ps);\n    bool operator<(const PuzzleStatus &) const;\n\n    bool move_up();\n    bool move_down();\n    bool move_left();\n    bool move_right();\n\n    static const vector< vector<int> > & get_target();\n    static void set_target();\n    const vector< vector<int> > & get_position() const;\n    // PuzzleStatus() {distance = 0;}\n\n    private:\n        vector< vector<int> > position;\n        Coordinate space_pos;\n        int distance = 0;   //the fewest steps from the original status\n   \n        //require c++11\n        // static const vector< vector<int> > target;\n\n        static vector< vector<int> > target;\n};\n\n\nbool move(PuzzleStatus & u, string direction);\n\n//require c++11\n// const vector< vector<int> > PuzzleStatus::target = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\nvector< vector<int> > PuzzleStatus::target;\n\n// not used\n// bool is_target(PuzzleStatus);\n// vector<PuzzleStatus (PuzzleStatus::*) ()> funcs = \n// {PuzzleStatus::move_up, PuzzleStatus::move_down, PuzzleStatus::move_left, PuzzleStatus::move_right};\n// int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n// PuzzleStatus move(PuzzleStatus, PuzzleStatus (PuzzleStatus::*) (PuzzleStatus));\n\n//the size of puzzle\nconst int SIZE = 3;\n\nint main()\n{\n    PuzzleStatus::set_target();\n    \n    PuzzleStatus origin;\n\n    cin >> origin;\n\n    queue<PuzzleStatus> Q;\n    map<PuzzleStatus, bool> visited;\n    \n    Q.push(origin);\n    visited[origin] = true;\n\n    //require c++11\n    // vector<string> directions = {\"up\", \"down\", \"left\", \"right\"};\n    \n    string d[] = {\"up\", \"down\", \"left\", \"right\"};\n    vector<string> directions(d, d+4);\n\n    while (!Q.empty())\n    {\n        if (Q.front().get_position() == PuzzleStatus::get_target())\n            break;\n\n        for (int i = 0; i < 4; i++)\n        {\n            PuzzleStatus temp = Q.front();\n            if (move(temp, directions[i]) && !visited[temp])\n            {\n                visited[temp] = true; \n                Q.push(temp);                \n            }\n        }\n        Q.pop();\n    }\n\n    cout << Q.front();\n}\n\n\nostream & operator<<(ostream & os, PuzzleStatus & ps)\n{\n    os << ps.distance << endl;\n    return os;\n}\n\nistream & operator>>(istream & is, PuzzleStatus & ps)\n{\n    ps.position.resize(SIZE);\n    for (int i = 0; i < SIZE; i++)\n    {\n        ps.position[i].resize(SIZE);\n        for (int j = 0; j < SIZE; j++)\n        {\n            is >> ps.position[i][j];\n            if (ps.position[i][j] == 0)\n            {\n                ps.space_pos.first = i; \n                ps.space_pos.second = j; \n            }\n                           \n        }\n\n    }\n    return is;\n}\n\n\nbool PuzzleStatus::move_up()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (i > 0)\n    {\n        swap(position[i-1][j], position[i][j]);\n        i--;\n        distance++;\n        return true;     \n    }  \n    return false;   \n}\n\nbool PuzzleStatus::move_down()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (i < SIZE-1)\n    {\n        swap(position[i+1][j], position[i][j]);\n        i++;\n        distance++;   \n        return true;   \n    }  \n    return false;   \n}\n\nbool PuzzleStatus::move_left()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (j > 0)\n    {\n        swap(position[i][j-1], position[i][j]);\n        j--;\n        distance++;\n        return true;     \n    }  \n    return false;      \n}\n\nbool PuzzleStatus::move_right()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (j < SIZE-1)\n    {\n        swap(position[i][j+1], position[i][j]);\n        j++;\n        distance++; \n        return true;    \n    }  \n    return false;   \n}\n\n\n// PuzzleStatus move(PuzzleStatus u, PuzzleStatus (PuzzleStatus::*func) ())\n// {\n//     return (u.*func)();\n// }\n\nbool move(PuzzleStatus & u, string direction)\n{\n    if (direction == \"up\")\n        return u.move_up();\n    else if (direction == \"down\")\n        return u.move_down();\n    else if (direction == \"left\")\n        return u.move_left();\n    else if(direction == \"right\")\n        return u.move_right();\n    else\n        return false;\n}\n\n\nconst vector< vector<int> > & PuzzleStatus::get_target()\n{\n    return target;\n}\n\nconst vector< vector<int> > & PuzzleStatus::get_position() const\n{\n    return position;\n}\n\n\nbool PuzzleStatus::operator<(const PuzzleStatus & ps) const\n{\n    return position < ps.position;\n}\n\n\nvoid PuzzleStatus::set_target()\n{\n    target.resize(SIZE);\n    for (int i = 0; i < SIZE; i++)\n    {\n        target[i].resize(SIZE);\n        for (int j = 0; j < SIZE; j++)\n            target[i][j] = i*SIZE+j+1;\n    }\n    target[SIZE-1][SIZE-1] = 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\n//?Â§???Â¨??????\nstatic const int dx[4]={0,-1,0,1};\nstatic const int dy[4]={1,0,-1,0};\nstatic const char dir[4]={'u','l','d','r'};\n\n//Puzzle{????????????????????????}\nstruct Puzzle\n{ \n\tint f[N2], space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p) const\n\t{\n\t\tfor(int i=0;i<N2;i++)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]<p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle p)\n{\n\tfor(int i=0;i<N2;i++)\n\t\tif(p.f[i]!=(i+1))return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle>Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolveable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\t\n\tfor(int i=0;i<N2;i++)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\t//cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstruct state\n{\n  vector<vector<int>> bd;\n  int cnt;\n};\n\nclass EightPuzzle\n{\npublic:\n  queue<state> q;\n  vector<vector<int>> goal;\n  vector<int> dr,dc;\n  EightPuzzle(){}\n  EightPuzzle( state st ){ q.push(st); goal = {{1,2,3},{4,5,6},{7,8,0}}; dr = {1, -1, 0, 0}; dc = {0, 0, 1, -1}; }\n  int solve();\n  void find0( vector<vector<int>> &b, int &x, int &y );\n};\n\nvoid EightPuzzle::find0( vector<vector<int>> &b, int &r, int &c )\n{\n  for ( r = 0; r < 3; ++r )\n    for ( c = 0; c < 3; ++c )\n      if ( b[r][c] == 0 ) return;\n}\n\nint EightPuzzle::solve()\n{\n  while ( ! q.empty() )\n    {\n      state st = q.front();\n      \n      if ( st.bd == goal )\n        {\n          cout << st.cnt << endl;\n          return 0;\n        }\n\n      int r, c;\n      find0( st.bd, r, c );\n\n      for ( auto i = 0; i < 4; ++i )\n        {\n          int nr = r + dr[i];\n          int nc = c + dc[i];\n          if ( nr < 0 || nr > 2 || nc < 0 || nc > 2 ) continue;\n\n          state nst = st;\n          nst.bd[r][c] = st.bd[nr][nc];\n          nst.bd[nr][nc] = 0;\n          nst.cnt = st.cnt + 1;\n          q.push(nst);\n        }\n      q.pop();\n    }\n  \n  return 0;\n}\n\nint main()\n{\n  state st;\n  st.cnt = 0;\n  \n  for ( auto i = 0; i < 3; ++i )\n    {\n      vector<int> vl;\n      for ( auto j = 0; j < 3; ++j )\n        {\n          int v;\n          cin >> v;\n          vl.push_back(v);\n        }\n      st.bd.push_back(vl);\n    }\n\n  EightPuzzle ep( st );\n\n  ep.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define N 3\n#define MAXQ 3628800\n\nint bfs(int [N][N]);\nint check_save (int [N][N]);\n//hash\nlong long h1(long long);\nlong long  h2(long long);\n\n#define RIGHT -1\n#define LEFT -2\n#define ABOVE -3\n#define UNDER -4\n\nint Z[362880][N][N];\nint num=0;\n\nint hash[MAXQ];\n\nint main(){\n  int i,j;\n  int depth;\n  int P[N][N];\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&P[i][j]);\n    }\n  }\n  \n  for(i=0;i<MAXQ;i++) hash[i] = 0;\n\n  /* for(i=0;i<N;i++){\n     for(j=0;j<N;j++){\n     if(j) printf(\" \");\n     printf(\"%d\",P[i][j]);\n     }\n     printf(\"\\n\");\n\n     }\n  */\n\n  depth = bfs(P);\n\n  printf(\"%d\\n\",depth);\n  \n  return 0;\n}\nint Q[MAXQ][N][N];\nint Qd[MAXQ];\n\nint bfs(int A[N][N]){\n\n  int head=0,tail=0;\n  int depth;\n  int i,j,puzzle[N][N],tp[N][N];\n  int x,y;\n  int temp;\n  int direction = 0;\n  //int depth_limit = 32;\n  //int min = depth_limit;\n  int result;\n\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      Q[tail][i][j] = A[i][j];\n      Qd[tail]=0;\n    }\n  }\n  tail++;\n  //if(tail >= MAXQ) tail = 0;\n  \n\n  while(head != tail){\n    //printf(\"%d:%d\\n\",head,tail);\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        puzzle[i][j] = Q[head][i][j];\n        if(puzzle[i][j] == 0) {\n          x = i;\n          y = j;\n        }    \n      }\n    }\n    depth=Qd[head];\n    head++;\n    if(head >= MAXQ) head = 0;\n  \n    //finish\n    if(puzzle[0][0] == 1 &&\n       puzzle[0][1] == 2 &&\n       puzzle[0][2] == 3 &&\n       puzzle[1][0] == 4 &&\n       puzzle[1][1] == 5 &&\n       puzzle[1][2] == 6 &&\n       puzzle[2][0] == 7 &&\n       puzzle[2][1] == 8 && puzzle[2][2] == 0) return depth;\n\n    /*\n      result = check_save(puzzle);\n\n      if(result == 1) continue;\n    */\n  \n\n    //0ã®ä½ç½®ã¯(x,y)\n\n    //0 can swap above\n    if(y != 0){\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n      //swaping pazzle\n      temp = tp[x][y-1];\n      tp[x][y-1] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n    }\n\n    \n\n    //0 can swap under\n    if(y != 2) {\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n\n      temp = tp[x][y+1];\n      tp[x][y+1] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n\n    }\n\n    //0 can swap right\n    if(x != 2){\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n\n      temp = tp[x+1][y];\n      tp[x+1][y] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\n\n      \n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n    }\n\n    //0 can swap left\n    if(x != 0){\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n\n      temp = tp[x-1][y];\n      tp[x-1][y] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\t\n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n    }\n  }\n  return -1;\n}\n\n\n\n\n\nint check_save(int A[3][3]){\n  int i,j;\n  int sum=0;\n  int value;\n  \n  //å­å¨ããã° ï¼\n  \n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      sum += A[i][j];\n      if(i != 2 || j != 2) sum *=10;\n    }\n  }\n\n  //printf(\"sum = %d\\n\",sum);\n\n\n  i = 0; \n  while(1){\n    \n    value = (h1(sum) + i * h2(sum)) % MAXQ;\n  \n    if(hash[value] != 0) {\n      if(hash[value] == sum) {\n\t//printf(\"%d already exists!!\\n\", value);\n\treturn 1;\n\n      }\n      else{\n\t//printf(\"CONFLICT!!\\n\");\n\ti++;\n      }\n    }\n  \n    else{\n      hash[value] = sum;\n      break;\n    }\n  }\n\n  return 0;\n}\n\nlong long h1(long long key){\n  return key % MAXQ;\n}\n\nlong long h2(long long key){\n  return 1 + (key % (MAXQ-1));\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        }\n      }\n\n//      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n\n    }\n\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\n\n#define N 3\n#define N2 9\n//--------------------------------------- \nstruct P{\n    int f[N2];\n    int space;\n    string path;\n\n     \n    bool operator < (const P &p) const{\n        for(int i = 0; i < N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n//-------------------------------------------- \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \n//--------------------------------------------\nbool isTarget(P p){\n    for(int i = 0; i < N2; i++)\n        if(p.f[i] != (i + 1)) return false;\n    return true;\n}\n//--------------------------------------------\nstring bfs(P s){\n    queue<P> Q;\n    map<P, bool> V;\n    P u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n     \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n//-----------------------------\nint main(){\n    P in;\n    for(int i = 0; i < N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n     \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#include<cassert>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const{\n    for ( int i = 0; i < N2; i++ ){\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for ( int r = 0; r < 4; r++ ){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if ( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  assert(false);\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  \n  for ( int i = 0; i < N2; i++ ){\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2; \n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep2(x,fr,to) for(int (x)=(fr);(x)<(to);(x)++)\n#define rep(x,to) for(int (x)=0;(x)<(to);(x)++)\n#define repr(x,fr,to) for(int (x)=(fr);(x)>=(to);(x)--)\n#define all(c) (c).begin(),(c).end()\n#define sz(v) (int)(v).size()\n\nusing namespace std;\ntypedef long long ll; typedef vector<int> VI; typedef pair<int,int> pii;\nvoid dbg(){ cerr << \"\\n\"; }  template <typename T,typename ...T2>\nvoid dbg(const T& fst, const T2&...rst){ cerr << fst << \": \"; dbg(rst...); }\n\nconst vector<VI> cnsw ={\n\t{1,3},  {0,2,4},  {1,5},\n\t{0,4,6},{1,3,5,7},{2,4,8},\n\t{3,7},  {4,6,8},  {5,7}\n};\n\nconst VI pps = {1,2,3,4,5,6,7,8,0};\nint main(){\n\t\n\tVI ba(9); int wi;\n\trep(i,3) rep(j,3) {cin >> wi; ba[i*3+j] = wi;}\n\n\tmap<VI, int> usd;\n\tqueue<VI> q;\n\tq.emplace(pps);\n\tusd[pps] = 0;\n\tint ct=0;\n\twhile(!q.empty()){\n\t\tauto cv = q.front(); q.pop();\n\t\tint crz, oc = usd[cv]; \n\t\trep(i,9) if(cv[i]==0){crz=i; break;}\n\t\tfor(auto p: cnsw[crz]){\n\t\t\tswap(cv[crz], cv[p]);\n\t\t\tif(!usd.count(cv) ){\n\t\t\t\tq.emplace(cv);\n\t\t\t\tusd[cv] = oc +1;\n\t\t\t}\n\t\t\tswap(cv[crz], cv[p]);\n\t\t}\n\t}\n\t\n\t\n\t\n\tcout << (usd.count(ba)? usd[ba]: -1) <<\"\\n\";\n\t\n\t/*for(auto& x: usd){\n\t\tcout << x.second <<\" :: \";\n\t\tfor(int z: x.first) cout << z <<\" \";\n\t\tcout <<\"\\n\";\n\t}*/\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<memory.h>\n#define len 362888\n#define le 9\ntypedef int state[le];\nstate st[len],goal;\nint dis[len],fact[le],head[len],vis[len],der[4][2]= {{-1,0},{1,0},{0,-1},{0,1}};\nvoid encode()\n{\n    int i;\n    for(i=fact[0]=1; i<le; i++)\n        fact[i]=fact[i-1]*i;\n}\nint decode(int s)\n{\n    int i,j,code,cnt;\n    for(i=code=0; i<le; i++)\n    {\n        for(cnt=0,j=i+1; j<le; j++)    if(st[s][i]>st[s][j])     cnt++;\n        code+=cnt*fact[8-i];\n    }\n    if(vis[code])   return 0;\n    else            return vis[code]=1;\n}\nint bfs()\n{\n    int front=1,rear=2,i,x,y,z,nx,ny,nz;\n    encode();\n    while(front<rear)\n    {\n        state& s=st[front];\n        if(memcmp(s,goal,sizeof(s))==0)\n            return front;\n        for(i=0; i<le; i++)\n            if(s[i]==0)     break;\n        x=i/3;\n        y=i%3;\n        z=i;\n        for(i=0; i<4; i++)\n        {\n\n            nx=x+der[i][0];\n            ny=y+der[i][1];\n            nz=nx*3+ny;\n            if(nx>=0&&nx<3&&ny>=0&&ny<3)\n            {\n                state& t=st[rear];\n                memcpy(&t,&s,sizeof(s));\n                t[z]=s[nz];\n                t[nz]=s[z];\n                dis[rear]=dis[front]+1;\n                if(decode(rear))\n                    rear++;\n            }\n        }\n        front++;\n    }\n    return 0;\n}\nint main(void)\n{\n    int i,oj;\n    int ppp = 1;\n    for(i=0; i<le; i++)   scanf(\"%d\",&st[1][i]);\n    for(i=0; i<le; i++){\n        goal[i] = ppp;\n        ppp++;\n    }\n    goal[8] = 0;\n\n    //for(i=0; i<le; i++)   scanf(\"%d\",&goal[i]);\n    oj=bfs();\n    if(oj)    printf(\"%d\\n\",dis[oj]);\n    else    puts(\"Impossible\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for ( int i = 0; i < N2; i++ ) {\n            if ( f[i] == p.f[i] ) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for ( int i = 0; i < N2; i++ )\n      if ( p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for ( int r = 0; r < 4; r++ ) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched;\n\nbool find(int target){\n    int n = searched.size() - 1;\n    REP(i, n + 1){\n        if(searched[n-i] == target)\n            return false;\n    }\n    return true;\n}\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    int board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        return k;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = dfs();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * I used # 1687007 as a refference. Thx. \n */\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\n//const int PATTERN = 181440;     // 9! / 2;\nconst int PATTERN = 362880;     // 9! / 2;\nconst int FORWARD  = 1;\nconst int BACKWARD = -1;\nconst Board GOAL = 0x123456780LL;\nconst int DX[] = { -1, 0, 1,  0 },\n          DY[] = {  0, 1, 0, -1 };\n\nint history[PATTERN];\nqueue<Board> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, Board board) {\n//    printf(\"change_number(board) = %d\\n\", change_number(board));\n    int direction = history[change_number(board)];\n    swap(numpos, spacepos, board);\n    int pos = change_number(board);\n    if (!history[pos]) {\n        q.push(board);\n        history[pos] = direction + (direction > 0 ? 1 : -1);\n    }\n    else if ((history[pos] > 0 && direction < 0)\n          || (history[pos] < 0 && direction > 0)) {\n        return abs(history[pos]) + abs(direction) + (direction > 0 ? 1 : -1);\n    }\n    return 0;\n}\n\nvoid print(Board b) {\n    for (int i = N - 1; i >= 0; --i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = N - 1, num; i >= 0; --i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i * 4);\n    }\n//    print(board);\n//    print(GOAL);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    history[change_number(board)] = FORWARD;\n    history[change_number(GOAL)]  = BACKWARD;\n\n    q.push(board);\n    q.push(GOAL);\n    while (!q.empty()) {\n        board = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N)\n            if (((board >> (pos * 4)) & 0xF) == 0)\n                break;\n\n        int zx = pos % 3, zy = pos / 3;\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + DX[i], ny = zy + DY[i];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n                continue;\n            int npos = nx + ny * 3;\n//            printf(\"npos = %d\\n\", npos);\n            assert(pos >= 0 && pos < N);\n            assert(npos >= 0 && npos < N);\n            if ((count = swap_and_check(npos, pos, board)))\n                goto END;\n        }\n//        printf(\"\\n\");\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct r{\n\tint x;\n\tint y;\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9];\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tmemset(used,0,sizeof(used));\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t\tif(f.men[i][j]==0){\n\t\t\t\tf.x=j;\n\t\t\t\tf.y=i;\n\t\t\t}\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tfor(k=0;k<4;k++){\n\t\t\tif(f.y+dy[k]>=0&&f.y+dy[k]<3&&f.x+dx[k]>=0&&f.x+dx[k]<3){\n\t\t\t\tv=f;\n\t\t\t\ttemp=v.men[f.y][f.x];\n\t\t\t\tv.men[f.y][f.x]=v.men[f.y+dy[k]][f.x+dx[k]];\n\t\t\t\tv.men[f.y+dy[k]][f.x+dx[k]]=temp;\n\t\t\t\tv.x=f.x+dx[k];\n\t\t\t\tv.y=f.y+dy[k];\n\t\t\t\tv.cnt++;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(b1.num[zero1]!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(b2.num[zero2]!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n\nint heuristic_func2(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    Board b2 = decode(enc2);\n    int res = 0;\n    for(int i=0;i<SIZE;i++){\n        int pos1 = 0;\n        int pos2 = 0;\n        while(b1.num[pos1]!=i) pos1++;\n        while(b2.num[pos2]!=i) pos2++;\n        res += abs(pos1/3-pos2/3) + abs(pos1%3 - pos2%3);\n    }\n    return res;\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func2(start, goal), start));\n    visited[start] = 0;\n    int count = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            count++;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func2(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    //cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\nusing board_t = array<int32_t, 9>;\nusing state_t = tuple<int32_t, int32_t, board_t, board_t>;\n\nint32_t hamming(const board_t &board) {\n    int32_t d = 0;\n\n    for (int32_t i = 0; i < 9; i++) {\n        if (board[i] != (i+1)%9) d++;\n    }\n\n    return d;\n}\n\nvector<board_t> children(const board_t &board) {\n    vector<board_t> c;\n    int32_t z = 0;\n    while (board[z] != 0) z++;\n    int32_t zr = z/3, zc = z%3;\n\n    if (zr-1 >= 0) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[(zr-1)*3+zc]);\n        c.push_back(board_new);\n    }\n    if (zr+1 < 9) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[(zr+1)*3+zc]);\n        c.push_back(board_new);\n    }\n    if (zc-1 >= 0) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[zr*3+zc-1]);\n        c.push_back(board_new);\n    }\n    if (zc+1 < 9) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[zr*3+zc+1]);\n        c.push_back(board_new);\n    }\n\n    return c;\n}\n\n\nint main() {\n    board_t board;\n\n    for (int32_t i = 0; i < 9; i++) {\n        cin >> board[i];\n    }\n\n    auto c = [](state_t l, state_t r) {return (get<0>(l) + get<1>(l)) > (get<0>(r) + get<1>(r));};\n    priority_queue<state_t, vector<state_t>, decltype(c)> tovisit(c);\n    tovisit.push(make_tuple(0, hamming(board), board, board));\n\n    while (!tovisit.empty()) {\n        int32_t moves, dist;\n        board_t board, parent;\n        tie(moves, dist, board, parent) = tovisit.top();\n        tovisit.pop();\n\n        if (dist == 0) {\n            cout << moves << endl;\n            break;\n        }\n\n        for (board_t child : children(board)) {\n            if (child != parent) {\n                tovisit.push(make_tuple(moves + 1, hamming(child), child, board));\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define LIMIT 32\n\nstruct Puzzle{\n    char cont[9];\n    int space;\n    string path;\n    bool operator < ( const Puzzle &p ) const{\n        for ( int i = 0; i < 9; i++ ){\n            if ( cont[i] == p.cont[i] ) continue;\n            return cont[i] > p.cont[i];\n        }\n        return false;\n    }\n};\n\nint limit;\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char direction[4] = {'d', 'r', 'u', 'l'};\n\nbool isTarget(Puzzle puzzle){\n    for ( int i = 0; i < 8; i++ ){\n        if ( puzzle.cont[i] != '1' + i ) return false;\n    }\n    return true;\n}\n\nvoid bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty() ){\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ){\n            cout << u.path.size() << endl;\n            return;\n        } else if ( u.path.size() > LIMIT ) break;\n        \n        int sx, sy, tx, ty;\n        sx = u.space/3;\n        sy = u.space%3;\n        \n        for ( int r = 0; r < 4; r++ ){\n            tx = sx + dx[r];\n            ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= 3 || ty >= 3 ) continue;\n            v = u;\n            v.cont[u.space] = u.cont[tx*3+ty];\n            v.cont[tx*3+ty] = '0';\n            v.space = tx*3+ty;\n            if ( !V[v] ){\n                V[v] = true;\n                v.path += direction[r];\n                Q.push(v);\n            }\n        }\n    }\n    cout << \"unsolvable\" << endl;\n}\n\nint main(){\n    Puzzle in;\n    for ( int i = 0; i < 9; i++ ){\n        cin >> in.cont[i];\n        if ( in.cont[i] == '0' ) {\n            in.space = i;\n        }\n    }\n    \n    bfs(in);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define A 3\n#define B 9\n\nstruct pazzle{\n  int f[B];\n  int space;\n  string path;\n\n  bool operator < (const pazzle &p) const{\n    for(int i=0;i<B;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(pazzle p){\n  for(int i=0;i<B;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(pazzle s){\n  queue<pazzle> Q;\n  map<pazzle,bool> V;\n  pazzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    int sx = u.space/A;\n    int sy = u.space%A;\n\n    for(int r=0;r<4;r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n\n      if(tx<0 || ty<0 || tx>=A || ty>=A)continue;\n\n      v=u;\n      swap(v.f[u.space],v.f[tx*A+ty]);\n      v.space = tx*A+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  pazzle in;\n\n  for(int i=0;i<B;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=B;\n      in.space =i;\n    }\n  }\n string ans = bfs(in);\n cout << ans.size() << endl;\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\n//moves will be outputted to this filestream\nofstream ofs(\"PuzzleSolution.txt\");\n\n//Puzzle solver\nclass EPSolver\n{\n    using ID = uint64_t;\n    using P = pair<double, ID>;\n\npublic:\n    int h, w;\n\n    //Puzzle board\n    class Puzzle\n    {\n    public:\n        int h, w;\n        EPSolver::ID id;\n        vector<vector<int>> board;\n\n        Puzzle(int N = 3, int M = 3)\n        {\n            h = N, w = M;\n            id = 0;\n            board.resize(h, vector<int>(w));\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    board[i][j] = (i == h - 1 && j == w - 1 ? 0 : i * w + j + 1);\n                    id = id * h * w + board[i][j];\n                }\n            }\n        }\n\n        Puzzle(const vector<vector<int>> &newboard)\n        {\n            setBoard(newboard);\n        }\n\n        void setBoard(const vector<vector<int>> &newboard)\n        {\n            h = newboard.size();\n            w = newboard[0].size();\n            board = newboard;\n            id = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    board[i][j] = newboard[i][j];\n                    id = id * h * w + board[i][j];\n                }\n            }\n            if (!checkInput())\n            {\n                //cerr << \"Invalid Input\" << endl;\n                exit(0);\n            }\n        }\n\n        bool checkInput()\n        {\n            bool res = true;\n            set<int> s;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    int v = board[i][j];\n                    res &= 0 <= v && v < h * w;\n                    res &= s.find(v) == s.end();\n                    s.insert(v);\n                }\n            }\n            res &= s.size() == (h * w);\n            return res;\n        }\n\n        //evaluation function\n        //a=1å®å®\n        double calcScore(double a = 1.)\n        {\n            double res = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    int k = board[i][j];\n                    if (k == 0)\n                        continue;\n                    int y = (k - 1) / w, x = (k - 1) % w;\n                    res += pow(pow(abs(y - i), a) + pow(abs(x - j), a), 1 / a);\n                }\n            }\n            return res;\n        }\n\n        double calcScore(int a = 1)\n        {\n            double res = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    int k = board[i][j];\n                    if (k == 0)\n                        continue;\n                    int y = (k - 1) / w, x = (k - 1) % w;\n                    res += abs(y - i) + abs(x - j);\n                }\n            }\n            return res;\n        }\n\n        friend ostream &operator<<(ostream &os, const Puzzle &puzzle)\n        {\n            for (int i = 0; i < puzzle.h; i++)\n            {\n                for (int j = 0; j < puzzle.w; j++)\n                {\n                    int x = puzzle.board[i][j];\n                    os << (char)(x ? x + '0' : '#') << ' ';\n                }\n                os << '\\n';\n            }\n            return os;\n        }\n    };\n\n    //ID -> Puzzle\n    Puzzle encodeBoard(ID id)\n    {\n        vector<vector<int>> b(h);\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                b[i].push_back(id % ID(h * w));\n                id /= ID(h * w);\n            }\n            reverse(b[i].begin(), b[i].end());\n        }\n        reverse(b.begin(), b.end());\n        Puzzle p(b);\n        return p;\n    }\n\n    //score and boardID\n    priority_queue<P, vector<P>, greater<P>> open, close;\n    set<ID> openId, closeId;\n\n    //child, parent\n    map<ID, ID> par;\n    map<ID, double> scoreMemoF;\n    map<ID, double> scoreMemoG;\n\n    //first state, target state\n    ID initId, targetId;\n\n    EPSolver(const vector<vector<int>> &b, const vector<vector<int>> &t)\n    {\n        h = b.size();\n        w = b[0].size();\n        Puzzle pb(b), pt(t);\n        double s = pb.calcScore(1);\n        initId = pb.id;\n        targetId = pt.id;\n        openId.insert(initId);\n        open.push(make_pair(s, initId));\n        par[initId] = -1;\n        scoreMemoF[initId] = s;\n        solve();\n    }\n\n    vector<Puzzle> nextBoard(const Puzzle &puzzle)\n    {\n        vector<Puzzle> res;\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                //find empty cell\n                if (puzzle.board[i][j])\n                    continue;\n                for (int d = 0; d < 4; d++)\n                {\n                    int ny = i + ((d & 1) ? 0 : ((d & 2) ? 1 : -1));\n                    int nx = j + ((d & 1) ? ((d & 2) ? 1 : -1) : 0);\n                    if (0 > ny || ny >= h || 0 > nx || nx >= w)\n                        continue;\n                    vector<vector<int>> copyBoard(puzzle.board);\n                    swap(copyBoard[ny][nx], copyBoard[i][j]);\n                    Puzzle newpuzzle = Puzzle(copyBoard);\n                    res.push_back(newpuzzle);\n                }\n            }\n        return res;\n    }\n\n    void solve()\n    {\n        if (initId == targetId)\n        {\n            //cerr << \"Already Solved (*-vã»)\" << endl;\n            return;\n        }\n        while (!open.empty())\n        {\n            //openããä¸çªãããã®ãæ¡ç¨\n            double score = open.top().first;\n            ID id = open.top().second;\n\n            open.pop();\n            //openããåé¤ãcloseã«è¿½å \n            openId.erase(openId.find(id));\n            closeId.insert(id);\n\n            auto newBoard = encodeBoard(id);\n            auto nextState = nextBoard(newBoard);\n\n            for (auto board : nextState)\n            {\n                ID nextId = board.id;\n                if (!scoreMemoG[nextId] || scoreMemoG[nextId] < scoreMemoG[id] + 1)\n                {\n                    scoreMemoG[nextId] = scoreMemoG[id] + 1;\n                }\n                double score = board.calcScore(1) + scoreMemoG[nextId];\n                if (nextId == targetId)\n                {\n                    //cerr << \"Solution Was Found!\" << endl;\n                    par[nextId] = id;\n                    return;\n                }\n                bool foundInOpen = openId.find(nextId) != openId.end();\n                bool foundInClose = closeId.find(nextId) != closeId.end();\n                if (not foundInOpen and not foundInClose)\n                {\n                    open.push({score, nextId});\n                    openId.insert(nextId);\n                    scoreMemoF[nextId] = score;\n                    par[nextId] = id;\n                }\n                else if (foundInClose)\n                {\n                    if (score < scoreMemoF[nextId])\n                    {\n                        scoreMemoF[nextId] = score;\n                        par[nextId] = id;\n                        openId.insert(nextId);\n                        open.push({score, nextId});\n                    }\n                }\n                else if (foundInOpen)\n                {\n                    if (score < scoreMemoF[nextId])\n                    {\n                        scoreMemoF[nextId] = score;\n                        par[nextId] = id;\n                    }\n                }\n            }\n        }\n        //cerr << \"Solution Was Not Found...\" << endl;\n        return;\n    }\n\n    void traceBack()\n    {\n        ID p = targetId;\n        vector<ID> path;\n        while (p != -1)\n        {\n            //ofs << p << ' ' << par[p] << endl;\n            path.push_back(p);\n            p = par[p];\n        }\n        cout << path.size() - 1 << endl;\n        //cerr << \"Number of moves: \" << path.size() - 1 << endl;\n        reverse(path.begin(), path.end());\n        int cnt = 0;\n        for (auto i : path)\n        {\n            ofs << \"move \" << cnt++ << '\\n'\n                << encodeBoard(i) << endl;\n        }\n    }\n};\n\nint main()\n{\n    int n = 3;\n    // vector<vector<int>> easy = {{5, 3, 4}, {1, 2, 6}, {7, 8, 0}};\n    // vector<vector<int>> hard = {{0, 6, 3}, {5, 8, 2}, {7, 4, 1}};\n    vector<vector<int>> b(n, vector<int>(n)), t(b);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n            cin >> b[i][j];\n            t[i][j] = i * n + j + 1;\n        }\n    t.back().back() = 0;\n    EPSolver eps(b, t);\n    eps.traceBack();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 3\n#define N2 9\nclass puzzle{\npublic:\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const puzzle &p) const {\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i]!=p.f[i]) return f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nstatic const int dx[4]={-1,+1,0,0};\nstatic const int dy[4]={0,0,-1,+1};\nstatic const char dir[4]={'u','d','l','r'};\n\nbool isTarget(puzzle u){\n\tfor(int i=0;i<N2;i++){\n\t\tif(u.f[i]!=i+1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(puzzle s){\n\tqueue<puzzle> Q;\n\tmap<puzzle,bool> V;\n\tpuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx=u.space/N,sy=u.space%N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx=sx+dx[r],ty=sy+dy[r];\n\t\t\tif(tx<0 || tx>=N || ty<0 || ty>=N) continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[v.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tpuzzle in;\n\tfor(int i=0;i<N2;i++){\n\t\t\tcin>>in.f[i];\n\t\t\tif(in.f[i]==0){\n\t\t\t\tin.f[i]=N2;\n\t\t\t\tin.space=i;\n\t\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint limit=0,T[3][3];\n\nint evaluate(){\n  int cx[]={2,0,1,2,0,1,2,0,1},cy[]={2,0,0,0,1,1,1,2,2};\n  int ret=0;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      int ti = T[i][j];\n      if (ti==0)continue;\n      ret+=abs(cx[ti]-j);\n      ret+=abs(cy[ti]-i);\n      // if (cx[ti]!=j||cy[ti]!=i)ret++;\n    }\n  }\n  return ret;\n}\n\nbool trymove(int c,int zx,int zy,int pzx,int pzy){\n  int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n  if (evaluate()==0)return true;\n  if (c+evaluate()>limit)return false;\n  for (int i=0;i<4;i++){\n    if (0>zx+dx[i]||zx+dx[i]>2||0>zy+dy[i]||zy+dy[i]>2)continue;\n    if (zx+dx[i]==pzx&&zy+dy[i]==pzy)continue;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n    if (trymove(c+1,zx+dx[i],zy+dy[i],zx,zy)) return true;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n  }\n  return false;\n}\n\nint main(){\n  int zx,zy;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      cin >> T[i][j];\n      if (T[i][j]==0){\n\tzx=j;\n\tzy=i;\n      }\n    }\n  }\n  \n  while (evaluate()){\n    limit++;\n    if (trymove(0,zx,zy,zx,zy))break;\n  }\n  \n  cout << limit << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 3\n#define NN 9\n\nusing namespace std;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar direction[4] = {'u', 'l', 'd', 'r'};\n\ntypedef struct Puzzle{\n    int state[NN];\n    int space;\n    string result;\n\n    bool operator < (const Puzzle &p) const{\n        for(int i = 0; i < NN; i++){\n            if(state[i] == p.state[i]) continue;\n            return state[i] > p.state[i];\n        }\n        return false;\n    }\n}P;\n\nbool isfinished(P p){\n    for(int i = 0; i < NN; i++){\n        if(p.state[i] != i+1) return false;\n    }\n    return true;\n}\n\nstring bfs(P p){\n    queue<P> Q;\n    map<P, bool> V;\n    P u, v;\n    int sx, sy, tx, ty;\n\n    p.result = \"\";\n    Q.push(p);\n    V[p] = true;\n\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n\n        if(isfinished(u)) return u.result;\n\n        sx = u.space / N;\n        sy = u.space % N;\n        for(int i = 0; i < 4; i++){\n            tx = sx + dx[i];\n            ty = sy + dy[i];\n            \n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n            v = u;\n            int tmp = v.state[u.space];\n            v.state[u.space] = v.state[tx * N + ty];\n            v.state[tx * N + ty] = tmp;\n            v.space = tx * N + ty;\n\n            if(!V[v]){\n                V[v] = true;\n                v.result += direction[i];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\nint main(){\n    P p;\n\n    for(int i = 0; i < NN; i++){\n        cin >> p.state[i];\n        if(p.state[i] == 0){\n            p.state[i] = NN;\n            p.space = i;\n        }\n    }\n\n    string result = bfs(p);\n\n    cout << result.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Puzzle{\n\tint f[9], space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < 9; ++i){\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < 9; ++i)if (p.f[i] != i + 1)return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile (!Q.empty()){\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))return u.path;\n\t\tint sx = u.space / 3, sy = u.space % 3;\n\t\tfor (int r = 0; r < 4; ++r){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * 3 + ty]);\n\t\t\tv.space = tx * 3 + ty;\n\t\t\tif (!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < 9; ++i){\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0){\n\t\t\tin.f[i] = 9;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN) / DIVN - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned && Puzzles[PtoI(Q)] < answer){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int INFTY = (1 << 20);\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nint n;\nvector<pair<int, int> > adj[MAX];\n\nvoid dijkstra() {\n\tpriority_queue<pair<int, int> > PQ;\n\tint color[MAX];\n\tint d[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\td[i] = INFTY;\n\t\tcolor[i] = WHITE;\n\t}\n\n\td[0] = 0;\n\tPQ.push(make_pair(0, 0));\n\tcolor[0] = GRAY;\n\n\twhile (!PQ.empty()) {\n\t\tpair<int, int> f = PQ.top();\n\t\tPQ.pop();\n\t\tint u = f.second;\n\n\t\tcolor[u] = BLACK;\n\n\t\tif (d[u] < f.first*(-1))continue;\n\n\t\tfor (unsigned int j = 0; j < adj[u].size(); j++) {\n\t\t\tint v = adj[u][j].first;\n\t\t\tif (color[v] == BLACK)continue;\n\t\t\tif (d[v] > d[v] + adj[u][j].second) {\n\t\t\t\td[v] = d[u] + adj[u][j].second;\n\t\t\t\tPQ.push(make_pair(d[v] * (-1), v));\n\t\t\t\tcolor[v] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << i << \" \" << (d[i] == INFTY ? -1 : d[i]) << endl;\n\t}\n}\n\nint main() {\n\tint k, u, v, c;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> u >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tcin >> v >> c;\n\t\t\tadj[u].push_back(make_pair(v, c));\n\t\t}\n\t}\n\n\tdijkstra();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define NPANEL 9\n\nclass State {\npublic:\n  int panels[9];\n  int empty;\n  State(int p[]) {\n    for (int i = 0; i < NPANEL; i++) {\n      panels[i] = p[i];\n      if (p[i] == 0)\n        empty = i;\n    }\n  }\n  void print() {\n    for (int i = 0; i < NPANEL; i++) {\n      if (i != 0 && i % 3 == 0)\n        printf(\"\\n\");\n      printf(\"%d \", panels[i]);\n    }\n  }\n  bool is_completed() {\n    for (int i = 1; i < NPANEL; i++)\n      if (panels[i - 1] != i)\n        return false;\n    return true;\n  }\n  State left() { return slide(empty, empty - 1); }\n  State above() { return slide(empty, empty - 3); }\n  State right() { return slide(empty, empty + 1); }\n  State bottom() { return slide(empty, empty + 3); }\n  State slide(int x, int y) {\n    auto s = State(panels);\n    swap(s.panels[x], s.panels[y]);\n    s.empty = y;\n    return s;\n  }\n\n  vector<State> nexts() {\n    vector<State> v;\n    if (empty % 3 != 0)\n      v.push_back(left());\n    if (empty >= 3)\n      v.push_back(above());\n    if (empty % 3 != 2)\n      v.push_back(right());\n    if (empty <= 5)\n      v.push_back(bottom());\n    return v;\n  }\n};\n\nbool store(State st) {\n  static set<int> pool;\n  int hash = 0;\n  for (int i = 0; i < NPANEL; i++) {\n    hash *= 10;\n    hash += st.panels[i];\n  }\n  bool exists = (pool.find(hash) != pool.end());\n  if (!exists)\n    pool.insert(hash);\n  return !exists;\n}\n\nstruct Node {\n  State state;\n  int depth;\n};\n\nint solve(State init) {\n  if (init.is_completed())\n    return 0;\n  queue<Node> que;\n  que.push(Node{init, 0});\n\n  while (!que.empty()) {\n    Node node = que.front();\n    for (auto s : node.state.nexts()) {\n      if (s.is_completed()) {\n        return node.depth + 1;\n      }\n      if (store(s)) {\n        que.push(Node{s, node.depth + 1});\n      }\n    }\n    que.pop();\n  }\n}\n\nint main() {\n  int data[NPANEL];\n  for (int i = 0; i < NPANEL; i++)\n    cin >> data[i];\n\n  auto s = State(data);\n  cout << solve(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define SIZE 3\n\nstruct Board {\n\tint array[SIZE][SIZE];\n\tint x0;\n\tint y0;\n};\n\nint distance(int a[][SIZE], int b[][SIZE])\n{\n\tint res = 0;\n\tfor (int i=0; i<SIZE*SIZE; i++) {\n\t\tint val = a[i/SIZE][i%SIZE];\n\t\tfor (int j=0; j<SIZE*SIZE; j++) {\n\t\t\tif (b[j/SIZE][j%SIZE] == val) {\n\t\t\t\tres += abs((i/SIZE) - (j/SIZE)) + abs((i%SIZE) - (j%SIZE));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res/2;\n}\n\nvoid copyBoard(int A[][SIZE], int B[][SIZE])\n{\n\tfor (int i=0; i<SIZE; i++) {\n\t\tfor (int j=0; j<SIZE; j++) A[i][j] = B[i][j];\n\t}\n}\n\nvoid swap(int& x,int& y)\n{\n\tint tmp = x;\n\tx = y;\n\ty = tmp;\n}\n\nbool DFS(Board b, Board goal, int step, int max_step, int pre_x0, int pre_y0)\n{\t\t\t\n\tif (distance(b.array, goal.array) + step > max_step) return false;\n\tif (distance(b.array, goal.array) == 0) return true;\n\t\n\tint x0 = b.x0;\n\tint y0 = b.y0;\n\t\n\tBoard next;\n\t\n\tif (x0 > 0 && !(pre_x0 == x0 - 1 && pre_y0 == y0) ) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0-1][y0], next.array[x0][y0]);\n\t\tnext.x0 = x0 - 1;\n\t\tnext.y0 = y0;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\tif (x0 < SIZE-1 && !(pre_x0 == x0 + 1 && pre_y0 == y0)) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0][y0], next.array[x0+1][y0]);\n\t\tnext.x0 = x0 + 1;\n\t\tnext.y0 = y0;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\tif (y0 > 0 && !(pre_x0 == x0 && pre_y0 == y0 - 1)) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0][y0], next.array[x0][y0-1]);\n\t\tnext.x0 = x0;\n\t\tnext.y0 = y0 - 1;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\tif (y0 < SIZE-1  && !(pre_x0 == x0 && pre_y0 == y0 + 1)) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0][y0], next.array[x0][y0+1]);\n\t\tnext.x0 = x0;\n\t\tnext.y0 = y0 + 1;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\treturn false;\n}\n\nint solve(Board init, Board goal, int lb_max_step)\n{\n\tfor (int max_step = lb_max_step; ; max_step++) {\n\t\tif ( DFS(init, goal, 0, max_step, init.x0, init.y0) ) return max_step;\n\t}\n}\n\t\n\t\nint main()\n{\n\tBoard init;\n\t\n\tfor (int i=0; i<SIZE; i++) {\n\t\tfor (int j=0; j<SIZE; j++) {\n\t\t\tstd::cin >> init.array[i][j];\n\t\t\tif (init.array[i][j] == 0) {\n\t\t\t\tinit.x0 = i, init.y0 = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tBoard goal;\n\tfor (int i=0; i<SIZE; i++) {\n\t\tfor (int j=0; j<SIZE; j++) {\n\t\t\tgoal.array[i][j] = (SIZE*i+j+1) % (SIZE*SIZE);\n\t\t}\n\t}\n\tgoal.x0 = SIZE-1;\n\tgoal.y0 = SIZE-1;\n\t\n\tint distance_to_goal = distance(init.array, goal.array);\n\t\n\tint fewest_steps = solve(init, goal, distance_to_goal);\n\t\n\tstd::cout << fewest_steps << std::endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const{\n        for (int i = 0; i < N2 ; ++i) {\n            if (f [i] == p.f[i])continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] ={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for (int i = 0; i < N2 ; ++i)\n        if (p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(! Q.empty()){\n        u = Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4 ; ++r) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if( tx < 0 or ty < 0 or tx >= N or ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space],v.f[tx * N + ty]);\n            v.space = tx * N +ty;\n            if (!V[v]){\n                V[v] = true ;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for (int i = 0; i < N2 ; ++i) {\n        cin >> in.f[i];\n        if (in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size () << endl;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nint main(void)\n{\n\tint i,j,a[9],b[9],x1,go,g[9]={1,2,3,4,5,6,7,8,0},x2,x3,y,x4;\n\tint d[9][4]={{1,3,-1,-1},{0,2,4,-1},{1,5,-1,-1},\n\t\t{0,4,6,-1},{1,3,5,7},{2,4,8,-1},\n\t{3,7,-1,-1},{4,6,8,-1},{5,7,-1,-1}};\n\tset<int> ss;\n\tset<int>::iterator it;\n\tqueue<int> q1,q2,q3;\n\tgo=0;\n\tfor(i=0;i<9;i++){\n\t\tgo*=9;\n\t\tgo+=g[i];\n\t}\n\tfor(i=0;i<9;i++)\tscanf(\"%d\",&a[i]);\n\tx1=0;\n\tfor(i=0;i<9;i++){\n\t\tx1*=9;\n\t\tx1+=a[i];\n\t\tif(a[i]==0)\tx2=i;\n\t}\t\n\tss.insert(x1);\n\tx3=0;\n\tq1.push(x1);\tq2.push(x2);\tq3.push(x3);\n\twhile(q1.size()!=0)\t{\n\t\tx1=q1.front();\tq1.pop();\n\t\tx2=q2.front();\tq2.pop();\n\t\tx3=q3.front();\tq3.pop();\n//\t\tprintf(\"x1=%d\\n\",x1);\n\t\tif(x1==go)\tbreak;\n\t\tfor(j=8;j>=0;j--)\t{\n\t\t\tb[j]=x1%9;\n\t\t\tx1/=9;\n\t\t}\t\t\n//\t\tfor(i=0;i<9;i++)\tprintf(\"%d \",b[i]);\tprintf(\"\\n\");\n\t\tfor(i=0;i<4;i++)\t{\n\t\t\ty=d[x2][i];\t\t\n//\t\t\tprintf(\"y=%d\\n\",y);\n\t\t\tif(y!=-1)\t{\n\t\t\t\tswap(b[x2],b[y]);\n\t\t\t\tx1=0;\n\t\t\t\tfor(j=0;j<9;j++){\n\t\t\t\t\tx1*=9;\n\t\t\t\t\tx1+=b[j];\n\t\t\t\t}\t\n\t\t\t\tit=ss.find(x1);\n\t\t\t\tif(it==ss.end())\t{\n\t\t\t\t\tq1.push(x1);\tq2.push(y);\tq3.push(x3+1);\n\t\t\t\t\tss.insert(x1);\n\t\t\t\t}\n\t\t\t\tswap(b[x2],b[y]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",x3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<string>\n\nusing namespace std;\n#define N2 9\n#define N  3\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < (const Puzzle &p)const {\n            for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n            }\n        return false;\n    }\n};\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char dir[4]={'u','l','d','r'};\nbool isTarge(Puzzle p)\n{\n    for(int i=0;i<N2;i++)if(p.f[i]!=i+1)return false ;\n    return true;\n}\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> q;\n    map<Puzzle,bool>V;\n    Puzzle u,v;\n    s.path=\"\";\n    q.push(s);\n    V[s]=true;\n    while(!q.empty())\n    {\n        u=q.front();q.pop();\n        if(isTarge(u))return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int i=0;i<4;i++)\n        {\n            int nx=sx+dx[i];\n            int ny=sy+dy[i];\n            if(nx<0||ny<0||nx>=N||ny>=N)continue;\n            v=u;\n            swap(v.f[u.space],v.f[nx*N+ny]);\n            v.space=nx*N+ny;\n            if(!V[v])\n            {\n                V[v]=true;\n                v.path+=dir[i];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsovleable\";\n}\nint main()\n{\n    Puzzle in;\n    for(int i=0;i<N2;i++)\n    {\n        cin>>in.f[i];\n        if(in.f[i]==0)\n        {\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define NN 9\n\nstruct Puzzle{\n    int f[NN];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const{\n        for(int i = 0; i < NN; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i = 0; i < NN; i++){\n        if(p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for(int i = 0; i < NN; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = NN;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool func(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\nstring func1(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty()){\n    u=Q.front();Q.pop();\n    if(func(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=func1(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\t\t\t  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)\n    const\n  {\n    for(int i=0;i<N2;i++)\n      {\n\tif(f[i]==p.f[i])\n\t  {\n\t    continue;\n\t  }\n      \n\treturn f[i]>p.f[i];\n      }\n    \n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i=0;i<N2;i++)\n    {\n      if(p.f[i]!=(i+1))\n\t{\n\t  return false;\n\t}\n    }\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle> Q;\n  map<Puzzle, bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n    {\n      u=Q.front();\n      Q.pop();\n      if(isTarget(u))\n\t{\n\t  return u.path;\n\t}\n    \n      int sx=u.space/N;\n      int sy=u.space%N;\n    \n      for(int r=0;r<4;r++)\n\t{\n\t  int tx=sx+dx[r];\n\t  int ty=sy+dy[r];\n      \n\t  if(tx<0||ty<0||tx>=N||ty>=N)\n\t    {\n\t      continue;\n\t    }\n\t  v=u;\n      \n\t  swap(v.f[u.space],v.f[tx * N + ty]);\n      \n\t  v.space=tx*N+ty;\n      \n\t  if(!V[v])\n\t    {\n\t      V[v]=true;\n\t      v.path+=dir[r];\n\t      Q.push(v);\n\t    }\n\t}\n    }\n\n  return \"unsolvable\";\n}\n\nint main(void)\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n    {\n      cin>>in.f[i];\n      if(in.f[i]==0)\n\t{\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n    }\n  \n  string ans=bfs(in);\n  \n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <set>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tset<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD.insert(p); que.push(make_pair(p, 0));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (D.find(p2) == D.end())\n\t\t\t\t{\n\t\t\t\t\tif (p2 == lastboard)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD.insert(p2);\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {}\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n        *this << x << newl;\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\nusing T = vector<vector<int>>;\nusing P = pair<T, int>;\n\nint main() {\n  T start(3, vector<int>(3));\n  rep(r, 3) rep(c, 3) start[r][c] = IN;\n\n  T goal = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\n  if (start == goal) {\n    OUT(0);\n    return 0;\n  }\n\n  set<T> done;\n  done.insert(start);\n  queue<P> q;\n  q.push({start, 0});\n\n  while (!q.empty()) {\n    P p = q.front(); q.pop();\n    T t = p.first; int e = p.second;\n    rep(r, 3) rep(c, 3) if (t[r][c] == 0) {\n      for (auto&& d : vector<vector<int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}})\n        if (0 <= r+d[0] and r+d[0] < 3 and 0 <= c+d[1] and c+d[1] < 3) {\n          T t1 = t;\n          swap(t1[r+d[0]][c+d[1]], t1[r][c]);\n          if (t1 == goal) {\n            OUT(e + 1);\n            return 0;\n          } else if (!done.count(t1)) {\n            q.push({t1, e+1});\n            done.insert(t1);\n          }\n        }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tunordered_map<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tr1/unordered_set>\n#include<cstring>\nusing namespace std;\nlong long m[10]={1};\nint f;\nlong long ans=0;\nint zon[10]={1,2,3,4,5,6,7,8,0};\nint fx[4]={1,-1,3,-3};\nint wz[10]={8,0,1,2,3,4,5,6,7};\ntr1::unordered_set<long long> s;\nvoid dfs(int use,long long sm,int tot){\n    if(use>tot || s.count(sm) || f) return;\n    if(ans==sm){\n        f=1;\n        return;\n    }\n    s.insert(sm);\n    int dt[9];\n    int p;\n    for(int i=8;i>=0;i--){\n        dt[i]=sm/m[i];\n        sm%=m[i];\n        if(dt[i]==0) p=i;\n    }\n    int u=0;\n    for(int i=1;i<9;i++){\n        u+=abs(i%3-wz[dt[i]]%3)+abs(i/3-wz[dt[i]]/3);\n    }\n    if(u+use*2>tot*2) return;\n    for(int i=0;i<4;i++){\n        if(p+fx[i]<0||p+fx[i]>8) continue;\n        dt[p]=dt[p+fx[i]];\n        dt[p+fx[i]]=0;\n        long long ssm=0;\n        for(int j=0;j<9;j++){\n            ssm+=dt[j]*m[j];\n        }\n        dfs(use+1,ssm,tot);\n        dt[p+fx[i]]=dt[p];\n        dt[p]=0;\n    }\n}\nint main(){\n    int dt[9];\n    for(int i=1;i<9;i++){\n        m[i]=m[i-1]*9;\n    }\n    long long sm=0;\n    for(int i=0;i<9;i++){\n        cin>>dt[i];\n        sm+=dt[i]*m[i];\n    }\n    for(int i=0;i<9;i++){\n        ans+=zon[i]*m[i];\n    }\n    for(int i=0;i<1000;i++){\n        s.clear();\n        dfs(0,sm,i);\n        if(f){\n            cout<<i<<\"\\n\";\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {\n    -1, 0, 1, 0\n};\nstatic const int dy[4] = {\n    0, -1, 0, 1\n};\nstatic const char dir[4] = {\n    'u', 'l', 'd', 'r'\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 10;\n\ntypedef struct Node{\n\tint a[maxn];\n\tint step;\n}Node;\n\nint arr[maxn],start[maxn];//start arr åå«æ¯å¼å§åç®æ ç¶æ \nint cnt;//è®°å½mapçå¼ \nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nmap<int,int>mp;\n\nint bfs(){\n\tqueue<Node>que;\n\tNode node;\n\tmemcpy(node.a,start,sizeof(start));\n\tnode.step = 0;\n\tque.push(node);\n\twhile(!que.empty()){\n\t\t//for()...\n\t\tnode = que.front();\n\t\tque.pop();\n\t\tint index;\n\t\tfor(int i = 0; i<9; i++){\n\t\t\tif(node.a[i] == 0) index = i;\n\t\t}\n\t\tint r = index/3;\n\t\tint c = index%3;\n\t\tfor(int i = 0; i<4; i++){\n\t\t\tint nr = r + dx[i];\n\t\t\tint nc = c + dy[i];\n\t\t\tif(0<=nr && nr<3 && 0<=nc && nc<3){\n\t\t\t\tNode node_new;\n\t\t\t\tint index_new = nr*3 + nc;\n\t\t\t\tint sum = 0;\n\t\t\t\tmemcpy(node_new.a,node.a,sizeof(node.a));\t\t\t\t\n\t\t\t\tswap(node_new.a[index],node_new.a[index_new]);\n\t\t\t\tfor(int j = 0; j<9; j++){\n\t\t\t\t\tsum = sum*10 + node_new.a[j];\n\t\t\t\t}\n\t\t\t\tif(mp[sum] == 0){\n\t\t\t\t\tmp[sum] = cnt++;\n\t\t\t\t\tnode_new.step = node.step+1;\n\t\t\t\t\tif(memcmp(arr,node_new.a,sizeof(arr)) == 0){\n\t\t\t\t\t\treturn node_new.step;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(node_new);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if !vis[i] ...que.push\n\t}\n}\nint main()\n{\n\tint sum1 = 0, cnt = 0, sum = 0;\n\tfor(int i = 1; i<=8; i++){\n\t\tsum1 = sum1*10 + i;\n\t\tstart[i-1] = i; \n\t}\n\tsum1 = sum1*10;\n\tstart[8] = 0;\n\tmp[sum1] = cnt++;\n\tfor(int i = 0; i<9; i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t\tsum = sum*10 + arr[i];\n\t}\n\tif(sum == sum1) printf(\"0\\n\");\n\telse{\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>   \n#include<cstdio>  \n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string>\nusing namespace std;\nconst int row = 3;\nconst int maxx = 9;\n\nstruct Puzzle {\n\tint f[maxx];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < maxx; i++) {\n\t\t\tif (f[i] != p.f[i])\n\t\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, -1, 0 ,1 };\nconst char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < maxx; i++)\n\t\tif (p.f[i] != (i + 1))\n\t\t\treturn false;\n\treturn true;\n}\n\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / row;\n\t\tint sy = u.space % row;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\n\t\t\tif (tx < 0 || ty < 0 || tx >= row || ty >= row)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * row + ty]);\n\t\t\tv.space = tx * row + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolveable\";\n}\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < maxx; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = maxx;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tprintf(\"%d\\n\", ans.size());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   for(int i=0;i<(n);++i)\n#define SORT(c)    sort((c).begin(),(c).end())\n#define CLR(a)     memset((&a), 0 ,sizeof(a))//clear memory\n#define dump(x)    cerr << #x << \" = \" << (x) << endl;//debug\n#define debug(x)   cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define EPS        1e-10//sample:if((double)>=(double)+EPS)\n//cin,cout release\n//std::cin.tie(0);\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n#define N 3\n#define N2 9\n#define LIMIT 100\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n\nint MDT[N2][N2];\n\nstruct puzzle {\n  int f[N2],space,MD;\n};\npuzzle state;\nint limit=100;\nint path[100];\n\nint getallmd(puzzle pz){\n  int sum=0;\n  rep(i,N2){\n    if(pz.f[i]==N2)continue;\n    sum+=MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\nbool isSolved(){\n  rep(i,N2)if(state.f[i]!=i+1)return 0;\n  return 1;\n}\nbool dfs(int depth,int prev){\n  if(state.MD==0){\n    return 1;\n  }\n  if(depth+state.MD>limit)return 0;\n  int sx=state.space/N;\n  int sy=state.space%N;\n  puzzle tmp;\n  rep(r,4){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    if(max(prev,r)-min(prev,r)==2)continue;\n    tmp=state;\n    state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n    state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n    swap(state.f[tx*N+ty],state.f[sx*N+sy]);\n    state.space = tx*N+ty;\n    if(dfs(depth+1,r)){\n      path[depth]=r;\n      return 1;\n    }\n    state=tmp;\n  }\n  return 0;\n}\n\nint iterative_deeping(puzzle in){\n  in.MD=getallmd(in);\n  for(limit=in.MD;limit<=LIMIT;limit++){\n    state=in;\n    if(dfs(0,-100)){\n      int ans=0;\n      rep(i,limit)ans+=1;\n      return ans;\n    }\n  }\n  return -1;\n}\n\n\n\nint main(){\n  rep(i,N2)rep(j,N2)MDT[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n  puzzle in;\n  rep(i,N2){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n   int ans = iterative_deeping(in);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nqueue<state> q;\nset<Board> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    if (history.insert(s.board).second) {\n        ++s.count;\n        q.push(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {\n    -1, 0, 1, 0\n};\nstatic const int dy[4] = {\n    0, -1, 0, 1\n};\nstatic const char dir[4] = {\n    'u', 'l', 'd', 'r'\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < ( const Puzzle &p ) const {\n    for( int i = 0 ; i < N2 ; i++ ){\n      if( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = { -1, 0, 1, 0};\nstatic const int dy[4] = { 0, -1, 0, 1};\nstatic const char dir[4] = { 'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for( i = 0 ; i < N2 ; i++ ){\n    if( p.f[i] != ( i + 1 ) ) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  int i, a;\n  Puzzle  u ,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for( a = 0 ; a < 4 ; a++ ){\n      int tx = sx + dx[a];\n      int ty = sy + dy[a];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n\tV[v] = true;\n\tv.path += dir[a];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  int i;\n\n  for( i = 0 ; i < N2 ; i++ ){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <fstream>\n#include <queue>\n#include <vector>\n#include <time.h>\n#define PSIZE 3\n#define PPSIZE PSIZE * PSIZE\n#define NOTMOVED \"NOTMOVED\"\n#define SPACE '0'\n\nusing namespace std;\n\nstring GOAL = \"123456780\";\nint dist_table[PPSIZE][PPSIZE];\n\ntypedef enum Move {\n    UP,\n    DOWN,\n    LEFT,\n    RIGHT,\n    NOMOVE\n} Move;\n\ntypedef struct State State;\nstruct State {\n    int depth;\n    int dist;\n    string puzzle;\n    State* parent;\n};\n\nstruct comp {\n    bool operator()(const State* s1, const State* s2) {\n        return (s1->depth + s1->dist) > (s2->depth + s2->dist);\n    }\n};\n\nState* createState(int depth, int dist, string puzzle, State* parent);\nint findSpace(string puzzle);\nstring movePuzzle(string puzzle, Move move);\nint mdist(string p1);\nvoid createDistTable();\nvoid printDistTable();\nvoid printPath(State* state);\n\nint solve(string start_puzzle) {\n    int dist;\n    string moved = \"\";\n    State* curr_state = NULL;\n    State* next_state = NULL;\n\n    map<string, int> puzzle_table;\n    priority_queue<State*, vector<State*>, comp> pqueue;\n\n    curr_state = createState(0, 0, start_puzzle, NULL);\n    pqueue.push(curr_state);\n    puzzle_table[start_puzzle] = 0;\n    \n    while (!pqueue.empty()) {\n        curr_state = pqueue.top();\n        pqueue.pop();\n        \n        if (mdist(curr_state->puzzle) == 0) break;\n        \n        for (int mi = 0; mi <= NOMOVE; mi++) {\n            Move move = (Move)mi;\n            moved = movePuzzle(curr_state->puzzle, move);\n            if (moved == NOTMOVED) continue;\n            if (puzzle_table.find(moved) != puzzle_table.end() && puzzle_table[moved] < curr_state->depth+1) continue;\n            puzzle_table[moved] = curr_state->depth+1;\n            dist = mdist(moved);\n            next_state = createState(curr_state->depth+1, dist, moved, curr_state);\n            pqueue.push(next_state);\n        }\n    }\n  \n    //printPath(curr_state);\n\n    return curr_state->depth;\n\n}\n\nint main() {\n\n    createDistTable();\n    //printDistTable();\n\n\n    int out;\n    string line, puzzle;\n    for (int i = 0; i < PSIZE; i++) {\n        getline(cin, line);\n        puzzle += line[0];\n        puzzle += line[2];\n        puzzle += line[4];\n    }\n\n    out = solve(puzzle);\n\n    cout << out << endl;\n\n    return 0;\n}\n\nState* createState(int depth, int dist, string puzzle, State* parent) {\n    State* state = new State;\n    state->depth = depth;\n    state->dist = dist;\n    state->puzzle = puzzle;\n    state->parent = parent;\n    return state;\n}\n\nint mdist(string p1) {\n    int dist = 0;\n    int pi;\n    for (int i = 0; i < PPSIZE; i++) {\n        if (p1[i] == '0') continue;\n        pi = p1[i] - '1';\n        dist += dist_table[pi][i];\n    }\n    return dist;\n}\n\nint findSpace(string puzzle) {\n    size_t found = puzzle.find(SPACE);\n    if (found == string::npos) return -1;\n    return (int)found;\n}\n\nstring movePuzzle(string puzzle, Move move) {\n    int si = findSpace(puzzle);\n    if (si == -1) return NOTMOVED;\n   \n    string moved = puzzle;\n    if (move == UP) {\n        if (si < PSIZE) return NOTMOVED;\n        swap(moved[si], moved[si-3]);\n    } else if (move == DOWN) {\n        if (si >= PSIZE*(PSIZE-1)) return NOTMOVED;\n        swap(moved[si], moved[si+3]);\n    } else if (move == LEFT) {\n        if (si % PSIZE == 0) return NOTMOVED;\n        swap(moved[si], moved[si-1]);\n    } else if (move == RIGHT) {\n        if (si % PSIZE == PSIZE-1) return NOTMOVED;\n        swap(moved[si], moved[si+1]);\n    } else {\n        return NOTMOVED;\n    }\n    return moved;\n}\n\nvoid createDistTable() {\n    for (int i = 0; i < PPSIZE; i++) {\n        for (int j = 0; j < PPSIZE; j++) {\n            dist_table[i][j] = abs(i / PSIZE - j / PSIZE) + abs(i % PSIZE - j % PSIZE);\n        }\n    }\n}\n\nvoid printDistTable() {\n    for (int i = 0; i < PPSIZE; i++) {\n        for (int j = 0; j < PPSIZE; j++) {\n            cout << dist_table[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid printPuzzle(string puzzle) {\n    cout << \"---\" << endl;\n    for (int i = 0; i < PSIZE; i++) {\n        for (int j = 0; j < PSIZE; j++) {\n            cout << puzzle[i*PSIZE+j];\n        }\n        cout << endl;\n    }\n    cout << \"---\" << endl;\n}\n\nvoid printPath(State* state) {\n    while (state != NULL) {\n        printPuzzle(state->puzzle);\n        state = state->parent;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> ans = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\tvector<int> s(9);\n\tfor (int i = 0; i < 9; i++) {\n\t\tcin >> s[i];\n\t}\n\tmap<vector<int>, int> mp; mp[s] = 1;\n\tqueue<vector<int>> q; q.push(s);\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tif (p == ans) {\n\t\t\tcout << mp[p] - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tint zero;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (p[i] == 0) {\n\t\t\t\tzero = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tauto cp = p;\n\t\tif ((zero + 1) % 3 != 0) {\n\t\t\tswap(cp[zero], cp[zero + 1]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero + 1]);\n\t\t}\n\t\tif (zero % 3 != 0) {\n\t\t\tswap(cp[zero], cp[zero - 1]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero - 1]);\n\t\t}\n\t\tif (zero < 6) {\n\t\t\tswap(cp[zero], cp[zero + 3]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero + 3]);\n\t\t}\n\t\tif (zero >= 3) {\n\t\t\tswap(cp[zero], cp[zero - 3]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero - 3]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef long long ll;\n\nll getValue(vector<int> &v){\n  ll res = 0LL;\n  for(auto x : v){\n    res *= 10LL;\n    res += x;\n  }\n  return res;\n}\n\nvector<int> getState(ll x){\n  vector<int> res;\n  while(x > 0LL){\n    res.push_back(x%10LL);\n    x /= 10LL;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\npair<int,int> getPos(int x){\n  if(x == 0){\n    return make_pair(2,2);\n  }else{\n    x--;\n    return make_pair(x%3,x/3);\n  }\n}\n\nint getMD(ll x){\n  vector<int> v = getState(x);\n  int res = 0;\n  for(int i = 0 ; i < 9 ; i++){\n    pair<int,int> tp = getPos(v[i]);\n    res += abs(i%3-tp.first) + abs(i/3-tp.second);\n  }\n  return res;\n}\n\nint LIMIT;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < 3 && 0 <= y && y < 3);\n}\n\nvoid print(vector<int> &v){\n  for(int i = 0 ; i < 3 ; i++){\n    for(int j = 0 ; j < 3 ; j++){\n      cout << v[i*3+j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint ans;\n\nbool solve(int sp,ll st,int step,int prev){\n  int md = getMD(st);\n  if(md == 0){ ans = step; return true; }\n  if(md + step > LIMIT){\n    return false;\n  }\n  int x = sp%3, y = sp/3;\n  bool res = false;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(!inField(nx,ny)){ continue; }\n    if(abs(i-prev) == 2){ continue; }\n    vector<int> v = getState(st);\n    int nsp = ny*3 + nx;\n    swap(v[sp],v[nsp]);\n    res |= solve(nsp,getValue(v),step+1,i);\n  }\n  return res;\n}\n\nint main(){\n  int sp = -1;\n  vector<int> v(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> v[i];\n    if(v[i] == 0){ sp = i; }\n  }\n  ll st = getValue(v);\n  ans = INF;\n  for(LIMIT = 0 ; LIMIT < 35 ; LIMIT++){\n    if(solve(sp,st,0,INF)){\n      cout << ans << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint limit=1,T[3][3];\n\nint evaluate(){\n  int cx[]={2,0,1,2,0,1,2,0,1},cy[]={2,0,0,0,1,1,1,2,2};\n  int ret=0;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      int ti = T[i][j];\n      if (ti==0)continue;\n      ret+=abs(cx[ti]-j);\n      ret+=abs(cy[ti]-i);\n      // if (cx[ti]!=j||cy[ti]!=i)ret++;\n    }\n  }\n  return ret;\n}\n\nbool trymove(int c,int zx,int zy,int pzx,int pzy){\n  int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n  if (evaluate()==0)return true;\n  if (c+evaluate()>limit)return false;\n  for (int i=0;i<4;i++){\n    if (0>zx+dx[i]||zx+dx[i]>2||0>zy+dy[i]||zy+dy[i]>2)continue;\n    if (zx+dx[i]==pzx&&zy+dy[i]==pzy)continue;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n    if (trymove(c+1,zx+dx[i],zy+dy[i],zx,zy)) return true;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n  }\n  return false;\n}\n\nint main(){\n  int zx,zy;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      cin >> T[i][j];\n      if (T[i][j]==0){\n\tzx=j;\n\tzy=i;\n      }\n    }\n  }\n\n  while (true){\n    if (trymove(0,zx,zy,zx,zy))break;\n    limit++;\n  }\n  \n  cout << limit << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <string>\n#include <unordered_map>\n\nint main() {\n  std::unordered_map<std::string, int> ss;\n  std::queue<std::pair<std::string, int>> q;\n  q.push(std::make_pair(\"123456780\", 0));\n  ss[\"123456780\"] = 0;\n  while (q.size()) {\n    auto p = q.front();\n    q.pop();\n    auto s = p.first;\n    auto d = p.second;\n    auto z = std::find(s.begin(), s.end(), '0') - s.begin();\n    auto x = z % 3, y = z / 3;\n    int dxs[] = { 1, -1, 0, 0 }, dys[] = { 0, 0, 1, -1 };\n    for (size_t i = 0; i < 4; i++) {\n      int a = x + dxs[i], b = y + dys[i];\n      if (0 <= a && a < 3 && 0 <= b && b < 3) {\n        std::swap(s[3*y+x], s[3*b+a]);\n        if (ss.find(s) == ss.end()) {\n          ss[s] = d + 1;\n          q.push(std::make_pair(s, d + 1));\n        }\n        std::swap(s[3*y+x], s[3*b+a]);\n      }\n    }\n  }\n  std::string s;\n  for (size_t i = 0; i < 9; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    s.push_back('0' + c);\n  }\n  printf(\"%d\\n\", ss[s]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nUL E[9][9]={\n {0,1,0,1,0,0,0,0,0},\n {1,0,1,0,1,0,0,0,0},\n {0,1,0,0,0,1,0,0,0},\n {1,0,0,0,1,0,1,0,0},\n {0,1,0,1,0,1,0,1,0},\n {0,0,1,0,1,0,0,0,1},\n {0,0,0,1,0,0,0,1,0},\n {0,0,0,0,1,0,1,0,1},\n {0,0,0,0,0,1,0,1,0}\n};\n\nint main() {\n set<string> G;\n string S(9,' '); rep(i,9) scanf(\" %c\",&S[i]);\n queue<pair<string,UL>> Q; Q.push({S,0});\n while(Q.size()){\n  string P=move(Q.front().first);\n  UL d=Q.front().second;\n  UL p=P.find('0');\n  Q.pop();\n  if(P==\"123456780\"){cout<<d<<endl; break;}\n  if(G.count(P)) continue;\n  G.insert(P);\n  rep(j,9) {\n   if(!E[p][j]) continue;\n   swap(P[p],P[j]);\n   Q.push({P,d+1});\n   swap(P[p],P[j]);\n  }\n }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nint main() {\n    std::vector<int> pazzle(9);\n    for (int i = 0; i < 9; i++) {\n        std::cin >> pazzle[i];\n    }\n\n    std::map<std::vector<int>, int> m;\n    std::queue <std::pair<std::vector<int>, int> > q;\n\n    m[pazzle] = 0;\n    m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] = 10000;\n\n    q.push({pazzle, 0});\n    while (!q.empty()) {\n        pazzle = q.front().first;\n        int num = q.front().second;\n        q.pop();\n        if (m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] != 0 && m[{1, 2, 3, 4, 5, 6, 7, 8, 0}]  < num) break;\n        //if (m[pazzle] != 0 && m[pazzle] <= num) continue;\n\n        int space = std::find(pazzle.begin(), pazzle.end(), 0) - pazzle.begin();\n\n        if (space > 2) {\n            std::swap(pazzle[space], pazzle[space - 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({pazzle, num + 1});\n            }\n            std::swap(pazzle[space], pazzle[space - 3]);\n        }\n        if (space < 6) {\n            std::swap(pazzle[space], pazzle[space + 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 3]);\n        }\n        if (space % 3 != 0) {\n            std::swap(pazzle[space], pazzle[space - 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space - 1]);\n        }\n        if (space % 3 != 2) {\n            std::swap(pazzle[space], pazzle[space + 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 1]);\n        }\n    }\n\n    std::cout << m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const char dir[4] = {'r', 'l', 'u', 'd'};\n\nclass Puzzle {\n public:\n  int v[N*N];\n  string path;\n  int space_pos;\n\n  bool operator < (const Puzzle &p) const {\n    for (int i = 0; i < N*N; i++) {\n      if (v[i] == p.v[i]) continue;\n      return v[i] < p.v[i];\n    }\n    return false;\n  }\n};\n\nbool isTarget(Puzzle& p) {\n  for (int i = 0; i < N*N; i++) {\n    if (p.v[i] != ((i+1) % (N*N))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle& p) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  p.path = \"\";\n  Q.push(p);\n  V[p] = true;\n  Puzzle new_u;\n  while(!Q.empty()) {\n    Puzzle u = Q.front();\n    Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    if (u.space_pos % 3 != 2) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos+1]);\n      new_u.space_pos = u.space_pos+1;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[0];\n        Q.push(new_u);\n      }\n    }\n    if (u.space_pos % 3 != 0) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos-1]);\n      new_u.space_pos = u.space_pos-1;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[1];\n        Q.push(new_u);\n      }\n    }\n    if (u.space_pos / 3 != 0) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos-N]);\n      new_u.space_pos = u.space_pos-N;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[2];\n        Q.push(new_u);\n      }\n    }\n    if (u.space_pos / 3 != 2) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos+N]);\n      new_u.space_pos = u.space_pos+N;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[3];\n        Q.push(new_u);\n      }\n    }\n  }\n}\n\n\nint main() {\n  Puzzle p;\n  for (int i = 0; i < N*N; i++) {\n    cin >> p.v[i];\n    if (!p.v[i]) p.space_pos = i;\n  }\n  cout << bfs(p).size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n// è¦ç´ æ°\n#define N 3\n#define N2 N * N\n\n// ä¸,å³,ä¸,å·¦ã®é ã§ãã§ãã¯ãã\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {-1,0,1,0};\nstatic const char dir[4] = {'u','r','d','l'};\n\nstruct Puzzle{\n    // åãã®ã¿ã¤ã«ã®ç¶æ(spaceã¯0ã ãã©ã9ã«æç®ãã)\n    int tiles[N2];\n    // ç©ºç½ã®ä½ç½®ãç®¡çindexã§0 - 8ã¾ã§\n    int space;\n    // è§£æ³ã¾ã§ã®ã«ã¼ããè¨é²\n    string path;\n    \n    // åãç¶æé·ç§»ãå¤å®ãã\n    bool operator < (const Puzzle &p) const {\n        for(int i = 0;i < N2;++i){\n            if(tiles[i] == p.tiles[i]) continue;\n            // ã¿ã¤ã«æ°å¤ãå¤§ããã¨ä¸è´ãã¦ããã¨å¤å®ãã\n            return tiles[i] < p.tiles[i];\n        }\n        return false;\n    }\n};\n\n/**\n    ããºã«ã®ä¸è´ãã§ãã¯\n*/\nbool isCorrect(Puzzle p){\n    // ããºã«ãé çªéãä¸è´ãã¦ããããã§ãã¯\n    for(int i = 0;i < N2;++i){\n        // 1,2,3,4,5,6,7,8ã®é ã§ä¸¦ã¶\n        if(p.tiles[i] != (i + 1)){\n          return false;\n        }\n    }\n    return true;\n}\n\n// å¹åªåæ¢ç´¢ãè¡ã\nstring bfs(Puzzle p){\n    // queueãä½¿ã£ã¦ãããºã«ã®ç¶æé·ç§»ãç®¡çãã\n    queue<Puzzle> Q;\n    // åãé·ç§»ç¶æããªããå¤å®ããããã«mapãå®ç¾©ãã\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    p.path = \"\";\n    Q.push(p);\n    // æåã®ç¶æé·ç§»ãä¿å­\n    V[p] = true;\n    \n    // å¹åªåæ¢ç´¢\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        \n        // æ­£è§£ãã§ãã¯\n        if(isCorrect(u)){\n            return u.path;\n        }\n        // ç©ºç½ã®ä½ç½®ãç®åºãã\n        int sx = u.space % N;\n        int sy = u.space / N;\n        \n        // ã¹ãã¼ã¹ã®å¨ãã®åæ¹ã®ã¿ã¤ã«ãåãã\n        for(int r = 0;r < 4;++r){\n            // åããã¿ã¤ã«ã®indexãç®åºãã(ä¸,å³,ä¸,å·¦ã®é )\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            // ç¯å²å¤ãã§ãã¯\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n                continue;\n            }\n            v = u;\n            // å¥ãæ¿ã\n            swap(v.tiles[u.space],v.tiles[ty * N + tx]);\n            // å¥ãæ¿ããå ´æãspaceã«ãªã\n            v.space = (ty * N) + tx;\n            \n            // åãç¶æãã§ãªãã£ãã\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    \n    for(int i = 0;i < N2;++i){\n        cin >> in.tiles[i];\n        if(in.tiles[i] == 0){\n            // ç©ºç½ã¯9ã¨ãã¦ç®¡ç\n            in.tiles[i] = N2;\n            in.space = i;\n        }\n    }\n    \n    string answer = bfs(in);\n    cout << answer.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\t//s+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t\t\t\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tint val=calc(v);\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 25;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int mx[4] = {0,-1,0,1};\nconst int my[4] = {-1,0,1,0};\nconst char itoc[10] = {'0','1','2','3','4','5','6','7','8','9'};\n\nint bfs(vector<int> p, string key) {\n    queue< pair<vector<int>,int> > q;\n    map<string,bool> m;\n    pair<vector<int>,int> a,b;\n    q.push(make_pair(p,0));\n    m[key] = true;\n\n    while(!q.empty()) {\n        a = q.front(); q.pop();\n        bool flg=true;\n        int blank;\n        for(int i=0; i<N2; i++) {\n            if(a.first[i]!=i+1) flg = false;\n            if(a.first[i]==N2) blank=i;\n        }\n        if(flg==true) return a.second;\n        int bx = blank%N, by = blank/N;\n        for(int i=0; i<4; i++) {\n            int x=bx+mx[i],y=by+my[i];\n            if(x<0 || x>=N || y<0 || y>=N) continue;\n            b = make_pair(a.first,a.second);\n            swap(b.first[y*N+x],b.first[blank]);\n            key=\"\";\n            for(int j=0; j<N2; j++) key += itoc[b.first[j]];\n            if(!m[key]) {\n                m[key] = true;\n                b.second+=1;;\n                q.push(b);\n            }\n        }\n\n\n    }\n    return 0;\n}\n\nint main() {\n    vector<int> init; int k;\n    string key=\"\";\n    for(int i=0; i<N2; i++) {\n        cin >> k; init.push_back(k);\n        if(init[i]==0) init[i]=N2;\n        key+=itoc[init[i]];\n    }\n    cout << bfs(init, key) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nconst ll R=3;\n\nll Hash(vector<vector<ll>> &A){\n    ll ret=0;\n    for(int i=0;i<R;i++){\n        for(int t=0;t<R;t++){\n            ret+=A[i][t];\n            if(i+1!=R || t+1!=R){\n                ret*=10;\n            }\n        }\n    }\n    return ret;\n}\n\nmap<ll,ll> M;\n\nvector<ll> dx={0,1,0,-1};\nvector<ll> dy={1,0,-1,0};\n\nstruct PZL{\n    ll hash;\n    vector<vector<ll>> A;\n    ll h,w;\n    ll d;\n};\n\n\nvoid bfs(vector<vector<ll>> A){\n    queue<PZL> Q;\n    Q.push({Hash(A),A,2,2,0});\n    M[Hash(A)]=0;\n    while(!Q.empty()){\n        PZL W=Q.front(); Q.pop();\n        for(int i=0;i<4;i++){\n            ll x=W.h+dx[i];\n            ll y=W.w+dy[i];\n            if(x<0 || y<0 || x>=R || y>=R){continue;}\n            PZL N=W;\n            swap(N.A[x][y],N.A[W.h][W.w]);\n            N.hash=Hash(N.A);\n            if(M.count(N.hash)){continue;}\n            N.h=x;\n            N.w=y;\n            M[N.hash]=++N.d;\n            Q.push(N);\n        }\n    }\n}\n\n\n\nint main(){\n    bfs({{1,2,3},{4,5,6},{7,8,0}});\n    vector<vector<ll>> A(3,vector<ll>(3));\n    for(int i=0;i<R;i++){\n        for(int t=0;t<R;t++){\n            cin>>A[i][t];\n        }\n    }\n    ll h=Hash(A);\n    cout<<M[h]<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nint minimum=-1;\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nint main(){\n\n\tint table[3][3];\n\tstack<long long>A,B;\n\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tA.push(makeLong(table));\n\tlong long tmp;\n\tbool foundFLG=false;\n\n\tfor(int count=0;count < 362880;count++){\n\t\tif(count%2 == 0){\n\t\t\twhile(!A.empty()){\n\t\t\t\ttmp = A.top();\n\t\t\t\tA.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0:\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tB.push(makeLong(next_table[3]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\twhile(!B.empty()){\n\t\t\t\ttmp = B.top();\n\t\t\t\tB.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0: //??????\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t//??????\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tA.push(makeLong(next_table[3]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(foundFLG)break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 3;\nconst int dx[4] = {0,1,0,-1},dy[4] = {1,0,-1,0};\n\nint mat[N][N];\nint lim;\n\nint getMD(){\n  int sum = 0;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < N; j++){\n      if(mat[i][j] == N*N-1) continue;\n      sum += abs(mat[i][j]/N-i) + abs(mat[i][j]%N-j);\n    }\n  }\n  return sum;\n}\n\nbool IDAstar(int depth,int prev,int py,int px){\n  int MD = getMD();\n  if(MD == 0) return true;\n  if(depth + MD > lim) return false;\n\n  for(int k = 0; k < 4; k++){\n    int ny = py + dy[k];\n    int nx = px + dx[k];\n    if(ny < 0 || N <= ny || nx < 0 || N <= nx) continue;\n    if(abs(k - prev) == 2) continue;\n    swap(mat[ny][nx],mat[py][px]);\n    if(IDAstar(depth+1,k,ny,nx)) return true;\n    swap(mat[ny][nx],mat[py][px]);\n  }\n  return false;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int py,px;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < N; j++){\n      cin >> mat[i][j];\n      if(mat[i][j] == 0){\n        mat[i][j] = N*N;\n        py = i;\n        px = j;\n      }\n      mat[i][j]--;\n    }\n  }\n\n  for(lim = 0; lim < 100; lim++){\n    if(IDAstar(0,100,py,px)){\n      cout << lim << endl;\n      return 0;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Data = pair < string , int >;\n\nint main()\n{\n        string S = \"         \";\n        queue < Data > que;\n        set < string > used;\n        int d[4] = {-3, -1, 1, 3};\n\n        for ( int i = 0; i < 9; i++ ) cin >> S[i];\n        \n        que.emplace(S, 0);\n\n        while ( !que.empty() ) {\n                Data q = que.front(); que.pop();\n                string T;\n                if ( q.first == \"123456780\" ) {\n                        cout << q.second << endl;\n                        return ( 0 );\n                }\n                int pos = q.first.find('0');\n                for ( int i = 0; i < 4; i++ ) {\n                        int npos = pos + d[i];\n                        string T = q.first;\n                        if ( i == 1 && pos % 3 == 0 ) continue;\n                        if ( i == 2 && pos % 3 == 2 ) continue;\n                        if ( npos < 0 || 8 < npos ) continue;\n                        swap(T[pos], T[npos]);\n                        if ( used.find(T) == used.end() ) {\n                                used.insert(T);\n                                que.emplace(T, q.second + 1);\n                        }\n                }\n        }\n\n        return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nstatic int board[9], goal[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\nstatic bool rec(int n, int x, int y) {\n  if (n == 0)\n    return std::mismatch(board, board + 9, goal).first == board + 9;\n  int dxs[] = { 1, -1, 0, 0 }, dys[] = { 0, 0, 1, -1 };\n  for (size_t i = 0; i < 4; i++) {\n    int p = x + dxs[i], q = y + dys[i];\n    if (0 <= p && p < 3 && 0 <= q && q < 3) {\n      std::swap(board[3*y+x], board[3*q+p]);\n      if (rec(n - 1, p, q))\n        return true;\n      std::swap(board[3*y+x], board[3*q+p]);\n    }\n  }\n  return false;\n}\n\nint main() {\n  for (size_t i = 0; i < 9; i++)\n    scanf(\"%d\", board + i);\n  int z = std::find(board, board + 9, 0) - board;\n  int x = z % 3, y = z / 3;\n  for (int n = 0;; n++)\n    if (rec(n, x, y)) {\n      printf(\"%d\\n\", n);\n      break;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\nconst int N = 3;\nconst int INF = 50;\nvector<vector<int> > cell(N, vector<int>(N));\nvector<vector<int> > ans = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\nint q = 0;\nunordered_set<int> ms;\nint zero_x = 0;\nint zero_y = 0;\nint ministep = INF;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\nint key(vector<vector<int> > cell)\n{\n\tint res = 0;\n\tint p = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tres += cell[i][j] * p;\n\t\t\tp *= 10;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(int i)\n{\n\tint p = key(cell);\n\tif (ms.find(p) != ms.end() || ministep < i) {\n\t\treturn;\n\t}\n\tif (p == q) {\n\t\tministep = min(ministep, i);\n\t\treturn;\n\t}\n\t\n\tms.insert(p);\n\tif (zero_x > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t}\n\tif (zero_x < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t}\n\tif (zero_y > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t}\n\tif (zero_y < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t}\n\tms.erase(p);\n}\n\nint main()\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcin >> cell[i][j];\n            if (cell[i][j] == 0) {\n                zero_x = i;\n                zero_y = j;\n            }\n\t\t}\n\t}\n\n\tq = key(ans);\n\tsolve(0);\n\tcout << ministep << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < ( const Puzzle &p ) const {\n\t\tfor ( int i = 0; i < N2; i++ ) {\n\t\t\tif ( f[i] == p.f[i] ) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n\tfor ( int i = 0; i < N2; i++ )\n\t\tif (p.f[i] != (i + 1)) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\nwhile ( !Q.empty()) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget(u) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\tfor ( int r = 0; r < 4; r++ ) {\n\t\tint tx = sx + dx[r];\n\t\tint ty = sy + dy[r];\n\t\tif ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t\tv = u;\n\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif ( !V[v] ) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++ ) {\n\t\tcin >> in.f[i];\n\t\tif ( in.f[i] == 0 ) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstruct pz{\n\tint a[9];\n\tint t;\n\n\tbool operator < (const pz &p) const {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (a[i] == p.a[i])\n\t\t\t\tcontinue;\n\t\t\treturn a[i] > p.a[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tpz p;\n\tint n = -1;\n\tmap<pz, bool> v;\n\n\tfor (int i = 0; i < 9; i++)\n\t\tcin >> p.a[i];\n\n\tp.t = 0;\n\n\tqueue<pz> que;\n\tque.push(p);\n\tv[p] = true;\n\n\twhile (!que.empty()) {\n\t\tpz g = que.front();\n\t\tque.pop();\n\n\t\tbool f = 1;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (g.a[i] != (i + 1)) {\n\t\t\t\tf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (f == 1) {\n\t\t\tn = g.t;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (g.a[i] == 0) {\n\t\t\t\tif(i % 3 != 0){\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i % 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 0) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n//        return s.count * 2 + direction - 1;\n        return s.count * 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid decodeboard(int board, vector<int>& brd) {\n\tfor(int i=0; i<9; ++i) {\n\t\tbrd[8-i]=board%10;\n\t\tboard/=10;\n\t}\n\treturn;\n}\n\nvoid encodeboard(int& board, vector<int>& brd) {\n\tboard=0;\n\tfor(int i=0; i<9; ++i) {\n\t\tboard*=10;\n\t\tboard+=brd[i];\n\t}\n\treturn;\n}\n\nint searchzero(vector<int> brd) {\n    for(int i=0; i<9; ++i){\n        if(brd[i]==0) return i;\n    }\n    return -1;\n}\n\nint main() {\n\tint board=0;\n\tint goal=123456780;\n\n\tvector<int> brd(9,0);\n\n\tfor(int i=0; i<9; ++i) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tboard*=10;\n\t\tboard+=temp;\n\t\tbrd[i]=temp;\n\t}\n\n\t// BFS\n\tqueue<P> q;\n\tunordered_set<int> checked;\n\tint cnt=0;\n\n\tq.push(P(board,0));\n\n\twhile(!q.empty()) {\n\t\tP p=q.front(); q.pop();\n\t\tboard=p.first; cnt=p.second;\n\t\tcnt=p.second;\n\t\tif(checked.count(board)!=0) continue;\n        if(board==goal) break;\n\t\tdecodeboard(board,brd); // board--->brd[]\n        ++cnt;\n        int zp=searchzero(brd);\n        switch(zp/3) {\n        case 0:\n            brd[zp]=brd[zp+3];\n            brd[zp+3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+3]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 1:\n            brd[zp]=brd[zp-3];\n            brd[zp-3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-3]=brd[zp];\n            brd[zp]=0;\n\n            brd[zp]=brd[zp+3];\n            brd[zp+3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+3]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 2:\n            brd[zp]=brd[zp-3];\n            brd[zp-3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-3]=brd[zp];\n            brd[zp]=0;\n            break;\n        }\n\n        switch(zp%3) {\n        case 0:\n            brd[zp]=brd[zp+1];\n            brd[zp+1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+1]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 1:\n            brd[zp]=brd[zp+1];\n            brd[zp+1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+1]=brd[zp];\n            brd[zp]=0;\n\n            brd[zp]=brd[zp-1];\n            brd[zp-1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-1]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 2:\n            brd[zp]=brd[zp-1];\n            brd[zp-1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-1]=brd[zp];\n            brd[zp]=0;\n            break;\n        }\n\t}\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0 ; i < N2 ; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] ={-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0 ; i < N2 ; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle, bool>V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0 ; r < 4 ; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0 ; i < N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout<< ans.size()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n#define N 3\n#define N2 9\n\nstruct 8puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const 8puzzle & p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n\nbool isTarget(8puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(8puzzle s)\n{\n    queue<8puzzle> Q;\n    map<8puzzle, bool> V;\n    8puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\nint main()\n{\n    8puzzle in;\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin >> p.f[i];\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> > Q;\n\nvoid Sw(string st,int x)\n{\n\tint i;\n\tint pos,npos;\n\tint d[4]={-3,3,-1,1};\n\tstring st1;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tif(st[i]=='0')\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=0;i<=3;i++)\n\t{\n\t\tst1=st;\n\t\tif(i==2 && pos%3==0) continue;\n\t\tif(i==3 && pos%3==0) continue;\n\t\tnpos=pos+d[i];\n\t\tif(npos>=9 || npos<=-1) continue;\n\t\tswap(st1[pos],st1[npos]);\n\t\tQ.push(pair<string,int>(st1,x+1));\n\t}\n}\n\nint main()\n{\n\tstring puzzle=\"\";\n\tstring goal=\"123456780\";\n\tmap<string,bool> M;\n\tint i,x;\n\tstring P;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tcin >> x;\n\t\tpuzzle+='0'+x;\n\t}\n\tQ.push(pair<string,int>(puzzle,0));\n\twhile(1)\n\t{\n\t\tpair<string,int> p=Q.front();\n\t\tQ.pop();\n\t\tP=p.first;\n\t\tx=p.second;\n\t\tif(P==goal)\n\t\t{\n\t\t\tcout << x << endl;\n\t\t\tbreak;\n\t\t}\n\t\tif(M[P]) continue;\n\t\telse M[P]=1;\n\t\tSw(P,x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define sz(x) ll(x.size())\n//typedef long long ll;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = 10e15;\nconst ll MINF = -10e10;\n//const int INF = INT_MAX / 100;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n\n\n//ifstream myfile(\"~/Downloads/02.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n//typedef priority_queue<P, vector<P>, greater<P> > PQ_ASK;\nconst int mod = 1000000007;\nconst double PI = 3.14159265358979323846;\n\ntypedef pair<ll, ll> P;\n\n\nstring to_upper(string str) {\n    int diff = 'a' - 'A';\n    for (int i = 0; i < str.size(); i++) {\n        char c = str[i];\n        if ('A' <= c && c <= 'Z') {\n            c += diff;\n            str[i] = c;\n        }\n    }\n    return str;\n}\n\nvector<int> up(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 0 || id == 1 || id == 2) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id - 3]);\n    return res;\n}\n\nvector<int> down(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 6 || id == 7 || id == 8) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id + 3]);\n    return res;\n}\n\nvector<int> right(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 2 || id == 5 || id == 8) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id + 1]);\n    return res;\n}\n\nvector<int> left(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 0 || id == 3 || id == 6) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id - 1]);\n    return res;\n}\n\nstruct Board {\n    vector<int> board;\n    int depth;\n};\n\nint bfs(vector<int> &board) {\n\n    vector<int> clear = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    set<vector<int> > used;\n\n    queue<Board> q;\n    q.push({board, 0});\n\n    while (!q.empty()) {\n        Board top = q.front();\n        q.pop();\n        if (top.board == clear) {\n            return top.depth;\n        }\n        if (used.find(top.board) != used.end()) {\n            continue;\n        }\n        used.insert(top.board);\n\n        vector<int> u = up(top.board),\n                d = down(top.board),\n                r = right(top.board),\n                l = left(top.board);\n\n        if (!u.empty()) {\n            q.push({u, top.depth + 1});\n        }\n        if (!d.empty()) {\n            q.push({d, top.depth + 1});\n        }\n        if (!r.empty()) {\n            q.push({r, top.depth + 1});\n        }\n        if (!l.empty()) {\n            q.push({l, top.depth + 1});\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    vector<int> board(9, 0);\n    rep(i, 9) cin >> board[i];\n\n    int ans = bfs(board);\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#define maxn 3\nusing namespace std;\n\nstruct Node\n{\n    int x,y;\n    int data[maxn][maxn];\n    int step;\n    friend bool operator ==(Node a,Node b)\n    {\n        bool flag=true;\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n                if(a.data[i][j]!=b.data[i][j])\n                    {\n                        flag=false;\n                        break;\n                    }\n        return flag;\n    }\n\n    string covert_string()\n    {\n        string st=\"\";\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n                st+=(data[i][j]-0+'0');\n        return st;\n    }\n};\nqueue<Node> q;\nmap<string,int> mp;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\n\nvoid read(int &x){//è¯»å¥æ­£æ´æ°ä¼å\n\tchar ch = getchar();x = 0;\n\tfor (; ch < '0' || ch > '9'; ch = getchar());\n\tfor (; ch >='0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n}\n\nint main()\n{\n    int i,j,k,t,x;\n    Node p,p_,aim;\n    for(i=0;i<maxn;i++)\n        for(j=0;j<maxn;j++)\n        {\n            read(x);\n            p.data[i][j]=x;\n            if(x==0)\n                p.x=i,p.y=j;\n        }\n    for(i=0;i<3;i++)\n        for(j=0;j<3;j++)\n            aim.data[i][j]=(i*3)+j+1;\n    aim.data[2][2]=0;\n    if(p==aim)\n    {\n        printf(\"0\\n\");\n        return 0;\n    }\n    p.step=0;\n    q.push(p);\n    mp[p.covert_string()]=1;\n    while(!q.empty())\n    {\n        p=q.front();\n        q.pop();\n        for(i=0;i<4;i++)\n        {\n            int xx=p.x+dx[i];\n            int yy=p.y+dy[i];\n            if(xx>=0&&xx<3&&yy>=0&&yy<3)\n            {\n                for(j=0;j<3;j++)\n                    for(k=0;k<3;k++)\n                        p_.data[j][k]=p.data[j][k];\n                swap(p_.data[xx][yy],p_.data[p.x][p.y]);\n                string st=p_.covert_string();\n                if(mp.count(st)==0)\n                {\n                    p_.x=xx,p_.y=yy,p_.step=p.step+1;\n                    if(p_==aim)\n                    {\n                        printf(\"%d\\n\",p_.step);\n                        return 0;\n                    }\n                    q.push(p_);\n                    mp[st]=1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n      return res;\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\nconst int n = 3;\nstruct no{\n    int a[n][n];//æ£ç\n    int x, y;//0æå¨çä½ç½®\n    string path;\n    bool operator < (const no &p) const {\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(a[i][j] == p.a[i][j]) continue;\n                return a[i][j] > p.a[i][j];\n            }\n        }\n        return false;\n    }\n};\nno s, g;\nint isEqual(no x, no y){\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(x.a[i][j] != y.a[i][j]) return 0;\n        }\n    }\n    return 1;\n}\nvoid bfs(){\n    int dy[] = {-1, 0, 1, 0};//å·¦ï¼ä¸ï¼å³ï¼ä¸\n    int dx[] = {0, -1, 0, 1};\n    string dr[] = {\"l\", \"u\", \"r\", \"d\"};\n    queue<no> q;\n    map<no, bool> used;\n    s.path = \"\";\n    q.push(s);\n    while(!q.empty()){\n        no t = q.front(); q.pop();\n        used[t] = true;\n        if(isEqual(t, g)){\n            cout<<t.path.length()<<endl;\n            break;\n        }\n        for(int i = 0; i < 4; i++){\n            int nx = t.x + dx[i];\n            int ny = t.y + dy[i];\n            if(0 <= nx && nx < n && 0 <= ny && ny < n){\n                no u;\n                u.x = nx; u.y = ny;\n                for(int k = 0; k < n; k++){\n                    for(int j = 0; j < n; j++){\n                        u.a[k][j] = t.a[k][j];\n                    }\n                }\n                u.a[t.x][t.y] = u.a[nx][ny]; u.a[nx][ny] = 0;\n                u.path = t.path;\n                if(!used[u]){\n                    u.path += dr[i];\n                    q.push(u);\n                }\n            }\n        }\n    }\n}\nint main(){\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            scanf(\"%d\", &s.a[i][j]);\n            if(s.a[i][j] == 0) {s.x = i; s.y = j; }\n            g.a[i][j] = n*i + (j+1);\n        }\n    }\n    g.a[n-1][n-1] = 0;\n    g.x = g.y = 2;\n    bfs();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define MAX 3\n#define MAX2 9\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n  \n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<MAX2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<MAX2;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n}\nstring BFS(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/MAX;\n    int sy=u.space%MAX;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=MAX || ty>=MAX)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*MAX+ty]);\n      v.space=tx*MAX+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"umsolvable\";\n}\n\nint main() {\n  Puzzle in;\n  for(int i=0;i<MAX2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=MAX2;\n      in.space=i;\n    }\n  }\n  string ans=BFS(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nmap<string, int> mp;\n\nstring trans(vector< vector<int> > a){\n  string t = \"\";\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) t += to_string(a[i][j]);\n  return t;\n}\n\nvoid dfs(vector< vector<int> > a, int turn){\n  string t = trans(a);\n  if( mp[t] != 0 && turn > mp[t] ) return;\n  if( t == \"123456780\" ){\n    // cout << t << \" \" << turn << \" \" << mp[t] << endl;\n    mp[t] = turn;\n    return;\n  }\n  if( turn > 15 ) return;\n  mp[t] = turn;\n  // cerr << t << \" \" << mp[t] << endl;\n\n  for(int y=0; y<3; y++){\n    for(int x=0; x<3; x++){\n      if( a[y][x] == 0 ){\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          vector< vector<int> > b = a;\n          swap(b[ny][nx], b[y][x]);\n          string tt = trans(b);\n          dfs(b, turn + 1);\n        }\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n\n  vector< vector<int> > a(3, vector<int>(3));\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) cin >> a[i][j];\n  mp[trans(a)] = 0;\n  mp[\"123456780\"] = inf;\n  dfs(a, 1);\n  cout << mp[\"123456780\"] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\n int i,j;\n//?Â§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    cin >>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n//        for (pos = 0; pos < N; ++pos) {\n//            if (((s.board >> (pos*4)) & 15) == 0) {\n//                break;\n//            }\n//        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    int steps = 0;\n    while (!pq.empty()) {\n        steps++;\n        node u = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0 && goal[u.zeroI - 1][u.zeroJ] != u.puzzle[u.zeroI - 1][u.zeroJ]) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3 && goal[u.zeroI + 1][u.zeroJ] != u.puzzle[u.zeroI + 1][u.zeroJ]) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0 && goal[u.zeroI][u.zeroJ - 1] != u.puzzle[u.zeroI][u.zeroJ - 1]) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3 && goal[u.zeroI][u.zeroJ + 1] != u.puzzle[u.zeroI][u.zeroJ + 1]) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur) - 1);\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//        cout << \"(i = \" << i << \") \" << in.path << endl;\n//        for (int j = 0; j < N2; j++)\n//            cout << \" \" << in.f[j];\n//        cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n//    ms[in] = true;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\n\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        if(p[i][j]==0) zy=i,zx=j;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      if(!m.count(t)){\n        m[t]=m[x]+1;\n        q.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"puzzle.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> Vector;\ntypedef vector<vector<ll>> DVector;\n\n#define fi          first\n#define se          second\n#define pb          push_back\n#define INF         INT_MAX/3\n#define bcnt        __builtin_popcount\n#define all(x)      (x).begin(),(x).end()\n#define dbg(x)      cout<<#x\"=\"<<x<<endl\n#define ub(x,y)     upper_bound(all(x),y)-x.begin()\n#define lb(x,y)     lower_bound(all(x),y)-x.begin()\n#define uni(x)      x.erase(unique(all(x)),x.end())\n#define rep(i,n)    repl(i,0,n-1)\n#define repl(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);i++)\n#define mmax(x,y)   (x>y?x:y)\n#define mmin(x,y)   (x<y?x:y)\n#define maxch(x,y)  x=mmax(x,y)\n#define minch(x,y)  x=mmin(x,y)\n#define exist(x,y)  (find(all(x),y)!=x.end())\n#define each(itr,v) for(auto itr:v)\n#define usort(x)    sort(all(x))\n#define dsort(x)    sort(all(x),greater<int>())\n#define mkp(x,y)    make_pair(x,y)\n#define N 3\n\n\nll seach_count = 0;\n\nint h0(DVector tmp){\n  return 0;\n}\n\nint h1(DVector &tmp){\n  int ct = 0;\n  rep(i,N)rep(j,N)if(amp[i][j] != tmp[i][j] && tmp[i][j] != 0 )ct++;\n  return ct;\n}\n\nint h2(int n){\n\n}\n\nbool as(){\n\n}\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  int mp[N][N];\n  create_puzzle(mp);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\n\nclass State{\npublic:\n    vector<vector<int>> puzzle;\n    int zero_col, zero_row, prev_zero_col, prev_zero_row;\n    int edge_len, heuristic;\n    State(vector<vector<int>>& arr, const int& zc, const int& zr, const int& pzc, const int& pzr, const int& h): puzzle(arr), zero_col(zc), zero_row(zr), prev_zero_col(pzc), prev_zero_row(pzr), heuristic(h) {\n        edge_len = arr.size();\n    }\n    int get_manhattan_diff(const int& new_zero_col, const int& new_zero_row){\n        int diff = 0;\n        diff += abs((puzzle[new_zero_row][new_zero_col]-1)/edge_len - zero_row) + abs((puzzle[new_zero_row][new_zero_col]-1)%edge_len - zero_col) - abs((puzzle[new_zero_row][new_zero_col]-1)/edge_len - new_zero_row) - abs((puzzle[new_zero_row][new_zero_col]-1)%edge_len - new_zero_col);\n        return diff;\n    }\n    vector<State> get_next_states(){\n        vector<State> res;    \n        vector<vector<int>> tmp;\n        int diff;\n        if(zero_col+1 < edge_len && prev_zero_col != zero_col+1){\n            diff = get_manhattan_diff(zero_col+1, zero_row);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row][zero_col+1]);\n            res.push_back(State(tmp, zero_col+1, zero_row, zero_col, zero_row, heuristic + diff));\n        }\n        if(zero_col-1 >= 0 && prev_zero_col != zero_col-1){\n            diff = get_manhattan_diff(zero_col-1, zero_row);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row][zero_col-1]);\n            res.push_back(State(tmp, zero_col-1, zero_row, zero_col, zero_row, heuristic + diff));\n        }\n        if(zero_row+1 < edge_len && prev_zero_row != zero_row+1){\n            diff = get_manhattan_diff(zero_col, zero_row+1);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row+1][zero_col]);\n            res.push_back(State(tmp, zero_col, zero_row+1, zero_col, zero_row, heuristic + diff));\n        }\n        if(zero_row-1 >= 0 && prev_zero_row != zero_row-1){\n            diff = get_manhattan_diff(zero_col, zero_row-1);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row-1][zero_col]);\n            res.push_back(State(tmp, zero_col, zero_row-1, zero_col, zero_row, heuristic + diff));\n        }\n        return res;\n    }\n};\n\nint get_sum_manhattan(vector<vector<int>>& state){\n    int edge_len = state.size(), res = 0;\n    for(int i = 0; i < edge_len; i++){\n        for(int j = 0; j < edge_len; j++){\n            if(state[i][j] != 0)\n                res += abs((state[i][j]-1)/edge_len - i) + abs((state[i][j]-1)%edge_len -j); \n        }\n    }\n    return res;\n}\n\nbool DLS(State& state, const int& limit, const int& depth){\n    if(depth + state.heuristic > limit) return false;\n    if(state.heuristic == 0) return true;\n    vector<State> next_states = state.get_next_states();\n    for(State s : next_states){\n        if(DLS(s, limit, depth+1)) return true;\n    }\n    return false;\n}\n\nint IDA(State& initial_state, const int& max_step){\n    for(int l = 0; l <= max_step; l++){\n        if(DLS(initial_state, l, 0))\n            return l;\n    }\n    return -1;\n}\n\nint main(){\n    int max_step = 45;\n    int edge_len = 3;\n    int x, zr, zc;\n    vector<vector<int>> puzzle(edge_len, vector<int>(edge_len));\n    for(int i = 0; i < edge_len; i++){\n        for(int j = 0; j < edge_len; j++){\n            scanf(\"%d\", &x);\n            if(x == 0){\n                zr = i; zc = j;\n            }\n            puzzle[i][j] = x;\n        }\n    }\n    State initial_state = State(puzzle, zc, zr, zc, zr, get_sum_manhattan(puzzle));\n    printf(\"%d\\n\", IDA(initial_state, max_step));\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9];\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tmemset(used,0,sizeof(used));\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tif(used[v.men[0][0]][v.men[0][1]][v.men[0][2]][v.men[1][0]][v.men[1][1]][v.men[1][2]][v.men[2][0]][v.men[2][1]][v.men[2][2]]==false){\n\t\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t\tif(b==1)break;\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<assert.h>\n\ntemplate<typename T>\nvoid swap(T &a,T &b){\n  T x=a;\n  a=b;\n  b=x;\n}\n\nint dif(int x,int y){return x-y>=0?x-y:y-x;}\n\nconst int N = 3;\nint st[N*N];\n\nint calc(int i,int j){ \n  if(st[i*N+j]<0) return 0;\n  int res=0; \n  res+=dif(i,st[i*N+j]/N);\n  res+=dif(j,st[i*N+j]%N);\n  return res;\n}\n\nint dist=0,ans=31;\n\nint check(int cur){\n  if(dist==0&&ans>cur) ans=cur;\n  int val=cur+dist;\n  return val<ans;  \n}\n\nint dy[]={0,0,1,-1};\nint dx[]={1,-1,0,0};\nint in(int y,int x){return 0<=y&&y<N&&0<=x&&x<N;};\n\nvoid dfs(int di,int y,int x,int p){\n  for(int k=0;k<4;k++){\n    if((p>=0)&&((p^1)==k)) continue;\n    int ny=y+dy[k],nx=x+dx[k];\n    if(!in(ny,nx)) continue;\n    dist-=calc(ny,nx);\n    swap(st[y*N+x],st[ny*N+nx]);\n    dist+=calc(y,x);\n    if(check(di+1)) dfs(di+1,ny,nx,k);    \n    dist-=calc(y,x);\n    swap(st[y*N+x],st[ny*N+nx]);\n    dist+=calc(ny,nx);\n  }\n}\n\nint main(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      std::cin>>st[i*N+j],st[i*N+j]--;\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      dist+=calc(i,j);\n  \n  int y=-1,x=-1;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      if(st[i*N+j]<0) y=i,x=j;\n\n  check(0);\n  dfs(0,y,x,-1);\n  \n  std::cout<<ans<<std::endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nusing Weight=int;\nusing Encoded=int;\n\nstruct State {\n    Weight hcost, acost;\n    Encoded encoded;\n    State() {}\n    State(Weight h, Weight a, Encoded e): hcost(h), acost(a), encoded(e) {}\n    bool operator>(const State & state2) const {\n        if (hcost+acost != state2.hcost+state2.acost) {\n            return hcost+acost > state2.hcost+state2.acost;\n        } else {\n            return acost > state2.acost;\n        }\n    }\n};\n\nconst Weight INF=1<<29;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nEncoded encode(vector<int> d) {\n    int cur=0;\n    Encoded enc=0;\n    for (size_t i=0; i<d.size()-1; ++i) {\n        cur = d[i];\n        for (size_t j=i+1; j<d.size(); ++j)\n            if (cur < d[j])\n                --d[j];\n\n        (enc += d[i]) *= d.size()-i-1;\n    }\n\n    return enc;\n}\n\nvector<int> decode(Encoded e) {\n    vector<int> d(9);\n    for (size_t i=1; i<=9; ++i) {\n        d[9-i] = e % i;\n        e /= i;\n    }\n\n    for (size_t i=9; i--;)\n        for (size_t j=i+1; j<9; ++j)\n            if (d[i] <= d[j])\n                ++d[j];\n\n    return d;\n}\n\nWeight heucost(Encoded start, Encoded end) {\n    static const vector<int> dend=decode(end);\n    vector<int> dstart=decode(start);\n\n    Weight h=0;\n    for (size_t i=0; i<9; ++i)\n        for (size_t j=0; j<9; ++j)\n            if (dstart[i] == dend[j]) {\n                h += abs(int(i/3-j/3))+abs(int(i%3-j%3));\n                break;\n            }\n\n    return h;\n}\n\nvector<pair<Weight, Encoded>> pmoves(Encoded cur) {\n    vector<int> d=decode(cur);\n    size_t i;\n    for (i=0; d[i]; ++i);\n\n    vector<pair<Weight, Encoded>> p;\n    if (i/3 < 2) {\n        swap(d[i], d[i+3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+3]);\n    }\n    if (i/3 > 0) {\n        swap(d[i], d[i-3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-3]);\n    }\n    if (i%3 < 2) {\n        swap(d[i], d[i+1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+1]);\n    }\n    if (i%3 > 0) {\n        swap(d[i], d[i-1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-1]);\n    }\n    return p;\n}\n\nWeight astar(Encoded start, Encoded end) {\n    lp_queue<State> q;\n    q.push(State(heucost(start, end), 0, start));\n\n    Weight opt=INF;\n    set<Encoded> visited;\n    while (!q.empty()) {\n        State p=q.top(); q.pop();\n        Weight cur_cost=p.acost;\n        Encoded cur_state=p.encoded;\n        visited.insert(cur_state);\n\n        if (opt < cur_cost) continue;\n        if (cur_state == end)\n            if (opt > cur_cost)\n                opt = cur_cost;\n\n        vector<pair<Weight, Encoded>> ms=pmoves(cur_state);\n        for (pair<Weight, Encoded> m: ms) {\n            if (visited.count(m.second)) continue;\n            if (cur_cost+m.first >= opt) continue;\n\n            q.push(State(heucost(m.second, end), cur_cost+m.first, m.second));\n        }\n    }\n\n    return opt;\n}\n\nint main() {\n    vector<int> d(9);\n    for (size_t i=0; i<9; ++i)\n        scanf(\"%d\", &d[i]);\n\n    Encoded e=encode(d);\n\n    Weight c=astar(e, 46233);\n    printf(\"%d\\n\", c);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define LIMIT 30\n\nstruct Puzzle{\n    char cont[9];\n    int space;\n    string path;\n    bool operator < ( const Puzzle &p ) const{\n        for ( int i = 0; i < 9; i++ ){\n            if ( cont[i] == p.cont[i] ) continue;\n            return cont[i] > p.cont[i];\n        }\n        return false;\n    }\n};\n\nint limit;\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char direction[4] = {'d', 'r', 'u', 'l'};\n\nbool isTarget(Puzzle puzzle){\n    for ( int i = 0; i < 8; i++ ){\n        if ( puzzle.cont[i] != '1' + i ) return false;\n    }\n    return true;\n}\n\nvoid bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty() ){\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ){\n            cout << u.path.size() << endl;\n            return;\n        } else if ( u.path.size() > LIMIT ) break;\n        \n        int sx, sy, tx, ty;\n        sx = u.space/3;\n        sy = u.space%3;\n        \n        for ( int r = 0; r < 4; r++ ){\n            tx = sx + dx[r];\n            ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= 3 || ty >= 3 ) continue;\n            v = u;\n            v.cont[u.space] = u.cont[tx*3+ty];\n            v.cont[tx*3+ty] = '0';\n            v.space = tx*3+ty;\n            if ( !V[v] ){\n                V[v] = true;\n                v.path += direction[r];\n                Q.push(v);\n            }\n        }\n    }\n    cout << \"unsolvable\" << endl;\n}\n\nint main(){\n    Puzzle in;\n    for ( int i = 0; i < 9; i++ ){\n        cin >> in.cont[i];\n        if ( in.cont[i] == '0' ) {\n            in.space = i;\n        }\n    }\n    \n    bfs(in);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\nbool in(int a,int b){\n  if(a<0||b<0||3<=a||3<=b)return false;\n  return true;\n}\nint main(){\n  int a;\n  string start=\"\",goal=\"123456780\";\n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n  queue<string> q;\n  map<string,int> m;\n  m[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    if(u==goal){\n      cout<<m[u]<<endl;\n      break;\n    }\n    int s=-1;\n    for(int i=0;i<u.length();i++)if(u[i]=='0')s=i;\n    int y=s/3,x=s%3;\n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int g=ny*3+nx;\n      string t=u;\n      swap(t[s],t[g]);\n      if(m.find(t)==m.end()){\n        m[t]=m[u]+1;\n        q.push(t);\n      }\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst char rd[4]={'u','d','l','r'};\nstruct gg{\n\tint mp[9];\n\tint space;\n\tstring path;\n\tbool operator<(const gg &tmp)const\n\t{\n\t\tfor(int i=0;i<=8;i++)\n\t\t   {\n\t\t   \tif(mp[i]!=tmp.mp[i])return mp[i]>tmp.mp[i];\n\t\t   }\n\t\treturn false;   \n\t}\n};\nbool ifok(gg a)\n{\n\tfor(int i=0;i<8;i++)\n\t  if(a.mp[i]!=i+1)return false;\n\treturn true;  \n}\ngg bfs(gg bg)\n{\n\tqueue<gg> q;gg now,tmp;int x,y;\n\tmap<gg,bool>vis;\n\tvis[bg]=1;\n\tq.push(bg);\n\twhile(!q.empty())\n\t{   \n\t\tnow=q.front();q.pop();\n\t\tif(ifok(now))return now;\n\t\tx=now.space%3;y=now.space/3;\n\t\tfor(int i=0;i<=3;i++)\n\t\t   {\n\t\t     tmp=now;\n\t\t     if(x+dx[i]<0||x+dx[i]>2||y+dy[i]<0||y+dy[i]>2)continue;\n\t\t     tmp.space=x+dx[i]+(y+dy[i])*3;\n\t\t     swap(tmp.mp[x+y*3],tmp.mp[x+dx[i]+(y+dy[i])*3]);\n\t\t     tmp.path+=rd[i];\n\t\t     if(vis[tmp])continue;\n\t\t     vis[tmp]=1;q.push(tmp);\n\t\t   }\n\t}\t\n}\nint main()\n{\n\tgg bg,ans;\n\tfor(int i=0;i<=8;i++)\n\t   {\n\t   \tscanf(\"%d\",&bg.mp[i]);\n\t   \tif(bg.mp[i]==0)bg.space=i;\n\t   }   \n\tbg.path=\"\";\n\tans=bfs(bg);\n\tcout<<ans.path.length()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,vector<int>> P;\n\nint main(){\n\tmap<vector<int>,int> dist;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\n\tvector<int> start(9),end = {1,2,3,4,5,6,7,8,0};\n\tfor(int i=0; i<9; i++) cin>>start[i];\n\t\n\tdist[start] = 0;\n\tq.push(P(0,start));\n\t\n\tfor(;q.size();){\n\t\tint cost = q.top().first;\n\t\tvector<int> now = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif(now==end){\n\t\t\tcout<<cost<<endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvector<vector<int>> next;\n\t\tint z = find(now.begin(), now.end(), 0) - now.begin();\n\t\tif(z > 2){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z-3]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\tif(z < 6){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z+3]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\tif(z % 3 > 0){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z-1]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\tif(z % 3 < 2){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z+1]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\t\n\t\tfor(auto n : next){\n\t\t\tif(dist.find(n) == dist.end() || 1+cost < dist[n]){\n\t\t\t\tq.push(P(dist[n]=1+cost, n));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * I used # 1687007 as a refference. Thx. \n */\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\n//const int PATTERN = 181440;     // 9! / 2;\nconst int PATTERN = 362880;     // 9! / 2;\nconst int FORWARD  = 1;\nconst int BACKWARD = -1;\nconst Board GOAL = 0x123456780LL;\nconst int DX[] = { -1, 0, 1,  0 },\n          DY[] = {  0, 1, 0, -1 };\n\nint history[PATTERN];\nqueue<Board> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, Board board) {\n//    printf(\"change_number(board) = %d\\n\", change_number(board));\n    int direction = history[change_number(board)];\n    swap(numpos, spacepos, board);\n    int pos = change_number(board);\n    if (history[pos] == 0) {\n        q.push(board);\n        history[pos] = direction + (direction > 0 ? 1 : -1);\n    }\n    else if ((history[pos] > 0 && direction < 0)\n          || (history[pos] < 0 && direction > 0)) {\n        return abs(history[pos]) + abs(direction) - 1;\n    }\n    return 0;\n}\n\nvoid print(Board b) {\n    for (int i = N - 1; i >= 0; --i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = N - 1, num; i >= 0; --i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i * 4);\n    }\n//    print(board);\n//    print(GOAL);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    history[change_number(board)] = FORWARD;\n    history[change_number(GOAL)]  = BACKWARD;\n\n    q.push(board);\n    q.push(GOAL);\n    while (!q.empty()) {\n        board = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N)\n            if (((board >> (pos * 4)) & 0xF) == 0)\n                break;\n\n        int zx = pos % 3, zy = pos / 3;\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + DX[i], ny = zy + DY[i];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n                continue;\n            int npos = nx + ny * 3;\n//            printf(\"npos = %d\\n\", npos);\n            assert(pos >= 0 && pos < N);\n            assert(npos >= 0 && npos < N);\n            if ((count = swap_and_check(npos, pos, board)))\n                goto END;\n        }\n//        printf(\"\\n\");\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; ++i){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n\n    for(int r = 0; r < 4; ++r){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for(int i = 0; i < N2; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem Description: 8 Puzzle\n * Category: Heuristic Search\n * Author: Khan\n * Date: 22th October, 2017\n */\n\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const\n    {\n        for (int i = 0; i < N2; ++i)\n        {\n            if(f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; ++i)\n        if(p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty())\n    {\n        u = Q.front(); Q.pop();\n        if(isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; ++r)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(int argc, char const *argv[])\n{\n    //freopen(\"sample.txt\", \"r\", stdin);\n    Puzzle in;\n\n    for (int i = 0; i < N2; ++i)\n    {\n        cin >> in.f[i];\n        if(in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    // goal\n    int final[N][N] =\n            {\n                    {1, 2, 3},\n                    {4, 5, 6},\n                    {7, 8, 0}\n            };\n\n    solve(initial, x, y, final);\n    cout << path - 1;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\nint i,j;\n//?Â§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nmap<int, int> book;\n\nint a[5][5];\nint nx[4][2] = { 0,1,1,0,0,-1,-1,0 };\n\nstruct node\n{\n\tint x, y, step;\n\tint aa[5][5];\n};\n\nnode getnode(int x, int y, int step, int aa[5][5])\n{\n\tnode q;\n\tq.x = x;\n\tq.y = y;\n\tq.step = step;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tq.aa[i][j] = aa[i][j];\n\t\t}\n\t}\n\treturn q;\n}\n\nvoid bfs(int x, int y, int step, int aa[5][5])\n{\n\tqueue<node> q;\n\tnode p;\n\tq.push(getnode(x, y, step, aa));\n\twhile (!q.empty())\n\t{\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint tx = q.front().x + nx[i][0];\n\t\t\tint ty = q.front().y + nx[i][1];\n\t\t\tif (tx >= 0 && tx < 3 && ty >= 0 && ty < 3)\n\t\t\t{\n\t\t\t\t//memcpy(p.aa,q.front().aa,sizeof(q.front().aa));\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tp.aa[i][j] = q.front().aa[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//\t\t\t\tprintf(\"******\\n\");\n\t\t\t\t//\t\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\t//\t\t\t\t{\n\t\t\t\t//\t\t\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\t//\t\t\t\t\t{\n\t\t\t\t//\t\t\t\t\t\tprintf(\"%d \",p.aa[i][j]);\n\t\t\t\t//\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t//\t\t\t\t}\n\t\t\t\tswap(p.aa[q.front().x][q.front().y], p.aa[tx][ty]);\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum = sum * 10 + p.aa[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\t\t\t\tprintf(\"sum===%d\\n\",sum);\n\n\n\t\t\t\tif (sum == 123456780)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\", q.front().step + 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\n\t\t\t\tif (!book[sum])\n\t\t\t\t{\n\t\t\t\t\tbook[sum] = 1;\n\t\t\t\t\tq.push(getnode(tx, ty, q.front().step + 1, p.aa));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%d%d\", &a[0][0], &a[0][1], &a[0][2]))\n\t{\n\t\tfor (int i = 1; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tint sum = 0, x1, y1;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tsum = sum * 10 + a[i][j];\n\t\t\t\tif (a[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\tx1 = i;\n\t\t\t\t\ty1 = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sum == 123456780)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tbook.clear();\n\t\tbook[sum] = 1;\n\t\tbfs(x1, y1, 0, a);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N1 9\n\nstruct P{\n    int f[N1];\n    int space;\n    string path;\n\n    bool operator < (const P &p) const{\n        for(int i = 0; i < N1; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n    return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\n\nint isT(P p){\n    for(int i = 0; i < N1; i++){\n        if(p.f[i] != (i + 1)) return 0;\n    }\n    return 1;\n}\n\nstring bfs(P s){\n    queue<P> Q;\n    map<P, bool> V;\n    P u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        if(isT(u) == 1) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    P in;\n\n    for(int i = 0; i < N1; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N1;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (ll)n; ++i)\nll dx[4] = { 0, 1, 0, -1 };\nll dy[4] = { 1, 0, -1, 0 };\nstatic const int N = 3;\nstatic const int N2 = 9;\nstatic const char dir[4] = { 'u', 'r', 'd', 'l' };\n\nstruct Puzzle {\n    int f[N2]; // f[i] = i+1ã¨ãªã£ã¦ããã¨ãã«ç­ã\n    int space; // 0ãããå ´æã®æ·»å­\n    string path; // ç§»åãæå­åã§ç®¡çãã¦ãã\n    bool operator<(const Puzzle& p) const\n    {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) {\n                continue;\n            }\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n// ãã®ããºã«ãç­ãã§ããã¨ã\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q; // ããºã«ãã­ã¥ã¼ã«å¥ãã(æ·±ãå¹åªåãªã®ã§)\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true; // å¥åã®ååãtrue(æ¢ç´¢æ¸ã¿)ã«ãã\n\n    while (!Q.empty()) {\n        u = Q.front(); // ä¸çªæåã«å¥ããã­ã¥ã¼ã®ä¸­èº«ãã»ãã\n        Q.pop();\n        if (isTarget(u)) { //ããã¿ã¼ã²ãããªãç§»åã®é åºãè¿ã\n            return u.path;\n        }\n        // ã¹ãã¼ã¹ã®ããä½ç½®ã¯(sx, sy)\n        int sx = u.space / N;\n        int sy = u.space % N;\n\n        rep(r, 4)\n        {\n            // ã¹ãã¼ã¹ã®ç§»ååã®å ´æã(tx, ty)\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            // ããæ ã®å¤ã«ç§»åãã¦ãããç¡è¦\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            // u: ç§»ååã®ç¤, v: ç§»åå¾ã®ç¤\n            v = u;\n            // ã³ããäº¤æ\n            v.space = tx * N + ty; // æ°ããã¹ãã¼ã¹ã®ç½®ãå ´æ\n            swap(v.f[u.space], v.f[v.space]);\n            if (!V[v]) {\n                V[v] = true; // vãæ¢ç´¢æ¸ã¿ã«ãã\n                v.path += dir[r]; // çµè·¯ãè¿½å ãã\n                Q.push(v); // æ¢ç´¢æ¸ã¿ã®çµè·¯ãQã«è¿½å ãã\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2; // ã¹ãã¼ã¹ã9ã¨ãã¦æ±ã\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost();\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 ||tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  printf(\"%d\\n\",ans.size());\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n \nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n \nint main() {\n  Puzzle in;\n \n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.f[i]=N2;\n      in.space = i;\n    }\n  }\n \n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isT(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isT(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n       int ty=sy+dy[r];\n       if(tx<0||ty<0||tx>=N||ty>=N) continue;\n       v=u;\n       swap(v.f[u.space],v.f[tx*N+ty]);\n       v.space=tx*N+ty;\n       if(!V[v]){\n         V[v]=true;\n         v.path+=dir[r];\n         Q.push(v);\n\n       }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nvector<int> board( 9 );\nset< vector<int> > reachedState;\n\nvoid PrintBoard() {\n    for ( int row=0; row<3; ++row ) {\n\tfor ( int col=0; col<3; ++col ) cout << board[row*3+col];\n\tcout << endl;\n    }\n}\n\nbool IsReachedState( const vector<int>& b ) {\n    return reachedState.find( b ) != reachedState.end();\n}\n\nvoid RegisterState( const vector<int>& b ) {\n    reachedState.insert( b );\n}\n\nbool IsCompleted( const vector<int>& b ) {\n    for ( int i=0; i<8; ++i ) {\n\tif ( b[i] != i+1 ) return false;\n    }\n    return b[8] == 0;\n}\n\nint main() {\n\n    const int dx[4] = { -1, 0, 1,  0 };\n    const int dy[4] = {  0, 1, 0, -1 };\n    \n    int x, y;\n    for ( int i=0; i<3; ++i ) {\n\tfor ( int j=0; j<3; ++j ) {\n\t    cin >> board[i*3+j];\n\t    if ( board[i*3+j] == 0 ) {\n\t\ty = i;\n\t\tx = j;\n\t    }\n\t}\n    }\n\n    //    PrintBoard();\n\n    queue< pair<vector<int>,int> > stateQue;\n    stateQue.push( make_pair(board, 0) );\n\n    while ( !stateQue.empty() ) {\n\n\tvector<int> state = stateQue.front().first;\n\tint step = stateQue.front().second;\n\tstateQue.pop();\n\n\tif ( IsCompleted( state ) ) {\n\t    cout << step << endl;\n\t    board = state;\n\t    //\t    PrintBoard();\n\t    break;\n\t}\n\n\tif ( IsReachedState( state ) ) continue;\n\tRegisterState( state );\n\n\tint x, y;\n\tfor ( int i=0; i<9; ++i ) {\n\t    if ( state[i] == 0 ) {\n\t\tx = i%3;\n\t\ty = i/3;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tfor ( int i=0; i<4; ++i ) {\n\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\n\t    if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue;\n\n\t    vector<int> next = state;\n\t    swap( next[3*y+x], next[3*ny+nx] );\n\t    stateQue.push( make_pair( next, step+1 ) );\n\t    \n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth, int dir) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        if (dir != -1 && k == (dir + 2) % 4) {\n            continue;\n        }\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1, k);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    if (check(b)) {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (int i = 1; i <= 45; i++) {\n        int ret = dfs(b, i, -1);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst char rd[4]={'u','d','l','r'};\nstruct gg{\n\tint mp[9];\n\tint space;\n\tstring path;\n\tbool operator<(const gg &tmp)const\n\t{\n\t\tfor(int i=0;i<=8;i++)\n\t\t   {\n\t\t   \tif(mp[i]!=tmp.mp[i])return mp[i]>tmp.mp[i];\n\t\t   }\n\t\treturn false;   \n\t}\n};\nbool ifok(gg a)\n{\n\tfor(int i=0;i<8;i++)\n\t  if(a.mp[i]!=i+1)return false;\n\treturn true;  \n}\ngg bfs(gg bg)\n{\n\tqueue<gg> q;gg now,tmp;int x,y;\n\tmap<gg,bool>vis;\n\tvis[bg]=1;\n\tq.push(bg);\n\twhile(!q.empty())\n\t{   \n\t\tnow=q.front();q.pop();\n\t\tif(ifok(now))return now;\n\t\tx=now.space%3;y=now.space/3;\n\t\tfor(int i=0;i<=3;i++)\n\t\t   {\n\t\t     tmp=now;\n\t\t     if(x+dx[i]<0||x+dx[i]>2||y+dy[i]<0||y+dy[i]>2)continue;\n\t\t     tmp.space=x+dx[i]+(y+dy[i])*3;\n\t\t     swap(tmp.mp[x+y*3],tmp.mp[x+dx[i]+(y+dy[i])*3]);\n\t\t     tmp.path+=rd[i];\n\t\t     if(vis[tmp])continue;\n\t\t     vis[tmp]=1;q.push(tmp);\n\t\t   }\n\t}\t\n}\nint main()\n{\n\tgg bg,ans;\n\tfor(int i=0;i<=8;i++)\n\t   {\n\t   \tscanf(\"%d\",&bg.mp[i]);\n\t   \tif(bg.mp[i]==0)bg.space=i;\n\t   }   \n\tbg.path=\"\";\n\tans=bfs(bg);\n\tcout<<ans.path.length();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\nclass Board {\npublic:\n  int board[3][3];\n  Board() {}\n  Board(int b[3][3]) {\n    REP(i, 3) {\n      REP(j, 3) {\n        board[i][j] = b[i][j];\n      }\n    }\n  }\n\n  int hash() {\n    int accum = 0;\n    int digit = 1;\n    REP(i, 3) {\n      REP(j, 3) {\n        accum += board[i][j] * digit;\n        digit *= 10;\n      }\n    }\n    return accum;\n  }\n  string to_str() {\n    string str = \"\";\n    REP(i, 3) {\n      REP(j, 3) {\n        str += \" \" + to_string(board[i][j]);\n      }\n      str += \"\\n\";\n    }\n    return str;\n  }\n  bool operator==( const Board& other) {\n    REP(i, 3) {\n      REP(j, 3) {\n        if (board[i][j] != other.board[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n};\n\nclass Nully;\nstatic Board Nully;\n\nBoard swap_with_upper(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i - 1][pos_j]);\n  return next;\n}\nBoard swap_with_lower(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i + 1][pos_j]);\n  return next;\n}\nBoard swap_with_left(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j - 1]);\n  return next;\n}\nBoard swap_with_right(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j + 1]);\n  return next;\n}\n\nint main() {\n  // int b[3][3] = {{1, 3, 0}, {4, 2, 5}, {7, 8, 6}};\n  int b[3][3];\n  REP(i, 3) {\n    REP(j, 3) {\n      cin >> b[i][j];\n    }\n  }\n\n  int g[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n  Board init(b);\n  Board goal(g);\n  // cout << init.to_str() << endl;\n\n  int depth = 0;\n  queue<pair<Board, int> > Q;\n  Q.push(make_pair(init, depth));\n\n  while (!Q.empty()) {\n    Board current = Q.front().first;\n    Board next;\n    int dpt = Q.front().second;\n    Q.pop();\n\n    if (goal == current) {\n      cout << dpt << endl;\n      return 0;\n    }\n\n    next = swap_with_upper(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_lower(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_left(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_right(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front();\n    Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_D 3\n#define MAX_N 9\n#define MAX_C 362880\nint fact1[MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][2];\nvector<int> fact2[MAX_C]; int MAP[MAX_D][MAX_D]; int DP[MAX_C], K;\nvoid FACT() {\n\tint a[MAX_N]; for (int i = 0; i < MAX_N; i++) { a[i] = i; }int cnt = 0;\n\tdo {\n\t\tif (a[MAX_N - 2] < a[MAX_N - 1]) { fact1[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][0] = cnt; }\n\t\telse { fact1[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][1] = cnt; }\n\t\tvector<int>vec; for (int i = 0; i < MAX_N; i++) { vec.push_back(a[i]); }fact2[cnt] = vec; cnt++;\n\t} while (next_permutation(a, a + MAX_N));\n}\nint main() {\n\tfor (int i = 0; i < MAX_D; i++) {\n\t\tfor (int j = 0; j < MAX_D; j++) { cin >> MAP[i][j]; }\n\t}FACT(); for (int i = 0; i < MAX_C; i++) { DP[i] = MAX_C; }\n\tint T = fact1[1][2][3][4][5][6][7][1];\n\tif (MAP[2][1] < MAP[2][2]) { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][0]; }\n\telse { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][1]; }DP[K] = 0;\n\twhile (DP[T] == MAX_C) {\n\t\tfor (int i = 0; i < MAX_C; i++) {\n\t\t\tif (DP[i] >= MAX_C) { continue; }vector<int>X = fact2[i]; int y[MAX_D][MAX_D], z[MAX_D][MAX_D], cx, cy; int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int j = 0; j < X.size(); j++) { y[j / 3][j % 3] = X[j]; if (X[j] == 0) { cx = j / 3; cy = j % 3; } }\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) { z[k / 3][k % 3] = y[k / 3][k % 3]; }int ex = cx + dx[j], ey = cy + dy[j];\n\t\t\t\tif (ex >= 3 || ex <= -1 || ey >= 3 || ey <= -1) { continue; } swap(z[cx][cy], z[ex][ey]);\n\t\t\t\tif (z[2][1] < z[2][2]) { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][0]; }\n\t\t\t\telse { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][1]; }DP[K] = min(DP[K], DP[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#define N 9\n#define n 3\n#define Blank 0\n#define up -N/n\n#define down N/n\n#define left -1\n#define right 1\n#define limit 34\nusing namespace std;\nstruct p{\n  int v[N];\n  int blankPlace;\n  int g=0;\n  int h=0;\n  bool operator < (const p& pazzle) const {\n    for(int i=0;i<N;i++){\n      if(v[i] == pazzle.v[i]) continue;\n      return v[i]<pazzle.v[i];\n    }\n    return false;\n  }\n};\npriority_queue <p, vector<p>, greater<p> > pazzle;\nmap <p,bool> existPazzle;\nbool operator > (const p a,const p b){return a.h+a.g>b.h+b.g;};\n\nint calculate_h(p this_pazzle,int i){\n  if(i == this_pazzle.blankPlace ) return abs(i/n-(N-1)/n)+abs(i%n-(N-1)/n);\n  else return abs(i/n-(this_pazzle.v[i]-1)/n)+abs(i%n-(this_pazzle.v[i]-1)%n);\n}\n\np checkPazzle(p thisPazzle){\n  thisPazzle.h = 0;\n    for(int i=0;i<N;i++)\n      thisPazzle.h += calculate_h(thisPazzle,i);\n  return thisPazzle;\n}\n\nvoid moveBlank(p thisPazzle,int move){\n  int moved = thisPazzle.blankPlace + move;\n  thisPazzle.g++;\n  //cout<<\"g: \"<<thisPazzle.g<<\" moved: \"<<moved<<endl;\n  swap(thisPazzle.v[thisPazzle.blankPlace],thisPazzle.v[moved]);\n  if(existPazzle[thisPazzle])return;\n  thisPazzle.blankPlace = moved;\n  thisPazzle = checkPazzle(thisPazzle);\n  if(thisPazzle.g+thisPazzle.h>limit)return;\n  pazzle.push(thisPazzle);\n}\n\nvoid movePazzle(p thisPazzle){\n  if(thisPazzle.blankPlace+up>=0)\n    moveBlank(thisPazzle,up);\n  if(thisPazzle.blankPlace+down<9)\n    moveBlank(thisPazzle,down);\n  if(thisPazzle.blankPlace + left >= 0&&thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+left)/3)\n    moveBlank(thisPazzle,left);\n  if(thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+right)/3)\n    moveBlank(thisPazzle,right);\n}\n\np dfs(){\n  p tmp,thisPazzle;\n  tmp.g = -1;\n  while(!pazzle.empty()){\n    thisPazzle = pazzle.top();\n    pazzle.pop();\n    existPazzle[thisPazzle]=true;\n    if(!thisPazzle.h)return thisPazzle;\n    movePazzle(thisPazzle);\n  }\n  return tmp;\n}\n\nint main(){\n  p thisPazzle;\n  for(int i=0;i<N;i++){\n    cin>>thisPazzle.v[i];\n    if(thisPazzle.v[i]==Blank)thisPazzle.blankPlace=i;\n  }\n  thisPazzle = checkPazzle(thisPazzle);\n  pazzle.push(thisPazzle);\n  thisPazzle = dfs();\n  cout<<thisPazzle.g<<endl;\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair< int, vector<int> > Q;\n\n#define MAX 100005\n#define INF 1001001001\n\nint main(int, char**)\n{\n    vector<int> b(9);\n    rep(i,9) { cin >> b[i]; b[i]--; }\n\n    map< vector<int>, bool > close;\n    map< vector<int>, int > h;\n    priority_queue< Q, vector<Q>, greater<Q> > q;\n\n    auto heu = [&](vector<int> v) -> int {\n        if (h.count(v)) return h[v];\n        int dif = 0;\n        rep(i,9) {\n            if (v[i] == -1) continue;\n            dif += abs(v[i]/3 - i/3) + abs(v[i]%3 - i%3); // åããã«ã®ç®çå°ã¾ã§ã®ãã³ããã¿ã³è·é¢ã®ç·å\n        }\n        h[v] = dif;\n        return dif;\n    };\n\n    q.push({heu(b), b});\n    int ans;\n    while (!q.empty()) {\n        vector<int> b;\n        int f;\n        tie(f,b) = q.top(); q.pop();\n        if (h[b]==0) {\n            ans = f;\n            break;\n        }\n        close[b] = true;\n \n        int g = f - h[b];\n\n        int r, c;\n        rep(i,9) {\n            if (b[i] == -1) {\n                r = i/3;\n                c = i%3;\n                break;\n            }\n        }\n        int dr[4] = { -1,  0,  1,  0};\n        int dc[4] = {  0, -1,  0,  1};\n        rep(i,4) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if (nr < 0 || nr >= 3 || nc < 0 || nc >= 3) continue;\n            vector<int> nb = b;\n            swap(nb[nr*3+nc], nb[r*3+c]);\n            if (!close[nb]) {\n                q.push({g+1+heu(nb), nb});\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 8ããºã«\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n//const int PUZZLE_NUM = 9;\n\n// ããã«ã®ç§»åæ¹åã®å®ç¾©\nconst int LOW = 1;\nconst int UP = 2;\nconst int LEFT = 3;\nconst int RIGHT = 4;\n\n// ç®æ¨ã®ç¶æ ( 0x12345678 ã 10 é²æ°ã«å¤æããå¤ )\nint Target = 305419896;\n\nconst int PANEL_NUM = 8;\n// 1 ã 8 ã¾ã§ã®å\nconst int ALL_SUM = 36;\n\n// ä¸¦ã³æ¿ãã®ç¶æãæ ¼ç´ããã­ã¥ã¼\n// ç¬¬1è¦ç´  : æ¤ç´¢ããæ°å¤, ç¬¬2è¦ç´  : ä¸¦ã³æ¿ããåæ°\nqueue<pair<int, int>> q_P;\n// æ¢ç´¢æ¸ã¿ã®ããã«ã®ç¶æãæ ¼ç´ãã¦ããããã\nmap<int, bool> Map_V;\n\n// -------------------------------\n// ããºã«ã®ããã«ãæä½ããããã®ã¯ã©ã¹\n// -------------------------------\nclass PuzzleOperation\n{\n\n    public:\n\n        // ããã«ã®ä¸¦ã³ã16é²æ°ã«å¤æãã¦æ ¼ç´ããå¤æ°\n        int panel;\n        // ããã«åã®ã¼ã­ã®ä½ç½®\n        int zeroPos;\n        // panel ãåè§£ããç¶æãä¿æããéå\n        //int ary_panel[PANEL_NUM];\n        // 8 åã®ããã«ã«å¥ã£ã¦ããªãæ°\n        int remainNum;\n        // ä¸¦ã³æ¿ãã®åæ°\n        int sortNum;\n\n    // ã³ã³ã¹ãã©ã¯ã¿\n    PuzzleOperation()\n    {\n        panel = 0;\n        zeroPos = 0;\n        remainNum = 0;\n        sortNum = 0;\n    }\n\n    // ã³ãã¼ã³ã³ã¹ãã©ã¯ã¿\n    PuzzleOperation(const PuzzleOperation& p)\n    {\n        panel = p.panel;\n        zeroPos = p.zeroPos;\n        remainNum = p.remainNum;\n        sortNum = p.sortNum;\n\n        //cout << \"ã³ãã¼ã³ã³ã¹ãã©ã¯ã¿ãå¼ã°ãã¾ãã\" << endl;\n    }\n\n    // ãã¹ãã©ã¯ã¿\n    ~PuzzleOperation()\n    {\n        //cout << \"ãã¹ãã©ã¯ã¿ãå¼ã°ãã¾ãã\" << endl;\n    }\n\n    // --------------------------------------------------\n    // map ã®ã­ã¼ã§ãã PuzzleOperation ã¯ã©ã¹ãã­ã¼é ã«ä¸¦ã¹ãããã®å®ç¾©\n    // --------------------------------------------------\n    bool operator < (const PuzzleOperation &p ) const\n    {\n\n        if( panel > p.panel )\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    // ã´ã¼ã«ã«å°éããããå¤å®ããé¢æ°\n    bool reachGoal(int p)\n    {\n        if( p != Target )\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    // panel ã«è¨­å®ãããæ°å¤ããæ­£è§£ãæ±ãã\n    // è¨ç®å¤ : num ã®ä¸­ã§ 4bit ãã¼ã­ã¨ãªã£ã¦ããä½ç½® ( zeroPos )\n    //       : 8åã®éåè¦ç´ ã«å«ã¾ãã¦ããªãæ° ( remainNum )\n    // æ»ãå¤ : ä¸¦ã³æ¿ãã®åæ°\n    bool panelMove()\n    {\n        int x, y;\n        bool retX = false, retY = false;\n\n        int tmp = panel;\n        int bitNum;\n\n        // æåã« 1 ã 8 ã¾ã§ã®åãå¥ãã¦ããã¦, ä¸è¶³ãã¦ããæ°ãæ±ãã\n        remainNum = ALL_SUM;\n        // éåã® 9 çªç®ã«ã¼ã­ãå­å¨ãããã¨ãèæ®ãã¦ãã\n        // ( è¦ç´ æ°ã¨ãã¦ã¯, 8 çªç® )\n        zeroPos = 8;\n\n        for(int i = PANEL_NUM - 1; i >= 0; i--)\n        {\n            bitNum = tmp & 0xF;\n            // éåã® 8 è¦ç´ ã«å¥ã£ã¦ãªãå¤ãæ±ãã\n            remainNum -= bitNum;\n\n            if( bitNum == 0 )\n            {\n                // ã¼ã­ä½ç½®ã®è¨­å®\n                zeroPos = i;\n            }\n\n            tmp = tmp >> 4;\n        }\n\n        // ã¼ã­ã®ä½ç½®ãã x, y åº§æ¨ã«å¤æãã\n        x = zeroPos / 3;\n        y = zeroPos % 3;\n\n        // -----------------\n        // ããã«ãç§»åããã\n        // -----------------\n        retX = moveX(x, y);\n        retY = moveY(x, y);\n\n        if( retX == true || retY == true )\n        {\n            // ããã«ãç®æ¨ã®ç¶æã«å°éãã\n            return true;\n        }\n\n        return false;\n    }\n\n    // æå®ä½ç½®ã®ããã«ã¨ã¼ã­ä½ç½®ã®ããã«ã®å¥ãæ¿ãæä½ãããå¦ç\n    bool panelReplacement(int movePos)\n    {\n\n        bool ret = false;\n        int movePanel, moveNum, sortCount;\n\n        // ç§»åæä½ã¯ã³ãã¼ãããã®ã§å®æ½ãã\n        movePanel = panel;\n        sortCount = sortNum;\n        moveNum = 0;\n\n        if( movePos < PANEL_NUM )\n        {\n            // -------------------------\n            // 8 ä»¥åãªããã®ã¾ã¾å¥ãæ¿ãã\n            // -------------------------\n\n            // ç§»åããå¤ã¾ã§, 4ãããåä½ã§ãããã·ãããã\n            moveNum = movePanel >> ( 4 * ( ( PANEL_NUM - 1 ) - movePos ) );\n            // ç§»åããå¤ãæãåºã\n            moveNum = moveNum & 0xF;\n        }\n        else\n        {\n            // 9 åç®ã®è¦ç´ ãªã, remainNum ãå¥ãã¦ãã\n            moveNum = remainNum;\n        }\n\n        // -----â¼â¼â¼ ã¼ã­ã®ä½ç½®ã«ç§»åããå¤ãå¥ããå¦çãâ¼â¼â¼-----\n\n        if( zeroPos != 8 )\n        {\n            // éåè¦ç´ ã® 8 çªç®ã«ã¼ã­ããã£ãå ´åã¯éåã®åå¤ã«ãªãã®ã§ä½ãããªã\n\n            // ç§»åããå¤ã, ç§»åããä½ç½®ã¾ã§, 4ãããåä½ã§ãããã·ãããã\n            moveNum = moveNum << ( 4 * ( ( PANEL_NUM - 1 ) - zeroPos ) );\n            // ç§»åããå¤ãã¼ã­ã®ä½ç½®ã«å¥ãã\n            movePanel = movePanel | moveNum;\n        }\n\n        // -----â²â²â² ã¼ã­ã®ä½ç½®ã«ç§»åããå¤ãå¥ããå¦çãâ²â²â²-----\n\n        // -----â¼â¼â¼ ç§»åãããç®æãã¼ã­ã«è½ã¨ãå¦çãâ¼â¼â¼-----\n\n        if( movePos < PANEL_NUM )\n        {\n            int zeroNum = 0xF;\n\n            // ã¼ã­ã®å¥ãä½ç½®ã¾ã§, 4ãããåä½ã§ãããã·ãããã\n            zeroNum = zeroNum << ( 4 * ( ( PANEL_NUM - 1 ) - movePos ) );\n            // ãããåè»¢ãã\n            zeroNum = ~zeroNum;\n            // ã¼ã­ãè¨­å®ãã\n            movePanel = movePanel & zeroNum;\n        }\n\n        // -----â²â²â² ç§»åãããç®æãã¼ã­ã«è½ã¨ãå¦çãâ²â²â²-----\n\n        // éåããæ°å¤ã¸çµ±åãã\n        //copy.numIntegration();\n\n        // å¥ãæ¿ãåæ°ãã¤ã³ã¯ãªã¡ã³ããã\n        sortCount++;\n\n        if( reachGoal(movePanel) == false )\n        {\n            // ä¸¦ã³æ¿ãããã®ãã­ã¥ã¼ã«å¥ãç´ã\n            if( searchPanelStatus(movePanel) == true )\n            {\n                // æªæ¤ç´¢ã®æ°å¤ã®ã¿ã­ã¥ã¼ã«ããã·ã¥ãã\n                q_P.push(make_pair(movePanel, sortCount));\n            }\n        }\n        else\n        {\n            ret = true;\n        }\n\n        return ret;\n    }\n\n    // ------------------\n    // x æ¹åã®ããã«ãç§»å\n    // ------------------\n    // x : ããã«ä½ç½®ã® x åº§æ¨\n    // y : ããã«ä½ç½®ã® y åº§æ¨\n    // æ»ãå¤ : true - ç®æ¨å°é, false : ç®æ¨ã«å°éãã¦ããªã\n    bool moveX(int x, int y)\n    {\n        bool ret = false;\n\n        // é¢æ°ã³ã¼ã«å¾ã® x ã¯å¤ãå¤ããã®ã§åã®å¤ãè¦ãã¦ãã\n        int nowX = x;\n\n        switch (x)\n        {\n            case 0:\n                // ä¸ã®ããã«ã¨äº¤æ\n                panelShift_X(LOW, x);\n                ret = panelSwap(x, y);\n                break;\n\n            case 1:\n\n                // ä¸ã®ããã«ã¨äº¤æ\n                panelShift_X(UP, x);\n                ret = panelSwap(x, y);\n\n                if( ret == false )\n                {\n                    x = nowX;\n\n                    // ä¸ã®ããã«ã¨äº¤æ\n                    panelShift_X(LOW, x);\n                    ret = panelSwap(x, y);\n                }\n\n                break;\n\n            case 2:\n                // ä¸ã®ããã«ã¨äº¤æ\n                panelShift_X(UP, x);\n                ret = panelSwap(x, y);\n\n                break;\n        }\n\n        return ret;\n    }\n\n    // ------------------\n    // y æ¹åã®ããã«ãç§»å\n    // ------------------\n    // puz : ããã«ã®ç¶æãä¿æããéå\n    // x : ããã«ä½ç½®ã® x åº§æ¨\n    // y : ããã«ä½ç½®ã® y åº§æ¨\n    // æ»ãå¤ : true - ç®æ¨å°é, false : ç®æ¨ã«å°éãã¦ããªã\n    bool moveY(int x, int y)\n    {\n        bool ret = false;\n\n        // é¢æ°ã³ã¼ã«å¾ã® y ã¯å¤ãå¤ããã®ã§åã®å¤ãè¦ãã¦ãã\n        int nowY = y;\n\n        switch (y)\n        {\n            case 0:\n                // å³ã®ããã«ã¨äº¤æ\n                panelShift_Y(RIGHT, y);\n                ret = panelSwap(x, y);\n                break;\n\n            case 1:\n\n                // å·¦ã®ããã«ã¨äº¤æ\n                panelShift_Y(LEFT, y);\n                ret = panelSwap(x, y);\n\n                if( ret == false )\n                {\n                    y = nowY;\n\n                    // å³ã®ããã«ã¨äº¤æ\n                    panelShift_Y(RIGHT, y);\n                    ret = panelSwap(x, y);\n                }\n\n                break;\n\n            case 2:\n                // å·¦ã®ããã«ã¨äº¤æ\n                panelShift_Y(LEFT, y);\n                ret = panelSwap(x, y);\n\n                break;\n        }\n\n        return ret;\n    }\n\n    // -------------------------------------\n    // ç§»åå¾ã®ããã«ãç®æ¨ã«å°éãã¦ããããç¢ºèª\n    // -------------------------------------\n    // puz : ããã«ã®ç¶æãä¿æããéå\n    // x : ããã«ä½ç½®ã® x åº§æ¨\n    // y : ããã«ä½ç½®ã® y åº§æ¨\n    // æ»ãå¤ : true - ç®æ¨å°é, false : ç®æ¨ã«å°éãã¦ããªã\n    bool panelSwap(int x, int y)\n    {\n        bool ret = false;\n        int movePos;\n\n        // ç§»åãããåã«è¤è£½ãä½ã£ã¦ãã\n        //PuzzleOperation copy = puz;\n\n        // åº§æ¨ããéåã®è¦ç´ No.ã¸å¤æãã\n        movePos = calcArrayNum(x, y);\n        // æ°å¤ãå¥ãæ¿ãã\n        ret = panelReplacement(movePos);\n\n        return ret;\n    }\n\n    // x, y åº§æ¨ããéåã®è¦ç´ æ°ã¸å¤æããé¢æ°\n    int calcArrayNum(int x, int y)\n    {\n        return 3 * x + y;\n    }\n\n    // ããã«ã®ç§»åå¾ã® X åº§æ¨ãè¨ç®ããé¢æ°\n    void panelShift_X(int moveNum, int &x)\n    {\n        switch ( moveNum )\n        {\n            case UP:\n                x = x - 1;\n                break;\n\n            case LOW:\n                x = x + 1;\n                break;\n\n            default:\n                // x ããã®ã¾ã¾è¿ã\n                break;\n        }\n    }\n\n    // ããã«ã®ç§»åå¾ã® Y åº§æ¨ãè¨ç®ããé¢æ°\n    void panelShift_Y(int moveNum, int &y)\n    {\n        switch ( moveNum )\n        {\n            case LEFT:\n                y = y - 1;\n                break;\n\n            case RIGHT:\n                y = y + 1;\n                break;\n\n            default:\n            // y ããã®ã¾ã¾è¿ã\n                break;\n        }\n    }\n\n    // æ¤ç´¢ããããã«ã®ä¸¦ã³ãè¨æ¶ãã¦ãéå»ã®ããã«ç¶æã¨ã®æ¯è¼ããã\n    // puz   : æ´æ°å¤ã«ç½®ãæããããã«ã®ç¶æ\n    // æ»ãå¤ : true - æ°ãããã¿ã¼ã³, false : æ¤ç´¢æ¸ã¿ã®ãã¿ã¼ã³\n    bool searchPanelStatus(int p)\n    {\n        int ret = false;\n\n        if( !Map_V[p] )\n        {\n            // --- æå®å¤ãæªæ¤ç´¢ã®æ ---\n\n            // æ¤ç´¢æ¸ã¿ã§ãããã¨ãè¨æ¶ãã\n            Map_V[p] = true;\n            ret = true;\n        }\n\n        return ret;\n\n    }\n\n};\n\n// ----------------\n// 8ããºã«ãè§£ãé¢æ°\n// ----------------\n// æ»ãå¤ : ããã«ã®ç§»ååæ°\nint solveEightPuzzle()\n{\n    int count = 0;\n\n    while( !q_P.empty() )\n    {\n        pair<int, int> q_element;\n        PuzzleOperation puz;\n\n        q_element = q_P.front();\n        q_P.pop();\n\n        // ã­ã¥ã¼ããåãåºããå¤ãè¨­å®ãã\n        puz.panel = q_element.first;\n        puz.sortNum = q_element.second;\n\n        // æ´æ°å¤ããããã«ã®ä¸¦ã³ã¸ã¨åå²ãã\n        if( puz.panelMove() == true )\n        {\n            // puz ã®ç¶æã¯æ­£è§£ã®ä¸ã¤åã®ç¶æãªã®ã§, æçµçãªåæ°ã¨ãã¦1ãè¶³ãã¦ãã\n            count = puz.sortNum + 1;\n            break;\n        }\n    }\n\n    return count;\n}\n\nint main(void)\n{\n\n    int count = 0;\n    int panelCond = 0;\n\n    PuzzleOperation puz;\n\n    int ary_panel[PANEL_NUM];\n\n    // åæç¶æãè¨­å®ãã\n    for(int i = 0; i < PANEL_NUM; i++)\n    {\n        cin >> ary_panel[i];\n    }\n\n    // æ°å¤ã«å¤æãã\n    // 8åã®éåè¦ç´ ãã, panel ã«æ°å¤ãè¨­å®ãã\n    for(int i = 0; i < PANEL_NUM; i++)\n    {\n        // 4bit å·¦ã«ã·ãããã\n        panelCond = panelCond << 4;\n        // æ°å¤ã«å¤æãã\n        panelCond += ary_panel[i] & 0xF;\n    }\n\n    // åæç¶æã®è¨­å®\n    puz.panel = panelCond;\n    puz.sortNum = 0;\n\n    q_P.push(make_pair(puz.panel, 0));\n    puz.searchPanelStatus(puz.panel);\n\n    if( puz.reachGoal(panelCond) == false )\n    {\n        // æåã®å¥åãæ­£è§£ã§ç¡ããã°, æ¢ç´¢ãéå§ãã\n        count = solveEightPuzzle();\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 10\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\nint f[N2];\nint space;\nstring path;\nbool operator < (const Puzzle &p) const\n{\nfor(int i=0;i<N2;i++)\n{\nif(f[i]==p.f[i]) continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1)) return false;\nreturn true;\n}\n\nstring bfs(Puzzle s)\n{\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path= \"\";\nQ.push(s);\nV[s]=true;\n\nwhile(!Q.empty())\n{\nu=Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx=u.space/N;\nint sy=u.space%N;\nfor(int r=0;r<4;r++)\n{\nint tx=sx+dx[r];\nint ty=sy+dy[r];\nif(tx<0||ty<0||tx>=N||ty>=N) continue;\nv=u;\nswap(v.f[u.space],v.f[tx*N+ty]);\nv.space=tx*N+ty;\nif(!V[v])\n{\nV[v]=true;\nv.path+=dir[r];\nQ.push(v);\n\n}\n}\n}\nreturn \"unsolvable\";\n}\n\nint main()\n{\nPuzzle in;\n\nfor(int i=0;i<N2;i++)\n{\ncin >>in.f[i];\nif(in.f[i]==0)\n{\nin.f[i]=N2;\nin.space=i;\n}\n}\nstring ans=bfs(in);\ncout << ans.size()<<endl;\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\n\tarr b;\n\tpos p;\n\tint f, g, h;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tg = 0;\n\t\tf = h = hn(b);\n\t}\n\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tstatic int hn(const arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tif (!a[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\tint k = a[i][j] - 1;\n\t\t\t\tl += abs(i - k / size) + abs(j - k % size);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tstatic int key(const arr &a) {\n\t\tint k = 0;\n\t\tfor (auto &r: a)\n\t\t\tfor (int c: r)\n\t\t\t\tk = (k * 10) + c;\n\t\treturn k;\n\t}\n\n\tint solver() {\n\t\tstatic const pos to[] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\t\tunordered_set<int> m;\n\t\tpriority_queue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.top();\n\t\t\tq.pop();\n\t\t\tint k = key(a.b);\n\t\t\tif (m.count(k))\n\t\t\t\tcontinue;\n\t\t\tm.insert(k);\n\t\t\tif (!a.h)\n\t\t\t\treturn a.g;\n\t\t\tfor (pos o: to) {\n\t\t\t\to.r += a.p.r, o.c += a.p.c;\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.g += 1;\n\t\t\t\t\tc.h = hn(c.b);\n\t\t\t\t\tc.f = c.g + c.h;\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nbool operator < (const board &a, const board &b) {\n\treturn a.f > b.f;\n}\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {\n    -1, 0, 1, 0\n};\nstatic const int dy[4] = {\n    0, -1, 0, 1\n};\nstatic const char dir[4] = {\n    'u', 'l', 'd', 'r'\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tconst int MAX_N = 900000000;\n\tstd::vector<bool> visited(MAX_N);\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!eight_puzzle::visited[states[i].table]){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\teight_puzzle::visited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define EPS (1e-10)\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\n\nconstexpr int N = 3;\nconstexpr int N2 = 9;\nconstexpr int dx[4] = {0, -1, 0, 1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nstruct Puzzle {\n    int f[N2], z_pos, MD;\n    int depth;\n    bool operator<(const Puzzle& pz) const {\n        rep(i, 0, N2) {\n            if (f[i] == pz.f[i]) { continue; }\n            return f[i] < pz.f[i];\n        }\n        return false;\n    }\n};\n\nstruct State {\n    Puzzle pz;\n    int estimate;\n    bool operator<(const State& st) const { return estimate > st.estimate; }\n};\n\nvoid init_MD(vvi& MDT) {\n    rep(i, 0, N2) {\n        rep(j, 0, N2) { MDT[i][j] = abs(i / N - j / N) + abs(i % N - j % N); }\n    }\n}\n\nint get_md(const Puzzle& pz, const vvi& MDT) {\n    int sum = 0;\n    rep(i, 0, N2) {\n        if (pz.f[i] == N2) { continue; }\n        sum += MDT[i][pz.f[i] - 1];\n    }\n    return sum;\n}\n\nint astar(const Puzzle& pz, const vvi& MDT) {\n    State init;\n    init.pz = pz;\n    init.pz.depth = 0;\n    init.pz.MD = get_md(init.pz, MDT);\n    init.estimate = init.pz.MD;\n\n    priority_queue<State> PQ;\n    PQ.push(init);\n\n    map<Puzzle, bool> seen;\n\n    while (!PQ.empty()) {\n        State st = PQ.top();\n        PQ.pop();\n\n        if (st.pz.MD == 0) { return st.pz.depth; }\n        seen[st.pz] = true;\n\n        int sx = st.pz.z_pos % N;\n        int sy = st.pz.z_pos / N;\n\n        rep(i, 0, 4) {\n            int tx = sx + dx[i];\n            int ty = sy + dy[i];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) { continue; }\n\n            State next = st;\n            next.pz.MD -= MDT[ty * N + tx][next.pz.f[ty * N + tx] - 1];\n            next.pz.MD += MDT[sy * N + sx][next.pz.f[ty * N + tx] - 1];\n\n            swap(next.pz.f[sy * N + sx], next.pz.f[ty * N + tx]);\n            next.pz.z_pos = ty * N + tx;\n\n            if (!seen[next.pz]) {\n                ++next.pz.depth;\n                next.estimate = next.pz.depth + next.pz.MD;\n                PQ.push(next);\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    Puzzle pz;\n    rep(i, 0, N2) {\n        cin >> pz.f[i];\n        if (pz.f[i] == 0) {\n            pz.f[i] = N2;\n            pz.z_pos = i;\n        }\n    }\n\n    vvi MDT(N2, vi(N2));\n    init_MD(MDT);\n\n    cout << astar(pz, MDT) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(b1.num[zero1]!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(b2.num[zero2]!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n/*\nint heuristic_func2(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    Board b2 = decode(enc2);\n    for(int i=0;i<SIZE;i++){\n        int pos1 = 0;\n        int pos2 = 0;\n        while(zero1!=i)\n    }\n}\n*/\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func(start, goal), start));\n    visited[start] = 0;\n    int count = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            count++;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    //cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 5;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        cout << \"(i = \" << i << \") \" << in.path << endl;\n        for (int j = 0; j < N2; j++)\n            cout << \" \" << in.f[j];\n        cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n//    ms[in] = true;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<unordered_set>\nusing namespace std;\n\nconst int D_x[4] = { 0,1,0,-1 };\nconst int D_y[4] = { 1,0,-1,0 };\nconst int ANS = 123456780;\n\nvoid setNum(int puzzle[3][3],int n) {\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\tpuzzle[i][j] = n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t}\n}\n\nint getNum(int puzzle[3][3]) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tres *= 10;\n\t\t\tres += puzzle[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid find_0(int puzzle[3][3], int& x, int& y) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (puzzle[i][j] == 0) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int puzzle[3][3]) {\n\tqueue<int> q;\n\tunordered_set<int> table;\n\tint cnt = 1;\n\n\tq.push(getNum(puzzle));\n\tif (q.front() == ANS)return 0;\n\twhile (true) {\n\t\tint s = q.size();\n\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint x, y;\n\t\t\tsetNum(puzzle, q.front());\n\t\t\tfind_0(puzzle, x, y);\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint X = x + D_x[j];\n\t\t\t\tint Y = y + D_y[j];\n\t\t\t\tif (X < 0 || Y < 0 || X >= 3 || Y >= 3)continue;\n\t\t\t\tsetNum(puzzle, q.front());\n\t\t\t\tswap(puzzle[y][x], puzzle[Y][X]);\n\n\t\t\t\tint n = getNum(puzzle);\n\t\t\t\tif (n == ANS) {\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t\tif (table.count(n) == 0) {\n\t\t\t\t\ttable.insert(n);\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcnt++;\n\t}\n}\n\nint main() {\n\tint puzzle[3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> puzzle[i][j];\n\t\t}\n\t}\n\n\tcout << solve(puzzle) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nvector<int> in(N2);\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nconst char dir[4] = {'u', 'l', 'd', 'r'};\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle p)\n{\n    map<Puzzle, bool> mp;\n    queue<Puzzle> mq;\n    Puzzle u, v;\n    mp[p] = true;\n    mq.push(p);\n    while(!mq.empty()) {\n        u = mq.front();\n        mq.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[tx * N + ty], v.f[sx * N + sy]);\n            v.space = tx * N + ty;\n\n            if (!mp[v]) {\n                mp[v] = true;\n                v.path += dir[r];\n                mq.push(v);\n            }\n        }\n    }\n    return \"unsolveable\";\n}\n\nint main()\n{\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.space = i;\n            in.f[i] = N2;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nclass state{\npublic:\n  int* num;\n  int time;\n  int space;\n\n  state(){\n    num = new int[9];\n  }\n\n  state(int time){\n    num = new int[9];\n    this->time = time;\n  }\n\n  state(const state &st){\n    num = new int[9];\n    for(int i=0; i<9; i++) num[i]=st.num[i];\n    time = st.time;\n    space = st.space;\n  }\n\n  ~state(){\n    delete[] num;\n  }\n\n  bool operator < (const state&a) const{\n    for(int i=0; i<9; i++){\n      if(num[i]==a.num[i]) continue;\n      return num[i] < a.num[i];\n    }\n    return false;\n  }\n\n  bool check_ans(){\n    bool flag=true;\n    for(int i=0; i<9; i++){\n      if(num[i]!=i+1) flag=false;\n    }\n    return flag;\n  }\n\n  //ã³ã¼ã1~4ãæå®ãã¦ãããºã«ãç§»åããã\n  state operate(int i){\n    int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};//ç§»åæ¹å\n    int nx = space%3+dx[i], ny = space/3+dy[i];\n    state ns=*this;\n    ns.swap(ny*3+nx, space);\n\n    ns.time=time+1;\n    ns.space=ny*3+nx;\n\n    return ns;\n  }\n\n  bool direction_check(int i){\n    int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};//ç§»åæ¹å\n    int nx = space%3+dx[i], ny = space/3+dy[i];\n    if(nx<0 || 2<nx || ny<0 || 2<ny) return false;\n    return true;\n  }\nprivate:\n  //numã®n1çªç®ã®è¦ç´ ã¨n2çªç®ã®è¦ç´ ãå¥ãæ¿ãã\n  void swap(int n1, int n2){\n    int temp=num[n1];\n    num[n1]=num[n2];\n    num[n2]=temp;\n  }\n};\nint main(){\n  state start(0);//åæç¶æã®çæ\n  for(int i=0; i<9; i++) {\n    cin >> start.num[i];\n    if(start.num[i]==0){\n      start.num[i]=9;\n      start.space=i;\n    }\n  }\n\n  //éè¤ãé¿ããããã®map\n  map<state, bool> mp;\n  mp[start]=true;\n\n  //bfsç¨ã®queueçæ\n  queue<state> q; q.push(start);\n\n  //queueãç©ºã«ãªãã¾ã§\n  while(!q.empty()){\n    state now=q.front(); q.pop();\n\n    //ããåãåºããç¶æãææã®ç¶æãªããããã£ãåæ°ãè¡¨ç¤ºãã¦çµäº\n    if(now.check_ans()){\n      cout << now.time << endl;\n      break;\n    }\n\n    for(int i=0; i<4; i++){\n      if(!now.direction_check(i)) continue;\n      state ns=now.operate(i);\n      if(!mp[ns]){\n        mp[ns]=true;\n        q.push(ns);\n      }\n    }\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstruct state\n{\n  vector<vector<int>> bd;\n  int cnt;\n};\n\nclass EightPuzzle\n{\npublic:\n  queue<state> q;\n  map<vector<vector<int>>,bool> m;\n  vector<vector<int>> goal;\n  vector<int> dr,dc;\n  EightPuzzle(){}\n  EightPuzzle( state st ){ q.push(st); goal = {{1,2,3},{4,5,6},{7,8,0}}; dr = {1, -1, 0, 0}; dc = {0, 0, 1, -1}; }\n  int solve();\n  void find0( vector<vector<int>> &b, int &x, int &y );\n};\n\nvoid EightPuzzle::find0( vector<vector<int>> &b, int &r, int &c )\n{\n  for ( r = 0; r < 3; ++r )\n    for ( c = 0; c < 3; ++c )\n      if ( b[r][c] == 0 ) return;\n}\n\nint EightPuzzle::solve()\n{\n  while ( ! q.empty() )\n    {\n      state st = q.front();\n      \n      if ( st.bd == goal )\n        {\n          cout << st.cnt << endl;\n          return 0;\n        }\n\n      int r, c;\n      find0( st.bd, r, c );\n\n      for ( auto i = 0; i < 4; ++i )\n        {\n          int nr = r + dr[i];\n          int nc = c + dc[i];\n          if ( nr < 0 || nr > 2 || nc < 0 || nc > 2 ) continue;\n\n          state nst = st;\n          nst.bd[r][c] = st.bd[nr][nc];\n          nst.bd[nr][nc] = 0;\n          nst.cnt = st.cnt + 1;\n\n          if ( m.count(nst.bd) == 0 )\n            {\n              q.push(nst);\n              m[nst.bd] = true;\n            }\n        }\n      q.pop();\n    }\n  \n  return 0;\n}\n\nint main()\n{\n  state st;\n  st.cnt = 0;\n  \n  for ( auto i = 0; i < 3; ++i )\n    {\n      vector<int> vl;\n      for ( auto j = 0; j < 3; ++j )\n        {\n          int v;\n          cin >> v;\n          vl.push_back(v);\n        }\n      st.bd.push_back(vl);\n    }\n\n  EightPuzzle ep( st );\n\n  ep.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define ll long long\n#define endl '\\n'\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'}; // dir:direction\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Puzzle in;\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;  // set space\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i]){\n                pq.pop();\n                return;\n            }\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#define N 3\n#define N2 9\nusing namespace std;\n \nstruct Puz{\n  int f[N2];\n  int space;\n  string path;\n  \n  bool operator < (const Puz &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i]==p.f[i]) continue;\n      \n      return f[i]>p.f[i];\n      \n    }\n    \n    return false;\n    \n  }\n};\n \nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nchar dir[4]={'u','l','d','r'};\n \nbool check(Puz p){\n  for(int i = 0; i < N2; i++){\n    if(p.f[i] != (i+1)) return false;\n  }\n  \n  return true;\n\n}\n \nstring bfs(Puz s){\n  queue<Puz> Q;\n  map<Puz,bool> V;\n  Puz u, v;\n  \n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n   \n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    \n    if(check(u)) return u.path;\n    \n    int sx = u.space / N;\n    int sy = u.space % N;\n    \n    for(int i = 0; i < 4; i++){\n      int tx = sx + dx[i];\n      int ty = sy + dy[i];\n      \n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      \n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      \n      v.space = tx * N + ty;\n      \n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[i];\n\tQ.push(v);\n      }\n    }\n  }\n  \n  return \"unsolvable\";\n  \n}\n \nint main(){\n  Puz in;\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    \n    if(in.f[i] == 0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  \n  string ans = bfs(in);\n  \n  cout << ans.size() << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nvector<int> tiles(9);\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 50){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n        i += 5;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1);\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[o] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nstruct Node{\n\tvector<int> arr;\n\tint step;\n};\nconst int tx[]={1,0,-1,0};\nconst int ty[]={0,1,0,-1};\nvector<int> start,end;\nqueue<Node> sq;\nset<int> pan;\n\nvoid input()\n{\n\tint tmp;\n\tfor(int i=0;i!=3;++i)\n\t\tfor(int j=0;j!=3;++j)\n\t\t{\n\t\t\tcin>>tmp;\n\t\t\tstart.push_back(tmp);\n\t\t}\n\tfor(int i=0;i!=8;++i)\n\t\tend.push_back(i+1);\n\tend.push_back(0);\n}\n\nNode makenod(vector<int> tmp,int step)\n{\n\tNode res;\n\tres.arr=tmp;\n\tres.step=step;\n\treturn res;\n}\n\nint vton(vector<int> tmp)\n{\n\tint res=0;\n\tfor(int i=0;i!=9;++i)\n\t\tres=res*10+tmp[i];\n\treturn res;\n}\n\n/*\nvoid print(vector<int> tmp)\n{\n\tfor(int i=1;i!=10;++i)\n\t{\n\t\tcout<<tmp[i-1]<<' ';\n\t\tif(i%3==0)\tcout<<endl;\n\t}\n\tcout<<endl;\n}\n*/\nint main()\n{\n\tinput();\n\n\tsq.push(makenod(start,0));\n\tpan.insert(vton(start));\n\t\n\tint ans;\n\twhile(!sq.empty())\n\t{\n\t\tNode now=sq.front();\tsq.pop();\n\n\t\tprint(now.arr);\n\n\t\tif(now.arr==end)\n\t\t{\n\t\t\tans=now.step;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ith;\n\t\tfor(int i=0;i!=9;++i)\n\t\t\tif(now.arr[i]==0)\n\t\t\t{\n\t\t\t\tith=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x=ith/3,y=ith%3;\n\t\t\n\t\tfor(int i=0;i!=4;++i)\n\t\t{\n\t\t\tint nx=x+tx[i],ny=y+ty[i];\n\t\t\tif(nx>=0 && nx<3 && ny>=0 && ny<3)\n\t\t\t{\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t\tint num=vton(now.arr);\n\t\t\t\tif(pan.count(num)==0)\n\t\t\t\t{\n\t\t\t\t\tsq.push(makenod(now.arr,now.step+1));\n\t\t\t\t\tpan.insert(num);\t\t\n\t\t\t\t}\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<string>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n  int pas[N2], ss;\n  string path;\n\n  bool operator < (const Puzzle &p1) const {\n\n    for (int i = 0; i < N2; i++) {\n      if (pas[i] == p1.pas[i]) continue;\n      return pas[i] > p1.pas[i];\n    }\n    return false;\n  }\n};\n\nbool isTarget(Puzzle u) {\n  for (int i = 0; i < N2; i++) {\n    if (u.pas[i] != i + 1) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map <Puzzle, bool> V;\n\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    if (isTarget(u)) return u.path;\n    int sx = u.ss / N;\n    int sy = u.ss % N;\n    for (int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.pas[u.ss], v.pas[tx * N + ty]);\n      v.ss = tx * N + ty;\n      if (!V[v]) {\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n\nint main() {\n  Puzzle in;\n  for (int i = 0; i < N2; i++) {\n    cin >> in.pas[i];\n    if (!in.pas[i]) {\n      in.pas[i] = N2;\n      in.ss = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nint minimum=-1;\n\nint checkTable[362880];\t//????????Â¶????????????????????Â£??????????????????????????????????????????????????????????????????\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\t//(table[row][col]-1)/3:??Â¬??\\???????????????(0???2)\n\t\tfor(int col=0;col<3;col++){ //(table[row][col]-1)%3:??Â¬??\\???????????????(0???2)\n\t\t\tif(table[row][col] != 0){\t//0?????\\??Â±???\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\tstack<long long>A,B;\n\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tA.push(makeLong(table));\n\tlong long tmp;\n\tbool foundFLG=false;\n\tint zero_loc;\n\n\tfor(int count=0;count < 362880;count++){\n\t\tif(count%2 == 0){\n\t\t\twhile(!A.empty()){\n\t\t\t\ttmp = A.top();\n\t\t\t\tA.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzero_loc = zeroLoc(tmpTable);\n\t\t\t\tswitch(zero_loc){\n\t\t\t\tcase 0:\t//?Â§?\n\t\t\t\tcase 2:\n\t\t\t\tcase 20:\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1://???\n\t\t\t\tcase 10:\n\t\t\t\tcase 12:\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(zero_loc){\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswap(next_table[2][0][1],next_table[2][0][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\twhile(!B.empty()){\n\t\t\t\ttmp = B.top();\n\t\t\t\tB.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tzero_loc = zeroLoc(tmpTable);\n\t\t\t\tswitch(zero_loc){\n\t\t\t\tcase 0:\t//?Â§?\n\t\t\t\tcase 2:\n\t\t\t\tcase 20:\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1://???\n\t\t\t\tcase 10:\n\t\t\t\tcase 12:\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(zero_loc){\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswap(next_table[2][0][1],next_table[2][0][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(foundFLG)break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p ) const{\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const int dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i = 0;i<N2;i++)\n\tif(p.f[i] != (i+1) ) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\t\n\twhile( !Q.empty() ){\n\t\tu = Q.front();Q.pop();\n\t\tif( isTarget(u) )return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r = 0; r < 4 ; r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space],v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif( !V[v] ){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\t\n\tfor(int i = 0;i < N2; i++){\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0 ){\n\t\t\tin.f[i] = N2; // set space\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() <<  endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n#define N1 3\n#define N2 9  \n#define LIMITMAX 100\n//#define false 0\n//#define true 1\n\nstruct PUZZLE{\n  int f[N2], kuuhaku ,MD;/*ãã³ããã¿ã³è·é¢*/\n  //int cost;\n};\n\nstatic const int dx_123[4] = {0, -1, 0, 1};//ï¼æ¹å\nstatic const int dy_123[4] = {1, 0, -1, 0};//ï¼æ¹å\nstatic const char houkou[4] ={'r', 'u', 'l', 'd'};//å³:right,ãä¸:up,ãå·¦:left,ãä¸:down\n\nint ManhattanDistance[N2][N2];\nPUZZLE jyoutai;\nint limit;//æ·±ãã®limit\nint miti[LIMITMAX];\n\nint GetallManhattanDistance(PUZZLE);\nbool dfs(int, int);\n//int max(int, int);\n//int min(int, int);\nstring  iterative_deepning(PUZZLE); //åå¾©æ·±å\n\n\nint main(){\n\n  int i,j,k;\n  PUZZLE in;\n  \n  for(i=0;i<N2;i++){\n    for(j=0;j<N2;j++){\n      ManhattanDistance[i][j] = abs( i/N1 - j/N1 ) + abs(i%N1 -j%N1); \n    }\n  }\n\n   \n  for(i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] =  N2;\n      in.kuuhaku = i;\n    }\n  }\n\n  string kotae = iterative_deepning(in);\n\n  cout << kotae.size();\n  cout << endl;\n \n  return 0;\n}\n\n/*\n  void  swap(int *a , int *b){\n  int *tmp;\n  \n  tmp = a;\n  a = b ;\n  b = tmp;\n  \n  }\n*/\nint GetallManhattanDistance(PUZZLE p){//å¨ã¦ã®ãã³ããã¿ã³è·é¢ãåå¾ãã\n\n  int goukei = 0;\n  int i,j,k;\n\n  for(i=0;i<N2;i++){\n    if(p.f[i] == N2)continue;\n    goukei += ManhattanDistance[i][p.f[i]-1];\n  }\n\n  return goukei;\n}\n\nbool dfs(int depth, int prev){\n\n  int i,j,k;\n  int r;\n  int sx,sy;\n  PUZZLE tmp;\n  int tx,ty;\n  \n  if(jyoutai.MD == 0) return true ;\n  //ç¾å¨ã®æ·±ãã«ãã¥ã¼ãªã¹ãã£ãã¯ãè¶³ãã¦å¶éãè¶ãããæãåã\n\n  if( depth + jyoutai.MD > limit ) return false;\n\n  sx = jyoutai.kuuhaku / N1;\n  sy = jyoutai.kuuhaku % N1;\n\n  for(r=0;r<4;r++){\n    tx = sx + dx_123[r];\n    ty = sy + dy_123[r];\n\n    if(tx < 0 || tx >= N1 || ty < 0 || ty >= N1 ) continue;\n    if(max(prev, r) - min(prev, r) == 2 ) continue;\n    tmp = jyoutai;\n    //ãã³ããã¿ã³è·é¢ã®å·®åãè¨ç®ãã¤ã¤ããã¼ã¹ãã¹ã¯ãã\n    jyoutai.MD -= ManhattanDistance[tx * N1 + ty][jyoutai.f[tx * N1 + ty]-1];\n    jyoutai.MD += ManhattanDistance[sx * N1 + sy][jyoutai.f[tx * N1 + ty]-1];\n    swap(jyoutai.f[tx * N1 + ty], jyoutai.f[sx * N1 + sy]);\n    jyoutai.kuuhaku = tx * N1 + ty;\n    if( dfs(depth + 1, r) ){\n      miti[depth] = r;\n      return true;\n    }\n    jyoutai = tmp;\n  }\n  \n  return false;\n}\n/*\n  int max(int a, int b){\n  if(a<b) return b;\n  return a;\n  }\n\n  int min(int a, int b){\n  if(a<b) return a;\n  return b;\n  }\n*/\n\n\n\n\nstring  iterative_deepning(PUZZLE in){//åå¾©æ·±å\n\n  int i,j,k;\n  //string  kotae = \"\";\n  //char kotae2[] = \"unsolvable\";\n  \n  in.MD = GetallManhattanDistance(in);//åæã®ãã³ããã¿ã³è·é¢\n\n  for(limit = in.MD; limit <= LIMITMAX; limit++ ){\n    jyoutai = in;\n    if( dfs(0, -100) ){\n      string kotae = \"\";\n      for(i = 0; i < limit; i++) kotae += houkou[miti[i]];\n      return kotae;\n    } \n  }\n  \n  return \"ã§ãã¾ããã§ãã\";\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst char answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<char> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<char> tiles;\n    explicit board(vector<char> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return ((b1.moves + b1.wrongs) > (b2.moves + b2.wrongs)) ? true : false;\n}\n\nint dfs(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if((target.moves + target.wrongs) > 100)\n            return -1;\n        if(target.wrongs == 0)\n            return target.moves;\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    short ii;\n    REP(i, 9){\n        cin >> ii;\n        original[i] = ii;\n    }\n    int move = dfs();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nbool isTarget(Puzzle );\nstring bfs(Puzzle );\n\nstruct Puzzle{\n  int i,f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const{\n\n    for(i = 0;i < N2;i ++)\n      {\n\tif(f[i] == p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n \n \nint main(){\n\n  Puzzle in;\n\n  int i;\n\n \n  for(i = 0;i < N2;i ++)\n    {\n      cin >> in.f[i];\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n string ans = bfs(in);\n\n  cout << ans.size() << endl;\n \n  return 0;\n}\n\nbool isTarget(Puzzle p){\n\n  int i;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      if(p.f[i] != (i + 1)) return false;\n    }\n  \n  return true;\n}\n \nstring bfs(Puzzle s){\n\n  int sx,sy,tx,ty,r;\n  \n  queue<Puzzle> Q;\n\n  map<Puzzle, bool> V;\n\n  Puzzle u, v;\n\n  s.path = \"\";\n\n  Q.push(s);\n\n  V[s] = true;\n \n  while(!Q.empty()){\n\n    u = Q.front();\n\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for(r = 0;r < 4;r ++)\n      {\n\ttx = sx + dx[r];\n\tty = sy + dy[r];\n\n\tif(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n       \n\tv = u;\n      \n\tswap(v.f[u.space], v.f[tx * N + ty]);\n      \n\tv.space = tx * N + ty;\n      \n\tif(!V[v]){\n\t  V[v] = true;\n\t  v.path += dir[r];\n\t  Q.push(v);\n\t}\n      }\n  }\n \n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (D[p2] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (p2 == lastboard)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>        // swap()\n\nusing namespace std;\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstruct puzzle\n{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const puzzle &p) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] != p.f[i])\n\t\t\t\treturn f[i] > p.f[i];\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nbool\nis_target(puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nstring\nbfs(puzzle s)\n{\n\tqueue<puzzle> Q;\n\tmap<puzzle, bool> V;\n\tpuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (is_target(u))\n\t\t\treturn u.path;\n\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint\nmain(int argc, char** argv)\n{\n\tpuzzle in;\n\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif (in.f[i] == 0)\n\t\t{\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tstring ans = bfs(in);\n\tprintf(\"%lu\\n\", ans.size());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\nusing PZL = vector<vector<int>>;\n\nint potential(PZL p) {\n    int res = 0;\n    rep(i, 3) {\n        rep(j, 3) {\n            int x = (p[i][j] - 1) % 3;\n            int y = (p[i][j] - 1) / 3;\n            if (p[i][j] == 0) {\n                x = 2;\n                y = 2;\n            }\n            res += abs(j - x) + abs(i - y);\n        }\n    }\n    return res;\n}\n\nll hashing(PZL p) {\n    ll res = 0;\n    ll base = 1;\n    rep(i, 3) {\n        rep(j, 3) {\n            res += p[i][j] * base;\n            base *= 9;\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    PZL pazzle(3, vector<int>(3)); \n    rep(i, 3) {\n        rep(j, 3) cin>>pazzle[i][j];\n    }\n\n    PZL ans {\n        vector<int> {1, 2, 3},\n        vector<int> {4, 5, 6},\n        vector<int> {7, 8, 0},\n    };\n    vector<P> direc {P(1, 0), P(-1, 0), P(0, 1), P(0, -1)};\n    priority_queue<pair<P, PZL>, vector<pair<P, PZL>>, greater<pair<P, PZL>>> q;\n    set<ll> visited;\n    q.push(pair<P, PZL>(P(potential(pazzle), 0), pazzle));\n\n    int res = 0;\n    while (!q.empty()) {\n        pair<P, PZL> p = q.top(); q.pop();\n        PZL pzl = p.second;\n        int w = p.first.second;\n        \n        if (pzl == ans) {\n            res = w;\n            break;\n        }\n\n        ll hash = hashing(pzl);\n        if (visited.find(hash) != visited.end()) continue;\n        visited.insert(hash);\n\n        P z;\n        rep(i, 3) {\n            rep(j, 3) {\n                if (pzl[i][j] == 0) z = P(i, j);\n            }\n        }\n        for (auto d : direc) {\n            int ni = z.first + d.first;\n            int nj = z.second + d.second;\n            if (ni < 0 || ni >= 3 || nj < 0 || nj >= 3) continue;\n            swap(pzl[z.first][z.second], pzl[ni][nj]);\n            q.push(pair<P, PZL>(P(w + 1 + potential(pzl), w + 1), pzl));\n            swap(pzl[z.first][z.second], pzl[ni][nj]);\n        }\n    }\n    cout<<res<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle p) const {\n//\t\tfor (int i = 0; i < N2; ++i) {\n//\t\t\tif (f[i] == p.f[i])\n//\t\t\t\tcontinue;\n//\t\t\treturn f[i] > p.f[i];\n//\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N >= 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n        pos = st.find(\"0\");\n        Q.pop();\n        if (mp.count(st)) {\n            if (mp[st] == FLG) {\n                continue;\n            } else if (mp[st] == GOAL) {\n                return cnt;\n            } else\n                printf(\"ERROR: %d\\n\", __LINE__);\n        }\n        mp[st] = FLG;\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n\n  \nbool operator < (const Puzzle &p)const{\n  for(int i=0;i<N2;i++){\n    if(f[i] == p.f[i])continue;\n    return f[i] > p.f[i];\n  }\n  return false;\n}\n};  \n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\n\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i + 1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n\n  \n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r<4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0||ty<0||tx>=N||ty>=N)continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  \n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nqueue<int>Q[3][3];\nqueue<int>R[3][3];\n\nint main() {\n\tint a, b, c, d, e, sum=0;\n\tint x[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> a;\n\t\t\tQ[i][j].push(a);\n\t\t}\n\t}\n\twhile (true) {\n\t\twhile (!Q[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (Q[i][j].front() == 0) {\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[0][0] == 1 && x[0][1] == 2 && x[0][2] == 3 && x[1][0] == 4 && x[1][1] == 5 && x[1][2] == 6 && x[2][0] == 7 && x[2][1] == 8) {\n\t\t\t\tgoto owata;\n\t\t\t}\n\t\t\tif (b >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b - 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b - 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b + 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b + 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c - 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c - 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c + 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c + 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!R[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].push(R[i][j].front());\n\t\t\t\t\tR[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\nowata:;\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string>\nusing namespace std;\n#define maxn 10\nstruct my\n{\n    int tu[10];\n    int space;\n    int  ans;\n    bool operator <(const my &p)const{\n    for (int i=0;i<9;i++)\n        {\n            if(tu[i]==p.tu[i]) continue;\n        return tu[i]>p.tu[i];\n        }\n        return false ;\n    }\n};\nbool is(my s)\n{\n    for (int i=0;i<9;i++)\n        if(s.tu[i]!=(i+1)) return false;\n    return true;\n}\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n//char dir[]={'u','l','d','r'};\nint bfs(my s)\n{\n    queue<my>Q;\n    map<my,bool>V;\n    s.ans=0;\n    Q.push(s);\n    V[s]=true;\n    my u,v;\n\n    while(!Q.empty())\n    {\n        u=Q.front();\n        Q.pop();\n        if(is(u)) return u.ans;\n        int sx=u.space/3;\n        int sy=u.space%3;\n        for (int i=0;i<4;i++)\n        {\n            int tx=sx+dx[i];\n            int ty=sy+dy[i];\n            if(tx<0||ty<0||tx>=3||ty>=3) continue;\n            v=u;\n            swap(v.tu[u.space],v.tu[tx*3+ty]);\n            v.space=tx*3+ty;\n            if(!V[v])\n            {\n                V[v]=true;\n                v.ans++;\n                Q.push(v);\n            }\n        }\n    }\n}\nint main()\n{\n    my in;\n    for (int i=0;i<9;i++)\n    {\n        scanf(\"%d\",&in.tu[i]);\n        if(in.tu[i]==0){\n            in.space=i;\n            in.tu[i]=9;\n        }\n    }\n    int sum=bfs(in);\n    printf(\"%d\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,mat> P;\n\nbool check(mat A){\n  \n  string ans = \"123456780\";\n  string s;\n  \n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++) s += (char)( A[i][j] + '0' );\n  }\n  \n  return ans == s;  \n}\n\nint bfs(mat s){\n  \n  queue<P> Q;\n  map<mat,int> memo;\n  \n  Q.push( P( 0, s ) );\n  memo[ s ] = 0;\n  \n  while( !Q.empty() ){\n    \n    P t = Q.front(); Q.pop();\n    \n    int cost = t.first;\n    mat A = t.second;\n    \n    if( check( A ) == true ) return cost;\n    \n    int y, x;\n    \n    for(int i=0;i<3;i++){\n      \n      for(int j=0;j<3;j++){\n\t\n\tif( A[i][j] == 0 ) y = i, x = j;\n\t\n      }\n      \n    }\n    \n    int dy[4] = {-1,0,1,0};\n    int dx[4] = {0,1,0,-1};\n    \n    for(int i=0;i<4;i++){\n      \n      int ny = y + dy[i], nx = x + dx[i];\n      \n      if( ny < 0 || nx < 0 || 3 <= ny || 3 <= nx ) continue;\n      \n      mat nA = A;\n      int ncost = cost + 1;\n      \n      swap( nA[y][x], nA[ny][nx] );\n      \n      if( memo.count( nA ) ) continue;\n      \n      memo[nA] = ncost;\n      Q.push( P( ncost, nA ) );\n      \n    }\n    \n  }\n  \n  return 0; \n}\n\nsigned main(){\n  \n  mat s = mat( 3, vec( 3 ) );\n  \n  for(int i=0;i<3;i++){\n    \n    for(int j=0;j<3;j++){\n      \n      cin>>s[i][j];\n      \n    }\n    \n  }\n  \n  cout<<bfs(s)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs(((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN)) - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned && Puzzles[PtoI(Q)] < answer){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    \n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nvoid RenewTargets(\n\tconst TPuzzle& Puzzle,\n\tconst TMovePattern& Pattern,\n\tstd::vector<TPuzzle>& Targets,\n\tstd::set<TPuzzle>& History)\n{\n\tif(!Movable(Puzzle, Pattern)) return;\n\tTPuzzle Moved = Move(Puzzle, Pattern);\n\tif(History.find(Moved) != History.end()) return;\n\tTargets.push_back(Moved);\n\tHistory.insert(Moved);\n}\n//?Â¬??????????????????????????????Â¶???????????????\n\n//????Â¬??????????????????????????Â¨?????????Â£???????????Â°?????????\n//?Â¬?????????????????????????????????Â§?????????????????????????????????\n//???????????Â§????Â±\\??Â´????????Â£????????????\n//?Â¬???????????????????????????????????????????????????????\n//?Â±\\??Â´????????????\n//????????????\nbool CountMove(std::vector<TPuzzle>& NextTargets,\n\t          const TPuzzle& Goal,\n\t          std::set<TPuzzle>& History)\n{\n\tif(std::find(NextTargets.begin(), NextTargets.end(), Goal) != NextTargets.end()) return true;\n\tstd::vector<TPuzzle> NewTargets;\n\tfor(std::vector<TPuzzle>::const_iterator It = NextTargets.begin(); It != NextTargets.end(); ++It){\n\t\tRenewTargets(*It, mpUp,    NewTargets, History);\n\t\tRenewTargets(*It, mpDown,  NewTargets, History);\n\t\tRenewTargets(*It, mpLeft,  NewTargets, History);\n\t\tRenewTargets(*It, mpRight, NewTargets, History);\n\t}\n\tNextTargets = NewTargets;\n\treturn false;\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::vector<TPuzzle> Targets(1, Puzzle);\n\tstd::set<TPuzzle> History;\n\tint Count = 0;\n\twhile(!CountMove(Targets, Goal, History)) ++Count;\n\treturn Count;\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <ctime>\n#include <queue>\ntypedef std::vector<std::vector<int>> vvi;\n\nint n;\nvvi a(4,std::vector<int>(4));\nstd::map<vvi, int> mp;\n/*ã´ã¼ã«ç¶æããããã\n0 1 2\n3 4 5\n6 7 *\n\n0 1 2 3\n4 5 6 7\n8 9 10 11\n12 13 14 *\nã¨ãã\n */\n\nvoid init(){\n\tint N = n*n;\n\tstd::vector<bool> use(N,false);\n\tint now = 0;\n\twhile(now < N){\n\t\tint x = rand() % N;\n\t\tif(!use[x]){\n\t\t\ta[now/n][now%n] = x;\n\t\t\tuse[x] = true;\n\t\t\tnow++;\n\t\t}\n\t}\n}\n\nbool goal(){\n\tbool res = true;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(a[i][j] != i*n+j) res = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid print(){\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++) std::cout << a[i][j] << \" \";\n\t\tstd::cout << \"\\n\";\n\t}\n}\n\nint h(int mode){\n\tif(mode == 0) return 0;\n\tint res = 0;\n\tif(mode == 1){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[i][j] != i*n+j) res++;\n\t\t\t}\n\t\t}\n\t}else if(mode == 2){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tint y = a[i][j]/n;\n\t\t\t\tint x = a[i][j]%n;\n\t\t\t\tres += abs(y-i) + abs(x-j);\n\t\t\t}\n\t\t}\n\t}else{\n\t\treturn 1<<30;\n\t}\n\treturn res;\n}\n\nint f(int mode, int g){\n\treturn h(mode) + g;\n}\n\n\nbool in(int y, int x){\n\treturn 0 <= y && y < n && 0 <= x && x < n;\n}\n\nint dy[4] = {1,0,-1,0};\nint dx[4] = {0,1,0,-1};\n\nstruct dat{\n\tint f,g;\n\tvvi vec;\n\tbool operator< (const dat &d) const {\n\t\treturn f > d.f;\n\t}\n};\n\nint search(int mode){\n\tstd::priority_queue<dat> pq;\n\tpq.push({f(mode,0),0,a});\n\t//std::cout << f(mode,0) << \" \" << ss << \"\\n\";\n\tmp[a] = f(mode,0);\n\twhile(!pq.empty()){\n\t\tauto p = pq.top(); pq.pop();\n\t\ta = p.vec;\n\t\tif(goal()) return p.g;\n\t\tint y,x;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[i][j] == n*n-1){\n\t\t\t\t\ty = i; x = j; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(!in(ny,nx)) continue;\n\t\t\tstd::swap(a[ny][nx], a[y][x]);\n\t\t\tif(mp.find(a) != mp.end()){\n\t\t\t\tstd::swap(a[ny][nx], a[y][x]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint cost = f(mode, p.g + 1);\n\t\t\tmp[a] = cost;\n\t\t\tpq.push({cost, p.g + 1, a});\n\t\t\tstd::swap(a[ny][nx], a[y][x]);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(){\n\t//srand(unsigned(time(NULL)));\n\tint mode = 1;\n\tn = 3;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint c; std::cin >> c;\n\t\t\ta[i][j] = c - 1;\n\t\t\tif(a[i][j] < 0) a[i][j] += 9;\n\t\t}\n\t}\n\t//std::cin >> n >> mode;\n\t//cin >> n;\n\t//init();\n\tstd::cout << search(mode) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r','u','l','d'};\nint MDT[N2][N2];\n\nstruct Puzzle {\n    int f[N2], space, MD;\n    int cost;\n\n    bool operator < (const Puzzle &p) const{\n        for(int i=0; i<N2; i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i] < p.f[i];\n        }\n        return false;\n    }\n};\n\nstruct State{\n    Puzzle puzzle;\n    int estimated;\n    bool operator < (const State &s) const{\n        return estimated > s.estimated;\n    }\n};\n\nint getAllMD(Puzzle pz){\n    int sum=0;\n    for(int i=0; i<N2; i++){\n        if(pz.f[i] == N2) continue;\n        sum += MDT[i][pz.f[i]-1];\n    }\n    return sum;\n}\n\nint astar(Puzzle s){\n    priority_queue<State> PQ;//åªåé ä½ä»ãã­ã¥ã¼\n    s.MD = getAllMD(s);//ãã³ããã¿ã³è·é¢ã®åæå¤ãè¨ç®\n    s.cost = 0;//ã³ã¹ãå¤ã¯æåã¯0\n    //mapã¨ã¯C++æ¨æºã©ã¤ãã©ãªã«ç¨æãããå¹³è¡¡äºåæ¨.\n    //è¦ç´ ã®è¦ç´ æ°ã«å¯¾ããå¯¾æ°ãªã¼ãã¼ã§ã®é«éãªæ¤ç´¢ãå¯è½ãåé¨ã§è¦ç´ ãã½ã¼ãç¶æã§ä¿æããã\n    //è¾æ¸ã¿ãããªä½¿ãæ¹ãå¤ã\n    //Puzzleãkey,boolãvalue\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    State initial;//Stateæ§é ä½ã¯ããºã«ã®æå ±ã¨ãã¥ã¼ãªã¹ãã£ãã¯å¤ãè¨ç®\n    initial.puzzle = s; //Stateã®ã¤ã³ã¹ã¿ã³ã¹ãçæ\n    initial.estimated = getAllMD(s);//sã®ãã³ããã¿ã³è·é¢ãè¨ç®ãã¦æ ¼ç´\n    PQ.push(initial);//initialãã­ã¥ã¼ã«ããã·ã¥\n\n    while(!PQ.empty()){//PQãç©ºã§ãªãéã¯ã«ã¼ã å¨ã¦ã®ã­ã¥ã¼ã«å¥ã£ã¦ããè¦ç´ ãè¦ã\n        State st = PQ.top(); PQ.pop();//ã­ã¥ã¼ã®è¦ç´ ãstã«ä»£å¥ãã¦åé¤\n        u = st.puzzle; //stã®ã¡ã³ãã§ããç¤é¢æå ±puzzleãuã«ä»£å¥\n\n        if(u.MD == 0) return u.cost;//ãã³ããã¿ã³è·é¢ã0 -->è§£ãã\n        V[u] = true;//Vã¯mapã§ãPuzzleã®ã¤ã³ã¹ã¿ã³ã¹ã¨true,falseãå¯¾å¿ãããã\n\n        int sx = u.space / N;//xåº§æ¨è¨ç®\n        int sy = u.space % N;//yåº§æ¨è¨ç®\n\n        for(int r=0; r<4; r++){ //4æ¹åãã¹ã¦ãè©¦ãã\n            int tx = sx + dx[r]; //xæ¹åã®é·ç§»\n            int ty = sy + dy[r]; //yæ¹åã®é·ç§»\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;//ç§»åå¾ãã¹ããã¯ã¿åºããå ´å\n            v = u;\n            \n            /*ãã³ããã¿ã³è·é¢ã®å·®åãè¨ç®ãã¤ã¤ããã¼ã¹ãã¹ã¯ãã*/\n            //tx * N + tyã¯ç©ºç½ã®ä½ç½®ãféåã¯ããºã«ã®ãã¹ã®å¤ãv.f[tx * N + ty]ã¯ããºã«ã®å¤\n            //ç©ºç½ãç§»åããå(tx*N+ty)ããã¨ãã¨ã®æ°å­ããã£ãå ´æãªã®ã§ãç§»ååã®ãã³ããã¿ã³è·é¢ãå¼ã\n            v.MD -= MDT[tx * N + ty][v.f[tx * N + ty] - 1];\n            //ãã¨ãã¨ã®æ°å­ã¯ç©ºç½ããã£ãå ´æã«ç§»åãããããã«ãã£ã¦å¢ãããã³ããã¿ã³è·é¢ãè¶³ãã\n            v.MD += MDT[sx * N + sy][v.f[tx * N + ty] - 1];\n\n            swap(v.f[sx * N + sy], v.f[tx * N + ty]);//ç©ºç½ã®ä½ç½®ãswap\n            v.space = tx * N + ty;//swapããã®ã§ç©ºç½ã®ä½ç½®ãæ´æ°\n            if(!V[v]){\n                v.cost++;//swapããã®ã§æ¨ã®ä¸ã«è¡ã£ã¦ã³ã¹ãã1å¢ãã\n                State news;\n                news.puzzle = v;\n                news.estimated = v.cost + v.MD;//æ¨ã®æ·±ãã¨ãã³ããã¿ã³è·é¢ãè¶³ãã¦ãã¥ã¼ãªã¹ãã£ãã¯å¤ã«ããã\n                PQ.push(news);\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    //ãã³ããã¿ã³è·é¢ã®è¨ç®\n    for(int i=0; i<N2; i++){\n        for(int j=0;j<N2;j++){\n            //MDT[i][j] := ã1æ¬¡åéåä¸ã®ãä½ç½®iããä½ç½®jã«ç§»åãããã¨ããæã\n            //2æ¬¡åéåä¸ã§ã¯ãã³ããã¿ã³è·é¢ã§ã©ããããç§»åãã¦ãããåè¨ç®\n            //abs(i/N - j/N)ã¯ç¸¦æ¹åã®è·é¢ã®çµ¶å¯¾å¤\n            //abs(i%N - j%N)ã¯æ¨ªæ¹åã®è·é¢ã®çµ¶å¯¾å¤\n            MDT[i][j] = abs(i/N-j/N) + abs(i%N-j%N);//ãã³ããã¿ã³è·é¢\n        }\n    }\n    Puzzle in;\n\n    for(int i=0;i<N2;i++){\n        cin >> in.f[i];\n        if(in.f[i]==0){\n            in.f[i] = N2;//ç©ºç½ã®é¨åã¯N2(16)ãä»£å¥\n            in.space = i;//ç©ºç½ã®ä½ç½®ãæ ¼ç´\n        }\n    }\n    cout << astar(in) << endl;\n\n    return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<vector<int>, int> P;\n\nint zeroPosition( vector<int> a ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] == 0 ) return i;\n    }\n\n    return -1;\n}\n\nvector<int> swapDigit( vector<int> v, int a, int b ) {\n    vector<int> ret = v;\n    int x = v[a];\n    int y = v[b];\n    ret[a] = y;\n    ret[b] = x;\n\n    return ret;\n}\n\nbool isSame( vector<int> a, vector<int> b ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] != b[i] ) return false;\n    }\n\n    return true;\n}\n\nint convert( vector<int> a ) {\n    int ret = 0;\n    for ( int i = 0; i < 9; i++ ) {\n\tret *= 10;\n\tret += a[i];\n    }\n\n    return ret;\n}\n\nint main()\n{\n    set<int> S;\n    queue<P> Q;\n    vector<int> start;\n    vector<int> goal;\t\t// 123456780\n    for ( int i = 0; i < 9; i++ ) {\n\tgoal.push_back( (i + 1) % 9 );\n    }\n\n    for ( int i = 0; i < 9; i++ ) {\n\tint d;\n\tscanf(\"%d\", &d);\n\tstart.push_back( d );\n    }\n\n    S.insert( convert(start) );\n    Q.push( make_pair( start, 0 ) );\n    int ans = 0;\n\n    while ( !Q.empty() ) {\n\tP p = Q.front(); Q.pop();\n\tif ( isSame( p.first, goal) ) {\n\t    ans = p.second;\n\t    break;\n\t}\n\tint pos = zeroPosition( p.first );\n\t\n\tif ( ( pos % 3 ) != 0 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 1 );\n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n\n\tif ( ( pos % 3 ) != 2 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 1 );\t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n\n\tif ( pos > 2 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n\n\tif ( pos < 6 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n  \nint t[3][3];\nint limit;\n  \nint Puzzle_1(){\n  int res=0,a;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(t[i][j]==0)continue;\n      a=t[i][j]-1;\n      res+=abs(a/3-i)+abs(a%3-j);\n    }\n  }\n  return res;\n}\n  \nbool confirm(int depth,int prev,int py,int px){\n  int heuri=Puzzle_1();\n  if(heuri+depth>limit)return false;\n  if(heuri==0)return true;\n  for(int i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int ny=py+dy[i],nx=px+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=3||nx>=3)continue;\n    swap(t[ny][nx],t[py][px]);\n    if(confirm(depth+1,i,ny,nx)) return true;\n    swap(t[ny][nx],t[py][px]);\n  }\n  return false;\n}\n  \nvoid solve(int py,int px){\n  for(limit=0;;limit++){\n    if(confirm(0,99,py,px)){\n      cout<<limit<<endl;\n      return;\n    }\n  }\n}\nint main(){\n  int py,px;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      cin>>t[i][j];\n      if(t[i][j]==0){\n    py=i;\n    px=j;\n      }\n    }\n  }\n  solve(py,px);\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i = 0 ; i < N2 ; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0 ; i < N2 ; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0 ; r < 4 ; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0 ; i < N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\n#define chmax(a,b) if(a<b)a=b;\n#define chmin(a,b) if(b<a)a=b;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair<int, int> pii;\nconstexpr int dx[] = {1, 0, -1,  0};\nconstexpr int dy[] = {0, 1,  0, -1};\n#define N 3\n#define N2 9\nconstexpr char dir[4] = {'u', 'l', 'd', 'r'};\nstruct Puzzle {\n\tvi f;\n\tint space;\n\tstring path;\n\tPuzzle(): space(0), path(\"\") {\n\t\tvi b(N2, 0);\n\t\tf = b;\n\t}\n\tbool operator < (const Puzzle &p) const {\n\t\trep(i, 0, N2) {\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isTarget(Puzzle p) {\n\trep(i, 0, N2)\n\t\tif(p.f[i] != (i + 1)) return false;\n\treturn true;\n}\nstring bfs(Puzzle s) {\n\tdeque<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.eb(s);\n\tV[s] = true;\n\tint sx, sy, tx, ty;\n\twhile(!Q.empty()) {\n\t\tu = Q.front(); Q.pop_front();\n\t\tif(isTarget(u)) return u.path;\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\trep(r, 0, 4) {\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif(!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.eb(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsoIvable\";\n}\nint main() {\n\tPuzzle in;\n\trep(i, 0, N2) {\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tP(len(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n \n/* attention\n    long longã®ã·ããæ¼ç®ã«ã¯æ°ãã¤ããã\n    ã¿ã¤ãããæã®ãããã°ãæ­»ã¬ã»ã©ãã¤ããªãã®ã§å¤æ°åã¯æä½3å­ãããä½¿ã£ãæ¹ããããã\n*/\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i=0; i<N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0; i<N2; i++){\n        if(p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space/N;\n        int sy = u.space%N;\n        for(int r=0; r<4; r++){\n            int tx = sx+dx[r];\n            int ty = sy+dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N + ty]);\n            v.space = tx*N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for(int i=0; i<N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, s, n) for (int i = s; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\n// data\nint P[3][3];\n\nvoid solve();\nint main(){\n    rep(i, 3){\n        rep(j, 3){\n            cin >> P[i][j];\n        }\n    }\n\n    solve();\n}\n\nint manhattan(int (*P)[3]){\n    int dst = 0;\n    rep(i, 3){\n        rep(j, 3){\n            if(P[i][j] == 0) continue;\n\n            int ti = (P[i][j] - 1) / 3,\n                tj = (P[i][j] - 1) % 3; // target location\n            dst += abs(ti - i) + abs(tj - j);\n        }\n    }\n\n    return dst;\n}\n\ntypedef pair<int, int> Pi;\n\nstruct State{\n    State(int (*P0)[3], int move0, Pi blankBef, Pi blankNow){\n        rep(i, 3)\n            rep(j, 3)\n                P[i][j] = P0[i][j];\n        move = move0;\n        dst = manhattan(P) + move;\n        blank = blankNow;\n        _blank = blankBef;\n    }\n    friend bool operator>(State s0, State s1){\n        return s0.dst > s1.dst;\n    }\n    int dst;\n    int move;\n    int P[3][3];\n    pair<int, int> blank, _blank;\n};\n\nconst int di[4] = {-1, 1, 0 ,0},\n    dj[4] = {0,0,-1, 1};\nvoid solve(){\n    // find blank\n    int bi, bj;\n    rep(i, 3)\n        rep(j, 3) if (P[i][j] == 0) bi = i,\n                                    bj = j;\n\n    State s0(P, 0, Pi(bi, bj), Pi(bi, bj));\n    priority_queue<State, vector<State>, greater<State>> pq;\n    pq.push(s0);\n\n    while(!pq.empty()){\n        State s = pq.top(); pq.pop();\n\n        // check final\n        if(manhattan(s.P) == 0){\n            cout << s.move << endl;\n            break;\n        }\n        \n        rep(i, 4){\n            int ii, jj;\n            ii = s.blank.first + di[i];\n            jj = s.blank.second + dj[i];\n\n            if(ii>=0&&ii<3 && jj>=0&&jj<3 && Pi(ii, jj)!= s._blank){\n                swap(s.P[s.blank.first][s.blank.second], \n                    s.P[ii][jj]);\n\n                pq.push(State(s.P, s.move+1, s.blank, Pi(ii, jj)));\n\n                swap(s.P[s.blank.first][s.blank.second],\n                     s.P[ii][jj]);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\nqueue<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n//    board |= static_cast<long long>(num) << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 3) {\n            if (pos < 2) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 0) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else if (pos < 6) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 5) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 3) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 8) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 6) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <set>\n#include <queue>\n\n\nusing namespace std;\n\nconst int N = 3;\n\nstruct Puzzle {\n    array<array<int, N>, N> board;\n    array<int, 2> empty;\n    int turn;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (board[i][j] != p.board[i][j])\n                    return board[i][j] < p.board[i][j];\n            }\n        }\n        return false;\n    }\n};\n\n\nvector<array<int, 2>> dir = {\n    {-1, 0}, // left\n    {0, -1}, // up\n    {1, 0},  // right\n    {0, 1},  // down\n};\n\nbool solved(const Puzzle& p) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x = i == 2 && j == 2 ? 0 : i * 3 + j + 1;\n            if (p.board[i][j] != x) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    Puzzle start;\n    start.turn = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x;\n            cin >> x;\n            if (x == 0) {\n                start.empty = {i, j};\n            }\n            start.board[i][j] = x;\n        }\n    }\n\n    Puzzle ans;\n    set<Puzzle> visited;\n    queue<Puzzle> Q;\n    Q.push(start);\n    while (!Q.empty()) {\n        auto u = Q.front();\n        Q.pop();\n        if (solved(u)) {\n            ans = u;\n            break;\n        }\n        for (auto& d : dir) {\n            auto tx = u.empty[0] + d[0];\n            auto ty = u.empty[1] + d[1];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            auto v = u;\n            swap(v.board[v.empty[0]][v.empty[1]], v.board[tx][ty]);\n            v.empty = {tx, ty};\n            if (visited.find(v) == visited.end()) {\n                ++v.turn;\n                visited.insert(v);\n                Q.push(v);\n            }\n        }\n    }\n    cout << ans.turn << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define A 3\n#define B 9\n\nstruct puzzle{\n    int f[B];\n    int space;\n    string path;\n    \n    bool operator<(const puzzle &p) const{\n        int i;\n        for(i=0;i<B;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool Target(puzzle p){\n    int i;\n    for(i=0;i<B;i++)\n        if(p.f[i] != (i+1)) return false;\n    return true;\n}\n\nstring bfs(puzzle s){\n    queue<puzzle> Q;\n    map<puzzle,bool>V;\n    puzzle u,v;\n    s.path= \"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u=Q.front();\n        Q.pop();\n        if(Target(u)) return u.path;\n        int sx=u.space/A;\n        int sy=u.space%A;\n        int r;\n        for(r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=A||ty>=A) continue;\n            v=u;\n            swap(v.f[u.space], v.f[tx*A+ty]);\n            v.space=tx*A+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    puzzle in;\n    int i;\n    \n    for(i=0;i<B;i++){\n        cin >> in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=B;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#define N 3\n#define N2 9\nusing namespace std;\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  \n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  printf(\"%lu\\n\",ans.size());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <map>\n#include <queue>\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\n\nconst std::array<std::array<int, 3>, 3> goal({std::array<int, 3>({1, 2, 3}),\n                                              std::array<int, 3>({4, 5, 6}),\n                                              std::array<int, 3>({7, 8, 0})});\n\nint encode(const std::array<std::array<int, 3>, 3>& brd) {\n    int ret = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            ret += ipow(9, i * 3 + j) * brd[i][j];\n        }\n    }\n    return ret;\n}\n\nint main() {\n    std::array<std::array<int, 3>, 3> brd;\n    for (auto& v : brd) {\n        for (auto& e : v) std::cin >> e;\n    }\n\n    std::map<int, int> dp;\n    std::queue<std::array<std::array<int, 3>, 3>> que;\n    que.push(brd);\n    dp[encode(brd)] = 0;\n\n    while (!que.empty()) {\n        auto b = que.front();\n        que.pop();\n        int ope = dp[encode(b)];\n\n        int zx, zy;\n        {\n            bool flag = false;\n            for (zx = 0; zx < 3; ++zx) {\n                for (zy = 0; zy < 3; ++zy) {\n                    if (b[zx][zy] == 0) {\n                        flag = true;\n                        break;\n                    }\n                }\n                if (flag) break;\n            }\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + dx[i], ny = zy + dy[i];\n            if (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny) continue;\n            std::swap(b[zx][zy], b[nx][ny]);\n            int id = encode(b);\n            if (!dp.count(id)) {\n                dp[id] = ope + 1;\n                que.push(b);\n            }\n            std::swap(b[zx][zy], b[nx][ny]);\n        }\n    }\n\n    std::cout << dp[encode(goal)] << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 8ããºã«åé¡ãæ±ã\n *\n * @date 2016/02/29\n */\n\n\n\n//****************************************\n// å¿è¦ãªããããã¡ã¤ã«ã®ã¤ã³ã¯ã«ã¼ã\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\n\n\n//****************************************\n// åã·ããã \n//****************************************\n\nusing array1D = std::vector<int>;\n\n\n//****************************************\n// å¤§åå¤æ°ã®å®ç¾©\n//****************************************\n\nstatic const int N  = 3;                           /**< 3x3ã®ç¤é¢ãèãã */\nstatic const int NN = 9;                           /**< 3x3 = 9 */\nstatic const array1D dx = { -1,  0,  1,  0 };      /**< æ¹åãã¯ãã«ã®xæå */\nstatic const array1D dy = {  0, -1,  0,  1 };      /**< æ¹åãã¯ãã«ã®yæå */\nstatic const char dir[] = { 'l', 'u', 'r', 'd' };  /**< æ¹åãã¯ãã«ã®ã­ã¼ */\n\n\n\n//****************************************\n// æ§é ä½ã®å®ç¾©\n//****************************************\n\nstruct puzzle {\n    array1D state;\n    int space;\n    std::string path;\n\n    puzzle() : state(NN) { }\n\n    /**< @brief <æ¼ç®å­ãªã¼ãã¼ã­ã¼ã */\n    bool operator < (const puzzle& p) const\n    {\n        for (int i = 0; i < NN; i++) {\n            if (state[i] == p.state[i]) { continue; }\n            return state[i] > p.state[i];\n        }\n        return false;\n    }\n\n    /**< @brief []æ¼ç®å­ãªã¼ãã¼ã­ã¼ã */\n    int& operator [] (std::size_t i)\n    {\n        return state[i];\n    }\n\n     /**< @brief ããºã«ã®ç¶æãè§£æ±ºæ¸ã¿ãå¦ãè¿ã  */\n    bool resolved()\n    {\n        for (int i = 0; i < NN; i++) {\n            if (state[i] != (i + 1)) { return false; }\n        }\n        return true;\n    }\n};\n\n\n\n/**< @brief å¹åªåæ¢ç´¢ãè¡ã8ããºã«ãè§£ã */\nstd::string bfs(puzzle s)\n{\n    std::queue<puzzle> Q;      // ããºã«ãæ ¼ç´ããã­ã¥ã¼\n    std::map<puzzle, bool> V;  // ããºã«ãã­ã¼ã¨ããé£æ³éå\n    puzzle u, v;\n\n    auto init  = [&]() -> void      { s.path = \"\"; Q.push(s); V[s] = true; };                     // æç¶ãã¨åæã«å§ç¹sãçºè¦\n    auto visit = [&](int i) -> void { if (!V[v]) { V[v] = true; v.path += dir[i]; Q.push(v);} };  // è¨ªåæ¸ã¿ã®å°ãå»ã\n\n    init();\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (u.resolved()) { return u.path; }  // ããºã«ãè§£æ±ºæ¸ã¿ãªãããã¾ã§ã®æãè¿ã\n        // ç¾å¨ã®ç©ºãã¦ãããã¹ã®åº§æ¨ãåå¾\n        int spaceX = u.space % N;\n        int spaceY = u.space / N;\n        for (int i = 0; i <= N; i++) {  // å·¦ãä¸ãå³ãä¸æ¹åã®é ã«ã«ã¼ããã\n            // ã¿ã¼ã²ããã¨ãªãåº§æ¨ãåå¾\n            int targetX = spaceX + dx[i];\n            int targetY = spaceY + dy[i];\n            // ããºã«ã®ç¯å²å¤ãªãé£æ¥ãã¦ããªãã¨ã¿ãªã\n            if (targetX < 0 || targetX >= N || targetY < 0 || targetY >= N) { continue; }\n            // ä»¥ä¸ãuã®é£æ¥ãªã¹ãã«å±ããããºã«ã®ç¶ævãèãã\n            v = u;\n            std::swap(v[u.space], v[targetY * N + targetX]);    // ããºã«ã®æãé²ãã\n            v.space = targetY * N + targetX;                    // ç©ºãããã¹ãè¨æ¶\n            visit(i);                                           // æªè¨ªåãªãã°ãè¨ªåãã\n        }\n    }\n    return \"unresovable\";\n}\n\n\nint main()\n{\n    using namespace std;\n    puzzle p;\n\n    for (int i = 0; i < NN; i++) {\n        cin >> p[i];\n        if (p[i] == 0) {\n            p[i] = NN;\n            p.space = i;\n        }\n    }\n\n    string ans = bfs(p);\n    cout << ans.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x,sx,sy,g[3][3],dir[4][2]={{-1,0},{0,-1},{0,1},{1,0}};\nstruct node{\n\tint v[3][3],x,y,step;\n};\nmap<string,int> ht;\nint judge(node a){\n\tstring s=\"\";\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tx=a.v[i][j];\n\t\t\ts+=x+'0';\n\t\t}\n\t}\n\tif(!ht[s]){\n\t\tht[s]=1;\n\t\treturn 1;\n\t}\n\telse return 0;\n}\nint check(node a){\n\tint cnt=1,f=1;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(a.v[i][j]==cnt){\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==9) cnt=0;\n\t\t\t}\n\t\t\telse f=0;\n\t\t}\n\t}\n\treturn f;\n}\nvoid bfs(){\n\tqueue<node> q;\n\tnode tmp,tt;\n\ttmp.x=sx,tmp.y=sy,tmp.step=0;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\ttmp.v[i][j]=g[i][j];\n\t\t}\n\t}\n\tjudge(tmp);\n\tq.push(tmp);\n\twhile(!q.empty()){\n\t\ttt=q.front();\n\t\tq.pop();\n\t\tif(check(tt)) {\n\t\t\tprintf(\"%d\\n\",tt.step);\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx=tt.x+dir[i][0];\n\t\t\tint ty=tt.y+dir[i][1];\n\t\t\tif(tx>=0&&tx<3&&ty>=0&&ty<3){\n\t\t\t\ttmp.x=tx,tmp.y=ty,tmp.step=tt.step+1;\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\t\ttmp.v[i][j]=tt.v[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp.v[tt.x][tt.y]=tt.v[tx][ty];\n\t\t\t\ttmp.v[tx][ty]=0;\n\t\t\t\tif(judge(tmp)){\n\t\t\t\t\tq.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}\nint main()\n{\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x==0) {\n\t\t\t\tsx=i,sy=j;\n\t\t\t}\n\t\t\tg[i][j]=x;\n\t\t}\n\t}\n\tbfs();\n } \n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tunordered_map<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle p) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(int moves, int cutoff){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > cutoff)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n\n    REP(i, 100){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n        pq = priority_queue <board>();\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n#include <sstream>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\nconst ll MD = 1000000007LL;\n\nstruct Board{\n\tvector<vint> v;\n    ll _hash;\n\n\tBoard(vector<vint> v){\n\t\tthis->v = v;\n        _hash = hash();\n\t}\n\n\tvector<Board> transition(){\n\t\tvector<Board> ret;\n\n\t\tvint dx{1, 0, -1, 0};\n\t\tvint dy{0, 1, 0, -1};\n\n\t\tint x0 = 0, y0 = 0;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tif(v[y][x] == 0) {x0 = x; y0 = y;}\n\t\t}\n\n\t\trep(d, 4){\n\t\t\tint xn = x0 + dx[d];\n\t\t\tint yn = y0 + dy[d];\n\t\t\tif(xn >= 0 && xn < 3 && yn >= 0 && yn < 3){\n\t\t\t\tvector<vint> vv = v;\n\t\t\t\tvv[yn][xn] = v[y0][x0];\n\t\t\t\tvv[y0][x0] = v[yn][xn];\n\t\t\t\tret.push_back(Board(vv));\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tll hash() const{\n\t\tll ret = 0;\n\t\tll m = 1;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tret += v[y][x] * m;\n\t\t\tm *= 10;\n\t\t}\n        return ret;\n\t}\n\n\tbool operator < (const Board &p) const {\n        ll h1 = _hash;\n        ll h2 = p._hash;\n\t\treturn h1 < h2;\n\t}\n\n\tbool operator == (const Board &p) const{\n        ll h1 = _hash;\n        ll h2 = p._hash;\n        return h1 == h2;\n\t}\n};\n\nint main() {\n\tvector<vint> v0;\n\trep(y, 3){\n\t\tvint v;\n\t\trep(x, 3) { int n; cin >> n; v.push_back(n);}\n\t\tv0.push_back(v);\n\t}\n\tBoard b0 = Board(v0);\n\n\tvector<vint> ve;\n\tvint ve1{1, 2, 3}; ve.push_back(ve1);\n\tvint ve2{4, 5, 6}; ve.push_back(ve2);\n\tvint ve3{7, 8, 0}; ve.push_back(ve3);\n\tBoard be = Board(ve);\n\n\tset<Board> S;\n\tqueue<pair<Board, int>> q;\n\n\tq.push(make_pair(b0, 0));\n    // fprintf(stderr, \"%09lld\\n\", b0.hash());\n    // fprintf(stderr, \"%09lld\\n\", be.hash());\n\n\twhile(true){\n\t\tauto p = q.front(); q.pop();\n\t\tBoard b = p.first;\n\t\tint t = p.second;\n\n        S.find(b);\n        S.end();\n\t\tif(S.find(b) != S.end()) continue;\n        S.insert(b);\n        // fprintf(stderr, \"%09lld %d\\n\", b.hash(), t);\n\n\t\tif(b == be) {cout << t << endl; return 0;}\n\n\t\tvector<Board> trans = b.transition();\n\t\tfor(Board bb: trans){\n\t\t\tq.push(make_pair(bb, t+1));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define BOARD_N 3\n\nint board[BOARD_N][BOARD_N];\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint min_depth;\n\nvoid dfs(int a[BOARD_N][BOARD_N], int maxdepth, int depth)\n{\n\tif (maxdepth == depth)\n\t{\n\t\tbool ok = true;\n\n\t\tfor (int i = 0; i < BOARD_N * BOARD_N - 1; i++)\n\t\t{\n\t\t\tif (a[i / BOARD_N][i % BOARD_N] != i + 1)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tmin_depth = maxdepth;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint x, y;\n\n\tfor (int i = 0; i < BOARD_N; i++)\n\t{\n\t\tfor (int j = 0; j < BOARD_N; j++)\n\t\t{\n\t\t\tif (a[i][j] == 0)\n\t\t\t{\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tint b[BOARD_N][BOARD_N];\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tif (0 <= x + dx[dir] && dx[dir] < BOARD_N && 0 <= y + dy[dir] && y + dy[dir] < BOARD_N)\n\t\t{\n\t\t\tfor (int i = 0; i < BOARD_N; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < BOARD_N; j++)\n\t\t\t\t{\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswap(b[y][x], b[y + dy[dir]][x + dx[dir]]);\n\n\t\t\tdfs(b, maxdepth, depth + 1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmin_depth = 100;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> board[i][j];\n\n\tfor (int i = 0; i < 45; i++)\n\t{\n\t\tdfs(board, i, 0);\n\n\t\tif (min_depth != 100) { break; }\n\t}\n\n\tcout << min_depth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Puzzle{\n    int f[9];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p)const{\n        for(int i=0;i<9;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]<p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle &p){\n    for(int i=0;i<9;i++){\n        if(p.f[i]!=i+1) return false;\n    }\n    return true;\n}\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nstring bfs(Puzzle &s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n    while(!Q.empty()){\n        u=Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/3;\n        int sy=u.space%3;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>2||ty>2){\n                continue;\n            }\n            v=u;\n            swap(v.f[u.space],v.f[tx*3+ty]);\n            v.space=tx*3+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle x;\n    for(int i=0;i<9;i++){\n        cin>>x.f[i];\n        if(x.f[i]==0){\n            x.f[i]=9;\n            x.space=i;\n        }\n    }\n\n    cout<<(bfs(x)).size()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst char rd[4]={'d','u','r','l'};\nstruct gg{\n\tint mp[9];\n\tint space;\n\tstring path;\n\tbool operator<(const gg &tmp)const\n\t{\n\t\tfor(register int i=0;i<=8;i++)\n\t\t   {\n\t\t   \tif(mp[i]!=tmp.mp[i])return mp[i]>tmp.mp[i];\n\t\t   }\n\t\treturn false;   \n\t}\n};map<gg,bool>vis;\ninline void bfs(gg bg)\n{   queue<gg> q;\n\tgg now,tmp;register int x,y;\n\tvis[bg]=1;\n\tq.push(bg);\n\twhile(!q.empty())\n\t{   \n\t\tnow=q.front();q.pop();\n\t\ty=now.space/3;x=now.space-y-y-y;\n\t\tfor(register int i=0;i<=3;i++)\n\t\t   {\n\t\t     tmp=now;\n\t\t     if(x+dx[i]<0||x+dx[i]>2||y+dy[i]<0||y+dy[i]>2)continue;\n\t\t     tmp.space=x+dx[i]+y+dy[i]+y+dy[i]+y+dy[i];\n\t\t     swap(tmp.mp[x+y*3],tmp.mp[x+dx[i]+y+dy[i]+y+dy[i]+y+dy[i]]);\n\t\t     tmp.path+=rd[i];\n\t\t     if(!vis[tmp])vis[tmp]=1,q.push(tmp);\n\t\t   }\n\t}\t\t \n}\nint main()\n{ \n\tgg bg,ans;char c;string s;\n\tbg.mp[0]=1;bg.mp[1]=2;bg.mp[2]=3;bg.mp[3]=4;bg.mp[4]=5;bg.mp[5]=6;bg.mp[6]=7;bg.mp[7]=8;bg.mp[8]=0;bg.space=8;bg.path=\"\";bfs(bg);  \n\t for(register int i=0;i<=8;i++)\n\t   {scanf(\" %c\",&c);\n\t   \tif(c=='x')bg.space=i,bg.mp[i]=0;\n\t   \telse bg.mp[i]=c-48;}   \n\tbg.path=\"\";\n\tmap<gg,bool>::iterator pos=vis.find(bg);\n\tif(pos!=vis.end())\n \t  {s=pos->first.path;printf(\"%d\",s.length());}//or(int i=s.length()-1;i!=-1;i--)printf(\"%c\",s[i]);}\n    else cout<<\"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 500009\n#define int long long\nusing namespace std;\nstruct st {\n  int puzzle[3][3],cnt,x0,y0;\n};\nint dx[] = { -1,0,1,0 }, dy[] = { 0,-1,0,1 };\nint used[M];\nint fhash(int x) {\n  for (int i = 1;; ++i) \n    if (used[i*x%M] == 0 || used[i * x % M] == x) return i;\n}\nsigned main() {\n  struct st p;\n  p.cnt = 0;\n  for (int i = 0; i < 3; ++i)\n    for (int j = 0; j < 3; ++j) {\n      cin >> p.puzzle[i][j];\n      if (p.puzzle[i][j] == 0) { p.x0 = j; p.y0 = i; }\n    }\n  int head = 0, tail = 0;\n  struct st que[M];\n  que[tail++] = p;\n  while (head != tail) {\n    p = que[head%M]; ++head;\n    int flag = 1;\n    for (int i = 0; i < 3; ++i)\n      for (int j = 0; j < 3; ++j)\n\tif (p.puzzle[i][j] != (3 * i + j + 1) % 9) flag = 0;\n    if (flag) {\n      cout << p.cnt << endl;\n      return 0;\n    }\n    int x = 0, k = 1;\n    for (int i = 2; i >= 0; --i)\n      for (int j = 2; j >= 0; --j, k *= 10) x += p.puzzle[i][j] * k;\n    int y = fhash(x);\n    if (used[y*x%M] == x) continue;\n    used[y*x%M] = x;\n    for (int i = 0; i < 4; ++i) {\n      if (p.x0 + dx[i] >= 0 && p.x0 + dx[i] < 3 && p.y0 + dy[i] >= 0 && p.y0 + dy[i] < 3) {\n\tstruct st q;\n\tfor (int i = 0; i < 3; ++i)\n\t  for (int j = 0; j < 3; ++j) q.puzzle[i][j] = p.puzzle[i][j];\n\tint tmp;\n\ttmp = q.puzzle[p.y0][p.x0];\n\tq.puzzle[p.y0][p.x0] = q.puzzle[p.y0+dy[i]][p.x0+dx[i]];\n\tq.puzzle[p.y0 + dy[i]][p.x0 + dx[i]] = tmp;\n\tq.cnt = p.cnt + 1; q.x0 = p.x0 + dx[i]; q.y0 = p.y0 + dy[i];\n\tque[tail%M] = q; ++tail;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int field[N2];\n  int blank;\n  int count;\n\n  bool operator < (const Puzzle &p) const {\n    int i;\n    \n    for (i = 0; i < N2; i++) {\n      if (field[i] == p.field[i]) continue;\n      return field[i] > p.field[i];\n    }\n    return false;\n  }\n};\n\nbool isTrue(Puzzle p);\nint bfs(Puzzle s);\n\nint x[4] = {-1, 0, 1, 0};\nint y[4] = {0, -1, 0, 1};\n\nint main() {\n  Puzzle input;\n  int i;\n\n  for (i = 0; i < N2; i++) {\n    cin >> input.field[i];\n    if (input.field[i] == 0) {\n      input.field[i] = N2;\n      input.blank = i;\n    }\n  }\n\n  cout << bfs(input) << endl;\n\n  return 0;\n}\n\nbool isTrue(Puzzle p) {\n  int i;\n  \n  for (i = 0; i < N2; i++) {\n    if (p.field[i] != i + 1) return false;\n  }\n  return true;\n}\n\nint bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  int x1, y1, x2, y2, i;\n  s.count = 0;\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    if (isTrue(u)) return u.count;\n    x1 = u.blank / N;\n    y1 = u.blank % N;\n    for (i = 0; i < 4; i++) {\n      x2 = x1 + x[i];\n      y2 = y1 + y[i];\n      if (!(x2 >= 0 && y2 >= 0 && x2 < N && y2 < N)) continue;\n      v = u;\n      swap(v.field[u.blank], v.field[x2 * N + y2]);\n      v.blank = x2 * N + y2;\n      if (!V[v]) {\n\tV[v] = true;\n\tv.count++;\n\tQ.push(v);\n\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\n\nusing namespace std;\n\n#define TEST //*******************************************************************************************************************************************\n//?????????????????Â¨??Â§?????\\????????????????????????????????Â°?????????????Â¨???????????????????dout???????????????????????Â§???????????Â¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????Â§?CPU???????Â£??????????????????Â§???TLE?????????????????????????????????????????Â§????????Â¨???                           ????????????????????????cerr????????Â£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#define din cin\n#else\nstringstream dummy; //???????????Â°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????Â¨?????Â¢?????Â¢???????????????\n//???????????Â¨??????????????????goodbit?????????????????????????????Â¨???????????Â´????????????????????????????????Â¨?????Â°?????????????????Â§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile //??Â¨????????????TLE????????Â§?????????dout?????Â¨??Â¨??????????????Â¢????????????????????????????????????????????Â§????Â¨????????????Â´??????????????Â£??????????????????????Â¨?????????????????????????????????????????????Â§?????????????????????\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nstruct d {int n, m, r, l;}; //for Binary Search Tree\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int INF = 2e9+10;\nconst ll INF_LL = 1e18; //Be careful for overflow.\nconst int NONE = -1;\nconst int SUCCESSFUL = -2;\n\n#define GOAL 123456780\n//int numOfMove = -1; //?????Â°\nll numOfSearch = 0;\n\n#define N_MAX 100000//876543210 //num of vertex or element\n#define M_MAX 10000 //num of edge\n\nint N;\n\nstruct d T[N_MAX+1]; //Binary Search Tree\nint H = 0; //num of data in T[]. next new data will be placed on T[H]\n\nqueue<pii> Q; // <puzzle, numOfMove>\n\n\nvoid printInorder(int i) {\n    if(i==NONE) return;\n    \n    printInorder(T[i].l);\n    dout << \" \" << T[i].n;\n    printInorder(T[i].r);\n}\nvoid printPreorder(int i) {\n    if(i==NONE) return;\n    \n    dout << \" \" << T[i].n;\n    printInorder(T[i].l);\n    printInorder(T[i].r);\n}\nvoid print() {\n    printInorder(0);\n    dout << endl;\n    printPreorder(0);\n    dout << endl;\n}\n\nbool find(int x, int i=0) {\n    \n    if(i==NONE) return 0;\n    if(T[i].n==x) return 1;\n    \n    if(x < T[i].n) return find(x, T[i].l);\n    else return find(x, T[i].r);\n    \n}\n\n\nvoid insert(int x, int i=0) { //insert x at T[i]\n\n    if(T[i].n==INF) {\n        T[i].n = x;\n//        T[i].m = numOfMove; //Binary Search Tree?????Â°????????Â¶????????????????????Â¨?????????????????????????????Â¶????????????????????Â¨???????????Â°????Â¨????????????????\n        H++;\n        return;\n    }\n    \n    if(x < T[i].n) {\n        if(T[i].l==NONE) T[i].l=H;\n        insert(x, T[i].l);\n    }\n    else {\n        if(T[i].r==NONE) T[i].r=H;\n        insert(x, T[i].r);\n    }\n    \n}\n\nvoid puzzle_int2array(int puzzle, int p[]) {\n    int digit = 1e8;\n    rep(i,0,9) {\n        p[i] = puzzle/digit;\n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\nint puzzle_array2int(int p[]) {\n    int puzzle = 0;\n    int digit = 1e8;\n    rep(i,0,9) {\n        puzzle += p[i]*digit;\n        digit /= 10;\n    }\n    \n    return puzzle;\n}\n\n\n\n\n\nvoid display(int puzzle) {\n    int digit = 1e8;\n    \n    for(int i=8; i>=0; i--) {\n        dout << puzzle/digit << \" \";\n        if(i%3==0) dout << endl;\n        \n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\n\n\nvoid solve(int puzzle, int numOfMove=0) {\n    \n    Q.push(make_pair(puzzle, numOfMove));\n    \n    while( !Q.empty() ) {\n        \n        puzzle = Q.front().first;\n        numOfMove = Q.front().second;\n        Q.pop();\n        \n        if( find(puzzle) ) continue; //??Â¢??\\?????Â¶?????Â§????????Â°????????????\n        \n        insert(puzzle);\n\n        \n//        dout << \"-----------------\\n\";\n//        disp(++numOfSearch);\n//        disp(numOfMove);\n//        display(puzzle);\n        \n        if(puzzle == GOAL) {\n            dout << numOfMove << endl;\n            return;\n        }\n        \n        int p[9];\n        puzzle_int2array(puzzle,p);\n        \n        \n        //find 0\n        int zero=NONE;\n        rep(i,0,9) {\n            if( p[i] == 0 ) {\n                zero = i;\n                break;\n            }\n        }\n        assert(zero!=NONE); //0 must be found\n        \n        \n        //move 0 to 4 direction\n        numOfMove++;\n        \n        int alt;\n        \n        alt = zero - 3;\n        if(0<=alt && alt<=8) {\n//            disp(-3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero - 1;\n        if(0<=alt && alt<=8 && zero%3!=0) { //0??????????????Â´?????????????????????\n//            disp(-1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        \n        alt = zero + 1;\n        if(0<=alt && alt<=8 && zero%3!=2) { //0??????????????Â´?????????????????????\n//            disp(1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero + 3;\n        if(0<=alt && alt<=8 ) {\n//            disp(3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n    } //end of while-loop\n    \n}\n\n\n\n\nint main() {\n    \n    //initialize\n    rep(i,0,N_MAX+1) {\n        T[i].n = INF;\n        T[i].l = T[i].r = NONE;\n    }\n    \n    int puzzle = 0;\n    int digit = 1e8;\n\n    int p;\n    rep(i,0,9) {\n            din >> p;\n            puzzle += digit * p;\n            digit /= 10;\n    }\n    \n    \n//    display(puzzle);\n    \n    solve(puzzle, 0);\n\n    \n\n    \n    \n    \n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdlib.h>\n#include <limits.h>\n#include <unordered_map>\n#include <string>\n#include <map>\n#include <sstream>\n#include <cstdlib> \nusing namespace std;\n\n#define INF     INT_MAX\n#define SIZE  9\n#define WIDTH 3\n\n#define LEFT  0\n#define RIGHT 1\n#define UP    2\n#define DOWN  3\n\ntypedef struct{\n  int            dist;        // accumulated distance fromt start board \n  int            evaluation;\n  bool           visited;     // default: false\n} v_t;\n\nmap< string, v_t >  Node; // Key: cell hash, Value: node\nvoid assert(vector<int> v);\n\nbool Move[SIZE][4];\nvoid initMove(){\n  // Can Move Right?\n  Move[0][RIGHT]=Move[1][RIGHT]=Move[3][RIGHT]=Move[4][RIGHT]=Move[6][RIGHT]=Move[7][RIGHT]=true;\n  Move[2][RIGHT]=Move[5][RIGHT]=Move[8][RIGHT]=false;\n  // Can Move Left?\n  Move[1][LEFT]=Move[2][LEFT]=Move[4][LEFT]=Move[5][LEFT]=Move[7][LEFT]=Move[8][LEFT]=true;\n  Move[0][LEFT]=Move[3][LEFT]=Move[6][LEFT]=false;\n  // Can Move Up?\n  Move[3][UP]=Move[4][UP]=Move[5][UP]=Move[6][UP]=Move[7][UP]=Move[8][UP]=true;\n  Move[0][UP]=Move[1][UP]=Move[2][UP]=false;\n  // Can Move Down?\n  Move[0][DOWN]=Move[1][DOWN]=Move[2][DOWN]=Move[3][DOWN]=Move[4][DOWN]=Move[5][DOWN]=true;\n  Move[6][DOWN]=Move[7][DOWN]=Move[8][DOWN]=false;\n}\n\nmultimap< int, string > Q;   // Key: dist + evaluation , Value: cell hash\nstring hashkey(vector<int> cell){\n  string hash;\n  for(const auto& e: cell){\n    hash += to_string(e) + \",\";\n  }\n  return hash;\n}\n\nvector<string> split(const string &str, char sep)\n{\n  vector<string> v;\n  stringstream ss(str);\n  string buffer;\n  while( getline(ss, buffer, sep) ) {\n      v.push_back(buffer);\n  }\n  return v;\n}\nvector<int> dehash(string hash){\n  vector<int> cell;\n  vector<string> board = split(hash, ',');\n  for(const auto& e : board){\n    cell.push_back(stoi(e));\n  }\n  return cell;\n}\n\nint estimateH(vector<int> cell){\n  int hr = 0; // heuristic\n  for(int i = 0 ; i < SIZE ; i++){\n    if(cell[i] == 0){\n      cell[i] = SIZE;\n    }\n    hr += abs( (cell[i]-1)%WIDTH - i%WIDTH );\n    hr += abs( (cell[i]-1)/WIDTH - i/WIDTH );\n  }\n\treturn hr;\n}\n\nvector<int> updateGQ(vector<int> curCell,int space, int dir){\n  const string curHash = hashkey(curCell);\n  vector<int> nextCell(curCell);\n  int moveto = space + dir; // move to = space(0) + direction\n  nextCell[space] = nextCell[moveto];\n  nextCell[moveto] = 0;\n  const string nextHash = hashkey(nextCell); \n  if( !Node[nextHash].visited ){\n    Node[nextHash].visited = true;\n  \tNode[nextHash].dist = Node[curHash].dist + 1;\n   \tNode[nextHash].evaluation = estimateH(nextCell);\n    int dist_ev = 1 + Node[curHash].dist + Node[curHash].evaluation;\n\t\tQ.insert(make_pair(dist_ev, nextHash));\n  }\n  return nextCell;\n}\n\nvoid move(vector<int> curCell){\n  for(int i = 0 ; i < SIZE ; i++ ){\n    vector<int> resultCell;\n    if(curCell[i] == 0){\n      if(Move[i][LEFT]){\n        resultCell = updateGQ(curCell, i, -1); \n      }\n      if(Move[i][RIGHT]){\n        resultCell = updateGQ(curCell, i, 1 ); \n      }\n      if(Move[i][UP]){\n        resultCell = updateGQ(curCell, i, -3); \n      }\n      if(Move[i][DOWN]){\n        resultCell = updateGQ(curCell, i, 3); \n      }\n    }\n  }\n  return;\n}\n\nvoid assert(vector<int> v){ // for debug\n  int i = 0;\n\tfor(auto itr = v.begin() ; itr != v.end(); ++itr){\n    fprintf(stderr, \"%d \"  ,*itr);\n    i++;\n    if(i==3){\n      i = 0;\n      fprintf(stderr, \"\\n\");\n    }\n  }\n}\n\nint main(){ // Dijkstra P.254\n  vector<int> cell(SIZE); // current cell\n  const vector<int> goalCell = {1,2,3,4,5,6,7,8,0};\n  const string goalHash = hashkey(goalCell);\n  initMove();\n \n  //  insert First node\n  for(int i = 0 ; i < SIZE ; i++){\n    int num;\n    scanf(\"%d\" ,&num);\n    cell[i] = num;\n  }\n  v_t firstNode = {0, 0, true};\n  Node[hashkey(cell)] = firstNode;\n\tQ.insert( make_pair(0, hashkey(cell)) );\n  move(cell);\n  auto itr = Q.begin();\n  Q.erase(itr);\n\n  while(!Q.empty()){\n    if( Node[goalHash].visited ){\n      break;\n    }\n    auto itr = Q.begin();\n    string curHash = itr->second;\n    Q.erase(itr);\n    cell = dehash(curHash);\n    move(cell);\n  }\n\n  printf(\"%d\\n\" ,Node[goalHash].dist );\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tunordered_map<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tint val=calc(v);\n\t\tunordered_map<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tunordered_map<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 3\n#define MAX2 9\n\nusing namespace std;\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < (Puzzle &p){\n  int i;\n    for(i = 0; i < MAX2; i++){\n      if( f[i] == p.f[i] ){\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstring bfs(Puzzle);\nbool isTarget(Puzzle);\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for(i = 0; i < MAX2; i++){\n    if( p.f[i] != (i+1) ){\n      return false;\n    }\n  }\n  return true;\n}//end of isTarget func\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i = 0; i < MAX2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] == MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}//end of main func\n\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  \n  int r,tx,ty;\n  int sx,sy;\n  int tmp;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ){\n      return u.path;\n    }\n    sx = u.space / MAX;\n    sy = u.space % MAX;\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX){\n        continue;\n      }\n      v = u;\n      /*swap*/\n      tmp = v.f[u.space];\n      v.f[u.space] = v.f[tx * MAX + ty];\n      v.f[tx * MAX + ty] = tmp;\n\n      v.space = tx * MAX + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n#include <stdio.h>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i<N2;i++){\n\t\tif(p.f[i] != (i+1)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile(!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif(tx<0 || ty<0 || tx >=N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space = tx * N +ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\n\t\t\n\nint main(void){\n\t\n\tint i;\n\tPuzzle in;\n\tstring ans;\n\n\tfor(i=0;i<N2;i++){\n\t\tscanf(\"%d\",&in.f[i]);\n\t\tif(in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tans = bfs(in);\n\tprintf(\"%lu\\n\",ans.size());\n\n\treturn 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n\nint search(int);\nint translate(std::array<int, 9>);\n\nstruct BoardStatus {\n\tstd::array<int, 9> arrange = {};\n\tint distance = 0;\n\tint zero_position = 8;\n};\n\nint main()\n{\n\tstd::array<int, 9> board;\n\tfor (int i = 0; i < 9; ++i)\n\t\tstd::cin >> board[i];\n\n\tstd::cout << search(translate(board)) << std::endl;\n\n\treturn 0;\n}\n\nint search(int dest_num)\n{\n    if (dest_num == 46233) return 0;\n    \n\tBoardStatus board;\n\tboard.arrange = { 1, 2, 3, 4, 5, 6, 7, 8, 0};\n\tboard.distance = 0;\n\tboard.zero_position = 8;\n\t\n\tstd::vector<BoardStatus> queue;\n\tqueue.push_back(board);\n\tint pre_size = 0;\n\tint table[362880] = { };\n\n\tint move_direction[4] = { 1, -1, 3, -3 };\n\n\twhile (pre_size != queue.size())\n\t{\n\t\tint now_size = queue.size();\n\t\tfor (int queue_i = pre_size; queue_i < now_size; ++queue_i)\n\t\t{\n\t\t\tint zero_pos = queue[queue_i].zero_position;\n\t\t\tbool can_move[4] = {\n\t\t\t\tzero_pos % 3 != 2, zero_pos % 3 != 0,\n\t\t\t\tzero_pos / 3 != 2, zero_pos / 3 != 0\n\t\t\t};\n\t\t\tfor (int condi_i = 0; condi_i < 4; ++condi_i)\n\t\t\t{\n\t\t\t\tif (!can_move[condi_i]) continue;\n\n\t\t\t\tboard = queue[queue_i];\n\t\t\t\tint next_zero = zero_pos + move_direction[condi_i];\n\n\t\t\t\tboard.arrange[board.zero_position] = board.arrange[next_zero];\n\t\t\t\tboard.arrange[next_zero] = 0;\n\t\t\t\tboard.zero_position = next_zero;\n\t\t\t\tboard.distance++;\n\n\t\t\t\tint num_board = translate(board.arrange);\n\t\t\t\tif (!table[num_board] && num_board != 46233)\n\t\t\t\t{\n\t\t\t\t\ttable[num_board] = board.distance;\n\t\t\t\t\tqueue.push_back(board);\n\t\t\t\t}\n\t\t\t\tif (num_board == dest_num)\n\t\t\t\t\treturn board.distance;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint translate(std::array<int , 9> board)\n{\n\tbool used[9]{};\n\tint count = 0, tmp, ret = 0, fac = 362880;\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tcount = 0;\n\t\ttmp = board[i];\n\t\tfor (int j = 0; j < tmp; ++j)\n\t\t\tif (!used[j])\n\t\t\t\tcount++;\n\t\tused[tmp] = true;\n\t\tfac /= 9 - i;\n\t\tret += fac * count;\n\t}\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator<(const Puzzle& p) const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic char dir[4] = { 'u','l','d','r' };\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++) {\n\t\tif (p.f[i] != (i + 1)) return false;\n\t}\n\treturn true;\n}\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) swap(tmp[p], tmp[q]);\n            else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n\n            int num;\n            if (N < 4) num = state.state[q] - '1';\n            else num = stoi(state.state.substr(2 * q, 2)) - 1;\n            // calcurate manhattan distance\n            int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n            + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n            if (manhattan == 0) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 + manhattan > boundary) continue; // estimate value is over boundary\n            find = h2_dfs(boundary, State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break;\n        }\n    }\n    return find;\n}\n\nint ids_h2(string state, int manhattan, P blank) {\n    int i = manhattan, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h2_dfs(i, State{0, manhattan, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h2(state, manhattan, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false);\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) scanf(\"%d\", &original[i]);\n    int move = solve();\n    printf(\"%d\\n\", move);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n \nusing namespace std;\n \n#define RY 3\n#define N 9\n \ntypedef struct board {\n  int hira[N];\n  int maru;\n  vector<int> path;\n \n  bool operator < (const board &t) const {\n    for (int i = 0; i < N; i++) {\n      if (hira[i] == t.hira[i]) continue;\n      else if (hira[i] < t.hira[i]) return true;\n      else return false;\n    }\n    return false;\n  }\n} cubic;\n\nint xx[4] = { 0, 1, 0, -1 };\nint yy[4] = { 1, 0, -1, 0 };\n \nbool fingoal(cubic b) {\n  for (int i = 0; i < N-1; i ++)\n    if (b.hira[i] != i+1) return false;\n \n  return true;\n}\n \nvoid meltd(cubic b) {\n  map<cubic, bool> visited;\n  queue<cubic> q;\n  q.push(b);\n \n  while (!q.empty()) {\n    cubic bcur = q.front(); q.pop();\n    visited[bcur] = true;\n \n    if (fingoal(bcur)) {\n      cout << bcur.path.size() << endl;\n      return;\n    }\n \n    for (int i = 0; i < 4; i ++) {\n      cubic b = bcur;\n      int nx = (bcur.maru / RY) + xx[i];\n      int ny = (bcur.maru % RY) + yy[i];\n \n      if (nx < 0 || nx > 2 || ny < 0 || ny > 2) continue;\n \n      b.maru = nx * RY + ny;\n      swap(b.hira[b.maru], b.hira[bcur.maru]);\n \n      if (visited[b]) continue;\n \n      b.path.push_back(b.maru);\n      q.push(b);\n    }\n  }\n}\n \nint main() {\n  cubic b;\n \n  for (int i = 0; i < N; i++) {\n    cin >> b.hira[i];\n    if (b.hira[i] == 0) b.maru = i;\n  }\n \n  meltd(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <string>\n#include <cassert>\nusing namespace std;\nconst int num = 9, ud[] = { -1, 0, 1, 0 }, lr[] = { 0, -1, 0, 1 }, nd = 3;\nconst char wa[] = { 'u', 'l', 'd', 'r' };\nstruct puzzle {\n\tint sp, p[num];\n\tstring way;\n\tbool operator < (const puzzle &pu) const {\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (p[i] == pu.p[i]) continue;\n\t\t\treturn p[i] < pu.p[i];\n\t\t}\n\t\treturn false;\n\t}\n};\ninline bool fin(puzzle pu) {\n\tfor (int i = 0; i < num; i++)\n\t\tif (pu.p[i] != i + 1) return false;\n\treturn true;\n}\ninline string bfs(puzzle pu) {\n\tqueue<puzzle> q;\n\tmap <puzzle, bool> m;\n\tq.push(pu);\n\tm[pu] = true;\n\tpuzzle x, y;\n\tint row, col, ns, ro, co;\n\twhile (!q.empty()) {\n\t\tx = q.front(); q.pop();\n\t\tif (fin(x)) return x.way;\n\t\tro = x.sp / nd;\n\t\tco = x.sp % nd;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\trow = ro + ud[i];\n\t\t\tcol = co + lr[i];\n\t\t\tif (row >= nd || row < 0 || col >= nd || col < 0) continue;\n\t\t\ty = x;\n\t\t\tns = row*nd + col;\n\t\t\tswap(y.p[x.sp], y.p[ns]);\n\t\t\ty.sp = ns;\n\t\t\tif (!m[y]) {\n\t\t\t\tm[y] = true;\n\t\t\t\ty.way += wa[i];\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tpuzzle fi;\n\tfor (int i = 0; i < num; i++) {\n\t\tcin >> fi.p[i];\n\t\tif (!fi.p[i]) { \n\t\t\tfi.sp = i; \n\t\t\tfi.p[i] = num;\n\t\t}\n\t}\n\tcout << bfs(fi).size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, vv.size()) {\n        REP(j, vv[i].size()) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / __gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 0) return 1;\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\n#define INF 1e8\n\nstruct edge {int u, v, cost;};\n\nvector<edge> g;\nVI par, rnk;\n\nint root(int x) {\n    if(par[x] == x) return x;\n    else return par[x] = root(par[x]);\n}\n\nint same(int x, int y) {\n    x = root(x);\n    y = root(y);\n    return x == y;\n}\n\nvoid unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(rnk[x] > rnk[y]) {\n        par[y] = x;\n    } else {\n        par[x] = y;\n        if(rnk[x] == rnk[y]) rnk[y]++;\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    VVI b(3, VI(3));\n    REP(i, 3) REP(j, 3) cin >> b[i][j];\n    VVI c = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n    if(b == c) {cout << 0 << endl; return 0;}\n    map<VVI, int> mb;\n    queue<VVI> q;\n    q.push(b);\n    while(!q.empty()) {\n        auto p = q.front();\n        q.pop();\n        int i, j;\n        REP(_i, 3) REP(_j, 3) if(p[_i][_j] == 0) {\n            i = _i;\n            j = _j;\n        }\n        if(i > 0) {\n            VVI c(p);\n            swap(c[i-1][j], c[i][j]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(i < 2) {\n            VVI c(p);\n            swap(c[i][j], c[i+1][j]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(j > 0) {\n            VVI c(p);\n            swap(c[i][j-1], c[i][j]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(j < 2) {\n            VVI c(p);\n            swap(c[i][j], c[i][j+1]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(mb[{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}]) {\n            cout << mb[{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}] << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\n//queue<state> q;\n//vector<state> q;\nlist<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n//    board |= static_cast<long long>(num) << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n//    for (queue<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n//    q.push(s);\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n//    q.push({ board, 0 });\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n//        q.pop();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 3) {\n            if (pos < 2) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 0) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else if (pos < 6) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 5) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 3) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 8) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 6) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint cnt = 0;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tint solver() {\n\t\tconst arr end = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n\t\t\tif (a.b == end)\n\t\t\t\treturn a.cnt;\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n  if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx =u.space/N;\n    int sy =u.space%N;\n    for(int r=0;r<4;r++){\n      int tx =sx+dx[r];\n      int ty =sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path+=dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans =bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n    int i;\n\n    bool operator < (const Puzzle &p) const\n    {\n        int i;\n        for(i=0;i<N2;i++)\n        {\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n    int i;\n\n    for(i=0;i<N2;i++)\n    {\n       if(p.f[i] != (i+1)) return false;\n    }\n       return true; \n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty())\n    {\n        u = Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r=0;r<4;r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space],v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n\n}\n\nint main()\n{\n    Puzzle in;\n\n    for(int i=0;i<N2;i++)\n    {\n        cin >> in.f[i];\n        if(in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty() ){\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n\tv.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\t \t\t  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\n\tarr b;\n\tpos p;\n\tint f, g, h;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tg = 0;\n\t\tf = h = hn(b);\n\t}\n\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tstatic int hn(const arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint k = a[i][j] ? a[i][j] - 1 : size * size - 1;\n\t\t\t\tl += abs(i - k / size) + abs(j - k % size);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tstatic int key(const arr &a) {\n\t\tint k = 0;\n\t\tfor (auto &r: a)\n\t\t\tfor (int c: r)\n\t\t\t\tk = (k * 10) + c;\n\t\treturn k;\n\t}\n\n\tint solver() {\n\t\tstatic const pos to[] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\t\tunordered_set<int> m;\n\t\tpriority_queue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.top();\n\t\t\tq.pop();\n\t\t\tint k = key(a.b);\n\t\t\tif (m.count(k))\n\t\t\t\tcontinue;\n\t\t\tm.insert(k);\n\t\t\tif (!a.h)\n\t\t\t\treturn a.g / 2;\n\t\t\tfor (pos o: to) {\n\t\t\t\to.r += a.p.r, o.c += a.p.c;\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.g += 2;\n\t\t\t\t\tc.h = hn(c.b);\n\t\t\t\t\tc.f = c.g + c.h;\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nbool operator < (const board &a, const board &b) {\n\treturn a.f > b.f;\n}\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  s8 =   int8_t;\nusing  u8 =  uint8_t;\nusing s16 =  int16_t;\nusing u16 = uint16_t;\nusing s32 =  int32_t;\nusing u32 = uint32_t;\nusing s64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// é©å®èª¿æ´\n//#define int s64\n//#define double long double\n\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr bool STDIO_ENABLE = false;\n\nconstexpr int IOS_PREC = 10;\n\nconstexpr int INF_S32 =             1'010'000'000;\nconstexpr s64 INF_S64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_S64;\nconstexpr double EPS = 1e-9;\n\nconstexpr s64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayStruct {\n    using type = array<typename ArrayStruct<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayStruct<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t N, size_t... NS>\nusing Array = typename ArrayStruct<T,N,NS...>::type;\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool is_even(T x) {\n    return x % 2 == 0;\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) {\n    return (x > y) - (x < y);\n}\n\ntemplate<typename T>\nconstexpr int sgn(T x) {\n    return cmp(x, T(0));\n}\n\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n    assert(b >= 0);\n    T res(1);\n    for(T i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n    return a/b + !!(a%b);\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n    return a/b;\n}\n\ntemplate<typename T, typename U>\nconstexpr auto modulo(T a, U b) {\n    using R = common_type_t<T,U>;\n    assert(b > 0);\n    R r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(x > hi)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T>\nT isqrt(T x) {\n    assert(x >= 0);\n    return static_cast<T>(sqrt(static_cast<long double>(x)));\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(x > xmax) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\ntemplate<typename T>\narray<pair<T,T>,4> neighbor4(const T& x, const T& y) {\n    return array<pair<T,T>,4> {{\n                    { x, y-1 },\n        { x-1, y },             { x+1, y },\n                    { x, y+1 },\n    }};\n}\n\ntemplate<typename T>\narray<pair<T,T>,8> neighbor8(const T& x, const T& y) {\n    return array<pair<T,T>,8> {{\n        { x-1, y-1 }, { x, y-1 }, { x+1, y-1 },\n        { x-1, y   },             { x+1, y   },\n        { x-1, y+1 }, { x, y+1 }, { x+1, y+1 },\n    }};\n}\n\ntemplate<typename T>\nbool in_bounds(const T& x, const T& minx, const T& maxx) {\n    return !(x < minx) && !(maxx < x);\n}\n\ntemplate<typename T>\nbool in_bounds_2(\n    const T& x,    const T& y,\n    const T& minx, const T& miny,\n    const T& maxx, const T& maxy) {\n    return in_bounds(x, minx, maxx) && in_bounds(y, miny, maxy);\n}\n\ntemplate<typename T>\nbool in_bounds_wh(const T& x, const T& y, const T& w, const T& h) {\n    return in_bounds_2(x, y, 0, 0, w-1, h-1);\n}\n\nstruct pairhash {\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t res = 17;\n        res = 31*res + hash<T1>()(p.first);\n        res = 31*res + hash<T2>()(p.second);\n        return res;\n    }\n};\n\nstruct vectorhash {\n    template<typename T>\n    size_t operator()(const vector<T>& v) const {\n        size_t res = 17;\n        res = 31*res + hash<size_t>()(v.size());\n        for(const auto& e : v) {\n            res = 31*res + hash<T>()(e);\n        }\n        return res;\n    }\n};\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef DEBUG\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\n// åºå {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    for(InputIt it = first; it != last; ++it) {\n        if(it != first) out << ' ';\n        out << *it;\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef DEBUG\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1æ¬¡åçéå {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef DEBUG\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2æ¬¡åçéå {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef DEBUG\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// émapã³ã³ãã {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\n// ç¹å¥æ±ã\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// ç¹å¥æ±ã\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c) {\n    return out << set<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c) {\n    return out << multiset<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n// }}}\n\n// mapã³ã³ãã {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef DEBUG\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c) {\n    return out << map<K,V>(cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c) {\n    return out << multimap<K,V>(cbegin(c), cend(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&) {\n    return out;\n}\n\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t) {\n    if(Pos != 0)\n        out << ',';\n    out << get<Pos>(t);\n    return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    out << '(';\n    FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n    out << ')';\n    return out;\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef DEBUG\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef DEBUG\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    if(STDIO_ENABLE)\n        fflush(stdout);\n    else\n        cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef DEBUG\n    fflush(stdout);\n    fflush(stderr);\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef DEBUG\n        cin.tie(nullptr);\n        if(!STDIO_ENABLE)\n            ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n\n        if(AUTOFLUSH) {\n            if(STDIO_ENABLE)\n                setvbuf(stdout, nullptr, _IONBF, 0);\n            cout << unitbuf;\n        }\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(s64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n// }}}\n\nusing Board = vector<int>;\n\nunordered_map<Board,bool,vectorhash> M;\n\nBoard INI;\n\nbool is_ok(const Board& board) {\n    static constexpr int OK[9] = {\n        1, 2, 3,\n        4, 5, 6,\n        7, 8, 0,\n    };\n\n    return ALL(equal, board, begin(OK));\n}\n\nvector<Board> neighbor(const Board& board) {\n    vector<Board> res;\n\n    int pos = ALL(argfind, board, 0);\n    int pos_x = pos % 3;\n    int pos_y = pos / 3;\n    for(const auto& p : neighbor4(pos_x, pos_y)) {\n        int x,y; tie(x,y) = p;\n        if(x < 0 || 3 <= x || y < 0 || 3 <= y) continue;\n        Board b(board);\n        int pos2 = 3*y + x;\n        swap(b[pos], b[pos2]);\n        res.emplace_back(b);\n    }\n\n    return res;\n}\n\nint bfs() {\n    queue<pair<Board,int>> que;\n    M[INI] = true;\n    que.emplace(make_pair(INI,0));\n\n    while(!que.empty()) {\n        Board board;\n        int turn;\n        tie(board,turn) = POP(que);\n\n        if(is_ok(board)) return turn;\n\n        for(const auto& b : neighbor(board)) {\n            if(M[b]) continue;\n            M[b] = true;\n            que.emplace(make_pair(b,turn+1));\n        }\n    }\n\n    return -1;\n}\n\nvoid solve() {\n    int ans = bfs();\n    PRINTLN(ans);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    INI.resize(9);\n    REP(i, 9) {\n        int a; RD(a);\n        INI[i] = a;\n    }\n\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs(((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN)) - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const {\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool itarget(Puzzle x){\n  for(int i=0;i<N2;i++)\n    if(x.f[i]!=(i+1))return false;\n    return true;\n  }\n\n  string bfs(Puzzle a){\n    queue<Puzzle>Q;\n    map<Puzzle, bool>V;\n    Puzzle u, v;\n    a.path=\"\";\n    Q.push(a);\n    V[a]=true;\n\n    while(!Q.empty()){\n      u=Q.front(); Q.pop();\n      if(itarget(u))return u.path;\n      int xx=u.space/N;\n      int xy=u.space%N;\n\n      for(int k=0;k<4;k++){\n\tint yx=xx+dx[k];\n\tint yy=xy+dy[k];\n\tif(yx<0 || yy<0 || yx >=N || yy>=N)continue;\n\tv=u;\n\tswap(v.f[u.space],v.f[yx*N+yy]);\n\tv.space=yx*N+yy;\n\tif(!V[v])\n\t  {\n\t    V[v]=true;\n\t    v.path+=dir[k];\n\t    Q.push(v);\n\t  }\n      }\n    }\n    return \"unsolvable\";\n  }\n  \n\nint main(){\n  Puzzle n;\n  for(int i=0;i<N2;i++){\n    cin>>n.f[i];\n    if(n.f[i]==0){\n      n.f[i]=N2;\n      n.space=i;\n    }\n  }\n  string ans=bfs(n);\n  cout<<ans.size()<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[40000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>27) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator<(const Puzzle &p)const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic const char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++)\n\t\tif (p.f[i] != (i + 1))return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space%N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N + ty]);\n\t\t\tv.space = tx*N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n      return res;\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint limit;\nint cost;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\n\nstruct state {\n    int puzzle[9];\n    int space;\n    int cost;\n    int evaluation;\n\n    bool operator < (const state &s) const {\n        return evaluation > s.evaluation;\n    }\n};\n\n\nint goal[9] = {1, 2, 3,\n               4, 5, 6,\n               7, 8, 0};\n\n\nbool IsGoal(state s) {\n    for (int i = 0; i < 9; i++) {\n        if (s.puzzle[i] != goal[i]) return false;\n    }\n    return true;\n}\n\n\nvector<state> closed;\n\nbool IsSamePuzzle(state s1, state s2){\n    for (int i = 0; i < 9; i++) {\n        if (s1.puzzle[i] != s2.puzzle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool InClosed(state s){\n    for (int i = 0; i < closed.size(); i++) {\n        if (IsSamePuzzle(s, closed[i])) return true;\n    }\n    return false;\n}\n\n\nint h2(state s) {\n    int res = 0;\n    for (int i = 0; i < 9; i++) {\n        if (s.puzzle[i] == 0) continue;\n\n        int px = (s.puzzle[i] - 1) / 3;\n        int py = (s.puzzle[i] - 1) % 3;\n\n        int x = i / 3;\n        int y = i % 3;\n\n        res += abs(x - px) + abs(y - py);\n    }\n    return res;\n}\n\n\nint astar(state s) {\n    priority_queue<state> pq;\n    pq.push(s);\n\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n\n        if (IsGoal(st)) {\n            return st.cost;\n        }\n\n        closed.push_back(st);\n\n        int px = st.space / 3;\n        int py = st.space % 3;\n\n        for (int i = 0; i < 4; i++) {\n            int x = px + dx[i];\n            int y = py + dy[i];\n\n            if (x < 0 || y < 0 || x >= 3 || y >= 3) continue;\n\n            state next = st;\n            swap(next.puzzle[st.space], next.puzzle[x * 3 + y]);\n            next.space = x * 3 + y;\n\n            if (!InClosed(next)) {\n                next.cost++;\n                next.evaluation = next.cost + h2(next);\n                pq.push(next);\n            }\n        }\n    }\n\n    return -1;\n}\n\n\nint main() {\n    state init;\n\n    for (int i = 0; i < 9; i++) {\n        cin >> init.puzzle[i]; \n        if (init.puzzle[i] == 0) init.space = i;\n    }\n    init.cost = 0;\n    init.evaluation = init.cost + h2(init);\n\n    cout << astar(init) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\n#define N (3)\n#define N2 (N*N)\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n\tfor ( int i = 0; i < N2; i++ ) {\n\t    if ( f[i] == p.f[i] ) continue;\n\t    return ( f[i] < p.f[i] );\n\t}\n\t//return false;\t\t// ????????????????????Â´???????????\\????????????\n        return true;\n    }\n};\n\n// x, y?????????????????Â£??????\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget( Puzzle p ) {\n    for ( int i = 0; i < N2; i++ ) {\n\tif ( p.f[i] != ( i + 1 ) ) return false;\n    }\n    return true;\n}\n\nstring bfs( Puzzle s ) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push( s );\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget( u ) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\t\n\tfor ( int r = 0; r < 4; r++ ) {\n\t    int tx = sx + dx[r];\n\t    int ty = sy + dy[r];\n\n\t    if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t    v = u;\n\t    swap( v.f[u.space], v.f[tx * N + ty] );\n\t    v.space = tx * N + ty;\n\t    if ( !V[v] ) {\n\t\tV[v] = true;\n\t\tv.path += dir[r];\n\t\tQ.push( v );\n\t    }\n\t}\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n\tscanf(\"%d\", &in.f[i]);\n\tif ( in.f[i] == 0 ) {\n\t    in.f[i] = N2;\n\t    in.space = i;\n\t}\n    }\n    string ans = bfs( in );\n\n    printf(\"%d\\n\", (int)ans.size());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n     int f[N2];\n     int space;\n     string path;\n     bool operator < ( const Puzzle &p ) const {\n         for ( int i = 0; i < N2; i++ ) {\n        if ( f[i] == p.f[i] ) continue;\n        return f[i] > p.f[i];\n             \n         }\n        return false;\n         \n     }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nbool isTarget(Puzzle p) {\n    for ( int i = 0; i < N2; i++ )\n        if ( p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for ( int r = 0; r < 4; r++ ) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n    \n}\nint main() {\n    Puzzle in;\n    for ( int i = 0; i < N2; i++ ) {\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ) {\n            in.f[i] = N2; // set space\n            in.space = i;\n            \n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (p2 == lastboard)\n\t\t\t\t{\n\t\t\t\t\treturn p1.second;\n\t\t\t\t}\n\n\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tr1/unordered_set>\n#include<cstring>\nusing namespace std;\nbool done[40000000];\nint m[10]={1};\nint f;\nlong long ans=0;\nint zon[10]={1,2,3,4,5,6,7,8,0};\nint fx[4]={1,-1,3,-3};\nint wz[10]={8,0,1,2,3,4,5,6,7};\ntr1::unordered_set<long long> s;\nvoid dfs(int use,long long sm,int tot){\n    if(use>tot || s.count(sm) || f) return;\n    if(ans==sm){\n        f=1;\n        return;\n    }\n    s.insert(sm);\n    long long dt[9],p,ssm;\n    for(int i=8;i>=0;i--){\n        dt[i]=sm/m[i];\n        sm-=m[i]*dt[i];\n        if(dt[i]==0) p=i;\n    }\n    int u=0;\n    for(int i=1;i<9;i++){\n        u+=abs(i%3-wz[dt[i]]%3)+abs(i/3-wz[dt[i]]/3);\n    }\n    if(u+use*2>tot*2) return;\n    for(int i=0;i<4;i++){\n        if(p+fx[i]<0||p+fx[i]>15) continue;\n        dt[p]=dt[p+fx[i]];\n        dt[p+fx[i]]=0;\n        ssm=0;\n        for(int i=0;i<9;i++) ssm+=dt[i]*m[i];\n        dfs(use+1,ssm,tot);\n        dt[p+fx[i]]=dt[p];\n        dt[p]=0;\n    }\n}\nint main(){\n    int dt[9];\n    for(int i=1;i<9;i++){\n        m[i]=m[i-1]*9;\n    }\n    long long sm=0;\n    for(int i=0;i<9;i++){\n        cin>>dt[i];\n        sm+=dt[i]*m[i];\n    }\n    for(int i=0;i<9;i++){\n        ans+=zon[i]*m[i];\n    }\n    for(int i=0;i<1000;i++){\n        s.clear();\n        dfs(0,sm,i);\n        if(f){\n            cout<<i<<\"\\n\";\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n  int f[9];\n  int t;\n  int st;\n  bool operator < (const P &p) const{\n    for(int i=0;i<9;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nint main(){\n  P in;\n  map<P,bool> V;\n  queue<P> Q;\n  for(int i=0;i<9;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0)in.st=i;\n  }\n  in.t=0;\n  Q.push(in);\n  while(!Q.empty()){\n    P top=Q.front();\n    Q.pop();\n    if(!V[top]){\n      V[top]=true;\n      int flag=0;\n      for(int i=0;i<9;i++)if((i+1)%9!=top.f[i])flag=1;\n      if(!flag){\n\tcout<<top.t<<endl;\n\tbreak;\n      }\n      int st=top.st;\n      top.t++;\n      P tmp;\n      if(st-3>=0){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st-3]);\n\ttmp.st-=3;\n\tQ.push(tmp);\n      }\n      if(st+3<9){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st+3]);\n\ttmp.st+=3;\n\tQ.push(tmp);\n      }\n      if(st%3!=2){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st+1]);\n\ttmp.st++;\n\tQ.push(tmp);\n      }\n      if(st%3!=0){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st-1]);\n\ttmp.st--;\n\tQ.push(tmp);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ****************************************************************************\n// C header\n// ****************************************************************************\n#include <cmath>\n// ****************************************************************************\n// C++ header\n// ****************************************************************************\n#include <iostream>\n// ****************************************************************************\n// STL library\n// ****************************************************************************\n#include <queue>\n#include <set>\n// ****************************************************************************\n// MACRO\n// ****************************************************************************\n#define N       3\n#define FINITE  123456780\n// ****************************************************************************\n// STRUCT\n// ****************************************************************************\ntypedef struct _State {\n    int v[N][N];\n    int cnt;\n    int x, y;\n} State;\n// ****************************************************************************\n// PROTOTYPE\n// ****************************************************************************\nint hash ( int state[][N] );\nint solve( int state[][N] );\n// ****************************************************************************\n// GLOBAL VARIABLE\n// ****************************************************************************\nstd::set< int > hset;\n// ****************************************************************************\n// FUNCTIONS\n// ****************************************************************************\nint hash( int state[][N] ) {\n    int res=0, k=8;\n    for (int i=0; i<N; ++i) {\n        for (int j=0;j<N; ++j) {\n            res += state[i][j] * pow(10, k);\n            --k;\n        }\n    }\n    return res;\n}\n\nint solve( int state[][N] ) {\n    int dx[] = {-1,  0,  1,  0},\n        dy[] = { 0, -1,  0,  1};\n    std::queue< State > que;\n    while ( !que.empty() ) que.pop();\n    State s;\n    for (int i=0; i<N; ++i) {\n        for (int j=0; j<N; ++j) {\n            s.v[i][j] = state[i][j];\n            if (state[i][j] == 0) {\n                s.x = i;\n                s.y = j;\n            }\n        }\n    }\n    s.cnt = 0;\n    que.push( s );\n\n    while ( !que.empty() ) {\n        s = que.front();\n        int h = hash( s.v );\n\n        if ( h == FINITE ) break;\n\n        if (hset.find( h ) == hset.end()) {\n            hset.insert( h );\n\n            for (int i=0; i<4; ++i) {\n                int x=s.x+dx[i], y=s.y+dy[i];\n                if (0<=x && x<N && 0<=y && y<N) {\n                    State tmp = s;\n                    std::swap( tmp.v[s.x][s.y], tmp.v[x][y] );\n                    tmp.x = x;\n                    tmp.y = y;\n                    ++tmp.cnt;\n                    que.push( tmp );\n                }\n            }\n        }\n        que.pop();\n    }\n    return que.front().cnt;\n}\n// ****************************************************************************\n// MAIN FUNCTION\n// ****************************************************************************\nint main() {\n    int state[N][N];\n    for (int i=0; i<N; ++i) {\n        for (int j=0; j<N; ++j) {\n            std::cin >> state[i][j];\n        }\n    }\n    std::cout << solve( state ) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it == history.end()) {\n        history.insert(make_pair(s.board, ' '));\n        q.push_back(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\nusing Weight=int;\nusing Encoded=int;\n\nstruct State {\n    Weight hcost, acost;\n    Encoded encoded;\n    State() {}\n    State(Weight h, Weight a, Encoded e): hcost(h), acost(a), encoded(e) {}\n    bool operator>(const State & state2) const {\n        if (hcost+acost != state2.hcost+state2.acost) {\n            return hcost+acost > state2.hcost+state2.acost;\n        } else {\n            return acost > state2.acost;\n        }\n    }\n};\n\nconst Weight INF=1<<29;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nEncoded encode(vector<int> d) {\n    int cur=0;\n    Encoded enc=0;\n    for (size_t i=0; i<d.size()-1; ++i) {\n        cur = d[i];\n        for (size_t j=i+1; j<d.size(); ++j)\n            if (cur < d[j])\n                --d[j];\n\n        (enc += d[i]) *= d.size()-i-1;\n    }\n\n    return enc;\n}\n\nvector<int> decode(Encoded e) {\n    vector<int> d(9);\n    for (size_t i=1; i<=9; ++i) {\n        d[9-i] = e % i;\n        e /= i;\n    }\n\n    for (size_t i=9; i--;)\n        for (size_t j=i+1; j<9; ++j)\n            if (d[i] <= d[j])\n                ++d[j];\n\n    return d;\n}\n\nWeight heucost(Encoded start, Encoded end) {\n    static const vector<int> dend=decode(end);\n    vector<int> dstart=decode(start);\n\n    Weight h=0;\n    for (size_t i=0; i<9; ++i)\n        for (size_t j=0; j<9; ++j)\n            if (dstart[i] == dend[j]) {\n                h += abs(i/3-j/3)+abs(i%3-j%3);\n                break;\n            }\n\n    return h;\n}\n\nvector<pair<Weight, Encoded>> pmoves(Encoded cur) {\n    vector<int> d=decode(cur);\n    size_t i;\n    for (i=0; d[i]; ++i);\n\n    vector<pair<Weight, Encoded>> p;\n    if (i/3 < 2) {\n        swap(d[i], d[i+3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+3]);\n    }\n    if (i/3 > 0) {\n        swap(d[i], d[i-3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-3]);\n    }\n    if (i%3 < 2) {\n        swap(d[i], d[i+1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+1]);\n    }\n    if (i%3 > 0) {\n        swap(d[i], d[i-1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-1]);\n    }\n    return p;\n}\n\nWeight astar(Encoded start, Encoded end) {\n    lp_queue<State> q;\n    q.push(State(heucost(start, end), 0, start));\n\n    Weight opt=INF;\n    vector<bool> visited(362881);\n    while (!q.empty()) {\n        State p=q.top(); q.pop();\n        Weight cur_cost=p.acost;\n        Encoded cur_state=p.encoded;\n        visited[cur_state] = true;\n\n        if (opt < cur_cost) continue;\n        if (cur_state == end)\n            if (opt > cur_cost)\n                opt = cur_cost;\n\n        vector<pair<Weight, Encoded>> ms=pmoves(cur_state);\n        for (pair<Weight, Encoded> m: ms) {\n            if (visited[m.second]) continue;\n\n            q.push(State(heucost(m.second, end), cur_cost+m.first, m.second));\n        }\n    }\n\n    return opt;\n}\n\nint main() {\n    vector<int> d(9);\n    for (size_t i=0; i<9; ++i)\n        scanf(\"%d\", &d[i]);\n\n    Encoded e=encode(d);\n\n    Weight c=astar(e, 46233);\n    printf(\"%d\\n\", c);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define NUM 3\n\ntypedef struct STATUS{\n    int num;                    //????????????????????????????????Â°\n    int board[NUM * NUM];       //?????Â¢?????Â¶???\n    int x,y;                    //?????Â¢???0???????????????????????Â§?Â¨?\n}STATUS;\n\nbool checked[9*8*7*6*5*4*3*2*1];\n\n/* ?????Â¢?????Â¶????????????????????? */\nint change_number( int *board )\n{\n    int work[NUM*NUM];\n    static int fact_table[NUM*NUM] = {\n        40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n    };\n    int j, k, value = 0;\n    memcpy( work, board, sizeof(int)*NUM*NUM );\n    for( j = 0; j < NUM*NUM - 1; j++ ){\n        value += fact_table[j] * work[j];\n        for( k = j + 1; k < NUM*NUM; k++ ){\n            if( work[j] < work[k] ) work[k]--;\n        }\n    }\n    return value;\n}\n\n\nint search(STATUS in){\n    \n    int x = 0, y = 0;\n    int chk_num,goal_num;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    int goal[9] = {1,2,3,4,5,6,7,8,0};\n    STATUS out;\n    goal_num = change_number(goal);\n    \n    //?????Â¢?????Â¶????????????????????????????????\\???\n    queue<STATUS> qu;\n    qu.push(in);\n    \n    //?????\\???????????????????????Â§?Â¶???????\n    while (!qu.empty()) {\n        \n        in = qu.front();\n        qu.pop();\n        chk_num = change_number(in.board);\n        if (goal_num == chk_num){\n            return in.num;\n        }\n        else{\n            checked[chk_num] = true;\n        }\n        for (int i = 0; i < 4; i++) {\n            //?????Â¢???0???????????????????????Â§?Â¨????x,y???????????????\n            x = in.x;\n            y = in.y;\n            if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n                memcpy(&out, &in, sizeof(STATUS));\n                swap(out.board[NUM*y + x], out.board[NUM*(y+dy[i]) + x + dx[i]] );\n                \n                chk_num = change_number(out.board);\n                if (checked[chk_num] == true){\n                    continue;\n                }\n                else{\n                    out.num++;\n                    out.x = x + dx[i];\n                    out.y = y + dy[i];\n                    qu.push(out);\n                }\n            }\n        }\n    }\n    \n    //?????Â¢???goal?????Â°??????????????Â£?????Â´??????-1?????????\n    return -1;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i*NUM +j] = val;\n            if (val == 0){\n                init.x = j;\n                init.y = i;\n            }\n        }\n    }\n    \n    ans = search(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9][9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 7)\n            k += (tiles[i+2] * pow(10, i));\n        for(int i = searched[tiles[0]][tiles[1]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][tiles[1]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]][tiles[1]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false);\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        if(target.wrongs == 0)\n            return target.cost;\n        pq.pop();\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#include<map>\n#include<queue>\n#define Max 9\nint gg[Max]={1,2,3,4,5,6,7,8,0}, s[Max];\n\nint ff[4][2] = {0,-1,1,0,0,1,-1,0};\nint sum;\nstruct node\n{\n\tint a[Max];\n\tint step;\n};\nmap<int ,int >m;\n\n\nint bfs()\n{\n\tnode tt;\n\tmemcpy(tt.a,s,sizeof(s));\n\ttt.step = 0;\n\tqueue<node > q;\n\tq.push(tt);\n\twhile(!q.empty())\n\t{\n\t\tnode star = q.front();\n\t\tq.pop();\n\t\tint i;\n\t\tfor(i = 0;i<9;i++)\n\t\t\tif(star.a[i]==0)\n\t\t\t\tbreak;\n\t\tint y = i/3;\n\t\tint x = i%3;\n\t\tfor(i = 0;i<4;i++)\n\t\t{\n\t\t\tint tx = x + ff[i][0];\n\t\t\tint ty = y + ff[i][1];\n\t\t\tif(tx >= 0&&ty>=0&&ty<3&&tx<3)\n\t\t\t{\n\t\t\t\tnode end;\n\t\t\t\tmemcpy(end.a,star.a,sizeof(star.a));\n\t\t\t\tint k = ty*3+tx;\n\t\t\t\tswap(end.a[k],end.a[y*3+x]);\n\t\t\t\tint sum1 = 0;\n\t\t\t\tfor(int j = 0;j<9;j++)\n\t\t\t\t\tsum1 = sum1*10+end.a[j];\n\t\t\t\tif(!m[sum1])\n\t\t\t\t{\n\t\t\t\t\tm[sum1] = sum++;\n\t\t\t\t\tend.step = star.step+1;\n\t\t\t\t\tif(memcmp(end.a,gg,sizeof(gg))==0)\n\t\t\t\t\t\treturn end.step;\n\t\t\t\t\tq.push(end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j;\n\n\twhile(~scanf(\"%d\",&s[0]))\n\t{\n\t\tm.clear();\n\t\tint k = s[0];\n\t\tsum = 1;\n\t\tfor(i = 1;i<9;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tk = k*10+s[i];\n\t\t}\n\t\tm[k] = sum++;\n\t\tif(memcmp(s,gg,sizeof(gg)==0))\n\t\t\tprintf(\"0\\n\");\n\t\telse printf(\"%d\\n\",bfs());\n\t\t\n\t}\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0;i < N2;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0;i < N2;i++){\n    if(p.f[i] != (i + 1))return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0;i < N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) \n        if (p.f[i] != (i + 1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint getcost(int i, int j, int tmp)\n{\n    return abs(i - (tmp - 1) / 3) + abs(j - (tmp - 1) % 3);\n}\n\nbool solve(vector<vector<int> > puzzle, int cutoff, int cost)\n{\n    priority_queue<pair<int, vector<vector<int> > > > qu;\n    qu.push(make_pair(-cost, puzzle));\n    while(!qu.empty()){\n        vector<vector<int> > now = (qu.top()).second;\n        int nowcost = (qu.top()).first;\n        qu.pop();\n        int h = 0;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                int tmp = now[i][j];\n                if(tmp != 0) h += getcost(i, j, tmp); \n            }\n        }\n        // cout << nowcost << endl;\n        if(h == 0){\n            return true;\n        }\n        for(int i = 0; i < 4; i++){\n            for(int j = 0; j < 4; j++){\n                // cout << now[i][j] << \" \";\n                if(now[i][j] == 0){\n                    int dx[4] = {0, 1, 0, -1};\n                    int dy[4] = {1, 0, -1, 0};\n                    for(int k = 0; k < 4; k++){\n                        int nx = i + dx[k];\n                        int ny = j + dy[k];\n                        if(nx < 0 || ny < 0 || nx >= 3 || ny >= 3) continue;\n                        int nowc = getcost(nx, ny, now[nx][ny]);\n                        int nextc = getcost(i, j, now[nx][ny]);\n                        // cout << now[nx][ny] << \" \" << nextc - nowc << endl;\n                        nowcost -= nextc - nowc + 1;\n                        swap(now[i][j], now[nx][ny]);\n                        if(-nowcost <= cutoff) qu.push(make_pair(nowcost, now));\n                        swap(now[i][j], now[nx][ny]);\n                        nowcost += nextc - nowc + 1;\n                    }\n                    i = 5;\n                    break;\n                }\n            }\n            // cout << endl;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    vector<vector<int> > puzzle(3);\n    int cost = 0;\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            int tmp;\n            cin >> tmp;\n            puzzle[i].push_back(tmp);\n            if(tmp != 0) cost += getcost(i, j, tmp);\n        }\n    }\n    // cout << cost << endl;\n    for(int i = cost; ; i++){\n        if(solve(puzzle, i, cost)){\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define b 3\n#define n2 9\n\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char dir[4]={'u','l','d','r'};\n\nstruct puzzle{\n    int f[n2];\n    int space;\n    string path;\n    bool operator < (const puzzle &p)const {\n        for(int i=0;i<n2;i++){\n            if(f[i]==p.f[i]){\n                continue;\n            }\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nbool istarget(puzzle p)\n{\n    for(int i=0;i<n2;i++){\n        if(p.f[i]!=(i+1)){\n            return false;\n        }\n    }\n    return true;\n}\n\nstring bfs(puzzle s)\n{\n    queue<puzzle>q;\n    map<puzzle,bool>V;\n    puzzle u,v;\n    s.path=\"\";\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        u=q.front();\n//        for(int i=0;i<n2;i++){\n//            cout<<u.f[i]<<\" \";\n//        }\n//        cout<<endl;\n        q.pop();\n        if(istarget(u)){\n            return u.path;\n        }\n        int sx=u.space/b;\n        int sy=u.space%b;\n//        cout<<sx<<\" \"<<sy<<endl;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=b||ty>=b){\n                continue;\n            }\n            v=u;\n            v.space=tx*b+ty;\n            swap(v.f[v.space],v.f[u.space]);\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    puzzle in;\n    for(int i=0;i<n2;i++){\n        scanf(\"%d\",&in.f[i]);\n        if(in.f[i]==0){\n            in.f[i]=n2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n/*\n1 3 0\n4 2 5\n7 8 6\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p)const{\nfor(int i=0;i<N2;i++){\nif(f[i]==p.f[i])continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1))return false;\nreturn true;\n}\nstring bfs(Puzzle s){\nqueue<Puzzle>Q;\nmap<Puzzle,bool>V;\nPuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\nwhile(!Q.empty()){\n  u=Q.front();\n  Q.pop();\n  if(isTarget(u))return u.path;\n  int sx=u.space/N;\n  int sy=u.space%N;\n  for(int r=0 ; r<4 ; r++){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n    v=u;\n    swap(v.f[u.space], v.f[tx*N+ty]);\n    v.space=tx*N+ty;\n    if(!V[v]){\n      V[v]=true;\n      v.path+=dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0 ; i<N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n    in.f[i]=N2;\n    in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 50\n\n#define MAX 500000000\nchar passed[MAX];\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\nint rtnindex(STATUS in){\n    \n    int ret = 0;\n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            ret += val*in.board[i][j];\n            val *= 9;\n        }\n    }\n    return ret;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            int rtn = rtnindex(out);\n            if (passed[rtn] == 1) {\n                continue;\n            }\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n            passed[rtn] = 1;\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    for (int i = 0; i < MAX; i++) passed[i] = 0;\n    \n    passed[rtnindex(init)] = 1;\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t\t\t\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tint val=calc(v);\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3,NN=9;\nconst int dx[4]={0,1,-1,0};\nconst int dy[4]={1,0,0,-1};\nstruct Puz{\n\tint mp[NN],space,path;\n\tbool operator<(const Puz &p)const{\n\t\tfor(int i=0;i<NN;i++){\n\t\t\tif(mp[i]==p.mp[i]) continue;\n\t\t\treturn mp[i]>p.mp[i];\n\t\t}\n\t\treturn false;\n\t}\t\n};\nbool solved(Puz p){\n\tfor(int i=0;i<NN;i++) if(p.mp[i]!=(i+1)) return false;\n\treturn true;\n}\nint bfs(Puz s){\n\tmap<Puz,bool>tab;\n\tqueue<Puz>Q;\n\tPuz u,v;\n\ts.path=0;\n\ttab[s]=true;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(solved(u)) return u.path;\n\t\tint sx=u.space/N,sy=u.space%N;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx=sx+dx[i],ty=sy+dy[i];\n\t\t\tv=u;\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\tswap(v.mp[u.space],v.mp[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!tab[v]){\n\t\t\t\tv.path++;\n\t\t\t\ttab[v]=true;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tPuz src;\n\tfor(int i=0;i<NN;i++){\n\t\tscanf(\"%d\",&src.mp[i]);\n\t\tif(src.mp[i]==0){\n\t\t\tsrc.mp[i]=NN;\n\t\t\tsrc.space=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs(src));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) swap(tmp[p], tmp[q]);\n            else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n\n            if (tmp == ans_str) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 > boundary) continue; // estimate value is over boundary\n            find = h0_dfs(boundary, State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break; // find an answer\n        }\n    }\n    return find;\n}\n\nint ids_h0(string state, P blank) {\n    int i = 1, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h0_dfs(i, State{0, 0, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h0(state, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H=3,W=3;\nset<vector<vector<short>>> memo;\n\nstruct STATE {\n    int f;\n    int g;\n    vector<vector<short>> b;\n\n    bool operator < (const STATE& tgt) const {\n\treturn f > tgt.f; // ?Â¨????\n    }\n};\ninline bool is_searched(const STATE& s) {\n    return (memo.find(s.b) != memo.end());\n}\ninline void searched(const STATE& s) {\n    memo.insert(s.b);\n}\ninline bool is_goal(const STATE& s) {\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    if( i == H-1 and j == W-1 )  return true;\n\t    if( s.b[i][j] != (i*W)+j+1 ) return false;\n\t}\n    }\n}\n\ninline void where0(const STATE& s, int& h, int& w) {\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    if( s.b[i][j] == 0 ) {\n\t\th = i;\n\t\tw = j;\n\t    }\n}\n\ninline int manhattan_dis(const int tgt, const int h, const int w) {\n    if(tgt == 0 ) return 0;\n    int tgt_h = (tgt-1)/W;\n    int tgt_w = (tgt-1)%W;\n    return abs(tgt_h - h) + abs(tgt_w - w);\n}\n\ninline int heuristic(const vector<vector<short>>& b) {\n    int ans = 0;\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    ans += manhattan_dis(b[i][j],i,j);\n\t}\n    }\n    return ans;\n}\n\nconst int dx[] = { 1, 0,-1, 0}; \nconst int dy[] = { 0, 1, 0,-1};\ninline vector<STATE> adjcency(const STATE& cur) {\n    int h,w;   where0(cur,h,w);\n    vector<STATE> ans;\n    vector<vector<short>> b = cur.b;\n    \n    for(int i=0; i<4; i++) { // 4??????\n\tint nh = h+dy[i], nw = w+dx[i];\n\tif( nh >= 0 and nh < H and nw >= 0 and nw < W ) {\n\t    swap(b[nh][nw], b[h][w]);\n\t    int heu = heuristic(b);\n//\t    if( cur.g+1+heu <= 24 )\n\t\tans.push_back( STATE{cur.g+1+heu, cur.g+1, b} );\n\t    swap(b[nh][nw], b[h][w]);\n\t}\n    }\n    return ans;\n}\n    \nSTATE astar(const STATE& init) {\n    \n    priority_queue<STATE> pq;              // ?????????????Â°?????????????????????????????????????\n    pq.push(init);                         // ????????? STATE ????????Â£??????\n    \n    while( pq.size() ) {                   // ?????\\???????????????????????Â§????????Â§???\n\tSTATE cur = pq.top(); pq.pop();    // ?????Â£??Â¨????????????????????Â¶??????????????Â§???\n\tif( is_searched(cur) ) continue;   // ??????????????Â¢?Â´Â¢????????Â§...\n\tif( is_goal(cur) ) return cur;     // ??Â´??????????????Â´????????????\n\n\tsearched(cur);                     // cur ?????Â¢?Â´Â¢???????????Â¨????????????????????????\n\t\n\tfor(STATE& next : adjcency(cur)) { // ?????????????????Â¨?????????????????Â§???\n\t    if( is_searched(next) ) continue;\n\t    pq.push(next);\n\t}\n    }\n    // ???????????\\?????Â£??????????????Â¨??????...????????????????????Â£?????Â£????????Â¨???...\n    return init;\n}\n\nint main() {\n\n//    cin >> H >> W;\n    vector<vector<short>> b(H,vector<short>(W));\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) cin >> b[i][j];\n\n    int h = heuristic(b);\n    STATE init{h,0,b};\n    \n    STATE lst = astar(init);\n    cout << lst.g << endl;\n\n//    cout << memo.size() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nstruct Info{\n\tInfo(){data = count = 0;}\n\tInfo(long long arg_data,int arg_count){\n\t\tdata = arg_data;\n\t\tcount = arg_count;\n\t}\n\tlong long data;\n\tint count;\n};\n\nclass LongQ{\npublic:\n\tLongQ(){\n\t\tQ = new Info[362880];\n\t\thead = tail = num_of_data=0;\n\t}\n\n\tvoid enqueue(long long arg_data,int arg_count){\n\t\tQ[tail].count = arg_count;\n\t\tQ[tail].data = arg_data;\n\t\tnum_of_data++;\n\t\ttail = (tail+1)%362880;\n\t}\n\n\tInfo dequeue(){\n\t\tInfo ret = Q[head];\n\t\thead = (head+1)%362880;\n\t\tnum_of_data--;\n\t\treturn ret;\n\t}\n\n\tbool isEmpty(){\n\t\treturn num_of_data == 0;\n\t}\n\nprivate:\n\tInfo* Q;\n\tint head,tail,num_of_data;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tLongQ queue;\n\n\tqueue.enqueue(makeLong(table),0);\n\n\tInfo tmpInfo;\n\n\twhile(true){\n\t\ttmpInfo=queue.dequeue();\n\n\t\tint tmpTable[3][3];\n\t\tsetNUM(tmpTable,tmpInfo.data);\n\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\tprintf(\"%d\\n\",tmpInfo.count);\n\t\t\tbreak;\n\t\t}\n\n\t\tint next_table[4][3][3];\n\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(zeroLoc(tmpTable)){\n\t\tcase 0: //??????\n\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t//??????\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[3])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[3]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<unordered_set>\nusing namespace std;\n\nconst int D_x[4] = { 0,1,0,-1 };\nconst int D_y[4] = { 1,0,-1,0 };\nconst int ANS = 123456780;\n\nvoid setNum(int puzzle[3][3],int n) {\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\tpuzzle[i][j] = n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t}\n}\n\nint getNum(int puzzle[3][3]) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tres *= 10;\n\t\t\tres += puzzle[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid find_0(int puzzle[3][3], int& x, int& y) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (puzzle[i][j] == 0) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int puzzle[3][3]) {\n\tqueue<int> q;\n\tunordered_set<int> table;\n\tint cnt = 1;\n\n\tq.push(getNum(puzzle));\n\tif (q.front() == ANS)return 0;\n\twhile (true) {\n\t\tint s = q.size();\n\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint x, y;\n\t\t\tfind_0(puzzle, x, y);\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint X = x + D_x[j];\n\t\t\t\tint Y = y + D_y[j];\n\t\t\t\tif (X < 0 || Y < 0 || X >= 3 || y >= 3)continue;\n\t\t\t\tsetNum(puzzle, q.front());\n\t\t\t\tswap(puzzle[y][x], puzzle[Y][X]);\n\n\t\t\t\tint n = getNum(puzzle);\n\t\t\t\tif (n == ANS) {\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t\tif (table.count(n) == 0) {\n\t\t\t\t\ttable.insert(n);\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcnt++;\n\t}\n}\n\nint main() {\n\tint puzzle[3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> puzzle[i][j];\n\t\t}\n\t}\n\n\tcout << solve(puzzle) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <queue>\n#include <unistd.h>\n#include <set>\nusing namespace std;\n\nclass puzzle{\npublic:\n  int num;\n  pair<int, int> zid;\n  int v[3][3];\n  bool operator<(const puzzle& another) const{\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 3; j++){\n        if(v[i][j] < another.v[i][j]) return false;\n        else if(v[i][j] > another.v[i][j]) return true;\n      }\n    }\n    return false;\n  }\n  void print(){\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 3; j++){\n        cout << v[i][j] << \" \";\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool istarget(puzzle p){\n  for(int i = 0; i < 3; i++){\n    for(int j = 0; j < 3; j++){\n      if(p.v[i][j] != (i * 3 + j  + 1) % 9) return false;\n    }\n  }\n  return true;\n}\n\nvoid solve(){\n  puzzle p, ans;\n  for(int i = 0; i < 3; i++){\n    for(int j = 0; j < 3; j++){\n      cin >> p.v[i][j];\n      if(p.v[i][j] == 0) p.zid = make_pair(i, j);\n    }\n  }\n  p.num = 0;\n  map<puzzle, bool> mp;\n  mp[p] = true;\n  queue<puzzle> q;\n  q.push(p);\n  while(q.size() > 0){\n    puzzle c = q.front(), n; q.pop();\n    //cout << c.num << endl;\n    //c.print();\n    if(istarget(c)){\n      cout << c.num << endl;\n      break;\n    }\n    int x = c.zid.first, y = c.zid.second;\n    n = c;\n    n.num++;\n    if(x >= 1){\n      swap(n.v[x][y], n.v[x - 1][y]);\n      n.zid.first--;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n    n = c;\n    n.num++;\n    if(x <= 1){\n      swap(n.v[x][y], n.v[x + 1][y]);\n      n.zid.first++;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n    n = c;\n    n.num++;\n    if(y >= 1){\n      swap(n.v[x][y], n.v[x][y - 1]);\n      n.zid.second--;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n    n = c;\n    n.num++;\n    if(y <= 1){\n      swap(n.v[x][y], n.v[x][y + 1]);\n      n.zid.second++;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n  }\n  return;\n}\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nbitset<362880> ht;\ntypedef pair<int[9],int> state;\nqueue<state> q;\nconst int goal=46233;\n\nint hash(const int *board)\n{\n    const static int fact[]={40320,5040,720,120,24,6,2,1};\n    int h=0;\n    int work;\n    for(int i=0; i<8; i++) {\n        work=board[i];\n        for(int j=0; j<i; j++) {\n            if(board[j]<board[i]) --work;\n        }\n        h+=work*fact[i];\n    }\n    return h;\n}\n\nint search()\n{\n    while(!q.empty()) {\n        state now=q.front();\n        if(hash(now.first)==goal) return now.second;\n        q.pop();\n        int f;\n        for(f=0; now.first[f]; f++);\n        if(f%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        }\n        if((f+1)%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f>=3) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f<6) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n    }\n    return -1;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    state board;\n    board.second=0;\n    for(int i=0; i<9; i++) cin>>board.first[i];\n    ht.set(hash(board.first));\n    q.push(board);\n    cout<<search()<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\ntypedef struct {\n  int f[N2];\n  int space:\n  string path;\n\n  bool operator < (const puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n} Puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1);\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[o] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\ntypedef long long ll;\n\nP Dir[4] = {\n\tP(-1, 0),\n\tP(0, -1),\n\tP(1, 0),\n\tP(0, 1),\n};\n\nll pow17[15];\n\nvoid Init() {\n\tpow17[0] = 1;\n\tfor (int i = 1; i < 15; ++i) {\n\t\tpow17[i] = pow17[i-1]*17;\n\t}\n}\n\nclass Puzzle {\nprivate:\n\tint W, H;\n\tint holes;\n\tint board[4][4];\n\tint coe[4][4];\n\tmap<int, P> rboard;\n\tll hash, gHash;\n\tvector< pair<P, P> > psl;\n\npublic:\n\tPuzzle(int W, int H) : W(W), H(H) {\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tholes = 0;\n\t\trboard.clear();\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tboard[y][x] = k;\n\t\t\t}\n\t\t}\n\t\tinitCoe();\n\t\tinitHash();\n\t}\n\tvoid setTile(int x, int y, int v) {\n\t\tint pv = board[y][x];\n\t\tif (pv < 0) --holes;\n\t\tif (v < 0) ++holes;\n\t\tboard[y][x] = v;\n\t\trboard[v] = P(x, y);\n\t\thash += ((v < 0 ? 0 : v) - (pv < 0 ? 0 : pv)) * pow17[coe[y][x]];\n\t}\n\tvoid initCoe() {\n\t\tfor (int y = 0, k = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tcoe[y][x] = k++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoe[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgHash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint x = (v-1)%W, y = (v-1)/W;\n\t\t\t\t\tgHash += v * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getTile(int x, int y) {\n\t\treturn board[y][x];\n\t}\n\tbool swap(int x1, int y1, int x2, int y2) {\n\t\tint v1 = getTile(x1, y1), v2 = getTile(x2, y2);\n\t\tif (v1 == 0 || v2 == 0 || (v1 < 0 && v2 == 0)) return false;\n\t\tsetTile(x1, y1, v2);\n\t\tsetTile(x2, y2, v1);\n\t\treturn true;\n\t}\n\tbool isComplete() {\n\t\treturn hash == gHash;\n/*\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tint v = board[y][x];\n\t\t\t\tif (v > 0 && k != v) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n*/\n\t}\n\tbool isOut(int x, int y ) {\n\t\treturn x < 0 || x >= W || y < 0 || y >= H;\n\t}\n\tvoid move(int dir) {\n\t\tdir = (dir + 2) % 4;\n\t\tvector< pair<P, int> > v;\n\t\tfor (int i = 0; i < holes; ++i) {\n\t\t\tP& p = rboard[-(i+1)];\n\t\t\tint x = p.real(), y = p.imag();\n\t\t\tint nx = x + Dir[dir].real(), ny = y + Dir[dir].imag();\n\t\t\tif (isOut(nx, ny)) continue;\n\t\t\tif (getTile(nx, ny) < 0) continue;\n\t\t\tv.push_back( pair<P, int>(p, getTile(nx, ny)) );\n\t\t}\n\t\tpsl.clear();\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tint x = v[i].first.real(), y = v[i].first.imag();\n\t\t\tP p = rboard[v[i].second];\n\t\t\tif ( swap(x, y, p.real(), p.imag()) ) {\n\t\t\t\tpsl.push_back( pair<P, P>(P(x, y), p) );\n\t\t\t}\n\t\t}\n\t}\n\tvoid prev() {\n\t\tfor (int i = psl.size()-1; i >= 0; --i) {\n\t\t\tP &p1 = psl[i].first, &p2 = psl[i].second;\n\t\t\tswap(p1.real(), p1.imag(), p2.real(), p2.imag());\n\t\t}\n\t}\n\tvoid draw() {\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (x) cout << \" \";\n\t\t\t\tprintf(\"%2d\", getTile(x, y));\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tll getHash() {\n\t\treturn hash;\n\t}\n\tvoid initHash() {\n\t\thash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v != 0) {\n\t\t\t\t\thash += (v < 0 ? 0 : v) * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid setHash(ll h) {\n\t\tint k = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tint v = h%17; if (v == 0) v = --k;\n\t\t\t\t\tsetTile(x, y, v);\n\t\t\t\t\th /= 17;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getH() {\n\t\tint res = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint gx = (v-1)%W, gy = (v-1)/W;\n\t\t\t\t\tres += abs(gx-x) + abs(gy-y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint getHoles() {\n\t\treturn holes;\n\t}\n\tll getGHash() {\n\t\treturn gHash;\n\t}\n};\n\nstruct Node {\n\tll hash;\n\tint step, h;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.h > n2.h;\n}\n\nint main() {\n\tInit();\n\n//\tint W, H; cin >> W >> H;\n\tint W = 3, H = 3;\n\tPuzzle puzzle(W, H);\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tint v; cin >> v;\n\t\t\tif (v == 0) v = -1;\n\t\t\tpuzzle.setTile(x, y, v);\n\t\t}\n\t}\n\tpuzzle.initCoe();\n\tpuzzle.initHash();\n\n\tint s = 0;\n\n\tset<ll> gone;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push((Node){puzzle.getHash(), 0, puzzle.getH()});\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tll hash = node.hash;\n\t\tint step = node.step;\n\n\t\tif (step > s) {\n//\t\t\ts = step;\n//\t\t\tcout << s << endl;\n\t\t}\n\n\t\tif (gone.count(hash)) continue;\n\t\tgone.insert(hash);\n\n\t\tif (puzzle.getGHash() == hash) {\n\t\t\tcout << step << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tpuzzle.setHash(hash);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (i) puzzle.prev();\n\t\t\tpuzzle.move(i);\n\t\t\tll h = puzzle.getHash();\n\t\t\tif (gone.count(h) == 0) {\n\t\t\t\tQ.push((Node){h, step+1, step*puzzle.getHoles()+puzzle.getH()});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[{ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } }];\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i != N2; ++i) {\n            if ( f[i] == p.f[i] ) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle s) {\n    for (int i = 0; i != N2; ++i) {\n        if ( s.f[i] == i + 1 ) continue;\n        return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    Puzzle u, v;\n    map<Puzzle, bool> V;\n    V[s] = true;\n    s.path = \"\";\n    Q.push(s);\n    \n    while ( !Q.empty() ) {\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r != 4; ++r) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for (int i = 0; i != N2; ++i) {\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nint main() {\n    std::vector<int> pazzle(9);\n    for (int i = 0; i < 9; i++) {\n        std::cin >> pazzle[i];\n    }\n\n    std::map<std::vector<int>, int> m;\n    std::queue <std::pair<std::vector<int>, int> > q;\n\n    m[pazzle] = 0;\n    m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] = 10000;\n\n    q.push({pazzle, 0});\n    while (!q.empty()) {\n        pazzle = q.front().first;\n        int num = q.front().second;\n        q.pop();\n        if (m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] != 0 && m[{1, 2, 3, 4, 5, 6, 7, 8, 0}]  < num) break;\n        //if (m[pazzle] != 0 && m[pazzle] <= num) continue;\n\n        int space = std::find(pazzle.begin(), pazzle.end(), 0) - pazzle.begin();\n\n        if (space > 2) {\n            std::swap(pazzle[space], pazzle[space - 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({pazzle, num + 1});\n            }\n            std::swap(pazzle[space], pazzle[space - 3]);\n        }\n        if (space < 6) {\n            std::swap(pazzle[space], pazzle[space + 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 3]);\n        }\n        if (space % 3 != 0) {\n            std::swap(pazzle[space], pazzle[space - 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space - 1]);\n        }\n        if (space % 3 != 2) {\n            std::swap(pazzle[space], pazzle[space + 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 1]);\n        }\n    }\n\n    std::cout << m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\nusing Graph = vector<vector<int>>;\n\nint main() {\n  Graph board(3, vector<int>(3)),last(3, vector<int>(3));\n  rep(i,3) {\n    rep(j,3) cin >> board[i][j];\n  }\n\n  last = {\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}\n  };\n\n  map<Graph, int> m;\n  m[board] = 0;\n  queue <Graph> que;\n  que.push(board);\n\n  const vector<int> dy = {-1,0,0,1};\n  const vector<int> dx = {0,-1,1,0};\n\n  while(!que.empty()) {\n    Graph v = que.front();\n    int count = m[v];\n    que.pop();\n    int y,x;\n    rep(i,3) {\n      rep(j,3) {\n        if (v[i][j] == 0) {\n          y = i;\n          x = j;\n        }\n      }\n    }\n\n    rep(i,4) {\n      int yy = y + dy[i];\n      int xx = x + dx[i];\n      if (yy < 0 || yy >= 3 || xx < 0 || xx >= 3) continue;\n      swap(v[y][x],v[yy][xx]);\n      if (!m.count(v)) {\n        que.push(v);\n        m[v] = count + 1;\n        if (m.count(last)) goto OUT;\n      }\n      swap(v[y][x],v[yy][xx]);\n    }\n  }\n\n  OUT:\n\n  cout << m[last] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    for (int i = 1; i <= 45; i++) {\n        int ret = dfs(b, i);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#define N 3\n#define NN 9\nusing namespace std;\n\nstruct Puzzle{\n  int f[NN];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p)const{\n    for(int i=0;i<NN;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic int dx[4]={1,0,-1,0};\nstatic int dy[4]={0,1,0,-1};\nstatic char dir[4]={'r','d','l','u'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<NN;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  \n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<NN;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=NN;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  printf(\"%lu\\n\",ans.size());\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p)const {\n\t\tfor(int i=0;i < N2;++i){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i < N2;++i)\n\t\tif(p.f[i] != (i+1)) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\t\n\twhile(!Q.empty()){\n\t\tu = Q.front(), Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0;r < 4;++r){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N+ty]);\n\t\t\tv.space = tx*N + ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\t\n\tfor(int i=0;i < N2;++i){\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nclass Puzzle {\npublic:\n    int piece[N2];\n    int space;\n    string path;\n\n    Puzzle() {}\n\n    Puzzle(int space, string path) : space(space), path(path) {}\n\n    bool operator<(const Puzzle &p) const {\n        for(int i = 0; i < N2; i++)\n        {\n            if(piece[i] == p.piece[i])\n                continue;\n            return piece[i] < p.piece[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.piece[i] != (i + 1)) // ä¸æ­£è§£\n            return false;\n\n    return true;\n}\n\nstring bfs(Puzzle start)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> is_visit;\n    Puzzle u, v;\n    start.path = \"\";\n    Q.push(start);\n    is_visit[start] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n\n        if (isTarget(u))\n            return u.path;\n\n        int sx = u.space / N; // ç©ºããã¹ã®xåº§æ¨\n        int sy = u.space % N; // ç©ºããã¹ã®yåº§æ¨\n        for (int direct = 0; direct < 4; direct++)\n        {\n            int tx = sx + dx[direct]; // é·ç§»åã®ç©ºããã¹ã®xåº§æ¨\n            int ty = sy + dy[direct]; // é·ç§»åã®ç©ºããã¹ã®yåº§æ¨\n            if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n                continue; // æ å¤ã«ã§ããç¡è¦\n            v = u;\n            swap(v.piece[u.space], v.piece[tx * N + ty]); // ãã¼ã¹ãç§»å\n            v.space = tx * N + ty;\n            if(!is_visit[v])\n            {\n                is_visit[v] = true;\n                v.path += dir[direct];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle input;\n\n    for(int i = 0; i < N2; i++)\n    {\n        cin >> input.piece[i];\n        if(input.piece[i] == 0)\n        {\n            input.piece[i] = N2;\n            input.space = i;\n        }\n    }\n\n    string answer = bfs(input);\n    cout << answer.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for((i)=(s);(i)<(int)(e);(i)++)\n#define REP(i,e) FOR(i,0,e)\n\n#define all(o) (o).begin(), (o).end()\n#define psb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst double EPS = 1e-10;\n\nconst int N = 3;\nconst int M = 9;\nconst int dx[] = {1, 0, -1,  0};\nconst int dy[] = {0, 1,  0, -1};\nconst char dir[] = {'r', 'u', 'l', 'd'};\n\ntypedef struct puzzle_def {\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const puzzle_def &p) const {\n    for (int i=0; i<M; i++) \n      if (f[i] < p.f[i])\n        return true;\n      else if (f[i] > p.f[i])\n        return false;\n    return false;\n  }\n\n/*\n  bool operator < (const puzzle_def &l, const puzzle_def &r) {\n    for (int i=0; i<M; i++) \n      if (l.f[i] < r.f[i])\n        return true;\n      else if (l.f[i] > r.f[i])\n        return false;\n    return false; \n  }\n*/\n\n} pzl;\n\nbool is_target(pzl p) {\n  for (int i=0; i<M; i++)\n    if (p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(pzl s) {\n  queue<pzl> q;\n  map<pzl, bool> past;\n  s.path = \"\";\n  q.push(s);\n  past[s] = true;\n\n  while (q.size()) {\n    pzl u = q.front(); q.pop(); \n    if (is_target(u)) return u.path;\n    int x = u.space / N, y = u.space % N;\n    for (int i=0; i<4; i++) {\n      int nx = x + dx[i]; \n      int ny = y + dy[i]; \n      if (nx<0 || nx>=N || ny<0 || ny>=N) continue;\n      pzl v = u;\n      swap(v.f[v.space], v.f[nx * N + ny]);\n      v.space = nx * N + ny;\n      if (!past[v]) {\n        past[v] = true;\n        v.path += dir[i];\n        q.push(v);\n      }\n    }\n  }\n  return \"failed.\";\n}\n\nint main() {\n  pzl ini;\n  for (int i=0; i<M; i++) {\n    scanf(\"%d \", &(ini.f[i])); \n    if (!ini.f[i]) {\n      ini.f[i] = M;\n      ini.space = i;\n    }\n  }\n\n  string res = bfs(ini);\n  cout << res.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstddef>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <utility>\n\nstatic const int N = 3;\nstatic const int N2 = N * N;\n\nstatic std::array<int, 4> dx{0, -1, 0, 1};\nstatic std::array<int, 4> dy{1, 0, -1, 0};\nstatic std::array<char, 4> dchar{'u', 'l', 'd', 'r'};\n\nstruct Puzzle\n{\n    std::array<int, N2> state;\n    int space;\n    std::string path = \"\";\n\n    // For map comparison\n    bool operator<(const Puzzle &p) const\n    {\n        for (size_t i = 0; i < state.size(); ++i)\n        {\n            if (state[i] != p.state[i])\n            {\n                return state[i] < p.state[i];\n            }\n        }\n\n        return false;\n    }\n};\n\nbool isTarget(Puzzle &p)\n{\n    for (int i = 0; i < p.state.size(); ++i)\n    {\n        if (p.state.at(i) != (i + 1))\n            return false;\n    }\n    return true;\n}\n\nstd::string bfs(Puzzle &p)\n{\n    std::queue<Puzzle> q;\n    std::map<Puzzle, bool> visited;\n\n    q.push(p);\n    visited[p] = true;\n\n    while (!q.empty())\n    {\n        auto u = q.front();\n        q.pop();\n\n        if (isTarget(u))\n        {\n            return u.path;\n        }\n\n        int u_space_x = u.space % 3;\n        int u_space_y = u.space / 3;\n\n        for (size_t i = 0; i < 4; ++i)\n        {\n            auto nx = u_space_x + dx[i];\n            auto ny = u_space_y + dy[i];\n\n            if (0 <= nx && nx < N && 0 <= ny && ny < N)\n            {\n                auto v = u;\n                auto next_space = ny * 3 + nx;\n\n                std::swap(v.state[u.space], v.state[next_space]);\n                v.space = next_space;\n                v.path += dchar[i];\n\n                if (!visited[v])\n                {\n                    q.push(v);\n                    visited[v] = true;\n                }\n            }\n        }\n    }\n\n    return \"Unsolvable\\n\";\n}\n\nint main()\n{\n    Puzzle in;\n    for (size_t i = 0; i < N2; ++i)\n    {\n        std::cin >> in.state[i];\n        if (in.state[i] == 0)\n        {\n            in.state[i] = 9;\n            in.space = i;\n        }\n    }\n\n    auto ans = bfs(in);\n    std::cout << ans.length() << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<cassert>\n#include<cmath>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n#define LIMIT 100\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\n\nint MDT[N2][N2];\n\nstruct Puzzle{\n  int f[N2], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint getAllMD(Puzzle pz){\n  int sum = 0;\n  for(int i=0 ; i<N2 ; ++i){\n    if(pz.f[i] == N2) continue;\n    sum += MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0 ; i<N2 ; ++i) if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n  if(depth + state.MD > limit) return false;\n\n  int sx = state.space/N;\n  int sy = state.space%N;\n  Puzzle tmp;\n\n  for(int r=0 ; r<4 ; ++r){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx<0 || ty<0|| tx>=N || ty >= N) continue;\n    if(max(prev, r)-min(prev, r) == 2) continue;\n    tmp = state;\n\n    state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n    state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n    swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n    state.space = tx*N+ty;\n    if(dfs(depth+1, r)){\n      path[depth] = r;\n      return true;\n    }\n    state = tmp;\n  }\n  return false;\n}\n\nstring iterative_deeping(Puzzle in){\n  in.MD = getAllMD(in);\n\n  for(limit = in.MD ; limit<=LIMIT ; ++limit){\n    state = in;\n    if(dfs(0, -100)){\n      string ans = \"\";\n      for(int i=0 ; i<limit ; ++i) ans += dir[path[i]];\n      return ans;\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0 ; i<N2 ; ++i){\n    for(int j=0 ; j<N2 ; ++j){\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n    }\n  }\n  Puzzle in;\n  for(int i=0 ; i<N2 ; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deeping(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i=0;i<N2;i++)\n      {\n\tif(f[i]==p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i=0;i<N2;i++)\n  \n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle>Q;\n  map<Puzzle, bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n    {\n      u=Q.front();Q.pop();\n      if(isTarget(u)) return u.path;\n      int sx=u.space/N;\n      int sy=u.space%N;\n      for(int r=0;r<4;r++)\n\t{\n\t  int tx=sx+dx[r];\n\t  int ty=sy+dy[r];\n\t  if(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t  v=u;\n\t  swap(v.f[u.space],v.f[tx*N+ty]);\n\t  v.space=tx*N+ty;\n\t  if(!V[v])\n\t    {\n\t      V[v]=true;\n\t      v.path += dir[r];\n\t      Q.push(v);\n\t    }\n\t}\n    }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n    {\n      cin>>in.f[i];\n      if(in.f[i]==0)\n\t{\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n    }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\t    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n\n\nll get(ll now,ll tc,ll tn){\n\tll res = now;\n\tll c = now/tc;\n\tc = c%10LL;\n\tres -= c*tc;\n\tres += c*tn;\n\treturn res;\n}\n\n\nint main(){\n\n\tqueue<ll> p,dep,zero;\n\tll now=0,k;\n\tll f = 123456780;\n\tll ten = 100000000LL;\n\tFOR(i,0,9){\n\t\tcin >> k;\n\t\tnow += k*ten;\n\t\tif(k==0){\n\t\t\tzero.push(ten);\n\t\t}\n\t\tten /= 10LL;\n\t}\n\n\t//cout << now << endl;\n\tll minten = 1LL;\n\tll maxten = 100000000LL;\n\n\tp.push(now);\n\tdep.push(0);\n\tset<ll> se;\n\tse.insert(now);\n\n\twhile(p.size()){\n\t\tnow = p.front(); p.pop();\n\t\tll d = dep.front(); dep.pop();\n\t\tll t = zero.front(); zero.pop();\n\t\tif(now==f){\n\t\t\tcout << d << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(t*1000<=maxten && !se.count(get(now,t*1000,t))){\n\t\t\tse.insert(get(now,t*1000,t));\n\t\t\tp.push(get(now,t*1000,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t*1000);\n\t\t}\n\t\tif(t/1000>=minten && !se.count(get(now,t/1000,t))){\n\t\t\tse.insert(get(now,t/1000,t));\n\t\t\tp.push(get(now,t/1000,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t/1000);\n\t\t}\n\t\tif(t*10<=maxten && t!=100 && t!=100000 && !se.count(get(now,t*10,t))){\n\t\t\tse.insert(get(now,t*10,t));\n\t\t\tp.push(get(now,t*10,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t*10);\n\t\t}\n\t\tif(t/10>=minten && t!=1000 && t!=1000000&& !se.count(get(now,t/10,t))){\n\t\t\tse.insert(get(now,t/10,t));\n\t\t\tp.push(get(now,t/10,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t/10);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nvoid RenewTargets(\n\tconst TPuzzle& Puzzle,\n\tconst TMovePattern& Pattern,\n\tstd::vector<TPuzzle>* Targets,\n\tstd::set<TPuzzle>& History)\n{\n\tif(!Movable(Puzzle, Pattern)) return;\n\tTPuzzle Moved = Move(Puzzle, Pattern);\n\tif(History.find(Moved) != History.end()) return;\n\tTargets->push_back(Moved);\n\tHistory.insert(Moved);\n}\n//?Â¬??????????????????????????????Â¶???????????????\n\n//????Â¬??????????????????????????Â¨?????????Â£???????????Â°?????????\n//?Â¬?????????????????????????????????Â§?????????????????????????????????\n//???????????Â§????Â±\\??Â´????????Â£????????????\n//?Â¬???????????????????????????????????????????????????????\n//?Â±\\??Â´????????????\n//????????????\nint CountMove(std::vector<TPuzzle>* NextTargets,\n\t          const TPuzzle& Goal,\n\t          int Count,\n\t          std::set<TPuzzle>& History)\n{\n\tif(std::find(NextTargets->begin(), NextTargets->end(), Goal) != NextTargets->end()) return Count;\n\tstd::vector<TPuzzle>* NewTargets = new std::vector<TPuzzle>();\n\tfor(std::vector<TPuzzle>::const_iterator It = NextTargets->begin(); It != NextTargets->end(); ++It){\n\t\tRenewTargets(*It, mpUp,    NewTargets, History);\n\t\tRenewTargets(*It, mpDown,  NewTargets, History);\n\t\tRenewTargets(*It, mpLeft,  NewTargets, History);\n\t\tRenewTargets(*It, mpRight, NewTargets, History);\n\t}\n\tdelete NextTargets;\n\treturn CountMove(NewTargets, Goal, 1 + Count, History);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> History;\n\treturn CountMove(new std::vector<TPuzzle>(1, Puzzle), Goal, 0, History);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n  {\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r=0;r<4;r++)\n    {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx * N + ty;\n      if(!V[v])\n      {\n        V[v]=true;\n        v.path+=dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n  {\n    cin >> in.f[i];\n    if(in.f[i]==0)\n    {\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint start_x,start_y;//èµ·å§ä½ç½®x,yï¼\nint Map[5][5];//èµ·å§ç¶ææ°ç»ï¼\nint max1,min1;//èµ·å§åæ¼é¡¿è·ç¦»åå®éæå°æ­¥æ°ï¼\nint goal[5][5];//ç®æ ç¶ææ°ç»ï¼\nint c[4][2]={1,0,0,1,0,-1,-1,0};//æ¹åæ°ç»ï¼\nint flag;//æ è®°åéï¼\n\nvoid start_xyz()//æ±èµ·å§ä½ç½®ï¼\n{\n    int i,j;\n    for(i=0; i<4; i++)\n        for(j=0; j<4; j++)\n            if(Map[i][j]==0)\n            {\n                start_x=i;\n                start_y=j;\n                return ;\n            }\n}\n\nint MHT()//åæ¼é¡¿è·ç¦»ï¼\n{\n    int i,j,num=0;\n    for(i=0;i<4;i++)\n        for(j=0;j<4;j++)\n            if(Map[i][j]==0)continue;\n            else num+=(fabs((Map[i][j]-1)/4-i)+fabs((Map[i][j]-1)%4-j));\n    return num;\n}\n\nvoid swap(int *a,int *b)//äº¤æ¢ä½ç½®ï¼\n{\n    int t;\n    t=*a;\n    *a=*b;\n    *b=t;\n}\n\nvoid dfs(int x,int y,int s,int last_dis)//æ·±æè¿ç¨ï¼\n{\n    if(flag)\n        return ;\n    if(s==max1)//å½æ­¥æ°ä¸æå°å¼ç¸ç­æ¶ï¼\n    {\n        int len=MHT();\n        if(len==0)//ä¸æ­¤æ¶çåæ¼é¡¿è·ç¦»ä¸ºé¶ï¼ä¹å°±æ¯æ­¤æ¶çå¾åç®æ å¾ç¸åï¼\n        {\n            flag=1;\n            min1=s;\n        }\n        return ;\n    }\n    for(int i=0;i<4;i++)//åä¸ªæ¹åï¼\n    {\n        if(i+last_dis==3&&s>0)continue;//æ­¤æ¶çæ¹ååä¸ä¸æ­¥çç¸åï¼ä¹å°±æ¯ååå°äºä¸ä¸æ­¥ï¼æ­¤æ¶åºè¯¥continue;\n        int dx=x+c[i][0];\n        int dy=y+c[i][1];\n        if(dx<0||dy<0||dx>=4||dy>=4)continue;//æ¯å¦è¶çï¼\n        swap(&Map[dx][dy],&Map[x][y]);//åäº¤æ¢ä½ç½®åå¤æ­æ¯å¦ç¬¦åæåµï¼\n        if(MHT()+s<=max1&&!flag)//å½åä½ç½®çåæ¼é¡¿è·ç¦»+å½åæ·±åº¦<=åå§åæ¼é¡¿è·ç¦»ï¼\n        {\n            dfs(dx,dy,s+1,i);\n            if(flag)\n                return ;\n        }\n        swap(&Map[dx][dy],&Map[x][y]);//ä¸ç¬¦åæ¡ä»¶åäº¤æ¢åæ¥ï¼\n    }\n}\n\nint main()\n{\n    int i,j;\n    for(i=0; i<4; i++)\n        for(j=0; j<4; j++)\n            scanf(\"%d\",&Map[i][j]);\n    int k=1;\n    for(i=0;i<4;i++)//ç®æ æ°ç»ï¼\n        for(j=0;j<4;j++)\n            if(i==3&&j==3)goal[i][j]=0;\n            else goal[i][j]=k++;\n    start_xyz();//æ¾èµ·å§ä½ç½®ï¼\n    flag=0;\n    max1=MHT();//åå§åæ¼é¡¿è·ç¦»ï¼\n    while(!flag)\n    {\n        dfs(start_x,start_y,0,0);\n        if(!flag)\n            max1++;//å¢å åå§åæ¼é¡¿è·ç¦»ï¼\n    }\n    if(flag)\n        printf(\"%d\\n\",min1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\n#define ROW 3\n#define COL 3\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\n\nstruct Puzzle{\n\tint puzzle[ROW][COL];\n\tint space_x, space_y;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor(int i = 0; i < ROW; i++){\n\t\t\tfor(int j = 0; j < COL; j++){\n\t\t\t\tif(puzzle[i][j] == p.puzzle[i][j]) continue;\n\t\t\t\treturn puzzle[i][j] < p.puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstruct Node{\n\tPuzzle state;\n\tint level;\n\tint cost;\n\n\tbool operator < (const Node &n) const {\n\t\treturn cost > n.cost;\n\t}\n};\n\nint goal[ROW][COL] = {\n\t\t1, 2, 3,\n\t\t4, 5, 6,\n\t\t7, 8, 0\n\t};\nmap<int, pair<int, int>> heuristicMap;\n\nint isGoal(Puzzle p){\n\tfor(int i = 0; i < ROW; i++){\n\t\tfor(int j = 0; j < COL; j++){\n\t\t\tif(goal[i][j] != p.puzzle[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint Heuristuc0(Puzzle p){\n\treturn 0;\n}\n\nint g(int level){\n\treturn level;\n}\n\nint CaliculateCost(Node node){\n\treturn Heuristuc0(node.state) + g(node.level);\n}\n\nint ASearch(Node start){\n\tpriority_queue<Node> openList;\n\tmap<Puzzle, pair<bool, int>> closedList;\n\n\topenList.push(start);\n\n\twhile(!openList.empty()){\n\t\tNode now = openList.top(); openList.pop();\n\t\t\n\t\tif(isGoal(now.state)) return now.level;\n\n\t\tclosedList[now.state] = make_pair(true, now.cost);\n\t\t\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint tx = now.state.space_x + dx[k];\n\t\t\tint ty = now.state.space_y + dy[k];\n\t\t\tif(tx < 0 || ty < 0 || tx >= ROW || ty >= COL) continue;\n\n\t\t\tNode child;\n\t\t\tchild.state = now.state;\n\t\t\tswap(child.state.puzzle[now.state.space_x][now.state.space_y], child.state.puzzle[tx][ty]);\n\t\t\tchild.state.space_x = tx;\n\t\t\tchild.state.space_y = ty;\n\t\t\tchild.level = now.level + 1;\n\t\t\tchild.cost = CaliculateCost(child);\n\n\t\t\tif(!closedList[child.state].first){\n\t\t\t\topenList.push(child);\n\t\t\t}else if(child.cost < closedList[child.state].second){\n\t\t\t\tclosedList.erase(child.state);\n\t\t\t\topenList.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(){\n\tfor(int i = 0; i < ROW; i++){\n\t\tfor(int j = 0; j < COL; j++){\n\t\t\theuristicMap[goal[i][j]] = make_pair(i, j);\n\t\t}\n\t}\n\n\tNode start;\n\tfor(int i = 0; i < ROW; i++){\n\t\tfor(int j = 0; j < COL; j++){\n\t\t\tcin >> start.state.puzzle[i][j];\n\t\t\tif(start.state.puzzle[i][j] == 0){\n\t\t\t\tstart.state.space_x = i;\n\t\t\t\tstart.state.space_y = j;\n\t\t\t}\n\t\t}\n\t}\n\tstart.level = 0;\n\tstart.cost = CaliculateCost(start);\n\n\tcout << ASearch(start) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i = 0;i < N2;i++) {\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0;i < N2;i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < 4;r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >=N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]) {\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n  \n  for(int i = 0;i < N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n  \nint t[3][3];\nint limit;\n  \nint getHeuri(){\n  int res=0,a;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(t[i][j]==0)continue;\n      a=t[i][j]-1;\n      res+=abs(a/3-i)+abs(a%3-j);\n    }\n  }\n  return res;\n}\n  \nbool check(int depth,int prev,int py,int px){\n  int heuri=getHeuri();\n  if(heuri+depth>limit)return false;\n  if(heuri==0)return true;\n  for(int i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int ny=py+dy[i],nx=px+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=3||nx>=3)continue;\n    swap(t[ny][nx],t[py][px]);\n    if(check(depth+1,i,ny,nx)) return true;\n    swap(t[ny][nx],t[py][px]);\n  }\n  return false;\n}\n  \nvoid solve(int py,int px){\n  for(limit=0;;limit++){\n    if(check(0,99,py,px)){\n      cout<<limit<<endl;\n      return;\n    }\n  }\n}\nint main(){\n  int py,px;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      cin>>t[i][j];\n      if(t[i][j]==0){\n    py=i;\n    px=j;\n      }\n    }\n  }\n  solve(py,px);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct r{\n\tint x;\n\tint y;\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9];\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tmemset(used,0,sizeof(used));\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t\tif(f.men[i][j]==0){\n\t\t\t\tf.x=j;\n\t\t\t\tf.y=i;\n\t\t\t}\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tfor(k=0;k<4;k++){\n\t\t\tif(f.y+dy[k]>=0&&f.y+dy[k]<3&&f.x+dx[k]>=0&&f.x+dx[k]<3){\n\t\t\t\tv=f;\n\t\t\t\ttemp=v.men[f.y][f.x];\n\t\t\t\tv.men[f.y][f.x]=v.men[f.y+dy[k]][f.x+dx[k]];\n\t\t\t\tv.men[f.y+dy[k]][f.x+dx[k]]=temp;\n\t\t\t\tv.x=f.x+dx[k];\n\t\t\t\tv.y=f.y+dy[k];\n\t\t\t\tv.cnt++;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n//        return s.count * 2 + direction - 1;\n//        return s.count * 2;\n        return s.count * 2 - (frontier[pos] - 1);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(wrongs + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint main(){\n    map<string,int> dp;\n    string g = \"123456780\";\n    string t = \"\";\n    for(int i = 0; i < 9; i++){\n        char c; cin >> c;\n        t += c;\n    }\n    dp[t] = 0;\n    queue<string> q;\n    q.push(t);\n    while(!q.empty()){\n        string s = q.front();   q.pop();\n        int now = dp[s];\n        if(s == g){\n            cout << dp[s] << endl;\n            return 0;\n        }\n        for(int i = 0; i < 9; i++){\n            if(i%3==2)  continue;\n            if(s[i] != '0' && s[i+1] != '0')    continue;\n            swap(s[i], s[i+1]);\n            if(dp.count(s) == 0){\n                dp[s] = now+1;\n                q.push(s);\n            }\n            swap(s[i], s[i+1]);\n        }\n        for(int i = 0; i < 6; i++){\n            if(s[i] != '0' && s[i+3] != '0')    continue;\n            swap(s[i], s[i+3]);\n            if(dp.count(s) == 0){\n                dp[s] = now+1;\n                q.push(s);\n            }\n            swap(s[i], s[i+3]);   \n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nvector<int> board( 9 );\nset< vector<int> > reachedState;\n\nvoid PrintBoard() {\n    for ( int row=0; row<3; ++row ) {\n\tfor ( int col=0; col<3; ++col ) cout << board[row*3+col];\n\tcout << endl;\n    }\n}\n\nbool IsReachedState( const vector<int>& b ) {\n    return reachedState.find( b ) != reachedState.end();\n}\n\nvoid RegisterState( const vector<int>& b ) {\n    reachedState.insert( b );\n}\n\nbool IsCompleted( const vector<int>& b ) {\n    for ( int i=0; i<8; ++i ) {\n\tif ( b[i] != i+1 ) return false;\n    }\n    return b[8] == 0;\n}\n\nint main() {\n\n    const int dx[4] = { -1, 0, 1,  0 };\n    const int dy[4] = {  0, 1, 0, -1 };\n    \n    for ( int i=0; i<3; ++i ) {\n\tfor ( int j=0; j<3; ++j ) {\n\t    cin >> board[i*3+j];\n\t}\n    }\n\n    //    PrintBoard();\n\n    queue< pair<vector<int>,int> > stateQue;\n    stateQue.push( make_pair(board, 0) );\n\n    while ( !stateQue.empty() ) {\n\n\tvector<int> state = stateQue.front().first;\n\tint step = stateQue.front().second;\n\tstateQue.pop();\n\n\tif ( IsCompleted( state ) ) {\n\t    cout << step << endl;\n\t    board = state;\n\t    //\t    PrintBoard();\n\t    break;\n\t}\n\n\t//\tif ( IsReachedState( state ) ) continue;\n\t//\tRegisterState( state );\n\n\tint x, y;\n\tfor ( int i=0; i<9; ++i ) {\n\t    if ( state[i] == 0 ) {\n\t\tx = i%3;\n\t\ty = i/3;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tfor ( int i=0; i<4; ++i ) {\n\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\n\t    if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue;\n\n\t    vector<int> next = state;\n\t    swap( next[3*y+x], next[3*ny+nx] );\n\t    stateQue.push( make_pair( next, step+1 ) );\n\t    \n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint MDT[N2][N2];\n\nstruct Puzzle\n{\n\tint f[N2], space, MD;\n\tint cost;\n\tbool operator < (const Puzzle &p) const\n\t{\n\t\tfor(int i = 0; i < N2; i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint getallMD(const Puzzle &p)\n{\n\tint h = 0;\n\tfor(int i = 0; i < N2; i++){\n\tif(i == p.space) continue;\n\t\th += MDT[i][p.f[i] - 1];\n\t}\n\treturn h;\n}\n\nstruct State\n{\n\tPuzzle pz;\n\tint estimated;\n\tbool operator < (const State &s) const\n\t{\n\t\treturn estimated > s.estimated;\n\t}\n};\n\nint astar(Puzzle p)\n{\n\tpriority_queue<State> A;\n\tmap<Puzzle, bool> USED;\n\n\tState initial;\n\tinitial.pz = p;\n\tinitial.estimated = p.MD;\n\tA.push(initial);\n\tUSED[p] = true;\n\n\tPuzzle u, v;\n\tint sx, sy, tx, ty, r;\n\n\twhile(!A.empty())\n\t{\n\t\tu = A.top().pz; A.pop();\n\t\tif(u.MD == 0) return u.cost;\n\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\tfor(r = 0; r < 4; r++){\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tv.MD -= MDT[tx * N + ty][u.f[tx * N + ty] - 1];\n\t\t\tv.MD += MDT[sx * N + sy][u.f[tx * N + ty] - 1];\n\t\t\tswap(v.f[sx * N + sy], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\t\n\t\t\tif(!USED[v]){\n\t\t\t\tv.cost++;\n\t\t\t\tUSED[v] = true;\n\t\t\t\tState new_s;\n\t\t\t\tnew_s.pz = v;\n\t\t\t\tnew_s.estimated = v.cost + v.MD;\n\t\t\t\tA.push(new_s);\n\t\t\t}\n\t\t}\n\t};\n\treturn -1;\n}\n\nint main()\n{\n\t\n\tfor(int i = 0; i < N2; i++){\n\t\tfor(int j = 0; j < N2; j++){\n\t\t\tMDT[i][j] = abs((i / N) - (j / N)) + abs((i % N) - (j % N));\n\t\t}\n\t}\n\n\tPuzzle in;\n\n\tfor(int i = 0; i < N2; i++){\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif(in.f[i] == 0) in.space = i;\n\t}\n\tin.cost = 0;\n\tin.MD = getallMD(in);\n\n\tcout << astar(in) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define INF 1e9\n#define LIMIT 16\ntypedef vector<int> Vec;\n  \nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\nint res;\nbool flg;\n  \nbool inField(int y,int x){\n  return 0 <= y && y < 3 && 0 <= x && x < 3; \n}\n  \nbool check(Vec &vec){\n  for(int i = 0 ; i < 8 ; i++){\n    if(vec[i] != i+1) return false;\n  }\n  return true;\n}\n  \nvoid solve(Vec &start,int z,map<Vec,int> &cost){\n  queue<Vec> Q;\n  queue<int> zero;\n  Q.push(start); zero.push(z);\n  cost[start] = 0;\n    \n  while(!Q.empty()){\n    Vec now = Q.front(); Q.pop();\n    int pos = zero.front(); zero.pop();\n    int x = pos % 3, y = pos / 3;\n    if(!flg && check(now)){\n      res = cost[now];\n      return;\n    }\n    if(cost[now] == LIMIT) break;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      vector<int> next = now;\n      swap(next[pos],next[ny*3+nx]);\n      if(!cost.count(next)){\n        cost[next] = cost[now] + 1;\n        Q.push(next);\n        zero.push(ny*3+nx);\n      }\n    }\n  }\n}\n  \nint main(){\n  int z = -1;\n  vector<int> start(9),goal(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> start[i];\n    goal[i] = i+1;\n    if(start[i] == 0) z = i;\n  }\n  goal[8] = 0;\n  res = INF; flg = false;\n  map<Vec,int> s2v,g2v;\n  solve(start,z,s2v);\n  if(res == INF){\n    flg = true;\n    solve(goal,8,g2v);\n  }\n  map<Vec,int>::iterator s,g;\n  for(s = s2v.begin() ; s != s2v.end() ; ++s){\n    if(g2v[s->first]){\n      res = min(res,s->second+g2v[s->first]);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao in 2019.\n//  Copyright Â© 2019 conan1024hao. All rights reserved.\n//  å°ç¨ã©ã¤ãã©ãªã§ããèªç±ã«ã³ãã¼ãã¦æ§ãã¾ããã\n//  æè°¢çæçä»£ç ï¼Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\nll cmp1(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n\n//---------------------------------------------------------------------------\n#define n 3\n#define n2 9\n\nstruct puzzle{\n    int f[n2];\n    int space;\n    string path;\n    \n    bool operator < (const puzzle &p)const{\n        for(int i=0;i<n2;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nbool istarget(puzzle p){\n    for(int i=0;i<n2;i++){\n        if(p.f[i]!=(i+1))return false;\n    }\n    return true;\n}\n\nstring bfs(puzzle s){\n    queue<puzzle>q;\n    map<puzzle,bool>V;\n    puzzle u,v;\n    s.path=\"\";\n    q.push(s);\n    V[s]=1;\n    while(!q.empty()){\n        u=q.front();q.pop();\n        if(istarget(u))return u.path;\n        int sx=u.space/n;\n        int sy=u.space%n;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=n||ty>=n)continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*n+ty]);\n            v.space=tx*n+ty;\n            if(!V[v]){\n                V[v]=1;\n                v.path+=dir[r];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n//---------------------------------------------------------------------------\nint main(){//åé¡ãã¡ããã¨è¦ã!!!!!!!!!!!!!!!!!      llã??????????\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    puzzle in;\n    for(int i=0;i<n2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=n2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid debug() { cerr << \"\\n\"; }\ntemplate <class T> void debug(const T &x) { cerr << x << \"\\n\"; }\ntemplate <class T, class... Args> void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\ntemplate <class T> void debugVector(const vector<T> &v) {\n    for(const T &x : v) {\n        cerr << x << \" \";\n    }\n    cerr << \"\\n\";\n}\n\n//----------------------------------------------\n\nconst int N = 3;\narray<array<int, N * N>, N * N> MHTdist;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct State {\n    array<char, N * N> data;\n    int space_id;\n    int d;\n    State() {}\n    void init() {\n        for(int i = 0; i < N * N; i++) {\n            if(data[i] == 0) {\n                data[i] = N * N;\n                space_id = i;\n                break;\n            }\n        }\n        d = 0;\n    }\n    bool operator<(const State &s) const {\n        for(int i = 0; i < N * N; i++) {\n            if(data[i] != s.data[i]) {\n                return (data[i] < s.data[i]);\n            }\n        }\n        return false;\n    }\n    int h() {\n        int res = 0;\n        for(int i = 0; i < N * N; i++) {\n            if(data[i] == N * N) {\n                continue;\n            }\n            res += MHTdist[i][data[i] - 1];\n        }\n        return res;\n    }\n};\n\nstruct Data {\n    State state;\n    int cost;\n    bool operator<(const Data &d) const { return (cost > d.cost); }\n};\n\nvoid debugState(const State &s) {\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cerr << s.data[i * N + j] << \" \";\n        }\n        cerr << \"\\n\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    State start;\n    {\n        for(int i = 0; i < N * N; i++) {\n            int hoge;\n            cin >> hoge;\n            start.data[i] = hoge;\n        }\n        start.init();\n        for(int i = 0; i < N * N; i++) {\n            for(int j = 0; j < N * N; j++) {\n                MHTdist[i][j] = abs(i / N - j / N) + abs(i % N - j % N);\n            }\n        }\n    }\n\n    map<State, int> dp;\n    priority_queue<Data> que;\n    que.emplace(Data{start, start.h()});\n    dp[start] = 0;\n\n    while(que.size()) {\n        auto nowState = que.top().state;\n        int nowCost = que.top().cost;\n        que.pop();\n        // debugState(nowState);\n        if(!nowState.h()) {\n            cout << nowState.d << \"\\n\";\n            return 0;\n        }\n        int i = nowState.space_id / N;\n        int j = nowState.space_id % N;\n        for(int k = 0; k < 4; k++) {\n            int ni = i + dy[k], nj = j + dx[k];\n            if(ni < 0 || ni >= N || nj < 0 || nj >= N) {\n                continue;\n            }\n            State nextState = nowState;\n            swap(nextState.data[nowState.space_id],\n                 nextState.data[ni * N + nj]);\n            nextState.space_id = ni * N + nj;\n            if(!dp.count(nextState)) {\n                nextState.d++;\n                dp[nextState] = nextState.d;\n                que.emplace(Data{nextState, nextState.d + nextState.h()});\n            } else if(dp[nextState] > nowState.d + 1) {\n                dp[nextState] = nowState.d + 1;\n                nextState.d = nowState.d + 1;\n                que.emplace(Data{nextState, nextState.d + nextState.h()});\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                if (tmp == ans_str) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        steps = h0();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(char a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tchar board[3][3];\n\tchar distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tcin >> start.board[i][j];\n\n\t\t\tstart.board[i][j] -= 48;\n\t\t}\n\t}\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << (int)Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t\t\t\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tint val=calc(v);//,nxtval;\n\t\t//printf(\"[+] %d\\n\",val);\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\n//vector<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//    for (vector<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nstruct Node{\n\tvector<int> arr;\n\tint step;\n};\nconst int tx[]={1,0,-1,0};\nconst int ty[]={0,1,0,-1};\nvector<int> start,end;\nqueue<Node> sq;\nset<int> pan;\n\nvoid input()\n{\n\tint tmp;\n\tfor(int i=0;i!=3;++i)\n\t\tfor(int j=0;j!=3;++j)\n\t\t{\n\t\t\tcin>>tmp;\n\t\t\tstart.push_back(tmp);\n\t\t}\n\tfor(int i=0;i!=8;++i)\n\t\tend.push_back(i+1);\n\tend.push_back(0);\n}\n\nNode makenod(vector<int> tmp,int step)\n{\n\tNode res;\n\tres.arr=tmp;\n\tres.step=step;\n\treturn res;\n}\n\nint vton(vector<int> tmp)\n{\n\tint res=0;\n\tfor(int i=0;i!=9;++i)\n\t\tres=res*10+tmp[i];\n\treturn res;\n}\n\nint main()\n{\n\tinput();\n\n\tsq.push(makenod(start,0));\n\tpan.insert(vton(start));\n\t\n\tint ans;\n\twhile(!sq.empty())\n\t{\n\t\tNode now=sq.front();\tsq.pop();\n\n\t\tif(now.arr==end)\n\t\t{\n\t\t\tans=now.step;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ith;\n\t\tfor(int i=0;i!=9;++i)\n\t\t\tif(now.arr[i]==0)\n\t\t\t{\n\t\t\t\tith=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x=ith/3,y=ith%3;\n\t\t\n\t\tfor(int i=0;i!=4;++i)\n\t\t{\n\t\t\tint nx=x+tx[i],ny=y+ty[i];\t\n\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\tint num=vton(now.arr);\n\t\t\tif(nx>=0 && nx<3 && ny>=0 && ny<3 && pan.count(num)==0)\n\t\t\t{\n\t\t\t\tsq.push(makenod(now.arr,now.step+1));\n\t\t\t\tpan.insert(num);\t\t\n\t\t\t}\n\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"not solved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin >> p.f[i];\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tconst int MAX_N = 876543211;\n\tstd::vector<bool> visited(MAX_N);\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!eight_puzzle::visited[states[i].table]){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\teight_puzzle::visited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\n#define NN 9\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nvector<int> start(NN);\nvector<int> goal(NN);\nint bfs()\n{\n    queue<P> que;\n    map<vector<int>, int> mp;\n    que.push(P(start, 0));\n    mp[start] = 0;\n    while(que.size())\n    {\n        P p = que.front();\n        que.pop();\n        vector<int> now = p.first;\n        int res = p.second;\n        if(now == goal) return res;\n        int y, x, pos;\n        for(int i = 0; i < NN; i++)\n        {\n            if(now[i] != 0) continue;\n            x = i % 3;\n            y = i / 3;\n            pos = i;\n        }\n        res++;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(ny < 0 || nx < 0 || ny >= 3 || nx >= 3) continue;\n            int idx = 3 * ny + nx;\n            vector<int> next = now;\n            swap(next[pos], next[idx]);\n            if(mp.count(next) == 0 || mp[next] > res)\n            {\n                mp[next] = res;\n                que.push(P(next, res));\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(int i = 0; i < NN; i++) \n    {\n        cin >> start[i];\n        goal[i] = (i + 1) % NN;\n    }\n    cout << bfs() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n #define LIMIT 30\n\nstruct Puzzle{\n  int cont[9];\n  int space;\n  string path;\n  bool operator < ( const Puzzle &p ) const{\n    for ( int i = 0; i < 8; i++ ){\n      if ( cont[i] == p.cont[i] ) continue;\n      return cont[i] > p.cont[i];\n    }\n    return false;\n  }\n};\n\nint limit;\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char direction[4] = {'d', 'r', 'u', 'l'};\n\nbool isTarget(Puzzle puzzle){\n  for ( int i = 0; i < 9; i++ ){\n    if ( puzzle.cont[i] != 1 + i ) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ){\n      return u.path;\n    }\n\n    int sx, sy, tx, ty;\n    sx = u.space/3;\n    sy = u.space%3;\n\n    for ( int r = 0; r < 4; r++ ){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= 3 || ty >= 3 ) continue;\n      v = u;\n      swap(v.cont[u.space],v.cont[tx*3+ty]);\n      v.space = tx*3+ty;\n      if ( !V[v] ){\n\tV[v] = true;\n\tv.path += direction[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nmain(){\n  Puzzle in;\n  for ( int i = 0; i < 9; i++ ){\n    cin >> in.cont[i];\n    if ( in.cont[i] == 0 ) {\n      in.cont[i]=9;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortãªã©ã®å¼æ°ãçç¥ããã\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define ZERO(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//æ¬ä½\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nint main() {\n    PRE_COMMAND\n    array<int, 9> root;\n    INPUT(root);\n    map<array<int, 9>, int> d;  // æ ¹ããã®è·é¢\n    d[root] = 0;\n    vector<array<int, 9>> q = {root};\n    int cnt = 0;\n    while (q.size()) {  // BFS\n        cnt++;\n        vector<array<int, 9>> qq;\n        while (q.size()) {\n            array<int, 9> i = q.back();\n            q.pop_back();\n            vector<array<int, 9>> g;\n            int zero = (int)(find(i.begin(), i.end(), 0) - i.begin());\n\n            array<int, 9> temp;\n            temp = i;\n            if (zero % 3 != 0) {\n                swap(temp[zero - 1], temp[zero]);\n                g.push_back(temp);\n            }\n            temp = i;\n            if (zero % 3 != 2) {\n                swap(temp[zero + 1], temp[zero]);\n                g.push_back(temp);\n            }\n            temp = i;\n            if (zero / 3 != 0) {\n                swap(temp[zero - 3], temp[zero]);\n                g.push_back(temp);\n            }\n            temp = i;\n            if (zero / 3 != 2) {\n                swap(temp[zero + 3], temp[zero]);\n                g.push_back(temp);\n            }\n\n            for (auto j : g) {\n                if (d.find(j) == d.end()) {\n                    d[j] = cnt;\n                    qq.push_back(j);\n                }\n            }\n        }\n        q = qq;\n    }\n    PRINT(d[{1, 2, 3, 4, 5, 6, 7, 8, 0}]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//13_B ï¼ããºã«åé¡  8 Puzzle\n\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r=0;r<4;r++){\n      int tx = sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty >=N ) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx *N +ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans =bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nlong long int N = 9;\nlong long int finish_key;\nstd::map<int, int> keys;\n\nlong long int calc_key(const std::vector<long long int> & puzzle) {\n    long long int scale = 1;\n    long long int key = 0;\n    for (int i = 0; i < N; i++) {\n        key += scale * puzzle[i];\n        scale *= N;\n    }\n    return key;\n}\n\n\nstd::vector<long long int> move_up(std::vector<long long int> puzzle, int white_idx) {\n    if (white_idx + 3 < N) {\n        std::swap(puzzle[white_idx], puzzle[white_idx + 3]);\n    }\n    return puzzle;\n}\n\nstd::vector<long long int> move_down(std::vector<long long int> puzzle, int white_idx) {\n    if (0 <= white_idx - 3) {\n        std::swap(puzzle[white_idx], puzzle[white_idx - 3]);\n    }\n    return puzzle;\n}\n\nstd::vector<long long int> move_left(std::vector<long long int> puzzle, int white_idx) {\n    if (white_idx % 3 != 2) {\n        std::swap(puzzle[white_idx], puzzle[white_idx + 1]);\n    }\n    return puzzle;\n}\n\nstd::vector<long long int> move_right(std::vector<long long int> puzzle, int white_idx) {\n    if (white_idx % 3 != 0) {\n        std::swap(puzzle[white_idx], puzzle[white_idx - 1]);\n    }\n    return puzzle;\n}\n\nvoid search(int cnt, std::vector<long long int> puzzle) {\n    std::cout << cnt << std::endl;\n    if (keys.find(finish_key) != keys.end() && cnt >= keys[finish_key]) {\n        return;\n    }\n    long long int key = calc_key(puzzle);\n    if (key == finish_key) {\n        if (keys.find(key) == keys.end() || cnt < keys[key]){\n            keys[key] = cnt;\n        }\n        return;\n    }\n    if (keys.find(key) != keys.end()) {\n        if (cnt < keys[key]) {\n            keys[key] = cnt;\n        } else {\n            return;\n        }\n    } else {\n        keys[key] = cnt;\n    }\n    auto iter = std::find(puzzle.begin(), puzzle.end(), 0);\n    int white_idx = std::distance(puzzle.begin(), iter);\n    search(cnt + 1, move_up(puzzle, white_idx));\n    search(cnt + 1, move_down(puzzle, white_idx));\n    search(cnt + 1, move_left(puzzle, white_idx));\n    search(cnt + 1, move_right(puzzle, white_idx));\n}\n\n\nint main() {\n    std::vector<long long int> puzzle(N);\n    for (int i = 0; i < N; i++) {\n        std::cin >> puzzle[i];\n    }\n    finish_key = calc_key({1, 2, 3, 4, 5, 6, 7, 8, 0});\n    // search(0, puzzle);\n\n    long long int key = calc_key(puzzle);\n    int cnt = 0;\n    std::queue<std::pair<int, std::vector<long long int>>> queues;\n    while (key != finish_key) {\n        keys[key] = cnt;\n\n        auto iter = std::find(puzzle.begin(), puzzle.end(), 0);\n        int white_idx = std::distance(puzzle.begin(), iter);\n        {\n            auto next = move_up(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n        {\n            auto next = move_down(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n        {\n            auto next = move_left(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n        {\n            auto next = move_right(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n\n        auto que = queues.front();\n        queues.pop();\n        cnt = que.first;\n        puzzle = que.second;\n        key = calc_key(puzzle);\n    }\n    std::cout << cnt << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<vector<int>, int> P;\nmap<vector<int>, int> checked;\nqueue<P> que;\nint dy[4] = {1, 0, -1, 0};\nint dx[4] = {0, 1, 0, -1};\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> v;\n  FOR(i,0,9){\n    int n;\n    cin>>n;\n    v.push_back(n);\n  }\n  vector<int> goal = {1,2,3,4,5,6,7,8,0};\n  que.push(P(v, 0));\n  checked[v] = 0;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    vector<int> now = p.first;\n    int dist = p.second;\n    bool ok = true;\n    FOR(i,0,9){\n      if(now[i]!=goal[i]){\n        ok = false;\n        break;\n      }\n    }\n    if(ok){\n      cout << dist << endl;\n      return 0;\n    }\n    int x, y, zero;\n    FOR(i,0,9){\n      if(now[i]==0){\n        x = i % 3;\n        y = i / 3;\n        zero = i;\n        break;\n      }\n    }\n    FOR(i,0,4){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(ny<0||ny>=3||nx<0||nx>=3) continue;\n      int j = 3 * ny + nx;\n      vector<int> nxt = now;\n      swap(nxt[zero], nxt[j]);\n      if(checked.count(nxt)==0||checked[nxt] > dist + 1) {\n        checked[nxt] = dist + 1;\n        que.push(P(nxt, dist+1));\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        }\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\nstruct Puzzle {\n\tint st[9];\n\tint space, len;\n\tbool operator < (const Puzzle& rhs) const {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (st[i] == rhs.st[i]) continue;\n\t\t\treturn st[i] < rhs.st[i];\n\t\t}\n\t\treturn false;\n\t}\n} in;\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < 9; i++) {\n\t\tif (p.st[i] != i + 1) return false;\n\t}\n\treturn true;\n}\nint bfs() {\n\tqueue<Puzzle> q;\n\tset<Puzzle> s;\n\tq.push(in);\n\ts.insert(in);\n\twhile (!q.empty()) {\n\t\tPuzzle u = q.front(), v;\n\t\tq.pop();\n\t\tif (isTarget(u)) return u.len;\n\t\tint sx = u.space / 3, sy = u.space % 3;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tx = sx + dx[i], ty = sy + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\t\t\tv = u;\n\t\t\tv.space = tx * 3 + ty;\n\t\t\tv.len++;\n\t\t\tswap(v.st[u.space], v.st[v.space]);\n\t\t\tif (!s.count(v)) {\n\t\t\t\ts.insert(v);\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n    for (int i = 0; i < 9; i++) {\n    \tscanf(\"%d\", &in.st[i]);\n    \tif (in.st[i] == 0) {\n    \t\tin.space = i;\n    \t\tin.st[i] = 9;\n\t\t}\n\t}\n\tin.len = 0;\n\tprintf(\"%d\\n\", bfs());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nconst int N = 3;\nconst int NN = N*N;\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\n\n\n//n puzzle\nstruct Puzzle {\n\tint f[NN];\n\tint space;\n\tstring path;\n\tPuzzle() :path(\"\") {};\n\n\tbool operator<(const Puzzle &p)const {\n\t\tfor (int i = 0; i < NN; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n\tvoid input() {\n\t\tfor (int i = 0; i < NN; i++) {\n\t\t\tcin >> f[i];\n\t\t\tif (f[i] == 0) {\n\t\t\t\tf[i] = NN;\n\t\t\t\tspace = i;\n\t\t\t}\n\t\t}\n\t}\n\tvoid slide(int t) {\n\t\tswap(f[space], f[t]);\n\t\tspace = t;\n\t}\n};\n\nbool is_target(const Puzzle &p) {\n\tfor (int i = 0; i < NN; i++)\n\t\tif (p.f[i] != (i + 1))\n\t\t\treturn false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> mp;\n\tPuzzle u, v;\n\tq.emplace(s);\n\tmp[s] = true;\n\twhile (q.size()) {\n\t\tu = q.front(); q.pop();\n\t\tif (is_target(u))return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space%N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\t\tv = u;\n\t\t\tv.slide(tx*N + ty);\n\t\t\tif (mp[v])continue;\n\t\t\tmp[v] = true;\n\t\t\tv.path += dir[r];\n\t\t\tq.emplace(v);\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPuzzle p;\n\tp.input();\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint minimum = -1;\n\n\nint calcDiffSum(int table[3][3]){\n    int sum = 0;\n    for(int row=0;row<3;row++){\n        for(int col=0;col<3;col++){\n            if(table[row][col] != 0){\n                sum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n            }\n        }\n    }\n    return sum;\n}\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nvoid recursive(int table[3][3],int max_depth,int count,int pre_loc,int zero_loc){\n\tint diffSum = calcDiffSum(table);\n\tif(count == max_depth && diffSum == 0){\n\t\tminimum = max_depth;\n\t\treturn;\n\t}\n\n\tif(minimum != -1)return;\n\n\tint next_table[4][3][3],tmp_row,tmp_col,pre_row,pre_col;\n\tint dif1,dif2,dif3,dif4;\n\n\n\tswitch(zero_loc){\n\tcase 0:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)%3==0){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 1:\n\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 0){\n\t\t\tif((table[0][0]-1)%3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,0);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][1],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 2){\n\t\t\tif((table[0][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][0][1],next_table[2][0][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,2);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)%3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 0){\n\t\t\tif((table[0][0]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,0);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 11:\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)%3>=1){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)/3<=1){\n\t\t\t\tdif4 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif4 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tif(count < max_depth && dif4 <= max_depth-count){\n\t\t\t\trecursive(next_table[3],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 2){\n\t\t\tif((table[0][2]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,2);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 20:\n\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 21:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)%3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)/3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 22:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t}\n}\n\n\nvoid func(int table[3][3],int max_depth){\n\twhile(minimum == -1){\n\t\trecursive(table,max_depth,0,-1,zeroLoc(table));\n\t\tmax_depth += 2;\n\t}\n}\n\n\nint main(){\n\n    int table[3][3],start_count;\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n    start_count = calcDiffSum(table);\n\n    func(table,start_count);\n\n    printf(\"%d\\n\",minimum);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    int steps = 0;\n    while (!pq.empty()) {\n        steps++;\n        node u = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur) - 1);\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<map>\n\nusing namespace std;\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nclass puzzle{\npublic :\n  int f[9],space;\n  string path;\n\n  bool operator < (const puzzle &p) const{\n    for(int i=0;i<9;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nbool isTarget(puzzle p){\n  for(int i=0;i<9;i++){\n    if(p.f[i] !=(i+1))return false;\n  }\n  return true;\n}\n\nstring bfs(puzzle s){\n  queue<puzzle> Q;\n  map<puzzle,bool> V;\n  puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n    int sx=u.space/3;\n    int sy=u.space%3;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=3||ty>=3)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*3+ty]);\n      v.space = tx*3+ty;\n\n      if(!V[v]){\n\tV[v] =true;\n\tv.path +=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  puzzle in;\n  for(int i=0;i<9;i++){\n    cin >> in.f[i];\n    if(in.f[i] ==0){\n      in.f[i] = 9;\n      in.space=i;\n    }\n  }\n  string ans =bfs(in);\n  cout << ans.size()<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]){\n\tcontinue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n    if(p.f[i] != (i + 1)) return false;\n  }\n    return true;\n}\n\nstring bfs(Puzzle s){\n  \n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  \n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n\n    int sx = u.space / N;\n    int sy = u.space % N;\n\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n\tcontinue;\n      }\n\n      v = u;\n\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    \n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n  \n\t  \n      \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] != p.f[i]) {\n\t\t\t\treturn f[i] < p.f[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\nstring bfs(Puzzle p) {\n\tp.path = \"\";\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\tqueue<Puzzle> Q;\n\tQ.push(p);\n\tfor (int i = 0; i < N2; ++i) {\n\t\twhile (!Q.empty()) {\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (isComplete(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u;\n\t\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!M[v]) {\n\t\t\t\t\tM[v] = true;\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#define N 9\n#define n 3\n#define Blank 0\n#define up -N/n\n#define down N/n\n#define left -1\n#define right 1\n#define limit 34\nusing namespace std;\nstruct p{\n  int v[N];\n  int blankPlace;\n  int g=0;\n  int h=0;\n  bool operator < (const p& pazzle) const {\n    for(int i=0;i<N;i++){\n      if(v[i] == pazzle.v[i]) continue;\n      return v[i]<pazzle.v[i];\n    }\n    return false;\n  }\n};\npriority_queue <p, vector<p>, greater<p> > pazzle;\nmap <p,bool> existPazzle;\nbool operator > (const p a,const p b){return a.h+a.g>b.h+b.g;};\n\nint calculate_h(p this_pazzle,int i){\n  if(i == this_pazzle.blankPlace ) return abs(i/n-(N-1)/n)+abs(i%n-(N-1)/n);\n  else return abs(i/n-(this_pazzle.v[i]-1)/n)+abs(i%n-(this_pazzle.v[i]-1)%n);\n}\n\np checkPazzle(p thisPazzle){\n  thisPazzle.h = 0;\n    for(int i=0;i<N;i++)\n      thisPazzle.h += calculate_h(thisPazzle,i);\n  return thisPazzle;\n}\n\nvoid moveBlank(p thisPazzle,int move){\n  int moved = thisPazzle.blankPlace + move;\n  thisPazzle.g++;\n  //cout<<\"g: \"<<thisPazzle.g<<\" moved: \"<<moved<<endl;\n  swap(thisPazzle.v[thisPazzle.blankPlace],thisPazzle.v[moved]);\n  if(existPazzle[thisPazzle])return;\n  thisPazzle.blankPlace = moved;\n  thisPazzle = checkPazzle(thisPazzle);\n  if(thisPazzle.g+thisPazzle.h>limit)return;\n  pazzle.push(thisPazzle);\n}\n\nvoid movePazzle(p thisPazzle){\n  if(thisPazzle.blankPlace+up>=0)\n    moveBlank(thisPazzle,up);\n  if(thisPazzle.blankPlace+down<9)\n    moveBlank(thisPazzle,down);\n  if(thisPazzle.blankPlace + left >= 0&&thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+left)/3)\n    moveBlank(thisPazzle,left);\n  if(thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+right)/3)\n    moveBlank(thisPazzle,right);\n}\n\np dfs(){\n  p tmp,thisPazzle;\n  tmp.g = -1;\n  while(!pazzle.empty()){\n    thisPazzle = pazzle.top();\n    pazzle.pop();\n    existPazzle[thisPazzle]=true;\n    if(!thisPazzle.h)return thisPazzle;\n    movePazzle(thisPazzle);\n  }\n  return tmp;\n}\n\nint main(){\n  p thisPazzle;\n  for(int i=0;i<N;i++){\n    cin>>thisPazzle.v[i];\n    if(thisPazzle.v[i]==Blank)thisPazzle.blankPlace=i;\n  }\n  thisPazzle = checkPazzle(thisPazzle);\n  pazzle.push(thisPazzle);\n  thisPazzle = dfs();\n  cout<<thisPazzle.g<<endl;\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#define R 3\n#define L 3\n#define total 9\n#define TryCnt 45\nusing namespace std;\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;\nint val[total] ={};\n\n\nint main( void )\n{\n  int i = 0;\n  int x,y = 0;\n\n  for(i=0; i<total; i++)\n    {\n      cin>>val[i];\n      if(val[i] == 0)\n        {\n      num = i;\n        }\n    }\n\n  x = R - (num/L) -1;\n  y = L - (num%L) -1;\n\n  for(i=0; i<TryCnt; i++)\n    {\n      if( serch(x,y,i,4) == 1 )\n        {\n          cout<<i<<endl;\n      break;\n        }\n    }\n  return 0;\n}\nint serch(int x, int y, int MaxCnt, int pre)\n{\n  int result;\n  int i=0;\n\n  if(MaxCnt < (x + y) )\n    {\n      return 0;\n    }\n\n  if(MaxCnt==0)\n    {\n      for(i=0; i<total-1; i++)\n        if(val[i] != (i+1)) return 0;\n      return 1;\n    }\n\n for(i=0; i<4; i++)\n    {\n      result = 0;\n      switch(i)\n        {\n    case 0:\n      if( (x > 0) && (pre != 3) )\n        {\n          down_0();\n          result = serch(x-1, y, MaxCnt-1, 0);\n          up_0();\n        }\n      break;\n    case 1:\n      if( (y > 0) && (pre != 2) )\n        {\n          right_0();\n\n          result = serch(x, y-1, MaxCnt-1, 1);\n\n          left_0();\n        }\n      break;\n    case 2:\n      if( (y < L -1 ) && (pre != 1) )\n        {\n          left_0();\n          result = serch(x, y+1, MaxCnt-1, 2);\n          right_0();\n        }\n      break;\n    case 3:\n      if( (x < R -1 ) && (pre != 0) )\n        {\n          up_0();\n          result = serch(x+1, y, MaxCnt-1, 3);\n          down_0();\n        }\n      break;\n    default:\n      break;\n        }\n      if(result)\n        {\n      return 1;\n        }\n    }\n\n  return 0;\n}\n\ninline void down_0()\n{\n  val[num] = val[num + L];\n  num = num + L;\n}\n\ninline void up_0()\n{\n  val[num] = val[num - L];\n  num = num - L;\n}\n\ninline void right_0()\n{\n  val[num] = val[num +1];\n  num = num + 1;\n}\n\ninline void left_0()\n{\n  val[num] = val[num -1];\n  num = num - 1;\n}\n// å¥åä¾                                                                       \n\n// 1 3 0                                                                        \n// 4 2 5                                                                        \n// 7 8 6                                                                        \n\n// åºåä¾                                                                       \n\n// 4                                                                            \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nbitset<362880> ht;\ntypedef pair<int[9],int> state;\nqueue<state> q;\nconst int goal=46233;\n\nint hash(const int *board)\n{\n    const static int fact[]={40320,5040,720,120,24,6,2,1};\n    int h=0;\n    int work;\n    for(int i=0; i<8; i++) {\n        work=board[i];\n        for(int j=i-0; j>=0; j--) {\n            if(board[j]<work) --work;\n        }\n        h+=work*fact[i];\n    }\n    return h;\n}\n\nint search()\n{\n    while(!q.empty()) {\n        state now=q.front();\n        if(hash(now.first)==goal) return now.second;\n        q.pop();\n        int f;\n        for(f=0; now.first[f]; f++);\n        if(f%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        }\n        if((f+1)%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f>=3) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f<6) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n    }\n    return -1;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    state board;\n    board.second=0;\n    for(int i=0; i<9; i++) cin>>board.first[i];\n    ht.set(hash(board.first));\n    q.push(board);\n    cout<<search()<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\nconst int MOD = 1000000007;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nstatic const int N = 3;\nstatic const int T = 9;\n\nstruct Puzzle {\n    int f[T];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p) const {\n        REP(i, T) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] < p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    REP(i, T) if (p.f[i] != (i + 1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle p) {\n    queue<Puzzle> q;\n    map<Puzzle, bool> m;\n    p.path = \"\";\n    q.push(p);\n    m[p] = true;\n    while (!q.empty()) {\n        Puzzle u = q.front();\n        q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        REP(i, 4) {\n            int tx = sx + dx[i];\n            int ty = sy + dy[i];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            Puzzle v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!m[v]) {\n                m[v] = true;\n                v.path += dir[i];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(void) {\n    Puzzle in;\n    REP(i, T) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = T;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int W = 3;\n\nstruct Point{\n    ll x;\n    ll y;\n    Point(ll x, ll y): x(x), y(y) {}\n    Point(){}\n};\n\nstruct Puzzle{\n    ll A[W][W];\n    vector<ll> path;\n\n    Point get_space(){\n        Point p;\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x]==0){\n                    p.x = x;\n                    p.y = y;\n                    return p;\n                }\n            }\n        }\n        return p;\n    }\n\n    bool operator<(const Puzzle &b)const\n    {\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x] != b.A[y][x]){\n                    return A[y][x] < b.A[y][x];\n                }\n            }\n        }\n        return false;\n    }\n\n    bool is_solved(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                ll target = W*y + x + 1;\n                if(y==W-1 && x==W-1) target = 0;\n                if(A[y][x]!=target) return false;\n            }\n        }\n        return true;\n    }\n\n    void print(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                cout << A[y][x] << ' ';\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // åæç¶æ\n    auto p = Puzzle();\n    FOR(y, 0, 3){\n        FOR(x, 0, 3){\n            cin >> p.A[y][x];\n        }\n    }\n\n    map<Puzzle, bool> mp;\n    mp[p] = true;\n\n    queue<Puzzle> que;\n    que.push(p);\n\n    while(!que.empty()){\n        auto pu = que.front();\n        que.pop();\n\n        if(pu.is_solved()){\n            p(pu.path.size());\n            return 0;\n        }\n\n        FOR(i, 0, 4){\n            auto sp = pu.get_space();\n            ll x = sp.x;\n            ll y = sp.y;\n            \n            // target position\n            ll tx = x + dx[i];\n            ll ty = y + dy[i];\n\n            auto cp = pu;\n\n            // in range\n            if(0<=tx && tx<W && 0<=ty && ty<W){\n                swap(cp.A[y][x], cp.A[ty][tx]);\n\n                // ã¾ã ãã®ç¶æã«ãªã£ããã¨ããªããªãå¥ãã\n                if(mp[cp]!=true){\n                    mp[cp] = true;\n                    cp.path.push_back(i);\n                    que.push(cp);\n                }   \n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t        in.f[i] = 10;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 4e5 + 1;\n\nbool vis[N];\nint fac[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};\nstd::queue<std::pair<std::vector<int>, int>> q;\n\nint get_rank(std::vector<int> &cur) {\n  int rank = 0;\n  for (int i = 0; i < 9; ++i) {\n    int cnt = 0;\n    for (int j = i + 1; j < 9; ++j) {\n      if (cur[j] < cur[i]) cnt ++;\n    }\n    rank += cnt * fac[8 - i];\n  }\n  return rank;\n}\n\nvoid extend(std::vector<int> &cur, int pos, int step, int opr, int opc) {\n  auto nxt = cur;\n  int r = pos / 3;\n  int c = pos % 3;\n  int nr = r + opr;\n  int nc = c + opc;\n  if (nr >= 0 && nr < 3 && nc >= 0 && nc < 3) {\n    int np = nr * 3 + nc;\n    std::swap(nxt[pos], nxt[np]);\n    int rank = get_rank(nxt);\n    if (!vis[rank]) {\n      q.push({nxt,  step + 1});\n      vis[rank] = 1;\n    }\n\n  }\n}\n\nint main() {\n  while (!q.empty()) q.pop();\n  memset(vis, 0, sizeof(vis));\n  std::vector<int> goal = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  int target = get_rank(goal);\n  std::vector<int> st(9);\n  for (int i = 0; i < 9; ++i) std::cin >> st[i];\n  q.push({st, 0});\n  vis[get_rank(st)] = 1;\n  while (!q.empty()) {\n    auto cur = q.front();\n    q.pop();\n    auto p = cur.first;\n    int step = cur.second;\n    if (get_rank(p) == target) {\n      std::cout << step << std::endl;\n      return 0;\n    }\n    if (step + 1 > 45) continue;\n    int pos;\n    for (int i = 0; i < 9; ++i) {\n      if (p[i] == 0) pos = i;\n    }\n    extend(p, pos, step, 0, 1);\n    extend(p, pos, step, 0, -1);\n    extend(p, pos, step, 1, 0);\n    extend(p, pos, step, -1, 0);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\nclass Board {\npublic:\n  int board[3][3];\n  Board() {}\n  Board(int b[3][3]) {\n    REP(i, 3) {\n      REP(j, 3) {\n        board[i][j] = b[i][j];\n      }\n    }\n  }\n\n  int hash() {\n    int accum = 0;\n    int digit = 1;\n    REP(i, 3) {\n      REP(j, 3) {\n        accum += board[i][j] * digit;\n        digit *= 10;\n      }\n    }\n    return accum;\n  }\n  string to_str() {\n    string str = \"\";\n    REP(i, 3) {\n      REP(j, 3) {\n        str += \" \" + to_string(board[i][j]);\n      }\n      str += \"\\n\";\n    }\n    return str;\n  }\n  bool operator==( const Board& other) {\n    REP(i, 3) {\n      REP(j, 3) {\n        if (board[i][j] != other.board[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n};\n\nclass Nully;\nstatic Board Nully;\n\nBoard swap_with_upper(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i - 1][pos_j]);\n  return next;\n}\nBoard swap_with_lower(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i + 1][pos_j]);\n  return next;\n}\nBoard swap_with_left(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j - 1]);\n  return next;\n}\nBoard swap_with_right(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j + 1]);\n  return next;\n}\n\nint main() {\n  // int b[3][3] = {{1, 3, 0}, {4, 2, 5}, {7, 8, 6}};\n  int b[3][3];\n  REP(i, 3) {\n    REP(j, 3) {\n      cin >> b[i][j];\n    }\n  }\n\n  int g[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n  Board init(b);\n  Board goal(g);\n  // cout << init.to_str() << endl;\n\n  int depth = 0;\n  queue<pair<Board, int> > Q;\n  Q.push(make_pair(init, depth));\n\n  while (!Q.empty()) {\n    Board current = Q.front().first;\n    Board next;\n    int dpt = Q.front().second;\n    Q.pop();\n\n    if (goal == current) {\n      cout << dpt << endl;\n      return 0;\n    }\n\n    next = swap_with_upper(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_lower(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_left(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_right(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i<N2;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\nlong mhash(array<array<int,3>,3>& e) {\n\tlong res = 0;\n\tlong cb = 1;\n\tloop(i,0,9) {\n\t\tres += cb * e[i/3][i%3];\n\t\tcb = cb * 9;\n\t}\n\treturn res;\n}\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\n\nint main() {\n\tset<long> ald; \n\tarray<array<int,3>,3> pz;\n\tqueue<pair<array<array<int,3>,3> ,int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nint minimum=-1;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\tstack<long long>A,B;\n\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tA.push(makeLong(table));\n\tlong long tmp;\n\tbool foundFLG=false;\n\n\tfor(int count=0;count < 362880;count++){\n\t\tif(count%2 == 0){\n\t\t\twhile(!A.empty()){\n\t\t\t\ttmp = A.top();\n\t\t\t\tA.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0:\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\twhile(!B.empty()){\n\t\t\t\ttmp = B.top();\n\t\t\t\tB.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0: //??????\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t//??????\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(foundFLG)break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, s, n) for (int i = s; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\n// data\nint P[3][3];\n\nvoid solve();\nint main(){\n    rep(i, 3){\n        rep(j, 3){\n            cin >> P[i][j];\n        }\n    }\n\n    solve();\n}\n\nint manhattan(int (*P)[3]){\n    int dst = 0;\n    rep(i, 3){\n        rep(j, 3){\n            if(P[i][j] == 0) continue;\n\n            int ti = (P[i][j] - 1) / 3,\n                tj = (P[i][j] - 1) % 3; // target location\n            dst += abs(ti - i) + abs(tj - j);\n        }\n    }\n\n    return dst;\n}\n\ntypedef pair<int, int> Pi;\n\nstruct State{\n    State(int (*P0)[3], int move0, Pi blankBef, Pi blankNow){\n        rep(i, 3)\n            rep(j, 3)\n                P[i][j] = P0[i][j];\n        move = move0;\n        dst = manhattan(P) + move;\n        blank = blankNow;\n        _blank = blankBef;\n    }\n    friend bool operator>(State s0, State s1){\n        return s0.dst > s1.dst;\n    }\n    int dst;\n    int move;\n    int P[3][3];\n    pair<int, int> blank, _blank;\n};\n\nconst int di[4] = {-1, 1, 0 ,0},\n    dj[4] = {0,0,-1, 1};\nvoid solve(){\n    // find blank\n    int bi, bj;\n    rep(i, 3)\n        rep(j, 3) if (P[i][j] == 0) bi = i,\n                                    bj = j;\n\n    State s0(P, 0, Pi(bi, bj), Pi(bi, bj));\n    priority_queue<State, vector<State>, greater<State> > pq;\n    pq.push(s0);\n\n    while(!pq.empty()){\n        State s = pq.top(); pq.pop();\n\n        // check final\n        if(manhattan(s.P) == 0){\n            cout << s.move << endl;\n            break;\n        }\n        \n        rep(i, 4){\n            int ii, jj;\n            ii = s.blank.first + di[i];\n            jj = s.blank.second + dj[i];\n\n            if(ii>=0&&ii<3 && jj>=0&&jj<3 && Pi(ii, jj)!= s._blank){\n                swap(s.P[s.blank.first][s.blank.second], \n                    s.P[ii][jj]);\n\n                pq.push(State(s.P, s.move+1, s.blank, Pi(ii, jj)));\n\n                swap(s.P[s.blank.first][s.blank.second],\n                     s.P[ii][jj]);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntemplate < typename T >\nvoid vprint(T &V){\n\tfor(auto v : V){\n    \tcout << v << \" \";\n\t}\n\tcout << endl;\n}\n\nconst int W = 3;\n\nstruct Point{\n    ll x;\n    ll y;\n    Point(ll x, ll y): x(x), y(y) {}\n    Point(){}\n};\n\nstruct Puzzle{\n    ll A[W][W];\n    vector<ll> path;\n\n    Point get_space(){\n        Point p;\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x]==0){\n                    p.x = x;\n                    p.y = y;\n                    return p;\n                }\n            }\n        }\n        return p;\n    }\n\n    bool operator<(const Puzzle &b)const\n    {\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x] != b.A[y][x]){\n                    return A[y][x] < b.A[y][x];\n                }\n            }\n        }\n        return false;\n    }\n\n    bool is_solved(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                ll target = W*y + x + 1;\n                if(y==W-1 && x==W-1) target = 0;\n                if(A[y][x]!=target) return false;\n            }\n        }\n        return true;\n    }\n\n    void print(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                cout << A[y][x] << ' ';\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // åæç¶æ\n    auto p = Puzzle();\n    FOR(y, 0, 3){\n        FOR(x, 0, 3){\n            cin >> p.A[y][x];\n        }\n    }\n\n    // p.print();\n\n    // p.A[0][0] = 1;\n    // p.A[0][1] = 2;\n    // p.A[0][2] = 3;\n    \n    // p.A[1][0] = 4;\n    // p.A[1][1] = 5;\n    // p.A[1][2] = 6;\n    \n    // p.A[2][0] = 7;\n    // p.A[2][1] = 8;\n    // p.A[3][2] = 0;\n\n    // pn(p.is_solved());\n    // return 0;\n    \n\n    map<Puzzle, bool> mp;\n    mp[p] = true;\n\n    queue<Puzzle> que;\n    que.push(p);\n\n    while(!que.empty()){\n        auto pu = que.front();\n        que.pop();\n\n        // pu.print();\n        // br();\n\n        if(pu.is_solved()){\n            p(pu.path.size());\n            return 0;\n        }\n\n        FOR(i, 0, 4){\n            auto sp = pu.get_space();\n            ll x = sp.x;\n            ll y = sp.y;\n            \n            // target position\n            ll tx = x + dx[i];\n            ll ty = y + dy[i];\n\n            auto cp = pu;\n\n            // in range\n            if(0<=tx && tx<W && 0<=ty && ty<W){\n                swap(cp.A[y][x], cp.A[ty][tx]);\n\n                // ã¾ã ãã®ç¶æã«ãªã£ããã¨ããªã\n                if(mp[cp]!=true){\n                    mp[cp] = true;\n                    cp.path.push_back(i);\n                    que.push(cp);\n                }   \n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\tif (p == lastboard)\n\t{\n\t\treturn 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (D[p2] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (p2 == lastboard)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/*permutation-id <-> sequence*/\n\n#define MAX_DATASIZE 9\n\nint encode(const int *data, int size){\n  bool used[MAX_DATASIZE] = {};\n  int num = 0;\n  int t = 1;\n  \n  for(int i=1; i<=size; i++) t *= i;\n  \n  for(int i=size; i>=1; i--){\n    t /= i;\n    \n    int s = 0;\n    for(int j=0; j<data[size-i]; j++){\n      if(!used[j]) s++;\n    }\n    \n    used[data[size-i]] = true;\n    num += s * t;\n  }\n  \n  return num;\n}\n\nvoid decode(int num, int *data, int size){\n  bool used[MAX_DATASIZE] = {};\n  int t = 1;\n  \n  for(int i=1; i<=size; i++) t *= i;\n  for(int i=size; i>=1; i--){\n    t /= i;\n    \n    int s = num / t;\n    for(int j=0;;j++){\n      if(!used[j]){\n        if(s == 0){\n          data[size-i] = j;\n          used[j] = true;\n          break;\n        }\n        s--;\n      }\n    }\n    num %= t;\n  }\n}\n\n\n\nbool visited[9*8*7*6*5*4*3*2*1];\n\nint bfs(const int pazzle[9]){\n  queue<int> que;\n  que.push(encode(pazzle, 9));\n\n  int goal[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  int goalId = encode(goal, 9);\n  \n  for(int i=0;que.size();i++){\n    queue<int> que2;\n    while(que.size()){\n      int id = que.front(); que.pop();\n      if(visited[id]) continue;\n      visited[id] = true;\n      \n      if(id == goalId) return i;\n\n      int next[9];\n      decode(id, next, 9);  \n\n      for(int i=0;i<9;i++){  \n        if(next[i] == 0){\n          if(i/3 != 0){\n            swap(next[i], next[i-3]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i-3]);\n          }\n          if(i/3 != 2){\n            swap(next[i], next[i+3]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i+3]);\n          }\n          if(i%3 != 0){\n            swap(next[i], next[i-1]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i-1]);\n          }\n          if(i%3 != 2){\n            swap(next[i], next[i+1]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i+1]);\n          }\n          break;\n        }\n      }\n    }\n    que = que2;\n  }\n\n  return INF;\n}\n\nint main(){\n  int pazzle[9];\n\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      scanf(\"%d\", pazzle+(i*3+j));\n    }\n  }\n\n  cout << bfs(pazzle) << endl;\n\n  \n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nstruct Panel{\n\tint dat[3][3];\n\tint nx, ny;\n\n\tbool operator < (const Panel &p) const{\n\t\trep(i, 3)rep(j, 3)if (dat[i][j] != p.dat[i][j])return dat[i][j] < p.dat[i][j];\n\t\treturn false;\n\t}\n};\n\nPanel up(Panel p){\n\tif (p.ny != 0)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny - 1][p.nx]), --p.ny;\n\treturn p;\n}\n\nPanel down(Panel p){\n\tif (p.ny != 2)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny + 1][p.nx]), ++p.ny;\n\treturn p;\n}\n\nPanel left(Panel p){\n\tif (p.nx != 0)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny][p.nx - 1]), --p.nx;\n\treturn p;\n}\n\nPanel right(Panel p){\n\tif (p.nx != 2)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny][p.nx + 1]), ++p.nx;\n\treturn p;\n}\n\nbool check(Panel p){\n\trep(i, 3){\n\t\trep(j, 3){\n\t\t\tif (p.dat[i][j] != ((j + 1) + i * 3) % 9)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\ntypedef std::pair<Panel, int> MP;\n\nint main(){\n\tPanel p;\n\trep(i, 3){\n\t\trep(j, 3){\n\t\t\tstd::cin >> p.dat[i][j];\n\t\t\tif (p.dat[i][j] == 0)p.nx = j, p.ny = i;\n\t\t}\n\t}\n\n\tstd::queue<MP> que;\n\tstd::set<Panel> s;\n\tque.push(MP(p, 0));\n\n\twhile (!que.empty()){\n\t\tMP p = que.front();\n\t\tque.pop();\n\n\t\tif (s.find(p.first) != s.end())continue;\n\t\telse s.insert(p.first);\n\n\t\tif (check(p.first)){\n\t\t\tstd::cout << p.second << std::endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tque.push(MP(up(p.first), p.second + 1));\n\t\tque.push(MP(down(p.first), p.second + 1));\n\t\tque.push(MP(left(p.first), p.second + 1));\n\t\tque.push(MP(right(p.first), p.second + 1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans[3][3] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (f[i][j] != ans[i][j])\n                return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l) {\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> f[i][j];\n            if (f[i][j] == 0) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 50; ++i) {\n        if ((res = dfs(f, x, y, -1, 0, i)) >= 0) {\n            break;\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// File name: 8 Puzzle\n// Written by: by_sknight\n// Date: 2019/5/21\n#include <bits/stdc++.h>\nusing namespace std;\n#define size 3\n\n\nstruct Board {\n\tint P[size][size];\n\tint space_x, space_y;\n\tbool up() {\n\t\tif (space_y == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x][space_y - 1]);\n\t\tspace_y--;\n\t\treturn true;\n\t}\n\tbool down() {\n\t\tif (space_y == size - 1) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x][space_y + 1]);\n\t\tspace_y++;\n\t\treturn true;\n\t}\n\tbool left() {\n\t\tif (space_x == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x - 1][space_y]);\n\t\tspace_x--;\n\t\treturn true;\n\t}\n\tbool right() {\n\t\tif (space_x == size - 1) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x + 1][space_y]);\n\t\tspace_x++;\n\t\treturn true;\n\t}\n\tbool isOver() {\n\t\tint i, j, v;\n\t\tv = 1;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tif (i == size - 1 && j == size - 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (P[i][j] != v)\n\t\t\t\t\treturn false;\n\t\t\t\tv++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid operator=(const Board& obj) {\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tP[i][j] = obj.P[i][j];\n\t\t\t}\n\t\t}\n\t\tspace_x = obj.space_x;\n\t\tspace_y = obj.space_y;\n\t}\n\tbool operator<(const Board& obj) const{\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tif (P[i][j] < obj.P[i][j])\n\t\t\t\t\treturn true;\n\t\t\t\telse if (P[i][j] > obj.P[i][j])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nset<Board> status;\nBoard bo;\n\nvoid solution() {\n\tqueue<pair<Board, int> > Q;\n\tBoard now_board;\n\tint now_step;\n\tQ.push(make_pair(bo, 0));\n\twhile (1) {\n\t\tnow_board = Q.front().first;\n\t\tnow_step = Q.front().second;\n\t\tQ.pop();\n\t\t// å¦ææ»¡è¶³æç»æ¡ä»¶, éåºå¾ªç¯\n\t\tif (now_board.isOver()) {\n\t\t\tbreak;\n\t\t}\n\t\t// å¦æå½åæ£çç¶æå·²ç»åºç°è¿, åç´æ¥è·³è¿, å¤çä¸ä¸ä¸ª\n\t\tif (status.insert(now_board).second == false) { \n\t\t\tcontinue;\n\t\t}\n\t\t// å¦æå¯ä»¥åä¸ç§»å¨ç©ºæ ¼, åå°åä¸ç§»å¨ä¹åçç¶æä¸æ­¥æ°å­å¥éå\n\t\tif (now_board.up()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\t// ä¹åæ¢å¤ä¹åçç¶æ\n\t\t\tnow_board.down();\n\t\t}\n\t\t// ä»¥ä¸ä¸ä¸ªåä¸\n\t\tif (now_board.down()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\tnow_board.up();\n\t\t}\n\t\tif (now_board.left()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\tnow_board.right();\n\t\t}\n\t\tif (now_board.right()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\tnow_board.left();\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tcout << now_step << endl;\n\treturn;\n}\n\nint main(void) {\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < size; j++) {\n\t\t\tcin >> bo.P[i][j];\n\t\t\tif (bo.P[i][j] == 0) {\n\t\t\t\tbo.space_x = i;\n\t\t\t\tbo.space_y = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n//goal\nint final[N][N] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    solve(initial, x, y, final);\n    path -= 1;\n    cout << path << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct State\n{\n\tint puzzle[9];\n\tint depth;\n\tint evaluation;\n\n\tbool operator<(const State& s)const\n\t{\n\t\treturn evaluation < s.evaluation;\n\t}\n\n\tbool operator>(const State& s)const\n\t{\n\t\treturn evaluation > s.evaluation;\n\t}\n\n\tbool operator==(const State& s)const\n\t{\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (puzzle[i] != s.puzzle[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nState goal;\nvector<State> checkedState;\n\nint heuristic(State s)\n{\n\tint eva = 0;\n\tint pos1[9], pos2[9];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tpos1[s.puzzle[i]] = i;\n\t\tpos2[goal.puzzle[i]] = i;\n\t}\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint manhattan = 0;\n\t\tmanhattan += abs(pos1[i] / 3 - pos2[i] / 3);\n\t\tmanhattan += abs(pos1[i] % 3 - pos2[i] % 3);\n\t\teva += manhattan;\n\t}\n\treturn eva;\n}\n\nint solve(State start)\n{\n\tpriority_queue<State, vector<State>, greater<State>> pq;\n\n\tpq.push(start);\n\n\twhile (!pq.empty())\n\t{\n\t\tState ts = pq.top();\n\t\tpq.pop();\n\n\t\tcheckedState.push_back(ts);\n\n\t\tif (ts == goal)\n\t\t{\n\t\t\treturn ts.depth;\n\t\t}\n\n\t\tint zeroi = -1;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (ts.puzzle[i] == 0)\n\t\t\t{\n\t\t\t\tzeroi = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zeroi <= 5)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 3];\n\t\t\ttts.puzzle[zeroi + 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t\tif (zeroi % 3 != 2)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 1];\n\t\t\ttts.puzzle[zeroi + 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t\tif (zeroi % 3 != 0)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 1];\n\t\t\ttts.puzzle[zeroi - 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t\tif (3 <= zeroi)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 3];\n\t\t\ttts.puzzle[zeroi - 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tState start;\n\n\tgoal.depth = 0;\n\tgoal.evaluation = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tgoal.puzzle[i] = (i + 1) % 9;\n\t}\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tstart.puzzle[i] = n;\n\t}\n\n\tstart.depth = 0;\n\tstart.evaluation = 0;\n\n\tprintf(\"%d\\n\", solve(start));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    int steps = 0;\n    while (!pq.empty()) {\n        steps++;\n        node u = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0 && goal[u.zeroI - 1][u.zeroJ] != u.puzzle[u.zeroI - 1][u.zeroJ]) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3 && goal[u.zeroI + 1][u.zeroJ] != u.puzzle[u.zeroI + 1][u.zeroJ]) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0 && goal[u.zeroI][u.zeroJ - 1] != u.puzzle[u.zeroI][u.zeroJ - 1]) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3 && goal[u.zeroI][u.zeroJ + 1] != u.puzzle[u.zeroI][u.zeroJ + 1]) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur) - 1);\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Puzzle p){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!=Q.empty()){\n    u=Q.front();Q.pop();\n    is(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define N 3\n#define N2 9\n  \nstruct 8puzzle{\nint f[N2];\nint space;\nstring path;\n  \nbool operator < (const 8puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n  \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n  \nbool isTarget(8puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n  \nstring bfs(8puzzle s){\nqueue<8puzzle> Q;\nmap<8puzzle, bool> V;\n8puzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n  \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"\";\n}\n  \nint main(){\n8puzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n  \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue> \nusing namespace std;\nint map[5][5];\nint dx[5]={0,0,1,-1},dy[5]={1,-1,0,0};\nqueue<int> a1,a2,a3,a4,a5,a6,a7,a8,a9,jx,jy;\nqueue<int> a;\nbool pd[45000000];\nint main(){\n\tfor(int i=1;i<=3;i++){\n\t\tfor(int j=1;j<=3;j++) {\n\t\t    cin>>map[i][j];\n\t\t    if(i==1 && j==1) a1.push(map[i][j]);\n\t\t    else if(i==1 && j==2) a2.push(map[i][j]);\n\t\t    else if(i==1 && j==3) a3.push(map[i][j]);\n\t\t    else if(i==2 && j==1) a4.push(map[i][j]);\n\t\t    else if(i==2 && j==2) a5.push(map[i][j]);\n\t\t    else if(i==2 && j==3) a6.push(map[i][j]);\n\t\t    else if(i==3 && j==1) a7.push(map[i][j]);\n\t\t    else if(i==3 && j==2) a8.push(map[i][j]);\n\t\t    else if(i==3 && j==3) a9.push(map[i][j]);\n\t\t    if(map[i][j]==0){\n\t\t    \tjx.push(i);\n\t\t    \tjy.push(j);\n\t\t    \ta.push(0);\n\t\t    }\n\t\t}\n\t}\n\tint jishu=0;\n\tjishu=a1.front();\n\tjishu=jishu*9+a2.front();\n\tjishu=jishu*9+a3.front();\n\tjishu=jishu*9+a4.front();\n\tjishu=jishu*9+a5.front();\n\tjishu=jishu*9+a6.front();\n\tjishu=jishu*9+a7.front();\n\tjishu=jishu*9+a8.front();\n\tpd[jishu]=1;\n\tjishu=0;\n\twhile(a1.front()!=1  || a2.front()!=2 || a3.front()!=3 || a4.front()!=4 || a5.front()!=5 || a6.front()!=6 || a7.front()!=7 || a8.front()!=8 || a9.front()!=0){\n\t\tfor(int i=0;i<=3;i++){\n\t\t\tif(jx.front()+dx[i]>=1 && jx.front()+dx[i]<=3 && jy.front()+dy[i]>=1 && jy.front()+dy[i]<=3){\n\t\t\t\tmap[1][1]=a1.front();\n\t\t        map[1][2]=a2.front();\n\t\t        map[1][3]=a3.front();\n\t\t        map[2][1]=a4.front();\n\t\t        map[2][2]=a5.front();\n\t\t        map[2][3]=a6.front();\n\t\t        map[3][1]=a7.front();\n\t\t        map[3][2]=a8.front();\n\t\t        map[3][3]=a9.front();\n\t\t\t\t\n\t\t\t\tmap[jx.front()][jy.front()]=map[jx.front()+dx[i]][jy.front()+dy[i]];\n\t\t\t\tmap[jx.front()+dx[i]][jy.front()+dy[i]]=0;\n\t\t\t\t\n\t\t\t\tjishu=map[1][1];\n\t            jishu=jishu*9+map[1][2];\n\t            jishu=jishu*9+map[1][3];\n\t            jishu=jishu*9+map[2][1];\n\t            jishu=jishu*9+map[2][2];\n\t            jishu=jishu*9+map[2][3];\n\t            jishu=jishu*9+map[3][1];\n\t            jishu=jishu*9+map[3][2];\n\t            \n\t\t\t\tif(pd[jishu]==1) continue;\n\t            else pd[jishu]=1;\n\t\t\t    \n\t\t\t\tfor(int i1=1;i1<=3;i1++){\n\t\t\t    \tfor(int i2=1;i2<=3;i2++){\n\t\t\t    \t\tif(i1==1 && i2==1) a1.push(map[i1][i2]);\n\t\t                else if(i1==1 && i2==2) a2.push(map[i1][i2]);\n\t\t                else if(i1==1 && i2==3) a3.push(map[i1][i2]);\n\t\t                else if(i1==2 && i2==1) a4.push(map[i1][i2]);\n\t\t                else if(i1==2 && i2==2) a5.push(map[i1][i2]);\n\t\t                else if(i1==2 && i2==3) a6.push(map[i1][i2]);\n\t\t                else if(i1==3 && i2==1) a7.push(map[i1][i2]);\n\t\t                else if(i1==3 && i2==2) a8.push(map[i1][i2]);\n\t\t                else a9.push(map[i1][i2]);\n\t\t\t    \t}\n\t\t\t    }\n\t\t\t    jx.push(jx.front()+dx[i]);\n\t\t\t    jy.push(jy.front()+dy[i]);\n\t\t\t    a.push(a.front()+1);\n\t\t\t}\n\t\t\n\t\t}\n\t\ta1.pop(); \n\t\ta2.pop(); \n\t\ta3.pop(); \n\t\ta4.pop(); \n\t\ta5.pop(); \n\t\ta6.pop(); \n\t\ta7.pop(); \n\t\ta8.pop(); \n\t\ta9.pop(); \n\t\tjx.pop();\n\t\tjy.pop();\n\t\ta.pop();\n\t} \n\tcout<<a.front()<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == n.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] < n.f[i];\n\t\t}\n\t\treturn false;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < (const Puzzle &p) const{\n        for(int i = 0;i<N2;i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i = 0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0;r<4;r++){\n            int tx = sx+dx[r];\n            int ty = sy+dy[r];\n            if(tx<0 || ty<0 || tx >=N || ty >=N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N+ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    \n    for(int i = 0;i<N2;i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0 ){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nbool check(BOARD &b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth, int dir) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int est = 0;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (i * j == boardw * boardw) continue;\n            for (int k = 0; k < boardw; ++k) {\n                for (int l = 0; l < boardw; ++l) {\n                    if (i * boardw + j + 1 == b.map[k][l]) {\n                        est += std::abs(k - i) + std::abs(l - j);\n                    }\n                }\n            }\n        }\n    }\n    if (est > depth) {\n        return -1;\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        if (dir != -1 && k == (dir + 2) % 4) {\n            continue;\n        }\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1, k);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    if (check(b)) {\n        cout << 0 << endl;\n        return 0;\n    }\n    int i = 0;\n    while(++i) {\n        int ret = dfs(b, i, -1);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    /*bool operator == (const puzzle &t1) const {\n        for(int i=0;i<N2;++i){\n            if(f[i] != t1.f[i]) return false;\n        }\n        return true;\n    }*/\n    bool operator < (const puzzle &t1) const {\n        for(int i=0;i<N2;++i){\n            if(f[i] == t1.f[i]) continue;\n            return f[i] > t1.f[i];\n        }\n        return false;\n    }\n};\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char dstr[4] = {'d','l','u','r'};\n\nbool target(puzzle u){\n    for(int i=0;i<N2;++i){\n        if(u.f[i] != i+1) return false;\n    }\n    return true;\n}\n\nstring bfs(puzzle init){\n    map<puzzle,bool> m;\n    m[init] = true;\n    queue<puzzle> q;\n    q.push(init);\n    puzzle u, v;\n    int sx, sy, tx, ty;\n    while(!q.empty()){\n        u = q.front();\n        q.pop();\n        if(target(u)) return u.path;\n        tx = u.space/N;\n        ty = u.space%N;\n        for(int i=0;i<4;++i){\n            sx = tx + dx[i];\n            sy = ty + dy[i];\n            if(sx<0 || sy<0 || sx>=N || sy>=N) continue;\n            v = u;\n            v.space = sx*N+sy;\n            swap(v.f[u.space],v.f[v.space]);\n            if(!m[v]){\n                m[v] = true;\n                v.path += dstr[i];\n                q.push(v);\n            }\n        }\n    }\n}\n\n\nint main(){\n    puzzle init;\n    init.path = \"\";\n    for(int i=0;i<N2;++i){\n        cin>>init.f[i];\n        if(init.f[i]==0){\n            init.f[i] = N2;\n            init.space = i;\n        }\n    }\n    string res = bfs(init);\n    cout<<res.size()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n#define H 3\n#define W 3\n#define begin 1\n#define end 4\nstruct BOARD{\n        int board[5][5],y,x,count;\n        bool operator<(const BOARD &other)const{\n                for(int i=begin ; i<end ; i++ )\n                        for(int j=begin ; j<end ; j++ ){\n                                if(board[i][j]==other.board[i][j])\n                                        continue;\n                                return board[i][j]>other.board[i][j];\n                        }\n                return false;\n        }\n};\nbool check(BOARD now){\n        int s=1;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        if(now.board[i][j]==s){\n                                s++;\n                                s%=9;\n                        }else return false;\n                }\n        }\n}\nint main(){\n        int direction[5]={-1,0,1,0,-1};\n        map <BOARD,bool> past;\n        BOARD board;\n        board.count=0;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        cin >> board.board[i][j] ;\n                        if(board.board[i][j]==0){\n                                board.y=i;\n                                board.x=j;\n                        }\n                }\n        }\n        queue<BOARD> circle;\n        circle.push(board);\n        int count=0;\n        while(circle.size()!=0){\n                board=circle.front();circle.pop();\n                if(board.y<1 || board.y>=4 )continue;\n                if(board.x<1 || board.x>=4 )continue;\n                past[board]=true;\n                if(check(board)){\n                        cout << board.count << endl;\n                        break;\n                }\n                for(int i=0 ; i<4 ; i++ ){\n                        int y=board.y+direction[i];\n                        int x=board.x+direction[i+1];\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                        board.count++;\n                        circle.push(board);\n                        board.count--;\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nint main() {\n    std::vector<int> pazzle(9);\n    for (int i = 0; i < 9; i++) {\n        std::cin >> pazzle[i];\n    }\n\n    \n\n    std::map<std::vector<int>, int> m;\n    std::queue <std::pair<std::vector<int>, int> > q;\n\n    m[pazzle] = 0;\n\n    std::vector<int> ans(9);\n    for (int i = 0; i < 9; i++) {\n        ans[i] = (i + 1) % 9;\n    }\n\n    if (pazzle == ans) {\n        std::cout << 0 << std::endl;\n        return 0;\n    }\n    m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] = 10000;\n\n    q.push({pazzle, 0});\n    while (!q.empty()) {\n        pazzle = q.front().first;\n        int num = q.front().second;\n        q.pop();\n        if (m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] != 0 && m[{1, 2, 3, 4, 5, 6, 7, 8, 0}]  < num) break;\n        //if (m[pazzle] != 0 && m[pazzle] <= num) continue;\n\n        int space = std::find(pazzle.begin(), pazzle.end(), 0) - pazzle.begin();\n\n        if (space > 2) {\n            std::swap(pazzle[space], pazzle[space - 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({pazzle, num + 1});\n            }\n            std::swap(pazzle[space], pazzle[space - 3]);\n        }\n        if (space < 6) {\n            std::swap(pazzle[space], pazzle[space + 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 3]);\n        }\n        if (space % 3 != 0) {\n            std::swap(pazzle[space], pazzle[space - 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space - 1]);\n        }\n        if (space % 3 != 2) {\n            std::swap(pazzle[space], pazzle[space + 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 1]);\n        }\n    }\n\n    std::cout << m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n//    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        goto END;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 8ããºã«\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<string>\n#include<map>\n\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    // --------------------------------------------------\n    // map ã®ã­ã¼ã§ãã Puzzle ã¯ã©ã¹ãã­ã¼é ã«ä¸¦ã¹ãããã®å®ç¾©\n    // --------------------------------------------------\n    bool operator < (const Puzzle &p ) const\n    {\n        for(int i = 0; i < N2; i++)\n        {\n            if( f[i] == p.f[i] )\n            {\n                continue;\n            }\n\n            return f[i] > p.f[i];\n        }\n\n        return false;\n    }\n};\n\n// ããã«ã® x è»¸æ¹åã¸ã®ç§»å\nstatic const int dx[4] = {-1, 0 , 1, 0};\n// ããã«ã® y è»¸æ¹åã¸ã®ç§»å\nstatic const int dy[4] = {0, -1, 0, 1};\n// ããã«ã®äº¤ææä½ãè¡¨ãæå­å ( ä¸, å·¦, ä¸, å³ )\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\n// ä¸¦ã³æ¿ããçµæãç®æ¨ã«å°éãã¦ããããæ¤ç´¢ãã\nbool isTarget(Puzzle p)\n{\n    for(int i = 0; i < N2; i++)\n    {\n        if( p.f[i] != ( i + 1 ) )\n        {\n            // 1 ã 9 ã®é çªã§ä¸¦ãã§ãããç®æ¨å°é\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// ä¸¦ã³æ¿ããå®æ½ããã¯ã©ã¹\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> Map_V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    Map_V[s] = true;\n\n    while( !Q.empty() )\n    {\n        u = Q.front();\n        Q.pop();\n\n        if( isTarget(u) )\n        {\n            // ç®æ¨ã«å°éãã\n            return u.path;\n        }\n\n        // ã¼ã­ã®ä½ç½®ãéåã®è¦ç´ No.ã«å¤æãã\n        // x : ç¸¦æ¹å, y : æ¨ªæ¹å\n        int sx = u.space / N;\n        int sy = u.space % N;\n\n        for(int r = 0; r < 4; r++)\n        {\n            // ç¡æ¡ä»¶ã«å¨æ¹åã«ç§»åããã\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n\n            if( tx < 0 || ty < 0 || tx >= N || ty >= N )\n            {\n                // ç§»åããçµæ, ç¯å²å¤ãªãå¦çãã¹ã­ãããã\n                continue;\n            }\n\n            // u ã¯åãã¼ã¿ã§ä¸¦ã³æ¿ãã®åã®ç¶æãä¿æããå¿è¦ãããã®ã§, ä¸¦ã³æ¿ãã¯ã³ãã¼ããå¤æ°ã§è¡ã\n            v = u;\n\n            // ããã«ãå¥ãæ¿ãã\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            // ã¼ã­ã®ä½ç½®ãå¥ãæ¿ãã\n            v.space = tx * N + ty;\n\n            // æ¢ã«æ¤ç´¢æ¸ã¿ã®ç¶æããèª¿ã¹ã\n            if( !Map_V[v] )\n            {\n                // æ¤ç´¢æ¸ã¿ã§ãããã¨ãè¨æ¶ãã\n                Map_V[v] = true;\n                // ããã«ã®ç§»åæ¹åãè¨æ¶ãã¦ãã\n                v.path += dir[r];\n                // ã­ã¥ã¼ã«ååº¦ããã·ã¥ãã\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n\n}\n\nint main(void)\n{\n    Puzzle in;\n\n    for(int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n\n        if( in.f[i] == 0 )\n        {\n            // ããã«ã®ã¼ã­ã®ä½ç½®ãè¨­å®ãã\n            in.f[i] = N2; // set space\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "///IDA*\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint Map[4][4];\nint max1,min1;\nint start_x,start_y;\nint flag;\nint c[4][2]= {0,1,-1,0,1,0,0,-1};///å³ï¼0ï¼ï¼ä¸ï¼1ï¼ï¼ä¸ï¼2ï¼ï¼å·¦ï¼3ï¼ï¼\n\nint HMD()///æ¼åé¡¿è·ç¦»ï¼\n{\n    int i,j,num=0;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n            if(Map[i][j]==0)\n                continue;\n            else\n                num+=fabs((Map[i][j]-1)/3-i)+fabs((Map[i][j]-1)%3-j);\n    return num;\n}\n\nvoid start_xyz()///0çèµ·å§ä½ç½®ï¼\n{\n    int i,j;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n            if(Map[i][j]==0)\n            {\n                start_x=i;\n                start_y=j;\n                return ;\n            }\n}\n\nvoid swap(int *a,int *b)///äº¤æ¢å½æ°;\n{\n    int t;\n    t=*a;\n    *a=*b;\n    *b=t;\n}\n\nvoid dfs(int x,int y,int s,int last_step)\n{\n    if(flag)\n        return ;\n    if(s==max1)///å½ç»æç­äºå½ååå®æä¼è§£ï¼\n    {\n        int l=HMD();\n        if(l==0)///ä¸ç®æ ç¶æç¸åï¼\n        {\n            min1=s;///è®°å½ç»æï¼\n            flag=1;\n        }\n        return ;\n    }\n    for(int i=0; i<4; i++)\n    {\n        if(last_step+i==3&&s>0)///åä¸æ¬¡æ¹åä¸è½ç¸åï¼\n            continue;\n        int dx=x+c[i][0];\n        int dy=y+c[i][1];\n        if(dx<0||dy<0||dx>=3||dy>=3)///æ¯å¦è¶çï¼\n            continue;\n        swap(&Map[dx][dy],&Map[x][y]);///åäº¤æ¢0åè¦äº¤æ¢æ°çå¼ï¼\n        if(HMD()+s<=max1&&!flag)///IDA*åªæãæ ¸å¿ï¼å½åæ¼åé¡¿è·ç¦»+å½åæ·±åº¦<=åå®æä¼è§£ï¼\n        {\n            dfs(dx,dy,s+1,i);\n            if(flag)\n                return ;\n        }\n        swap(&Map[dx][dy],&Map[x][y]);///åæº¯ï¼\n    }\n}\nint main()\n{\n    char a[10];\n    int i,j;\n    for(i=0;i<3;i++)\n        for(j=0;j<3;j++)\n            scanf(\"%d\",&Map[i][j]);\n    start_xyz();///æ¾å°0çèµ·å§ä½ç½®ï¼\n    max1=HMD();///åå§åå®æä¼è§£ï¼\n    flag=0;\n    while(!flag)\n    {\n        dfs(start_x,start_y,0,0);\n        if(!flag)\n            max1++;///å¢å åå®æä¼è§£ï¼\n    }\n    printf(\"%d\\n\",min1);\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\nbool in(int a,int b){\n  if(a<0||b<0||3<=a||3<=b)return false;\n  return true;\n}\nint main(){\n  int a;\n  string start=\"\",goal=\"123456780\";\n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n  queue<string> q;\n  map<string,int> m;\n  m[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    if(u==goal){\n      cout<<m[u]<<endl;\n      break;\n    }\n    int s=-1;\n    for(int i=0;i<u.length();i++)if(u[i]=='0')s=i;\n    int y=s/3,x=s%3;\n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int g=ny*3+nx;\n      string t=u;\n      swap(t[s],t[g]);\n      if(m.find(t)==m.end()){\n        m[t]=m[u]+1;\n        q.push(t);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define NPANEL 9\n\nclass State {\npublic:\n  int panels[9];\n  int empty;\n  State(int p[]) {\n    for (int i = 0; i < NPANEL; i++) {\n      panels[i] = p[i];\n      if (p[i] == 0)\n        empty = i;\n    }\n  }\n  void print() {\n    for (int i = 0; i < NPANEL; i++) {\n      if (i != 0 && i % 3 == 0)\n        printf(\"\\n\");\n      printf(\"%d \", panels[i]);\n    }\n  }\n  bool is_completed() {\n    for (int i = 1; i < NPANEL; i++)\n      if (panels[i - 1] != i)\n        return false;\n    return true;\n  }\n  State left() { return slide(empty, empty - 1); }\n  State above() { return slide(empty, empty - 3); }\n  State right() { return slide(empty, empty + 1); }\n  State bottom() { return slide(empty, empty + 3); }\n  State slide(int x, int y) {\n    auto s = State(panels);\n    swap(s.panels[x], s.panels[y]);\n    s.empty = y;\n    return s;\n  }\n\n  vector<State> nexts() {\n    vector<State> v;\n    if (empty % 3 != 0)\n      v.push_back(left());\n    if (empty >= 3)\n      v.push_back(above());\n    if (empty % 3 != 2)\n      v.push_back(right());\n    if (empty <= 5)\n      v.push_back(bottom());\n    return v;\n  }\n};\n\nbool store(State st) {\n  static set<int> pool;\n  int hash = 0;\n  for (int i = 0; i < NPANEL; i++) {\n    hash *= 10;\n    hash += st.panels[i];\n  }\n  bool exists = (pool.find(hash) != pool.end());\n  if (!exists)\n    pool.insert(hash);\n  return !exists;\n}\n\nstruct Node {\n  State state;\n  int depth;\n};\n\nint solve(State init) {\n  queue<Node> que;\n  que.push(Node{init, 0});\n\n  while (!que.empty()) {\n    Node node = que.front();\n    for (auto s : node.state.nexts()) {\n      if (s.is_completed()) {\n        return node.depth + 1;\n      }\n      if (store(s)) {\n        que.push(Node{s, node.depth + 1});\n      }\n    }\n    que.pop();\n  }\n}\n\nint main() {\n  int data[NPANEL];\n  for (int i = 0; i < NPANEL; i++)\n    cin >> data[i];\n\n  auto s = State(data);\n  cout << solve(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\nbool operator < (const Puzzle &p)const{\n  for(int i=0;i<N2;i++){\n    if(f[i] == p.f[i])continue;\n    return f[i] > p.f[i];\n  }\n  return false;\n}\n};  \n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i + 1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r<4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0||ty<0||tx>=N||ty>=N)continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for( int i = 0; i < N2; i++){\n      if( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for( int i = 0; i < N2; i++ )\n    if( p.f[i] != (i + 1) )return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if( isTarget(u) )return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for( int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for( int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n/*\n  Topic13 ProblemB 8Puzzle\n  8 ããºã«ã¯ï¼ã¤ã®ç©ºç½ãå«ã 3Ã3 ã®ãã¹ä¸ã« 8 æã®ããã«ãéç½®ããã\n  ç©ºç½ãä½¿ã£ã¦ããã«ãä¸ä¸å·¦å³ã«ã¹ã©ã¤ããããçµµæãæããããºã«ã§ãã\n\n  å¥å\n  å¥åã¯ããã«ã®æ°å­ãããã¯ç©ºç½ãè¡¨ã 3Ã3ãåã®æ´æ°ã§ãã\n  ç©ºç½ã§åºåããã 3 ã¤ã®æ´æ°ã 3 è¡ã§ä¸ãããã¾ãã\n\n  åºå\n  æç­ææ°ãï¼è¡ã«åºåãã¦ãã ããã\n\n  use C++\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2]; //??????????????????????????Â°???\n\tint space; //0?????\\??Â£???????????????\n\tstring path; //???????????Â§?????????????????????\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++){\n\t\t\tif (f[i] == p.f[i]) continue; //?????Â£??Â¨?????????????Â´???Â§?????????\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false; //??????????????????\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor (int i = 0; i < N2; i++){\n\t\tif (p.f[i] != (i + 1)) return false; //0???????????Â£??????????????????????????Â£???\n\t}\n\treturn true; //???????????????\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\"; //???????????????????Â¨????\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N; //space????????Â§?Â¨?\n\t\tint sy = u.space % N; //space????Â¨???Â§?Â¨?\n\t\tfor (int r = 0; r < 4; r++){\n\t\t\tint tx = sx + dx[r]; //?????Â§?Â¨?\n\t\t\tint ty = sy + dy[r]; //?Â¨???Â§?Â¨?\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue; //???????????????\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++){\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0){\n\t\t\tin.f[i] = N2; //0?????Â´???9???????????????\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl; //unsolvable?????Â´??????10????????????????????????????????Â¶???????????????????????????\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nusing namespace std;\n\nusing LL = long long int;\nusing LD = long double;\n\nusing pii = pair<int, int>;\nusing pll = pair<LL, LL>;\nusing pdd = pair<double, double>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vl = vector<LL>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\n\nconst int INF = (1 << 30) - 1;\nconst LL INF64 = ((LL)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\nconst char dir[4] = { 'u', 'l', 'd', 'r' };\n\nint gcd(int x, int y) { return y ? gcd(y, x % y) : x; }\nLL gcd(LL x, LL y) { return y ? gcd(y, x % y) : x; }\n\nconst int N = 3, N2 = 9;\n\nstruct Puzzle {\n\tint board[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (board[i] == p.board[i]) continue;\n\t\t\treturn board[i] > p.board[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++) {\n\t\tif (p.board[i] != i + 1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> que;\n\tmap<Puzzle, bool> mp;\n\tp.path = \"\";\n\tque.push(p);\n\tmp[p] = true;\n\n\twhile (!que.empty()) {\n\t\tPuzzle u = que.front(); que.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tconst int sx = u.space / N;\n\t\tconst int sy = u.space % N;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tconst int nx = sx + dx[i];\n\t\t\tconst int ny = sy + dy[i];\n\t\t\tif (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;\n\t\t\tPuzzle v = u;\n\t\t\tswap(v.board[v.space], v.board[nx * N + ny]);\n\t\t\tv.space = nx * N + ny;\n\t\t\tif (!mp[v]) {\n\t\t\t\tmp[v] = true;\n\t\t\t\tv.path += dir[i];\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tPuzzle puzzle;\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> puzzle.board[i];\n\t\tif (puzzle.board[i] == 0) {\n\t\t\tpuzzle.board[i] = 9;\n\t\t\tpuzzle.space = i;\n\t\t}\n\t}\n\n\tstring res = bfs(puzzle);\n\tcout << res.size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\nint c[4][2]={1,0,0,1,-1,0,0,-1};\nint puzzle[10];\n\nmap<string,int> book;\nstruct yun\n{\n    int s;\n    int state[9];\n};\n\nint bfs()\n{\n    int i,j,k,l;\n    yun st,en;\n    queue<yun> Q;\n    st.s=0;\n    for(i=0;i<9;i++)\n        st.state[i]=puzzle[i];\n    Q.push(st);\n    while(Q.size())\n    {\n        st=Q.front();\n        Q.pop();\n        for(k=0;k<9;k++)\n            if(!st.state[k])break;\n        int x=k/3,y=k%3;\n        for(j=0;j<4;j++)\n        {\n            int dx=x+c[j][0];\n            int dy=y+c[j][1];\n            int dz=dx*3+dy;\n            if(dx<0||dy<0||dx>=3||dy>=3)continue;\n            string ss=\"\";\n            for(l=0;l<9;l++)\n                en.state[l]=st.state[l];\n            en.state[k]=en.state[dz];\n            en.state[dz]=0;\n            int f=0;\n            for(l=0;l<8;l++)\n            {\n                ss+=en.state[l]+'0';\n                if(en.state[l]!=l+1)\n                    f=1;\n            }\n          //  cout<<ss<<endl;\n            if(!f)return st.s+1;\n            if(book[ss])continue;\n            book[ss]=1;\n            en.s=st.s+1;\n            Q.push(en);\n        }\n    }\n}\n\nint main()\n{\n    int i;\n    for(i=0;i<9;i++)\n        scanf(\"%d\",&puzzle[i]);\n    int g=0;\n    for(i=0;i<8;i++)\n    {\n        if(puzzle[i]!=i+1)\n            g=1;\n    }\n    int max1;\n    if(!g)\n        max1=0;\n    else max1=bfs();\n    printf(\"%d\\n\",max1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 22;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(int moves, int cutoff){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > cutoff)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = dfs(0, 100);\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle);\nstring bfs(Puzzle);\n\nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++) \n    if(p.f[i] != (i+1) ) return false;\n    return true;\n}\n\nint main() {\n\n  Puzzle in;\n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}    \n\nstring bfs(Puzzle s) {\n\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if(isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0;r<4;r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx<0 || ty<0 || tx >=N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if( !V[v] ) {\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\n     \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct pz{\n\tint a[9];\n\tint t;\n};\n\nint main()\n{\n\tpz p;\n\tint n = -1;\n\n\tfor (int i = 0; i < 9; i++)\n\t\tcin >> p.a[i];\n\n\tp.t = 0;\n\n\tqueue<pz> que;\n\tque.push(p);\n\n\twhile (!que.empty()) {\n\t\tpz g = que.front();\n\t\tque.pop();\n\n\t\tbool f = 1;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (g.a[i] != (i + 1)) {\n\t\t\t\tf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (f == 1) {\n\t\t\tn = g.t;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (g.a[i] == 0) {\n\t\t\t\tif(i % 3 != 0){\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i % 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 0) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n\n#define MAX 10000\n#define INFTY 1<<30 // 2^30\n#define N 3\n#define N2 9  // N * N\n#define REP(i,n) for(int i=0;i<n;i++)\n\n/*\npriority_queue<> pq\n push()  pop() size()  top()\nmap<>\n find() begin() end() insert(map<>::value_type())\npair<>\nsort(.begin(), .end())\nsort(arr, arr+N)\nsort(a, a+N, greater<int>())\nbinary_search(vc.begin(), vc.end(), x)  //binary_search???true, false?????????\nvector<int>::iterator lit = lower_bound(vc.begin(), vc.end(), x);\n  lower_bound?????????????????????\"??\\???\"????????????????????????????????????????????Â¬???????????????\nvector<int>::iterator uit = upper_bound(vc.begin(), vc.end(), x);\n  upper_bound????????????????????????\"?Â¶???????\"?????????????????????????????????????????Â¬???????????????\n*/\n\n\nusing namespace std;\n\ntypedef long long llong;\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i = 0; i < N2; i++)\n    {\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n/*\n  1 3 2       1 2 3\n  4 5 6   <   4 5 6\n  7 8 9       7 8 9\n  : true\n  1 2 3       1 3 2\n  4 5 6   <   4 5 6\n  7 8 9       7 8 9\n  : false\n  ??Â¨??Â¨??????\n  : false\n*/\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i = 0; i< N2; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty())\n  {\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++)\n    {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v])\n      {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // FROM HERE\n  Puzzle in;\n  for(int i = 0; i < N2; i++)\n  {\n    cin >> in.f[i];\n    if(in.f[i] == 0)\n    {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl; \n  //cerr << bfs(in) << endl;\n  // END\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\n\nusing namespace std;\n\n#define TEST //*******************************************************************************************************************************************\n//?????????????????Â¨??Â§?????\\????????????????????????????????Â°?????????????Â¨???????????????????dout???????????????????????Â§???????????Â¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????Â§?CPU???????Â£??????????????????Â§???TLE?????????????????????????????????????????Â§????????Â¨???                           ????????????????????????cerr????????Â£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#define din cin\n#else\nstringstream dummy; //???????????Â°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????Â¨?????Â¢?????Â¢???????????????\n//???????????Â¨??????????????????goodbit?????????????????????????????Â¨???????????Â´????????????????????????????????Â¨?????Â°?????????????????Â§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile //??Â¨????????????TLE????????Â§?????????dout?????Â¨??Â¨??????????????Â¢????????????????????????????????????????????Â§????Â¨????????????Â´??????????????Â£??????????????????????Â¨?????????????????????????????????????????????Â§?????????????????????\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nstruct d {int n, m, r, l;}; //for Binary Search Tree\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int INF = 2e9+10;\nconst ll INF_LL = 1e18; //Be careful for overflow.\nconst int NONE = -1;\nconst int SUCCESSFUL = -2;\n\n#define GOAL 123456780\n//int numOfMove = -1; //?????Â°\nll numOfSearch = 0;\n\n#define N_MAX 181440 //num of vertex or element\n#define M_MAX 10000 //num of edge\n\nint N;\n\nstruct d T[N_MAX+1]; //Binary Search Tree\nint H = 0; //num of data in T[]. next new data will be placed on T[H]\n\nqueue<pii> Q; // <puzzle, sign>\n\nvoid printInorder(int i) {\n    if(i==NONE) return;\n    \n    printInorder(T[i].l);\n    dout << \" \" << T[i].n;\n    printInorder(T[i].r);\n}\nvoid printPreorder(int i) {\n    if(i==NONE) return;\n    \n    dout << \" \" << T[i].n;\n    printInorder(T[i].l);\n    printInorder(T[i].r);\n}\nvoid print() {\n    printInorder(0);\n    dout << endl;\n    printPreorder(0);\n    dout << endl;\n}\n\nint find(int x, int i=0) {\n    \n    if(i==NONE) return NONE;\n    if(T[i].n==x) return i;\n    \n    if(x < T[i].n) return find(x, T[i].l);\n    else return find(x, T[i].r);\n    \n}\n\n\nvoid insert(int x, int m, int i=0) { //insert x at T[i]\n\n    if(T[i].n==INF) {\n        T[i].n = x;\n        T[i].m = m; //Binary Search Tree?????Â°????????Â¶????????????????????Â¨?????????????????????????????Â¶????????????????????Â¨???????????Â°????Â¨?????????????????????????????????Â¢?Â´Â¢?????Â´????????Â°???????????Â°??Â§????????????\n        H++;\n        return;\n    }\n    \n    if(x < T[i].n) {\n        if(T[i].l==NONE) T[i].l=H;\n        insert(x, m, T[i].l);\n    }\n    else {\n        if(T[i].r==NONE) T[i].r=H;\n        insert(x, m, T[i].r);\n    }\n    \n}\n\nvoid puzzle_int2array(int puzzle, int p[]) {\n    int digit = 1e8;\n    rep(i,0,9) {\n        p[i] = puzzle/digit;\n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\nint puzzle_array2int(int p[]) {\n    int puzzle = 0;\n    int digit = 1e8;\n    rep(i,0,9) {\n        puzzle += p[i]*digit;\n        digit /= 10;\n    }\n    \n    return puzzle;\n}\n\n\n\n\n\nvoid display(int puzzle) {\n    int digit = 1e8;\n    \n    for(int i=8; i>=0; i--) {\n        dout << puzzle/digit << \" \";\n        if(i%3==0) dout << endl;\n        \n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\n\n\nvoid solve(int puzzle, int numOfMove=1) {\n    \n//    Q.push(make_pair(puzzle, numOfMove));\n    Q.push(make_pair(puzzle, 1)); //??Â£????????Â°?????????????????Â¢?Â´Â¢??????????????Â°?????????????????Â¢?Â´Â¢\n    Q.push(make_pair(GOAL, -1)); //???????????Â¢?Â´Â¢?????????GOAL????????\\????????????\n    \n    while( !Q.empty() ) {\n        \n        puzzle = Q.front().first;\n        numOfMove = Q.front().second; //??????????????Â¢?Â´Â¢?????Â´?????????????????Â°\n        Q.pop();\n        \n        //??Â£?Â§Â£??????\n        int index = find(puzzle);\n        if( index!=NONE ) { //?????Â§???????????????\n            if(numOfMove*T[index].m < 0) { //numOfMove ??Â¨ T[index].m ?????Â°?Â¬??????Â§????????Â°\n                dout << abs(numOfMove) + abs(T[index].m) -2 << endl;\n                return;\n            }\n            else { //????Â¬??????Â§????????Â°\n                continue; //????????????\n            }\n        }\n        \n        insert(puzzle, numOfMove);\n\n        \n//        dout << \"-----------------\\n\";\n//        disp(++numOfSearch);\n//        disp(numOfMove);\n//        display(puzzle);\n        \n\n//??Â£?Â§Â£?????????????Â¨???Â§????????????????????Â£????????Â§?????????????????????\n//        if(puzzle == GOAL) {\n//            dout << numOfMove << endl;\n//            return;\n//        }\n        \n        int p[9];\n        puzzle_int2array(puzzle,p);\n        \n        \n        //find 0\n        int zero=NONE;\n        rep(i,0,9) {\n            if( p[i] == 0 ) {\n                zero = i;\n                break;\n            }\n        }\n        assert(zero!=NONE); //0 must be found\n        \n        \n        //move 0 to 4 direction\n        \n        //?????Â°???????????????????????????1????????????\n        if( numOfMove > 0) numOfMove++;\n        else numOfMove--;\n        \n        int alt;\n        \n        alt = zero - 3;\n        if(0<=alt && alt<=8) {\n//            disp(-3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????Â£?????Â¨??????????????Â°?Â¬??????Â§????????Â°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????Â¬????????????????????????Â£????????????????????????\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero - 1;\n        if(0<=alt && alt<=8 && zero%3!=0) { //0??????????????Â´?????????????????????\n            //            disp(-1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n                //                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????Â£?????Â¨??????????????Â°?Â¬??????Â§????????Â°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????Â¬????????????????????????Â£????????????????????????\n                //                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        \n        alt = zero + 1;\n        if(0<=alt && alt<=8 && zero%3!=2) { //0??????????????Â´?????????????????????\n            //            disp(1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n                //                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????Â£?????Â¨??????????????Â°?Â¬??????Â§????????Â°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????Â¬????????????????????????Â£????????????????????????\n                //                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero + 3;\n        if(0<=alt && alt<=8 ) {\n            //            disp(3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n                //                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????Â£?????Â¨??????????????Â°?Â¬??????Â§????????Â°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????Â¬????????????????????????Â£????????????????????????\n                //                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n    } //end of while-loop\n    \n}\n\n\n\n\nint main() {\n    \n    //initialize\n    rep(i,0,N_MAX+1) {\n        T[i].n = INF;\n        T[i].l = T[i].r = NONE;\n    }\n    \n    int puzzle = 0;\n    int digit = 1e8;\n\n    int p;\n    rep(i,0,9) {\n            din >> p;\n            puzzle += digit * p;\n            digit /= 10;\n    }\n    \n    \n//    display(puzzle);\n    \n    solve(puzzle, 0);\n\n    \n\n    \n    \n    \n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<queue>\nusing namespace std;\nint inf = 1000000000;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nmap<string, int> mp;\n\nstring trans(vector< vector<int> > a){\n  string t = \"\";\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) t += to_string(a[i][j]);\n  return t;\n}\n\nvoid dfs(vector< vector<int> > a, int turn){\n  string t = trans(a);\n  if( mp[t] != 0 && turn > mp[t] ) return;\n  if( t == \"123456780\" ){\n    // cout << t << \" \" << turn << \" \" << mp[t] << endl;\n    mp[t] = turn;\n    return;\n  }\n  if( turn > 15 ) return;\n  mp[t] = turn;\n  // cerr << t << \" \" << mp[t] << endl;\n\n  for(int y=0; y<3; y++){\n    for(int x=0; x<3; x++){\n      if( a[y][x] == 0 ){\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          vector< vector<int> > b = a;\n          swap(b[ny][nx], b[y][x]);\n          string tt = trans(b);\n          dfs(b, turn + 1);\n        }\n      }\n    }\n  }\n  return;\n}\n\nvoid bfs(string sss){\n  queue< pair<int, string> > q;\n  q.push(make_pair(0, sss));\n  map<string, int> mpb;\n  while( !q.empty() ){\n    pair<int, string> p = q.front();\n    q.pop();\n\n    string s = p.second;\n    mpb[s] = p.first;\n    // cerr << p.first << \" \" << p.second << endl;\n    if( s == \"123456780\" ){\n      cout << p.first << endl;\n      return;\n    }\n\n    for(int i=0; i<9; i++){\n      if( s[i] == '0' ){\n        int y = i / 3;\n        int x = i % 3;\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          // cerr << x << \" \" << y << \" -> \" << nx << \" \" << ny << endl;\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          string t = s;\n          swap(t[i], t[ny*3 + nx]);\n          // cerr << t << endl;\n          if( mpb[t] == 0 ) q.push( make_pair(p.first + 1, t) );\n        }\n      }\n    }\n\n  }\n}\n\nint main(){\n\n  vector< vector<int> > a(3, vector<int>(3));\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) cin >> a[i][j];\n  // mp[trans(a)] = 0;\n  // mp[\"123456780\"] = inf;\n  // dfs(a, 1);\n  bfs(trans(a));\n  // cout << mp[\"123456780\"] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\nconst int N = 9;\nconst string GOAL = \"123456780\";\n\nstruct state {\n    string board;\n    int count;\n};\n\nqueue<state> q;\n\ninline void swap(int numpos, int spacepos, string& board) {\n    char tmp = board[numpos];\n    board[numpos] = board[spacepos];\n    board[spacepos] = tmp;\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push(s);\n    return -1;\n}\n\nint main(void) {\n\n    string board;\n    int i = N;\n    while (i != 0) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            --i;\n            board += ch;\n        }\n    }\n\n//    cout << \"[main] board = \" << board << \"\\n\";\n//    printf(\"[main] board = %s\\n\", board.c_str());\n\n    q.push({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop();\n        // ?????????????????????\n\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (s.board[i] == '0') {\n                pos = i; break;\n            }\n        }\n\n        if (pos < 3) {\n            if (pos < 2) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 0) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else if (pos < 6) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 5) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 3) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 8) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 6) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\nstruct board{\n    int val[3][3];\n    int now;\n    void in(){\n        for(int i=0;i<3;i++)for(int j=0;j<3;j++)scanf(\"%d\",&val[i][j]);\n        return ;\n    }\n};\nvoid swap(int &a,int &b){\n    int temp=a;\n    a=b;\n    b=temp;\n    return ;\n}\nint btoi(board a){\n    int ans=0;\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++){\n        ans*=9;\n        ans+=a.val[i][j];\n    }\n    return ans;\n}\nint main(){\n    unordered_set<int> s;\n    queue<board> q;\n    board a;\n    int temp;\n    bool f;\n    a.in();\n    a.now=0;\n    q.push(a);\n    s.insert(btoi(a));\n    while(!q.empty()){\n        a=q.front();\n        q.pop();\n        f=true;\n        for(int i=0;i<3&&f;i++)for(int j=0;j<3&&f;j++)f=a.val[i][j]==(i*3+j+1)%9;\n        if(f){\n            printf(\"%d\\n\",a.now);\n            return 0;\n        }\n        a.now++;\n        for(int i=0;i<3;i++)for(int j=0;j<3;j++)if(a.val[i][j]==0){\n            if(i!=0){\n                swap(a.val[i][j],a.val[i-1][j]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i-1][j]);\n            }\n            if(i!=2){\n                swap(a.val[i][j],a.val[i+1][j]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i+1][j]);\n            }\n            if(j!=0){\n                swap(a.val[i][j],a.val[i][j-1]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i][j-1]);\n            }\n            if(j!=2){\n                swap(a.val[i][j],a.val[i][j+1]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i][j+1]);\n            }\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tvector<vector<int>> a(3, vector<int>(3)), b{ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\tfor (vector<int>& i : a) {\n\t\tfor (int& j : i) cin >> j;\n\t}\n\tqueue<pair<int, vector<vector<int>>>> c;\n\tc.emplace(0, a);\n\tset<vector<vector<int>>> d;\n\td.insert(a);\n\twhile (true) {\n\t\tqueue<pair<int, vector<vector<int>>>> e;\n\t\twhile (!c.empty()) {\n\t\t\tif (b == c.front().second) break;\n\t\t\tpair<int, int> f;\n\t\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\t\tif (!c.front().second[i / 3][i % 3]) {\n\t\t\t\t\tf.first = i / 3;\n\t\t\t\t\tf.second = i % 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (2 != f.first) {\n\t\t\t\tswap(c.front().second[1 + f.first][f.second], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[1 + f.first][f.second], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tif (2 != f.second) {\n\t\t\t\tswap(c.front().second[f.first][1 + f.second], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[f.first][1 + f.second], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tif (f.first) {\n\t\t\t\tswap(c.front().second[f.first - 1][f.second], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[f.first - 1][f.second], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tif (f.second) {\n\t\t\t\tswap(c.front().second[f.first][f.second - 1], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[f.first][f.second - 1], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tc.pop();\n\t\t}\n\t\tif (!c.empty()) break;\n\t\tswap(c, e);\n\t}\n\tcout << c.front().first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++){\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor (int i = 0; i < N2; i++){\n\t\tif (p.f[i] != (i + 1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx + N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++){\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\n#define N 9\n#define SIZE 3\n\nusing namespace std;\n\nclass Puzzle{\nprivate:\n    vector<int> table;\n    vector<int> goal;\n    vector<int> checks;\n    const int STATE_NUM;\n    \n    int Factrial(int n){\n        if(n <= 1)\n            return 1;\n        return n * Factrial(n - 1);\n    }\n    \n    int GetSpace(const vector<int> &v){\n        for(int i = 0; i < N; i++)\n            if(v[i] == 0)\n                return i;\n        return -1;\n    }\n    \n    int state_number(vector<int> v){\n        int n = 0;\n        \n        for(int i = 0; i < N - 1 ; i++){\n            n += v[i] * Factrial(N - i - 1);\n            for(int j = i + 1; j < N; j++){\n                if(v[i] < v[j])\n                    v[j]--;\n            }\n        }\n        \n        return n;\n    }\n    \n    queue<int> next_q(vector<int> &v){\n        queue<int> q;\n        int space = GetSpace(v);\n        \n        if(space % SIZE != 2)\n            q.push(space + 1);\n        if(space % SIZE != 0)\n            q.push(space - 1);\n        if(0 <= space + SIZE && space + SIZE < N)\n            q.push(space + SIZE);\n        if(0 <= space - SIZE && space - SIZE < N)\n            q.push(space - SIZE);\n        \n        return q;\n    }\n    \n    int search(int step, vector<vector<int> > &state){\n        std::queue<int> q;\n        int target;\n        int state_num;\n        int q_num = 0;\n        vector<vector<int> > new_state;\n        \n        if(step == 1 && state[0] == goal)\n            return 0;\n        \n        for(vector<vector<int> >::size_type i = 0; i < state.size(); i++){\n            state_num = state_number(state[i]);\n            \n            if(checks[state_num] == 0){\n                checks[state_num] = 1;\n                q = next_q(state[i]);\n                \n                new_state.resize(q.size() + q_num);\n                while(!q.empty()){\n                    new_state[q_num] = state[i];\n                    target = q.front();\n                    q.pop();\n                    \n                    swap(new_state[q_num][target], new_state[q_num][GetSpace(new_state[q_num])]);\n                    if(new_state[q_num] == goal)\n                        return step;\n                    \n                    q_num++;\n                }\n            }\n        }\n        \n        return search(step + 1, new_state);\n    }\n    \npublic:\n    Puzzle() : STATE_NUM(Factrial(N)), table(N){\n        checks.resize(STATE_NUM);\n        \n        for(int i = 0; i < N; i++){\n            cin >> table[i];\n            goal.push_back(i == N - 1 ? 0 : i + 1);\n        }\n    }\n    \n    int GetMinStep(){\n        vector<vector<int> > state(1);\n        state[0] = table;\n        return search(1, state);\n    }\n};\n\nint main(){\n    Puzzle pz;\n    cout << pz.GetMinStep() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n//\tbool operator <(const Puzzle p) const {\n//\t\tfor (int i = 0; i < N2; ++i) {\n//\t\t\tif (f[i] == p.f[i])\n//\t\t\t\tcontinue;\n//\t\t\treturn f[i] > p.f[i];\n//\t\t}\n//\t\treturn false;\n//\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n//\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n//\t\t\tif (!M[v]) {\n//\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n//\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < (const Puzzle &p) const\n    {\n        for(int i=0; i<N2; i++)\n        {\n            if(f[i]==p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for(int i=0; i<N2; i++)\n    {\n        if(p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty())\n    {\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r=0; r<4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N + ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n\n    for(int i=0; i<N2; i++)\n    {\n        cin >> in.f[i];\n        if(in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <array>\n#include <list>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <valarray>\n#include <utility>\n#include <tuple>\n#include <cmath>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <locale>\n#include <regex>\n#include <complex>\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n//vector\ntemplate <class T>\nusing vec = std::vector<T>;\n\ntemplate <class T>\nusing vvec = vec<vec<T>>;\n\nconstexpr std::size_t operator\"\"_sz(ull n) { return std::size_t(n); }\n\nconstexpr int N = 8;\n\nstd::pair<int, vvec<bool>> solve(vvec<bool> map, int y, int x, int queenCount, vec<bool> h, vec<bool> w, vec<bool> tr, vec<bool> br)\n{\n    ++queenCount;\n\n    map[y][x] = true;\n    h[y] = true;\n    w[x] = true;\n    tr[y + x] = true;\n    br[7 - y + x] = true;\n\n    if (queenCount == N)\n    {\n        return make_pair(queenCount, map);\n    }\n\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n        {\n            if (!h[i] && !w[j] && !tr[i + j] && !br[7 - i + j])\n            {\n\n                auto m = solve(map, i, j, queenCount, h, w, tr, br);\n\n                if (m.first == N)\n                {\n                    queenCount = N;\n                    map = m.second;\n                    goto LOOP_END;\n                }\n            }\n        }\n\n    LOOP_END:\n\n    return make_pair(queenCount, map);\n}\n\nint main()\n{\n    using namespace std;\n    // cerr.rdbuf(nullptr);\n\n    string s;\n    for (int i = 0; i < 3; ++i)\n    {\n        string line;\n        getline(cin, line);\n        s += line;\n    }\n\n    string r;\n    remove_copy(s.cbegin(), s.cend(), back_inserter(r), ' ');\n\n    set<ll> used;\n\n    queue<pair<int, string>> q;\n    q.push(make_pair(0, r));\n\n    const string target = \"123456780\";\n\n    while (!q.empty())\n    {\n        auto current = q.front();\n        q.pop();\n        //cout << current.second << endl;\n\n        if (used.count(stoll(current.second)) == 1)\n            continue;\n        used.emplace(stoll(current.second));\n\n        if (current.second == target)\n        {\n            cout << current.first << endl;\n            break;\n        }\n\n        for (int i = 0; i < 9; ++i)\n            if (current.second[i] == '0')\n            {\n                auto r = i / 3;\n                auto c = i % 3;\n                for (int y = -1; y <= 1; ++y)\n                    for (int x = -1; x <= 1; ++x)\n                    {\n                        if (abs(x) + abs(y) != 1)\n                            continue;\n                        if (r + y < 0 || r + y > 2 || c + x < 0 || c + x > 2)\n                            continue;\n                        auto next = current.second;\n                        swap(next[i], next[(r + y) * 3 + c + x]);\n                        q.push(make_pair(current.first + 1, next));\n                    }\n            }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 100\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define n 3\n#define n1 9\n\n\nstruct puzz{\n  int m[n1];\n  int space;\n  string path;\n  int operator < (const puzz &p)const{\n    for(int i=0;i<n1;i++){\n      if(m[i]==p.m[i])continue;\n      return m[i] > p.m[i];\n    }\n    return false;\n  }\n};\n\n\nstatic const int x[4]={-1,0,1,0};\nstatic const int y[4]={0,-1,0,1};\nstatic const char c[4]={'u','l','d','r'};\n\nint target(puzz p){\n  for(int i=0;i<n1;i++){\n    if(p.m[i]!=(i+1))return false;\n  }\n  return true;\n}\n\nstring am(puzz p){\n  queue<puzz> Q;\n  map<puzz, int> V;\n  puzz a,b;\n  int tmp;\n  p.path=\"\";\n  Q.push(p);\n  V[p]=true;\n\n  while(!Q.empty()){\n    a=Q.front();\n    Q.pop();\n    if(target(a))return a.path;\n    int xx=a.space/n;\n    int yy=a.space%n;\n    for(int k=0;k<4;k++){\n      int xc=xx+x[k];\n      int yc=yy+y[k];\n      if(xc<0||yc<0||xc>=n||yc>=n)continue;\n      b=a;\n      tmp=b.m[a.space];\n      b.m[a.space]=b.m[xc*n+yc];\n      b.m[xc*n+yc]=tmp;\n      b.space=xc*n+yc;\n      if(!V[b]){\n\tV[b]=true;\n\tb.path+=c[k];\n\tQ.push(b);\n\t\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  puzz input;\n  for(int i=0;i<n1;i++){\n    cin>>input.m[i];\n    if(input.m[i]==0){\n      input.m[i]=n1;\n      input.space=i;\n    }\n  }\n  string ans =am(input);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define MAX_V 200000\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tmap<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space:\n  string path;\n\n  bool operator < (const puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1);\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[o] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int M = 362880; // =9!\nconst int G = 46233; //??Â´????????????????????Â£?????Â°\nvector<int> check(M,0);\nvector<int> preve(M,-1);\nvector<int> d(M,INF);\n\ntypedef vector<int> Board;\n\nint factorial(int n){\n\tif(n==0){\n\t\treturn 0;\n\t}\n\tif(n==1){\n\t\treturn 1;\n\t}\n\treturn n*factorial(n-1);\n}\n\nint translate(Board &b){\n\tBoard bb(9);\n\tbb=b;\n\tint S = 0 ;\n\tfor(int i=0;i<9;i++){\n\t\tS+=factorial(8-i)*bb[i];\n\t\tfor(int j=i+1;j<9;j++){\n\t\t\tif(bb[j]>bb[i]){\n\t\t\t\tbb[j]--;\n\t\t\t}\n\t\t}\n\t}\n\treturn S;\n}\n\nvoid Adj(Board u, vector< Board> &adj){\n\tint zero;\n\tfor(int i=0;i<9;i++){\n\t\tif(u[i]==0){zero=i;}\n\t}\n\n\tif(zero<6){\n\t\tBoard v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero+3]);\n\t\tadj.push_back(v);\n\t}\n\tif(zero>2){\n\t\tBoard v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero-3]);\n\t\tadj.push_back(v);\n\t}\n\tif(zero%3 == 0 || zero%3 == 1){\n\t\tBoard  v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero+1]);\n\t\tadj.push_back(v);\n\t}\n\tif(zero%3 == 1 || zero%3 == 2){\n\t\tBoard v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero-1]);\n\t\tadj.push_back(v);\n\t}\n}\n\nint solve(Board &init){\n\tBoard u(9),v(9);\n\tint u_code, v_code;\n\tint init_code = translate(init);\n\n\tqueue<Board> q;\n\tq.push(init);\n\tcheck[init_code]=1;\n\td[init_code]=0;\n\tpreve[init_code]=-1;\n\n\tif(init_code==G){\n\treturn d[init_code];\n\t}\n\n\twhile(!q.empty()){\n\t\tu = q.front();\n\t\tq.pop();\n\t\tu_code = translate(u);\n\t\tvector<Board> adj(0);\n\t\tAdj(u, adj);\n\t\tfor(int i=0;i<adj.size();i++){\n\t\t\tv = adj[i];\n\t\t\tv_code = translate(v);\n\t\t\tif(check[v_code]==0){\n\t\t\t\tcheck[v_code]=1;\n\t\t\t\td[v_code]=d[u_code]+1;\n\t\t\t\tpreve[v_code]=u_code;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t\tif(v_code==G){\n\t\t\t\treturn d[v_code];\n\t\t\t}\n\t\t}\n\t\tcheck[u_code] = 2;\n\t}\n}\n\nint main(){\n\tBoard init(9);\n\tfor(int i=0;i<9;i++){\n\t\tcin >> init[i]; \n\t} \n\n\t//cout << translate(init) << endl;\n\t/*\n\tvector<Board> b(0);\n\tAdj(init,b);\n\tfor(int i=0;i<b.size();i++){\n\t\tfor (int j=0;j<9;j++){\n\t\t\tcout << b[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl ;\n\t*/ \n\tcout << solve(init) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define _all(arg) begin(arg),end(arg)\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0; }\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0; }\n\nusing namespace std;\nusing vi=vector<int>;\nusing vii=vector<vi>;\n\nmap<vii, int> memo;\n\nbool check(vii m) {\n\trep(i, 8) {\n\t\tif(m[i/3][i%3] != i+1) return false;\n\t}\n\tif(m[2][2] != 0) return false;\n\treturn true;\n}\n\nint bfs(vii m) {\n\tqueue<vii> Q;\n\tQ.push(m);\n\tmemo[m] = 0;\n\twhile(Q.size()) {\n\t\tvii cur = Q.front();\n\t\tQ.pop();\n\n\t\tif(check(cur)) return memo[cur];\n\n\t\tconst int dr[4] = {1, 0, -1, 0};\n\t\tconst int dc[4] = {0, 1, 0, -1};\n\n\t\tint zero_r, zero_c;\n\n\t\trep(i, 3) rep(j, 3) if(cur[i][j] == 0) zero_r = i, zero_c = j;\n\t\trep(i, 4) {\n\t\t\tvii next = cur;\n\t\t\tint nr = zero_r + dr[i];\n\t\t\tint nc = zero_c + dc[i];\n\t\t\tif(nr<0 || 3<=nr || nc<0 || 3<=nc) continue;\n\t\t\tswap(next[zero_r][zero_c], next[nr][nc]);\n\t\t\tif(memo.find(next) != memo.end()) continue;\n\t\t\tmemo[next] = memo[cur]+1;\n\t\t\tQ.push(next);\n\t\t}\n\t}\n} \n\nint main(void){\n\tvii m(3, vi(3, 0));\n\trep(i, 9) cin >> m[i/3][i%3];\n\n\tcout << bfs(m) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 30\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????Â¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nset<long long> s;\nint map1[10][10];\nint k[10];\nint t;\nqueue<long long> x,y;\nvoid input(){\n\tint g=0;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map1[i][j];\n\t\t\tg=g*10+map1[i][j];\n\t\t}\n\t}\n\ts.insert(g);\n\tx.push(g);\n\ty.push(0);\n}\nvoid syf(){\n\twhile(!x.empty()){\n\t\tif(x.front()==123456780){\n\t\t\tcout<<y.front()<<endl;\n\t\t\treturn;\n\t\t}\n\t\tint g=x.front(),tot=0,kl=-1;\n\t\twhile(g!=0){\n\t\t\tif(g%10==0) kl=tot;\n\t\t\tk[tot++]=g%10;\n\t\t    g/=10;\n\t\t}\n\t\tif(kl==-1) {\n\t\t\tkl=tot;\n\t\t\ttot++;\n\t\t}\n\t\tif(kl%3>0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t}\n\t\tif(kl%3<2){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\t\t\t\n\t\t}\n\t\tif(kl+3<=8){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\t\t\n\t\t}\n\t\tif(kl-3>=0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\t\t\t\n\t\t}\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}\nint main(){\n\tinput();\n\tsyf();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth, int dir) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        if (dir != -1 && k == (dir + 2) % 4) {\n            continue;\n        }\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1, k);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    for (int i = 1; i <= 45; i++) {\n        int ret = dfs(b, i, -1);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it == history.end()) {\n        history.insert(make_pair(s.board, ' '));\n        ++s.count;\n        q.push_back(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nbool frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = true;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n \nstruct Puzzle {\n  int f[N*N];\n  int space;\n  string path;\n \n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i < N*N; i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n \nbool isTarget(Puzzle p){\n  for(int i=0;i<N*N;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n \n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n    V[v]=true;\n    v.path+=dir[r];\n    Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n \nint main()\n{\n  Puzzle in;\n \n  for(int i=0;i<N*N;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N*N;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 3\n#define MAX2 9\n\nusing namespace std;\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    int i;\n    for(i = 0; i < MAX2; i++){\n      if( f[i] == p.f[i] ){\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstring bfs(Puzzle);\nbool isTarget(Puzzle);\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for(i = 0; i < MAX2; i++){\n    if( p.f[i] != (i+1) ){\n      return false;\n    }\n  }\n  return true;\n}//end of isTarget func\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i = 0; i < MAX2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}//end of main func\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  int r,tx,ty;\n  int sx,sy;\n  int tmp;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ){\n      return u.path;\n    }\n    sx = u.space / MAX;\n    sy = u.space % MAX;\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX){\n        continue;\n      }\n      v = u;\n      /*swap*/\n      tmp = v.f[u.space];\n      v.f[u.space] = v.f[tx * MAX + ty];\n      v.f[tx * MAX + ty] = tmp;\n\n      v.space = tx * MAX + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cmath>\nusing namespace std;\n#define N 3 \n#define PN 9\n#define LIMIT 50\n\nint MDT[PN][PN];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\nint limit;\n\nstruct Puzzle{ int f[PN], space, MD;};\nPuzzle state;\n\nint sumMD(Puzzle p){\n    int sum = 0;\n    for(int i = 0; i < PN; i++){\n        if(p.f[i] == PN) continue;\n        sum += MDT[i][p.f[i]-1];\n    }\n    return sum;\n}\n\nbool dfs(int depth, int prev){\n    if(state.MD == 0) return true;\n    if(depth+state.MD > limit) return false;\n\n    int sx = state.space/N;\n    int sy = state.space%N;\n    Puzzle tmp = state;\n\n    for(int r = 0; r < 4; r++){\n        int tx = sx + dx[r];\n        int ty = sy + dy[r];\n        if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n        if((r+2)%4 == prev) continue;\n        tmp = state;\n        state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n        state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n        swap(state.f[tx*N+ty],state.f[sx*N+sy]);\n        state.space = tx*N+ty;\n        if(dfs(depth+1,r)) return true;\n        //if(dfs(depth+1,r)){path[depth] = r; return true;}\n        state = tmp;\n    }\n\n    return false;\n}\n\nint main(){\n    Puzzle p;\n\n    for(int i = 0; i < PN; i++){\n        cin >> p.f[i];\n        if(p.f[i] == 0){\n            p.f[i] = PN;\n            p.space = i;\n        }\n    }\n\n    for(int i = 0; i < PN; i++){\n        for(int j = 0; j < PN; j++){\n            MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n        }\n    }\n\n    p.MD = sumMD(p);\n\n    for(limit = 0; limit < LIMIT; limit++){\n        state = p;\n        if(dfs(0,-1)){\n            cout << limit << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct puzzle{\n  int x[N2];\n  int space;\n  string path;\n  bool operator < (const puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(x[i]==p.x[i]) continue;\n      return x[i]>p.x[i];\n    }\n    return false;\n  }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nchar dir[4] = {'u','l','d','r'};\n\nbool target(puzzle);\nstring bfs(puzzle);\n\nint main(){\n  int i;\n  string answer;\n  puzzle in;\n\n  for(i=0;i<N2;i++){\n    cin >> in.x[i];\n    if(in.x[i] == 0){\n      in.x[i] = N2;\n      in.space = i;\n    }\n  }\n  answer = bfs(in);\n  cout << answer.size() << endl;\n\n  return 0;\n}\n\nbool target(puzzle p){\n  int i;\n  for(i=0;i<N2;i++)\n    if(p.x[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(puzzle p){\n  int px,py,tx,ty,r;\n  queue<puzzle> Que;\n  map<puzzle,bool> V;\n  puzzle m,k;\n  p.path=\"\";\n  Que.push(p);\n  V[p]=true;\n\n  while(!Que.empty()){\n    m=Que.front(); Que.pop();\n    if(target(m)==true) return m.path;\n    px=m.space/N;\n    py=m.space%N;\n    for(r=0;r<4;r++){\n      tx=px+dx[r];\n      ty=py+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      k=m;\n      swap(k.x[m.space],k.x[tx*N+ty]);\n      k.space=tx*N+ty;\n      if(!V[k]){\n\tV[k]=true;\n\tk.path += dir[r];\n\tQue.push(k);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle& p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= || ty >= N) {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << and.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#define N 3\n#define N2 9\nusing namespace std;\n\nstruct game{\n  int b[N2];\n  bool operator < (const game &other) const{\n    for(int i=0;i<N2;i++){\n      if(b[i]<other.b[i]){\n        return true;\n      }else if(b[i]>other.b[i]){\n        return false;\n      }\n    }\n    return false;\n  }\n};\ngame g;\nmap<game,int> checked;\nqueue<game> q;\n\nvoid print(game _g){\n  for(int i=0;i<N2;i++)\n    printf(\"%d \",_g.b[i]);\n  printf(\"\\n\");\n}\n\nbool clear(game _g){\n  for(int i=0;i<N2;i++){\n    if(_g.b[i]!=i+1) return false;\n  }\n  return true;\n}\n\nint solve(){\n  q.push(g);\n  checked.insert(make_pair(g,0));\n  int depth;\n  while(!q.empty()){\n    g=q.front();q.pop();\n    depth=checked[g];\n    if(clear(g)){ return depth; }\n    int w;\n    for(int i=0;i<N2;i++){\n      if(g.b[i]==N2) {\n        w=i;\n        break;\n      }\n    }\n    vector<int> v;\n    if(w%N<N-1) v.push_back(1);\n    if(w%N>0  ) v.push_back(-1);\n    if(w/N<N-1) v.push_back(N);\n    if(w/N>0  ) v.push_back(-N);\n    for(int i:v){\n      game gt=g;\n      swap(gt.b[w],gt.b[w+i]);\n      if(checked.find(gt)==checked.end()){\n        q.push(gt);\n        checked.insert(make_pair(gt,depth+1));\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  for(int i=0;i<N2;i++) {\n    int tmp; cin>>tmp;\n    if(tmp==0) tmp=N2;\n    g.b[i]=tmp;\n  }\n\n  cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\nconst int N = 3;\nconst int INF = 50;\nvector<vector<int> > cell(N, vector<int>(N));\nvector<vector<int> > ans = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\nint q = 0;\nunordered_set<int> ms;\nint zero_x = 0;\nint zero_y = 0;\nint ministep = INF;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\nint key(vector<vector<int> > cell)\n{\n\tint res = 0;\n\tint p = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tres += cell[i][j] * p;\n\t\t\tp *= 10;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(int i)\n{\n\tint p = key(cell);\n\tif (ms.find(p) != ms.end() || ministep < i) {\n\t\treturn;\n\t}\n\tif (p == q) {\n\t\tministep = min(ministep, i);\n\t\treturn;\n\t}\n\t\n\tms.insert(p);\n\tif (zero_x > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t}\n\tif (zero_x < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t}\n\tif (zero_y > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t}\n\tif (zero_y < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t}\n\tms.erase(p);\n}\n\nint main()\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcin >> cell[i][j];\n            if (cell[i][j] == 0) {\n                zero_x = i;\n                zero_y = j;\n            }\n\t\t}\n\t}\n\n\tq = key(ans);\n\tsolve(0);\n\tcout << ministep << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tconst int ansval = 123456780;\n\tconst int ansarray[N*N] = {1,2,3,4,5,6,7,8,0};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid valuetoarray(uint t,int *table){\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tuint getscore(uint t){\n\t\tint table[N*N];\n\t\tuint score = 0;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tfor(int j=0;j<N*N;++j){\n\t\t\t\tif(ansarray[i]==table[j]){\n\t\t\t\t\tscore += (i/N-j/N)*(i/N-j/N)+(i%N-j%N)*(i%N-j%N);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t\tscore = getscore(table);\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool operator<(const State& s) const{\n\t\t\treturn score < s.score;\n\t\t}\n\t\tbool operator>(const State& s) const{\n\t\t\treturn score > s.score;\n\t\t}\n\t\tbool isfinished() const{\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t\tuint score;\n\t};\n\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tif(table[i]==0){\n\t\t\t\tzi = i/N;\n\t\t\t\tzj = i%N;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::map<uint, bool> visited;\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n//\tstd::priority_queue<State,std::vector<State>,std::greater<State> > Q;\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(visited.find(states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<cassert>\n\n#define N 3\n#define N2 8\n#define LIMIT 100\n\nusing namespace std;\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\nint MDT[N2][N2];\n\nstruct Puzzle {\n  int f[N2], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint getAllMD(Puzzle pz){\n  int sum = 0;\n  for(int i=0; i<N2; i++){\n    if(pz.f[i] == N2) continue;\n    sum += MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0; i<N2; i++)\n    if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n\n  if(depth+state.MD > limit) return false;\n\n  int sx = state.space / N;\n  int sy = state.space % N;\n  Puzzle tmp;\n\n  for(int r=0; r<4; r++){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    \n    if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n       if(max(prev, r)-min(prev, r) == 2) continue;\n       tmp = state;\n\n       state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n       state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n       swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n       state.space = tx*N+ty;\n       if(dfs(depth+1,r) ) {path[depth] = r; return true; }\n       state = tmp;\n  }       \n       \n    return false;\n  \n}    \n\n\nstring iterative_deepening(Puzzle in){\n  in.MD = getAllMD(in);\n\n  for(limit = in.MD; limit <= LIMIT; limit++){\n    state = in;\n    if(dfs(0, -100) ){\n      string ans = \"\";\n      for(int i = 0; i<limit; i++) ans += dir[path[i]];\n      return ans;\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0; i<N2; i++)\n    for(int j=0; j<N2; j++)\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deepening(in);\n  cout << ans.size() << endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nvoid RenewTargets(\n\tconst TPuzzle& Puzzle,\n\tconst TMovePattern& Pattern,\n\tstd::vector<TPuzzle>& Targets,\n\tstd::set<TPuzzle>& History)\n{\n\tif(!Movable(Puzzle, Pattern)) return;\n\tTPuzzle Moved = Move(Puzzle, Pattern);\n\tif(History.find(Moved) != History.end()) return;\n\tTargets.push_back(Moved);\n\tHistory.insert(Moved);\n}\n//?Â¬??????????????????????????????Â¶???????????????\n\n//????Â¬??????????????????????????Â¨?????????Â£???????????Â°?????????\n//?Â¬?????????????????????????????????Â§?????????????????????????????????\n//???????????Â§????Â±\\??Â´????????Â£????????????\n//?Â¬???????????????????????????????????????????????????????\n//?Â±\\??Â´????????????\n//????????????\nint CountMove(const std::vector<TPuzzle>& NextTargets,\n\t          const TPuzzle& Goal,\n\t          int Count,\n\t          std::set<TPuzzle>& History)\n{\n\tif(std::find(NextTargets.begin(), NextTargets.end(), Goal) != NextTargets.end()) return Count;\n\tstd::vector<TPuzzle> NewTargets;\n\tfor(std::vector<TPuzzle>::const_iterator It = NextTargets.begin(); It != NextTargets.end(); ++It){\n\t\tRenewTargets(*It, mpUp,    NewTargets, History);\n\t\tRenewTargets(*It, mpDown,  NewTargets, History);\n\t\tRenewTargets(*It, mpLeft,  NewTargets, History);\n\t\tRenewTargets(*It, mpRight, NewTargets, History);\n\t}\n\treturn CountMove(NewTargets, Goal, 1 + Count, History);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> History;\n\treturn CountMove(std::vector<TPuzzle>(1, Puzzle), Goal, 0, History);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????Â¨?????????24????????Â±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[20000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>25) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\nconst int N = 9;\nint board[N];\n\n// OK\nint main(void) {\n\n    int count = 0;\n    for (int y = 0, pos; y < 3; ++y) {\n        for (int x = 0; x < 3; ++x) {\n            pos = y * 3 + x;\n            scanf(\"%d\", &board[pos]);\n            if (board[pos] == 0) { continue; }\n            int x1 = (board[pos] - 1) % 3, y1 = (board[pos] - 1) / 3;\n            count += abs(x1 - x) + abs(y1 - y);\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\n\nbool in(int a,int b){\n  if(a<0 || b<0 || 3<=a || 3<=b)return false;\n  return true;\n}\n\nint main()\n{\n  int a;\n  string start=\"\",goal=\"123456780\";\n\n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n  \n  queue<string> q;\n  map<string,int> mp;\n  mp[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    int s=-1,cost=mp[u];\n    if(u==goal){\n      cout<<mp[u]<<endl;\n      break;\n    }\n\n    for(int i=0;i<u.length();i++){\n      if(u[i]=='0')s=i;\n    }\n\n    int y=s/3,x=s%3;\n\n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int index=ny*3+nx;\n      string t=u;\n      swap(t[s],t[index]);\n      if(mp.find(t)==mp.end()){\n\tmp[t]=cost+1;\n\tq.push(t);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tTPuzzle Result = Puzzle;\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Result[Row][Col], Result[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Result[Row][Col], Result[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Result[Row][Col], Result[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Result[Row][Col], Result[Row][Col + 1]);break;\n\tdefault : break;\n\t}\n\treturn Result;\n}\n\nint CountMove(const std::vector<TPuzzle>& Before, const TPuzzle& Goal, int Count)\n{\n\tif(std::find(Before.begin(), Before.end(), Goal) != Before.end()) return Count;\n\tstd::vector<TPuzzle> Next;\n\tfor(std::vector<TPuzzle>::const_iterator It = Before.begin(); It != Before.end(); ++It){\n\t\tconst TPuzzle& Puzzle = *It;\n\t\tif(Movable(Puzzle, mpUp))    Next.push_back(Move(Puzzle, mpUp));\n\t\tif(Movable(Puzzle, mpDown))  Next.push_back(Move(Puzzle, mpDown));\n\t\tif(Movable(Puzzle, mpLeft))  Next.push_back(Move(Puzzle, mpLeft));\n\t\tif(Movable(Puzzle, mpRight)) Next.push_back(Move(Puzzle, mpRight));\n\t}\n\treturn CountMove(Next, Goal, 1 + Count);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::vector<TPuzzle> Start(1, Puzzle);\n\treturn CountMove(Start, Goal, 0);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tr1/unordered_set>\n#include<cstring>\nusing namespace std;\nbool done[40000000];\nint m[10]={1};\nint f;\nint ans=0;\nint zon[10]={1,2,3,4,5,6,7,8,0};\nint fx[4]={1,-1,3,-3};\nint wz[10]={8,0,1,2,3,4,5,6,7};\ntr1::unordered_set<int> s;\nvoid dfs(int use,int sm,int tot){\n    if(use>tot || s.count(sm) || f) return;\n    if(ans==sm){\n        f=1;\n        return;\n    }\n    s.insert(sm);\n    int dt[9],p,ssm;\n    for(int i=8;i>=0;i--){\n        dt[i]=sm/m[i];\n        sm-=m[i]*dt[i];\n        if(dt[i]==0) p=i;\n    }\n    int u=0;\n    for(int i=1;i<9;i++){\n        u+=abs(i%3-wz[dt[i]]%3)+abs(i/3-wz[dt[i]]/3);\n    }\n    if(u+use*2>tot*2) return;\n    for(int i=0;i<4;i++){\n        if(p+fx[i]<0||p+fx[i]>15) continue;\n        dt[p]=dt[p+fx[i]];\n        dt[p+fx[i]]=0;\n        ssm=0;\n        for(int i=0;i<9;i++) ssm+=dt[i]*m[i];\n        dfs(use+1,ssm,tot);\n        dt[p+fx[i]]=dt[p];\n        dt[p]=0;\n    }\n}\nint main(){\n    int dt[9];\n    for(int i=1;i<9;i++){\n        m[i]=m[i-1]*9;\n    }\n    int sm=0;\n    for(int i=0;i<9;i++){\n        cin>>dt[i];\n        sm+=dt[i]*m[i];\n    }\n    for(int i=0;i<9;i++){\n        ans+=zon[i]*m[i];\n    }\n    for(int i=0;i<1000;i++){\n        s.clear();\n        dfs(0,sm,i);\n        if(f){\n            cout<<i<<\"\\n\";\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\n  for(int i=0; i<N2; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n\n    u = Q.front();\n    Q.pop();\n\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n\n}\n\nint main(){\n\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <math.h>\n\n#define ll long ilong\n#define Int int\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (*(x.end()-1))\n\nusing namespace std;\n\n#define N 3\n#define NN (N*N)\n\nvector<Int> dx = {0, 0, -1, 1};\nvector<Int> dy = {-1, 1, 0, 0};\nvector<char> dirs = {'u', 'd', 'l', 'r'};\n\n\nstruct Puzzle {\n  vector<Int> vec;\n  Int blank;\n  string path;\n  \n  Puzzle(): vec(NN, -1), blank(-1), path(\"\") {\n  }\n  \n  Puzzle(vector<Int> &vec, Int blank, string path) {\n    this->vec = vec;\n    this->blank = blank;\n    this->path = path;\n  }\n  \n  bool operator == (const Puzzle &other) const { \n    loop(n,0,NN) {\n      if (vec[n] != other.vec[n]) return false;\n    }\n    \n    return true;\n  }\n  \n  Puzzle move(Int dir) {\n    // i = h * N + w\n    Int sx = blank % N;\n    Int sy = blank / N;\n    Int tx, ty;\n    \n    switch (dir) {\n      case 0: \n      case 1:\n      case 2:\n      case 3:\n        tx = sx + dx[dir];\n        ty = sy + dy[dir];\n        break;\n      default:\n        cout << \"Invalid dir: \" << dir << endl;\n        exit(1);\n        break;\n    }\n    \n    Puzzle p;\n    if (tx < 0 || N <= tx || ty < 0 || N <= ty) {\n      return p;\n    }\n    \n    p = *this;\n    swap(p.vec[sy * N + sx], p.vec[ty * N + tx]);\n    p.blank = ty * N + tx;\n    p.path += dirs[dir];\n    return p;\n  }\n  \n  void dump() {\n    loop(n,0,NN) cout << vec[n] << ' '; cout << endl;\n  }\n  \n  void dump2() {\n    loop(h,0,N) {\n      loop(w,0,N) {\n        cout << vec[h * N + w] << ' ';\n      }\n      cout << endl;\n    }\n  }\n};\n\nnamespace std {\n\n  template <>\n  struct hash<Puzzle>\n  {\n    std::size_t operator()(const Puzzle& p) const\n    {\n      std::size_t seed = p.vec.size();\n      for(auto& i : p.vec) {\n        seed ^= i + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n      }\n      return seed;\n    }\n  };\n}\n\n\nvector<Int> targetVec = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nPuzzle target(targetVec, 8, \"\");\nPuzzle source;\n\n\nInt bfs() {\n  queue<Puzzle> Q;\n  unordered_map<Puzzle, bool> DONE;\n  \n  Q.push(source);\n  DONE[source] = true;\n  \n  while (!Q.empty()) {\n    Puzzle top = Q.front(); Q.pop();\n    if (top == target) return top.path.length();\n    \n    loop(dir,0,dirs.size()) {\n      Puzzle p = top.move(dir);\n      if (p.blank== -1) continue; // Invalid board\n      if (DONE[p]) continue;\n      Q.push(p);\n      DONE[p] = true;\n    }\n  }\n  \n  cout << \"No solution\" << endl;\n  return -1;\n}\n\nvoid input() {\n  vector<Int> vec(NN, -1);\n  Int blank = -1;\n  loop(h,0,N) {\n    loop(w,0,N) {\n      cin >> vec[h*N + w];\n      if (vec[h*N + w] == 0) blank = h * N + w;\n    }\n  }\n  source.vec = vec;\n  source.blank = blank;\n}\n\nvoid solve() {\n  cout << bfs() << endl;\n}\n\n\nint main() {\n  input();\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\nset<Board> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    if (history.insert(s.board).second) {\n        ++s.count;\n        q.push(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nconst int N = 3;\n\nclass Puzzle {\npublic:\n\n\tint p[N][N];\n\tpair<int, int> space;\n\tint count;\n\n\tbool operator < (const Puzzle &a) const {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (p[i][j] == a.p[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\treturn p[i][j] < a.p[i][j];\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n};\n\n\nvoid printPuzzle(const Puzzle &a) {\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout << a.p[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tint x;\n\tcin >> x;\n}\n\n\nbool isSolve(const Puzzle &p) {\n\n\tint count = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (p.p[i][j] != count)\n\t\t\t\treturn false;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint bfs(Puzzle &p) {\n\n\tint dx[4] = { 1, 0, -1, 0 };\n\tint dy[4] = { 0, 1, 0, -1 };\n\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> M;\n\tQ.push(p);\n\tint count = 0;\n\tM[p] = true;\n\n\twhile (!Q.empty()) {\n\t\tPuzzle nowPuzzle = Q.front();\n\t\tQ.pop();\n\n\t\tif (isSolve(nowPuzzle))\n\t\t\treturn nowPuzzle.count;\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nextX = nowPuzzle.space.first + dx[i];\n\t\t\tint nextY = nowPuzzle.space.second + dy[i];\n\n\t\t\tif (nextX < 0 || N <= nextX || nextY < 0 || N <= nextY)\n\t\t\t\tcontinue;\n\n\t\t\tPuzzle nextPuzzle = nowPuzzle;\n\t\t\tnextPuzzle.space = make_pair(nextX, nextY);\n\t\t\tswap(nextPuzzle.p[nextX][nextY], nextPuzzle.p[nowPuzzle.space.first][nowPuzzle.space.second]);\n\t\t\tif (!M[nextPuzzle]) {\n\t\t\t\tM[nextPuzzle] = true;\n\t\t\t\tnextPuzzle.count++;\n\t\t\t\tQ.push(nextPuzzle);\n\t\t\t\t// cout << nextPuzzle.count << endl;\n\t\t\t\t// printPuzzle(nextPuzzle);\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\n\tPuzzle puzzle;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> puzzle.p[i][j];\n\n\t\t\tif (puzzle.p[i][j] == 0) {\n\t\t\t\tpuzzle.p[i][j] = 9;\n\t\t\t\tpuzzle.space = make_pair(i, j);\n\t\t\t\tpuzzle.count = 0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tcout << bfs(puzzle) << endl;\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define inf 0x3f3f3f3f\nint map[8][8];\nint vis[8][8];\nint minn;\nint dir[4][2]={0,1,1,0,0,-1,-1,0};\nint s[8][8]={{1,2,3},{4,5,6},{7,8,0}};\nint judge(int a[8][8])\n{\n      for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n      if(a[i][j]!=s[i][j])return 0;\n    return 1;\n}\nvoid dfs(int x,int y,int step)\n{\n    if(judge(map))\n    {\n        if(step<minn)minn=step;\n    }\n    for(int i=0;i<4;i++)\n    {\n        int tx=x+dir[i][0];\n        int ty=y+dir[i][1];\n        if(tx<0||ty<0||tx>=3||ty>=3)continue;\n        if(vis[tx][ty]==0)\n        {\n            vis[tx][ty]=1;\n            map[x][y]=map[tx][ty];\n            map[tx][ty]=0;\n            dfs(tx,ty,step+1);\n            vis[tx][ty]=0;\n            map[tx][ty]=map[x][y];\n            map[x][y]=0;\n        }\n    }\n    return ;\n}\nint main()\n{\n    minn=inf;\n    memset(vis,0,sizeof(vis));\n    int a,b;\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n        {\n            scanf(\"%d\",&map[i][j]);\n            if(map[i][j]==0)\n            {\n                a=i;b=j;\n            }\n        }\n    dfs(a,b,0);\n    printf(\"%d\\n\",minn);\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#define N  3\n#define N2 9\nusing namespace std;\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char toward[4]={'l','u','r','d'};\n\nclass Block{\npublic:\n    int A[N2];\n    string trace;\n    int loc;\n\n    bool operator < (const Block & b) const {\n        for(int i=0;i<N2;i++){\n            if(this->A[i]>b.A[i]) return false;\n            if(this->A[i]<b.A[i]) return true;\n        }\n        return false;\n    }\n};\nbool right(const Block &b){\n    for(int i=0;i<N2;i++){\n        if(b.A[i]!=i+1) return false;\n    }\n    return true;\n}\nvoid show(Block b){\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            cout<<b.A[i*N+j]<<' ';\n        }\n        cout<<endl;\n    }\n}\nstring bfs(Block b){\n    queue<Block> Q;\n    map<Block,bool> M;\n    Block temp;\n    int i,j,k;\n    Q.push(b);\n    M[b]=true;\n    while(!Q.empty()){\n        temp=Q.front();\n        Block tt=temp;\n        Q.pop();\n        if(right(temp)){\n            return temp.trace;\n        }\n        for(i=0;i<4;i++){\n            temp=tt;\n            int temploc=temp.loc;\n            int sx=temp.loc%N;\n            int sy=temp.loc/N;\n            int ex=sx+dx[i];\n            int ey=sy+dy[i];\n            int eloc=ey*N+ex;\n            if(ex<0 || ey<0 || ex>=N || ey>=N) continue;\n            swap(temp.A[temploc],temp.A[eloc]);\n            temp.loc=eloc;\n            if(right(temp)){\n                temp.trace+=toward[i];\n                return temp.trace;\n            }else\n            if(!M[temp]){\n                temp.trace+=toward[i];\n                M[temp]=true;\n                Q.push(temp);\n                //show(temp);\n                //cout<<endl;\n            }\n\n        }\n    }\n    cout<<\"???\"<<endl;\n    return \"WTF!\";\n}\nint main(){\n    int i;\n    Block b;\n    for(int i=0;i<N2;i++){\n        cin>>b.A[i];\n        if(b.A[i]==0){\n            b.loc=i;\n            b.A[i]=N2;\n        }\n    }\n    b.trace=\"\";\n    string s=bfs(b);\n    if(s==\"WTF!\") cout<<\"unsolvable\"<<endl;\n    else cout<<s.length()<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst vector<int> answer = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\nqueue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move, int zp){\n        wrongs = 0;\n        tiles = num;\n        zero_place = zp;\n        moves = move;\n    }\n\n    void board_to_int(int m){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1, zero_place+m));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int(-1);\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int(-3);\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int(3);\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int(1);\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nint solve(){\n    int z;\n    REP(i, 9) if(original[i] == 0) {z=i; break;}\n    pq.push(board(original, 0, z));\n    while(1){\n        auto target = pq.front();\n        pq.pop();\n        if(target.tiles == answer)\n            return target.moves;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i = a ; i < (int)n ; i++)\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nstruct Puzzle{\n  int field[9];\n  int space;\n  int turn;\n\n  bool operator < (const Puzzle& a) const{\n    rep(i, 9){\n      if(a.field[i] == field[i]) continue;\n      return field[i] >  a.field[i];\n    }\n    return false;\n  }\n};\n\nbool check(Puzzle p){\n  rep(i, 9){\n    if(p.field[i] != i+1) return false;\n  }\n  return true;\n}\n\nint solve(Puzzle in){\n  queue<Puzzle> q;  \n  map<Puzzle, bool> mp;\n\n  q.push(in);\n  mp[in] = true;\n  \n  // bfs\n  while(!q.empty()){\n    Puzzle p = q.front(); q.pop();\n    if(check(p)) return p.turn;\n    int x = p.space % 3;\n    int y = p.space / 3;\n    rep(i, 4){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || 2 < nx || ny < 0 || 2 < ny) continue;\n      Puzzle tmp = p;\n      swap(tmp.field[p.space], tmp.field[3 * ny + nx]);\n      tmp.space = 3 * ny + nx;\n      if(mp[tmp] == false){\n    mp[tmp] = true;\n    tmp.turn++;\n    q.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main(){\n  Puzzle in;\n  \n  rep(i, 9){\n    cin >> in.field[i];\n    if(in.field[i] == 0){\n      in.field[i] = 9;\n      in.space = i;\n    }    \n  }\n\n  in.turn = 0;\n  cout << solve(in) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t        in.f[i] = 9;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Puzzle {\npublic:\n    Puzzle(int *pzl) {\n        for (int i=0;i<9;i++) {\n            board[i]=pzl[i];\n            if (board[i] == 0)\n                zero = i;\n        }\n        moves_so_far = 0;\n    };\n\n    int moves_made() const {\n        return moves_so_far;\n    }\n\n    // for std::priority_queue\n    bool operator< (const Puzzle& p) const {\n        return hamm_dist() > p.hamm_dist();\n    }\n\n    bool operator== (const Puzzle& p) const {\n        for (int i = 0; i < 9; i++)\n            if (board[i] != p.board[i])\n                return false;\n        return true;\n    }\n\n    bool operator!= (const Puzzle& p) const {\n        return !(*this == p);\n    }\n\n    Puzzle& operator= (const Puzzle& p) {\n        zero = p.blank();\n        moves_so_far = p.moves_made();\n        for (int i = 0; i < 9; i++)\n            board[i] = p.board[i];\n\n        return *this;\n    }\n\n    int hamm_dist() const {\n        int cnt = 0;\n        for (int i = 0; i < 9; i++)\n            if (board[i] != i + 1)\n                cnt++;\n        return cnt + moves_so_far;\n    }\n\n    void move(int from, int to) {\n        swap(board[from], board[to]);\n        moves_so_far++;\n        zero = to;\n    }\n\n    int blank() const {\n        return this->zero;\n    }\n\n    bool solved() {\n        for (int i = 0; i < 8; i++)\n            if (this->board[i] != i + 1)\n                return false;\n        return true;\n    }\n    \nprivate:\n    int board[9];\n    int moves_so_far;\n    int zero;\n};\n\nint main(void)\n{\n    int puzzle[9];\n    for (int i = 0; i < 9; i++)\n        cin >> puzzle[i];\n    priority_queue<Puzzle> pqueue;\n    pqueue.push(Puzzle(puzzle));\n\n    Puzzle prev(puzzle);\n    while (true) {\n        Puzzle cur = pqueue.top();\n        pqueue.pop();\n        if (cur.solved()) {\n            cout << cur.moves_made() << endl;\n            break;\n        }\n\n        int zero = cur.blank();\n        vector<int> moves;\n        if (zero > 2)\n            moves.push_back(-3);\n        if (zero < 6)\n            moves.push_back(3);\n        if ((zero + 1) % 3 != 0)\n            moves.push_back(1);\n        if (zero % 3 != 0)\n            moves.push_back(-1);\n        for (auto d : moves) {\n            Puzzle newp = cur;\n            newp.move(zero, zero + d);\n            if (prev != newp)\n                pqueue.push(newp);\n        }\n        prev = cur;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint f, g, h;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tg = 0;\n\t\tf = h = hn(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tint hn(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint k = a[i][j] ? a[i][j] - 1 : size * size - 1;\n\t\t\t\tl += abs(i - k / 3) + abs(j - k % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tint solver() {\n\t\tstatic const pos to[] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\t\tset<arr> m;\n\t\tpriority_queue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.top();\n\t\t\tq.pop();\n//\t\t\tout(a.f,  '\\n');\n//\t\t\ta.print();\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!a.h)\n\t\t\t\treturn a.g / 2;\n\t\t\tfor (pos o: to) {\n\t\t\t\to.r += a.p.r, o.c += a.p.c;\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.g += 2;\n\t\t\t\t\tc.h = hn(c.b);\n\t\t\t\t\tc.f = c.g + c.h;\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nbool operator < (const board &a, const board &b) {\n\treturn a.f > b.f;\n}\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r',};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n\nstruct Puzzle {\n  int f[N*N];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i < N*N; i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N*N;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N*N;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N*N;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n     \n    bool operator < (const Puzzle &p) const{\n        for(int i = 0; i < N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \nbool isTarget(Puzzle p){\n    for(int i = 0; i < N2; i++)\n        if(p.f[i] != (i + 1)) return false;\n    return true;\n}\n \nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n     \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n \nint main(){\n    Puzzle in;\n    for(int i = 0; i < N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n     \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i<N2;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i<N2;i++){\n    if(p.f[i] != (i+1)) return false;\n  }\n    return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r<4;r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(b1.num[zero1]!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(b2.num[zero2]!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n\nint heuristic_func2(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    Board b2 = decode(enc2);\n    int res = 0;\n    for(int i=1;i<SIZE;i++){\n        int pos1 = 0;\n        int pos2 = 0;\n        while(b1.num[pos1]!=i) pos1++;\n        while(b2.num[pos2]!=i) pos2++;\n        res += abs(pos1/3-pos2/3) + abs(pos1%3 - pos2%3);\n    }\n    return res;\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func2(start, goal), start));\n    visited[start] = 0;\n    int count = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            count++;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func2(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    //cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\nint i,j;;\n//?Â§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\ntypedef pair<string,pair<int,int> > state;\n\nint solve(){\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  queue<state> q;\n  set<string> st;\n  st.insert(s);\n  q.push(mp(s,mp(0,ind)));\n  while(!q.empty()){\n    state u = q.front();\n    q.pop();\n    if(u.f==ans)return u.s.f;\n    FOR(i,0,4){\n      int index = u.s.s;\n      if(index%3==0 && d[i]==-1)continue;\n      if((index+1)%3==0 && d[i]==1)continue;\n      if(index<=2 && d[i]==-3)continue;\n      if(6<=index && d[i]==3)continue;\n      string v = u.f;\n      swap(v[index],v[index+d[i]]);\n      if(st.count(v)==0){\n        q.push(state(v,mp(u.s.f+1,index+d[i])));\n        st.insert(v);\n      }\n    }\n  }\n  return inf;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tconst int ansval = 123456780;\n\tconst int ansarray[N*N] = {1,2,3,4,5,6,7,8,0};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid valuetoarray(uint t,int *table){\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tuint getscore(uint t){\n\t\tint table[N*N];\n\t\tuint score = 0;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tfor(int j=0;j<N*N;++j){\n\t\t\t\tif(ansarray[i]==table[j]){\n\t\t\t\t\tscore += (i/N-j/N)*(i/N-j/N)+(i%N-j%N)*(i%N-j%N);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t\tscore = getscore(table);\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool operator<(const State& s) const{\n\t\t\treturn score < s.score;\n\t\t}\n\t\tbool operator>(const State& s) const{\n\t\t\treturn score > s.score;\n\t\t}\n\t\tbool isfinished() const{\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t\tuint score;\n\t};\n\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tif(table[i]==0){\n\t\t\t\tzi = i/N;\n\t\t\t\tzj = i%N;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\tstd::priority_queue<State,std::vector<State>,std::greater<State> > Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.top();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint MDT[N2][N2];\n\nstruct Puzzle\n{\n\tint f[N2], space, MD;\n\tint cost;\n\tbool operator < (const Puzzle &p) const\n\t{\n\t\tfor(int i = 0; i < N2; i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint getallMD(const Puzzle &p)\n{\n\tint h = 0;\n\tfor(int i = 0; i < N2; i++){\n\tif(i == p.space) continue;\n\t\th += MDT[i][p.f[i] - 1];\n\t}\n\treturn h;\n}\n\nstruct State\n{\n\tPuzzle pz;\n\tint estimated;\n\tbool operator < (const State &s) const\n\t{\n\t\tif(estimated != s.estimated){\n\t\t\treturn estimated > s.estimated;\n\t\t}else{\n\t\t\treturn pz.MD > s.pz.MD;\n\t\t}\n\t}\n};\n\nint astar(Puzzle p)\n{\n\tpriority_queue<State> A;\n\tmap<Puzzle, bool> USED;\n\n\tState initial;\n\tinitial.pz = p;\n\tinitial.estimated = p.MD;\n\tA.push(initial);\n\tUSED[p] = true;\n\n\tPuzzle u, v;\n\tint sx, sy, tx, ty, r;\n\n\twhile(!A.empty())\n\t{\n\t\tu = A.top().pz; A.pop();\n\t\tif(u.MD == 0) return u.cost;\n\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\tfor(r = 0; r < 4; r++){\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tv.MD -= MDT[tx * N + ty][u.f[tx * N + ty] - 1];\n\t\t\tv.MD += MDT[sx * N + sy][u.f[tx * N + ty] - 1];\n\t\t\tswap(v.f[sx * N + sy], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\t\n\t\t\tif(!USED[v]){\n\t\t\t\tv.cost++;\n\t\t\t\tUSED[v] = true;\n\t\t\t\tState new_s;\n\t\t\t\tnew_s.pz = v;\n\t\t\t\tnew_s.estimated = v.cost + v.MD;\n\t\t\t\tA.push(new_s);\n\t\t\t}\n\t\t}\n\t};\n\treturn -1;\n}\n\nint main()\n{\n\t\n\tfor(int i = 0; i < N2; i++){\n\t\tfor(int j = 0; j < N2; j++){\n\t\t\tMDT[i][j] = abs((i / N) - (j / N)) + abs((i % N) - (j % N));\n\t\t}\n\t}\n\tPuzzle in;\n\n\tfor(int i = 0; i < N2; i++){\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif(in.f[i] == 0) in.space = i;\n\t}\n\tin.cost = 0;\n\tin.MD = getallMD(in);\n\n\tcout << astar(in) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#define _USE_MATH_DEFINES // M_PI????????????????????????\n#include<math.h>\n#include<queue>\n#include<map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < ( const Puzzle &p ) const {\n\t\tfor(int i=0; i<N2; i++){\n\t\t\tif( f[i]==p.f[i] ) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1, 0, 1, 0};\nstatic const int dy[4]={0, -1, 0, 1};\nstatic const char dir[4]={'u', 'l', 'd', 'r'}\n\nbool isTarget(Puzzle p){\n\tfor(int i=0; i<N2; i++)\n\t\tif( p.f[i]!=(i+1) ) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.puth = \"\";\n\tQ.psuh(s);\n\tV[s] = true;\n\n\twhile( !Q.empty() ){\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif( isTarget(u) ) return u.push;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0; r<4; r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx<0 || ty<0 || tx>=N || ty>=N ) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N+ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif( !V[v] ){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor(int i=0; i<N2; i++){\n\t\tcin >> in.f[i];\n\t\tif( in.f[i]==0 ){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nstruct Puz{\n  int board[3][3];\n  int zx, zy;\n  int cnt;\n  \n  bool operator < (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] == p.board[i][j]) continue;\n        return board[i][j] > p.board[i][j];\n      }\n    }\n    return false;\n  }\n  \n  bool operator == (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] != p.board[i][j]) return false;\n      }\n    }\n    return true;\n  }\n};\n\nint d[5] = {0, -1, 0, 1, 0};\nPuz g = {{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}};\nmap<Puz, int> mem;\n\nint bfs(Puz s){\n  \n  queue<Puz> Q;\n  \n  Q.push(s);\n  mem[s] = 1;\n  \n  while(Q.size()){\n    Puz p = Q.front(), q;\n    Q.pop();\n    \n    if(p == g) return p.cnt;\n    \n    for(int i = 0;i < 4;i++){\n      int x = p.zx + d[i], y = p.zy + d[i + 1];\n      \n      if(0 <= x && x < 3 && 0 <= y && y < 3){\n        q = p;\n        swap(q.board[q.zy][q.zx], q.board[y][x]);\n        q.zy = y;\n        q.zx = x;\n        q.cnt++;\n        if(!mem[q]++) Q.push(q);\n      }\n    }\n  }\n  \n  return 0;\n}\n\nint main(){\n  \n  Puz s;\n  \n  for(int i = 0;i < 3;i++){\n    for(int j = 0;j < 3;j++){\n      cin >> s.board[i][j];\n      if(s.board[i][j] == 0){\n        s.zy = i;\n        s.zx = j;\n      }\n    }\n  }\n  s.cnt = 0;\n  \n  cout << bfs(s) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\n#define N (3)\n#define N2 (N*N)\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n\tfor ( int i = 0; i < N2; i++ ) {\n\t    if ( f[i] == p.f[i] ) continue;\n\t    return ( f[i] < p.f[i] );\n\t}\n\treturn false;\t\t// ????????????????????Â´???????????\\????????????\n        //return true;\n    }\n};\n\n// x, y?????????????????Â£??????\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget( Puzzle p ) {\n    for ( int i = 0; i < N2; i++ ) {\n\tif ( p.f[i] != ( i + 1 ) ) return false;\n    }\n    return true;\n}\n\nstring bfs( Puzzle s ) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push( s );\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget( u ) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\t\n\tfor ( int r = 0; r < 4; r++ ) {\n\t    int tx = sx + dx[r];\n\t    int ty = sy + dy[r];\n\n\t    if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t    v = u;\n\t    swap( v.f[u.space], v.f[tx * N + ty] );\n\t    v.space = tx * N + ty;\n\t    if ( !V[v] ) {\n\t\tV[v] = true;\n\t\tv.path += dir[r];\n\t\tQ.push( v );\n\t    }\n\t}\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n\tscanf(\"%d\", &in.f[i]);\n\tif ( in.f[i] == 0 ) {\n\t    in.f[i] = N2;\n\t    in.space = i;\n\t}\n    }\n    string ans = bfs( in );\n\n    printf(\"%d\\n\", (int)ans.size());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nconst int N=3;\nconst int N2=9;\n\nclass puzzle\n{\npublic:\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator<(const puzzle &p)const\n\t{\n\t\tfor(int i=0;i<N2;i++)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char dir[4]={'u','l','d','r'};\n\nbool istarget(puzzle p)\n{\n\tfor(int i=0;i<N2;i++)if(p.f[i]!=i+1)return false;\n\treturn true;\n}\n\nstring bfs(puzzle s)\n{\n\tqueue<puzzle>Q;\n\tmap<puzzle,bool>V;\n\tpuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(istarget(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||tx>=N||ty<0||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tpuzzle in;\n\tfor(int i=0;i<N2;i++)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\t\n\tstring ans=bfs(in);\n\t\n\tif(ans!=\"unsolvable\")cout<<ans.length()<<endl;\n\telse cout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint cnt = 0;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tint solver() {\n\t\tconst arr end = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n\t\t\tif (a.b == end)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<vector<int>, int> P;\n\nint zeroPosition( vector<int> a ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] == 0 ) return i;\n    }\n\n    return -1;\n}\n\nvector<int> swapDigit( vector<int> v, int a, int b ) {\n    vector<int> ret = v;\n    int x = v[a];\n    int y = v[b];\n    ret[a] = y;\n    ret[b] = x;\n\n    return ret;\n}\n\nbool isSame( vector<int> a, vector<int> b ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] != b[i] ) return false;\n    }\n\n    return true;\n}\n\nint convert( vector<int> a ) {\n    int ret = 0;\n    for ( int i = 0; i < 9; i++ ) {\n\tret *= 10;\n\tret += a[i];\n    }\n\n    return ret;\n}\n\nint main()\n{\n    set<int> S;\n    queue<P> Q;\n    vector<int> start;\n    vector<int> goal;\t\t// 123456780\n    for ( int i = 0; i < 9; i++ ) {\n\tgoal.push_back( (i + 1) % 9 );\n    }\n\n    for ( int i = 0; i < 9; i++ ) {\n\tint d;\n\tscanf(\"%d\", &d);\n\tstart.push_back( d );\n    }\n\n    S.insert( convert(start) );\n    Q.push( make_pair( start, 0 ) );\n    int ans = 0;\n\n    while ( !Q.empty() ) {\n\tP p = Q.front(); Q.pop();\n\tif ( isSame( p.first, goal) ) {\n\t    ans = p.second;\n\t    break;\n\t}\n\tint pos = zeroPosition( p.first );\n\t\n\tif ( ( pos % 3 ) != 0 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 1 );\n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n\n\tif ( ( pos % 3 ) != 2 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 1 );\t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n\n\tif ( pos > 2 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n\n\tif ( pos < 6 ) { // ???????Â§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\n\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++){\n    if(p.f[i] != (i+1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n  \n}\n\nint main(){\n  \n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;//set space\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <stdio.h>\n\nusing namespace std;\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\nint main() {\n\tarray<array<int,3>,3> pz;\n\tqueue<pair<typeof(pz),int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nmap<string, int> mp;\n\nstring trans(vector< vector<int> > a){\n  string t = \"\";\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) t += to_string(a[i][j]);\n  return t;\n}\n\nvoid dfs(vector< vector<int> > a, int turn){\n  string t = trans(a);\n  if( mp[t] != 0 && turn > mp[t] ) return;\n  if( t == \"123456780\" ){\n    // cout << t << \" \" << turn << \" \" << mp[t] << endl;\n    mp[t] = turn;\n    return;\n  }\n  if( turn > 20 ) return;\n  mp[t] = turn;\n  // cerr << t << \" \" << mp[t] << endl;\n\n  for(int y=0; y<3; y++){\n    for(int x=0; x<3; x++){\n      if( a[y][x] == 0 ){\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          vector< vector<int> > b = a;\n          swap(b[ny][nx], b[y][x]);\n          string tt = trans(b);\n          dfs(b, turn + 1);\n        }\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n\n  vector< vector<int> > a(3, vector<int>(3));\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) cin >> a[i][j];\n  mp[trans(a)] = 0;\n  mp[\"123456780\"] = inf;\n  dfs(a, 1);\n  cout << mp[\"123456780\"] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\nint str[5][5],v[5][5];\nlong long int book[5][5][100010];\nstruct Han\n{\n    int x,y,n;\n    int s[5][5];\n};\nvoid bfs(int x,int y)\n{\n    int i,j,k=0,next[4][2]={0,1,1,0,0,-1,-1,0};\n    long long l=0;\n    queue<Han>Q;\n    Han q,now;\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            l=l*10+str[i][j];\n            q.s[i][j]=str[i][j];\n        }\n    }\n    book[x][y][0]=l;\n    v[x][y]++;\n    q.x=x;\n    q.y=y;\n    q.n=0;\n    Q.push(q);\n    while(!Q.empty())\n    {\n        now=Q.front();\n        Q.pop();\n        for(i=0;i<4;i++)\n        {\n            int xx=now.x+next[i][0];\n            int yy=now.y+next[i][1];\n            if(xx<0||yy<0||xx>=3||yy>=3)continue;\n            q.x=xx;\n            q.y=yy;\n            q.n=now.n+1;\n\n            for(k=0;k<3;k++)\n            {\n                for(j=0;j<3;j++)\n                {\n                    q.s[k][j]=now.s[k][j];\n                }\n            }\n            k=q.s[now.x][now.y];\n            q.s[now.x][now.y]=q.s[xx][yy];\n            q.s[xx][yy]=k;\n\n            l=0;\n            for(k=0;k<3;k++)\n            {\n                for(j=0;j<3;j++)\n                {\n                    l=l*10+q.s[k][j];\n                }\n            }\n            if(l==123456780){printf(\"%d\\n\",q.n);return;}\n            int flag=0,a=v[xx][yy];\n            for(k=0;k<a;k++)\n            {\n                if(book[xx][yy][k]==l)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                book[xx][yy][a]=l;\n                v[xx][yy]++;\n                Q.push(q);\n            }\n        }\n    }\n}\nint main()\n{\n    int i,j,a,ex,ey;\n    memset(book,0,sizeof(book));\n    memset(v,0,sizeof(v));\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            scanf(\"%d\",&a);\n            str[i][j]=a;\n            if(a==0)\n            {\n                ex=i;\n                ey=j;\n            }\n        }\n    }\n    bfs(ex,ey);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int turn;\n    int map[boardw][boardw];\n    bool operator<(const BOARD &rhs) const {\n        for(int i = 0; i < boardw; i++) {\n            for (int j = 0; j < boardw; ++j) {\n                if (this->map[i][j] < rhs.map[i][j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n \n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    b.turn = 0;\n    q.push(b);\n    while(!q.empty()) {\n        BOARD nowB;\n        nowB = q.front(); q.pop();\n \n        if (check(nowB)) {\n            cout << nowB.turn << endl;\n            return 0;\n        }\n \n        int px, py;\n \n        for (int i = 0; i < boardw; ++i) {\n            for (int j = 0; j < boardw; ++j) {\n                if (nowB.map[i][j] == 0) {\n                    px = j;\n                    py = i;\n                }\n            }\n        }\n        /*\n        int est = 0;\n        for (int i = 0; i < boardw; ++i) {\n            for (int j = 0; j < boardw; ++j) {\n                int tgt = i * boardw + j + 1;\n                if (tgt == 16) tgt = 0;\n                for (int k = 0; k < boardw; k++) {\n                    for (int l = 0; l < boardw; l++) {\n                        if (nowB.map[k][l] == tgt) {\n                            est += std::abs(k - i) + std::abs(l - j);\n                        }\n                    }\n                }\n            }\n        }\n        if (nowB.turn + est / 2 - 1 > 45) continue;\n        */\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n        for (int k = 0; k < 4; ++k) {\n            int tx = px + dx[k];\n            int ty = py + dy[k];\n            if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n             \n            BOARD newB;\n            for (int i = 0; i < boardw; ++i) {\n                for (int j = 0; j < boardw; ++j) {\n                    newB.map[i][j] = nowB.map[i][j];\n                }\n            }\n            newB.turn = nowB.turn + 1;\n \n            int temp = newB.map[py][px];\n            newB.map[py][px] = newB.map[ty][tx];\n            newB.map[ty][tx] = temp;\n            if (m.find(newB) == m.end()) {\n                m[newB] = 1;\n                q.push(newB);\n                \n            } \n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n \nusing namespace std;\n \n#define N 3\n#define N2 9\n \nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n     \n    bool operator < (const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n \nstatic const int dx[4]={-1,0,1,0};\n \nstatic const int dy[4]={0,-1,0,1};\n \nstatic const char dir[4]={'u','a','d','r'};\n \nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n    return true;\n}\n \n \nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n     \n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n     \n    return \"unsolvable\";\n}\n \n \nint main(){\n    Puzzle in;\n     \n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n     \n    string ans = bfs(in);\n     \n    cout<<ans.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nint CountMove(const std::set<TPuzzle>& Before, const TPuzzle& Goal, int Count)\n{\n\tif(Before.find(Goal) != Before.end()) return Count;\n\tstd::set<TPuzzle> Next;\n\tfor(std::set<TPuzzle>::const_iterator It = Before.begin(); It != Before.end(); ++It){\n\t\tconst TPuzzle& Puzzle = *It;\n\t\tif(Movable(Puzzle, mpUp))    Next.insert(Move(Puzzle, mpUp));\n\t\tif(Movable(Puzzle, mpDown))  Next.insert(Move(Puzzle, mpDown));\n\t\tif(Movable(Puzzle, mpLeft))  Next.insert(Move(Puzzle, mpLeft));\n\t\tif(Movable(Puzzle, mpRight)) Next.insert(Move(Puzzle, mpRight));\n\t}\n\treturn CountMove(Next, Goal, 1 + Count);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> Start;\n\tStart.insert(Puzzle);\n\treturn CountMove(Start, Goal, 0);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pazzle {\n    string field;\n    int space;\n};\n\nmap<string, bool> mp;\nqueue<Pazzle> que;\n\nint main() {\n    Pazzle p;\n    int num, depth = 0;\n    for (int i = 0; i < 9; i++) {\n        cin >> num;\n        p.field += num + '0';\n\n        if (num == 0) {\n            p.space = i;\n        }\n    }\n\n    que.push(p);\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            p = que.front();\n            que.pop();\n\n            if (p.field == \"123456780\") {\n                cout << depth << endl;\n                return 0;\n            }\n            if (mp[p.field] == true) {\n                continue;\n            }\n            else {\n                mp[p.field] = true;\n            }\n\n            if ((p.space + 1) % 3 != 0) {\n                swap(p.field[p.space], p.field[p.space + 1]);\n                p.space++;\n                que.push(p);\n                p.space--;\n                swap(p.field[p.space], p.field[p.space + 1]);\n            }\n            if (p.space % 3 != 0) {\n                swap(p.field[p.space], p.field[p.space - 1]);\n                p.space--;\n                que.push(p);\n                p.space++;\n                swap(p.field[p.space], p.field[p.space - 1]);\n            }\n            if (2 < p.space) {\n                swap(p.field[p.space], p.field[p.space - 3]);\n                p.space -= 3;\n                que.push(p);\n                p.space += 3;\n                swap(p.field[p.space], p.field[p.space - 3]);\n            }\n            if (p.space < 6) {\n                swap(p.field[p.space], p.field[p.space + 3]);\n                p.space += 3;\n                que.push(p);\n                p.space -= 3;\n                swap(p.field[p.space], p.field[p.space + 3]);\n            }\n        }\n        depth++;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\nbool rec(string v,int index,int step,int limit){\n  if(limit<step)return false;\n  if(v==ans)return true;\n  FOR(i,0,4){\n    if(index%3==0 && d[i]==-1)continue;\n    if((index+1)%3==0 && d[i]==1)continue;\n    if(index<=2 && d[i]==-3)continue;\n    if(6<=index && d[i]==3)continue;\n    string u = v;\n    swap(u[index],u[index+d[i]]);\n    if(rec(u,index+d[i],step+1,limit))return true;\n  }\n  return false;  \n}\n\nint solve(){\n  int res = 0;\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  while(!rec(s,ind,0,res))res++;\n  return res;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define Ntw 3\n#define N2tw 9\n\nstruct Puzzletw{\n    int f[N2tw];\n    int space;\n    string path;\n\n    bool operator < (const Puzzletw &p)const{\n        for(int i=0;i<N2tw;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzletw p){\n    for(int i=0;i<N2tw;i++)\n    if(p.f[i] != (i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzletw s){\n    queue<Puzzletw> Q;\n    map<Puzzletw,bool>V;\n    Puzzletw u, v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n\n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u))return u.path;\n        int sx = u.space/Ntw;\n        int sy = u.space%Ntw;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=Ntw||ty>=Ntw)continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*Ntw+ty]);\n            v.space=tx*Ntw+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzletw in;\n\n    for(int i=0;i<N2tw;i++){\n        cin >> in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2tw;\n            in.space=i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size()<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define Size 9\n\nusing namespace std; \n\nint find_zero(string state) {\n\tfor (int i = 0; i < Size; ++i) {\n\t\tif (state[i] == '0') {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstring move(string str, int p1, int p2) {\n\tstring res = str;\n\tres[p1] = str[p2];\n\tres[p2] = str[p1];\n\treturn res;\n}\n\nint main(void) {\n\tstring state = \"012345678\";\n\tfor (int i = 0; i < Size; ++i) {\n\t\tcin >> state[i];\n\t}\n\n\tint zi;\n\tmap<string,int> memo;\n\tmemo[state] = 1;\n\tpair<string,int> now;\n\tqueue< pair<string,int> > q;\n\tq.push({state,1});\n\twhile (!q.empty()) {\n\t\tnow = q.front();\n\t\tq.pop();\n\t\tif (now.first == \"123456780\") {\n\t\t\tcout << now.second-1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tzi = find_zero(now.first);\n\t\tif (zi%3 != 2) {\n\t\t\tstate = move(now.first,zi,zi+1);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t\tif (zi%3 != 0) {\n\t\t\tstate = move(now.first,zi,zi-1);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t\tif (zi/3 > 0) {\n\t\t\tstate = move(now.first,zi,zi-3);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t\tif (zi/3 < 2) {\n\t\t\tstate = move(now.first,zi,zi+3);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(zero1!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(zero2!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func(start, goal), start));\n    visited[start] = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint calc(const vec& v){\n  int res=0;\n  for(int i=0;i<9;i++){\n    if(v[i]==0)continue;\n    int id=v[i]-1;\n    res+= abs(id/3 - i/3) + abs(id%3 - i%3);\n  }\n  return res;\n}\n\nint main(){\n  vec A(9);\n  for(int i=0;i<9;i++)cin>>A[i];\n\n  queue< vec > Q;\n  map< vec , int > d;\n  d[A]=0;\n  Q.push(A);\n  while(!Q.empty()){\n    vec p=Q.front();\n    Q.pop();\n    \n    if( calc(p)==0){\n      cout<<d[p]<<endl;\n      break;\n    }\n    \n    int py=0,px=0;\n    for(int i=0;i<9;i++){\n      if(p[i]==0){\n        py=i/3;\n        px=i%3;\n        break;\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int ny=py+dy[i];\n      int nx=px+dx[i];\n      if(ny<0 || ny>=3 || nx<0 || nx>=3)continue;\n      vec np=p;\n      swap( np[ny*3+nx] , np[py*3+px] );\n      if( d.count(np) == 0 ){\n        Q.push(np);\n        d[np]=d[p]+1;\n      }\n    }\n    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(wrongs + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ã§ãã­ãï¼\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"è¡ç®ã ãã¼ããã»ã»\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" âãªãã ãã¼ãã®æ°å­ï¼\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nvvi pz0(3,vi(3,0));\nint ans=32;\nmap <vvi,int> tf;\n\nint find0(vvi pz){\n\n  REP(i,3) REP(j,3) if(pz[i][j]==0) return i*3+j;\n\n}\n\nvoid print(vvi pz){\n\n  REP(i,3){\n    REP(j,3){\n      if(j) cout<<\" \";\n      cout<<pz[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\nvoid bfs(vvi pz){\n\n  queue <pair<vvi,int>> pzq;\n  pzq.push(mp(pz,0));\n\n  for(;!pzq.empty();){\n\n    vvi now=pzq.front().fi;\n    int how=pzq.front().se;\n    pzq.pop();\n\n    if(how>31) continue;\n\n    if(tf[now]) continue;\n    tf[now]=1;\n\n    if(now==pz0){\n\n      ans=how;\n      return;\n\n    }\n\n    int x=find0(now)%3;\n    int y=find0(now)/3;\n\n    REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(now[y][x],now[y0][x0]);\n    pzq.push(mp(now,how+1));\n    swap(now[y][x],now[y0][x0]);\n\n    }\n\n  }\n\n}\n\nvoid dfs(vvi pz,int how){\n\n  if(tf[pz]) return;\n  tf[pz]=1;\n\n  if(how>31) return;\n  if(pz0==pz){\n\n    ans=min(ans,how);\n    return;\n\n  }\n\n  int x=find0(pz)%3;\n  int y=find0(pz)/3;\n\n  REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(pz[y][x],pz[y0][x0]);\n    dfs(pz,how+1);\n    swap(pz[y][x],pz[y0][x0]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  vvi pz(3,vi(3,0));\n\n  REP(i,9) pz0[i/3][i%3]=(i+1)%9;\n  REP(i,9) cin>>pz[i/3][i%3];\n\n  bfs(pz);\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nqueue<int>Q[3][3];\nqueue<int>R[3][3];\n\nint main() {\n\tint a, b, c, d, e, sum=0;\n\tint x[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> a;\n\t\t\tQ[i][j].push(a);\n\t\t}\n\t}\n\twhile (true) {\n\t\twhile (!Q[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (Q[i][j].front() == 0) {\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[0][0] == 1 && x[0][1] == 2 && x[0][2] == 3 && x[1][0] == 4 && x[1][1] == 5 && x[1][2] == 6 && x[2][0] == 7 && x[2][1] == 8) {\n\t\t\t\tgoto owata;\n\t\t\t}\n\t\t\tif (b >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b - 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b - 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b + 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b + 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c - 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c - 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c + 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c + 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!R[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].push(R[i][j].front());\n\t\t\t\t\tR[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\nowata:;\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nclass puzzle8 {\npublic:\n\tint** field;\n\tint cost;\n\tint guess;\n\tint row_0, column_0;\n\tpuzzle8();\n\tpuzzle8(puzzle8*);\n\tvoid calc_guess();\n\tvoid slide_up();\n\tvoid slide_down();\n\tvoid slide_left();\n\tvoid slide_right();\n};\n\n\n\npuzzle8::puzzle8() {\n\tfield = new int* [3];\n\tfor (int i = 0;i < 3;i++) {\n\t\tfield[i] = new int[3];\n\t}\n\tcolumn_0 = row_0 = 0;\n\tcost = guess = 0;\n}\npuzzle8::puzzle8(puzzle8* a) {\n\tfield = new int* [3];\n\tfor (int i = 0;i < 3;i++) {\n\t\tfield[i] = new int[3];\n\t\tfor (int j = 0;j < 3;j++) {\n\t\t\tfield[i][j] = a->field[i][j];\n\n\t\t}\n\t}\n\tcost = a->cost;\n\tguess = a->guess;\n\trow_0 = a->row_0;\n\tcolumn_0 = a->column_0;\n}\nvoid puzzle8::calc_guess() {\n\tguess = 0;\n\tfor (int i = 0;i < 3;i++) {\n\t\tfor (int j = 0;j < 3;j++) {\n\t\t\tif (field[i][j] != 8) {\n\t\t\t\tguess += abs(i - field[i][j] / 3) + abs(j - field[i][j] % 3);\n\t\t\t}\t\n\t\t}\n\t}\n}\nvoid puzzle8::slide_up() {\n\tswap(field[row_0][column_0], field[row_0 - 1][column_0]);\n\tguess += abs(field[row_0][column_0] / 3 - row_0) - abs(field[row_0][column_0] / 3 - row_0 + 1);\n\trow_0--;\n\tcost++;\n}\nvoid puzzle8::slide_down() {\n\tswap(field[row_0][column_0], field[row_0 + 1][column_0]);\n\tguess += abs(field[row_0][column_0] / 3 - row_0) - abs(field[row_0][column_0] / 3 - row_0 - 1);\n\trow_0++;\n\tcost++;\n}\nvoid puzzle8::slide_left() {\n\tswap(field[row_0][column_0], field[row_0][column_0 - 1]);\n\tguess += abs(field[row_0][column_0] % 3 - column_0) - abs(field[row_0][column_0] % 3 - column_0 + 1);\n\tcolumn_0--;\n\tcost++;\n}\nvoid puzzle8::slide_right() {\n\tswap(field[row_0][column_0], field[row_0][column_0 + 1]);\n\tguess += abs(field[row_0][column_0] % 3 - column_0) - abs(field[row_0][column_0] % 3 - column_0 - 1);\n\tcolumn_0++;\n\tcost++;\n}\n\nint btoi(puzzle8* a) {\n\tint sum = 0;\n\tfor (int i = 0;i < 9;i++) {\n\t\tsum += pow(9, i) * a->field[i / 3][i % 3];\n\t}\n\treturn sum;\n}\n\ninline bool operator>(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess > b.cost + b.guess;\n}\ninline bool operator>=(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess >= b.cost + b.guess;\n}\ninline bool operator<(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess < b.cost + b.guess;\n}\ninline bool operator<=(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess <= b.cost + b.guess;\n}\n\nint main() {\n\tpuzzle8 p,new_puzzle;\n\t\n\tpriority_queue<puzzle8,vector<puzzle8>,greater<puzzle8>> pq;\n\tvector<int> appeared;\n\tint tmp;\n\tfor (int i = 0;i < 3;i++) {\n\t\tfor (int j = 0;j < 3;j++) {\n\t\t\tcin >> p.field[i][j];\n\t\t\tif (p.field[i][j] == 0) {\n\t\t\t\tp.field[i][j] = 8;\n\t\t\t\tp.row_0 = i;\n\t\t\t\tp.column_0 = j;\n\t\t\t}\n\t\t\telse p.field[i][j]--;\n\t\t}\n\t}\n\tp.cost = 0;\n\tp.calc_guess();\n\tappeared.push_back(btoi(&p));\n\twhile (p.guess != 0) {\n\t\tif (p.row_0 != 0) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_up();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\t\n\t\t}\n\t\tif (p.row_0 != 2) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_down();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tif (p.column_0 != 0) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_left();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tif (p.column_0 != 2) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_right();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tp = pq.top();\n\t\tpq.pop();\n\t}\n\tcout << p.cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\n#define N (3)\n#define N2 (N*N)\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n\tfor ( int i = 0; i < N2; i++ ) {\n\t    if ( f[i] == p.f[i] ) continue;\n\t    return ( f[i] < p.f[i] );\n\t}\n\treturn false;\t\t// ????????????????????Â´???????????\\????????????\n    }\n};\n\n// x, y?????????????????Â£??????\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget( Puzzle p ) {\n    for ( int i = 0; i < N2; i++ ) {\n\tif ( p.f[i] != ( i + 1 ) ) return false;\n    }\n    return true;\n}\n\nstring bfs( Puzzle s ) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push( s );\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget( u ) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\t\n\tfor ( int r = 0; r < 4; r++ ) {\n\t    int tx = sx + dx[r];\n\t    int ty = sy + dy[r];\n\n\t    if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t    v = u;\n\t    swap( v.f[u.space], v.f[tx * N + ty] );\n\t    v.space = tx * N + ty;\n\t    if ( !V[v] ) {\n\t\tV[v] = true;\n\t\tv.path += dir[r];\n\t\tQ.push( v );\n\t    }\n\t}\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n\tscanf(\"%d\", &in.f[i]);\n\tif ( in.f[i] == 0 ) {\n\t    in.f[i] = N2;\n\t    in.space = i;\n\t}\n    }\n    string ans = bfs( in );\n\n    printf(\"%d\\n\", (int)ans.size());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_13_B\n// Heuristic Search - 8 Puzzle\n// status:\n// tag: [bfs]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <map>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct puzzle {\n    int p[N2];\n    string path;\n    int space;\n\n    bool is_complete() {\n        // complete pattern is:\n        // 1 2 3\n        // 4 5 6\n        // 7 8 9\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] != i + 1) return false;\n        }\n\n        return true;\n    }\n\n    bool operator<(const puzzle& other) const {\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] == other.p[i]) continue;\n            return other.p[i] < p[i];\n        }\n\n        // equal\n        return false;\n    }\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char direction[] = {'l', 'd', 'r', 'u'};\n\nint to_index(int x, int y) { return y * N + x; }\nint to_x(int index) { return index % N; }\nint to_y(int index) { return index / N; }\n\nqueue<puzzle> pq;\n\nstring bfs() {\n    map<puzzle, bool> puzzle_memory;\n\n    while (!pq.empty()) {\n        auto curr_puzzle = pq.front();\n        pq.pop();\n\n        int curr_x = to_x(curr_puzzle.space), curr_y = to_y(curr_puzzle.space);\n        for (int r = 0; r < 4; ++r) {\n            int next_x = curr_x + dx[r], next_y = curr_y + dy[r];\n            if (next_x < 0 || N <= next_x || next_y < 0 || N <= next_y) continue;\n\n            auto next_puzzle = curr_puzzle;\n            next_puzzle.space = to_index(next_x, next_y);\n            swap(next_puzzle.p[curr_puzzle.space], next_puzzle.p[next_puzzle.space]);\n            // æ¢ã«åºç¾ããç¤é¢ãªãcontinue\n            if (puzzle_memory[next_puzzle]) continue;\n\n            next_puzzle.path += direction[r];\n            if (next_puzzle.is_complete()) return next_puzzle.path;\n\n            puzzle_memory[next_puzzle] = true;\n            pq.push(next_puzzle);\n        }\n    }\n\n    // fail\n    return \"\";\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(1 3 0\n4 2 5\n7 8 6\n)\";\n    stringstream stream(program_input_str);\n#endif\n    puzzle start_puzzle;\n    start_puzzle.path = \"\";\n\n    int value;\n    for (int y = 0; y < N; ++y) {\n        for (int x = 0; x < N; ++x) {\n            auto index = to_index(x, y);\n            stream >> value;\n            start_puzzle.p[index] = value;\n            if (value == 0) {\n                start_puzzle.p[index] = N2;\n                start_puzzle.space = index;\n            }\n        }\n    }\n\n    pq.push(start_puzzle);\n    auto ans = bfs();\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint factorial[9];\nint state[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}, target, ans;\nqueue<int> id_que, layer_que;\nbool inque[362900];\n\nint cantor(int *map){\n    int rank = 0;\n    for(int i=0; i<9; i++){\n        int n_smaller = 0;\n        for(int j=i+1; j<9; j++)\n            if(map[i]>map[j])\n                n_smaller += 1;\n        rank += n_smaller * factorial[8-i];\n    }\n    return rank;\n}\n\nvoid inv_cantor(int rank, int *map){\n    bool used[9];\n    memset(used, 0, sizeof(used));\n    for(int i=0; i<9; i++){\n        int n_smaller = rank / factorial[8-i], cnt=0;\n        rank -= n_smaller*factorial[8-i];\n        for(int j=0; j<9; j++){\n            if(used[j]) continue;\n            if(cnt==n_smaller){\n                *(map+i) = j;\n                used[j] = true;\n                break;\n            }else \n                ++cnt;\n        }\n    }\n}\n\nbool check(int pos){\n    return pos >= 0 && pos < 3;\n}\n\nint main(){\n    factorial[0] = 1;\n    for(int i=1; i<9; i++)\n        factorial[i] = i * factorial[i-1];\n    target = cantor(state[0]);\n\n    \n    for(int i=0; i<9; i++)\n        scanf(\"%d\", state[0]+i);\n    memset(inque, 0, sizeof(inque));\n    id_que.push(cantor(state[0]));\n    layer_que.push(0);\n    inque[id_que.front()] == true;\n\n    if(id_que.front()==target)\n        printf(\"0\\n\");\n    else{\n        int head, tail, layer, zx, zy, nx, ny;\n        bool found=false;\n        while(!id_que.empty()){\n            head = id_que.front();\n            layer = layer_que.front();\n            id_que.pop();\n            layer_que.pop();\n            inv_cantor(head, state[0]);\n\n            //find the position of zero\n            for(int i=0; i<9; i++){\n                if(*(state[0]+i)==0){\n                    zx = i / 3;\n                    zy = i % 3;\n                    break;\n                }\n            }\n\n            //iterator the posible positions\n            for(int dir=0; dir<4; dir++){\n                nx = zx + dx[dir];\n                ny = zy + dy[dir];\n                if(check(nx) && check(ny)){\n                    state[zx][zy] = state[nx][ny];\n                    state[nx][ny] = 0;\n                    tail = cantor(state[0]);\n                    //printf(\"%d\\n\", tail);\n                    if(tail==target){\n                        found = true;\n                        ans = layer + 1;\n                        break;\n                    }else if(!inque[tail]){\n                        inque[tail] = true;;\n                        id_que.push(tail);\n                        layer_que.push(layer + 1);\n                    }\n                    state[nx][ny] = state[zx][zy];\n                    state[zx][zy] = 0;\n                }\n            }\n\n            if(found){\n                printf(\"%d\\n\", ans);\n                break;\n            }\n        }\n    }\n    \n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<string.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint n;\nint mp[10][10];\nint nextt[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\ntypedef struct note\n{\n    int a[5][5];\n    int x,y,s;\n}eight;\nqueue<eight>Q;\nint hash(eight x)\n{\n    int sum=0;\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            sum=sum*10+x.a[i][j];\n        }\n    }\n    return sum;\n}\nvoid bfs()\n{\n    map<int,bool>flag;\n    eight now,temp;\n    now=Q.front();\n    now.s=0;\n    int index=hash(now);\n    flag[index]=1;\n    while(!Q.empty())\n    {\n        now=Q.front();\n        //printf(\"%d\\n\",hash(now));\n        if(hash(now)==123456780)\n        {\n            printf(\"%d\\n\",now.s);\n            return ;\n        }\n        Q.pop();\n        for(int i=0;i<4;i++)\n        {\n            int tx=now.x+nextt[i][0];\n            int ty=now.y+nextt[i][1];\n            temp=now;\n            if(tx<0||ty<0||tx>=3||ty>=3)continue;\n            temp.a[now.x][now.y]=temp.a[tx][ty];\n            temp.a[tx][ty]=0;\n            index=hash(temp);\n            if(flag[index]==0)\n            {\n                flag[index]=1;\n                temp.x=tx;\n                temp.y=ty;\n                temp.s=now.s+1;\n                Q.push(temp);\n            }\n        }\n    }\n}\nint main()\n{\n    eight now;\n    while(!Q.empty())\n        Q.pop();\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            scanf(\"%d\",&mp[i][j]);\n            if(mp[i][j]==0)\n            {\n                now.x=i;\n                now.y=j;\n                now.a[i][j]=0;\n                now.s=0;\n            }\n            else\n                now.a[i][j]=mp[i][j];\n        }\n    }\n    Q.push(now);\n    bfs();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct State\n{\n\tint puzzle[9];\n\tint depth;\n\tint evaluation;\n\n\tbool operator<(const State& s)const\n\t{\n\t\treturn evaluation < s.evaluation;\n\t}\n\n\tbool operator>(const State& s)const\n\t{\n\t\treturn evaluation > s.evaluation;\n\t}\n\n\tbool operator==(const State& s)const\n\t{\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (puzzle[i] != s.puzzle[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nState goal;\n//vector<State> checkedState;\n\nint heuristic(State s)\n{\n\tint eva = 0;\n\tint pos1[9], pos2[9];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tpos1[s.puzzle[i]] = i;\n\t\tpos2[goal.puzzle[i]] = i;\n\t}\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint manhattan = 0;\n\t\tmanhattan += abs(pos1[i] / 3 - pos2[i] / 3);\n\t\tmanhattan += abs(pos1[i] % 3 - pos2[i] % 3);\n\t\teva += manhattan;\n\t}\n\treturn eva;\n}\n\nint solve(State start)\n{\n\tpriority_queue<State, vector<State>, greater<State>> pq;\n\n\tpq.push(start);\n\n\twhile (!pq.empty())\n\t{\n\t\tState ts = pq.top();\n\t\tpq.pop();\n\n\t\t//checkedState.push_back(ts);\n\n\t\tif (ts == goal)\n\t\t{\n\t\t\treturn ts.depth;\n\t\t}\n\n\t\tint zeroi = -1;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (ts.puzzle[i] == 0)\n\t\t\t{\n\t\t\t\tzeroi = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zeroi <= 5)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 3];\n\t\t\ttts.puzzle[zeroi + 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t\tif (zeroi % 3 != 2)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 1];\n\t\t\ttts.puzzle[zeroi + 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t\tif (zeroi % 3 != 0)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 1];\n\t\t\ttts.puzzle[zeroi - 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t\tif (3 <= zeroi)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 3];\n\t\t\ttts.puzzle[zeroi - 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tState start;\n\n\tgoal.depth = 0;\n\tgoal.evaluation = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tgoal.puzzle[i] = (i + 1) % 9;\n\t}\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tstart.puzzle[i] = n;\n\t}\n\n\tstart.depth = 0;\n\tstart.evaluation = 0;\n\n\tprintf(\"%d\\n\", solve(start));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define M 9\n\nstruct Puzz{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzz &p) const {\n    for(int i=0;i<M;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1 ,0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dirc[4] = {'u','l','d','t'};\n\nbool Tage(Puzz p){\n  for(int i=0;i<M;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring afs(Puzz m){\n  queue<Puzz> Q;\n  map<Puzz, bool> V;\n  Puzz u,v;\n  m.path=\"\";\n  Q.push(m);\n  V[m]=true;\n\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n\n    if(Tage(u)) return u.path;\n    int mx=u.space/N;\n    int my=u.space%N;\n\n    for(int i=0;i<4;i++){\n      int px=mx+dx[i];\n      int py=my+dy[i];\n      if(px<0 || py<0 || px>=N || py>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[px*N+py]);\n      v.space=px*N+py;\n\n      if(!V[v]){\n        V[v]=true;\n        v.path+=dirc[i];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzz ln;\n\n  for(int i=0;i<M;i++){\n    cin >> ln.f[i];\n    if(ln.f[i] ==0){\n      ln.f[i]=M;\n      ln.space =i;\n    }\n  }\n  string answer = afs(ln);\n  cout << answer.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    if(check() == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(check() + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 100){\n        move = dfs(0, check() + i);\n        if(move > 0)\n            break;\n    }\n\n\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nvector<int> tiles(9);\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 50){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint max;\n\tint cnt = 0;\n\n\tint f(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint c = a[i][j];\n\t\t\t\tif (c == 0)\n\t\t\t\t\tc = size * size - 1;\n\t\t\t\telse\n\t\t\t\t\tc--;\n\t\t\t\tl += abs(i - c / 3) + abs(j - c % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tmax = f(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\n\tint solver() {\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n//\t\t\ta.print();\n\t\t\tint dis = f(a.b);\n\t\t\tif (dis > max + 10 - a.cnt / 1.5)\n\t\t\t\tcontinue;\n//\t\t\tout(dis, \"\\n\");\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!dis)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n  \nusing namespace std;\n  \n#define RY 3\n#define N 9\n  \ntypedef struct board {\n  int O[N];\n  int ling;\n  vector<int> path;\n  \n  bool operator < (const board &t) const {\n    for (int i = 0; i < N; i++) {\n      if (O[i] == t.O[i]) continue;\n      else if (O[i] < t.O[i]) return true;\n      else return false;\n    }\n    return false;\n  }\n} cubic;\n \nint xx[4] = { 0, 1, 0, -1 };\nint yy[4] = { 1, 0, -1, 0 };\n  \nbool fingoal(cubic b) {\n  for (int i = 0; i < N-1; i ++)\n    if (b.O[i] != i+1) return false;\n  \n  return true;\n}\n  \nvoid meltd(cubic b) {\n  map<cubic, bool> visited;\n  queue<cubic> q;\n  q.push(b);\n  \n  while (!q.empty()) {\n    cubic bcur = q.front(); q.pop();\n    visited[bcur] = true;\n  \n    if (fingoal(bcur)) {\n      cout << bcur.path.size() << endl;\n      return;\n    }\n  \n    for (int i = 0; i < 4; i ++) {\n      cubic b = bcur;\n      int nx = (bcur.ling / RY) + xx[i];\n      int ny = (bcur.ling % RY) + yy[i];\n  \n      if (nx < 0 || nx > 2 || ny < 0 || ny > 2) continue;\n  \n      b.ling = nx * RY + ny;\n      swap(b.O[b.ling], b.O[bcur.ling]);\n  \n      if (visited[b]) continue;\n  \n      b.path.push_back(b.ling);\n      q.push(b);\n    }\n  }\n}\n  \nint main() {\n  cubic b;\n  \n  for (int i = 0; i < N; i++) {\n    cin >> b.O[i];\n    if (b.O[i] == 0) b.ling = i;\n  }\n  \n  meltd(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    int i;\n    for(i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const char dir[4] = {'u','l','d','r'};\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\n\nbool isTarget(Puzzle p) {\n  int i;\n  for(i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#pragma warning(disable:4996)\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] != p.f[i]) return f[i] < p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1) return false;\n\t}\n\treturn true;\n}\n\nconst int dx[4]{ -1, 0, 1, 0 };\nconst int dy[4]{ 0, -1, 0, 1 };\nconst char dir[4]{ 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tp.path = \"\";\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\tqueue<Puzzle> Q;\n\tQ.push(p);\n\tfor (int i = 0; i < N2; ++i) {\n\t\twhile (!Q.empty()) {\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (isComplete(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\t\tv = u;\n\t\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!M[v]) {\n\t\t\t\t\tM[v] = true;\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), -1);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN) / DIVN - i / DIVN);\n\t}\n\treturn -result - Puzzles[x] * 32768;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> tmp, result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>]\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N (3)\n#define N2 (9)\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator<(const Puzzle &p)const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1))return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u))return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N)continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(void){\n    Puzzle in;\n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<cassert>\n\n#define N 3\n#define N2 9\n#define LIMIT 100\n\nusing namespace std;\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\nint MDT[N2][N2];\n\nstruct Puzzle {\n  int f[N2], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint getAllMD(Puzzle pz){\n  int sum = 0;\n  for(int i=0; i<N2; i++){\n    if(pz.f[i] == N2) continue;\n    sum += MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0; i<N2; i++)\n    if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n\n  if(depth+state.MD > limit) return false;\n\n  int sx = state.space / N;\n  int sy = state.space % N;\n  Puzzle tmp;\n\n  for(int r=0; r<4; r++){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    \n    if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n       if(max(prev, r)-min(prev, r) == 2) continue;\n       tmp = state;\n\n       state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n       state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n       swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n       state.space = tx*N+ty;\n       if(dfs(depth+1,r) ) {path[depth] = r; return true; }\n       state = tmp;\n  }       \n       \n    return false;\n  \n}    \n\n\nstring iterative_deepening(Puzzle in){\n  in.MD = getAllMD(in);\n\n  for(limit = in.MD; limit <= LIMIT; limit++){\n    state = in;\n    if(dfs(0, -100) ){\n      string ans = \"\";\n      for(int i = 0; i<limit; i++) ans += dir[path[i]];\n      return ans;\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0; i<N2; i++)\n    for(int j=0; j<N2; j++)\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deepening(in);\n  cout << ans.size() << endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator<(const Puzzle &p) const{\n\tfor(int i=0;i<N2;i++){\n\t  if(f[i]==p.f[i]) continue;\n\t  return f[i]>p.f[i];\n\t}\n\treturn false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n\tif(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n\tu=Q.front(); Q.pop();\n\tif(isTarget(u)) return u.path;\n\tint sx = u.space /N;\n\tint sy =u.space %N;\n\tfor(int r=0;r<4;r++){\n\t  int tx=sx+dx[r];\n\t  int ty = sy+dy[r];\n\t  if(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t  v=u;\n\t  swap(v.f[u.space],v.f[tx*N+ty]);\n\t  v.space=tx*N+ty;\n\t  if(!V[v]){\n\t\tV[v]=true;\n\t\tv.path+=dir[r];\n\t\tQ.push(v);\n\t  }\n\t}\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n\tcin>>in.f[i];\n\tif(in.f[i]==0){\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n  }\n  string ans = bfs(in);\n  cout <<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint getcost(int i, int j, int tmp)\n{\n    return abs(i - (tmp - 1) / 3) + abs(j - (tmp - 1) % 3);\n}\n\nbool solve(vector<vector<int> > puzzle, int cutoff, int cost)\n{\n    priority_queue<pair<int, vector<vector<int> > > > qu;\n    qu.push(make_pair(-cost, puzzle));\n    while(!qu.empty()){\n        vector<vector<int> > now = (qu.top()).second;\n        int nowcost = (qu.top()).first;\n        qu.pop();\n        int h = 0;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                int tmp = now[i][j];\n                if(tmp != 0) h += getcost(i, j, tmp); \n            }\n        }\n        // cout << nowcost << endl;\n        if(h == 0){\n            return true;\n        }\n        for(int i = 0; i < 4; i++){\n            for(int j = 0; j < 4; j++){\n                // cout << now[i][j] << \" \";\n                if(now[i][j] == 0){\n                    int dx[4] = {0, 1, 0, -1};\n                    int dy[4] = {1, 0, -1, 0};\n                    for(int k = 0; k < 4; k++){\n                        int nx = i + dx[k];\n                        int ny = j + dy[k];\n                        if(nx < 0 || ny < 0 || nx >= 3 || ny >= 3) continue;\n                        int nowc = getcost(nx, ny, now[nx][ny]);\n                        int nextc = getcost(i, j, now[nx][ny]);\n                        // cout << now[nx][ny] << \" \" << nextc - nowc << endl;\n                        nowcost -= nextc - nowc + 1;\n                        swap(now[i][j], now[nx][ny]);\n                        if(-nowcost <= cutoff) qu.push(make_pair(nowcost, now));\n                        swap(now[i][j], now[nx][ny]);\n                        nowcost += nextc - nowc + 1;\n                    }\n                    i = 5;\n                    break;\n                }\n            }\n            // cout << endl;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    vector<vector<int> > puzzle(3);\n    int cost = 0;\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            int tmp;\n            cin >> tmp;\n            puzzle[i].push_back(tmp);\n            if(tmp != 0) cost += getcost(i, j, tmp);\n        }\n    }\n    // cout << cost << endl;\n    for(int i = cost; ; i++){\n        if(solve(puzzle, i, cost)){\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n#include <sstream>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\nconst ll MD = 1000000007LL;\n\nstruct Board{\n\tvector<vint> v;\n\n\tBoard(vector<vint> v){\n\t\tthis->v = v;\n\t}\n\n\tvector<Board> transition(){\n\t\tvector<Board> ret;\n\n\t\tvint dx{1, 0, -1, 0};\n\t\tvint dy{0, 1, 0, -1};\n\n\t\tint x0 = 0, y0 = 0;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tif(v[y][x] == 0) {x0 = x; y0 = y;}\n\t\t}\n\n\t\trep(d, 4){\n\t\t\tint xn = x0 + dx[d];\n\t\t\tint yn = y0 + dy[d];\n\t\t\tif(xn >= 0 && xn < 3 && yn >= 0 && yn < 3){\n\t\t\t\tvector<vint> vv = v;\n\t\t\t\tvv[yn][xn] = v[y0][x0];\n\t\t\t\tvv[y0][x0] = v[yn][xn];\n\t\t\t\tret.push_back(Board(vv));\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tll hash() const{\n\t\tll ret = 0;\n\t\tll m = 1;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tret += v[y][x] * m;\n\t\t\tm *= 10;\n\t\t}\n        return ret;\n\t}\n\n\tbool operator < (const Board &p) const {\n        ll h1 = hash();\n        ll h2 = p.hash();\n\t\treturn h1 < h2;\n\t}\n\n\tbool operator == (const Board &p) const{\n        ll h1 = hash();\n        ll h2 = p.hash();\n        return h1 == h2;\n\t}\n};\n\nint main() {\n\tvector<vint> v0;\n\trep(y, 3){\n\t\tvint v;\n\t\trep(x, 3) { int n; cin >> n; v.push_back(n);}\n\t\tv0.push_back(v);\n\t}\n\tBoard b0 = Board(v0);\n\n\tvector<vint> ve;\n\tvint ve1{1, 2, 3}; ve.push_back(ve1);\n\tvint ve2{4, 5, 6}; ve.push_back(ve2);\n\tvint ve3{7, 8, 0}; ve.push_back(ve3);\n\tBoard be = Board(ve);\n\n\tset<Board> S;\n\tqueue<pair<Board, int>> q;\n\n\tq.push(make_pair(b0, 0));\n    // fprintf(stderr, \"%09lld\\n\", b0.hash());\n    // fprintf(stderr, \"%09lld\\n\", be.hash());\n\n\twhile(true){\n\t\tauto p = q.front(); q.pop();\n\t\tBoard b = p.first;\n\t\tint t = p.second;\n\n        S.find(b);\n        S.end();\n\t\tif(S.find(b) != S.end()) continue;\n        S.insert(b);\n        // fprintf(stderr, \"%09lld %d\\n\", b.hash(), t);\n\n\t\tif(b == be) {cout << t << endl; return 0;}\n\n\t\tvector<Board> trans = b.transition();\n\t\tfor(Board bb: trans){\n\t\t\tq.push(make_pair(bb, t+1));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0;i<N2;i++){\n      if(f[i] == p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int  i = 0; i < N2; i++)\n    if(p.f[i] != (i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path  = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r = 0; r <4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0||ty<0||tx>=N||ty >= N)continue;\n      v =u;\n      swap(v.f[u.space],v.f[tx * N +ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i =0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p)const{\nfor(int i=0;i<N2;i++){\nif(f[i]==p.f[i])continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1))return false;\nreturn true;\n}\n\nstring bfs(Puzzle s){\nqueue<Puzzle>Q;\nmap<Puzzle,bool>V;\nPuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\nwhile(!Q.empty()){\n  u=Q.front();\n  Q.pop();\n  if(isTarget(u))return u.path;\n  int sx=u.space/N;\n  int sy=u.space%N;\n  for(int r=0 ; r<4 ; r++){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n    v=u;\n    swap(v.f[u.space], v.f[tx*N+ty]);\n    v.space=tx*N+ty;\n    if(!V[v]){\n      V[v]=true;\n      v.path+=dir[r];\n      Q.push(v);\n    }\n  }\n}\n\nreturn \"unsolvable\";\n\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0 ; i<N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n    in.f[i]=N2;\n    in.space=i;\n    }\n  }\n  \n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tif (P[i] == 0) continue;\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] - 1) / DIVN - i / DIVN);\n\t}\n\treturn -result-Puzzles[x];\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nconstexpr int NX = 3, NY = 3;\nconstexpr int SIZE = NX*NY;\n\nusing namespace std;\n\ntypedef pair< int, vector<int> > PuzzleState;\n\nset< vector<int> > visited;\n\nbool IsSolved( const vector<int>& s ) {\n    int cnt = s[SIZE-1] == 0 ? 1 : 0;\n    for ( int i=0; i<SIZE; ++i ) {\n\tif ( s[i] == i+1 ) ++cnt;\n    }\n    return cnt == SIZE;\n}\n\nbool IsVisited( const vector<int>& s ) {\n    return visited.find( s ) != visited.end();\n}\n\nint Solve( const vector<int>& init_s ) {\n\n    const int dx[4] = { -1,  0, 1, 0 };\n    const int dy[4] = {  0, -1, 0, 1 };\n\n    queue< PuzzleState > state;\n    state.push( make_pair(0, init_s) );\n    visited.insert( init_s );\n\n    while ( !state.empty() ) {\n\n\tPuzzleState curr = state.front();\n\n\tif ( IsSolved( curr.second ) ) return curr.first;\n\tstate.pop();\n\t\n\tint x, y;\n\tfor ( int i=0; i<SIZE; ++i ) {\n\t    if ( curr.second[i] == 0 ) {\n\t\tx = i%NX;\n\t\ty = i/NY;\n\t\tbreak;\n\t    }\n\t}\n\n\tfor ( int i=0; i<4; ++i ) {\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\t    if ( nx >= 0 && nx < NX && ny >= 0 && ny < NY ) {\n\n\t\tswap( curr.second[NX*y+x], curr.second[NX*ny+nx] );\n\t\tcurr.first += 1;\n\t\t\n\t\tif ( !IsVisited( curr.second ) ) {\n\t\t    state.push( curr );\n\t\t    visited.insert( curr.second );\n\t\t}\n\t\t\n\t\tcurr.first -= 1;\n\t\tswap( curr.second[NX*y+x], curr.second[NX*ny+nx] );\n\t    }\n\t}\n    }\n    return 1000000;\n}\n\nint main() {\n\n    vector<int> s(SIZE);\n    for ( int i=0; i<SIZE; ++i ) cin >> s[i];\n\n    cout << Solve( s ) << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), i##_max = (b); i < i##_max; ++i)\n#define RFOR(i, a, b) for (int i = (b)-1, i##_min = (a); i >= i##_min; --i)\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define RREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define ALL(obj) (obj).begin(), (obj).end()\n\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n\nusing namespace std;\nusing i64 = int64_t;\nusing u64 = uint64_t;\nusing vb = vector<bool>;\nusing vi = vector<int>;\nusing vl = vector<i64>;\nusing vd = vector<double>;\nusing pi = pair<int, int>;\nusing pl = pair<i64, i64>;\nusing pd = pair<double, double>;\n\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1000000007;\n\ntemplate <typename T>\ninline void chmin(T &a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\ninline void chmax(T &a, T b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid print(T &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) cout << \" \";\n    cout << *it;\n  }\n  cout << endl;\n}\n\nconstexpr int N = 3;\nconstexpr int N2 = N * N;\nconstexpr array<int, 4> dx{-1, 0, 1, 0}, dy{0, -1, 0, 1};\nconstexpr array<char, 4> dir{'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n  std::array<int, N2> f;\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const {\n    REP(i, N2) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nbool is_target(Puzzle &p) {\n  REP(i, N2) {\n    if (p.f[i] != i + 1) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle &s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    auto u = Q.front();\n    Q.pop();\n    if (is_target(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    REP(r, 4) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      auto v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n}\n\nint main() {\n  Puzzle in;\n  REP(i, N2) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  auto ans = bfs(in);\n  cout << ans.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n    if(p.f[i] != (i + 1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int i = 0; i < 4; i++){\n      int tx = sx + dx[i];\n      int ty = sy + dy[i];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[i];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator = (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] != p.f[i]) return false;\n        }\n\n        return true;\n    }\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle start) {\n    map<Puzzle, bool> m;\n    m[start] = true;\n    queue<Puzzle> Q;\n    Q.push(start);\n\n    while (!Q.empty()) {\n        Puzzle x = Q.front();\n        Q.pop();\n        if (isTarget(x)) {\n            return x.path;\n        }\n        int spaceX = x.space / N;\n        int spaceY = x.space % N;\n        for (int i = 0; i < 4; i++) {\n            int nextX = spaceX + dx[i];\n            int nextY = spaceY + dy[i];\n            if (nextX < 0 || nextX >= N || nextY < 0 || nextY >= N) {\n                continue;\n            }\n\n            Puzzle nextP = x;\n            nextP.space = nextX * N + nextY;\n            nextP.path += dir[i];\n            swap(nextP.f[x.space], nextP.f[nextX * N + nextY]);\n            if (!m[nextP]) {\n                m[nextP] = true;\n                Q.push(nextP);\n            }\n        }\n    }\n\n    return \"\";\n}\n\nint main() {\n    Puzzle p;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> p.f[N * i + j];\n            if (p.f[N * i + j] == 0) {\n                p.f[N * i + j] = N2;\n                p.space = N * i + j;\n            }\n        }\n    }\n    p.path = \"\";\n\n    string ans = bfs(p);\n\n    cout << ans.length() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H=3,W=3;\nset<vector<vector<short>>> memo;\n\nstruct STATE {\n    int f;\n    int g;\n    vector<vector<short>> b;\n\n    bool operator < (const STATE& tgt) const {\n\treturn f > tgt.f; // ?Â¨????\n    }\n};\ninline bool is_searched(const STATE& s) {\n    return (memo.find(s.b) != memo.end());\n}\ninline void searched(const STATE& s) {\n    memo.insert(s.b);\n}\ninline bool is_goal(const STATE& s) {\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    if( i == H-1 and j == W-1 )  return true;\n\t    if( s.b[i][j] != (i*W)+j+1 ) return false;\n\t}\n    }\n}\n\ninline void where0(const STATE& s, int& h, int& w) {\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    if( s.b[i][j] == 0 ) {\n\t\th = i;\n\t\tw = j;\n\t    }\n}\n\ninline int manhattan_dis(const int tgt, const int h, const int w) {\n    if(tgt == 0 ) return 0;\n    int tgt_h = (tgt-1)/W;\n    int tgt_w = (tgt-1)%W;\n    return abs(tgt_h - h) + abs(tgt_w - w);\n}\n\ninline int heuristic(const vector<vector<short>>& b) {\n    int ans = 0;\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    ans += manhattan_dis(b[i][j],i,j);\n\t}\n    }\n    return ans;\n}\n\nconst int dx[] = { 1, 0,-1, 0}; \nconst int dy[] = { 0, 1, 0,-1};\ninline vector<STATE> adjcency(const STATE& cur) {\n    int h,w;   where0(cur,h,w);\n    vector<STATE> ans;\n    vector<vector<short>> b = cur.b;\n    \n    for(int i=0; i<4; i++) { // 4??????\n\tint nh = h+dy[i], nw = w+dx[i];\n\tif( nh >= 0 and nh < H and nw >= 0 and nw < W ) {\n\t    swap(b[nh][nw], b[h][w]);\n\t    int heu = heuristic(b);\n\t    if( cur.g+1+heu <= 24 )\n\t\tans.push_back( STATE{cur.g+1+heu, cur.g+1, b} );\n\t    swap(b[nh][nw], b[h][w]);\n\t}\n    }\n    return ans;\n}\n    \nSTATE astar(const STATE& init) {\n    \n    priority_queue<STATE> pq;              // ?????????????Â°?????????????????????????????????????\n    pq.push(init);                         // ????????? STATE ????????Â£??????\n    \n    while( pq.size() ) {                   // ?????\\???????????????????????Â§????????Â§???\n\tSTATE cur = pq.top(); pq.pop();    // ?????Â£??Â¨????????????????????Â¶??????????????Â§???\n\tif( is_searched(cur) ) continue;   // ??????????????Â¢?Â´Â¢????????Â§...\n\tif( is_goal(cur) ) return cur;     // ??Â´??????????????Â´????????????\n\n\tsearched(cur);                     // cur ?????Â¢?Â´Â¢???????????Â¨????????????????????????\n\t\n\tfor(STATE& next : adjcency(cur)) { // ?????????????????Â¨?????????????????Â§???\n\t    if( is_searched(next) ) continue;\n\t    pq.push(next);\n\t}\n    }\n    // ???????????\\?????Â£??????????????Â¨??????...????????????????????Â£?????Â£????????Â¨???...\n    return init;\n}\n\nint main() {\n\n//    cin >> H >> W;\n    vector<vector<short>> b(H,vector<short>(W));\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) cin >> b[i][j];\n\n    int h = heuristic(b);\n    STATE init{h,0,b};\n    \n    STATE lst = astar(init);\n    cout << lst.g << endl;\n\n//    cout << memo.size() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ã§ãã­ãï¼\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"è¡ç®ã ãã¼ããã»ã»\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" âãªãã ãã¼ãã®æ°å­ï¼\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nvvi pz0(3,vi(3,0));\nint ans=32;\nmap <vvi,int> tf;\n\nint find0(vvi pz){\n\n  REP(i,3) REP(j,3) if(pz[i][j]==0) return i*3+j;\n\n}\n\nvoid print(vvi pz){\n\n  REP(i,3){\n    REP(j,3){\n      if(j) cout<<\" \";\n      cout<<pz[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\nvoid bfs(vvi pz){\n\n  queue <pair<vvi,int>> pzq;\n  pzq.push(mp(pz,0));\n\n  for(;!pzq.empty();){\n\n    vvi now=pzq.front().fi;\n    int how=pzq.front().se;\n    pzq.pop();\n\n    if(how>31) continue;\n\n    if(tf[now]) continue;\n    tf[now]=1;\n\n    if(now==pz0){\n\n      ans=how;\n      return;\n\n    }\n\n    int x=find0(now)%3;\n    int y=find0(now)/3;\n\n    REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(now[y][x],now[y0][x0]);\n    pzq.push(mp(now,how+1));\n    swap(now[y][x],now[y0][x0]);\n\n    }\n\n  }\n\n}\n\nvoid dfs(vvi pz,int how){\n\n  if(tf[pz]) return;\n  tf[pz]=1;\n\n  if(how>31) return;\n  if(pz0==pz){\n\n    ans=min(ans,how);\n    return;\n\n  }\n\n  int x=find0(pz)%3;\n  int y=find0(pz)/3;\n\n  REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(pz[y][x],pz[y0][x0]);\n    dfs(pz,how+1);\n    swap(pz[y][x],pz[y0][x0]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  vvi pz(3,vi(3,0));\n\n  REP(i,9) pz0[i/3][i%3]=(i+1)%9;\n  REP(i,9) cin>>pz[i/3][i%3];\n\n  bfs(pz);\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nint d_x[4] = { -1,0,1,0 };\nint d_y[4] = { 0,1,0,-1 };\n\nint t[3][3];\nint level=0;\n\nint countpath() {\n\tint ret=0;\n\tint tmp;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (t[i][j] != 0) {\n\t\t\t\ttmp = t[i][j] - 1;\n\t\t\t\tret += abs(tmp / 3 - i) + abs(tmp % 3 - j);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool check(int depth, int pre, int px, int py) {\n\tint w = countpath();\n\tif (w + depth > level) return false;\n\tif (w == 0)return true;\n\tint dx, dy;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) != 2) {\n\t\t\tdx = px + d_x[i];\n\t\t\tdy = py + d_y[i];\n\t\t\tif (dx < 0 || dx == 3 || dy < 0 || dy == 3) continue;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t\tif (check(depth + 1, i, dx, dy)) return true;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t}\n\t\t\n\t}\n\treturn false;\n}\n\nvoid solution(int px, int py) {\n\tfor (level = 0;; level++) {\n\t\tif (check(0, 9, px, py)) {\n\t\t\tcout << level << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tint px, py;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> t[i][j];\n\t\t\tif (t[i][j] == 0) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution(px,py);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n \nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n \nint t[3][3];\nint limit;\n \nint getHeuri(){\n  int res=0,a;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(t[i][j]==0)continue;\n      a=t[i][j]-1;\n      res+=abs(a/3-i)+abs(a%3-j);\n    }\n  }\n  return res;\n}\n \nbool check(int depth,int prev,int py,int px){\n  int heuri=getHeuri();\n  if(heuri+depth>limit)return false;\n  if(heuri==0)return true;\n  for(int i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int ny=py+dy[i],nx=px+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=3||nx>=3)continue;\n    swap(t[ny][nx],t[py][px]);\n    if(check(depth+1,i,ny,nx)) return true;\n    swap(t[ny][nx],t[py][px]);\n  }\n  return false;\n}\n \nvoid solve(int py,int px){\n  for(limit=0;;limit++){\n    if(check(0,99,py,px)){\n      cout<<limit<<endl;\n      return;\n    }\n  }\n}\n \nint main(){\n  int py,px;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      cin>>t[i][j];\n      if(t[i][j]==0){\n    py=i;\n    px=j;\n      }\n    }\n  }\n  solve(py,px);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[10000008];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>26) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include<algorithm>\nusing namespace std;\n\nint d_x[4] = { -1,0,1,0 };\nint d_y[4] = { 0,1,0,-1 };\n\nint t[3][3];\nint px, py, level=0;\n\nint countpath() {\n\tint ret=0;\n\tint tmp;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (t[i][j] != 0) {\n\t\t\t\ttmp = t[i][j] - 1;\n\t\t\t\tret += abs(tmp / 3 - i) + abs(tmp % 3 - j);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool check(int depth, int pre) {\n\tint w = countpath();\n\tif (w + depth > level) return false;\n\tif (w == 0)return true;\n\tint dx, dy;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) != 2) {\n\t\t\tdx = px + d_x[i];\n\t\t\tdy = py + d_y[i];\n\t\t\tif (dx < 0 || dx == 3 || dy < 0 || dy == 3) continue;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t\tif (check(depth + 1, i)) return true;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t}\n\n\t}\nreturn false;\n}\n\nvoid solution() {\n\tfor (level = 0;; level++) {\n\t\tif (check(0, 9)) {\n\t\t\tcout << level << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> t[i][j];\n\t\t\tif (t[i][j] == 0) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs(((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN)) - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 10){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n\nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"unsolvable\";\n}\n\nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint mins = LIM;\nstruct dep h[HN];\n\nint hash1(int k){\n    return k%HN;\n}\nint hash2(int k){\n  return 1+k%(HN-1);\n}\nint hashs(int k, int i){\n  return (hash1(k)+i*hash2(k))%HN;\n}\n\n\nvoid dfs(int X[N][N], int n){\n  int i,j,in,jn,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=X[i][j])f++;\n      if(X[i][j]==0){\n        in=i;\n        jn=j;\n      }\n      a+=X[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0){\n    if(mins>=n)mins=n;\n    return;\n  }\n  if(n>mins)return;\n  i=0;\n  while(1){\n    b=hashs(a, i);\n    if(h[b].key == 0){\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }else if(h[b].key == a){\n      if(h[b].depth>n){\n        h[b].depth=n;\n        break;\n      }else return;\n    }\n    i++;\n  }\n\n  if(in>0 && in<N){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in-1][jn]);\n    dfs(tmp, n+1);\n  }\n  if(jn>0 && jn<N){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in][jn-1]);\n    dfs(tmp, n+1);\n  }\n\n  if(in>=0 && in<N-1){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in+1][jn]);\n    dfs(tmp, n+1);\n  }\n  if(jn>=0 && jn<N-1){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in][jn+1]);\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main(){\n  int i,j;\n  int X[N][N]={};\n  for(i=0;i<N;i++)for(j=0;j<N;j++)cin>>X[i][j];\n  dfs(X,0);\n  cout<<mins<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define INF 9223372036854775807\n#define NN 9\n#define N 3\n\ntypedef struct Pazzle\n{\n    int frame[N][N];\n    int space[2];\n    int level;\n\n    bool operator<(const Pazzle &p) const\n    {\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (frame[i][j] == p.frame[i][j])\n                    continue;\n                return frame[i][j] > p.frame[i][j];\n            }\n        }\n        return false;\n    };\n} Pazzle;\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nbool equal(Pazzle a, Pazzle b)\n{\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (a.frame[i][j] != b.frame[i][j])\n                return false;\n    return true;\n}\n\nint solve(Pazzle start)\n{\n    Pazzle goal;\n    queue<Pazzle> q;\n    map<Pazzle, bool> V;\n\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            goal.frame[i][j] = (j + i * 3 + 1) % 9;\n    goal.space[0] = 2;\n    goal.space[1] = 2;\n\n    if (equal(start, goal))\n        return 0;\n    V[start] = true;\n    q.push(start);\n\n    while (1)\n    {\n        Pazzle u = q.front();\n        q.pop();\n\n        for (int i = 0; i < 4; i++)\n        {\n            Pazzle v = u;\n            int x = v.space[0] + dx[i];\n            int y = v.space[1] + dy[i];\n\n            if (x >= 0 && x < N && y >= 0 && y < N)\n            {\n                swap(v.frame[v.space[1]][v.space[0]], v.frame[y][x]);\n                v.space[1] = y;\n                v.space[0] = x;\n                v.level = u.level + 1;\n                if (equal(v, goal))\n                    return v.level;\n                if (!V[v])\n                {\n                    V[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    Pazzle start;\n    start.level = 0;\n\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            int n;\n            cin >> n;\n            if (n == 0)\n            {\n                start.space[0] = j;\n                start.space[1] = i;\n            }\n            start.frame[i][j] = n;\n        }\n    }\n\n    cout << solve(start) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> > Q;\n\nvoid Sw(string st,int x)\n{\n\tint i;\n\tint pos,npos;\n\tint d[4]={-3,3,-1,1};\n\tstring st1;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tif(st[i]=='0')\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=0;i<=3;i++)\n\t{\n\t\tst1=st;\n\t\tif(i==2 && pos%3==0) continue;\n\t\tif(i==3 && pos%3==2) continue;\n\t\tnpos=pos+d[i];\n\t\tif(npos>=9 || npos<=-1) continue;\n\t\tswap(st1[pos],st1[npos]);\n\t\tQ.push(pair<string,int>(st1,x+1));\n\t}\n}\n\nint main()\n{\n\tstring puzzle=\"\";\n\tstring goal=\"123456780\";\n\tmap<string,bool> M;\n\tint i,x;\n\tstring P;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tcin >> x;\n\t\tpuzzle+='0'+x;\n\t}\n\tQ.push(pair<string,int>(puzzle,0));\n\twhile(1)\n\t{\n\t\tpair<string,int> p=Q.front();\n\t\tQ.pop();\n\t\tP=p.first;\n\t\tx=p.second;\n\t\tif(P==goal)\n\t\t{\n\t\t\tcout << x << endl;\n\t\t\tbreak;\n\t\t}\n\t\tif(M[P]) continue;\n\t\telse M[P]=1;\n\t\tSw(P,x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2], space;\n\tstring path;\n\tbool operator<(const Puzzle& a) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == a.f[i]) continue;\n\t\t\treturn f[i] > a.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint dx[] = { -1,0,0,1 }, dy[] = { 0,-1,1,0 };\nchar dir[] = { 'u','l','r','d' };\n\nbool ok(Puzzle& p) {\n\tfor (int i = 0; i < N2; ++i)\n\t\tif (p.f[i] != i + 1) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tu = q.front(); q.pop();\n\t\tif (ok(u)) return u.path;\n\t\tint sx = u.space / N, sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r], ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const{\n    for (int i = 0; i < N2; i++){\n      if (f[i] == p.f[i])\n        continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for (int i = 0; i < N2; i++){\n    if (p.f[i] != (i + 1)){\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()){\n      u = Q.front();\n      Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for (int i=0; i < N2; i++){\n        cin >> in.f[i];\n        if (in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) {\n                swap(tmp[p], tmp[q]);\n                wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n            } else {\n                swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n            }\n\n            if (wrong_place == 0) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 + wrong_place > boundary) continue; // estimate value is over boundary\n            find = h1_dfs(boundary, State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break; // find an answer\n        }\n    }\n\n    return find;\n}\n\nint ids_h1(string state, int wrong_place, P blank) {\n    int i = wrong_place, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h1_dfs(i, State{0, wrong_place, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h1(state, wrong_place, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans;\n\n\twhile (!que.empty())\n\t{\n\t\tpuzzle p = que.front(); que.pop();\n\n\t\tint x, y;\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tif (p.board[i][j] == 0) \n\t\t\t\t{ \n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t{\n\t\t\t\tpuzzle q = p;\n\n\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\tbool found = true;\n\n\t\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\t\tif (p.board[i / 3][i % 3] != i + 1) { found = false; }\n\n\t\t\t\tif (found == true)\n\t\t\t\t{\n\t\t\t\t\tAns = p.distance; goto Exit;\n\t\t\t\t}\n\n\t\t\t\tque.push(q);\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n#define true 1\n#define false 0\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint getHeuristic(){\n  int i,j,sum=0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(t[i][j]==0)continue;\n    x=t[i][j]-1;\n    sum+=abs(x/N-i)+abs(x%N-j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int py,int px){\n  int h=getHeuristic();\n  if(h==0)return true;\n  if(depth+h>limit)return false;\n  int i;\n  for(i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int tx=px+dx[i],ty=py+dy[i];\n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    swap(&t[ty][tx],&t[py][px]);\n    if(dfs(depth+1,i,ty,tx))return true;\n    swap(&t[ty][tx],&t[py][px]);\n  }\n  return false;\n}\n\nvoid isSolved(int py,int px){\n  for(limit=0;;limit++){\n    if(dfs(0,99,py,px)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,px,py;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        py=i;\n        px=j;\n      }\n    }\n  }\n  isSolved(py,px);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\n#define MIN (1e-10)\n#define equal(a,b) (abs((a)-(b))<MIN)\n#define v2 ten\n#define chokusen senbun\n#define tenten senbun\n#define takaku vec<ten>\nusing namespace std;\nvoid solve();\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed;\n\tsolve();\n}\nstruct pea{\n\tll f,s;\n\tbool operator<(const pea &p)const{\n\t\treturn f!=p.f?f<p.f:s<p.s;\n\t};\n};\nstruct tri{\n\tll f,s,t;\n\tbool operator<(const tri &p)const{\n\t\tif(f!=p.f)return f<p.f;\n\t\tif(s!=p.s)return s<p.s;\n\t\treturn t<p.t;\n\t};\n};\nclass ten{\npublic:\n\tld x,y;\n\tten operator+(ten p){return{x+p.x,y+p.y};}\n\tten operator-(ten p){return{x-p.x,y-p.y};}\n\tten operator*(ld k){return{k*x,k*y};}\n\tten operator/(ld k){return{x/k,y/k};}\n\tld abs(){return sqrt(abs2());}\n\tld abs2(){return x*x+y*y;};\n\tbool operator<(const ten &p)const{return x!=p.x?x<p.x:y<p.y;};\n\tbool operator==(const ten &p)const{return (-MIN<x-p.x)&&(x-p.x<MIN)&&(-MIN<y-p.y)&&(y-p.y<MIN);};\n\tld naiseki(v2 b){return x*b.x+y*b.y;}\n\tld gaiseki(v2 b){return x*b.y-y*b.x;}\n};\nstruct senbun{ten p1,p2;};\nstruct en{ten o;ld r;};\n//å¹åªåæ¢ç´¢(8ããºã«)\nll bfs(vll hajime){\n\tstruct pazzle{vll id;ll depth;};\n\tvll goal={1,2,3,4,5,6,7,8,0};\n\tmap<vll,bool> hantei;\n\tdeque<pazzle> p;\n\tp.pub({hajime,0});\n\twhile(!p.empty()){\n\t\tif(p[0].id==goal)return p[0].depth;\n\t\tll pos=find(ALL(p[0].id),0)-p[0].id.begin();\n\t\tif(pos%3!=2){\n\t\t\tswap(p[0].id[pos],p[0].id[pos+1]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos+1]);\n\t\t}\n\t\tif(pos%3!=0){\n\t\t\tswap(p[0].id[pos],p[0].id[pos-1]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos-1]);\n\t\t}\n\t\tif(pos>=3){\n\t\t\tswap(p[0].id[pos],p[0].id[pos-3]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos-3]);\n\t\t}\n\t\tif(pos<=5){\n\t\t\tswap(p[0].id[pos],p[0].id[pos+3]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos+3]);\n\t\t}\n\t\tp.pof();\n\t}\n}\nvoid solve(){\n\tvll a(9);\n\trep(i,0,9)cin>>a[i];\n\tcout<<bfs(a)<<kai;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n#define H 3\n#define W 3\n#define begin 1\n#define end 4\nstruct BOARD{\n        int board[10][10],y,x,count;\n        bool operator<(const BOARD &other)const{\n                for(int i=begin ; i<end ; i++ )\n                        for(int j=begin ; j<end ; j++ ){\n                                if(board[i][j]==other.board[i][j])\n                                        continue;\n                                return board[i][j]>other.board[i][j];\n                        }\n                return false;\n        }\n};\nmap <BOARD,bool> past;\nint direction[5]={-1,0,1,0,-1};\nbool check(BOARD now){\n        int s=1;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        if(now.board[i][j]==s){\n                                s++;\n                                s%=9;\n                        }else return false;\n                }\n        }\n}\nint main(){\n        BOARD board;\n        board.count=0;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        cin >> board.board[i][j] ;\n                        if(board.board[i][j]==0){\n                                board.y=i;\n                                board.x=j;\n                        }\n                }\n        }\n        queue<BOARD> circle;\n        circle.push(board);\n        int count=0;\n        while(circle.size()!=0){\n                board=circle.front();circle.pop();\n                if(board.y<1 || board.y>=4 )continue;\n                if(board.x<1 || board.x>=4 )continue;\n                past[board]=true;\n                if(check(board)){\n                        cout << board.count << endl;\n                        break;\n                }\n                for(int i=0 ; i<4 ; i++ ){\n                        int y=board.y+direction[i];\n                        int x=board.x+direction[i+1];\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                        board.count++;\n                        circle.push(board);\n                        board.count--;\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include  <cassert>\n#include <fstream>\n#include <codecvt>\n\nusing namespace std;\nusing ll = long long int;\nusing ullong = unsigned long long;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define int ll\nconst int INF = (1LL << 32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\n\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle& p) const {\n\t\trep(i, N2) {\n\t\t\tif (p.f[i] == f[i]) continue;\n\t\t\treturn f[i] > p.f [i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const char dir[4] = { 'u','l','d','r' };\n\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++) \n\t\tif (p.f[i] != i+1) return false;\n\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\n\tstring path = \"\";\n\tqueue<Puzzle> Q;\n\tQ.push(s);\n\tmap<Puzzle, bool> V; \n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tauto p = Q.front();\n\t\tQ.pop();\n\n\t\tif (isTarget(p)) return p.path;\n\t\t\n\t\tint sx = p.space / N;\n\t\tint sy = p.space % N;\n\n\t\trep(r, 4) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 or ty < 0 or tx >= N or ty >= N) continue;\n\t\t\tauto v = p;\n\t\t\tswap(v.f[p.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (V[v] == false) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(true);\n\n\tPuzzle in;\n\n\trep(i, N2) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.space = i;\n\t\t\tin.f[i] = N2;\n\t\t}\n\t}\n\n\tcout << bfs(in).size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\n-- import Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3\nmaxAdr = size*size -1\n\nsolver :: [[Int]] -> Int\nsolver lst = bfs start goalID where\n    bfs start goalID = iter ((Seq.singleton (start, generateID start, 0)), M.empty) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(b, bId, d)\n                | bId == goalID -> d\n                | otherwise -> iter (insertPaths que visited (nextPaths path)) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(_,x,_):ps) = insertPaths (p Seq.<| q) (M.insert x () visited) ps\n                    nextPaths path@(b, bId, d) = [(x, xId, d+1)| (x, xId) <- nextBoards, notVisited xId] where        \n                        notVisited x = M.notMember x visited\n                        boards = [swapAt (b !! q) b | q <- dest!p]\n                        nextBoards = [(x, generateID x)| x <- boards]\n                        p = fromJust $ elemIndex 0 b\n    goalID= 123456780\n    start = concat lst\n    dest  = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]] \n    generateID board = foldl' (\\b a-> 10*b+a) 0 board\n\nswapAt v = iter where\n    iter [] = []\n    iter (x:xs)\n        | x == 0 = v:iter xs\n        | x == v = 0:iter xs\n        | otherwise = x:iter xs\n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3 \nsqSize = size*size\nmaxAdr = sqSize -1\nmask = 0xF\nshiftSize = 4\nshiftTimes= 16\n\nsolver :: [[Int]] -> Int\nsolver lst\n    | start == goal = 0\n    | otherwise = iter (initialQueue, initialVisited) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(board, distance, forward) -> case next path visited of\n                (_, Just d)  -> distance + d +1\n                (nextPaths, Nothing) -> iter (insertPaths que visited nextPaths) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(x, d, f):ps) = insertPaths insertQue insertVisited ps where\n                        insertQue = p Seq.<| q\n                        insertVisited = M.insert x (d, f) v\n        next path@(board, distance, forward) visited = iter [] Nothing nextBoards where\n            iter ac af [] = (ac, af)\n            iter ac af (x:xs) = case M.lookup x visited of\n                Nothing -> iter ((x, distance+1, forward):ac) af xs\n                Just (d', f') -> if forward == f' then iter ac af xs else (ac, Just d')\n            boards = [swapWith (valueAt p board) board | p <- dest!(searchZero board)]\n            nextBoards = [x| x <- boards]\n\n        initialQueue = (goal, 0, False) Seq.<| (Seq.singleton (start, 0, True))\n        initialVisited = M.insert goal (0, False) $ M.singleton start (0, True)\n        goal    = toBits [1,2,3,4,5,6,7,8,0]\n        start   = toBits $ concat lst\n        dest    = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n        toBits = foldl' (\\b a-> shiftL b shiftSize .|. a) 0\n        valueAt i w = mask .&. shiftR w (shiftSize*i)\n\nsearchZero :: Int -> Int\nsearchZero = iter 0 where\n    iter c w = case mask .&. w of \n        hb  | hb == 0 -> c\n            | otherwise -> iter (c+1) (rotateR w shiftSize)\n\nswapWith :: Int -> Int -> Int\nswapWith v = iter sqSize where\n    iter 0 w = rotateR w (shiftSize*(shiftTimes-sqSize))\n    iter c w = iter (c-1) $ rotateR (case mask .&. w of\n        hb  | hb == 0 -> w .|. v\n            | hb == v -> w `xor` v\n            | otherwise -> w) shiftSize\n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Arrow\nimport Data.Array.Unboxed as U\nimport Data.List\nimport Data.Maybe (fromJust)\nimport Control.Monad\n\nsize = 3 :: Int\n\ntype Field = U.UArray Loc Int\ntype Loc = (Int,Int)\n\ndata Dir = Up | Rt | Dw | Lf deriving (Show, Enum, Eq)\ntoVect :: Dir -> (Int,Int)\ntoVect Up = (-1,0)\ntoVect Rt = (0,1)\ntoVect Dw = (1,0)\ntoVect Lf = (0,-1)\n\ndata Puzzle = Puzzle {\n            _field :: Field,\n            _zloc :: Loc\n}\n\nfromList :: [Int] -> Puzzle\nfromList xs = let\n    f = listArray ((0,0),(size-1,size-1)) xs\n    in\n        Puzzle {\n               _field = f,\n               _zloc = (`divMod` size) .  head  $ 0 `elemIndices` xs\n               }\n\n\ninstance Show Puzzle where\n    show = showTable . _field\n\nshowTable :: Field -> String\nshowTable = unlines . map (tail . concatMap ('|':)) . cutEvery size\n    . map show . elems\n\ncutEvery :: Int -> [a] -> [[a]]\ncutEvery _ [] = []\ncutEvery n xs = let (pre,post) = splitAt n xs\n                    in pre : cutEvery n post\n\nmovableDirs :: Puzzle -> [Dir]\nmovableDirs p = let\n    (y,x) = _zloc p\n    in\n        filter (\n               case x of\n                   0 -> (/= Lf)\n                   2 -> (/= Rt)\n                   _ -> const True\n              )\n        . filter (\n                 case y of\n                    0 -> (/= Up)\n                    2 -> (/= Dw)\n                    _ -> const True\n                ) $ enumFrom Up\n\nmove :: Puzzle -> Dir -> Puzzle\nmove p d = let\n    next = toVect d `tupAdd` _zloc p\n    nexp = _field p // [(next,0), (_zloc p, _field p ! next)]\n    in\n        p {\n          _field = nexp,\n          _zloc = next\n        }\n\ntupAdd :: (Num a, Num b) => (a,b) -> (a,b) -> (a,b)\ntupAdd (x,y) = (+x) *** (+y)\n\nnextPossibles :: Puzzle -> [Puzzle]\nnextPossibles p = map (move p) (movableDirs p)\n\nisComplete :: Puzzle -> Bool\nisComplete = (== [1,2,3,4,5,6,7,8,0]) . elems . _field\n\ndata Phase = Phase {_puz :: Puzzle, _actualCost :: Int}\ninstance Show Phase where\n    show p = unlines [\"Phase :\", show (_puz p), \"cost\" ++ show (_actualCost p)]\nnextPhases :: Phase -> [Phase]\nnextPhases ph = let\n    p = _puz ph\n    c = _actualCost ph in\n        map (\\pz -> Phase pz (c+1)) . nextPossibles $ p\n\nmanHattan :: Puzzle -> Int\nmanHattan = sum . map (\\((x0,y0),e) -> let (x1,y1) = (e-1) `divMod` 3\n                                   in\n                                      abs (x1-x0) + abs (y1-y0))\n                                      . filter ((/=0) . snd) . assocs . _field\n\ntype Estimator = Puzzle -> Int\n\n\nidaStar :: Estimator -> Puzzle -> Maybe (Phase, Int)\nidaStar f p = let\n    iter :: Int -> Int -> [Phase] -> Maybe (Phase,Int)\n    iter steps depth [] = iter steps (depth+1) [Phase p 0]\n    iter steps depth ss =\n        case find (isComplete . _puz) next of\n            Just pu -> Just (pu,steps)\n            Nothing -> iter (steps+1) depth next\n        where\n            next = filter ((<= depth) . cost f) . concatMap nextPhases $ ss\n    in\n        iter 0 1 [Phase p 0]\n\ncost :: Estimator -> Phase -> Int\ncost f p = _actualCost p + f (_puz p)\n\nmain = replicateM 3 getLine >>=\n        print . _actualCost . fst . fromJust . idaStar manHattan . fromList\n            . map read . words . unlines"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\n-- import Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3\nmaxAdr = size*size -1\n\nsolver :: [[Int]] -> Int\nsolver lst = bfs start goalID where\n    bfs start goalID = iter ((Seq.singleton (start, generateID start, 0)), M.empty) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(b, bId, d)\n                | bId == goalID -> d\n                | otherwise -> iter (insertPaths que visited (nextPaths path)) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(_,x,_):ps) = insertPaths (p Seq.<| q) (M.insert x () visited) ps\n                    nextPaths path@(b, bId, d) = [(x, xId, d+1)| (x, xId) <- nextBoards, notVisited xId] where        \n                        notVisited x = M.notMember x visited\n                        boards = [swapAt (b !! q) b | q <- dest!p]\n                        nextBoards = [(x, generateID x)| x <- boards]\n                        p = fromJust $ elemIndex 0 b\n    goalID= generateID [1,2,3,4,5,6,7,8,0]\n    start = concat lst\n    dest  = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]] \n    generateID board = foldl' (\\b a-> shiftL b 4 .|. a) 0 board\n\nswapAt :: Int -> [Int] -> [Int]\nswapAt v = foldr (\\a b -> case a of\n    _   | a == 0 -> v:b\n        | a == v -> 0:b\n        | otherwise -> a:b\n     ) [] \n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3 \nsqSize = size*size\nmaxAdr = sqSize -1\nmask = 0xF\nshiftSize = 4\nshiftTimes= 16\n\nsolver :: [[Int]] -> Int\nsolver lst = bfs start goal where\n    bfs start goal = iter (initialQueue, initialVisited) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(board, distance, forward) -> case next path visited of\n                (_, Just d)  -> distance + d +1\n                (nextPaths, Nothing) -> iter (insertPaths que visited nextPaths) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(x, d, f):ps) = insertPaths insertQue insertVisited ps where\n                        insertQue = p Seq.<| q\n                        insertVisited = M.insert x (d, f) v\n        next path@(board, distance, forward) visited = iter [] Nothing nextBoards where\n            iter ac af [] = (ac, af)\n            iter ac af (x:xs) = case M.lookup x visited of\n                Nothing -> iter ((x, distance+1, forward):ac) af xs\n                Just (d', f') -> if forward == f' then iter ac af xs else (ac, Just d')\n            boards = [swapWith (valueAt p board) board | p <- dest!(searchZero board)]\n            nextBoards = [x| x <- boards]\n\n    initialQueue = (goal, 0, False) Seq.<| (Seq.singleton (start, 0, True))\n    initialVisited = M.insert goal (0, False) $ M.singleton start (0, True)\n    goal    = toBits [1,2,3,4,5,6,7,8,0]\n    start   = toBits $ concat lst\n    dest    = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n    toBits = foldl' (\\b a-> shiftL b shiftSize .|. a) 0\n    valueAt i w = mask .&. shiftR w (shiftSize*i)\n\nsearchZero :: Int -> Int\nsearchZero = iter 0 where\n    iter c w = case mask .&. w of \n        hb  | hb == 0 -> c\n            | otherwise -> iter (c+1) (rotateR w shiftSize)\n\nswapWith :: Int -> Int -> Int\nswapWith v = iter sqSize where\n    iter 0 w = rotateR w (shiftSize*(shiftTimes-sqSize))\n    iter c w = iter (c-1) $ rotateR (case mask .&. w of\n        hb  | hb == 0 -> w .|. v\n            | hb == v -> w `xor` v\n            | otherwise -> w) shiftSize\n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\nÂ \nmodule Main where\nÂ \nimport Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\nÂ \nsize = 3 \nsqSize = size*size\nmaxAdr = sqSize -1\nmask = 0xF\nshiftSize = 4\nshiftTimes= 16\nÂ \nsolver :: [[Int]] -> Int\nsolver lst\nÂ Â Â Â | start == goal = 0\nÂ Â Â Â | otherwise = iter (initialQueue, initialVisited) where\nÂ Â Â Â Â Â Â Â iter (que, visited) = case Seq.viewr que of\nÂ Â Â Â Â Â Â Â Â Â Â Â Seq.EmptyR -> error \"No path found.\"\nÂ Â Â Â Â Â Â Â Â Â Â Â que Seq.:> path@(board, distance, forward) -> case next path visited of\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (_, Just d)Â  -> distance + d +1\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (nextPaths, Nothing) -> iter (insertPaths que visited nextPaths) where\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â insertPaths q v [] = (q, v)\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â insertPaths q v (p@(x, d, f):ps) = insertPaths insertQue insertVisited ps where\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â insertQue = p Seq.<| q\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â insertVisited = M.insert x (d, f) v\nÂ Â Â Â Â Â Â Â next path@(board, distance, forward) visited = iter [] Nothing nextBoards where\nÂ Â Â Â Â Â Â Â Â Â Â Â iter ac af [] = (ac, af)\nÂ Â Â Â Â Â Â Â Â Â Â Â iter ac af (x:xs) = case M.lookup x visited of\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Nothing -> iter ((x, distance+1, forward):ac) af xs\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Just (d', f') -> if forward == f' then iter ac af xs else (ac, Just d')\nÂ Â Â Â Â Â Â Â Â Â Â Â nextBoards = [swapWith (valueAt p board) board | p <- dest!(searchZero board)]\nÂ \nÂ Â Â Â Â Â Â Â initialQueue = (goal, 0, False) Seq.<| (Seq.singleton (start, 0, True))\nÂ Â Â Â Â Â Â Â initialVisited = M.insert goal (0, False) $ M.singleton start (0, True)\nÂ Â Â Â Â Â Â Â goalÂ Â Â  = toBits [1,2,3,4,5,6,7,8,0]\nÂ Â Â Â Â Â Â Â startÂ Â  = toBits $ concat lst\nÂ Â Â Â Â Â Â Â destÂ Â Â  = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\nÂ Â Â Â Â Â Â Â toBits = foldl' (\\b a-> shiftL b shiftSize .|. a) 0\nÂ Â Â Â Â Â Â Â valueAt i w = mask .&. shiftR w (shiftSize*i)\nÂ \nsearchZero :: Int -> Int\nsearchZero = iter 0 where\nÂ Â Â Â iter c w = case mask .&. w of \nÂ Â Â Â Â Â Â Â hbÂ  | hb == 0 -> c\nÂ Â Â Â Â Â Â Â Â Â Â Â | otherwise -> iter (c+1) (rotateR w shiftSize)\nÂ \nswapWith :: Int -> Int -> Int\nswapWith v = iter sqSize where\nÂ Â Â Â iter 0 w = rotateR w (shiftSize*(shiftTimes-sqSize))\nÂ Â Â Â iter c w = iter (c-1) $ rotateR (case mask .&. w of\nÂ Â Â Â Â Â Â Â hbÂ  | hb == 0 -> w .|. v\nÂ Â Â Â Â Â Â Â Â Â Â Â | hb == v -> w `xor` v\nÂ Â Â Â Â Â Â Â Â Â Â Â | otherwise -> w) shiftSize\nÂ \nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\nÂ \nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\nÂ \nmain :: IO() \nmain = do\nÂ Â Â Â l <- replicateM size readIntList\nÂ Â Â Â print $ solver l\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\nint main( void )\n{\n\n    int kai[Total] ={};\n    \n    int i,j = 0;\n    int finish = 0;\n    int num_0,num_1 = 0;\n    int target=0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    while(finish==0)\n    {\n        for(i=j; i<j; i++)\n        {\n            if(val[i]=target)\n            {\n                num_1=i;\n            }\n        }\n        \n        \n        left_0();\n        \n        down_0();\n        \n        right_0();\n        \n        down_0();\n        \n        finish=1;\n        for(i=0; i<(Total-1); i++)\n        {\n            if(val[i] != (i+1))\n            {\n                finish = 0;\n                break;\n            }\n            \n        }\n    }\n    \n    printf(\"%d\\n\",cnt);\n\n    return 0;\n}\n\nvoid down_0()\n{\n    val[num] = val[num+3];\n    val[num +3] = 0;\n    num = num + 3;\n    cnt = cnt + 1;\n}\n\nvoid up_0()\n{\n    val[num] = val[num-3];\n    val[num -3] = 0;\n    num = num - 3;\n    cnt = cnt + 1;\n}\n\nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n    cnt = cnt + 1;\n}\n\nvoid left_0()\n{\n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n    cnt = cnt + 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 102400\n#define Hash_size 102400\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n \nextern inline void down_0(void);    // 0 ãä¸ã«ç§»å\nextern inline void up_0(void);      // 0 ãä¸ã«ç§»å\nextern inline void right_0(void);   // 0 ãå³ã«ç§»å\nextern inline void left_0(void);    // 0 ãå·¦ã«ç§»å\n \nextern unsigned char serch(unsigned char x, unsigned char y, unsigned char MaxCnt, unsigned char pre);\n\nint num = 0;            // 0 ã®ä½ç½®ãç¤ºã\nint val[Total] = {};    // å¥åæ°å¤ãæ ¼ç´\n \n \nint main( void )\n{\n    unsigned int i = 0;\n    unsigned int x,y = 0;\n     \n    // æ°å¤ã®åãè¾¼ã¿\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n     \n    // 0 ãå³ä¸ã«è¡ãããã« åãããªãã¨ãããªãåæ°\n    x = tate - (num / yoko) -1;\n    y = yoko - (num % yoko) -1;\n    \n    // è§£ãæ¢ã\n    for(i=0; i<TryCnt; i++)\n    {\n        if(serch(x,y,i,4) == 1)\n        {\n            // è§£ç­ãè¡¨ç¤º\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n     \n    return 0;\n}\n \nunsigned char serch(unsigned char x, unsigned char y, unsigned char MaxCnt, unsigned char pre)\n{\n    unsigned char result;\n    unsigned char i=0;\n    \n    // å³ä¸ã«æ»ããªãã®ã§æã¡åã\n    if(MaxCnt < (x + y))\n    {\n        return 0;\n    }\n     \n    // æå¤§æ°ã§ã´ã¼ã«ã¨ä¸è´ãã¦ãããç¢ºèª\n    if(0 == MaxCnt)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ã´ã¼ã«ã¨ä¸ä¸è´\n                return 0;\n            }\n        }\n        // ã´ã¼ã«ã¨ä¸è´ï¼ï¼\n        return 1;\n    }\n    \n    // 0 ã®ç§»å\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n         \n        switch(i)\n        {\n            // ä¸ã«ç§»å\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                     \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                     \n                    up_0();\n                }\n                break;\n                 \n            // å³ã«ç§»å\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                     \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                     \n                    left_0();\n                }\n                break;\n                \n            // å·¦ã«ç§»å\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                     \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                     \n                    right_0();\n                }\n                break;\n                \n            // ä¸ã«ç§»å\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                     \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                     \n                    down_0();\n                }\n                break;\n                 \n            default:\n                // ä½ãããªãã\n                break;\n        }\n         \n        if(result)\n        {\n            return 1;\n        }\n    }\n     \n    return 0;\n}\n \n \ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n  \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n  \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n  \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint kei(int,int,int,int);\nint c[9];\n\nint main(){\n\tint i,a;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&c[i]);\n\t\tif(c[i]==0)a=i;\n\t}\n\tprintf(\"%d\\n\",kei(a,0,10,1));\n\treturn 0;\n}\n\nint kei(int a,int co,int b,int e){\n\tint min=999,sum=0,i,m;\n\tif((e==co || b==10) && a==8){\t\n\t\tfor(i=0;i<8;i++){\n\t\t\tif(c[i]!=i+1){\n\t\t\t\tsum++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sum==0)return co;\n\t}\n\twhile(co<e){\n\t\n\t\tif((a+1)%3!=0 && b!=a+1){\n\t\t\tm=c[a+1];\n\t\t\tc[a+1]=c[a];\n\t\t\tc[a]=m;\n\t\t\tm=kei(a+1,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a+1];\n\t\t\tc[a+1]=m;\n\t\t}\n\t\tif((a-1)%3!=2 && a!=0 && b!=a-1){\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-1];\n\t\t\tc[a-1]=m;\n\t\t\tm=kei(a-1,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-1];\n\t\t\tc[a-1]=m;\n\t\t}\n\t\tif(a-3>=0 && b!=a-3){\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-3];\n\t\t\tc[a-3]=m;\n\t\t\tm=kei(a-3,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-3];\n\t\t\tc[a-3]=m;\n\t\t}\n\t\tif(a+3<9 && b!=a+3){\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a+3];\n\t\t\tc[a+3]=m;\n\t\t\tm=kei(a+3,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a+3];\n\t\t\tc[a+3]=m;\n\t\t}\n\t\tif(b==10)e++;\t\t\n\t\telse return min;\n\t}\n\treturn min;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint puzz[3][3];\nint copy[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\nint main(){\n  int i,j,ans,x,y,l;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &puzz[i][j]);\n\n\n  empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) copy[i][j] = puzz[i][j];\n        }\n         \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n         \n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puzz[i][j] = copy[i][j];\n        }\n         \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n\n\n  return 0;\n} \n \nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b) {\n    int tmp;\n     \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \n \nint cal() {\n    int i,a,sum=0;\n     \n    for(i=0; i<9; i++) {\n        a = puzz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n     \n    return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n     \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n     \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n         \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n        swap(&puzz[y][x],&puzz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n         \n        swap(&puzz[y][x],&puzz[ny][nx]);\n    }\n     \n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 3\n#define N2 9\n#define NMAX 500001\n\nint head = 0,tail = 0;\nint V[NMAX];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nstruct Puzz{\n  int f[N2];\n  int space;\n  int path;\n};\n\nstruct Puzz Q[NMAX];\n\nvoid enqueue(struct Puzz x){\n  \n  int next = (tail + 1) % NMAX;\n  Q[tail] = x;\n  tail = next;\n}\n\nstruct Puzz dequeue(void){\n  struct Puzz temp;\n  temp = Q[head];\n  head = (head + 1) % NMAX;\n  return temp;\n}\nint _Sort(struct Puzz x){\n  int i,j,key,cnt,n = 0;\n\n  for(i = 0,key = 1;i < N2;key *= ++i){\n    for(j = 0,cnt = 0;j < i;j++){\n      if(x.f[j] < x.f[i]){\n\tcnt++;\n      }\n    }\n    n += cnt * key;\n  }\n  return n;\n}\n\nint isTarget(struct Puzz x){\n  int i;\n\n  for(i = 0;i < N2;i++){\n    if(x.f[i] != (i + 1)){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint bfs(struct Puzz s){\n  int r,sx,sy,tx,ty,temp;\n  struct Puzz u,v;\n\n  s.path = 0;\n  enqueue(s);\n  V[_Sort(s)] = 1;\n\n  while(head != tail){\n    u = dequeue();\n    if(isTarget(u) == 1){\n      return u.path;\n    }\n    sx = u.space / N;\n    sy = u.space % N;\n    for(r = 0;r < 4;r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if(tx < 0 || ty < 0|| tx >= N || ty >= N){\n\tcontinue;\n      }\n      v = u;\n      temp = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = temp;\n      v.space = tx * N + ty;\n      if(V[_Sort(v)] != 1){\n\tV[_Sort(v)] = 1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(void){\n\n  int i,ans;\n  struct Puzz in;\n\n  for(i = 0;i < N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  ans = bfs(in);\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n  #include <stdlib.h>\n  int puzle[3][3];\n  int tmp[3][3];\n  int d1[4]={0,1,0,-1};\n  int d2[4]={1,0,-1,0};\n \n  void empty(int *x,int *y){\n    int i,j;\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        if(!puzle[i][j]){\n    *x=j;\n    *y=i;\n    return;\n        }\n      }\n    }\n  }\n \n  void swap(int *a,int *b){\n    int tmp=*a;\n    *a=*b;\n    *b=tmp;\n  }\n \n  int cal(){\n    int a,i,sum=0;\n    for(i=0;i<9;i++){\n      a=puzle[i/3][i%3];\n      if(a){\n        a--;\n        sum += abs(i/3-a/3) + abs(i%3-a%3);\n      }\n    }\n    return sum;\n  }\n \n  int dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,n1,n2,res;\n    h=cal();\n    if(h==0){\n      return dep;\n    }\n    if(dep+h > lim){\n      return -1;\n    }\n    for(i=0;i<4;++i){\n      n1=x+d1[i];\n      n2=y+d2[i];\n \n      if(~p && i==(p+2)%4)\n        continue;\n      if(!(0 <= n1 && n1 < 3 && 0 <= n2 && n2 < 3))\n        continue;\n      swap(&puzle[y][x],&puzle[n2][n1]);\n      res=dfs(n1,n2,i,dep+1,lim);\n \n      if(~res){\n        return res;\n      }\n      swap(&puzle[y][x],&puzle[n2][n1]);\n    }\n    return -1;\n  }\n \n  int main(){\n    int ans,x,y,l,i,j;\n \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        scanf(\"%d\",&puzle[i][j]);\n      }\n    }\n    empty(&x,&y);\n    for(l=0;l<100;l++){\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    tmp[i][j]=puzle[i][j];\n      }\n    }\n      ans=dfs(x,y,-1,0,l);\n      if(ans!=-1){\n        printf(\"%d\\n\",ans);\n        break;\n      }\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    puzle[i][j]=tmp[i][j];\n      }\n      }\n      ans=-1;\n      if(l==99){\n        printf(\"%d\\n\",ans);\n    }\n    }\n    return 0;\n  }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  char b[10];\n  int step;\n} Board;\n\nint qlen=400000;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\n\nint main()\n{\n  int i, k, n;\n  int qhead=0;\n  int qtail=0;\n  Board board;\n  fscanf(stdin, \"%c %c %c\\n\", &board.b[0], &board.b[1], &board.b[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.b[3], &board.b[4], &board.b[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.b[6], &board.b[7], &board.b[8]);\n  board.b[9]=0;\n  short int *used = (short int*)malloc(sizeof(short int)*87654321);\n  for (i=0; i<87654321; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    \n    if (strncmp(board.b, \"123456780\", 8)==0)   break;\n\n    k=board.b[7];\n    n=10;\n    for (i=1; i<8; i++) {\n      k += (board.b[7-i]-'0')*n;\n      n*=10;\n    }\n    \n    if ((used[k] & (1<<(board.b[8]-'0')))==(1<<(board.b[8]-'0'))) continue;\n    used[k] |= (1<<(board.b[8]-'0'));\n    \n    int space = (int)(strchr(board.b, '0')-board.b);    \n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && b.b[0]=='1'&&b.b[1]=='2'&&b.b[2]=='3') continue;\n      b.b[space] = b.b[m.pos];\n      b.b[m.pos] = '0';\n      b.step=board.step+1;\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\n\nint main() {\n    int i,j,ans,x,y,l;\n    \n    //puzzle input\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n    \n    \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n        \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n        \n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n        \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n    \n    //ans output\n    //printf(\"%d\\n\",ans);\n    \n    return 0;\n}\n\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n\nint cal() {\n    int i,a,sum=0;\n    \n    for(i=0; i<9; i++) {\n        a = puz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    \n    return sum;\n}\n\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n    \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n    \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n    }\n    \n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n\n\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mynode *data) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(&data->key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    rb_link_node(&data->node, parent, new);\n    rb_insert(&data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n\n// Queue\n#define QueueKey struct mykey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\nstruct mynode node[200000];\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    static int num = 0;\n    node[0].key = s;\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, node + num++);\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        struct mykey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            node[num].key = next_key;\n            if(my_insert(&mytree, node + num) == 0) num++;\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint pzl[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pzl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pzl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  \n  return S;\n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  \n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n  }\n  \n  return -1;\n  \n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pzl[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=pzl[i][j];\n      }\n    }\n    \n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpzl[i][j]=tmp[i][j];\n      }\n    }\n\n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int N = 8;\nint length;\n\nstruct Node {\n  int *board;\n  int h;\n  struct Node *parent;\n};\n\n\n// apparently most linkers don't auto include math.h even if you include the header file,\n// so I'm making bad sqrt for ints and ceiling functions\nint sqrt(int n) {\n  if (n == 0 || n == 1)\n    return n;\n\n  int i = 1, out = 1;\n  while (out <= n) {\n    i++;\n    out = i*i;\n  }\n\n  return i - 1;\n}\n\nint ceil(double n) {\n  if (n - (int) n > 0)\n    return (int) n + 1;\n  else\n    return (int) n;\n}\n\n\nint heuristic(int *board) {\n  int i, j, curx, counter = 0, dist = 0;\n\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < length; j++) {\n      if (board[counter] % 3 == 0)\n        curx = 3;\n      else\n        curx = board[counter] % 3;\n\n      if (board[counter] != 0)\n        dist += abs(curx -(j + 1)) + abs(ceil((double) board[counter] / 3.0) - (i + 1));\n      counter++;\n    }\n  }\n\n  //printf(\"manhattan distance is: %d\\n\", dist);\n  return dist;\n}\n\nint main() {\n  int i, j;\n  length = sqrt(N + 1);\n  int *board = malloc(length * length * sizeof(int));\n\n  //printf(\"printing input board:\\n\");\n\n  for (i = 0; i < length * length; i++) {\n    scanf(\"%d\", &board[i]);\n    /*\n    if ((i + 1) % 3 == 0)\n      printf(\"%d\\n\", board[i]);\n    else\n      printf(\"%d \", board[i]);\n    */\n  }\n\n  printf(\"%d\\n\", heuristic(board));\n  return 0;\n\n  /*\n  struct Node root;\n  root.board = board;\n  root.h = heuristic(board);\n  root.parent = NULL;\n  */\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<10; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n//    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n//    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n//    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n//    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}   \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,nx,ny,res;   \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1; \n    for(i=0; i<4; i++){\n        nx = x+dx[i];\n        ny = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;       \n        swap(&puz[y][x],&puz[ny][nx]);\n    }   \n    return -1;\n}    \nint main() {\n    int i,j,ans,x,y,l;\n       \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n        \n    empty(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n           \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n           \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n           \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n       \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 10240\n#define Hash_size 1024\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \nint board[9];\nint rows = 3, cols = 3, zeroIndex, current;\n \n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n \n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n \n  if (!moves) {\n    for (i = 0; i < 8; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n \n    return 1;\n  }\n \n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n \n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n \n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n \n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[--zeroIndex];\n  }\n if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n \n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[++zeroIndex];\n  }\n \n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n \n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n \n  return 0;\n}\n \nint main() {\n  int i, x, y;\n  current = 0;\n \n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n \n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n \n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      break;\n    }\n    current++;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<5; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n\n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n\n        ans = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n\n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    } \n    return 0;\n}\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n\n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *x,int *y) {\n\n  int i,j;\n\n  for(i = 0;i < 3;i ++)\n    {\n      for(j = 0;j < 3;j ++)\n\t{\n\t  if(!puz[i][j])\n\t    {\n\t      *x = j;\n\t      *y = i;\n\n\t      return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b) {\n\n  int tmp;\n     \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n \n \nint cal() {\n\n  int i,a;\n  int sum = 0;\n     \n  for(i = 0;i < 9;i ++)\n    {\n      a = puz[i/3][i%3];\n\n      if(a){\n\ta--;\n\n\tsum += abs(i/3 - a/3) + abs(i%3 - a%3);\n\n      }\n    }\n     \n  return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n\n  int i,h,nx,ny,res;\n     \n  h = cal();\n\n  if(h == 0){\n    return dep;\n  }\n    \n  if(dep+h > lim){\n    return -1;\n  }\n    \n  for(i = 0;i < 4;i ++)\n    {\n      nx = x+dx[i];\n      ny = y+dy[i];\n         \n      if(~p && i==(p+2)%4) continue;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny<3)) continue;\n         \n      swap(&puz[y][x],&puz[ny][nx]);\n\n      res = dfs(nx,ny,i,dep+1,lim);\n\n      if(~res){\n\treturn res;\n      }\n\t\n      swap(&puz[y][x],&puz[ny][nx]);\n    }\n     \n  return -1;\n}\n\n \n \nint main() {\n\n  int i,j,ans,x,y,l;\n     \n   \n  for(i = 0;i < 3;i ++)\n    {\n      for(j = 0;j < 3;j ++)\n\t{\n\t  scanf(\"%d\",&puz[i][j]);\n\t}\n    }\n     \n     \n  empty(&x,&y);\n\n  for(l = 0;l < 100;l ++)\n    {\n      for(i = 0;i < 3;i ++)\n\t{\n\t  for(j = 0;j < 3;j ++)\n\t    {\n\t      tmp[i][j] = puz[i][j];\n\t    }\n        }\n         \n      ans = dfs(x,y,-1,0,l);\n\n      if(ans != -1)\n\t{\n\t  printf(\"%d\\n\",ans);\n\t  break;\n        }\n         \n      for(i = 0;i < 3;i ++)\n\t{\n\t  for(j = 0;j < 3;j ++)\n\t    {\n\t      puz[i][j] = tmp[i][j];\n\t    }\n        }\n         \n      ans = -1;\n\n      if(l == 99){\n\tprintf(\"%d\\n\",ans);\n      }\n    }     \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_LENGTH 101\nint ini[4][4];\nint changed[4][4];\nint dxn[4] = {0, 1, 0, -1};\nint dyn[4] = {1, 0, -1, 0};\nvoid Empty(int *row, int *column)\n{\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            if(!ini[i][j]){*column = i;*row = j;}\n        }\n\n\tfor(int j=0;j<3;j++)\n        {\n            if(!ini[i][j]){*column = i;*row = j;}\n        }\n    }\n}\nint calculate()\n{\n    int countSum = 0;\n    for(int i=0;i<9;i++)\n    {\n        int temp = ini[i/3][i%3];\n        if(temp)\n        {\n            temp--;\n            countSum += abs(i/3-temp/3)+abs(i%3-temp%3);\n        }\n    }\n    return countSum;\n}\nint depthF(int x, int y, int k, int depth, const int limit)\n{\n    int length;\n    length = calculate();\n    if (length == 0)return depth;\n    if (depth + length > limit)return -1;\n    for (int i = 0; i < 4; i++)\n    {\n        int a = x + dxn[i];\n        int b = y + dyn[i];\n        if (~k && i == (k + 2) % 4)continue;\n        if (!(0 <= a && a < 3 && 0 <= b && b < 3))continue;\n        int tem = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=tem;\n        int res = depthF(a, b, i, depth + 1, limit);\n        if (~res)return res;\n        int te = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=te;\n    }\n    return -1;\n}\nint main() {\n    int row, column=0;\n    int step;\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++){scanf(\"%d\", &ini[i][j]);}\n\n\t\n    }\n    Empty(&row, &column);\n    for(int l=0;l<MAX_LENGTH;l++)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){changed[i][j]=ini[i][j];}\n        }\n        if((step = depthF(row, column, -1, 0, l))!=-1)\n        {\n            printf(\"%d\\n\", step);\n            break;\n        }\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){ini[i][j]=changed[i][j];}\n        }\n        step = -1;\n        if(l==MAX_LENGTH-1){printf(\"%d\\n\", step);}\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define true 1\n#define false 0\n#define LEN 500001\n#define N 3\n#define N2 9\n\ntypedef struct puzzle {\n\tint f[N2];\n\tint space;\n\tint path;\n} Puzzle;\n\nvoid enqueue(Puzzle);\nPuzzle dequeue();\n\nPuzzle Q[LEN];\nint head = 0, tail = 0;\nint V[LEN];\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint hash(Puzzle p) {\n\tint i, j;\n\tint key, count;\n\tint sum = 0;\n\n\tfor ( i = 0, key = 1; i < N2; key *= ++i) {\n\t\tfor ( j = 0, count = 0; j < i; j++) {\n\t\t\tif ( p.f[j] < p.f[i] ) count++;\n\t\t}\n\t\tsum += count * key;\n\t}\n\treturn sum;\n}\n\nint isTarget(Puzzle p) {\n\tint i;\n\tfor ( i = 0; i < N2; i++)\n\t\tif ( p.f[i] != ( i + 1 ) ) return false;\n\treturn true;\n}\n\nint bfs(Puzzle s) {\n\tPuzzle u, v;\n\tint r;\n\ts.path = 0;\n\tenqueue(s);\n\tV[hash(s)] = true;\n\n\twhile ( head != tail ){\n\t\tu = Q[head];\n\t\tdequeue();\n\t\tif ( isTarget(u) == true ) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor ( r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t\t\tv = u;\n\t\t\tint temp = v.f[u.space];\n\t\t\tv.f[u.space] = v.f[tx * N + ty];\n\t\t\tv.f[tx * N + ty] = temp;\n\t\t\tv.space = tx * N + ty;\n\t\t\tif ( V[hash(v)] != true ) {\n\t\t\t\tV[hash(v)] = true;\n\t\t\t\tv.path++;\n\t\t\t\tenqueue(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tPuzzle in;\n\tint i;\n\n\tfor ( i = 0; i < N2; i++) {\n\t\tscanf(\"%d\",&in.f[i]);\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tint ans = bfs(in);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\nvoid enqueue(Puzzle x) {\n\tQ[tail] = x;\n\ttail = (tail + 1) % LEN;\n}\n\nPuzzle dequeue() {\n\tPuzzle x = Q[head];\n\thead = (head + 1) % LEN; \n\treturn x;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, current;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint catch();\nvoid swap(int *,int *);\n\n\nint main() {\n    int i,j,ans,x,y,V;\n    \n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n    \n    \n    empty(&x,&y);\n    for(V=0; V<100; V++) {\n       \n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n        \n        ans = dfs(x,y,-1,0,V);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n        \n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n        \n         ans = -1;\n        if(V==99) printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n\nint catch() {\n    int i,a,sum=0;\n    \n    for(i=0; i<9; i++) {\n        a = puz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    \n    return sum;\n}\n\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n    \n    h = catch();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n    \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n    }\n    \n    return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint panel[3][3];\nint temp[3][3];\nint XX[4] = {0,1,0,-1};\nint YY[4] = {1,0,-1,0};\n\nint DFS(int,int,int,int,const int);\nint Calc();\nvoid empty(int *,int *);\nvoid swap(int *,int *);\n\nint main()\n{\n\tint i,j;\n\tint x,y;\n\tint A,l;\n\tfor(i=0; i<3; i++)\n\t{\n\t\tfor(j=0; j<3; j++) scanf(\"%d\",&panel[i][j]);\n\t}\n\n\tempty(&x,&y);\n\tfor(l=0; l<100; l++)\n\t{\n\t\tfor(i=0; i<3; i++)\n\t\t{\n\t\t\tfor(j=0; j<3; j++) temp[i][j] = panel[i][j];\n\t\t}\n\n\t\tA = DFS(x,y,-1,0,l);\n\n\t\tif(A != -1)\n\t\t{\n\t\t\tprintf(\"%d\\n\",A);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(i=0 ; i<3 ; i++)\n\t\t{\n\t\t\tfor(j=0 ; j<3 ; j++) panel[i][j] = temp[i][j];\n\t\t}\n\t\tA = -1;\n\t\tif(l == 99) printf(\"%d\\n\",A);\n\t}\n\treturn 0;\n}\n\nvoid empty(int *x,int *y)\n{\n\tint i,j;\n\tfor(i=0; i<3; i++)\n\t{\n\t\tfor(j=0; j<3; j++)\n\t\t{\n\t\t\tif(!panel[i][j])\n\t\t\t{\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid swap(int *a,int *b)\n{\n\tint temp;\n\ttemp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nint Calc()\n{\n\tint i,x,sum=0;\n\tfor(i=0; i<9; i++)\n\t{\n\t\tx = panel[i/3][i%3];\n\t\tif(x)\n\t\t{\n\t\t\tx--;\n\t\t\tsum += abs(i/3 - x/3) + abs(i%3 - x%3);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint DFS(int x,int y,int p,int Depth,const int Limit)\n{\n\tint i;\n\tint h,res;\n\tint X,Y;\n\n\th = Calc();\n\tif(h == 0) return Depth;\n\tif(Depth+h>Limit) return -1;\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tX = x + XX[i];\n\t\tY = y + YY[i];\n\n\t\tif(~p && i == (p+2)%4) continue;\n\t\tif(!(0 <= X && X<3 && 0 <= Y && Y<3)) continue;\n\n\t\tswap(&panel[y][x],&panel[Y][X]);\n\t\tres = DFS(X,Y,i,Depth+1,Limit);\n\t\tif(~res) return res;\n\n\t\tswap(&panel[y][x],&panel[Y][X]);\n\t}\n\n\treturn -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;\nint val[Total] ={};\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n\n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n\n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n\n    for(i=0; i<TryCnt; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n\n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n\n    if(MaxCnt < (x + y) )\n    {\n        return 0;\n    }\n\n    if(MaxCnt==0)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ã´ã¼ã«ã¨ä¸ä¸è´\n                return 0;\n            }\n        }\n        // ã´ã¼ã«ã¨ä¸è´ï¼ï¼\n        return 1;\n    }\n\n\n    // 0 ã®ç§»å\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n\n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n\n                    result = serch(x-1, y, MaxCnt-1, 0);\n\n                    up_0();\n                }\n                break;\n\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n\n                    result = serch(x, y-1, MaxCnt-1, 1);\n\n                    left_0();\n                }\n                break;\n\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n\n                    result = serch(x, y+1, MaxCnt-1, 2);\n\n                    right_0();\n                }\n                break;\n\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n\n                    result = serch(x+1, y, MaxCnt-1, 3);\n\n                    down_0();\n                }\n                break;\n\n            default:\n                // ä½ãããªãã\n                break;\n        }\n\n        if(result)\n        {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n\ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n\ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n\ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n#define T 1\n#define F 0\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp;\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n  return ;\n}\n\nint GetHeuristic(){\n  int i,j,sum = 0,x;\n  for(i = 0 ; i < N ; i++){\n    for(j = 0 ; j < N ; j++){\n    if(t[i][j] == 0)continue;\n    x = t[i][j]-1;\n    sum += abs(x/N - i) + abs(x%N - j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int py,int px){\n  int h = GetHeuristic();\n  if(h == 0)return T;\n  if(depth+h > limit)return F;\n  int i;\n  for(i = 0 ; i < 4 ; i++){\n    if(abs(i-prev) == 2)continue;\n    int tx = px + dx[i],ty = py + dy[i];\n    if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n    swap(&t[ty][tx],&t[py][px]);\n    if(dfs(depth + 1,i,ty,tx))return T;\n    swap(&t[ty][tx],&t[py][px]);\n  }\n  return F;\n}\n\nvoid isSolved(int py,int px){\n  for(limit = 0 ; ; limit++){\n    if(dfs(0,99,py,px)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,px,py;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        py=i;\n        px=j;\n      }\n    }\n  }\n  isSolved(py,px);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint P[N][N],G[N][N];\nint X[4]={0,1,0,-1};\nint Y[4]={1,0,-1,0};\n\nvoid Empty(int *,int *);\nvoid Swap(int *,int *);\nint DFS(int ,int ,int ,int ,const int );\nint cal();\n\nint main()\n{\n  int i,j;\n  int h,ans,row,col;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&P[i][j]);\n    }\n  }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tG[i][j] = -1;\n      }\n    }\n\n  Empty(&row,&col);\n\n  for(h=0;h<100;h++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        G[i][j] = P[i][j];\n      }\n    }\n    \n    ans = DFS(row,col,-1,0,h);\n\n    for(i=0;i<N;i++){\n      \n    }\n\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        P[i][j] = G[i][j];\n      }\n    }\n    \n    ans = -1;\n\n    if(h == 99)\n      printf(\"%d\\n\\n\",ans);\n  }\n  return 0;\n}\n\nvoid Empty(int *row,int *col)\n{\n  int i,j;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!P[i][j]){\n        *row = j;\n        *col = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid Swap(int *a,int *b) //äº¤æ\n{\n  int tmp;\n  \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint DFS(int x,int y,int p,int deep,const int lim)\n{\n  int i,len,emc;\n  int x2,y2;\n\n  len = cal();\n\n  if(len == 0)\n    return deep;\n  if(deep + len > lim)\n    return -1;\n\n  for(i=0; i<N+1; i++){\n    x2 = x+X[i];\n    y2 = y+Y[i];\n    if(p != -1 && i == (p + 2) % 4) \n      continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3))\n      continue;\n\n    Swap(&P[y][x],&P[y2][x2]);\n\n    emc = DFS(x2,y2,i,deep+1,lim);\n\n    if (emc != -1) \n      return emc;\n\n    Swap(&P[y][x],&P[y2][x2]);\n  }\n\n  return -1;\n}\n\nint cal()\n{\n  int i,e,C = 0;\n\n  for(i=0;i<9;i++){\n    e = P[i/3][i%3];\n    if(e){\n      e--;\n      C += abs(i/3-e/3) + abs(i%3-e%3);\n    }\n  }\n  return C;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n\nint X[4]={0,-1,0,1};\nint Y[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint Heuristic(){\n  int i,j,sum=0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(t[i][j]==0)continue;\n    x=t[i][j]-1;\n    sum+=abs(x/N-i)+abs(x%N-j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int y,int x){\n  int h=Heuristic();\n  if(h == 0) return 1;\n  if(depth + h > limit) return 0;\n  int i;\n  for(i = 0 ; i < 4 ; i++){\n    if(abs(i - prev) == 2) continue;\n    int tx=x+X[i],ty=y+Y[i];\n    if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n    swap(&t[ty][tx],&t[y][x]);\n    if(dfs(depth+1,i,ty,tx))return 1;\n    swap(&t[ty][tx],&t[y][x]);\n  }\n  return 0;\n}\n\nvoid solve(int y,int x){\n  for(limit = 0 ;; limit++){\n    if(dfs(0 ,99 ,y ,x)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,x,y;\n  for(i = 0 ; i < N ; i++){\n    for(j = 0 ; j < N ; j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        y=i;\n        x=j;\n      }\n    }\n  }\n  solve(y,x);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N   3\n#define LIM 32\n#define HN  362897\n\nstruct dep{\n    int depth;\n    int key;\n};\n\nint puz[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n\nint min = LIM;\nstruct dep h[HN];\n\nint Hash1(int x){\n    return x % HN;\n}\n\nint Hash2(int x){\n    return 1 + x % (HN-1);\n}\n\nint Hash3(int x, int y){\n    return (Hash1(x) + y * Hash2(x)) % HN;\n}\n\nvoid Dfs(int x[N][N], int n){\n    int i,j,l,m,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n\n    for(i = 0 ; i < N ; i++){\n        for(j = 0 ; j < N ; j++){\n            if(puz[i][j] != x[i][j]){\n              f++;\n            }\n            if(x[i][j] == 0){\n                l = i;\n                m = j;\n            }\n            a += x[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if(f == 0){\n        if(min >= n){\n            min = n;\n        }\n        return;\n    }\n    if(n > min){\n      return;\n    }\n    i = 0;\n    while(1){\n        b = Hash3(a, i);\n        if(h[b].key == 0){\n          h[b].key = a;\n          h[b].depth = n;\n          break;\n        }\n        else if(h[b].key == a){\n            if(h[b].depth > n){\n              h[b].depth = n;\n              break;\n            }\n            else{\n              return;\n            }\n        }\n        i++;\n    }\n\n    if(l > 0 && l < N){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l-1][m];\n        tmp[l-1][m] = f;\n        Dfs(tmp, n+1);\n    }\n\n    if(m > 0 && m < N){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l][m-1];\n        tmp[l][m-1] = f;\n        Dfs(tmp, n+1);\n    }\n\n    if(l >= 0 && l < N-1){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l+1][m];\n        tmp[l+1][m] = f;\n        Dfs(tmp, n+1);\n    }\n\n    if(m >= 0 && m < N-1){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l][m+1];\n        tmp[l][m+1] = f;\n        Dfs(tmp, n+1);\n    }\n}\n\nint main(){\n    int i,j;\n    int puz[N][N];\n\n    for(i = 0 ; i < N ; i++){\n        for(j = 0 ; j < N ; j++){\n            scanf(\"%d\",&puz[i][j]);\n        }\n    }\n    Dfs(puz,0);\n\n    printf(\"%d\\n\",min);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint pane[N][N], temp[N][N];\nint dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};\n\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n  int i,j,h,ans,row,col;\n      \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0; h<100; h++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++)\n\ttemp[i][j] = pane[i][j];\n    }    \n    ans = dfs(row,col,-1,0,h);    \n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }    \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++)\n\tpane[i][j] = temp[i][j];\n    }    \n    ans = -1;\n    if(h==99) printf(\"%d\\n\",ans);\n  }      \n  return 0;\n}\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0; i<3; i++)\n    for(j=0; j<3; j++)\n      if(!pane[i][j]){\n\t*row = j;\n\t*col = i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e,count=0; \n  for(i=0; i<9; i++){\n    e = pane[i/3][i%3];\n    if(e){\n      e--;\n      count += abs(i/3 - e/3) + abs(i%3 - e%3);\n    }\n  }    \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i,l,x2,y2,emc;   \n  l = cal();\n  if(l==0) return deep;\n  if(deep+l > limt) return -1; \n  for(i=0; i<4; i++){\n    x2 = x+dx[i];\n    y2 = y+dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n    swap(&pane[y][x],&pane[y2][x2]);\n    emc = dfs(x2,y2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y2][x2]);\n  }   \n  return -1;\n}  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nconst int N = 8;\nint length;\n\nstruct Node {\n  int *board;\n  int h;\n  struct Node *parent;\n};\n\n\nint heuristic(int *board) {\n  int i, j, curx, counter = 0, dist = 0;\n\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < length; j++) {\n      if (board[counter] % 3 == 0)\n        curx = 3;\n      else\n        curx = board[counter] % 3;\n\n      if (board[counter] != 0)\n        dist += abs(curx -(j + 1)) + abs((int) ceil((float) board[counter] / 3.0) - (i + 1));\n      counter++;\n    }\n  }\n\n  //printf(\"manhattan distance is: %d\\n\", dist);\n  return dist;\n}\n\n\nint main() {\n  int i, j;\n  length = (int) sqrt((double) N + 1);\n  int *board = malloc(length * length * sizeof(int));\n\n  //printf(\"printing input board:\\n\");\n\n  for (i = 0; i < length * length; i++) {\n    scanf(\"%d\", &board[i]);\n    /*\n    if ((i + 1) % 3 == 0)\n      printf(\"%d\\n\", board[i]);\n    else\n      printf(\"%d \", board[i]);\n    */\n  }\n\n  printf(\"%d\\n\", heuristic(board));\n  return;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int A[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&A[i][j]);\n    }\n  }\n  dfs(A,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 20\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint temp[3][3];\n\nint dx[4]={0,1,0,-1}; \nint dy[4]={1,0,-1,0}; \n// for changing position up,down,left,right\nvoid empty(int x[],int y[])\n{\n  int i,j;\n  for(i=0;i<3;i++) \n  {\n    for(j=0;j<3;j++) \n    {\n      if(puz[i][j]==0) \n      {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[])\n{\n  int temp;\n  temp=*a;\n  *a=*b;\n  *b=temp;\n}\nint calcum(){\n  int a;\n  int N=0;\n  for(int i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a!=0)\n    {\n      a=a-1;\n      N =N + abs((i/3)-(a/3))+abs((i%3)-(a%3));\n    }\n  }\n  return N;\n}\nint dfs(int x,int y,int p,int dep, int lim) \n{\n  int i,h,x2,y2,res;\n  h=calcum();\n  \n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<4;i++)\n  {\n    x2=x+dx[i];  \n    y2=y+dy[i];\n    if(~p && i==(p+2)%9) //////\n        continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) \n        continue;\n    swap(&puz[y][x],&puz[y2][x2]);\n    res = dfs(x2,y2,i,dep+1,lim);\n    if(~res) \n        return res;\n    swap(&puz[y][x],&puz[y2][x2]);\n  }\n  return -1;\n}\nint main() {\n  int def,x,y;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++)\n    {\n        scanf(\"%d\",&puz[i][j]);\n        temp[i][j]= puz[i][j];\n    }  \n  }\n  empty(&x,&y);\n  \n  for(int i=0;i<100;i++)\n  {\n    def=dfs(x,y,-1,0,i);\n    if(def!=-1)\n    {\n      printf(\"%d\\n\",def);\n      break;\n    }\n  \n    def = -1;  \n    if(i==99) \n        printf(\"%d\\n\",def);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/* \n * File:   main.c\n * Author: s1252007\n *\n * Created on August 2, 2018, 11:10 PM\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define Axiom 1\n#define Flaw 0\n#define Void 0\n#define Bi_Force 2\n#define Tri_Force 3\n#define Quad_Force 4\n\n/*\n * \n */\n\nint ow[] = {-1, 0, 1, 0};\nint oh[] = {0, 1, 0, -1};\nint round_table[Tri_Force][Tri_Force], lancelot;\n\nvoid swap(int *apple, int *pen);\nint getYourFatAssHereHeuriChan();\nint check(int intensity, int quondam, int loki, int odin);\nvoid solve(int loki, int odin);\n\nint main()\n{\n    int loki, odin;\n    for(int i = Void; i < Tri_Force; ++i)\n    {\n        for(int j = Void; j < Tri_Force; ++j)\n        {\n            scanf(\"%d\", &round_table[i][j]);\n            if(round_table[i][j] == Void )\n            {\n                loki = i;\n                odin = j;\n            }\n        }\n    }\n    \n    solve(loki, odin);\n    \n    return EXIT_SUCCESS;\n}\n\nvoid swap(int *apple, int *pen)\n{\n    int apple_pen = *apple;\n    *apple = *pen;\n    *pen = apple_pen;\n}\n\nint getYourFatAssHereHeuriChan()\n{\n    int heuri_chan = Void, arthur;\n    for(int i = Void; i < Tri_Force; ++i)\n    {\n        for(int j = Void; j < Tri_Force; ++j)\n        {\n            if(round_table[i][j] == Void) continue;\n            arthur = round_table[i][j] - 1;\n            heuri_chan = abs((arthur / Tri_Force) - i) + abs((arthur % Tri_Force) - j) + heuri_chan;\n        }\n    }\n    return heuri_chan;\n}\n \nint check(int intensity, int quondam, int loki, int odin)\n{\n    int heuri_chan;\n    heuri_chan = getYourFatAssHereHeuriChan();\n    if(heuri_chan + intensity > lancelot) return Flaw;\n    if(heuri_chan == Void) return Axiom;\n    for(int i = Void; i < Quad_Force; ++i)\n    {\n        if(abs(i - quondam) == Bi_Force) continue;\n        \n        int hel = loki + ow[i],gungnir = odin + oh[i];\n        if(hel < Void || gungnir < Void || hel >= Tri_Force || gungnir >= Tri_Force) continue;\n        \n        swap(&round_table[hel][gungnir], &round_table[loki][odin]);\n        if(check(intensity+1, i, hel, gungnir)) return Axiom;\n        \n        swap(&round_table[hel][gungnir], &round_table[loki][odin]);\n    }\n    return Flaw;\n}\n \nvoid solve(int loki, int odin)\n{\n    for(;;)\n    {\n        if(check(0, 1000, loki, odin))\n        {\n            printf(\"%d\\n\", lancelot);\n            return;\n        }\n        lancelot++;\n    }\n}\n \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint pzl[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pzl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pzl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  \n  return S;\n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  \n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n  }\n  \n  return -1;\n  \n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pzl[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=pzl[i][j];\n      }\n    }\n    \n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpzl[i][j]=tmp[i][j];\n      }\n    }\n\n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define Size 9\n#define Edge 3\n#define Heap_size 102400\n#define Hash_size 102400\n#define Goal_val 0x123456780LL\nstruct heap_table {\n  long long data;\n  int space;\n  int depth;\n  int score;\n};\nstruct hash_table {\n  long long data;\n  struct hash_table *next;\n};\nint goal_score, heapsize, dir[Size], to[Size][4];\nstruct heap_table heap[Heap_size];\nstruct hash_table *hash[Hash_size];\n\nlong long swap(int*, int, int);\nlong long board_val(int*);\nvoid val_board(long long, int*);\nint fair_evaluate(int*, int *);\nvoid downheap(int);\nvoid upheap(int);\nvoid hash_insert(long long);\nint hash_search(long long);\nint Bfs(int*, int*, int);\nint main(void)\n{\n  int i, j, result, space, init[Size], goal[Size];\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  for (i = 0; i < Size; i++) {\n    int dcount = 0;\n    scanf(\"%d\", &init[i]);\n    if (!init[i]) space = i;\n    goal[i] = (i + 1) % Size;\n    if (i > Edge - 1) to[i][dcount++] = i - Edge;\n    if (i % Edge) to[i][dcount++] = i - 1;\n    if ((i + 1) % Edge) to[i][dcount++] = i + 1;\n    if (i < Size - Edge) to[i][dcount++] = i + Edge;\n    dir[i] = dcount;\n  }\n  for (i = 0; i < Size / 2; i++) goal_score += goal[Size - 1 - i] - goal[i];\n  printf(\"%d\\n\", Bfs(init, goal, space));\n}\nlong long swap(int *board, int space, int next)\n{\n  int i;\n  long long res = 0;\n  for (i = 0; i < Size; i++) {\n    res <<= 4;\n    if (i == space) res |= board[next];\n    if (i == next) res |= board[space];\n    else res |= board[i];\n  }\n  return res;\n}\nlong long board_val(int *board)\n{\n  int i;\n  long long val = 0;\n  for (i = 0; i < Size; i++) {\n    val <<= 4;\n    val |= board[i];\n  }\n  return val;\n}\nvoid val_board(long long val, int *board)\n{\n  int i;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = val & 0xf;\n    val >>= 4;\n  }\n}\nint fair_evaluate(int *board, int *goal) {\n  int i, j, score = 0;\n  for (i = 1; i < Size; i++) {\n    int x1, y1, x2, y2;\n    for (j = 0; j < Size; j++) {\n      if (board[j] == i) {\n        x1 = j % Edge;\n        y1 = j / Edge;\n      }\n      if (goal[j] == i) {\n        x2 = j % Edge;\n        y2 = j / Edge;\n      }\n    }\n    score += abs(x1 - x2) + abs(y1 - y2);\n  }\n  return score;\n}\nvoid downheap(int k) {\n  int j;\n  struct heap_table v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && heap[j].score > heap[j + 1].score) j++;\n    if (v.score <= heap[j].score) break;\n    heap[k] = heap[j];\n    k = j;\n  }\n  heap[k] = v;\n}\nvoid upheap(int j)\n{\n  int k;\n  struct heap_table v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 - 1;\n    if (v.score >= heap[k].score) break;\n    heap[j] = heap[k];\n    j = k;\n  }\n  heap[j] = v;\n}\nvoid hash_insert(long long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal, int spa)\n{\n  struct heap_table theap;\n  int i, board[Size];\n  theap.data = board_val(init);\n  heap[heapsize].data = theap.data;\n  heap[heapsize].space = spa;\n  heap[heapsize].depth = 0;\n  heap[heapsize++].score = fair_evaluate(init, goal);\n  if (theap.data == Goal_val) return 0;\n  hash_insert(theap.data);\n  while (heapsize > 0) {\n    theap.data = heap[0].data;\n    val_board(theap.data, board);\n    theap.space = heap[0].space;\n    theap.depth = heap[0].depth;\n    heap[0] = heap[--heapsize];\n    downheap(0);\n    for (i = 0; i < dir[theap.space]; i++) {\n      int next = to[theap.space][i], nboard[Size];\n      long long nval = swap(board, theap.space, next);\n      if (!hash_search(nval)) {\n        if (nval == Goal_val) return theap.depth + 1;\n        hash_insert(nval);\n        heap[heapsize].data = nval;\n        heap[heapsize].space = next;\n        heap[heapsize].depth = theap.depth + 1;\n        val_board(nval, nboard);\n        heap[heapsize++].score = fair_evaluate(nboard, goal) + theap.depth + 1;\n        upheap(heapsize - 1);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!puz[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b) {\n  int tmp;\n  tmp= *a;\n  *a= *b;\n  *b=tmp;\n}\n\nint cal() {\n  int i,a;\n  int sum=0;\n  for(i=0;i<9;i ++){\n    a=puz[i/3][i%3];\n    if(a){\n      a--;\n      sum+=abs(i/3-a/3)+abs(i%3-a%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0){\n    return dep;\n  }\n  if(dep+h>lim){\n    return -1;\n  }\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res=dfs(nx,ny,i,dep+1,lim);\n    if(~res){\n      return res;\n    }\n    swap(&puz[y][x],&puz[ny][nx]);\n    }\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puz[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j =0;j<3;j++){\n        tmp[i][j] = puz[i][j];\n      }\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        puz[i][j]=tmp[i][j];\n      }\n    }\n    ans= -1;\n    if(l==99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define Last (Total - 1)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\n\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n \n    int ori[Total] ={};\n    \n    \n    int i = 0;\n    int finish = 0;\n    int num_0,num_1 = 0;\n    int x,y = 0;\n     \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        ori[i]=val[i];\n        \n        if(val[i] == 0)\n        {\n            num_0 = i;\n        }\n    }\n    \n    x = tate - (num_0/yoko);\n    y = yoko - (num_0%yoko);\n    \n    while(finish==0)\n    {\n        // åæå\n        for(i=0; i<Total; i++)\n        {\n            val[i]=ori[i];\n        }\n        num = num_0;\n        cnt = 0;\n        \n        \n        left_0();\n        down_0();\n        right_0();\n        down_0();\n        \n//  printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);        \n        \n        finish = 1;\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                finish = 0;\n                break;\n            }\n        }\n    }\n     \n    printf(\"%d\\n\",cnt);\n \n    return 0;\n}\n \nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n    cnt = cnt + 1;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n    cnt = cnt + 1;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n    cnt = cnt + 1;\n}\n \nvoid left_0()\n{\n\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n    cnt = cnt + 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define MAX 362880\n#define N 3\n#define N2 9\n\n\ntypedef struct puzzle{\n  int f[N2];\n  int space;\n  int path;\n}PUZZLE;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint V[MAX];\n\nPUZZLE Q[MAX];\nint head, tail;\n\nvoid push(PUZZLE x){\n  Q[tail] = x;\n  tail = (tail+1)%MAX;\n}\n\nPUZZLE pop(){\n  PUZZLE x;\n  x = Q[head];\n  head = (head+1)%MAX;\n  return x;\n}\n\nint check(PUZZLE p){\n  int i, j, fac, count, res = 0;\n  for(i = 0, fac = 1; i < N2; fac*= ++i){\n    for(j = 0, count = 0; j < i; j++){\n      if(p.f[j] < p.f[i]) count++;\n    }\n    res += count*fac;\n  }\n  return res;\n}\n\nint isTarget(PUZZLE p){\n  int i;\n  for(i = 0; i < N2; i++ )\n    if(p.f[i] != (i + 1) )\n      return 0;\n  return 1;\n}\n\nint bfs(PUZZLE s){\n  int sx, sy, tx, ty, r, temp;\n  PUZZLE u, v;\n\n  s.path = 0;\n  push(s);\n  V[check(s)] = 1;\n\n  while(head != tail){\n    u = pop();\n\n    if( isTarget(u))\n      return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for ( r = 0; r < 4; r++ ) {\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)\n\tcontinue;\n      \n      v = u;\n      temp = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = temp;\n\n      v.space = tx * N + ty;\n\n      if( !V[check(v)] ){\n\tV[check(v)] = 1;\n\tv.path++;\n\tpush(v);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i, ans;\n  PUZZLE in;\n\n  for( i = 0; i < N2; i++ ) {\n    scanf(\" %d\", &in.f[i]);\n    if( in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  ans = bfs(in);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m[3][3];\nint copy[3][3];\n\nvoid input(void){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            scanf(\"%d\",&m[i][j]);\n        }\n    }\n}\nvoid output(void){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            printf(\"%3d\",m[i][j]);\n            puts(\"\");\n        }\n    }\n}\nvoid cp(int a[3][3],int b[3][3]){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            a[i][j] = b[i][j];\n        }\n    }\n}\nint calc(void){\n    int i,sum = 0;\n    for(i=0;i<9;i++){\n        int a = m[i/3][i%3];\n        if(a){\n            a--;\n            sum += abs(i/3 - a/3)+abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid swap(int *a, int *b){\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\nint in(int a,int b){\n    return 0<=a&&a<3&&0<=b&&b<3;\n}\nint df(int a,int b,int p,int d,const int lim){\n    int i , h=calc();\n    if(h == 0)return d;\n    if(d+h > lim)return -1;\n    \n    for(i=0;i<4;i++){\n        int x= a+dx[i],y=b+dy[i];\n        int res;\n        if(~p && i == (p+2)%4)continue;\n        if(!in(x,y))continue;\n        swap(&m[b][a],&m[y][x]);\n        res = df(x,y,i,d+1,lim);\n        if(~res)return res;\n        swap(&m[b][a],&m[y][x]);\n    }\n    return -1;\n}\n\nvoid empty(int *a, int *b){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            if(!m[i][j]){\n                *a = j;\n                *b = i;\n                return;\n            }\n        }\n    }\n}\nint s(void){\n    int a,b,lim,x;\n    empty(&a,&b);\n    for(lim = 0;lim < 50;lim++){\n        cp(copy,m);\n        if((x = df(a,b,-1,0,lim)) != -1)return x;\n        cp(m,copy);\n    }\n    return -1;\n}\nint main(){\n    input();\n    printf(\"%d\\n\",s());\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n????\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define PUZZLE_SIZE 3\n#define DIRECTION_SIZE 4\n#define RESOLVED_PUZZLE_KEY 123456780\n#define DEFAULT_QUEUE_SIZE 16\n\ntypedef enum { UP, DOWN, RIGHT, LEFT } direction_t;\ntypedef struct { int row, col; } cell_t;\ntypedef struct { int cnt, size, key, **p; cell_t zero; } state_t;\ntypedef struct { int head, tail, size, max; state_t **arr; } queue_t;\ntypedef struct Node { int bf, x; struct Node *p, *l, *r; } node_t;\n\nstatic queue_t *new_queue(int);\nstatic void free_queue(queue_t *);\nstatic void enqueue(queue_t *, state_t *);\nstatic state_t *dequeue(queue_t *);\n\nstatic node_t *new_node(int);\nstatic void free_node(node_t *);\nstatic void insert_node(node_t *, node_t *);\nstatic node_t *find_node(node_t *, int);\nstatic node_t *rotate_left(node_t *);\nstatic node_t *rotate_right(node_t *);\nstatic node_t *rebalance(node_t *);\n\nstatic state_t *new_state(int);\nstatic state_t *copy_state(const state_t *);\nstatic void free_state(state_t *);\nstatic int advance_state(state_t *, direction_t);\nstatic void update_state_key(state_t *);\n\nstatic queue_t *new_queue(int size) {\n  queue_t *q;\n  int i;\n\n  q = (queue_t *) malloc(sizeof(queue_t));\n  q->head = q->tail = q->size = 0;\n  q->max = size;\n  q->arr = (state_t **) malloc(sizeof(state_t *) * q->max);\n  for (i = 0; i < q->max; ++i) q->arr[i] = NULL;\n  return q;\n}\n\nstatic void free_queue(queue_t *q) {\n  while (q->head < q->tail) {\n    free_state(q->arr[q->head]);\n    q->head = (q->head + 1) % q->max;\n  }\n  free(q->arr);\n  free(q);\n}\n\nstatic void enqueue(queue_t *q, state_t *s) {\n  int i, range, expanded;\n\n  q->size++;\n  if (q->size == q->max) {\n    range = q->max - q->head;\n    expanded = q->max;\n    q->max *= 2;\n    q->arr = (state_t **) realloc(q->arr, sizeof(state_t *) * q->max);\n    if (q->head > q->tail) {\n      for (i = q->max - 1; i >= q->tail; --i) q->arr[i] = (i >= q->max - range) ? q->arr[i - expanded] : NULL;\n      q->head = q->max - range;\n    }\n  }\n  q->arr[q->tail] = s;\n  q->tail = (q->tail + 1) % q->max;\n}\n\nstatic state_t *dequeue(queue_t *q) {\n  state_t *s;\n\n  if (q->size == 0) return NULL;\n  s = q->arr[q->head];\n  q->arr[q->head] = NULL;\n  q->head = (q->head + 1) % q->max;\n  q->size--;\n  return s;\n}\n\nstatic node_t *new_node(int x) {\n  node_t *n;\n\n  n = (node_t *) malloc(sizeof(node_t));\n  n->p = n->l = n->r = NULL;\n  n->x = x;\n  n->bf = 1;\n  return n;\n}\n\nstatic void free_node(node_t *n) {\n  if (n == NULL) return;\n  free_node(n->l);\n  free_node(n->r);\n  free(n);\n}\n\nstatic void insert_node(node_t *r, node_t *n) {\n  if (n->x < r->x) {\n    if (r->l == NULL) {\n      r->l = n;\n      n->p = r;\n    } else {\n      insert_node(r->l, n);\n    }\n  } else if (n->x > r->x) {\n    if (r->r == NULL) {\n      r->r = n;\n      n->p = r;\n    } else {\n      insert_node(r->r, n);\n    }\n  }\n}\n\nstatic node_t *find_node(node_t *n, int x) {\n  node_t *ret;\n\n  if (n == NULL) {\n    ret = NULL;\n  } else if (x == n->x) {\n    ret = n;\n  } else if (x < n->x) {\n    ret = find_node(n->l, x);\n  } else if (x > n->x) {\n    ret = find_node(n->r, x);\n  } else {\n    ret = NULL;\n  }\n  return ret;\n}\n\nstatic node_t *rotate_left(node_t *n) {\n  node_t *p, *r;\n\n  if (n == NULL) return n;\n\n  p = n->p;\n  r = n->r;\n\n  if (p != NULL) {\n    if (p->x > r->x) {\n      p->l = r;\n    } else {\n      p->r = r;\n    }\n  }\n\n  n->p = r;\n  n->r = r->l;\n  n->bf = r->bf - 1;\n\n  r->p = p;\n  r->l = n;\n\n  return r;\n}\n\nstatic node_t *rotate_right(node_t *n) {\n  node_t *p, *l;\n\n  if (n == NULL) return n;\n\n  p = n->p;\n  l = n->l;\n\n  if (p != NULL) {\n    if (p->x > l->x) {\n      p->l = l;\n    } else {\n      p->r = l;\n    }\n  }\n\n  n->p = l;\n  n->l = l->r;\n  n->bf = l->bf - 1;\n\n  l->p = p;\n  l->r = n;\n\n  return l;\n}\n\nstatic node_t *rebalance(node_t *n) {\n  int l, r;\n\n  if (n == NULL) return n;\n  l = n->l == NULL ? 0 : n->l->bf;\n  r = n->r == NULL ? 0 : n->r->bf;\n  n->bf = (l > r ? l : r) + 1;\n  if ((l - r < 0 ? (l - r) * -1 : l - r) > 1) {\n    if (l < r) {\n      n = rotate_left(n);\n    } else {\n      n = rotate_right(n);\n    }\n  }\n  return n->p ? rebalance(n->p) : n;\n}\n\nstatic state_t *new_state(int size) {\n  state_t *s;\n  int i;\n\n  s = (state_t *) malloc(sizeof(state_t));\n  s->size = size;\n  s->cnt = s->zero.row = s->zero.col = s->key = 0;\n  s->p = (int **) malloc(sizeof(int *) * s->size);\n  for (i = 0; i < s->size; ++i) s->p[i] = (int *) malloc(sizeof(int) * s->size);\n  return s;\n}\n\nstatic state_t *copy_state(const state_t *src) {\n  state_t *dest;\n  int i, j;\n\n  dest = new_state(src->size);\n  dest->cnt = src->cnt;\n  dest->zero = src->zero;\n  dest->key = src->key;\n  for (i = 0; i < dest->size; ++i) {\n    for (j = 0; j < dest->size; ++j) dest->p[i][j] = src->p[i][j];\n  }\n  return dest;\n}\n\nstatic void free_state(state_t *s) {\n  int i;\n\n  for (i = 0; i < s->size; ++i) free(s->p[i]);\n  free(s->p);\n  free(s);\n}\n\nstatic int advance_state(state_t *s, direction_t d) {\n  switch (d) {\n    case UP:\n      if (s->zero.row + 1 == s->size) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row + 1][s->zero.col];\n      s->zero.row++;\n      break;\n    case DOWN:\n      if (s->zero.row - 1 < 0) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row - 1][s->zero.col];\n      s->zero.row--;\n      break;\n    case RIGHT:\n      if (s->zero.col - 1 < 0) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row][s->zero.col - 1];\n      s->zero.col--;\n      break;\n    case LEFT:\n      if (s->zero.col + 1 == s->size) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row][s->zero.col + 1];\n      s->zero.col++;\n      break;\n  }\n  s->p[s->zero.row][s->zero.col] = 0;\n  update_state_key(s);\n  s->cnt++;\n  return 0;\n}\n\nstatic void update_state_key(state_t *s) {\n  int i, j, d;\n\n  for (i = 0, d = 1; i < (s->size * s->size - 1); ++i, d *= 10) {}\n  for (i = s->key = 0; i < s->size; ++i) {\n    for (j = 0; j < s->size; ++j, d /= 10) {\n      s->key += s->p[i][j] * d;\n    }\n  }\n}\n\nstatic int eight_puzzle(const state_t *s) {\n  direction_t d[DIRECTION_SIZE] = {UP, DOWN, RIGHT, LEFT};\n  state_t *s1, *s2;\n  node_t *root, *node;\n  queue_t *q;\n  int cnt, fail, i;\n\n  cnt = -1;\n  q = new_queue(DEFAULT_QUEUE_SIZE);\n  s1 = copy_state(s);\n  enqueue(q, s1);\n  root = new_node(s1->key);\n\n  // BFS\n  while (q->size > 0) {\n    s1 = dequeue(q);\n    if (s1 == NULL) break; // unsolvable or bug\n    if (s1->key == RESOLVED_PUZZLE_KEY) {\n      cnt = s1->cnt;\n      free_state(s1);\n      break;\n    }\n    for (i = 0; i < DIRECTION_SIZE; ++i) {\n      s2 = copy_state(s1);\n      fail = advance_state(s2, d[i]);\n      node = find_node(root, s2->key);\n      if (fail || node) {\n        free_state(s2);\n        continue;\n      }\n      enqueue(q, s2);\n      node = new_node(s2->key);\n      insert_node(root, node);\n      root = rebalance(root);\n    }\n    free_state(s1);\n  }\n\n  free_queue(q);\n  free_node(root);\n  return cnt;\n}\n\nint main(int argc, char **argv) {\n  state_t *s;\n  int i, j;\n\n  for (i = 0, s = new_state(PUZZLE_SIZE); i < s->size; ++i) {\n    for (j = 0; j < s->size; ++j) {\n      scanf(\"%d\", &s->p[i][j]);\n      if (s->p[i][j] == 0) {\n        s->zero.row = i;\n        s->zero.col = j;\n      }\n    }\n  }\n  update_state_key(s);\n  printf(\"%d\\n\", eight_puzzle(s));\n  free_state(s);\n}\n"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h> \n#include <stdlib.h> \n#define n_max 500000000\nint p_8_8sul[3][3]; \nint k_3_3_template[3][3]; \nint deleta_x_j[4] = {0,1,0,-1}; \nint deleta_y_j[4] = {1,0,-1,0}; \n\n\nvoid ch_em_k(int *x,int *y);\nvoid ch_sw_k(int *a,int *b);\nint ch_cl_k();\nint ch_df_k(int x,int y,int p,int dep,const int lim);\nvoid o_check1_kaisuu(int );\nvoid o_ch_kaisuu(int );\nvoid o_ch3_kaisuu(int );  \n\n   \nint main() { \n  int i,j,cout_ans,x,y,l,n[n_max],h[n_max];\n  char p[n_max],liok[n_max];\n    int chchch=0;\n    int macc;\n    int dett;\n    int check[5000000000];\n    for(int dett=0;dett<9;dett++){\n      macc=macc*macc;\n    }\n    for(dett=0;dett<macc;dett++){\n      p[dett]='y';\n      liok[dett]='o';\n    }\n    \n    \n    for(i=0; i<3; i++){ \n        for(j=0; j<3; j++) scanf(\"%d\",&p_8_8sul[i][j]); \n    }\n    /*chchch++;\n      printf(\"%d\",chchch);*/\n    ch_em_k(&x,&y); \n    for(l=0; l<100; l++){ \n        for(i=0; i<3; i++){ \n            for(j=0; j<3; j++) k_3_3_template[i][j] = p_8_8sul[i][j];\n\t    /*chchch++;\n\t      printf(\"%d\",chchch);*/\n        } \n           \n        cout_ans = ch_df_k(x,y,-1,0,l); \n        if(cout_ans!=-1){ \n            printf(\"%d\\n\",cout_ans); \n            break; \n        } \n           \n        for(i=0; i<3; i++){ \n            for(j=0; j<3; j++) p_8_8sul[i][j] = k_3_3_template[i][j]; \n        } \n        /*chchch++;\n\t  printf(\"%d\",chchch);*/   \n        cout_ans = -1; \n        if(l==99) printf(\"%d\\n\",cout_ans); \n    } \n       \n    return 0; \n}\n\n\n\n\nvoid ch_em_k(int *x,int *y) { \n  int i,j; \n  for(i=0; i<3; i++) { \n    for(j=0; j<3; j++) { \n      if(!p_8_8sul[i][j]) { \n*x = j; \n*y = i; \nreturn; \n      } \n    } \n  } \n} \n\nvoid o_check_kaisuu(int w){\n  int i=0;\n  int m=9;\n  int check[5000000000];\n  for(i=0;i<9;i++){\n    m=m*m;\n  }\n  for(i=0;i<m;i++){\n    check[i]=m;\n  }\n}\n\n\n\n\n\nvoid ch_sw_k(int *a,int *b){ \n  int k_3_3_template; \n  k_3_3_template = *a; \n  *a = *b; \n  *b = k_3_3_template; \n} \n   \nint ch_cl_k(){ \n  int i,a,a_b_p_p=0;  \n  for(i=0; i<9; i++){ \n    a = p_8_8sul[i/3][i%3]; \n    if(a){ \n      a--; \n      a_b_p_p += abs(i/3 - a/3) + abs(i%3 - a%3); \n    } \n  }     \n  return a_b_p_p; \n} \n\nvoid o_ch_kaisuu(int w){\n  int i=0;\n  int m=8;\n  int check[5000000000];\n  for(i=0;i<8;i++){\n    m=m*m;\n  }\n  for(i=0;i<m;i++){\n    check[i]=m;\n  }\n}\n\n\n\n\n\nint ch_df_k(int x,int y,int p,int dep,const int lim){ \n    int i,h,nx,ny,res;    \n    h = ch_cl_k(); \n    if(h==0) return dep; \n    if(dep+h>lim) return -1;  \n    for(i=0; i<4; i++){ \n        nx = x+deleta_x_j[i]; \n        ny = y+deleta_y_j[i];       \n        if(~p && i==(p+2)%4) continue; \n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;     \n        ch_sw_k(&p_8_8sul[y][x],&p_8_8sul[ny][nx]); \n        res = ch_df_k(nx,ny,i,dep+1,lim); \n        if(~res) return res;        \n        ch_sw_k(&p_8_8sul[y][x],&p_8_8sul[ny][nx]); \n    }    \n    return -1; \n}\n\n\n\n\n\nvoid o_ch3_kaisuu(int w){\n  int i=0;\n  int m=7;\n  int check[5000000000];\n  for(i=0;i<7;i++){\n    m=m*m;\n  }\n  for(i=0;i<m;i++){\n    check[i]=m;\n  }\n}\n\n\n/*#include <stdio.h>\n#include <stdbool.h>\n\n\n#define Niii 8\n#define freeqqq -1\n#define not_freewww 1\n\nvoid inter(void);\nvoid board(void);\nvoid recursive(int );\n\nint row[Niii],col[Niii],dpos[2*Niii-1],dneg[2*Niii-1];\n\nbool X[Niii][Niii];\n\n\n\nint main()\n{\n  inter();\n\n  for(int i=0;i<Niii;i++){\n    for(int j=0;j<Niii;j++){\n      X[i][j]=false;\n\n    }\n  }\n\n  int k;\n  scanf(\"%d\",&k);\n  for(int i=0;i<k;i++){\n    int r,c;\n    scanf(\"%d%d\",&r,&c);\n    X[r][c]=true;\n  }\n\n  recursive(0);\n  return 0;\n}\n\n\n\nvoid inter(){\n  int i;\n  for(i=0;i<Niii;i++){\n    row[i]=freeqqq;\n    col[i]=freeqqq;\n  }\n  for(i=0;i<2*Niii-1;i++){\n    dpos[i]=freeqqq;\n    dneg[i]=freeqqq;\n  }\n}\n\n\nvoid board(){\n  int i,j;\n  for(i=0;i<Niii;i++){\n    for(j=0;j<Niii;j++){\n      if(X[i][j]){\n\tif(row[i]!=j)return;\n      }\n    }\n  }\n  for(i=0;i<Niii;i++){\n    for(j=0;j<Niii;j++){\n      if(row[i]==j){\n\tprintf(\"Q\");\n      }\n      else{\n\tprintf(\".\");\n      }\n    }\n    printf(\"\\n\");\n  }\n}\n\n\nvoid recursive(int i){\n  if(i==Niii){\n    board();return;\n  }\n  for(int j=0;j<Niii;j++){\n    if(not_freewww==col[j] || not_freewww==dpos[i+j] || not_freewww==dneg[i-j+Niii-1])continue;\n    row[i]=j;\n    col[j]=not_freewww;\n    dpos[i+j]=not_freewww;\n    dneg[i-j+Niii-1]=not_freewww;\n    recursive(i+1);\n    row[i]=col[j]=dpos[i+j]=dneg[i-j+Niii-1]=freeqqq;\n  }\n}\n*/\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\nint ansArr[N][N]={{1,2,3},\n                  {4,5,6},\n                  {7,8,0}};\nint tempArr[N][N];\nint curMinCost=30;\nvoid calcMinCost(int);\nint get0Row(void);\nint get0Col(void);\nint isCorrect(void);\nvoid printArr(void);//debugging\nint main(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      scanf(\"%d\",&tempArr[i][j]);\n  calcMinCost(0);\n  printf(\"%d\\n\",curMinCost);\n  return 0;\n}\nvoid calcMinCost(int cost)\n{\n  int row,col;\n  //printArr();\n  if(cost>=curMinCost) return;\n  if(isCorrect()==1)\n    {\n      curMinCost=cost;\n      return;\n    }\n  row=get0Row();\n  col=get0Col();\n  if(row!=N-1)//slide up\n    {\n      tempArr[row][col]=tempArr[row+1][col];\n      tempArr[row+1][col]=0;\n      calcMinCost(cost+1);\n      tempArr[row+1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=N-1)//slide left\n    {\n      tempArr[row][col]=tempArr[row][col+1];\n      tempArr[row][col+1]=0;\n      calcMinCost(cost+1);\n      tempArr[row][col+1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(row!=0)//slide down\n    {\n      tempArr[row][col]=tempArr[row-1][col];\n      tempArr[row-1][col]=0;\n      calcMinCost(cost+1);\n      tempArr[row-1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=0)//slide right\n    {\n      tempArr[row][col]=tempArr[row][col-1];\n      tempArr[row][col-1]=0;\n      calcMinCost(cost+1);\n      tempArr[row][col-1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n}\nint get0Row(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return i;\n}\nint get0Col(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return j;\n}\nint isCorrect(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(ansArr[i][j]!=tempArr[i][j]) return 0;\n  return 1;\n}\nvoid printArr(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n        {\n          printf(\"%d \",tempArr[i][j]);\n        }\n      printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define N 3\n#define N2 9\n\ntypedef struct{\n  int f[N2];\n  int space;\n  //char path[20];\n  int path;\n}Puz;\n\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n//char dir[4]={'u','l','d','r'};\n//Puz V[N2];\n//int vv[N2];\n\nint tail=0,head=0;\nPuz queue[2000000];\nint cnt=0,key;\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\ntypedef struct node * Node;\n#define NIL NULL\n\nNode root;\n\nvoid insert(int k){\n  Node y = NIL;\n  Node x = root;\n  Node z;\n\n  z = malloc(sizeof(struct node));\n  z->key = k;\n  z->left = NIL;\n  z->right = NIL;\n\n  while(x!=NIL){\n    y=x;\n    if(z->key < x->key) x = x->left;\n    else x = x->right;\n  }\n  z->parent = y;\n\n  if(y==NIL)root=z;\n  else if(z->key < y->key)y->left = z;\n  else y->right = z;\n  \n}\n\nNode treeSearch(Node u, int k){\n\n  while(u!=NIL && k != u->key){\n    if(k < u->key)u = u->left;\n    else u = u->right;\n  }\n  return u;\n}\n\n/*\n\nvoid in(Puz p){\n  int i,ten;\n  ten=1;\n  v[cnt]=0;\n  for(i=0;i<N2;i++){\n    v[cnt]+=(ten*p.f[i]);\n    ten*=10;\n    }\n   v[cnt]=key;\n   printf(\"aaaa %d,%d\\n\",v[cnt],cnt);\n  cnt++;\n \n  }*/\n\nint search(Puz p){\n  int i,ten;\n  ten=1;\n  key=0;\n  for(i=0;i<N2;i++){\n    key+=(ten*p.f[i]);\n    ten*=10;\n  }\n  // printf(\"bbbb %d\\n\",key);\n  // printf(\"bbbb %d\\nbbbb %d\\n\\n\",key,v[i]);\n     if(treeSearch(root,key)==NIL){\n       //printf(\"ddddddddddddddddddddddddd\\n\");\n\treturn -1;\n      }\n  return 1;\n}\n\n\n\nPuz pop(void){\n\n  head=(head+1)%2000000;\n  return queue[head];\n}\nvoid push(Puz c){\n  tail=(tail+1)%2000000;\n  queue[tail]=c;\n}\n\nint istarget(Puz p){\n  int i;\n  for(i=0;i<N2;i++){\n    if(p.f[i]!=(i+1))return 0;\n  }\n  return 1;\n}\n\nint bfs(Puz s){\n  Puz u,v;\n  int tmp,i;\n  int sx;\n  int sy;\n  int tx,ty;\n  int r;\n  int len=0;\n  //s.path[0] = ' ';\n  s.path=0;\n  push(s);\n  // V[s]=1;\n  while(head!=tail){\n    u=pop();\n    //printf(\"head:%d,tail:%d\\n\",head,tail);\n    if(istarget(u)){\n      // printf(\"bbb\\n%d %d %d\\n%d %d %d\\n%d %d %d\\n\\n\",u.f[0],u.f[1],u.f[2],u.f[3],u.f[4],u.f[5],u.f[6],u.f[7],u.f[8]);\n      //return strlen(u.path);\n      return u.path;\n    }\n    sx=u.space/N;\n    sy=u.space%N;\n    for(r=0;r<4;r++){\n      tx=sx+dx[r];\n      ty=sy+dy[r];\n      // printf(\"%d %d\\n\",tx,ty);\n      if(tx<0 || ty<0 || tx>=N ||ty>=N)continue;\n      v=u;\n      // v.ff = dir[r];\n      tmp=v.f[u.space];\n      v.f[u.space]=v.f[tx*N+ty];\n      v.f[tx*N+ty]=tmp;\n      v.space=tx*N+ty;\n      //printf(\"(%d,%d) path:%d\\n\",u.space,tx*N+ty,v.path);\n      //printf(\"aaa\\n%d %d %d\\n%d %d %d\\n%d %d %d\\n\",v.f[0],v.f[1],v.f[2],v.f[3],v.f[4],v.f[5],v.f[6],v.f[7],v.f[8]);\n    \n      if(search(v)==1)continue;\n      \n      insert(key);\n      v.path++;\n      push(v);\n    }\n  }\n  return 0;\n}\n\nint main(){\n\n  int i,j;\n  Puz in;\n  \n  for(i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      //in.ff=NULL;\n      in.space = i;\n    }\n  }\n\n  printf(\"%d\\n\",bfs(in));\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //åããåã®ãã¼ã\n  node *next; //ãªã¹ãä¸ã®æ¬¡ã®ãã¼ã\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tã«openãªã¹ãã®åé ­ãæ¸¡ã\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\", open->p->g);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint ans[3][3] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint match(int f[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (f[i][j] != ans[i][j])\n                return 0;\n        }\n    }\n    return 1;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l) {\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            scanf(\"%d\", &f[i][j]);\n            if (f[i][j] == 0) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 50; ++i) {\n        if ((res = dfs(f, x, y, -1, 0, i)) >= 0) {\n            break;\n        }\n    }\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n  int ban[3*3], sp, MD, p[3][3];  \n}Record;\n\nvoid IDA(Record); \nint Manhat(Record);\nint dfs(int, int);\n\nint cnt = 0, ans[3][3], size, limit, stack[3], time, path[100];\nint dx[4] = {0, -1, 0, 1}; \nint dy[4] = {1, 0, -1, 0};\nint MDT[3*3][3*3];\nchar dir[4] = {'r','u','l','d'}; \nchar an[100];\nRecord data, in;\n\nint main () {\n  int i, j, k = 0, m = 0, l = 0;\n\n\n  for(i = 0 ; i < 3*3 ; i++) {\n    for(j = 0 ; j < 3*3 ; j++) {\n      m = i / 3 - j / 3;\n      l = i % 3 - j % 3;\n\n      if(m < 0) m = -1 * m;\n      if(l < 0) l = -1 * l;\n      MDT[i][j] = m + l;\n    }\n  }\n\n  for(i = 0 ; i < 3*3 ; i++) {\n      scanf(\"%d\",&in.ban[i]);\n\n      if(in.ban[i] == 0) {\n\tin.ban[i] = 3*3;\n\tin.sp = i;\n}\n}\n\n  IDA(in);\n \n  printf(\"%d\\n\",strlen(an));\n\n  return 0;\n}\n\nint Manhat(Record A) {\n  int d = 0, i;\n  \n  for(i = 0 ; i < 3 * 3 ; i++) {\n    if(A.ban[i] == 3*3) continue;\n    d += MDT[i][A.ban[i]-1];\n  }\n\n  return d;\n}\n\nint dfs(int def, int prev) {\n  int sx = 0, sy = 0, i, j, tx = 0, ty = 0, max = 0, min = 0, t1;\n  Record tmp;\n\n  if(data.MD == 0) return 1;\n\n  if(def + data.MD > limit) return -1;\n\n  sx = data.sp / 3;\n  sy = data.sp % 3;\n\n  for(i = 0 ; i < 4 ; i++) {\n    tx = sx + dx[i];\n    ty = sy + dy[i];\n\n    if(tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\n    if(prev > i) {\n      max = prev;\n      min = i;\n    }\n\n    else {\n      max = i;\n      min = prev;\n    }\n\n    if(max - min == 2) continue;\n\n    tmp = data;\n    data.MD -= MDT[tx * 3 + ty][data.ban[tx * 3 + ty]-1]; \n    data.MD += MDT[sx * 3 + sy][data.ban[tx * 3 + ty]-1];\n    t1 = data.ban[tx * 3 + ty];\n    data.ban[tx * 3 + ty] = data.ban[sx * 3 + sy];\n    data.ban[sx * 3 + sy] = t1;\n\n    data.sp = tx * 3 + ty;\n\n    if(dfs(def + 1, i) == 1) {\n      path[def] = i;\n      return 1;\n    }\n\n    data = tmp;\n  }\n  \n  return -1;\n}\n\n\nvoid IDA(Record A) {\n  int i, cnt = 0, j = 0;\n  \n  in.MD = Manhat(in);\n\n  for(limit = in.MD ; limit <= 100 ; limit++) {\n    data = in;\n\n    if(dfs(0, -100) == 1) {\n      for(i = 0 ; i < limit ; i++) {\n   \n\tan[j] = dir[path[i]];\n\tj++;\n      }\n      an[j] = '\\0';\n      return;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}};\n\nint min = LIM;\nint h[997];\n\nint hash(int a)\n{\n  return a%997;\n}\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  //printf(\"A\\n\");\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  if(ans[i][j]!=p[i][j])f++;\n\t  if(p[i][j]==0)\n\t    {\n\t      i0=i;\n\t      j0=j;\n\t    }\n\t  a+=p[i][j]*b;\n\t  b*=10;\n\t}\n    }\n\n  if(f==0)\n    {\n      if(min>n)\n\t{\n\t  min=n;\n\t}\n      return;\n    }\n\n  f=hash(a);\n  if(n>LIM || h[f]!=0) return;\n\n  h[f]=1;\n  \n  if(i0>0 && i0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0-1][j0];\n      tmp[i0-1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>0 && j0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0-1];\n      tmp[i0][j0-1]=f;\n      dfs(tmp, n+1);\n    }\n  \n  if(i0>=0 && i0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0+1][j0];\n      tmp[i0+1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>=0 && j0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0+1];\n      tmp[i0][j0+1]=f;\n      dfs(tmp, n+1);\n    }\n  \n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  scanf(\"%d\",&p[i][j]);\n\t}\n    }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n??\nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n??\nvoid empty(int *x,int *y) {\n????int i,j;\n????for(i=0;i<3;i++){\n????????for(j=0;j<3;j++){\n????????????if(!puz[i][j]){\n????????????????*x=j;\n????????????????*y=i;\n????????????????return;\n????????????}\n????????}\n????}\n}\n??\nvoid swap(int *a, int *b) {\n????int tmp;\n????tmp= *a;\n????*a= *b;\n????*b=tmp;\n}\n??\nint cal() {\n????int i,a;\n????int sum=0;\n????for(i=0;i<9;i ++){\n????????a=puz[i/3][i%3];\n????????if(a){\n????????????a--;\n????????????sum+=abs(i/3-a/3)+abs(i%3-a%3);\n????????}\n????}\n????return sum;\n}\n??\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i,h,nx,ny,res;\n????h=cal();\n????if(h==0){\n????????return dep;\n????}\n????if(dep+h>lim){\n????????return -1;\n????}\n????for(i=0;i<4;i++){\n????????nx=x+dx[i];\n????????ny=y+dy[i];\n????????if(~p&&i==(p+2)%4) continue;\n????????if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n????????swap(&puz[y][x],&puz[ny][nx]);\n????????res=dfs(nx,ny,i,dep+1,lim);\n????????if(~res){\n????????????return res;\n????????}\n????????swap(&puz[y][x],&puz[ny][nx]);\n????????}\n????return -1;\n}\n??\nint main() {\n????int i,j,ans,x,y,l;\n????for(i=0;i<3;i++){\n????????for(j=0;j<3;j++){\n????????????scanf(\"%d\",&puz[i][j]);\n????????}\n????}\n????empty(&x,&y);\n????for(l=0;l<100;l++){\n????????for(i=0;i<3;i++){\n????????????for(j =0;j<3;j++){\n????????????????tmp[i][j] = puz[i][j];\n????????????}\n????????}\n????????ans=dfs(x,y,-1,0,l);\n????????if(ans!=-1){\n????????????printf(\"%d\\n\",ans);\n????????????break;\n????????}\n????????for(i=0;i<3;i++){\n????????????for(j=0;j<3;j++){\n????????????????puz[i][j]=tmp[i][j];\n????????????}\n????????}\n????????ans= -1;\n????????if(l==99){\n????????????printf(\"%d\\n\",ans);\n????????}\n????}\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int N = 8;\nint length;\n\nstruct Node {\n  int *board;\n  int h;\n  struct Node *parent;\n};\n\n\n// apparently most linkers don't auto include math.h even if you include the header file,\n// so I'm making bad sqrt for ints and ceiling functions\nint sqrt(int n) {\n  if (n == 0 || n == 1)\n    return n;\n\n  int i = 1, out = 1;\n  while (out <= n) {\n    i++;\n    out = i*i;\n  }\n\n  return i - 1;\n}\n\nint ceil(double n) {\n  if (n - (int) n > 0)\n    return (int) n + 1;\n  else\n    return (int) n;\n}\n\n\nint heuristic(int *board) {\n  int i, j, curx, counter = 0, dist = 0;\n\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < length; j++) {\n      if (board[counter] % 3 == 0)\n        curx = 3;\n      else\n        curx = board[counter] % 3;\n\n      if (board[counter] != 0)\n        dist += abs(curx -(j + 1)) + abs(ceil((double) board[counter] / 3.0) - (i + 1));\n      counter++;\n    }\n  }\n\n  //printf(\"manhattan distance is: %d\\n\", dist);\n  return dist;\n}\n\nint main() {\n  int i, j;\n  length = sqrt(N + 1);\n  int *board = malloc(length * length * sizeof(int));\n\n  //printf(\"printing input board:\\n\");\n\n  for (i = 0; i < length * length; i++) {\n    scanf(\"%d\", &board[i]);\n    /*\n    if ((i + 1) % 3 == 0)\n      printf(\"%d\\n\", board[i]);\n    else\n      printf(\"%d \", board[i]);\n    */\n  }\n\n  printf(\"%d\\n\", heuristic(board));\n  return;\n\n  /*\n  struct Node root;\n  root.board = board;\n  root.h = heuristic(board);\n  root.parent = NULL;\n  */\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 15\ntypedef struct{\n    int A[N][N];\n}Pazzle;\nPazzle P;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n int hoge;\n hoge=*A;\n *A=*B;\n *B=hoge;\n \n \n}\n\nint check(Pazzle P){\n    int sum=0,i,j,hy,hx;\n    for(i=0;i<N;i++){\n \n    for(j=0;j<N;j++){\n        if(P.A[i][j]==0)\n        continue;\n        hy=(P.A[i][j]-1)/N-i;\n        hx=(P.A[i][j]-1)%N-j;\n        if(hy<0)\n        sum-=hy;\n        else\n        sum+=hy;\n        if(hx<0)\n        sum-=hx;\n        else\n        sum+=hx;\n \n \n}\n}\n \nreturn sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int m){\n         int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;   \n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1; \n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if((m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N)) continue;    \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,i);\n    if(ans!=-1) return ans;       \n     swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }   \n  return -1;\n}\n\nint main(void){\n    Pazzle t_P;\n    int  i,j,ans;\n    int x0,y0;\n\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&P.A[i][j]);\n            if(P.A[i][j]==0){\n                x0=j;\n                y0=i;\n                \n            }\n            \n        }\n    }\n    t_P=P;\n    for(i=1;i<46;i++){\n        P=t_P;\n    ans=dfs(x0,y0,i,0,-1);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n    }\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n????\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define LIMIT 30\n\nint piace[N][N]; //ããºã«\nint tmp[N][N]; //ä¿å­\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint result;\n\nint dfs(int ,int ,int ,int ,int );\nint cal();\n\n\nint main(){\n  int i,j,k=0;\n  int x,y;\n\n\n  for(i = 0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&piace[i][j]);\n    }\n  }\n\n  for(i = 0 ;i <N ;i++){\n    for(j = 0;j<N;j++){\n      if(piace[i][j]==0){\n\tx = j;\n\ty = i;\n      }\n    }\n  }\n\n  while(1){\n\n    for(i = 0;i<N;i++){\n      for(j = 0;j<N;j++){\n\ttmp[i][j] = piace[i][j];\n      }\n    }\n\n    result = dfs(x,y,-1,0,k);\n\n    if(result !=-1){\n      printf(\"%d\\n\",result);\n      break;\n    }\n\n    for(i =0;i<N;i++){\n      for(j=0;j<N;j++){\n\tpiace[i][j] = tmp[i][j];\n      }\n    }\n\n    result = -1;\n\n    k++;\n\n    }\n\n    \n  \n     \n  return 0;\n}\n\n \nint dfs(int x,int y,int p,int depth,int l){ //depth first search\n  int i;\n  int sum;\n  int x_2,y_2;\n  int res;\n\n\n  int hozon;\n  \n  sum = cal();\n  \n  if(sum==0) {\n    return depth;\n  }\n  \n  if(depth+sum > l) {\n    return -1;\n  }\n   \n  for(i=0;i<4;i++){\n    x_2 = x+dx[i];\n    y_2 = y+dy[i];\n    \n    if(p!=-1 && i ==(p+2)%4) continue;\n\n    if(x_2 < 0 || x_2 >= 3 || y_2 < 0 || y_2 >= 3) continue;\n \n\n    hozon=piace[y][x];\n    piace[y][x]=piace[y_2][x_2];\n    piace[y_2][x_2]=hozon;\n\n \n    res = dfs(x_2,y_2,i,depth+1,l);\n     \n    if(res!=-1) {\n      return res;\n    }\n\n    hozon=piace[y][x];\n    piace[y][x]=piace[y_2][x_2];\n    piace[y_2][x_2]=hozon;\n  }\n  return -1;\n}\n \nint cal(){\n  int i;\n  int hozon;\n  int sum=0;\n\n  int z[2]; //çµ¶å¯¾å¤\n\n  for(i = 0;i < 9;i++){\n\n    hozon = piace[i/3][i%3];\n    \n    if(hozon!=0) {\n      hozon--;\n\n      z[0]= i/3 - hozon/3;\n      if(z[0]<0)z[0]*=-1;\n\n      z[1]= i%3 - hozon%3;\n      if(z[1] < 0)z[1]*=-1;\n\n\n      sum += z[0] + z[1];\n    }\n  }\n  return sum;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\nint A[N][N] = {\n\t{1,2,3},\n\t{4,5,6},\n\t{7,8,0},\n};\nint Ax[9] = {2,0,1,2,0,1,2,0,1};\nint Ay[9] = {2,0,0,0,1,1,1,2,2};\nint C[N][N];\nint Puzzle_8(int,int,int);\nint manhattan();\nint main() {\n  int i, j, x, y;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j){\n      scanf(\"%d\",&C[i][j]);\n      if (C[i][j] == 0) {\n\tx = i;\n\ty = j;\n      }\n    }\n  }\n  for(i = 0;;i++){\n    //printf(\"%d\\n\",i);\n    if(Puzzle_8(x,y,i) == 1){\n      printf(\"%d\\n\",i);\n      break;\n    }\n  }\n  return 0;\n}\nint Puzzle_8(int x, int y,int tesu) {\n  int i,j,nextx,nexty;\n  int Dx[4] = {0,1,0,-1};\n  int Dy[4] = {1,0,-1,0};\n  // printf(\"%d\\n\",manhattan());\n\n  if (manhattan() == 0)return 1;\n  if(manhattan() > tesu){\n    return 0;\n  }\n  //ä¸ããæè¨åãã«èª¿ã¹ã¦ãã\n  for (i = 0; i < 4;i++) {\n    nextx = x + Dx[i];\n    nexty = y + Dy[i];\n    //0ãå ´å¤ã«åºã¦ãã¾ããªãæ¬¡ãè©¦ãã\n    if (0 > nextx || 0 > nexty || nextx > 2 || nexty > 2)continue;\n    C[x][y] = C[nextx][nexty];\n    C[nextx][nexty] = 0;\n    /*\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n      printf(\"%d\", C[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    //æ¬¡ãè©¦ã\n    if(Puzzle_8(nextx, nexty,tesu-1) == 1)return 1;\n    //åã«æ»ã\n    C[nextx][nexty] = C[x][y];\n    C[x][y] = 0;\n  }\n  return 0;\n}\nint manhattan(){\n  int i,j,x,y,sum = 0,key;\n  for(i =0;i < N;i++){\n    for(j= 0;j< N;j++){\n     key = C[i][j];\n     if(key == 0)continue;\n     x= j - Ax[key];\n     if(x < 0)x = (-1)*x;\n     y = i - Ay[key];\n     if(y < 0)y = (-1)*y;\n     sum = sum + x+y;\n   }\n  }\n  return sum;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define WHITE 0\n#define BLACK 1\n#define N 10000\n#define INF 1000000\n\nint d[N];\nint color[N];\nint w[N][N];\nint pi[N];\n\n\nvoid difkstra(int,int);\n\nint main()\n{\n    int i,n,j,k,c,u,v;\n    \n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            w[i][j]=-1;\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d%d\",&u,&k);\n        for(j=0;j<k;j++)\n        {\n            scanf(\"%d%d\",&v,&c);\n            w[u][v]=c;\n        }\n    }\n    difkstra(n,0);\n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%d %d\\n\",i,d[i]);\n    }\n    \n    return 0;\n}\n\nvoid difkstra(int n,int s)\n{\n    int i,j,u,v;\n    int mincost;\n    for(v=0; v<n; v++)\n    {\n        d[v] = INF;\n        pi[v]=-1;\n        color[v]=WHITE;\n    }\n    d[s]=0;\n    \n    while(1)\n    {\n        mincost=INF;\n        for(i=0;i<n;i++)\n        {\n            if(color[i]!=BLACK && d[i]<mincost)\n            {\n                mincost=d[i];\n                u=i;\n            }\n        }\n        if(mincost==INF)\n            break;\n        \n        color[u]=BLACK;\n        \n        for(v=0;v<n;v++)\n        {\n            if(color[v]!=BLACK && w[u][v]+d[u]<d[v] && w[u][v]>=0)\n            {\n                pi[v]=u;\n                d[v]=w[u][v]+d[u];\n            }\n        }\n        \n        \n    }\n    \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n  char s[10];\n  int f;\n  int h;\n  struct node *next;\n  struct node *back;\n}Node;\n\nvoid move_up(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-3];\n  s[x-3] = tmp;\n}\n\nvoid move_left(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-1];\n  s[x-1] = tmp;\n}\n\nvoid move_right(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+1];\n  s[x+1] = tmp;\n}\n\nvoid move_down(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+3];\n  s[x+3] = tmp;\n}\n\nint heuristic(char s[]) {\n  int h,i,d;\n  h = 0;\n  for (i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      h += 2-i%3 + 2-i/3;\n    }\n    else {\n      d = abs(s[i]-'0'-1 - i);\n      h += d%3 + d/3; \n    }\n  }\n  return h;\n}\n\nNode *add_list(Node *begin, char s[], int f, int h) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) {\n      if(p->f > f) p->f = f;\n      return begin;\n    }\n    p = p->next;\n  }\n  \n  p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->f = f;\n  p->h = h;\n  if(begin != NULL) begin->back = p;\n  p->next = begin;\n  p->back = NULL;\n  return p;\n}\n\nNode *remove_node(Node *begin, Node *p) {\n  if(p == begin) {\n    if(p->next != NULL) p->next->back = NULL;\n    return p->next;\n  }\n  p->back->next = p->next;\n  if(p->next != NULL) p->next->back = p->back;\n  return begin;\n}\n\nNode *move_node(Node *begin, Node *p) {\n  p->back = NULL;\n  p->next = begin;\n  if(begin != NULL) begin->back = p;\n  return p;\n}\n\nNode *search_node(Node *begin, char s[]) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) break;\n    p = p->next;\n  }\n  return p;\n}\n\nvoid open_node(Node **open, Node **close, char s[], int g) {\n  int f,h;\n  Node *p;\n  h = heuristic(s);\n  f = g + 1 + h;\n  p = search_node(*close,s);\n  if(p != NULL ) {\n    if(p->f > f) {\n      p->f = f;\n      *close = remove_node(*close,p);\n      *open = move_node(*open,p);\n    }\n  }\n  else {\n    *open = add_list(*open,s,f,h);\n  }\n}\n\nint solve(char s0[]) {\n  int x,g,min_f;\n  char s[10];\n  Node *open = NULL;\n  Node *close = NULL;\n  Node *p,*min;\n  open = add_list(open,s0,heuristic(s0),heuristic(s0));\n  while(1) {\n    p = open;\n    min_f = p->f;\n    min = p;\n    while(p != NULL) {\n      if(p->f < min_f) {\n  \tmin_f = p->f;\n  \tmin = p;\n      }\n      p = p->next;\n    }\n    strcpy(s,min->s);\n    //printf(\"%s\\n\",s);\n    if(strcmp(s,\"123456780\") == 0) break;\n    g = min_f - min->h;\n    open = remove_node(open,min);\n    close = move_node(close,min);\n    for (x = 0; x < 9; x++) if(s[x] == '0') break;\n    if(x > 2) {\n      move_up(s,x);\n      open_node(&open,&close,s,g);\n      move_down(s,x-3);\n    }\n    if(x < 6) {\n      move_down(s,x);\n      open_node(&open,&close,s,g);\n      move_up(s,x+3);\n    }\n    if(x%3 < 2) {\n      move_right(s,x);\n      open_node(&open,&close,s,g);\n      move_left(s,x+1);\n    }\n    if(x%3 > 0) {\n      move_left(s,x);\n      open_node(&open,&close,s,g);\n      move_right(s,x-1);\n    }\n  }\n  return min->f;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\ntypedef struct {\n  int B[3][3];\n}board;\n\nboard P,Q;\n\nint dfs(int,int,int,int,int);\nint heuri(void);\nvoid move(int,int);\n\nint main() {\n  int i, j,k, x, y, time;\n  board S;\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      scanf(\"%d\", &P.B[i][j]);\n      if (P.B[i][j] == 0) {\n\tx = j;\n\ty = i;\n      }\n    }\n  }\n\n  S = P;\n\n  for (i = 1; i < 46; i++) {\n    P = S;\n\n    time = dfs(x, y, i, 0, -1);\n    if (time != -1) {\n      printf(\"%d\\n\", time);\n      break;\n    }\n  }\n\n  return 0;\n}\n\nint dfs(int x, int y, int max, int cnt, int n) {\n  int i, temp, x0, y0, time, h;\n\n  h = heuri();\n  if (h == 0) return cnt;\n  else if (cnt + h > max) return -1;\n\n  for (i = 0; i < 4; i++) {\n    x0 = x + dx[i];\n    y0 = y + dy[i];\n\n    if ((i == (n + 2) % 4 && n != -1) || (x0 < 0 || 3 <= x0 || y0 < 0 || 3 <= y0)) continue;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n\n    time = dfs(x0, y0, max, cnt + 1, i);\n\n    if (time != -1) return time;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n  }\n\n  return -1;\n}\n\nint heuri() {\n  int i, j, x, y, sum = 0;\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      if (P.B[i][j] == 0) continue;\n\n      x = (P.B[i][j] - 1) % 3 - j;\n      y = (P.B[i][j] - 1) / 3 - i;\n\n      if (x < 0) sum -= x;\n      else sum += x;\n\n      if (y < 0) sum -= y;\n      else sum += y;\n    }\n  }\n\n  return sum;\n}\n\nvoid move(int x,int y){\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h> \n#define N 3\n  \nint search(int board[N][N], int min, int limit, int r_0, int c_0);\nint search(int board[N][N], int min, int limit, int r_0, int c_0){\n  int md_c;\n  int num;\n  int res[4];\n  if (min == 0){\n    return 0;\n  }\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else {\n\tres[0]++;\n      }\n    }\n    else{\n      res[0] = -1;\n    }\n  }\n  else{\n    res[0] = -1;\n  }\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[1]++;\n      }\n    }\n    else{\n      res[1] = -1;\n    }\n  } \n  else{\n    res[1] = -1;\n  }\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[2]++;\n      }\n    }\n    else{\n      res[2] = -1;\n    }\n  }\n  else{\n    res[2] = -1;\n  }\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      }\n      else{\n\tres[3]++;\n      }\n    }\n    else{\n      res[3] = -1;\n    }\n  }\n  else{\n    res[3] = -1;\n  }\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1){\n    return -1;\n  }\n  else if (res[0] != -1){\n    return res[0];\n  }\n  else if (res[1] != -1){\n    return res[1];\n  }\n  else if (res[2] != -1){\n    return res[2];\n  }\n  else {\n    return res[3];\n    }\n}\nint main(int argc, char *argv[]){\n  int board[N][N],md,i,j,r,c,r_0,c_0,found,res;\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++){\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  }\n\t  else{\n\t    md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  }\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1){\n\tbreak;\n      }\n    }\n  }\n  \n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n    }\n    else {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n    }\n    if (res != -1) break;\n  }  \n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define SIZE 9\n#define MAX 362880\n#define TRUE 1\n#define GOAL 2\n\n/*8ããºã«ã®ç¹ããç¤ºãé£æ¥ãªã¹ã*/\nint puzzle[SIZE][5]={\n  1,3,-1,-1,-1,  0,4,2,-1,-1,  1,5,-1,-1,-1,\n  0,4,6,-1,-1,   1,3,5,7,-1,   2,4,8,-1,-1,\n  3,7,-1,-1,-1,  4,6,8,-1,-1,  5,7,-1,-1,-1\n};\n\nint board[MAX][SIZE];  /*å±é¢*/\nint Space[MAX];        /*ã¹ãã¼ã¹ã®ä½ç½®*/\nint prev_board[MAX];\nint check_table[MAX];\nint init_board[SIZE];\nint goal_board[SIZE]={1,2,3,4,5,6,7,8,0};\n\nint change_num(int *);  /*å±é¢ãçªå·ã«å¤æ*/\nvoid Search(void);\nvoid print_answer(int);\n\nint main(){\n  int i;\n\n  for(i=0;i<SIZE;i++) scanf(\"%d\",&init_board[i]);\n\n  Search();\n\n  return 0;\n\n}\n  \n\nint change_num(int *board){\n  int work[SIZE];\n  int i,j,k,value=0;\n  int fact_table[SIZE]={40320,5040,720,120,24,6,2,1,0};\n\n  for(i=0;i<SIZE;i++) work[i]=board[i];\n\n  for(i=0;i<SIZE-1;i++){\n    value+=fact_table[i]*work[i];\n    for(j=i+1;j<SIZE;j++){\n      if(work[i]<work[j]) work[j]-=1;\n    }\n  }\n  return value;\n}\n\nvoid Search(void){\n  int i,j,k,n,s,front=0,rear=1,count=0,init,goal;\n\n  for(i=0;i<SIZE;i++){\n    board[0][i]=init_board[i];\n    if(init_board[i]==0) Space[0]=i;\n  }\n  prev_board[0]=-1;\n  init=change_num(init_board);\n  goal=change_num(goal_board);\n  check_table[init]=TRUE;\n  check_table[goal]=GOAL;\n\n  if(init==goal) {\n      print_answer(0);\n      return;\n  }\n  \n  while(front<rear){\n    s=Space[front];\n    for(i=0;(n=puzzle[s][i])!=-1;i++){\n      /*ç¶æã®ã³ãã¼*/\n      for(j=0;j<SIZE;j++) board[rear][j]=board[front][j];\n      board[rear][s]=board[rear][n]; /*ç©ºç½ã«ç§»å*/\n      board[rear][n]=0;\n      Space[rear]=n;\n      prev_board[rear]=front;\n      k=change_num(board[rear]);\n      if(check_table[k]==GOAL){\n\t/*çºè¦*/\n\tprint_answer(rear);\n\treturn;\n      }\n      \n      else if(!check_table[k]){\n\t  /*ã­ã¥ã¼ã«ç»é²*/\n\t  check_table[k]=TRUE;\n\t  rear++;\n\t}\n    }\n    front++;\n  }\n}\n\t\nvoid print_answer(int n){\n  int i,j,count=0;\n\n  while(n!=0){\n    count++;\n    n=prev_board[n];\n  }\n\n  printf(\"%d\\n\",count);\n\n  /* if(n!=0) print_answer(prev_board[n]); */\n\n  /* for(i=0;i<3;i++){ */\n  /*   for(j=0;j<3;j++){ */\n  /*     printf(\"%d \",board[n][i*3+j]); */\n  /*   } */\n  /*   printf(\"\\n\"); */\n  /* } */\n  /* printf(\"\\n\"); */\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint board[9];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < 8; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint A[3][3],tmp[3][3],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!A[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b) {\n  int tmp;\n  tmp= *a;\n  *a= *b;\n  *b = tmp;\n}\n\n\nint cal() {\n  int i,u,sum=0;\n  for(i=0;i<9;i ++){\n    u=A[i/3][i%3];\n    if(u != 0){\n      u--;\n      sum += abs(i/3 - u/3)+abs(i%3 - u%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x, int y, int p, int d, const int lim) {\n  int i,v,nx,ny,res;\n  v=cal();\n  if(v == 0) return d;\n  \n  if(d+v > lim) return -1;\n  \n  for(i=0;i<4;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p&&i == (p+2)%4) continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3)) continue;\n    swap(&A[y][x],&A[ny][nx]);\n    res=dfs(nx,ny,i,d+1,lim);\n\n    if(~res) return res;\n    \n    swap(&A[y][x],&A[ny][nx]);\n  }\n\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&A[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j =0;j<3;j++){\n        tmp[i][j] = A[i][j];\n      }\n    }\n    ans = dfs(x,y,-1,0,l);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        A[i][j]=tmp[i][j];\n      }\n    }\n\n    ans = -1;\n\n    if(l == 99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define TRUE  1\n#define FALSE 0\n#define FORWARD  1\n#define BACKWARD 2\n#define SIZE  9\n#define NIL   (-1)\n\n/* ç¶ææ° (9! / 2) */\n#define MAX_STATE 181440\n\n/* é£æ¥ãªã¹ã */\nconst char adjacent[SIZE][5] = {\n  1, 3,-1,-1,-1,\n  0, 4, 2,-1,-1,\n  1, 5,-1,-1,-1,\n  0, 4, 6,-1,-1,\n  1, 3, 5, 7,-1,\n  2, 4, 8,-1,-1,\n  3, 7,-1,-1,-1,\n  4, 6, 8,-1,-1,\n  5, 7,-1,-1,-1,\n};\n\n/* ã­ã¥ã¼ */\nchar state[MAX_STATE + 1][SIZE];      /* +1 ã¯ã¯ã¼ã¯é å */\nchar space_postion[MAX_STATE];\nint  prev_state[MAX_STATE];\nint  number_table[MAX_STATE];\n\n/* åä¸å±é¢ãã§ãã¯ãã¼ãã« */\nchar check_table[MAX_STATE * 2];\n\n/* åæç¶æ */\nchar init_state[SIZE];\n\n/* çµäºç¶æ */\nchar final_state[SIZE] = {\n  1, 2, 3, 4, 5, 6, 7, 8, 0\n};\n\nint count=0;\n\nint main()\n{\n  int i;\n  \n  for(i = 0; i < 9; i++){\n    scanf(\"%d\", &init_state[i]);\n  }\n  \n  search();\n  printf(\"count = %d\\n\", count-1);  \n\n  return 0;\n}\n\nvoid print_answer_forward(int n)\n{\n  if(n > 1) print_answer_forward(prev_state[n]);\n  count++;\n}\n\nvoid print_answer_backward( int n )\n{\n  do{\n    n = prev_state[n];\n    count++;\n  }\n\n  while( prev_state[n] != -1 );\n}\n\nvoid print_answer( int pos1, int num1, int num2 )\n{\n  /* num2 ã®ä½ç½®ãè¦ã¤ãã */\n  int pos2 = pos1 - 1;\n\n  while( num2 != number_table[pos2] ) pos2--;\n\n  if( check_table[num1] == FORWARD ){\n    print_answer_forward( pos1 );\n    print_answer_backward( pos2 );\n  }\n  else{\n    print_answer_forward( pos2 );\n    print_answer_backward( pos1 );\n  }\n}\n\n/* çªå·ã«å¤æ */\nint change_number( char *board )\n{\n  char work[SIZE];\n  static int fact_table[SIZE] = {\n    40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n  };\n  int j, k, value = 0;\n  memcpy( work, board, SIZE );\n  for( j = 0; j < SIZE - 1; j++ ){\n    value += fact_table[j] * work[j];\n    for( k = j + 1; k < SIZE; k++ ){\n      if( work[j] < work[k] ) work[k]--;\n    }\n  }\n  return value;\n}\n\n/* ã­ã¥ã¼ã®åæå */\nvoid init_queue( void )\n{\n  int num;\n\n  /* ã¹ã¿ã¼ã */\n  memcpy( state[0], init_state, SIZE );\n  space_postion[0] = 7;\n  prev_state[0] = -1;\n  num = change_number( init_state );\n  number_table[0] = num;\n  check_table[ num ] = FORWARD;\n\n  /* ã´ã¼ã« */\n  memcpy( state[1], final_state, SIZE );\n  space_postion[1] = 8;\n  prev_state[1] = -1;\n  num = change_number( final_state );\n  number_table[1] = num;\n  check_table[ num ] = BACKWARD;\n}\n\n/* æ¢ç´¢ */\nvoid search( void )\n{\n  int front = 0, rear = 2;\n\n  /* åæå */\n  init_queue();\n\n  while( front < rear ){\n    int s = space_postion[front];\n    int num1 = number_table[front];\n    int num2, i, n;\n\n    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){\n      /* ç¶æãã³ãã¼ */\n      memcpy( state[rear], state[front], SIZE );\n      /* ç§»å */\n      state[rear][s] = state[rear][n];\n      state[rear][n] = 0;\n      space_postion[rear] = n;\n      prev_state[rear] = front;\n      num2 = change_number( state[rear] );\n\n      if( !check_table[num2] ){\n\t/* ç»é² */\n        number_table[rear] = num2;\n        check_table[num2] = check_table[num1];\n\trear++;\n      }\n      else if( check_table[num1] != check_table[num2] ){\n        /* è§£ãè¦ã¤ãã£ã */\n        print_answer( rear, num1, num2 );\n        return;\n      }\n    }\n    front++;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define M 9\n#define N 3\n#define yes 1\n#define no -1\n#define lim 100\n\ntypedef struct{\n  int a[M],b,c;\n}Puzzle;\n\nPuzzle now;\n\nint s1[4]={0,-1,0,1};\nint s2[4]={1,0,-1,0};\nchar contl[4]={'r','u','l','d'};\nint bord[M][M];\n\nint max,leng[lim];\n\nint in_bord(Puzzle x){\n  int i,count=0;\n  for(i=0;i<M;i++){\n    if(x.a[i]==M) continue;\n    count+=bord[i][x.a[i]-1];\n  }\n  return count;\n}\n\nint dfs(int deep,int z){\n  int i,r1,r2,y1,y2,change;\n  \n  if(now.c==0) return yes;\n  if(deep+now.c>max) return no;\n\n   r1=now.b/N;\n   r2=now.b%N;\n  Puzzle comp;\n\n  for(i=0;i<4;i++){\n    y1=r1+s1[i];\n    y2=r2+s2[i];\n\n    if(y1<0 || y2<0 || y1>=N || y2>=N) continue;\n    if(abs(z-i)==2) continue;\n    comp=now;\n\n    now.c-=bord[y1*N+y2][now.a[y1*N+y2]-1];\n    now.c+=bord[r1*N+r2][now.a[y1*N+y2]-1];\n    change=now.a[y1*N+y2];\n    now.a[y1*N+y2]=now.a[r1*N+r2];\n    now.a[r1*N+r2]=change;\n    now.b=y1*N+y2;\n    if(dfs(deep+1,i)==yes){\n      leng[deep]=i;\n      return yes;\n    }\n    now=comp;\n  }\n  return no;\n}\n\nvoid solve(Puzzle x){\n  int i,count=0;\n  \n  x.c=in_bord(x);\n  for(max=x.c;max<=lim;max++){\n    now=x;\n    if(dfs(0,-100)==yes){\n      for(i=0;i<max;i++){\n\tcount++;\n      }\n      printf(\"%d\\n\",count);\n      return;\n    }\n  }\n}\n      \n\nint main(){\n  int i,j,keep;\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    for(j=0;j<M;j++){\n      bord[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n    }\n  }\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.a[i]);\n    if(in.a[i]==0) keep=i;\n  }\n      in.a[keep]=M;\n      in.b=keep;\n\n  solve(in);\n\n  return 0;\n}\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\nint suretu[N][N] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\nint keisan(int f[N][N]) {\n  int i,j;\n    for (i=0;i<N;++i) {\n        for (j=0;j<N;++j) {\n            if(f[i][j] != suretu[i][j])\n                return 0;\n        }\n    }\n    return 1;\n}\nint jeep(int f[N][N], int x, int y, int v, int d, int l) {\n  int i,j,res,nx,ny;\n    if (keisan(f)) return d;\n    if (d > l)return -1;\n    for (i=0;i<4;++i) {\n        nx=x+dx[i]; ny=y+dy[i];\n        if (nx<0||nx>2||ny<0||ny>2||(i+2)%4==v)\n            continue;\n        f[y][x]=f[ny][nx]; f[ny][nx]=0;\n        if((res=jeep(f, nx, ny, i, d + 1, l)) > 0)return res;\n        f[ny][nx] = f[y][x];  f[y][x] = 0;\n    }\n    return -1;\n}\nint main() {\n  int f[N][N], x, y,i,j,res;\n    for (i=0; i< N; ++i) {\n        for (j=0; j<N;++j) {\n            scanf(\"%d\",&f[i][j]);\n            if(f[i][j]==0) {\n                y=i;x=j;\n            }\n        }\n    }\n        for (i=1;i<50;++i) {\n        if ((res=jeep(f,x,y,-1,0,i))>=0){\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100000\n#define SENTINEL 2000000000\n\nstruct Card{\n  char suit;\n  int value;\n};\n\nstruct Card L[MAX/2+2], R[MAX/2+2];\n\nvoid merge(struct Card A[], int n, int left, int mid, int right){\n\n  int i, j, k;\n  int n1 = mid - left;\n  int n2 = right - mid;\n\n  for(i=0; i<n1; i++){\n    L[i] = A[left+1];\n  }\n  for(i=0; i<n2; i++){\n    R[i] = A[mid+i];\n  }\n\n  L[n1].value = R[n2].value = SENTINEL;\n  i = j = 0;\n\n  for(k=left; k<right; k++){\n    if(L[i].value <= R[j].value){\n      A[k] = L[i++];\n    }\n    else{\n      A[k] = R[j++];\n    }\n  }\n\n}\n\nvoid mergeSort(struct Card A[], int n, int left, int right){\n\n  int mid;\n\n  if(left+1 < right){\n    mid = (left+right)/2;\n    mergeSort(A, n, left, mid);\n    mergeSort(A, n, mid, right);\n    merge(A, n, left, mid, right);\n  }\n\n}\n\nint partition(struct Card A[], int n, int p, int r){\n\n  int i, j;\n  struct Card t, x;\n  x = A[r];\n  i = p-1;\n\n  for(j=p; j<r; j++){\n    if(A[j].value <= x.value){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n  return i+1;\n\n}\n\nvoid quickSort(struct Card A[], int n, int p, int r){\n\n  int q;\n\n  if(p<r){\n    q = partition(A, n , p, r);\n    quickSort(A, n, p, q-1);\n    quickSort(A, n, q+1, r);\n  }\n\n}\n\nint main(){\n\n  int n, i, v;\n  struct Card A[MAX], B[MAX];\n  char S[10];\n  int stable=1;\n\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n; i++){\n    scanf(\"%s %d\", S, &v);\n    A[i].suit = B[i].suit = S[0];\n    A[i].value = B[i].value = v;\n  }\n\n  mergeSort(A, n, 0, n);\n  quickSort(B, n, 0, n-1);\n\n  for(i=0; i<n; i++){\n    if(A[i].suit != B[i].suit){\n      stable = 0;\n    }\n  }\n\n if(stable==1){\n    printf(\"Stable\\n\");\n  }\n  else{\n    printf(\"Not stable\\n\");\n  }\n\n  for(i=0; i<n; i++){\n    printf(\"%c %d\\n\", B[i].suit, B[i].value);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 8765432\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/100;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint p[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid emp(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&p[i][j]);\n    }\n    emp(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = p[i][j];\n        }\n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) p[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    }\n     printf(\"%d\\n\",a);\n     return 0;\n}\n  \nvoid emp(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!p[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = p[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n   }\n    return sum;\n}\n \nint dfs(int x,int y,int p1,int d,const int lim) {\n    int i,h,nx,ny,res;\n    h = cal();\n    if(h==0) return d;\n    if(d+h>lim) return -1;\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        if(~p1 && i==(p1+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        swap(&p[y][x],&p[ny][nx]);\n        res = dfs(nx,ny,i,d+1,lim);\n        if(~res) return res;\n        swap(&p[y][x],&p[ny][nx]);\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\ntypedef struct{\n  int B[3][3];\n}board;\n\nboard P;\n\nint heustric(){\n  int i,j,x,y,sum=0;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(P.B[i][j] == 0) continue;\n      x = (P.B[i][j] -1)%3 - j;\n      y = (P.B[i][j] -1)/3 - i;\n\n      if(x < 0) sum -= x;\n      else sum += x;\n\n      if(y < 0) sum -=y;\n      else sum+= y;\n    }\n  }\n\n  return sum;\n}\n\nint DFS(int x,int y,int max,int cnt,int n){\n  int i,temp,x0,y0,time,h;\n\n  h = heustric();\n  if(h == 0) return cnt;\n  else if(cnt + h > max) return -1;\n\n  for(i=0;i<4;i++){\n    x0 = x + dx[i];\n    y0 = y + dy[i];\n\n    if((i == (n +2)%4 && n!= -1) || (x0 < 0 || 3<= x0 || y0 < 0 || 3 <= y0)) continue;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n\n    time = DFS(x0,y0,max,cnt+1,i);\n\n    if(time != -1) return time;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n  }\n\n  return -1;\n}\n\nint main(){\n  int i,j,x,y,time;\n  board S;\n  \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tscanf(\"%d\",&P.B[i][j]);\n\tif(P.B[i][j] == 0){\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n\n    S = P;\n\n    for(i=1;i<46;i++){\n      P = S;\n\n      time = DFS(x,y,i,0,-1);\n      if(time != -1){\n\tprintf(\"%d\\n\",time);\n\tbreak;\n      }\n    }\n\n    return 0;\n}\n\t  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint mas[3][3];\nint cpy[3][3];\n  \nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n  \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n  \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n  \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n  \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n  \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n  \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n  \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n  \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n  \n  return -1;\n}\n  \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n  \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n  \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "//2020.2.1\n//s1270188 xxxmk2\n//alds1_13b\n\n#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define D 100\n\n//struct\nstruct node{\n  int data[N][N];\n  struct node *p;\n};\nstruct xy{\n  int x;\n  int y;\n};\n\n//global\nstruct node root;\nint mv[4][2]={0,1,0,-1,-1,0,1,0};//ä¸ä¸å·¦å³ xy\n\n//function\nint man(int n,int x,int y){\n  int nx, ny;\n\n  nx=(n-1)%N;\n  ny=(n-1)/N;\n  \n  x=x-nx;\n  if(x<0) x*=-1;\n\n  y=y-ny;\n  if(y<0) y*=-1;\n  \n  return x+y;\n}\n\nint judge(struct node *n){\n  int i, j=0;\n\n  if(n==NULL) return -1;\n  \n  for(i=0;i<N*N;i++){\n    if(n->data[i%N][i/N]==0) continue;\n    if(n->data[i%N][i/N]!=i+1) j+=man(n->data[i%N][i/N],i%N,i/N);\n  }\n\n  return j;\n}\n\nstruct xy blank(struct node *n){\n  struct xy ddd;\n  int i;\n\n  for(i=0;i<N*N;i++)\n    if(n->data[i%N][i/N]==0) break;\n\n  ddd.x=i%N;\n  ddd.y=i/N;\n  \n  return ddd;\n}\n\nstruct node *mk(struct node *n,struct xy b, struct xy m){\n  struct node *aaa;\n  int i;\n  \n  aaa=malloc(sizeof(struct node));\n\n  for(i=0;i<N*N;i++) aaa->data[i%N][i/N]=n->data[i%N][i/N];\n  \n  aaa->data[b.x][b.y]=aaa->data[m.x][m.y];\n  aaa->data[m.x][m.y]=0;\n  aaa->p=n;\n  \n  return aaa;\n}\n\n\nint puzzle(struct node *n,struct node *bp, int g,int d){\n  int h=judge(n), i, j;\n  struct xy bl, m;\n  struct node *mm;\n  \n  if(h==0) return g;\n\n  if(g+h>d) return -1;\n  \n  bl=blank(n);\n  \n  for(i=0;i<4;i++){\n    m.x=bl.x+mv[i][0];\n    m.y=bl.y+mv[i][1];\n\n    if(m.x<0 || m.y<0 || m.x==N || m.y==N ) continue;\n    \n    mm=mk(n,bl,m);\n    if(bp!=NULL){\n      for(j=0;j<N*N;j++)\n\tif(mm->data[j%N][j/N]!=bp->data[j%N][j/N]) break;\n      if(j==N*N){\n\tfree(mm);\n\tcontinue;\n      }\n    }\n    \n    j=puzzle(mm,mm->p,g+1,d);\n    if(j>0) return j;\n  }\n\n  return -1;\n}\n\nint main(){\n  int i, ans;\n  struct node *n, *m;\n  \n  //input\n  for(i=0;i<N*N;i++) scanf(\"%d\",&root.data[i%N][i/N]);\n  root.p=NULL;\n  \n  for(i=judge(&root);i<=D;i++){\n    ans=puzzle(&root,NULL,0,i);\n\n    if(ans>0) break;\n  }\n  \n  //output\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 5) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n//\n\n\n// Util\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n//\n\n\n// Red Black Tree\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n//\n\n\n// node key\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mynode *data) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(&data->key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    rb_link_node(&data->node, parent, new);\n    rb_insert(&data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n//\n\n\n// List\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list) {\n    list->next = list;\n    list->prev = list;\n}\n\nstatic inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) {\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    prev->next = new;\n}\n\nstatic inline void list_add(struct list_head *new, struct list_head *head) {\n    __list_add(new, head, head->next);\n}\n\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head) {\n    __list_add(new, head->prev, head);\n}\n\nstatic inline void __list_del(struct list_head *prev, struct list_head *next) {\n    next->prev = prev;\n    prev->next = next;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry) {\n    __list_del(entry->prev, entry->next);\n}\n\nstatic inline void list_del(struct list_head *entry) {\n    __list_del_entry(entry);\n    entry->next = NULL;\n    entry->prev = NULL;\n}\n\nstatic inline int list_empty(const struct list_head *head) {\n    return head->next == head;\n}\n\n#define list_entry(ptr, type, member) container_of(ptr, type, member)\n#define list_first_entry(ptr, type, member) list_entry((ptr)->next, type, member)\n//\n\nstruct my_list {\n    struct mykey key;\n    struct list_head list;\n};\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\nstruct mynode node[200000];\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    static int num = 0;\n    node[0].key = s;\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, node + num++);\n    struct list_head head;\n    INIT_LIST_HEAD(&head);\n    struct my_list *data = malloc(sizeof(struct my_list));\n    data->key = s;\n    list_add_tail(&data->list, &head);\n    while(!list_empty(&head)) {\n        data = list_first_entry(&head, struct my_list, list);\n        struct mykey key = data->key;\n        list_del(&data->list);\n        free(data);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            node[num].key = next_key;\n            if(my_insert(&mytree, node + num) == 0) num++;\n            data = malloc(sizeof(struct my_list));\n            data->key = next_key;\n            list_add_tail(&data->list, &head);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 15\ntypedef struct{\n  int A[N][N];\n}Pazzle;\nPazzle P;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n  int hoge;\n  hoge=*A;\n  *A=*B;\n  *B=hoge;\n \n \n}\n\nint check(Pazzle P){\n  int sum=0,i,j,hy,hx;\n  for(i=0;i<N;i++){\n \n    for(j=0;j<N;j++){\n      if(P.A[i][j]==0)\n        continue;\n      hy=(P.A[i][j]-1)/N-i;\n      hx=(P.A[i][j]-1)%N-j;\n      if(hy<0)\n        sum-=hy;\n      else\n        sum+=hy;\n      if(hx<0)\n        sum-=hx;\n      else\n        sum+=hx;\n \n \n    }\n  }\n \n  return sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int m){\n  int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;   \n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1; \n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if((m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N)) continue;    \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,i);\n    if(ans!=-1) return ans;       \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }   \n  return -1;\n}\n\nint main(void){\n  Pazzle t_P;\n  int  i,j,ans;\n  int x0,y0;\n\n\n  for(i=0;i<N;i++){\n    if(i<N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&P.A[i][j]);\n      if(P.A[i][j]==0){\n\tx0=j;\n\ty0=i;\n                \n      }\n            \n    }\n  }\n  t_P=P;\n  for(i=1;i<46;i++){\n    P=t_P;\n    ans=dfs(x0,y0,i,0,-1);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n  }\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define LIMIT 100\n#define TRUE 1\n#define FALSE 0\n#define NIL -1\n\ntypedef struct{\n  int map[N*N];\n  int space,MD;\n}PUZZLE;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nchar vector[4]={'r','u','l','d'};\nint limit,path[LIMIT];\nint MDT[N*N][N*N];\nPUZZLE status,in;\n\nint getHeur(PUZZLE);//ãã³ããã¿ã³è·é¢ã®ç·åãè¨ç®ãããã®å¤ããã¥ã¼ãªã¹ãã£ãã¯å¤ã¨ããã\nint dfs(int,int);//æ·±ãåªåæ¢ç´¢\nvoid getAns(PUZZLE);//IDA\n\n\nint main(){\n  int i,j,memory;\n  PUZZLE p;\n  //  for(i=0;i<LIMIT;i++)path[i]=NIL;\n   \n  \n  for(i=0;i<N*N;i++){\n    for(j=0;j<N*N;j++){\n      MDT[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n    }\n  }\n\n  for(i=0;i<N*N;i++){\n    scanf(\"%d\",&p.map[i]);\n    if(p.map[i]==0)memory=i;\n  }\n  p.map[memory]=N*N;\n  p.space=memory;\n\n  getAns(p);\n  // for(i=0;i<100;i++)printf(\"%d\\n\",path[i]);\n  \n  return 0;\n}\n\n\nint getHeur(PUZZLE p){\n  int i;\n  int h=0;//ãã¥ã¼ãªã¹ãã£ãã¯å¤\n  for(i=0;i<N*N;i++){\n    if(p.map[i]==N*N){\n      continue;\n    }\n    h+=MDT[i][p.map[i]-1];\n  }\n  return h;\n}\n\nint dfs(int depth,int prev){\n  int i;\n  PUZZLE pTemp;\n  int sx,sy,tx,ty,temp;\n\n  \n  if(status.MD==0) return TRUE;\n  if(depth+status.MD>limit)return FALSE;\n\n  sx=status.space/N;\n  sy=status.space%N;\n\n  for(i=0;i<4;i++){\n    tx=sx+dx[i];\n    ty=sy+dy[i];\n    if(!(tx>=0&&tx<N&&ty>=0&&ty<N))continue;\n    if(abs(prev-i)==2)continue;\n    \n    pTemp=status;\n    status.MD+=MDT[sx*N+sy][status.map[tx*N+ty]-1];\n    status.MD-=MDT[tx*N+ty][status.map[tx*N+ty]-1];\n    temp=status.map[tx*N+ty];\n    status.map[tx*N+ty]= status.map[sx*N+sy];\n    status.map[sx*N+sy]=temp;\n    status.space=tx*N+ty;\n    if(dfs(depth+1,i)==TRUE){\n      path[depth]=i;\n      return TRUE;\n    }\n    status=pTemp;\n  }\n  return FALSE;\n}\n\n\n\nvoid getAns(PUZZLE p){\n  int i,result=0;\n  p.MD=getHeur(p);\n  for(limit=p.MD;limit<=LIMIT;limit++){\n    status=p;\n    if(dfs(0,-100)==TRUE){\n      for(i=0;i<limit;i++){\n\t//if(path[i]!=NIL)\n\tresult++;      \n      }\n      printf(\"%d\\n\",result);\n      return;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\tint ret;\n\tint i, j, temp;\n\tint seikai[9][2] =\n\t{\n\t\t{0,0},\n\t\t{0,1},\n\t\t{0,2},\n\t\t{1,0},\n\t\t{1,1},\n\t\t{1,2},\n\t\t{2,0},\n\t\t{2,1},\n\t\t{2,2}\n\t};\n\n\tret = 0;\n\tfor(i = 0; i < 3; i++){\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tscanf(\"%d\", &temp);\n\t\t\tif(temp != 0){\n\t\t\t\tret += abs(seikai[(temp - 1)][0] - i);\n\t\t\t\tret += abs(seikai[(temp - 1)][1] - j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N],int min,int limit,int r,int c);\n\nint main(int argc, char *argv[]){\n  int board[N][N];\n  int md;\n  int i,j,r,c,x,y,found;\n  int res;\n  for (i=0;i<N;i++) {\n    for (j=0;j<N;j++)\n    scanf(\"%d\",&board[i][j]);\n  }\n  md=0;\n  for(i=0;i<N*N;i++) {\n    found=0;\n    for(r=0;r<N;r++){\n      for(c=0;c<N;c++) {\n\t       if(board[r][c]==i){\n\t          if(i==0){\n\t             x=r;\n\t              y=c;\n\t             }\n               else md+=(int)abs((i-1)/N-r)+(int)abs((i-1)%N-c);\n\t              found=1;\n\t               break;\n\t        }\n      }\n      if (found == 1) break;\n      }\n  }\n\n  for(i=0;;i+=2){\n    if((x+y)%2==0){\n      if(md%2==0)res=search(board,md,md+i,x,y);\n      else res=search(board,md,md+i+1,x,y);\n    }\n    else{\n      if(md%2==0)res=search(board,md,md+i+1,x,y);\n      else res=search(board,md,md+i,x,y);\n    }\n    if(res!=-1)break;\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}\n\nint search(int board[N][N],int min,int limit,int x, int y){\n  int md_c,num,res[4];\n  if(min==0)return 0;\n  if(x!=0){\n    md_c=min;\n    num=board[x-1][y];\n    md_c-=(int)abs((num-1)/N-(x-1))+(int)abs((num-1)%N-y);\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1){\n      board[x-1][y]=0;\n      board[x][y]=num;\n      res[0]=search(board,md_c,limit-1,x-1,y);\n      if(res[0]==-1){\n\tboard[x-1][y]=num;\n\tboard[x][y]=0;\n      }\n      else res[0]++;\n    }\n    else res[0]=-1;\n  }\n  else res[0]=-1;\n  if(x!=N-1){\n    md_c=min;\n    num=board[x+1][y];\n    md_c-=(int)abs((num-1)/N-(x+1))+(int)abs((num-1)%N-y);\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1){\n      board[x+1][y]=0;\n      board[x][y]=num;\n      res[1]=search(board,md_c,limit-1,x+1,y);\n      if(res[1]==-1){\n\t       board[x+1][y]=num;\n\t       board[x][y]=0;\n      }\n      else res[1]++;\n    }\n    else res[1]=-1;\n  }\n  else res[1]=-1;\n\n  if(y!=0){\n    md_c=min;\n    num=board[x][y-1];\n    md_c-=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-(y-1));\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1){\n      board[x][y-1]=0;\n      board[x][y]=num;\n      res[2]=search(board,md_c,limit-1,x,y-1);\n      if(res[2]==-1){\n\t       board[x][y-1]=num;\n\t       board[x][y]=0;\n      }\n      else res[2]++;\n    }\n    else res[2]=-1;\n  }\n  else res[2]=-1;\n  if (y!=N-1){\n    md_c=min;\n    num=board[x][y+1];\n    md_c-=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-(y+1));\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1) {\n      board[x][y+1]=0;\n      board[x][y]=num;\n      res[3]=search(board,md_c,limit-1,x,y+1);\n      if(res[3]==-1){\n        board[x][y+1]=num;\n        board[x][y]=0;\n      }\n      else res[3]++;\n    }\n    else res[3]=-1;\n  }\n  else res[3]=-1;\n\n  if(res[0]==-1&&res[1]==-1&&res[2]==-1&&res[3]==-1) return -1;\n  else if(res[0]!=-1)return res[0];\n  else if(res[1]!=-1)return res[1];\n  else if(res[2]!=-1)return res[2];\n  else return res[3];\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define N 3\n#define SPACE 9\n#define QUEUE_MAX 400000\n#define TRUE 1\n#define FALSE 0\n\ntypedef struct P {\n  int steps;\n  int board[N*N];\n  int space;\n} puzzle;\n\nint solve(puzzle);\n\npuzzle queue[QUEUE_MAX];\nint q_top = 0;\nint q_tail = 0;\n\npuzzle q_pop() {\n  puzzle result = queue[q_top];\n  q_top++;\n  q_top %= QUEUE_MAX;\n\n  return result;\n}\n\nvoid q_push(puzzle p) {\n  queue[q_tail] = p;\n  q_tail++;\n  q_tail %= QUEUE_MAX;\n}\n\nint q_size(){\n  if(q_tail >= q_top){\n    return q_tail - q_top;\n  }\n  else {\n    return q_tail + QUEUE_MAX - q_top;\n  }\n}\n\nstruct node {\n  struct node* nodes[N*N + 1];\n};\n\ntypedef struct node * NodePointer;\n\nNodePointer makeNode() {\n  NodePointer node;\n\n  node = malloc(sizeof(struct node));\n\n  for(int i = 0; i < N*N + 1; i++){\n    node->nodes[i] = NULL;\n  }\n\n  return node;\n}\n\nNodePointer memTree;\n\nint exists(puzzle *p){\n  NodePointer current = memTree;\n  \n  for(int i = 0; i < N*N; i++){\n    // printf(\"%d, \", p->board[i]);\n    if(current->nodes[p->board[i]] == NULL){\n      //printf(\"DEPTH = %d NOT FOUND\\n\", i);\n      return FALSE;\n    }\n\n    current = current->nodes[p->board[i]];\n  }\n  \n  //printf(\"FOUND!!\\n\");\n  return TRUE;\n}\n\nvoid addToMem(puzzle *p){\n  NodePointer current = memTree;\n  \n  for(int i = 0; i < N*N; i++){\n    //printf(\"DEPTH = %d ADDING\\n\", i);\n    if(current->nodes[p->board[i]] == NULL){\n      current->nodes[p->board[i]] = makeNode();\n    }\n\n    current = current->nodes[p->board[i]];\n  }\n}\n  \n\nint main() {\n  puzzle input;\n  for(int i = 0; i < N*N ; i++){\n    scanf(\"%d\", &(input.board[i]));\n    if(input.board[i] == 0) {\n      input.board[i] = SPACE;\n      input.space = i;\n    }\n      \n    //    printf(\"%d \", input.board[i]);\n  }\n\n  memTree = makeNode();\n\n  input.steps = 0;\n\n  //debug\n  //addToMem(&input);\n  //exists(&input);\n  \n  printf(\"%d\\n\", solve(input));\n\n  \n  return 0;\n}\n\nint gameClear(puzzle* p){\n  for(int i = 0; i < N*N ; i++){\n    if(p->board[i] != i + 1){\n      return FALSE;\n    }\n  }\n\n  return TRUE;\n}\n\n//solve by BFS\nint solve(puzzle s) {\n  int result = 0;\n\n  int dx[4] = {0,1,0,-1};\n  int dy[4] = {-1,0,1,0};\n  char dir[4][6] = {\"up\", \"right\", \"down\", \"left\"};\n  //printf(\"steps %d\\n\", s.steps);\n\n  q_push(s);\n  addToMem(&s);\n\n  while(q_size() > 0){\n    puzzle u = q_pop();\n    //printf(\"steps %d\\n\", u.steps);\n\n    if(gameClear(&u)){\n      result = u.steps;\n      break;\n    }\n    int col = u.space / N;\n    int row = u.space % N;\n    //printf(\"space (%d, %d)\\n\", col, row);\n    \n    for(int i = 0; i < 4; i++){\n      int tc = col + dy[i];\n      int tr = row + dx[i];\n\n      if(tc < 0 || tr < 0 || tc >= N || tr >= N){\n\tcontinue;\n      }\n\n      //printf(\"try to %s\\n\", dir[i]);\n      puzzle v = u;\n      int tmp = v.board[tc*N + tr];\n      v.board[tc*N + tr] = v.board[u.space];\n      v.board[u.space] = tmp;\n\n      if(!exists(&v)){\n\tv.space = tc*N + tr;\n\tv.steps = u.steps + 1;\n\tq_push(v);\n\taddToMem(&v);\n      }\n    }\n  }\n  return result;\n}\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\nBoard *history;\nint nhistories=0;\ntypedef enum { U, D, L, R } Direction;\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\nint minstep = INT_MAX;\nconst Motion candidate[9][5] = \n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n  \n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    \n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return; \n    if (step>0 && strcmp(board, ini_board)==0) return; \n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) \n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint mas[3][3];\nint cpy[3][3];\n \nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n \n  return -1;\n}\n \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<map>\nusing namespace std;\nint str[5][5];\nstruct edge\n{\n    int x,y,n;\n    int s[5][5];\n};\nvoid bfs(int x,int y)\n{\n    int i,j,k=0,next[4][2]={0,1,1,0,0,-1,-1,0};    //åä¸ªæ¹å\n    long long l=0;                                  //åå§åä¸º0\n    queue<edge>Q;\n    map<int,int>book;                               //ä½¿ç¨mapå®¹å¨å¯ä»¥æ¾ç½®å¾å¤§çæ°\n    while(!Q.empty())\n        Q.pop();\n    edge q,now;\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            l=l*10+str[i][j];\n            q.s[i][j]=str[i][j];                    //è®¡ç®lçå¼ å¹¶å°å½ååç´ å­å¥q.s[i][j]\n        }  \n    }\n    if(l==123456780){printf(\"0\\n\");return;}\n    book[l]=1;\n    q.x=x;                                           //è®°å½0çæ¨ªçºµåæ \n    q.y=y;\n    q.n=0;\n    Q.push(q);                                       //æ¾å¥å¯¹å°¾\n    while(!Q.empty())\n    {\n        now=Q.front();\n        Q.pop();\n        for(i=0;i<4;i++)\n        {\n            int xx=now.x+next[i][0];                   //å¼å§åä¸ªæ¹åä¾¿å©\n            int yy=now.y+next[i][1];\n            if(xx<0||yy<0||xx>=3||yy>=3)continue;\n            q.x=xx;\n            q.y=yy;\n            q.n=now.n+1;\n            for(k=0;k<3;k++)                           //æ­¥æ°å ä¸\n            {\n                for(j=0;j<3;j++)\n                {\n                    q.s[k][j]=now.s[k][j];               //å°æ­¤æ¶åç´ çç¶æå­å¥q.s[][]ä¸­\n                }\n            }\n            k=q.s[now.x][now.y];\n            q.s[now.x][now.y]=q.s[xx][yy];\n            q.s[xx][yy]=k;                               //å°æ­¤æ¶0çä½ç½®æ¾å¥q.[now.x][now,y]\n            l=0;\n            for(k=0;k<3;k++)\n            {\n                for(j=0;j<3;j++)\n                {\n                    l=l*10+q.s[k][j];\n                }\n            }\n            if(l==123456780){printf(\"%d\\n\",q.n);return;}\n            if(book[l]==0)\n            {\n                book[l]=1;\n                Q.push(q);                             //å¦ææ²¡è¢«æ è®° å°å¶æ¾å¥éåå°¾\n            }       \n        }\n    }\n}\nint main()\n{\n    int i,j,a,ex,ey;\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            scanf(\"%d\",&a);\n            str[i][j]=a;\n            if(a==0)\n            {\n                ex=i;\n                ey=j;\n            }\n        }\n    }\n    bfs(ex,ey);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint pz[3][3],tmp[3][3];\nint dx[4] = {0,1,0,-1},dy[4] = {1,0,-1,0};\nvoid emp(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!pz[i][j]) {\n    *x = j;\n    *y = i;\n      }\n    }\n  }\n}\nvoid swap(int *s,int *v){\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n}   \nint calc(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = pz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int d,const int lim){\n    int i,h,x2,y2,res;   \n    h = calc();\n    if(h==0) {\n        return d;\n    }\n    if(d+h>lim) {\n        return -1;\n    }\n    for(i=0; i<4; i++){\n        x2 = x+dx[i];\n        y2 = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n        swap(&pz[y][x],&pz[y2][x2]);\n        res = dfs(x2,y2,i,d+1,lim);\n        if(~res) {\n            return res;\n        }\n        swap(&pz[y][x],&pz[y2][x2]);\n    }   \n    return -1;\n}    \nint main() {\n    int i,j,l,ans,x,y;\n       \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&pz[i][j]);\n    }\n        \n    emp(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = pz[i][j];\n        }\n           \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n           \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) pz[i][j] = tmp[i][j];\n        }\n           \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n       \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define T 1\n#define F 0\n#define N 3\n\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { 1,0,-1,0 };\nint lim;\nint p[N][N];\n\nint huristic() {\n\tint i, j, n, sum = 0;\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = 0; j < N; j++) {\n\t\t\tif (p[i][j] == 0)continue;\n\t\t\tn = p[i][j] - 1;\n\t\t\tsum += abs(n / N - i) + abs(n % N - j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dfs(int d, int pre, int y, int x) {\n\tint h = huristic();\n\tint i;\n\tif (h == 0)return T;\n\tif (lim < d + h) return F;\n\t\n\tfor (i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) == 2) continue;\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\tint tmp = p[ty][tx];\n\t\tp[ty][tx] = p[y][x];\n\t\tp[y][x] = tmp;\n\n\t\tif (dfs(d + 1, i, ty, tx))return T;\n\t\ttmp = p[ty][tx];\n\t\tp[ty][tx] = p[y][x];\n\t\tp[y][x] = tmp;\n\t}\n\treturn F;\n}\n\nvoid PZL(int x, int y) {\n\tfor (lim = 0;; lim++) {\n\t\tif (dfs(0, 99, y, x)) {\n\t\t\tprintf(\"%d\\n\", lim);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tint i,j;\n\tint x, y;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tscanf(\"%d\", &p[i][j]);\n\t\t\tif (p[i][j] == 0) {\n\t\t\t\ty = i;x = j;\n\t\t\t}\n\t\t}\n\t}\n\tPZL(x, y);\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\nvoid empty(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n  }\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  empty(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n     ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n  int i,j;\n  int h,ans,row,col;\n      \n  for(i=0; i<MAX; i++){\n    for(j=0; j<MAX; j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0; h<100; h++){\n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\ttemp[i][j] = pane[i][j];\n    }    \n    ans = dfs(row,col,-1,0,h);    \n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }    \n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\tpane[i][j] = temp[i][j];\n    }    \n    ans = -1;\n    if(h==99) printf(\"%d\\n\\n\",ans);\n  }      \n  return 0;\n}\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0; i<MAX; i++)\n    for(j=0; j<MAX; j++)\n      if(!pane[i][j]){\n\t*row = j;\n\t*col = i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  \n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0; i<9; i++){\n    e = pane[i/3][i%3];\n    if(e){\n      e--;\n      count += abs(i/3 - e/3) + abs(i%3 - e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i, len, x_2, y_2, emc;\n  \n  len = cal();\n  if(len==0) return deep;\n  if(deep+len > limt) return -1; \n  for(i=0; i<4; i++){\n    x_2 = x+d_x[i];\n    y_2 = y+d_y[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc = dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n} \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\nint c[4][2]={1,0,0,1,-1,0,0,-1};\nint puzzle[10];\n\nmap<string,int> book;\nstruct yun\n{\n    int s;\n    int state[9];\n};\n\nint bfs()\n{\n    int i,j,k,l;\n    yun st,en;\n    queue<yun> Q;\n    st.s=0;\n    for(i=0;i<9;i++)\n        st.state[i]=puzzle[i];\n    Q.push(st);\n    while(Q.size())\n    {\n        st=Q.front();\n        Q.pop();\n        for(k=0;k<9;k++)\n            if(!st.state[k])break;\n        int x=k/3,y=k%3;\n        for(j=0;j<4;j++)\n        {\n            int dx=x+c[j][0];\n            int dy=y+c[j][1];\n            int dz=dx*3+dy;\n            if(dx<0||dy<0||dx>=3||dy>=3)continue;\n            string ss=\"\";\n            for(l=0;l<9;l++)\n                en.state[l]=st.state[l];\n            en.state[k]=en.state[dz];\n            en.state[dz]=0;\n            int f=0;\n            for(l=0;l<8;l++)\n            {\n                ss+=en.state[l]+'0';\n                if(en.state[l]!=l+1)\n                    f=1;\n            }\n          //  cout<<ss<<endl;\n            if(!f)return st.s+1;\n            if(book[ss])continue;\n            book[ss]=1;\n            en.s=st.s+1;\n            Q.push(en);\n        }\n    }\n}\n\nint main()\n{\n    int i;\n    for(i=0;i<9;i++)\n        scanf(\"%d\",&puzzle[i]);\n    int g=0;\n    for(i=0;i<8;i++)\n    {\n        if(puzzle[i]!=i+1)\n            g=1;\n    }\n    int max1;\n    if(!g)\n        max1=0;\n    else max1=bfs();\n    printf(\"%d\\n\",max1);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 20\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n\nint puzz[N][N];\nint dy[4]={1,0,-1,0};\nint dx[4]={0,1,0,-1};\n\nint huri(){\n\n  int x,y ,i,j,sum=0;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(puzz[i][j] == 0)continue;\n\n      x=(puzz[i][j]-1)%N-j;\n      y=(puzz[i][j]-1)/N-i;\n      x=abs(x);\n      y=abs(y);\n      \n      sum+=x;\n      sum+=y;\n    }\n  }\n  return sum;\n}\n\nint DFS(int iof0,int jof0,int lim,int dpt){\n\n  int i,j,h,x,y,tmp,ans=-1;\n\n  h = huri();\n  if(h == 0) return dpt;\n  if(h+dpt > lim) return -1;\n\n  for(i=0;i<4;i++){\n    x = iof0 + dx[i];\n    y = jof0 + dy[i];\n\n    if(x >= N || x < 0) continue;\n    if(y >= N || y < 0) continue;\n\n    tmp = puzz[x][y];\n    puzz[x][y] = puzz[iof0][jof0];\n    puzz[iof0][jof0] = tmp;\n\n    ans = DFS(x,y,lim,dpt+1);\n\n    if(ans != -1) return ans;\n    tmp = puzz[x][y];\n    puzz[x][y] = puzz[iof0][jof0];\n    puzz[iof0][jof0] = tmp;\n  }\n  return -1;\n}\n\nint main(){\n\n  int i,j,iof0,jof0,ans;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&puzz[i][j]);\n      if(puzz[i][j] == 0){\n\tiof0 = i;\n\tjof0 = j;\n      }\n    }\n  }\n\n  for(i=1;i<101;i++){\n    ans = DFS(iof0,jof0,i,0);\n    if(ans != -1) {\n      printf(\"%d\\n\",ans);\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=0; i<45; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n\ntypedef struct node{\n  char s[10];\n  int t;\n  int x;\n  struct node *next;\n  struct node *back;\n}Node;\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(Node *root, char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  Node *p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->t = t;\n  int i;\n  for(i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      p->x = i;\n      break;\n    }\n  }\n  root->back->next = p;\n  p->back = root->back;\n  p->next = root;\n  root->back = p;\n  return -1;\n}\n\nint distance(char *s_new) {\n  char s[] = \"123456780\";\n  int i;\n  int sum = 0;\n  for(i = 0; i < 9; i++) {\n    int a = 0;\n    int b = 0;\n    while(s[a]-'0' != i) a++;\n    while(s_new[b]-'0' != i) b++;\n    sum += abs(a/3-b/3) + abs(a%3-b%3);\n  }\n  return sum;\n}\n\nint cal(Node *root) {\n  Node *p = root->next;\n  char *s_right,*s_left,*s_up,*s_down;\n  int right,left,up,down,min;\n  int k;\n  if((s_right = move_right(p->s, p->x)) != NULL) {\n    right = distance(s_right);\n  }else{\n    right = INT_MAX;\n  }\n  if((s_left = move_left(p->s, p->x)) != NULL) {\n    left = distance(s_left);\n  }else{\n    left = INT_MAX;\n  }\n  if ((s_up = move_up(p->s, p->x)) != NULL) {\n    up = distance(s_up);\n  }else{\n    up = INT_MAX;\n  }\n  if((s_down = move_down(p->s, p->x)) != NULL) {\n    down = distance(s_down);\n  }else{\n    down = INT_MAX;\n  }\n\n  min = right;\n  if(min > left) min = left;  \n  if(min > up) min = up;  \n  if(min > down) min = down;\n\n  if(right == min) {\n    if((k = create(root,s_right,p->t+1)) != -1) return k;\n  }\n  if(left == min) {\n    if((k = create(root,s_left,p->t+1)) != -1) return k;\n  }\n  if(up == min) {\n    if((k = create(root,s_up,p->t+1)) != -1) return k;\n  }\n  if(down == min) {\n    if((k = create(root,s_down,p->t+1)) != -1) return k;\n  }\n\n  if(s_right != NULL) free(s_right);\n  if(s_left != NULL) free(s_left);\n  if(s_up != NULL) free(s_up);\n  if(s_down != NULL) free(s_down);\n  p->next->back = root;\n  root->next = p->next;\n  free(p);\n  return -1;\n}\n  \n\nint solve(char s0[]) {\n  int t;\n  Node root;\n  root.next = &root;\n  root.back = &root;\n  if((t = create(&root,s0,0)) != -1) return t;\n  \n  while(1) {\n    if((t = cal(&root)) != -1) break;\n  }\n  return t;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { char a[10]; } Board;\n\nBoard  board, *history;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nMotion motion[9][5] = {\n   {{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint minstep = 31;\n\nvoid search(int step, int space, int nhistories)\n{\n  int i, j;\n  if (strncmp(board.a, \"123456780\", 8)==0) {\n    if (step==1 || step==31) {\n      printf(\"%d\\n\", step);\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    for (j=0; j<nhistories; j++) {\n      if (strcmp(board.a, history[j].a)==0) return;\n    }\n    history[nhistories++] = board; \n    for (i=0; motion[space][i].pos>=0; i++) {\n      Motion *m = &motion[space][i];\n      \n      if (m->pos==0 && board.a[0]=='1') continue;\n      if ((m->pos==1||m->pos==2) && board.a[0]=='1'&&board.a[1]=='2'&&board.a[2]=='3') continue;\n      if ((m->dir==U&&m->pos<3)||(m->dir==D&&m->pos>5)||(m->dir==L&&m->pos%3==0) || (m->dir==R && m->pos%3==2)) continue;\n\n      board.a[space] = board.a[m->pos];\n      search(step+1, m->pos, nhistories);\n      board = history[nhistories-1];\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[0],&board.a[1],&board.a[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[3],&board.a[4],&board.a[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[6],&board.a[7],&board.a[8]);\n  history = (Board*)malloc(sizeof(Board)*31);\n  search(0, strchr(board.a, '0')-board.a, 0);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n\nint main()\n{\n\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 3\n#define UP 0\n#define DOWN 2\n#define LEFT 1\n#define RIGHT 3\n#define DEBUG 0\n#define true 1\n#define false 0\n\n\n\nint up[2] = {-1,0};\nint down[2] = {1,0};\nint left[2] = {0,-1};\nint right[2] = {0,1};\n\nint targetPoints[SIZE*SIZE][2] ;\n\nint cost;\nint blank_row,blank_column;\nint tState[SIZE][SIZE];\n\nvoid get_matrix(int tmp[][SIZE]);\nvoid print_matrix(int tmp[][SIZE]);\nvoid targetPoints_constructor(int state[][SIZE]);\nint getHeuristic(int tmp[][SIZE]);\nint checkState(int state[][SIZE]);\nint solve(int state[][SIZE], int blank_row, int blank_column, int dep, int d, int h);\n\nint main(){\n    int step  = 0;\n    int sState[SIZE][SIZE];\n    int conut = 0;\n    int x;\n    int y;\n    int i;\n    int j;\n\n    for(x = 0; x < SIZE ; x++){\n        for(y = 0; y<SIZE; y++){\n            tState[x][y] = x*SIZE + y + 1;\n        }\n    }\n    tState[SIZE-1][SIZE-1] = 0;\n\n    if(DEBUG)print_matrix(tState);\n\n    get_matrix(sState);\n\n    if(DEBUG)print_matrix(sState);\n    targetPoints_constructor(sState);\n\n    if(checkState(sState)){\n        printf(\"%d\\n\",step);\n    }else{\n        j = getHeuristic(sState);\n        i = -1;\n\n        for(cost = j; ;cost++){\n            if(solve(sState, blank_row, blank_column, 0 , i, j)){\n                break;\n            }\n        }\n        printf(\"%d\\n\",cost);\n    }\n}\n\nint solve(int state[][SIZE], int blank_row, int blank_column, int dep, int d, int h){\n    int h1;\n    int isSovled = checkState(state);\n    if(isSovled){\n        return true;\n    }\n    if(dep == cost){\n        return false;\n    }\n\n    int blank_row1;\n    int blank_column1;\n    int state2[SIZE][SIZE];\n    int direction = 0;\n    int i;\n    int j;\n\n    for(direction=0;direction<4;direction++) {\n        for(i=0;i<SIZE;i++) {\n            for(j=0;j<SIZE;j++) {\n                state2[i][j] = state[i][j];\n            }\n        }\n\n\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n \n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n\n\n\n}\n\nint checkState(int state[][SIZE]){\n    int b = true;\n    int i;\n    int j;\n    for(int i = 0;i<SIZE;i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (!(state[i][j] == tState[i][j])) {\n                b = false;\n            }\n        }\n    }\n    return b;\n}\n\nint getHeuristic(int tmp[][SIZE]){\n    int i;\n    int i2;\n    int j;\n    int j2;\n    int ans = 0;\n    int value = 0;\n    int gap = 0;\n    for(i = 0; i < SIZE; i++){\n        for(j = 0; j < SIZE; j++){\n            if(tmp[i][j] == 0)\n                continue;\n\n            if(tmp[i][j] != (i*SIZE+j+1)){\n                value = tmp[i][j];\n                i2 = j2 = gap = 0 ;\n                while(value >SIZE){\n                    value -= SIZE;\n                    i2++;\n                }\n                j2 = value -1;\n\n                gap += abs(i2-i);  \n                gap += abs(j2 -j);\n                //printf(\"h2 : i = %d   j = %d  gap= %d   value = %d  i2 = %d   j2 = %d \\n\",i,j,gap,tmp[i][j],i2,j2);\n                ans += gap;\n            }\n                \n        }\n    }\n    return ans;\n}\n\nvoid targetPoints_constructor(int state[][SIZE]){\n    int i;\n    int j;\n    for(i=0;i<SIZE;i++) {\n        for(j=0;j<SIZE;j++) {\n               if(state[i][j] == 0) {\n                   blank_row = i;\n                   blank_column = j;\n                   break;\n               }\n           }\n    }\n    if(DEBUG)printf(\"Xz = %d, Yz = %d\\n\",blank_row,blank_column);\n    for(i=0;i<SIZE;i++) {\n        for(j=0;j<SIZE;j++) {\n            targetPoints[tState[i][j]][0] = i;\n            targetPoints[tState[i][j]][1] = j;\n        }\n    }\n}\n\n\nvoid get_matrix(int tmp[][SIZE]){\n    int i;\n    int j;\n    for(i = 0; i < SIZE; i++){\n        for(j = 0; j < SIZE; j++){\n            scanf(\"%d\", &tmp[i][j]);\n        }\n    }\n    return;\n}\nvoid print_matrix(int tmp[][SIZE]){\n    int i;\n    int j;\n    for(i = 0; i < SIZE; i++){\n        printf(\"%d\",tmp[i][0]);\n        for(j = 1; j < SIZE; j++){\n            printf(\" %d\", tmp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 13\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}};\n\nint min = LIM;\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a;\n  int f=0;\n  int tmp[N][N];\n  //printf(\"A\\n\");\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  if(ans[i][j]!=p[i][j])f++;\n\t  if(p[i][j]==0)\n\t    {\n\t      i0=i;\n\t      j0=j;\n\t    }\n\t}\n    }\n\n  if(f==0)\n    {\n      if(min>n)\n\t{\n\t  min=n;\n\t}\n      return;\n    }\n  if(n>LIM) return;\n  \n  if(i0>0 && i0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0-1][j0];\n      tmp[i0-1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>0 && j0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0-1];\n      tmp[i0][j0-1]=f;\n      dfs(tmp, n+1);\n    }\n  \n  if(i0>=0 && i0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0+1][j0];\n      tmp[i0+1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>=0 && j0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0+1];\n      tmp[i0][j0+1]=f;\n      dfs(tmp, n+1);\n    }\n  \n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  scanf(\"%d\",&p[i][j]);\n\t}\n    }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n#define N2 9\n#define L 3628800//ã­ã¥ã¼ã®é·ã//ãã£ã¡ãã§ããããï¼\n\n\ntypedef struct{\n  int m[N][N];\n  int space;//å·¦ä¸0ã¨ãã¦ç©ºç½ã®ãã¡ãç¤ºã(0=8)\n  \n  int changetime;\n}MAS;\n\n\nint head=0, tail=0;//head=tailã§åæååºæ¥ã(ç©ºã«åºæ¥ã)////////////\nint all_tail=0;\nMAS Q[L];\nint All[L];//ããã«ãã§ã«ãã£ãã1\nint way[4];//æ¬¡ã«é²ãæ¹åãä¸å³ä¸å·¦\n//==================================\nvoid Swap(int *a,int *b){\n  int c=*a;\n  *a=*b;\n  *b=c;\n}\n\n//Que==================================\nint isEmpty(){//1ãªãç©º\n  if(head==tail)return 1;\n  return 0;\n}\n\n\nvoid Enqueue(MAS x){\n  Q[tail]=x;\n  tail=(tail+1)%L;\n}\n\nMAS Dequeue(){\n  MAS x=Q[head];\n  head=(head+1)%L;\n  return x;\n}\n//========================================\nint Judge(MAS A,MAS B){//æåãã¦ããã1 å¤±æãã¦ããã0//ï¼ã¤ã®ä¸¦ã³ãåããç¢ºããã\n \n  int i,j;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(A.m[i][j]!=B.m[i][j])return 0;\n    }\n  }\n  return 1;\n}\n\nint Allcal(MAS child){\n  return child.m[0][0]*L/9+child.m[0][1]*L/9/8+child.m[0][2]*L/9/8/7+child.m[1][0]*L/9/8/7/6+child.m[1][1]*L/9/8/7/6/5+child.m[1][2]*L/9/8/7/6/5/4+child.m[2][0]*L/9/8/7/6/5/4/3+child.m[2][1]*L/9/8/7/6/5/4/3/2+child.m[2][2];\n}\n\n\n\n  \nvoid  Way(MAS u){//æ¬¡ã«é²ããæ¹åãæãããé²ããªãæ¹åã¯0ãããããã®ã¯1\n  int i;\n  \n  for(i=0;i<4;i++)way[i]=1;//åæå;\n\n  if(u.space==0||u.space==1||u.space==2)way[0]--;//ä¸\n  if(u.space==2||u.space==5||u.space==8)way[1]--;//å³\n  if(u.space==6||u.space==7||u.space==8)way[2]--;//ä¸\n  if(u.space%3==0)way[3]--;//å·¦\n    \n  // printf(\"%d%d%d%d\\n\",way[0],way[1],way[2],way[3]);\n}\n\n\nint  BFS(MAS Input){//ä½åã§è§£ãããè¿ã\n  MAS u;\n  MAS child;\n  MAS ans={1,2,3,4,5,6,7,8,0,0,0};\n  int count=0;\n  int i;\n  int haba=1;\n  int l=0;\n\n  if(Judge(ans,Input)==1)return child.changetime;\n  Enqueue(Input);\n  All[Allcal(Input)]=1;\n   \n\n\n  while(!isEmpty()){\n    u=Dequeue();\n    Way(u);\n    \n    child=u;\n    if(way[0]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N-1][child.space%N]);\n      child.space-=N;\n      child.changetime++;\n      if(Judge(ans,child)==1)return child.changetime;\n\n    \n    \n      \n      if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }\n      //printf(\"up \");\n    }   \n      \n    child=u;\t\n    if(way[1]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N][child.space%N+1]);\n      child.space++;\n      child.changetime++;\n      if(Judge(ans,child)==1)return child.changetime;\n    \n    \n      \n      if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }\n      //printf(\"right \");\n    }\n    \n    child=u;\t\n    if(way[2]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N+1][child.space%N]);      child.changetime++;\n      child.space+=N;\n      if(Judge(ans,child)==1)return child.changetime;\n    \n    \n      \n      if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }//printf(\"down \");\n    }\n    \n    child=u;\t\n    if(way[3]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N][child.space%N-1]);      child.changetime++;\n      child.space--;\n      if(Judge(ans,child)==1)return child.changetime;\n    \n    \n      \n       if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }\n    }\n    \n    //printf(\"%d     \\n\",child.changetime);\n    // printf(\"\\nchild.changetime %d\\n================\\n\",child.changetime);\n    //long=Max(long,)\n  }\n  // printf(\"long%d\\n\",long);\n  return -2;//å¤±æ\n \n}\n\t\t     \n\n\n\n\n    \n\n\nint main(){\n  int i,j;\n  MAS Input={0,0,0,0,0,0,0,0,0,0,0};\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&Input.m[i][j]);\n      if(Input.m[i][j]==0)Input.space=i*N+j;\n    }\n  }\n\n  // printf(\"A.space=%d\\n\",A.space);\n  \n  printf(\"%d\\n\",BFS(Input));\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>        \n#include <stdlib.h>          \nint puzz[3][3];\nint temp[3][3];\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n \nvoid empty(int *x, int *y){\n  int i,j;\n  for (i = 0; i < 3; ++i){\n    for (j = 0; j < 3; ++j){\n      if (!puzz[i][j]){\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\nvoid swap(int *a, int *b){\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n \nint cal(){\n  int sum = 0,i,a;\n  for (i = 0; i < 9; ++i){\n   a = puzz[i / 3][i % 3];\n    if (a){\n      a--;\n      sum += abs(i / 3 - a / 3) + abs(i % 3 - a % 3);\n    }\n  }\n  return sum;\n}\n \nint dfs(int x, int y, int p, int dep, const int lim){\n  int h,i,nx,ny,res;\n    h = cal();\n  if(h == 0) return dep;\n \n  if(dep + h > lim) return -1;\n \n  for(i = 0; i < 4; ++i){\n    nx = x + dx[i];\n    ny = y + dy[i];\n \n    if(p != -1 && i == (p + 2) % 4) continue;\n \n    if(0 <= nx && nx < 3 && 0 <= ny && ny < 3){\n      swap(&puzz[y][x], &puzz[ny][nx]);\n      res = dfs(nx, ny, i, dep + 1, lim);\n      if (res != -1) return res;\n      swap(&puzz[y][x], &puzz[ny][nx]);\n    }\n  }\n  return -1;\n}\n \nint main(){\n  int i,j,ans,x,y,l;\n  for(i = 0; i < 3; ++i){\n    for(j = 0; j < 3; ++j)scanf(\"%d\", &puzz[i][j]);\n  }\n \n  \n  empty(&x, &y);\n  \n  for(l = 0; l < 100; ++l){\n    for(i = 0; i < 3; ++i){\n      for(j = 0; j < 3; ++j) temp[i][j] = puzz[i][j];\n    }\n   ans = dfs(x, y, -1, 0, l);\n    if(ans != -1){\n      printf(\"%d\\n\", ans);\n      break;\n    }\n    for(i = 0; i < 3; ++i){\n      for(j = 0; j < 3; ++j) puzz[i][j] = temp[i][j];\n    }\n \n    ans = -1;\n    if(l == 99) printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 3\n#define TRUE 1\n#define FALSE 0\n\nint judge(void);\nint dfs(int,int,int,int,int);\n\nint answer[MAX][MAX] = {\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint f[MAX][MAX];\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint main(){\n  int x,y;\n  int result;\n  int i,j;\n\n  for (i = 0;i < MAX;i++)\n    for (j = 0;j < MAX;j++){\n      scanf(\"%d\",&f[i][j]);\n\n      if (f[i][j] == 0){\n\ty = i;\n\tx = j;\n      }\t\n    }\n\n  for (i = 1;i < 10000;i++){\n    result = dfs(x,y,-1,0,i);\n\n    if (result >= 0)\n      break;\n  }\n\n  printf(\"%d\\n\",result);\n\n  return 0;\n}\n\n//å¤å®ç¨\nint judge(void){\n  int i,j;\n\n  for (i = 0;i < MAX;i++)\n    for (j = 0;j < MAX;j++)\n      if (f[i][j] != answer[i][j])\n\treturn FALSE;\n\n  return TRUE;\n}\n\nint dfs(int x,int y,int v,int d,int l){\n  int i,j;\n  int result;\n  int nx,ny;\n\n  if (judge())\n    return d;\n\n//æ·±ããåºæºå¤ãè¶ãã¦ããã\n  if (d > l)\n    return -1;\n\n//ç§»åãããã¨ãèãã\n  for (i = 0;i < 4;i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n\n//ç¯å²ãè¶ããªãããã§ãã¯\n    if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n      continue;\n\n//ç§»åå¾ã®æå ±ãï½ãï½ã«ç§»å\n    f[y][x] = f[ny][nx];\n    f[ny][nx] = 0;\n\n//æ´ã«æãä¸ãã\n    if ((result = dfs(nx,ny,i,d + 1,l)) > 0)\n      return result;\n\n    f[ny][nx] = f[y][x];\n    f[y][x] = 0;\n  }\n\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint cp[3][3];\n\nvoid input() {\n\tint i, j;\n\tfor (i = 0; i < 3; i++)\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tscanf(\"%d\", &puz[i][j]);\n}\n\n\nvoid copy(int m[3][3], int t[3][3]) {\n\tint i, j;\n\tfor (i = 0; i < 3; i++)\n\t\tfor (j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n\tint i, sum = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tint v = puz[i / 3][i % 3];\n\t\tif (v) {\n\t\t\tv--;\n\t\t\tsum += abs(i / 3 - v / 3) + abs(i % 3 - v % 3);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid swap(int *a, int *b) {\n\tint tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\nint is_in(int x, int y) {\n\treturn 0 <= x && x<3 && 0 <= y && y<3;\n}\n\nint depth(int x, int y, int p, int dep, const int lim) {\n\tint i, h = calc();\n\tif (h == 0) return dep;\n\tif (dep + h > lim) return -1;\n\tfor (i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i], res;\n\t\tif (~p && i == (p + 2) % 4) continue;\n\t\tif (!is_in(nx, ny)) continue;\n\t\tswap(&puz[y][x], &puz[ny][nx]);\n\t\tres = depth(nx, ny, i, dep + 1, lim);\n\t\tif (~res) return res;\n\t\tswap(&puz[y][x], &puz[ny][nx]);\n\t}\n\treturn -1;\n}\n\nvoid get_empty(int *x, int *y) {\n\tint i, j;\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tif (!puz[i][j]) {\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve() {\n\tint x, y, lim, ans;\n\tget_empty(&x, &y);\n\tfor (lim = 0; lim < 50; lim++) {\n\t\tcopy(cp, puz);\n\t\tif ((ans = depth(x, y, -1, 0, lim)) != -1) return ans;\n\t\tcopy(puz, cp);\n\t}\n\treturn -1;\n}\n\nint main() {\n\tinput();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 876543\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;//\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/1000;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int a= 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    a+= factorial[8-i]*(s[i]-'0'-t);\n  }\n  return a;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,b;\n \n  b= que[head];\n  char *s = tagtos(b);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[b]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[b]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[b]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[b]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char a[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    a[i] = d+'0';\n  }\n  a[9] = '\\0';\n  printf(\"%d\\n\",solve(a)-1);\n   \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h> \n#define pt 3\n#define py 3\n#define psum (pt*py)\n#define cnt 45\nextern inline void ue();\nextern inline void sita();\nextern inline void hdr();\nextern inline void mgi();\nextern int  find(int,int,int,int);\nint zero = 0,pzl[psum];\nint main()\n{\n    int i = 0,x,y = 0;\n    for(i=0;i<psum;i++)\n    {\n        scanf(\"%d\",&pzl[i]);\n         \n        if(pzl[i] == 0) zero = i;\n    }\n     \n    x = pt - (zero/py) -1;\n    y = py - (zero%py) -1;\n     \n    for(i=0; i<cnt; i++)\n    {\n        if( find(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n     \n    return 0;\n}\n \nint find(int x, int y, int mcnt, int p)\n{\n    int res;\n    int i=0;\n     \n    if(mcnt < (x + y) )\n    {\n        return 0;\n    }\n    if(mcnt==0)\n    {\n        for(i=0; i<psum-1; i++)\n        {\n            if(pzl[i] != (i+1)) return 0;\n        }\n        return 1;\n    }\n    for(i=0; i<4; i++)\n    {\n        res = 0;\n         \n        switch(i)\n        {\n            case 0:\n                if( (x>0) && (p!=3) )\n                {\n                    sita();\n                    res = find(x-1, y, mcnt-1, 0);\n                    ue();\n                }\n                break;\n                 \n            case 1:\n                if((p!=2)&&(y>0))\n                {\n                    mgi();\n                    res = find(x,y-1,mcnt-1,1);\n                    hdr();\n                }\n                break;\n                 \n            case 2:\n                if((p!=1)&&(y<py-1))\n                {\n                    hdr();\n                    res = find(x,y+1, mcnt-1,2);\n                    mgi();\n                }\n                break;\n                 \n            case 3:\n                if((x<pt-1)&&(p!=0))\n                {\n                    ue();\n                    res = find(x+1,y,mcnt-1,3);\n                    sita();\n                }\n                break;\n            default:\n                break;\n        }\n         \n        if(res)\n        {\n            return 1;\n        }\n    }\n     \n    return 0;\n}\n \n \ninline void sita()\n{\n    pzl[zero] = pzl[zero+py];\n    zero += py;\n}\n  \ninline void ue()\n{\n    pzl[zero] = pzl[zero-py];\n    zero -= py;\n}\n  \ninline void mgi()\n{\n    pzl[zero] = pzl[zero+1];\n    zero += 1;\n}\n  \ninline void hdr()\n{\n    pzl[zero] = pzl[zero-1];\n    zero -= 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n#define LEN 362880\nint head = 0, tail = 0;\nint que[LEN];\n\nint start[9]; //åæç¶æ\t\nint goal = 46233;\t//æçµç¶æ\nint search[362880] = { 0 };\t//æ¢ç´¢æ¸ã¿\nint board[362880][9];\t//ç¤é¢ã®ç¶æ\nint d[362880];\t//æé\nint oya; //è¦ªã®ãã³ãã¼\nint dummy[9];\t//ç¤é¢ã³ãã¼ç¨\nint p0[362880];\t//0ã®ä½ç½®ãè¨æ¶\n\n/*ç¤é¢ã®é£æ¥ãªã¹ã*/\nint next[9][5] = { {2, 1, 3},\n\t\t\t\t   {3, 0, 2, 4},\n                   {2, 1, 5},\n\t\t\t\t   {3, 0, 4, 6},\n                   {4, 1, 3, 5, 7},\n\t\t\t\t   {3, 2, 4, 8},\n                   {2, 3, 7},\n                   {3, 4, 6, 8},\n\t\t\t\t   {2, 5, 7}\n};\n\n/*ã­ã¥ã¼ã®å®è£*/\nint isempty() {\n\treturn head == tail;\n}\n\nvoid enqueue(int x) {\n\tque[tail] = x;\n\tif ((tail + 1) == LEN)\n\t\ttail = 0;\n\telse\n\t\ttail++;\n}\n\nint dequeue() {\n\tint x;\n\tx = que[head];\n\tif ((head + 1) == LEN)\n\t\thead = 0;\n\telse\n\t\thead++;\n\treturn x;\n}\n\n/*0ã®ãã¹ãæ¢ç´¢*/\nint a_mas0(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*ç¤é¢ãã³ãã¼*/\nvoid board_copy(int a[], int b[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tb[i] = a[i];\n}\n\n/*éä¹ãè¨ç®*/\nint n_factorial(int n) {\n\tif (n == 1)\n\t\treturn 1;\n\treturn n * n_factorial(n - 1);\n}\n\n/*ç¤é¢è¨æ¶ã®ããã«ä½¿ç¨*/\nvoid a_location(int a[], int s) {\n\tfor (int i = s + 1; i < 9; i++)\n\t\tif (a[s] < a[i])\n\t\t\ta[i]--;\n}\n\n/*ç¤é¢ã®ç¶æãæ°å¤ã«å¤æ*/\nint assign_number(int a[]) {\n\tint b[9];\n\tint num = 0;\n\tint pos = 8;\n\tboard_copy(a, b);\n\tfor (int i = 8; i > 0; i--) {\n\t\tnum = num + b[8 - i] * n_factorial(i);\n\t\ta_location(b, 8 - i);\n\t\tif (a[8 - i] == 0)\n\t\t\tpos = 8 - i;\n\t}\n\tp0[num] = pos;\n\treturn num;\n}\n\n/*ãã¹ã®ç§»å*/\nvoid move(int *a, int *b) {\n\tint box;\n\tbox = *a;\n\t*a = *b;\n\t*b = box;\n}\n\n/*ç¤é¢ã®è¡¨ç¤º*/\nvoid puzzle_print(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tprintf(\"%d \", a[i]);\n\tprintf(\"\\n\");\n}\n\n/*0ã®ä½ç½®ãæ¢ç´¢*/\nint zero_position(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*å¹åªåæ¢ç´¢*/\nint bsf() {\n\tint num;\n\tint pos;\n\twhile (isempty() != 1) {\n\t\toya = dequeue();\n\t\tpos = p0[oya];\n\t\tfor (int i = 1; i <= next[pos][0]; i++) {\n\t\t\tboard_copy(board[oya], dummy);\t//oyaã®ç¤é¢ãdummyã«ã³ãã¼\n\t\t\tmove(&dummy[pos], &dummy[next[pos][i]]);\t//dummyã®ç¤é¢ãç§»å\n\t\t\tnum = assign_number(dummy);\t//ç§»åããç¤é¢ãæ°å¤ã«å¤æ\n\t\t\tif (num == goal){\t//æçµç¶æãçºè¦\n\t\t\t\td[num] = d[oya] + 1;\t\n\t\t\t\tsearch[num] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (search[num] != 1) {\t//æçµç¶æã§ãªã\n\t\t\t\tsearch[num] = 1;\n\t\t\t\tboard_copy(dummy, board[num]);\n\t\t\t\td[num] = d[oya] + 1;\n\t\t\t\tenqueue(num);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i = 0;\n\tint num;\n\t\n\t/*åæç¶æã®è¨­å®*/\n\tfor (i = 0; i < 9; i++)\n\t\tscanf(\"%d\", &start[i]);\n\tnum = assign_number(start);\t//åæç¶æã®æ°å¤\n\tboard_copy(start, board[num]);\t//åæç¶æã®ç¤é¢ãè¨æ¶\n\tsearch[num] = 1;\t//åæç¶æã®æ°å¤ãè¨æ¶(1ããã¦ã)\n\td[num] = 0;\t//åæç¶æã®æéã0ã«è¨­å®\n\tenqueue(num); //åæç¶æã®æ°å¤ãã­ã¥ã¼ã«æ ¼ç´\n\t\n\t/*æ¢ç´¢éå§*/\n\tif (num == goal)\n\t\tprintf(\"0\\n\");\n\telse if (bsf() == 1)\n\t\tprintf(\"%d\\n\", d[goal]);\n\telse\n\t\tprintf(\"ãªã\\n\"); \n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\n\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\n\nvoid emp(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint calsum(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=calsum();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  emp(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n    ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint pl[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid em(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid SW(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint cal(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n\nint df(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = cal();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n    result = df(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pl[i][j]);\n    }\n  }\n\n    em(&a,&b);\n    for(li=0;li<100;li++){\n      for(i=0;i<3;i++){\n\tfor(j=0;j<3;j++){\n\t  tmp[i][j]=pl[i][j];\n\t}\n      }\n\tTA = df(a,b,-1,0,li);\n\tif(TA!=-1){\n\t  printf(\"%d\\n\",TA);\n\t  break;\n\t}\n\n\tfor(i=0;i<3;i++){\n\t  for(j=0;j<3;j++){\n\t    pl[i][j]=tmp[i][j];\n\t  }\n\t}\n\n\tTA = -1;\n\tif(li==99){\n\t      printf(\"%d\\n\",TA);\n\t    }\n      }\n\n    return 0;\n\t    }\n\n  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) || (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) || (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n \n    int ori[Total] ={};\n    \n    \n    int i = 0;\n    int num_0 = 0;\n    int x,y = 0;\n     \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        ori[i]=val[i];\n        \n        if(val[i] == 0)\n        {\n            num_0 = i;\n        }\n    }\n    \n    x = tate - (num_0/yoko);\n    y = yoko - (num_0%yoko);\n    \n        // åæå\n        for(i=0; i<Total; i++)\n        {\n            val[i]=ori[i];\n        }\n        num = num_0;\n        cnt = 0;\n        \n    for(i=1; i<10; i++)\n    {\n        if( serch(x,y,i) )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n        \n//  printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);        \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(cnt >= MaxCnt)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x != 0)\n                {\n                    down_0();\n                    x = x-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    up_0();\n                    x = x+1;\n                }\n                break;\n            case 1:\n                if(y != 0)\n                {\n                    right_0();\n                    y = y-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    left_0();\n                    y = y+1;\n                }\n                break;\n            case 2:\n                if(y < yoko-1)\n                {\n                    left_0();\n                    y = y+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    right_0();\n                    y = y-1;\n                }\n                break;\n            case 3:\n                if(x < tate-1)\n                {\n                    up_0();\n                    x = x+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    down_0();\n                    x = x-1;\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n \nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!puz[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\n \nvoid swap(int *a, int *b) {\n  int tmp;\n  tmp= *a;\n  *a= *b;\n  *b=tmp;\n}\n \nint cal() {\n  int i,a;\n  int sum=0;\n  for(i=0;i<9;i ++){\n    a=puz[i/3][i%3];\n    if(a){\n      a--;\n      sum+=abs(i/3-a/3)+abs(i%3-a%3);\n    }\n  }\n  return sum;\n}\n \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0){\n    return dep;\n  }\n  if(dep+h>lim){\n    return -1;\n  }\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res=dfs(nx,ny,i,dep+1,lim);\n    if(~res){\n      return res;\n    }\n    swap(&puz[y][x],&puz[ny][nx]);\n    }\n  return -1;\n}\n \nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puz[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j =0;j<3;j++){\n        tmp[i][j] = puz[i][j];\n      }\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        puz[i][j]=tmp[i][j];\n      }\n    }\n    ans= -1;\n    if(l==99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \n#define tate 3\n#define yoko 3\n#define SUM (tate*yoko)\n#define Cnt 45\nextern inline void up(void);     \nextern inline void down(void);     \nextern inline void right(void);   \nextern inline void left(void);    \nextern int  serch(int a, int b, int cnt,int p);\n \nint n = 0,A[SUM]; \n\nint main()\n{\n  int i = 0,a,b= 0;\n     \n    \n    for(i=0; i<SUM; i++)\n    {\n        scanf(\"%d\",&A[i]);\n         \n        if(A[i] == 0)n = i;\n    } \n    a = tate - (n/yoko) -1;\n    b = yoko - (n%yoko) -1;\n    for(i=0; i<Cnt; i++){\n        if( serch(a,b,i,4) == 1 ){\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }          \n    return 0;\n}\n \nint serch(int a, int b, int cnt, int p)\n{\n  int res, i=0;\n     \n  if(Cnt < (a + b) )return 0;  \n    if(cnt==0){\n        for(i=0; i<SUM-1; i++){\n            if(A[i] != (i+1))return 0;\n        }   \n        return 1;\n    }\n        \n    for(i=0; i<4; i++){\n        res= 0;        \n        switch(i){\n            case 0:\n                if( (a> 0) && (p != 3) ){\n                    down();      \n                    res = serch(a-1, b, cnt-1, 0);\n                    up();\n                }\n                break;\n                 \n            case 1:\n\t      if( (b> 0) && (p != 2)){\n                    right();\n                    res = serch(a, b-1, cnt-1, 1);\n                    left();\n                }\n                break;\n                 \n            case 2:\n                if( (b < yoko -1 ) && (p != 1) ){\n                    left();\n                    res = serch(a, b+1, cnt-1, 2);\n                    right();\n                }\n                break;\n                 \n            case 3:\n                if( (a < tate -1 ) && (p != 0) ){\n                    up();\n                    res = serch(a+1, b, cnt-1, 3);\n                    down();\n                }\n                break;\n                 \n            default:\n                break;\n        }\n        if(res)return 1;\n    }     \n    return 0;\n}\n \ninline void up()\n{\n    A[n] = A[n - yoko];\n    n = n - yoko;\n}\n \ninline void down()\n{\n    A[n] = A[n + yoko];\n    n = n + yoko;\n}\n  \ninline void right()\n{\n    A[n] = A[n +1];\n    n = n + 1;\n}\n  \ninline void left()\n{\n    A[n] = A[n -1];\n    n = n - 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\nint ansArr[N][N]={{1,2,3},\n                  {4,5,6},\n                  {7,8,0}};\nint tempArr[N][N];\nint curMinCost=40;\nvoid calcMinCost(int,int);\nint get0Row(void);\nint get0Col(void);\nint isCorrect(void);\nvoid printArr(void);//debugging\nint main(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      scanf(\"%d\",&tempArr[i][j]);\n  calcMinCost(0,0);\n  printf(\"%d\\n\",curMinCost);\n  return 0;\n}\nvoid calcMinCost(int cost,int lastMove)\n{\n  int row,col;\n  //printArr();\n  if(cost>=curMinCost) return;\n  if(isCorrect()==1)\n    {\n      curMinCost=cost;\n      return;\n    }\n  row=get0Row();\n  col=get0Col();\n  if(row!=N-1&&lastMove!=3)//slide up\n    {\n      tempArr[row][col]=tempArr[row+1][col];\n      tempArr[row+1][col]=0;\n      calcMinCost(cost+1,1);\n      tempArr[row+1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=N-1&&lastMove!=4)//slide left\n    {\n      tempArr[row][col]=tempArr[row][col+1];\n      tempArr[row][col+1]=0;\n      calcMinCost(cost+1,2);\n      tempArr[row][col+1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(row!=0&&lastMove!=1)//slide down\n    {\n      tempArr[row][col]=tempArr[row-1][col];\n      tempArr[row-1][col]=0;\n      calcMinCost(cost+1,3);\n      tempArr[row-1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=0&&lastMove!=2)//slide right\n    {\n      tempArr[row][col]=tempArr[row][col-1];\n      tempArr[row][col-1]=0;\n      calcMinCost(cost+1,4);\n      tempArr[row][col-1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n}\nint get0Row(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return i;\n}\nint get0Col(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return j;\n}\nint isCorrect(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(ansArr[i][j]!=tempArr[i][j]) return 0;\n  return 1;\n}\nvoid printArr(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n        {\n          printf(\"%d \",tempArr[i][j]);\n        }\n      printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define N 3\n\nint Puzzle[N][N];\nint tmp[N][N];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid empty(int *,int *);\nint dfs(int ,int,int ,int ,int );\nint cal(void);\n\n\nint main(){\n\tint i,j,limit;\n\tint b,a,c;\n\n\n\tfor(i =0;i < N; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\tscanf(\"%d\",&Puzzle[i][j]);\n\t\t}\n\t}\n\tempty(&a,&b);\n\n\tfor(limit = 0; limit < 60 ; limit++){\n\t\tfor(i = 0; i < N ; i++){\n\t\t\tfor(j = 0; j < N ; j++){\n\t\t\t\ttmp[i][j] = Puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\tc = dfs(a,b,-1,0,limit);\n\t\tif(c!= -1){\n\t\t\tprintf(\"%d\\n\",c);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(i = 0; i < N ; i++){\n\t\t\tfor(j = 0 ; j < N ; j++){\n\t\t\t\tPuzzle[i][j] = tmp[i][j];\n\t\t\t}\n\t\t}\n\t\tc =-1;\n\t\tif(limit == 49)printf(\"%d\\n\",c);\n\t}\n\n\treturn 0;\n}\n\nvoid empty(int *x,int *y){\n\tint i,j;\n\tfor(i = 0; i < N ; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\tif(!Puzzle[i][j]){\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint dfs(int x,int y,int p, int dep, int lim){\n\tint i,j,h,n1,n2,res;\n\tint cp;\n\n\th = cal();\n\n\tif(h == 0)return dep;\n\tif(dep + h > lim) return -1;\n\n\tfor(i = 0; i< 4; i++){\n\t\tn1 = x + dx[i];\n\t\tn2 = y + dy[i];\n\n\t\tif(~p && i == (p+2)%4) continue;\n\t\tif(!(0 <= n1 && n1 < 3 && 0 <= n2 && n2 < 3)) continue;\n\n\t\tcp = Puzzle[y][x];\n\t\tPuzzle[y][x] = Puzzle[n2][n1];\n\t\tPuzzle[n2][n1] = cp;\n\n\t\tres = dfs(n1,n2,i,dep+1,lim);\n\t\tif(~res)return res;\n\n\t\tcp = Puzzle[y][x];\n\t\tPuzzle[y][x] = Puzzle[n2][n1];\n\t\tPuzzle[n2][n1] = cp;\n\n\t}\n\treturn -1;\n}\n\nint cal(void){\n\tint i,a;\n\tint sum = 0;\n\n\tfor(i = 0; i< N+6 ; i++){\n\t\ta = Puzzle[i/3][i%3];\n\t\tif(a){\n\t\t\ta--;\n\t\t\tsum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n\t\t}\n\t}\n\treturn sum;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 362880 \n\ntypedef struct \n{\n\tint f[9];\n\tint space;\n\tint path;\n}P;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint V[MAX];\n\nP Q[MAX];\nint head, tail;\n\nint kara()\n{\n    if (head == kara)\n\t    return 1;\n    else\n        return 0;  \n}\n\nvoid push(P x)\n{\n\tQ[tail] = x;\n\ttail = (tail+1)%MAX;\n}\n\nP front()\n{\n\tP x;\n\tx = Q[head];\n\thead = (head+1)%MAX;\n\treturn x;\n}\n\nint cheak(P p)\n{\n\tint i, j, fac, count, res = 0;\n\tfor(i = 0, fac = 1; i < 9; fac*= ++i)\n    {\n\t\tfor(j = 0, count = 0; j < i; j++)\n        {\n\t\t\tif(p.f[j] < p.f[i]) \n              count++;\n\t\t}\n\t\tres = res + (count*fac);\n\t}\n\treturn res;\t\n}\n\nint target(P p)\n{\n\tint i;\n\tfor(i = 0; i < 9; i++ )\n\t\tif(p.f[i] != (i + 1) ) return 0;\n\treturn 1;\n}\n\nint bfs(P s)\n{\n\tint sx, sy, tx, ty, r, temp;\n\tP u, v;\n\t\n\ts.path = 0;\n\t\n\tpush(s);\n\t\n\tV[cheak(s)] = 1;\n\t\n\twhile(!kara())\n    {\n\t\tu = front();\n\t\tif( target(u)) return u.path;\n\t\tsx = u.space / 3;\n\t\tsy = u.space % 3;\n\t\t\n\t\tfor ( r = 0; r < 4; r++ ) \n        {\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\t\t\tv = u;\n\t\t\t\n\t\t\ttemp = v.f[u.space];\n\t\t\tv.f[u.space] = v.f[tx * 3 + ty];\n\t\t\tv.f[tx * 3 + ty] = temp;\n\t\t\t\n\t\t\tv.space = tx * 3 + ty;\n\t\t\t\n\t\t\tif( !V[cheak(v)] )\n            {\n\t\t\t\tV[cheak(v)] = 1;\n\t\t\t\tv.path++;\n\t\t\t\tpush(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, a;\n\tP in;\n\t\n\tfor( i = 0; i < 9; i++ ) \n    {\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif( in.f[i] == 0) \n        {\n\t\t\tin.f[i] = 9;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\t\n\ta = bfs(in);\n\tprintf(\"%d\\n\",a);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \nstruct dep{\n    int depth,key;\n};\n \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}\n    };\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i0,j0,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n     \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n     \n    if(i0>0 && i0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n     \n    if(i0>=0 && i0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n     \n}\n \nint main()\n{\n    int i,j;\n    int p[N][N];\n     \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n     \n    printf(\"%d\\n\",min);\n     \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n    int depth,key;\n};\n\nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i0,j0,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n    \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n    \n    if(i0>0 && i0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n    \n    if(i0>=0 && i0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n    \n}\n\nint main()\n{\n    int i,j;\n    int p[N][N];\n    \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n    \n    printf(\"%d\\n\",min);\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\n  int i,f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const{\n\n    for(i = 0;i < N2;i ++)\n      {\n\tif(f[i] == p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n \n \nint main(){\n\n  Puzzle in;\n\n  int i;\n\n  string ans;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      cin >> in.f[i];\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n  ans = bfs(in);\n\n  cout << ans.size() << endl;\n \n  return 0;\n}\n\nbool isTarget(Puzzle p){\n\n  int i;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      if(p.f[i] != (i + 1)) return false;\n    }\n  \n  return true;\n}\n \nstring bfs(Puzzle s){\n\n  int sx,sy,tx,ty,r;\n  \n  queue<Puzzle> Q;\n\n  map<Puzzle, bool> V;\n\n  Puzzle u, v;\n\n  s.path = \"\";\n\n  Q.push(s);\n\n  V[s] = true;\n \n  while(!Q.empty()){\n\n    u = Q.front();\n\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for(r = 0;r < 4;r ++)\n      {\n\ttx = sx + dx[r];\n\tty = sy + dy[r];\n\n\tif(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n       \n\tv = u;\n      \n\tswap(v.f[u.space], v.f[tx * N + ty]);\n      \n\tv.space = tx * N + ty;\n      \n\tif(!V[v]){\n\t  V[v] = true;\n\t  v.path += dir[r];\n\t  Q.push(v);\n\t}\n      }\n  }\n \n  return \"unsolvable\";\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<45; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib>\n\n int puzle[3][3];\n int tmp[3][3;\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,1);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0;i<MAX;i++)\n    for(j=0;j<MAX;j++)\n      if(!pane[i][j]){\n\t*row=j;\n\t*col=i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0;i<9;i++){\n    e=pane[i/3][i%3];\n    if(e){\n      e--;\n      count+=abs(i/3-e/3)+abs(i%3-e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i;\n  int len;\n  int x_2,y_2;\n  int emc;   \n  len=cal();\n  if(len==0) return deep;\n  if(deep+len>limt) return -1; \n  for(i=0;i<4;i++){\n    x_2=x+d_x[i];\n    y_2=y+d_y[i];      \n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc=dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n} \n\nint main() {\n  int i,j;\n  int h,a,row,col;\n      \n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0;h<100;h++){\n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\ttemp[i][j]=pane[i][j];\n    }    \n    a=dfs(row,col,-1,0,h);    \n    if(a!=-1){\n      printf(\"%d\\n\",a);\n      break;\n    }    \n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\tpane[i][j]=temp[i][j];\n    }    \n    a=-1;\n    if(h==99) printf(\"%d\\n\\n\",a);\n  }      \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  \n#define N 3\n#define L 32\n#define H 362897\n  \nstruct dep {\n    int depth, key;\n};\n  \nint ans[N][N] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}};\n  \nint min = L;\nstruct dep h[H];\n  \nint hash1(int k) {\n    return k % H;\n}\n\nint hash2(int k) {\n    return 1 + k % (H-1);\n}\n\nint hash(int k, int i) {\n    return (hash1(k) + i * hash2(k)) % H;\n}\n  \nvoid dfs(int p[N][N], int n) {\n    int i, j, i1, j1, a = 0, b = 1;\n    int f = 0;\n    int tmp[N][N];\n    for (i=0;i<N;i++) {\n        for (j = 0; j<N; j++) {\n            if (ans[i][j] != p[i][j]) f++;\n            if(p[i][j] == 0) {\n                i1 = i;\n                j1 = j;\n            }\n            a += p[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if (f == 0) {\n        if(min >= n) {\n            min = n;\n        }\n        return;\n    }\n    if(n > min) return;\n    i = 0;\n    while(1) {\n        b = hash(a, i);\n        if (h[b].key == 0) {\n            h[b].key = a;\n            h[b].depth = n;\n            break;\n        }\n        else if (h[b].key == a) {\n            if (h[b].depth > n) {\n                h[b].depth = n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n      \n    if(i1 > 0 && i1 < N) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 - 1][j1];\n        tmp[i1 - 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 > 0 && j1 < N) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 - 1];\n        tmp[i1][j1 - 1] = f;\n        dfs(tmp, n + 1);\n    }\n      \n    if(i1 >= 0 && i1 < N - 1) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 + 1][j1];\n        tmp[i1 + 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 >= 0 && j1 < N - 1) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 + 1];\n        tmp[i1][j1 + 1] = f;\n        dfs(tmp, n + 1);\n    }\n}\n  \nint main(void)\n{\n    int i, j;\n    int p[N][N];\n      \n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            scanf(\"%d\", &p[i][j]);\n        }\n    }\n    dfs(p, 0);\n      \n    printf(\"%d\\n\", min);\n      \n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define YOKO 3\n#define TATE 3\n\nint DFS(int P[TATE][YOKO],int,int);\nint koukanmae(int,int,int);\nvoid koukan(int P[TATE][YOKO],int irekae2[TATE][YOKO],int,int,int);\nint Heuristic(int s[TATE][YOKO]);\n\nint Ans[TATE][YOKO]={1,2,3,4,5,6,7,8,0};//ç­\nint puzzle[TATE][YOKO];//åé¡\nint irekae[TATE][YOKO];//ä»®puzzle\n\nint clear=100000;\nint limit;//æ·±ãã®éåº¦\n\nint x[4]={0,1,0,-1},y[4]={-1,0,1,0};\n\n/*\n\nï¼ï¼ï¼x[4],y[4]ã«ã¤ãã¦ï¼ï¼ï¼\n\nx[4]ã¨y[4]ã¯ãã¹ã¨ãã¹ãå¥ãæ¿ããæã«ã»ããã§ç¨ããã\nãªãéåã«å¥ãããã¨ããã¨ãforæã§ã¾ã¨ãã¦å¥æ¿ä½æ¥­ãã§ããããã§ããã\n\nããããã¯é¢æ°ãã¿ãã\n\n*/\n\n\nint main()\n{\n  int i,j;\n\n  /*åé¡ã®ããºã«ãä»£å¥*/\n  \n  for(i=0;i<TATE;i++)\n    {\n      for(j=0;j<YOKO;j++)\n\t{\n\t  scanf(\"%d\",&puzzle[i][j]);\n\t}\n    }\n\n  while(1)\n    {\n      if(DFS(puzzle,-1,0)==1)break;\n      limit++;\n    }\n\n  printf(\"%d\\n\",clear);\n\n  return 0;\n}\n\nint DFS(int P[TATE][YOKO],int not,int hukasa)\n{\n\n  int i,j,a,b;\n  int zx,zy;//ï¼ã®ä½ç½®ç¹å®\n  int hantei=1;\n  int OK;\n  int irekae2[TATE][YOKO];\n  int H;\n  int hata=0;\n  \n  /*puzzleãAnsã¨ãã£ã¦ãããå¤å®*/\n\n  for(i=0;i<TATE;i++)\n    {\n      for(j=0;j<YOKO;j++)\n\t{\n\t  if(P[i][j]!=Ans[i][j])\n\t    {\n\t      hantei=0;\n\t    }\n\t   if(P[i][j]==0)\n\t\t{\n\t\t  zy=i;\n\t\t  zx=j;\n\t\t}\n\t}\n    }\n\n  if(hantei==1)\n    {\n      clear=hukasa;\n      return 1;//ãã£ã¦ããã1è¿ãã\n    }\n  else\n    {\n      for(i=0;i<4;i++)\n\t{\n\t  if((i+2)%4==not)continue;\n\t  \n\t  if(koukanmae(zx,zy,i)==1)\n\t    {\n\t      koukan(P,irekae2,zx,zy,i);\n\t\t  \n\t      H=Heuristic(irekae2);\n\n\t      if(hukasa+H<=limit)\n\t\t{\t\t\n\t\t  hata=DFS(irekae2,i,hukasa+1);\n\t\t  if(hata==1)return 1;\n\t\t}\n\t    }\n\t  \n\t}\n    }\n  return 0;\n}\n\n\nint koukanmae(int zx,int zy,int i)\n{\n  if( zx+x[i]>=YOKO || zx+x[i]<0\n      || zy+y[i]>=TATE || zy+y[i]<0 )\n    {\n      return 0;\n    }\n  else\n    {\n      return 1;\n    }\n}\n\n\nvoid koukan(int P[TATE][YOKO],int irekae2[TATE][YOKO],int zx,int zy,int i)\n{\n  int j,k,koukan;\n  \n  for(j=0;j<TATE;j++)\n    {\n      for(k=0;k<YOKO;k++)\n\t{\n\t  irekae2[j][k]=P[j][k];\n\t}\n    }\n  \n  koukan = irekae2[ zy +y[i] ][ zx+x[i] ];\n  irekae2[zy][zx]=koukan;\n  irekae2[ zy +y[i] ][ zx+x[i] ]=0;\n\n  }\n\n\nint Heuristic(int s[TATE][YOKO])\n{\n  int i,j,k=0,H2=0,cell[9],kyori=0;\n\n  for(i=0;i<TATE;i++)\n    {\n      for(j=0;j<YOKO;j++)\n\t{\n\t  cell[k]=s[i][j];\n\t  k++;\n\t}\n    }\n  for(i=0;i<9;i++)\n    {\n      if(cell[i]!=0)\n\t{\n\t  kyori+=abs((cell[i]-1)%3-i%3);\n\n\t  kyori+=abs((cell[i]-1)/3-i/3);\n\t}\n    }\n  \n\n  return kyori;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217    // 181441\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 30000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint i;\n\tint x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8, s[0].v = 0;\n\ttop = 0, end = 1;\n\tinsert(s[0].s, s[0].x, 0);\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x, v = s[top].v;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x == gx && a == gs) break;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx, s[end].v = nv;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n \nint calculateHeuristic(int board[3][3]) {\n    int res = 0;\n    int a, i, j;\n    \n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) {\n            if (board[i][j] == 0) continue;\n            a = board[i][j] - 1;\n            res += abs(a / 3 - i) + abs(a % 3 - j);\n        }\n    \n    return res;\n}\n\nvoid swap(int * a, int * b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint check(int board[3][3], int limit, int depth, int prev, int py, int px) {\n    int heuriScore = calculateHeuristic(board);\n    \n    if (heuriScore + depth > limit) return 0;\n    \n    // same board!! success!\n    if (heuriScore == 0) return 1;\n    \n    for (int i = 0; i < 4; i++) {\n        if (abs(i - prev) == 2) \n            continue;\n        \n        // new position\n        int ny = py + dy[i];\n        int nx = px + dx[i];\n        \n        // skip if swapping is out of boundary\n        if (ny <  0 || nx <  0 || ny >= 3 || nx >= 3) \n            continue;\n        \n        // try swapping\n        swap(&board[ny][nx], &board[py][px]);\n        \n        // return if success\n        if (check(board, limit, depth + 1, i, ny, nx))\n            return 1;\n        \n        // not work, swap back\n        swap(&board[ny][nx], &board[py][px]);\n    }\n    \n    return 0;\n}\n \nvoid solve(int board[3][3], int py, int px) {\n    int limit = 0;\n    \n    while (1) {\n        if (check(board, limit, 0, 99, py, px)) {\n            printf(\"%d\\n\", limit);\n            return;\n        }\n        limit++;\n    }\n}\n \nint main(int argc, char** argv) {\n    int py, px, i, j;\n    int board[3][3];\n    \n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) {\n            scanf(\"%d\", &board[i][j]);\n            \n            if (board[i][j] == 0) {\n                py = i;\n                px = j;\n            }\n        }\n\n    solve(board, py, px);\n    \n    return (EXIT_SUCCESS);\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n// Node\ntypedef struct NodeKey {\n    int board[9];\n    int space;\n    int cnt;\n} NodeKey;\n// lt: -1, gt: 1, eq: 0\nint cmp_node(const NodeKey *l, const NodeKey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        else if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\n\n// Treap\ntypedef struct Node {\n    NodeKey key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, const NodeKey key, const int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(cmp_node(&key, &root->key) == 0) return root;\n    if(cmp_node(&key, &root->key) == -1) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, const NodeKey key, const int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(Node *root, const NodeKey key) {\n    while(root != NULL && cmp_node(&key, &root->key)) {\n        if(cmp_node(&key, &root->key) == -1) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\n\n\n// Queue\n#define QueueKey NodeKey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\n// solve\nint bfs(NodeKey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    srand((unsigned)time(NULL));\n    BST BST;\n    bst_init(&BST);\n    bst_insert(&BST, s, rand());\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        NodeKey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            NodeKey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(bst_find(BST.root, next_key)) continue;\n\n            next_key.cnt++;\n            bst_insert(&BST, next_key, rand());\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    NodeKey initial;\n    initial.cnt = 0;\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define MAX 362880 //9ã®éä¹\n#define N 3\n#define N2 9\n\n/*\nèºææ¬ã®è§£ç­ä¾`ä¼¼ãã¦cè¨èªã§æ¸ãã¦ã¿ã\n*/\n\ntypedef struct puzzle{\n\tint f[N2];\n\tint space;\n\tint path;\n}Puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint V[MAX];\n\n// QUEUE --------\n\nPuzzle Q[MAX];\nint head, tail;\n\nint empty(){\n\treturn head == tail;\n}\n\nvoid push(Puzzle x){\n\tQ[tail] = x;\n\ttail = (tail+1)%MAX;\n}\n\nPuzzle front(){\n\tPuzzle x;\n\tx = Q[head];\n\thead = (head+1)%MAX;\n\treturn x;\n\t\n}\n\n// QUEUE --------\n\n\n/* \nint cheak(Puzzle p)\n1ãã9ã¾ã§ã®æ°ãä¸¦ã³æ¿ããæ°åããã¹ã¦åæãã¦è¾æ¸é ã«ä¸¦ã³æ¿ããã¨ãä»¥ä¸ã®æ°å\np.f[8],p.f[7],p.f[6].......p.[0]\nãåããä½çªç®ã«ããããè¿ãé¢æ°\n*/\nint cheak(Puzzle p){\n\tint i, j, fac, count, res = 0;\n\tfor(i = 0, fac = 1; i < N2; fac*= ++i){\n\t\tfor(j = 0, count = 0; j < i; j++){\n\t\t\tif(p.f[j] < p.f[i]) count++;\n\t\t\n\t\t}\n\t\tres += count*fac;\n\t}\n\t\n\treturn res;\t\n}\n\nint isTarget(Puzzle p){\n\tint i;\n\tfor(i = 0; i < N2; i++ )\n\t\tif(p.f[i] != (i + 1) ) return 0;\n\treturn 1;\n}\n\nint bfs(Puzzle s){\n\tint sx, sy, tx, ty, r, temp;\n\tPuzzle u, v;\n\t\n\ts.path = 0;\n\t\n\tpush(s);\n\t\n\tV[cheak(s)] = 1;\n\t\n\twhile(!empty()){\n\t\tu = front();\n\t\tif( isTarget(u)) return u.path;\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\t\n\t\tfor ( r = 0; r < 4; r++ ) {\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\t\n\t\t\ttemp = v.f[u.space];\n\t\t\tv.f[u.space] = v.f[tx * N + ty];\n\t\t\tv.f[tx * N + ty] = temp;\n\t\t\t\n\t\t\tv.space = tx * N + ty;\n\t\t\t\n\t\t\tif( !V[cheak(v)] ){\n\t\t\t\tV[cheak(v)] = 1;\n\t\t\t\tv.path++;\n\t\t\t\tpush(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main(){\n\tint i, ans;\n\tPuzzle in;\n\t\n\tfor( i = 0; i < N2; i++ ) {\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif( in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\t\n\tans = bfs(in);\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \nstruct dep{\n    int depth,key;\n};\n \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k){\n    return k % HN;\n}\nint hash2(int k){\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i){\n    return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n){\n    int i,j,i0,j0,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n     \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n     \n    if(i0>0 && i0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n     \n    if(i0>=0 && i0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n     \n}\n \nint main(){\n    int i,j;\n    int p[N][N];\n     \n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n     \n    printf(\"%d\\n\",min);\n     \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint V[1000000],dx[4]={-1,0,1,0},dy[4]={0,-1,0,1},head=0,tail=0;\n\nstruct P{\n  int f[9];\n  int space;\n  int path;\n};\n\nstruct P Q[1000000];\n\nvoid enqueue(struct P a){\n  int next=(tail+1)%1000000;\n  Q[tail]=a;\n  tail=next;\n}\n\nstruct P dequeue(){\n  struct P b;\n  b=Q[head];\n  head=(head+1)%1000000;\n  return b;\n}\n\nint sort(struct P p){\n  int i,j,k,cnt,a=0;\n  for(i=0,k=1;i<9;k*=++i){\n    for(j=0,cnt=0;j<i;j++){\n      if(p.f[j]<p.f[i]){\n\tcnt++;\n      }\n    }\n    a+=cnt*k;\n  }\n  return a;\n}\n\nint isTarget(struct P p){\n  int i;\n  for(i=0;i<9;i++){\n    if(p.f[i]!=i+1){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint bfs(struct P s){\n  int r,a,sx,sy,tx,ty;\n  struct P u,v;\n  s.path=0;\n  enqueue(s);\n  V[sort(s)]=1;\n  while(head!=tail){\n    u=dequeue();\n    if(isTarget(u)==1){\n      return u.path;\n    }\n    sx=u.space/3;\n    sy=u.space%3;\n    for(r=0;r<4;r++){\n      tx=sx+dx[r];\n      ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=3||ty>=3){\n\tcontinue;\n      }\n      v=u;\n      a=v.f[u.space];\n      v.f[u.space]=v.f[tx*3+ty];\n      v.f[tx*3+ty]=a;\n      v.space=tx*3+ty;\n      if(V[sort(v)]!=1){\n\tV[sort(v)]=1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i;\n  struct P in;\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=9;\n      in.space=i;\n    }\n  }\n  printf(\"%d\\n\",bfs(in));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\nvoid empty(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  empty(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n    ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 9\n#define INF 330000\n\nint ans[N]={1,2,3,4,5,6,7,8,0};\nint head=0,tail=0,cnt=0;\n\nstruct qu{\n  int s[N];\n};\n\nstruct node{\n  int key;\n  struct node *parent,*left,*right;\n};\n\nstruct node *root,*NIL;\nstruct qu Q[INF];\n\nvoid enqueue(struct qu x){\n\n  int next=tail+1;\n  Q[tail]=x;\n  tail=next;\n}\nstruct qu dequeue(void){\n  struct qu x;\n\n  x=Q[head];\n  head=head+1;\n  return x;\n}\n\nint find(struct node *u, int k){\n  while(u!=NIL&&k!=u->key){\n    if(k<u->key) u=u->left;\n    else u=u->right;\n  }\n  if(u!=NIL) return 1;\n  else return 0;\n}\n\nint insert(struct qu a){\n  int k,i,j;\n\n  for(i=0;i<=N;i++){\n    if(i==0) k+=a.s[i];\n    else{\n      for(j=0;j<i;j++) a.s[i]*=10;\n      k+=a.s[i];\n    }\n  }\n\n  if(find(root,k)==1) return 0;\n\n  struct node *y=NIL;  //xã®è¦ª\n  struct node *x=root;\n  struct node *z;\n\n  z=(struct node*)malloc(sizeof(struct node));\n\n  z->key=k;\n  z->left=NIL;\n  z->right=NIL;\n\n  while(x!=NIL){\n    y=x;\n    if(z->key<x->key) x=x->left;\n    else x=x->right;\n  }\n\n  z->parent=y;\n\n  if(y==NIL) root=z;\n  else if(z->key<y->key) y->left=z;\n  else y->right=z;\n\n  return 1;\n}\n\nint trade(){\n  int tmp,i,flag,loc,h[INF],sum;\n  struct qu a,b,c,d,y;\n\n  h[head]=0;\n\n  while(1){\n\n    sum=h[head];\n    y=dequeue();\n\n    flag=0;\n\n    for(i=0;i<N;i++){\n      if(y.s[i]!=ans[i]) flag=1;\n      if(y.s[i]==0) loc=i; //ï¼ã®ä½ç½®ãè¨é²\n    }\n    if(flag==0) break;\n\n    a=b=c=d=y;\n\n    /*\n      ï¼ãç§»åãããã¨ãã¦ãaã¯ä¸ãbã¯å³ãcã¯ä¸ãdã¯å·¦\n      æ¡ä»¶ãæºããå ´åï¼ã¨äº¤æãã¦ããã¥ã¼ãªã¹ãã£ãã¯æ¢ç´¢ãè¡ã\n    */\n    if(loc%3!=0){tmp=a.s[loc-1]; a.s[loc-1]=0; a.s[loc]=tmp;\n          if(insert(a)==1){ enqueue(a); h[tail-1]=(sum+1);}}\n\n    if(loc%3!=2){ tmp=b.s[loc+1]; b.s[loc+1]=0; b.s[loc]=tmp;\n      if(insert(b)==1){ enqueue(b); h[tail-1]=(sum+1);}}\n\n    if(loc<6){tmp=c.s[loc+3]; c.s[loc+3]=0; c.s[loc]=tmp;\n      if(insert(c)==1){ enqueue(c); h[tail-1]=(sum+1);}}\n\n    if(loc>2){tmp=d.s[loc-3]; d.s[loc-3]=0; d.s[loc]=tmp;\n      if(insert(d)==1){ enqueue(d); h[tail-1]=(sum+1);}}\n  }\n\n  return sum;\n}\n\nint main(){\n  int i,j,sum,a;\n  struct qu x;\n\n  for(i=0;i<N;i++){\n    scanf(\"%d\",&x.s[i]);\n  }\n\n  insert(x);\n  enqueue(x);\n  sum=trade();\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 50;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // åã¨åãéç½®ã«ãªã£ãã®ã§æ¬¡ã®æãè©¦ã\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n??\nint mas[3][3];\nint cpy[3][3];\n??\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n??\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n??\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n??\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n??\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n??\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n??\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n??\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n??\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n??\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n??\n????return -1;\n}\n??\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n??\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n??\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n void empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\n \nvoid swap(int *a,int *b) {\n    int tmp;\n \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \n  \nint cal() {\n    int i,a,sum=0;\n \n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n \n \n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n \n    return -1;\n}\n\nint main() {\n    int i,j,ans,x,y,l;\n \n    //puzzle input\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n \n \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n \n        //copy\n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n \n    //ans output\n    //printf(\"%d\\n\",ans);\n \n    return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\nint sum[N][N] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint num(int gum[N][N]) {\n    for (int a = 0; a < N; ++a) {\n        for (int b = 0; b < N; ++b) {\n            if (gum[a][b] != sum[a][b])\n                return 0;\n        }\n    }\n    return 1;\n}\n\nint xu(int gum[N][N], int x, int y, int v, int d, int e) {\n    if (num(gum))\n        return d;\n    if (d > e)\n        return -1;\n    for (int i = 0, fan; i < 4; ++i) {\n        int x2 = x + dx[i];\n        int y2 = y + dy[i];\n        if (x2 < 0 || x2 > 2 || y2 < 0 || y2 > 2 || (i + 2) % 4 == v)\n            continue;\n        gum[y][x] = gum[y2][x2];\n        gum[y2][x2] = 0;\n        if ((fan = xu(gum, x2, y2, i, d + 1, e)) > 0)\n            return fan;\n        gum[y2][x2] = gum[y][x];\n        gum[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int gum[N][N], x, y;\n    for (int a = 0; a < N; ++a) {\n        for (int b = 0; b < N; ++b) {\n            scanf(\"%d\", &gum[a][b]);\n            if (gum[a][b] == 0) {\n                y = a;\n                x = b;\n            }\n        }\n    }\n\n    int fan;\n    for (int a = 1; a < 50; ++a) {\n        if ((fan = xu(gum, x, y, -1, 0, a)) >= 0) {\n            break;\n        }\n    }\n    printf(\"%d\\n\", fan);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\nvoid empty(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n  }\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  empty(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n     ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint mas[3][3];\nint cpy[3][3];\n \n  \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n  \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n  \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n  \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n  \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n  \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n  \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n  \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n  \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n  \n  return -1;\n}\n  \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n  \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100000\n#define SENTINEL 2000000000\n\nstruct Card{\n  char suit;\n  int value;\n};\n\nstruct Card L[MAX/2+2], R[MAX/2+2];\n\nvoid merge(struct Card A[], int n, int left, int mid, int right){\n\n  int i, j, k;\n  int n1 = mid - left;\n  int n2 = right - mid;\n\n  for(i=0; i<n1; i++){\n    L[i] = A[left+1];\n  }\n  for(i=0; i<n2; i++){\n    R[i] = A[mid+i];\n  }\n\n  L[n1].value = R[n2].value = SENTINEL;\n  i = j = 0;\n\n  for(k=left; k<right; k++){\n    if(L[i].value <= R[j].value){\n      A[k] = L[i++];\n    }\n    else{\n      A[k] = R[j++];\n    }\n  }\n\n}\n\nvoid mergeSort(struct Card A[], int n, int left, int right){\n\n  int mid;\n\n  if(left+1 < right){\n    mid = (left+right)/2;\n    mergeSort(A, n, left, mid);\n    mergeSort(A, n, mid, right);\n    merge(A, n, left, mid, right);\n  }\n\n}\n\nint partition(struct Card A[], int n, int p, int r){\n\n  int i, j;\n  struct Card t, x;\n  x = A[r];\n  i = p-1;\n\n  for(j=p; j<r; j++){\n    if(A[j].value <= x.value){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n}\n}\n\nt = A[i+1];\nA[i+1] = A[r];\nA[r] = t;\n  return i+1;\n\n}\n\nvoid quickSort(struct Card A[], int n, int p, int r){\n\n  int q;\n\n  if(p<r){\n    q = partition(A, n , p, r);\n    quickSort(A, n, p, q-1);\n    quickSort(A, n, q+1, r);\n  }\n\n}\n\nint main(){\n\n  int n, i, v;\n  struct Card A[MAX], B[MAX];\n  char S[10];\n  int stable=1;\n\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n; i++){\n    scanf(\"%s %d\", S, &v);\n    A[i].suit = B[i].suit = S[0];\n    A[i].value = B[i].value = v;\n  }\n\n  mergeSort(A, n, 0, n);\n  quickSort(B, n, 0, n-1);\n\n  for(i=0; i<n; i++){\n    if(A[i].suit != B[i].suit){\n      stable = 0;\n    }\n  }\n\n if(stable==1){\n    printf(\"Stable\\n\");\n  }\n  else{\n    printf(\"Not stable\\n\");\n  }\n\n  for(i=0; i<n; i++){\n    printf(\"%c %d\\n\", B[i].suit, B[i].value);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint count;\nint A[N][N];\n\nint abs(int a){\n  if(a > 0) return a;\n  else return a*-1;\n}\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint Heuristic(){\n  int i,j,sum = 0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(A[i][j]==0)continue;\n    x = A[i][j] - 1;\n    sum+=abs(x/N - i)+abs(x%N - j);\n    }\n  }\n  return sum;\n}\n\nint move(int d,int pre,int s,int t){\n  int i,x,y,h = Heuristic();\n  if(h==0)return 1;\n  if(d+h > count)return 0;\n  for(i=0;i<4;i++){\n    if(abs(i - pre)==2)continue;/*return move*/\n\n    x = s + dy[i];\n    y = t + dx[i];\n\n    if(x<0||y<0||x>=N||y>=N)continue;/*frame over*/\n\n    swap(&A[x][y],&A[s][t]);\n    if(move(d+1,i,x,y))return 1;\n    swap(&A[x][y],&A[s][t]);/*return move because next move's starat is same this one */\n  }\n  return 0;\n}\n\nvoid counter(int s,int t){\n  count = 0;\n  while(1){\n    if(move(0,10,s,t)){\n      printf(\"%d\\n\",count);\n      return ;\n    }\n    count++;\n  }\n}\n\nint main(){\n  int i,j,s,t;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&A[i][j]);\n      if(A[i][j]==0){\n        s = i;\n        t = j;\n      }\n    }\n  }\n  counter(s,t);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ROW 3\n#define COL 3\n\ntypedef struct {\n  int row;\n  int col;\n}location;\n\nvoid swap(int **,location,location);\nint Search_min_path(int **,location,location,int,int);\nint incorrect(int **);\n\nint main(){\n  int **puzzle;\n  int i,j,limit,move_count=0,min;\n  location pre,current;\n\n  puzzle = malloc(sizeof(int*)*ROW);\n  for(i=0;i<ROW;i++)puzzle[i] = malloc(sizeof(int)*COL);\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)scanf(\"%d\",&puzzle[i][j]);\n\n  pre.row=-1;\n  pre.col=-1;\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)if(puzzle[i][j] == 0){\n\tcurrent.row = i;\n\tcurrent.col = j;\n      }\n  limit = incorrect(puzzle);\n\n  for(;1;limit++){\n    min = Search_min_path(puzzle,pre,current,limit,move_count);\n    if(-1 != min){\n      printf(\"%d\\n\",min);\n      break;\n    }\n  }\n\n  for(i=0;i<ROW;i++)free(puzzle[i]);\n  free(puzzle);\n  \n  return 0;\n}\n\nint Search_min_path(int **puzzle,location pre,location current,int limit,int move_count){\n  int **backup_puzzle;\n  int i,j,h,state;\n  location next;\n\n  h = incorrect(puzzle);\n  if(move_count + h >limit)return -1;\n  if(0 == h){\n    /**\n    for(i=0;i<ROW;i++){\n      for(j=0;j<COL;j++)printf(\" %d\",puzzle[i][j]);\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    **/\n    return move_count;\n  }\n\n  backup_puzzle = malloc(sizeof(int*)*ROW);\n  for(i=0;i<ROW;i++)backup_puzzle[i] = malloc(sizeof(int)*COL);\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)backup_puzzle[i][j] = puzzle[i][j];\n  next = current;\n  move_count++;\n\n  /*********************** up ****************************/\n  if(current.row -1 >= 0 && pre.row != current.row -1){\n    next.row --;\n    swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** up ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  next= current;\n\n  /*********************** down ****************************/\n  if(current.row +1 < ROW && pre.row != current.row +1){\n    next.row ++;\n     swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** down ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  next= current;\n\n  /*********************** left ****************************/\n  if(current.col -1 >=0 && pre.col != current.col -1){  \n    next.col --;\n    swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** left ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  next= current;\n\n  /*********************** right ****************************/\n  if(current.col +1 <COL && pre.col != current.col +1){\n    next.col ++;\n    swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** right ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  \n  \n  for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n  free(backup_puzzle);\n  return -1;\n}\n\nint incorrect(int **puzzle){\n  int i,j,num = 1,h=0,flag=0,tate,yoko,n,m;\n  for(num =1;num<=ROW*COL;num++){\n    n = (num-1)/ROW;\n    m = (num-1)%COL;\n    for(i=0;i<ROW;i++){\n      for(j=0;j<COL;j++){\n\tif(puzzle[i][j] == num%(ROW*COL)){\n\t  tate = i-n;\n\t  if(tate < 0)tate *=-1;\n\t  yoko = j-m;\n\t  if(yoko < 0)yoko *=-1;\n\t  flag = 1;\n\t  break;\n\t}\n      }\n      if(flag==1)break;\n    }\n    flag = 0;\n    h += tate + yoko;\n  }\n  return h;\n}\n\nvoid swap(int **puzzle,location A,location B){\n  int num;\n  num = puzzle[A.row][A.col];\n  puzzle[A.row][A.col] = puzzle[B.row][B.col];\n  puzzle[B.row][B.col]=num;\n}\n  \n\n  \n    \n\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define N 3\n#define N2 9\n#define TRUE 1\n#define FALSE 0\n#define MAX 500000\n\nint V[MAX];\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid swap(int x, int y){/*å¥ãæ¿ãã¾ã*/\n  int z = x;\n  x = y;\n  y = z;\n}\n\nstruct Puzzle{/*æ§é ä½ã®å®£è¨*/\n  int f[N2];\n  int space;\n  int path;\n};\n\nstruct Puzzle Q[MAX];\nint head = 0, tail = 0;\n\nvoid enqueue(struct Puzzle x){/* Q[tail] ã« x ãä»£å¥ããtail ãï¼ã¤å¢ããã¾ãã */\n  int next = (tail+1)%MAX;  \n  Q[tail] = x;\n  tail = next;\n}\n\nstruct Puzzle dequeue(){/* Q[head] ã®å¤ãè¿ããhead ãï¼ã¤å¢ããã¾ãã  */\n  struct Puzzle t; \n  t = Q[head];\n  head = (head+1)%MAX;\n  return t;\n}\n\nint sort(struct Puzzle p){\n  int i, j, key, count, n = 0;\n  for(i = 0, key = 1; i < N2; key *= ++i){\n    for(j = 0, count = 0; j < i; j++){\n      if(p.f[j] < p.f[i])count++;\n    }\n    n += count * key;\n  }\n  return n;\n}\n\nint isTarget(struct Puzzle p){\n  for(int i = 0; i < N2; i++)if(p.f[i] != (i+1))return FALSE;\n  return TRUE;\n}\n\nint bfs(struct Puzzle s){\n  struct Puzzle u, v;\n  s.path = FALSE;\n  enqueue(s);\n  V[sort(s)] = TRUE;\n  \n\n  while(head != tail){ \n    u = dequeue();\n    if(isTarget(u) == TRUE)return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n      v = u;\n      int num = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = num;\n      v.space = tx * N + ty;\n      if(V[sort(v)] != TRUE){\n\tV[sort(v)] = TRUE;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  struct Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  int ans = bfs(in);\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i,foundAnswer;\n  if (moves < (x+y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1){\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2){\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, j;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (j = 0; j < 50; j++) {\n    if (blindSearch(x,y,j,-1)) {\n      printf(\"%d\\n\", j);\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define true 1\n#define false 0\n\n#define MAX 3\n#define INF 100000000\n\nint limit;\nint shortest = INF;\nint count;\nint puzzle[MAX * MAX];\nint road[30][MAX * MAX];\n\nvoid swap(int *x, int *y) {\n    int tmp;\n    tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\nint history(int depth) {\n    int i, j, cnt;\n    if (depth < 2) return -1;\n\n    cnt = (MAX * MAX) - 1;\n    for (j = depth - 2; j != 0; j--) {\n        for (i = 1; i < (MAX * MAX); i++) {\n            if (puzzle[i - 1] == road[depth - 2][i - 1]) {\n                cnt--;\n            }\n        }\n        if (cnt == 0) return cnt;\n    }\n    return cnt;\n}\n\nint check() {\n    int i, cnt;\n\n    cnt = (MAX * MAX) - 1;\n    for (i = 1; i < (MAX * MAX); i++) {\n        if (puzzle[i - 1] == i) {\n            cnt--;\n        }\n    }\n    return cnt;\n}\n\nint up(int i, int *dir) {\n    *dir = i - MAX;\n    if (*dir >= 0) { return true; }\n    else return false;\n}\n\nint down(int i, int *dir) {\n    *dir = i + MAX;\n    if (*dir < (MAX * MAX)) { return true; }\n    else return false;\n}\n\nint left(int i, int *dir) {\n    *dir = i - 1;\n    if ((i % MAX != 0)) { return true; }\n    else return false;\n}\n\nint right(int i, int *dir) {\n    *dir = i + 1;\n    if ((i + 1) % MAX != 0) { return true; }\n    else return false;\n}\n\nvoid disp(int depth) {\n    int i;\n    if (depth < 0) return;\n\n    for (i = 0; i < (MAX * MAX); i++) {\n        if ((i % MAX) == 0) printf(\"\\n\");\n        printf(\"%d \", road[depth][i]);\n    }\n    printf(\"\\n\");\n    disp(depth - 1);\n}\n\nvoid cp(int depth) {\n    int i;\n    for (i = 0; i < (MAX * MAX); i++) {\n        road[depth][i] = puzzle[i];\n    }\n}\n\nvoid dfs(int depth, int pos) {\n    int dir;\n    int h = check();\n    cp(depth);\n    count++;\n\n    if (depth + h > limit || history(depth) == 0) {\n        return;\n    }\n    if (h == 0) {\n        if (shortest > depth) {\n            shortest = depth;\n            limit = depth;\n        }\n        //disp(depth);\n        return;\n    }\n\n    if (up(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n    if (down(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n    if (right(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n    if (left(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n}\n\nint  main() {\n    int i, pos;\n\n    for (i = 0; i < (MAX * MAX); i++) {\n        scanf(\"%d\", &puzzle[i]);\n        if (puzzle[i] == 0) {\n            pos = i;\n        }\n    }\n    limit = (check() + 1) * 4;\n\n    dfs(0, pos);\n\n    if (shortest != INF) {\n        printf(\"%d\\n\", shortest);\n        //printf(\"count >> %d\\n\", count);\n    } else {\n        printf(\">> not Solve limit-> %d, %d\\n\", limit, count);\n        disp(limit);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n#define true 1\n#define false 0\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint getHeuristic(){\n  int i,j,sum=0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(t[i][j]==0)continue;\n    x=t[i][j]-1;\n    sum+=abs(x/N-i)+abs(x%N-j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int py,int px){\n  int h=getHeuristic();\n  if(h==0)return true;\n  if(depth+h>limit)return false;\n  int i;\n  for(i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int tx=px+dx[i],ty=py+dy[i];\n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    swap(&t[ty][tx],&t[py][px]);\n    if(dfs(depth+1,i,ty,tx))return true;\n    swap(&t[ty][tx],&t[py][px]);\n  }\n  return false;\n}\n\nvoid isSolved(int py,int px){\n  for(limit=0;;limit++){\n    if(dfs(0,99,py,px)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,px,py;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        py=i;\n        px=j;\n      }\n    }\n  }\n  isSolved(py,px);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n\n#define N 3\n#define true 1\n#define false 0\n\n\nint x[4]={0,-1,0,1};\nint y[4]={1,0,-1,0};\nint l;\nint w[N][N];\n\nvoid swap(int *s,int *t){\n\n  int tmp = *s;\n  \n  *s = *t;\n  *t = tmp;\n  \n  return;\n\n}\n\n\nint abc(){\n\n  int i,j,s = 0,r;\n  \n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      if(w[i][j] == 0) continue;\n      r = w[i][j] - 1;\n      s += abs(r / N - i) + abs(r % N - j);\n    }\n  }\n  \n  return s;\n\n}\n\n\nint dfs(int d,int p,int ay,int ax){\n\n  int i,m = abc();\n  \n  if(m == 0)return true;\n  \n  if(d + m > l)return false;\n  \n  for(i = 0; i < 4; i++){\n    if(abs(i - p) == 2)continue;\n    \n    int tx = ax + x[i], ty = ay + y[i];\n    \n    if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n    \n    if(dfs(d + 1,i,ty,tx))return true;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n  }\n  \n  return false;\n\n}\n\n\nvoid Solved(int ay,int ax){\n\n  for(l = 0; ; l++){\n    if(dfs(0,99,ay,ax)){\n      printf(\"%d\\n\",l);\n      return ;\n    }\n  }\n\n}\n\nint main(){\n\n  int i,j,ax,ay;\n   \n   for(i = 0; i < N; i++){\n     for(j = 0; j < N; j++){\n       scanf(\"%d\",&w[i][j]);\n        if(w[i][j] == 0){\n\t  ay = i;\n\t  ax = j;\n\t}\n     }\n   }\n     \n   Solved(ay,ax);\n     \n     return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k){\n  return k % HN;\n}\nint hash2(int k){\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i){\n  return (hash1(k)+i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n){\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      if(ans[i][j] != p[i][j]) f++;\n      if(p[i][j] == 0){\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f == 0){\n    if(min >= n){\n      min = n;\n    }\n    return;\n  }\n\n  if(n > min) return;\n\n  i=0;\n\n  while(1){\n    b=hash(a, i);\n\n    if(h[b].key == 0){\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a){\n      if(h[b].depth>n){\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0 > 0 && i0 < N){\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(j0 > 0 && j0 < N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0 >= 0 && i0 < N-1){\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0 >= 0 && j0 < N-1){\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n}\n\nint main(){\n  int i,j;\n  int p[N][N];\n\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define L 32\n#define H 362897\n\nstruct depth{\n  int dep, key;\n};\n\nint ans[N][N] = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 0}\n};\n\nint min = L;\nstruct depth h[H];\n\nint hash1(int k){\n    return k % H;\n}\n\nint hash2(int k){\n    return 1 + k%(H-1);\n}\n\nint hash(int k, int i){\n    return (hash1(k) + i*hash2(k))%H;\n}\n\n\n\nvoid dfs(int p[N][N], int n){\n    int i, j, i0, j0;\n    int a = 0;\n    int b = 1;\n    int f = 0;\n    int tmp[N][N];\n\n    for(i = 0 ; i<N ; i++){\n        for(j=0 ; j<N ; j++){\n            if( ans[i][j] != p[i][j] ){f++;}\n            if( p[i][j] == 0 ){\n                i0 = i;\n                j0 = j;\n            }\n            a += p[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if( f == 0 ){\n        if( min >= n ){\n            min = n;\n        }\n        return;\n    }\n\n    if(n > min) return;\n    i = 0;\n    while(1){\n        b = hash(a, i);\n        if(h[b].key == 0){\n            h[b].key = a;\n            h[b].dep = n;\n            break;\n        }\n        else if(h[b].key == a){\n            if(h[b].dep>n){\n                h[b].dep = n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n\n    if(i0 > 0 && i0 < N){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0-1][j0];\n        tmp[i0-1][j0] = f;\n        dfs(tmp, n+1);\n      }\n    if(j0>0 && j0<N){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0][j0-1];\n        tmp[i0][j0-1] = f;\n        dfs(tmp, n+1);\n      }\n\n    if(i0>=0 && i0<N-1){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0+1][j0];\n        tmp[i0+1][j0] = f;\n        dfs(tmp, n+1);\n      }\n    if(j0>=0 && j0<N-1){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0][j0+1];\n        tmp[i0][j0+1] = f;\n        dfs(tmp, n+1);\n      }\n\n}\nint main(){\n  int i, j;\n  int p[N][N];\n\n  for(i=0 ; i<N ; i++){\n    for(j=0 ; j<N ; j++){\n      scanf(\"%d\", &p[i][j]);\n    }\n  }\n  dfs(p, 0);\n\n  printf(\"%d\\n\", min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define T 1\n#define F 0\n#define N 3\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint lim;\nint p[N][N];\n\nint huristic()\n{\n\tint i,j,n,sum=0;\n\tfor (i=0;i<N;i++)\n  {\n\t\tfor(j=0;j<N;j++)\n    {\n\t\t\tif(p[i][j]==0)continue;\n\t\t\tn=p[i][j]-1;\n\t\t\tsum+=abs(n/N-i)+abs(n%N-j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dfs(int d,int pre,int y,int x)\n{\n\tint h = huristic();\n\tint i;\n\tif(h==0)return T;\n\tif(lim<d+h) return F;\n\n\tfor(i=0;i<4;i++)\n  {\n\t\tif(abs(i-pre)==2)continue;\n\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\tif (tx<0||ty<0||tx>=N||ty>= N)continue;\n\t\tint tmp=p[ty][tx];\n\t\tp[ty][tx]=p[y][x];\n\t\tp[y][x]=tmp;\n\n\t\tif(dfs(d+1,i,ty,tx))return T;\n\t\ttmp=p[ty][tx];\n\t\tp[ty][tx]=p[y][x];\n\t\tp[y][x]=tmp;\n\t}\n\treturn F;\n}\n\nvoid azl(int x,int y)\n{\n\tfor(lim=0;;lim++)\n  {\n\t\tif(dfs(0,99,y,x))\n     {\n\t\t\tprintf(\"%d\\n\",lim);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\tint a,b;\n\n\tfor(i=0;i<3;i++)\n  {\n\t\tfor(j=0;j<3;j++)\n    {\n\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t\tif(p[i][j]==0)\n      {\n\t\t\t\tb=i;a=j;\n\t\t\t}\n\t\t}\n\t}\n\tazl(a,b);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define N 3\n#define LIM 32\n#define HN 362897\ntypedef struct {\n    int depth,key;\n}dep;\ndep  h[HN];\nint ans[N][N]={{1,2,3},{4,5,6},{7,8,0}},min = LIM;\nint hash1(int k) {\n    return k % HN;\n}\nint hash2(int k){\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i){\n    return (hash1(k) + i*hash2(k))%HN;\n}\nvoid dfs(int p[N][N], int n){\n    int i,j,i0,j0,a=0,b=1,f=0,tmp[N][N];\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0){\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n    if(f==0&&min>=n) {\n        min=n;\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1){\n        b=hash(a, i);\n        if(h[b].key == 0){\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }else if(h[b].key == a){\n            if(h[b].depth>n){\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n    if(i0>0 && i0<N){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n    if(i0>=0 && i0<N-1){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n}\nint main(){\n    int i,j,p[N][N];\n    for(i=0;i<N;i++)\n        for(j=0;j<N;j++)\n            scanf(\"%d\",&p[i][j]);\n    dfs(p,0);\n    printf(\"%d\\n\",min);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n\ntypedef struct{\n  int P[N][N];\n}Pazz;\n\nPazz Q;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint Heu(Pazz Q){\n  int i ,j;\n  int hx,hy,sum=0;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(Q.P[i][j]==0)continue;\n\n      hx=(Q.P[i][j]-1)%N-j;\n      hy=(Q.P[i][j]-1)/N-i;\n\n      if(hx<0)sum-=hx;\n      else sum+=hx;\n\n      if(hy<0)sum-=hy;\n      else sum+=hy;\n    }\n  }\n  return sum;\n}\nint dfs (int x,int y,int max,int count,int n){\n  int i,temp;\n  int x0,y0,ans=-1,h;\n\n  h=Heu(Q);\n\n  if(h==0)return count;\n  if((count+h) > max)return -1;\n\n  for(i=0;i<4;i++){\n    x0=x+dx[i];\n    y0=y+dy[i];\n\n    if(((i == (n+2)%4 )&& (n!=-1))||!((0<=x0 )&&( x0<N) && (0<=y0) && (y0<N)))continue;\n    temp=Q.P[y][x];\n    Q.P[y][x]=Q.P[y0][x0];\n    Q.P[y0][x0]=temp;\n\n    ans= dfs(x0,y0,max,count+1,i);\n\n    if(ans!=-1)return ans;\n    temp=Q.P[y][x];\n    Q.P[y][x]=Q.P[y0][x0];\n    Q.P[y0][x0]=temp;\n  }\n\n  return -1;\n\n}\n\nint main(){\n  int i,j;\n  int kx,ky,ans,a;\n  Pazz tP;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&a);\n      Q.P[i][j]=a;\n      if(a==0){\n        kx=j;\n        ky=i;\n      }\n    }\n  }\n\n  tP=Q;\n  for(i=1;i<46;i++){\n    Q=tP;\n    ans=dfs(kx,ky,i,0,-1);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX 100000000\n\n#define N 3\n#define N2 9\n#define LIMIT 31\n\ntypedef struct { char b[N2+1]; } Board;\nBoard board;\nint minstep;\ntypedef enum { R, U, L, D } Direction;\ntypedef struct { int pos; Direction dir; } Motion;\n\nconst Motion motion[N2][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nconst int rr[4][5] = {{0,0,1,0,0},{0,0,0,1,0},{1,0,0,0,0},{0,1,0,0,0}};\n\nint dd[N2][N2];\nint dist(char *b)\n{\n  int i, n, d = 0;\n  for (i=0; i<N2; i++) {\n    n = b[i]-1;\n    if (n<0)   continue;\n    d += dd[n][i];\n  }\n  return d;\n}\n\nvoid search(int step, Motion prev)\n{\n  int i, d=0;\n  d = dist(board.b);\n  if (step+d>minstep) return;\n  if (d==0) {\n    printf(\"%d\\n\", step);\n    exit(0);\n  }\n  Board board_bak = board;\n  for (i=0; motion[prev.pos][i].pos>=0; i++) {\n    Motion m = motion[prev.pos][i];\n    if (rr[m.dir][prev.dir]) continue; //åã«æ»ãã®ãé²æ­¢\n    board.b[prev.pos] = board.b[m.pos];\n    board.b[m.pos] = 0;\n    search(step+1, m);\n    board = board_bak;\n  }\n}\n\nvoid aaaaa(int a){\n  int i, count=0;\n  for(i=0; i<a; i++)count++;\n}\n\nint main()\n{\n  int i, j, a=10;\n  for (i=0; i<N2; i++)\n    for (j=0; j<N2; j++)\n      dd[i][j] = abs(i%N-j%N) + abs(i/N-j/N);\n  \n  Motion m;\n  m.dir = 4;\n  Board ini_board;\n  for (i=0; i<N2; i++) {\n    fscanf(stdin, \"%hd\", (short int*)&ini_board.b[i]);\n    if (ini_board.b[i]==0) m.pos = i;\n  }\n  for (minstep=dist(ini_board.b); minstep<=LIMIT; minstep++) {\n    board = ini_board;\n    search(0, m);\n  }\n  puts(\"no result.\");\n  aaaaa(a);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define tate 3\n#define yoko 3\n#define total (tate*yoko)\n#define N 45\n\nextern inline void down(void);\nextern inline void up(void);\nextern inline void right(void);\nextern inline void left(void);\nextern int puzzle(int x,int y,int a,int b);\n\nint n=0,board[total]={};\n\nint main(void)\n{\n  int i,x,y;\n  for(i=0;i<total;i++)\n    {\n      scanf(\"%d\",&board[i]);\n      if(board[i]==0)\n        {\n          n=i;\n        }\n    }\n  x=tate-(n/yoko)-1;\n  y=yoko-(n%yoko)-1;\n\n  for(i=0;i<N;i++)\n    {\n      if(puzzle(x,y,i,4)==1)\n        {\n          printf(\"%d\\n\",i);\n          break;\n        }\n    }\n  return 0;\n}\n\nint puzzle(int x,int y,int a,int b)\n{\n  int result,i;\n  if(a<(x+y))\n    {\n      return 0;\n    }\n  if(a==0)\n    {\n      for(i=0;i<total-1;i++)\n        {\n          if(board[i]!=(i+1))\n            {\n              return 0;\n            }\n        }\n      return 1;\n    }\n  for(i=0;i<4;i++)\n    {\n      result=0;\n      switch(i)\n        {\n        case 0:\n        if((x>0) && (b!=3))\n          {\n            down();\n            result=puzzle(x-1,y,a-1,0);\n            up();\n          }\n        break;\n        case 1:\n          if((y>0) && (b!=2))\n            {\n              right();\n              result=puzzle(x,y-1,a-1,1);\n              left();\n            }\n          break;\n        case 2:\n          if((y<yoko-1) && (b!=1))\n            {\n              left();\n              result=puzzle(x,y+1,a-1,2);\n              right();\n            }\n          break;\n        case 3:\n          if((x<tate-1) && (b!=0))\n            {\n              up();\n              result=puzzle(x+1,y,a-1,3);\n              down();\n            }\n          break;\n        default:\n          break;\n        }\n      if(result)\n        {\n          return 1;\n        }\n    }\n  return 0;\n}\n\ninline void down()\n{\n  board[n]=board[n+yoko];\n  n=n+yoko;\n}\n\ninline void up()\n{\n  board[n]=board[n-yoko];\n  n=n-yoko;\n}\n\ninline void right()\n{\n  board[n]=board[n+1];\n  n=n+1;\n}\n\ninline void left()\n{\n  board[n]=board[n-1];\n  n=n-1;\n}\n          \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3];\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,l);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \n \n \nstruct dep{\n  int depth,key;\n};\n   \n   \n   \nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n \n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n \n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    \n    dfs(tmp, n+1);\n  }\n \n  if(i0>=0 && i0<N-1)\n  \n  \n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n \n \n}\n \nint main()\n{\n  int i,j;\n  int p[N][N];\n \n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n \n \n  printf(\"%d\\n\",min);\n \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n\n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n\n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n\n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    } \n    return 0;\n}\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n\n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define TRUE  1\n#define FALSE 0\n#define FORWARD  1\n#define BACKWARD 2\n#define SIZE  9\n#define NIL   (-1)\n\n/* ç¶ææ° (9! / 2) */\n#define MAX_STATE 181440\n\n/* é£æ¥ãªã¹ã */\nconst char adjacent[SIZE][5] = {\n  1, 3,-1,-1,-1,\n  0, 4, 2,-1,-1,\n  1, 5,-1,-1,-1,\n  0, 4, 6,-1,-1,\n  1, 3, 5, 7,-1,\n  2, 4, 8,-1,-1,\n  3, 7,-1,-1,-1,\n  4, 6, 8,-1,-1,\n  5, 7,-1,-1,-1,\n};\n\n/* ã­ã¥ã¼ */\nchar state[MAX_STATE + 1][SIZE];      /* +1 ã¯ã¯ã¼ã¯é å */\nchar space_postion[MAX_STATE];\nint  prev_state[MAX_STATE];\nint  number_table[MAX_STATE];\n\n/* åä¸å±é¢ãã§ãã¯ãã¼ãã« */\nchar check_table[MAX_STATE * 2];\n\n/* åæç¶æ */\nchar init_state[SIZE];\n\n/* çµäºç¶æ */\nchar final_state[SIZE] = {\n  1, 2, 3, 4, 5, 6, 7, 8, 0\n};\n\nint count=0;\n\nvoid print_answer_forward(int n)\n{\n  if(n > 1) print_answer_forward(prev_state[n]);\n  count++;\n}\n\nvoid print_answer_backward( int n )\n{\n  do{\n    n = prev_state[n];\n    count++;\n  }\n\n  while( prev_state[n] != -1 );\n}\n\nvoid print_answer( int pos1, int num1, int num2 )\n{\n  /* num2 ã®ä½ç½®ãè¦ã¤ãã */\n  int pos2 = pos1 - 1;\n\n  while( num2 != number_table[pos2] ) pos2--;\n\n  if( check_table[num1] == FORWARD ){\n    print_answer_forward( pos1 );\n    print_answer_backward( pos2 );\n  }\n  else{\n    print_answer_forward( pos2 );\n    print_answer_backward( pos1 );\n  }\n}\n\n/* çªå·ã«å¤æ */\nint change_number( char *board )\n{\n  char work[SIZE];\n  static int fact_table[SIZE] = {\n    40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n  };\n  int j, k, value = 0;\n  memcpy( work, board, SIZE );\n  for( j = 0; j < SIZE - 1; j++ ){\n    value += fact_table[j] * work[j];\n    for( k = j + 1; k < SIZE; k++ ){\n      if( work[j] < work[k] ) work[k]--;\n    }\n  }\n  return value;\n}\n\n/* ã­ã¥ã¼ã®åæå */\nvoid init_queue( void )\n{\n  int num;\n\n  /* ã¹ã¿ã¼ã */\n  memcpy( state[0], init_state, SIZE );\n  space_postion[0] = 7;\n  prev_state[0] = -1;\n  num = change_number( init_state );\n  number_table[0] = num;\n  check_table[ num ] = FORWARD;\n\n  /* ã´ã¼ã« */\n  memcpy( state[1], final_state, SIZE );\n  space_postion[1] = 8;\n  prev_state[1] = -1;\n  num = change_number( final_state );\n  number_table[1] = num;\n  check_table[ num ] = BACKWARD;\n}\n\n/* æ¢ç´¢ */\nvoid search( void )\n{\n  int front = 0, rear = 2;\n\n  /* åæå */\n  init_queue();\n\n  while( front < rear ){\n    int s = space_postion[front];\n    int num1 = number_table[front];\n    int num2, i, n;\n\n    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){\n      /* ç¶æãã³ãã¼ */\n      memcpy( state[rear], state[front], SIZE );\n      /* ç§»å */\n      state[rear][s] = state[rear][n];\n      state[rear][n] = 0;\n      space_postion[rear] = n;\n      prev_state[rear] = front;\n      num2 = change_number( state[rear] );\n\n      if( !check_table[num2] ){\n\t/* ç»é² */\n        number_table[rear] = num2;\n        check_table[num2] = check_table[num1];\n\trear++;\n      }\n      else if( check_table[num1] != check_table[num2] ){\n        /* è§£ãè¦ã¤ãã£ã */\n        print_answer( rear, num1, num2 );\n        return;\n      }\n    }\n    front++;\n  }\n}\n\nint main()\n{\n  int i;\n  \n  for(i = 0; i < 9; i++){\n    scanf(\"%d\", &init_state[i]);\n  }\n  \n  search();\n  printf(\"%d\\n\", count-1);  \n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n\nint main(){\n  int i, j;\n  int c[N][N];\n  int sum = 0;\n\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n\n  if(c[0][0] == 2 || c[0][0] == 4){\n    sum = sum + 1;\n  }else if(c[0][0] == 3 || c[0][0] == 5 || c[0][0] == 7){\n    sum = sum + 2;\n  }else if(c[0][0] == 6 || c[0][0] == 8){\n    sum = sum + 7;\n  }\n  if(c[0][1] == 1 || c[0][1] == 3 || c[0][1] == 5){\n    sum = sum + 1;\n  }else if(c[0][1] == 4 || c[0][1] == 6 || c[0][1] == 8){\n    sum = sum + 2;\n  }else if(c[0][1] == 7){\n    sum = sum + 5;\n  }\n  if(c[0][2] == 2 || c[0][2] == 6){\n    sum = sum + 1;\n  }else if(c[0][2] == 1 || c[0][2] == 5){\n    sum = sum + 2;\n  }else if(c[0][2] == 4 || c[0][2] == 8){\n    sum = sum + 3;\n    if(c[1][1] == 1){\n      sum = sum + 6;\n    }\n  }else if(c[0][2] == 7){\n    sum = sum + 8;\n  }\n  if(c[1][0] == 1 || c[1][0] == 5 || c[1][0] == 7){\n    sum = sum + 1;\n  }else if(c[1][0] == 2 || c[1][0] == 6 || c[1][0] == 8){\n    sum = sum + 2;\n  }else if(c[1][0] == 3){\n    sum = sum + 3;\n  }\n  if(c[1][1] == 2 || c[1][1] == 4 || c[1][1] == 6 || c[1][1] == 8){\n    sum = sum + 1;\n  }else if(c[1][1] == 1 || c[1][1] == 3 || c[1][1] == 7){\n    sum = sum + 2;\n  }\n  if(c[1][2] == 3 || c[1][2] == 5){\n    sum = sum + 1;\n  }else if(c[1][2] == 2 || c[1][2] == 4 || c[1][2] == 8){\n    sum = sum + 2;\n  }else if(c[1][2] == 1 || c[1][2] == 7){\n    sum = sum + 6;\n  }\n  if(c[2][0] == 4 || c[2][0] == 8){\n    sum = sum + 1;\n  }else if(c[2][0] == 1 || c[2][0] == 5){\n    sum = sum + 2;\n  }else if(c[2][0] == 2 || c[2][0] == 6){\n    sum = sum + 6;\n  }else if(c[2][0] == 3){\n    sum = sum + 9;\n  }\n  if(c[2][1] == 5 || c[2][1] == 7){\n    sum = sum + 1;\n  }else if(c[2][1] == 2 || c[2][1] == 4 || c[2][1] == 6){\n    sum = sum + 2;\n  }else if(c[2][1] == 1 || c[2][1] == 3){\n    sum = sum + 5;\n    if(c[0][0] == 8){\n      sum = sum + 3;\n    }\n  }\n  if(c[2][2] == 6 || c[2][2] == 8){\n    sum = sum + 1;\n  }else if(c[2][2] == 3 || c[2][2] == 5 || c[2][2] == 7){\n    sum = sum + 2;\n  }else if(c[2][2] == 2 || c[2][2] == 4){\n    sum = sum + 4;\n    if(c[2][1] == 1){\n      sum = sum + 7;\n    }\n  }else if(c[2][2] == 1){\n    sum = sum + 9;\n    if(c[2][0] == 3 && c[0][2] == 7){\n      sum = sum - 6;\n    }\n    if(c[0][0] == 8 || c[0][0] == 6){\n      sum = sum - 2;\n    }\n  }\n\n  printf(\"%d\\n\", sum);\n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "int main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      break;\n    }\n    current++;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0;i<MAX;i++)\n    for(j=0;j<MAX;j++)\n      if(!pane[i][j]){\n\t*row=j;\n\t*col=i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0;i<9;i++){\n    e=pane[i/3][i%3];\n    if(e){\n      e--;\n      count+=abs(i/3-e/3)+abs(i%3-e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i;\n  int len;\n  int x_2,y_2;\n  int emc;   \n  len=cal();\n  if(len==0) return deep;\n  if(deep+len>limt) return -1; \n  for(i=0;i<4;i++){\n    x_2=x+d_x[i];\n    y_2=y+d_y[i];      \n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc=dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n} \n\nint main() {\n  int i,j;\n  int h,a,row,col;\n      \n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0;h<100;h++){\n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\ttemp[i][j]=pane[i][j];\n    }    \n    a=dfs(row,col,-1,0,h);    \n    if(a!=-1){\n      printf(\"%d\\n\",a);\n      break;\n    }    \n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\tpane[i][j]=temp[i][j];\n    }    \n    a=-1;\n    if(h==99) printf(\"%d\\n\\n\",a);\n  }      \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n  }\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc(),a;\n  if(h == 0) return dep;\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n    a = mas[y][x];\n    mas[y][x] = mas[ny][nx];\n    mas[ny][nx] = a;\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    a = mas[y][x];\n    mas[y][x] = mas[ny][nx];\n    mas[ny][nx] = a;\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans,i,j;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n  \tfor(i = 0; i < 3; i++)\n  \t    for(j = 0; j < 3; j++) cpy[i][j] = mas[i][j];\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    for(i = 0; i < 3; i++)\n        for(j = 0; j < 3; j++) mas[i][j] = cpy[i][j];\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \ntypedef unsigned char uchar;\n \n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n \nint lookup(unsigned s, int x)\n{\n    long long t = ((long long)x << 32) + s;\n    HASH *hp = hash + (int)(t % HASHSIZ);\n    while (hp->s) {\n        if (hp->s == s && hp->x == x) return hp->v;\n        if (++hp == hashend) hp = hash;\n    }\n    return 0;\n}\n \nvoid insert(unsigned s, int x, char v)\n{\n    long long t = ((long long)x << 32) + s;\n    HASH *hp = hash + (int)(t % HASHSIZ);\n    while (hp->s) {\n        if (hp->s == s && hp->x == x) { hp->v = v; break; }\n        if (++hp == hashend) hp = hash;\n    }\n    hp->s = s, hp->x = x, hp->v = v;\n}\n \n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n \nvoid toArray(char *nine, unsigned s, int x)\n{\n    int i;\n     \n    for (i = 8; i >= 0; i--) {\n        if (i == x) nine[i] = 0;\n        else nine[i] = s & 0xf, s >>= 4;\n    }\n}\n \nunsigned swap(char *nine, int zero, int nx)\n{\n    int i;\n    unsigned res;\n     \n    res = 0;\n    for (i = 0; i < 9; i++) {\n        if      (i == zero) res <<= 4, res |= nine[nx];\n        else if (i != nx)   res <<= 4, res |= nine[i];\n    }\n    return res;\n}\n \n#define MAGIC 20\n \nint main()\n{\n    int i, x, nx, v, nv, t;\n    unsigned a, na;\n    unsigned gs; int gx;    // goal\n    char nine[9];\n     \n    gs = 0; for (i = 0; i < 9; i++) {\n        scanf(\"%d\", &t);\n        if (t == 0) gx = i;\n        else gs <<= 4, gs |= t;\n    }\n    s[0].s = 0x12345678, s[0].x = 8;\n    s[1].x = -1;\n    top = 0, end = 2;\n    insert(s[0].s, s[0].x, 0);\n    v = 0;\n    while (top != end) {\n        a = s[top].s, x = s[top].x;\n        if (++top == QMAX) top = 0; \n        if (x < 0) {\n            if (v == MAGIC) break;\n            v++;\n            s[end].x = -1; if (++end == QMAX) end = 0;\n            continue;\n        }\n        if (x == gx && a == gs) goto done;\n        if (lookup(a, x) < v) continue;\n \n        toArray(nine, a, x);\n        for (i = 0; i < hi[x]; i++) {\n            nx = to[x][i];\n            na = swap(nine, x, nx), nv = v+1;\n            t = lookup(na, nx);\n            if (!t || nv < t) {\n                s[end].s = na, s[end].x = nx;\n                if (++end == QMAX) end = 0;\n                insert(na, nx, nv);\n            }\n        }\n    }\n \n    s[0].s = gs, s[0].x = gx, s[1].x = -1;\n    top = 0, end = 2;\n    v = 0;\n    while (top != end) {\n        a = s[top].s, x = s[top].x;\n        if (++top == QMAX) top = 0; \n        if (x < 0) {\n            v++;\n            s[end].x = -1; if (++end == QMAX) end = 0;\n            continue;\n        }\n        if ((t = lookup(a, x)) > 0) { v += t; break; }\n \n        toArray(nine, a, x);\n        for (i = 0; i < hi[x]; i++) {\n            nx = to[x][i];\n            na = swap(nine, x, nx), nv = v+1;\n            t = lookup(na, nx);\n            if (!t || nv < t) {\n                s[end].s = na, s[end].x = nx;\n                if (++end == QMAX) end = 0;\n            }\n        }\n    }\ndone:\n    printf(\"%d\\n\", v);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint a[10],fa[10]={1,1,2,6,24,120,720,5040,40320};\nint que[363000],quec,dp[362880];\n\nvoid swap(int i,int j){\n  int t;\n  t=a[i];\n  a[i]=a[j];\n  a[j]=t;\n}\n\nint ff(){\n  int i,ans=0,b=0;\n  for(i=8;i>=0;i--){\n    ans+=__builtin_popcount(b&((1<<a[i])-1))*fa[8-i];\n    b|=1<<a[i];\n  }\n  return ans;\n}\n\nvoid gg(int n){\n  int i,b=0;\n  for(i=0;i<9;i++) a[i]=i;\n  for(i=0;i<9;i++){\n    int x;\n    x=n/fa[8-i];\n    n%=fa[8-i];\n    for(int j=x;j>0;j--)swap(i+j,i+j-1);\n  }\n}\n\nint que[363000],quec;\nvoid ck(int p,int k){\n  int x;\n  x=ff();\n  if(!dp[x]){\n    dp[x]=k+1;\n    que[quec++]=x*10+p;\n  }\n}\n\nint cal(){\n  int i,x,p;\n  for(i=0;i<quec;i++){\n    x=que[i]/10;\n    p=que[i]%10;\n    if(x==0) return dp[x]-1;\n    gg(x);\n    if(p<6)swap(p,p+3),ck(p+3,dp[x]),swap(p,p+3);\n    if(p>2)swap(p,p-3),ck(p-3,dp[x]),swap(p,p-3);\n    if(p%3<2)swap(p,p+1),ck(p+1,dp[x]),swap(p,p+1);\n    if(p%3>0)swap(p,p-1),ck(p-1,dp[x]),swap(p,p-1);\n  }\n  return -1;\n}\n\nint main(){\n  int p,i,t;\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&t);\n    if(t) a[i]=t-1;\n    else{\n      a[i]=8;\n      p=i;\n    }\n  }\n  ck(p,0);\n  printf(\"%d\\n\",cal());\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint pazzle[3][3];\nint tmp[3][3];\nint test_x[4] = {0,1,0,-1};\nint test_y[4] = {1,0,-1,0};\n\nint main() {\n    int i,j,l,sign,x,y;\n        \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&pazzle[i][j]);\n    }\n         \n    emp(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = pazzle[i][j];\n        }\n            \n        sign = dfs(x,y,-1,0,l);\n        if(sign!=-1){\n            printf(\"%d\\n\",sign);\n            break;\n        }\n            \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) pazzle[i][j] = tmp[i][j];\n        }\n            \n        sign = -1;\n        if(l==99) printf(\"%d\\n\",sign);\n    }\n        \n    return 0;\n}\n\nvoid emp(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!pazzle[i][j]) {\n    *x = j;\n    *y = i;\n      }\n    }\n  }\n}\nvoid swap(int *s,int *v){\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n}   \nint calc(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = pazzle[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int d,const int lim){\n    int i,h,x2,y2,res;   \n    h = calc();\n    if(h==0) {\n        return d;\n    }\n    if(d+h>lim) {\n        return -1;\n    }\n    for(i=0; i<4; i++){\n        x2 = x+test_x[i];\n        y2 = y+test_y[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n        swap(&pazzle[y][x],&pazzle[y2][x2]);\n        res = dfs(x2,y2,i,d+1,lim);\n        if(~res) {\n            return res;\n        }\n        swap(&pazzle[y][x],&pazzle[y2][x2]);\n    }   \n    return -1;\n}    \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 3\n#define Na 4\n#define Nb 9\n#define Nc 100\n\nint puz[N][N];\nint temp[N][N];\nint dx[Na]={0,1,0,-1};\nint dy[Na]={1,0,-1,0};\n\nvoid emp(int x[],int y[]) {\n  int i, j;\n  for(i=0; i<N; i++) {\n    for(j=0; j<N; j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int a[], int b[]){\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nint calsum(){\n  int i, a, sum=0;\n  for(i=0; i<Nb; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum += abs((i/N)-(a/N)) + abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i, c, nx, ny, res;\n  c = calsum();\n  if(c==0) return dep;\n  if(dep+c>lim) return -1;\n  for(i=0;i<Na;i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n    if(~p && i==(p+2)%Nb) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\n\nint main() {\n  int i, j, k, x, y, ans;\n  for(i=0; i<N; i++){\n    for(j=0; j<N; j++) scanf(\"%d\",&puz[i][j]);\n  }\n  emp(&x,&y);\n  for(k=0; k<Nc; k++){\n    for(i=0; i<N; i++){\n      for(j=0; j<N; j++) temp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,k);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = temp[i][j];\n    }\n    ans = -1;\n    if(k==Nc-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define N 3\n#define pos(S, x, y) ((S).state.piece[(y)*N + (x)])\n\ntypedef enum {UP, DOWN, LEFT, RIGHT} Dir;\nstatic const int dx[4] = { 0, 0, -1, 1};\nstatic const int dy[4] = {-1, 1,  0, 0};\nstatic const int opposite[4] = {DOWN, UP, RIGHT, LEFT};\n\ntypedef struct _node {\n  union {\n    unsigned char piece[9];\n    struct {\n      unsigned long long int high;\n      unsigned long long int low;\n    } hash;\n  } state;\n  struct {\n    unsigned int x;\n    unsigned int y;\n  } emptyPos;\n  unsigned int moveCount;\n} Node;\n\ntypedef struct {\n  unsigned int size;\n  unsigned int head;\n  unsigned int tail;\n  Node** body;\n} Queue;\n\ntypedef struct _element {\n  Node* value;\n  struct _element* next;\n} Element;\n\ntypedef struct {\n  unsigned int size;\n  Element* body;\n} HashMap;\n\nvoid initHM(HashMap*);\nunsigned int hash(HashMap*, Node*);\nNode* find(HashMap*, Node*);\nvoid insert(HashMap*, Node*);\n\nvoid initQueue(Queue*);\nbool enqueue(Queue*, Node*);\nNode* dequeue(Queue*);\nbool isEmpty(Queue*);\nbool isFull(Queue*);\n\nint search(HashMap*, Queue*, Node*);\nNode* move(Node*, Dir);\nvoid print(Node*);\n\nint main () {\n  Node initialState;\n  Node finalState;\n\n  initialState.state.hash.high = 0;\n  initialState.state.hash.low = 0;\n  finalState.state.hash.high = 0;\n  finalState.state.hash.low = 0;\n  \n  unsigned int piece;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      scanf(\"%u\", &piece);\n      pos(initialState, j, i) = piece & 0xf;\n      pos(  finalState, j, i) = (i*N + j + 1)%9;\n      if (piece == 0) {\n\tinitialState.emptyPos.x = j;\n\tinitialState.emptyPos.y = i;\t\n      }\n    }\n  }\n  initialState.moveCount = 0;\n  \n  HashMap map;\n  initHM(&map);\n  insert(&map, &initialState);\n  \n  Queue queue;\n  initQueue(&queue);\n  enqueue(&queue, &initialState);\n  \n  printf(\"%d\\n\", search(&map, &queue, &finalState));\n\n  return 0;\n}\n\nvoid print(Node* node) {\n  printf(\"%llu\\n\", node->state.hash.high);\n  printf(\"%llu\\n\", node->state.hash.low);\n  for (unsigned int i = 0; i < N; i++) {\n    for (unsigned int j = 0; j < N; j++) {\n      fprintf(stderr, \"%2d\", pos(*node, j, i));\n    }\n    fprintf(stderr, \"\\n\");\n  }\n  fprintf(stderr, \"\\n\");\n}\n\nint search (HashMap* map, Queue* queue, Node* target) {\n  Node* node = dequeue(queue);\n  //print(node);\n  \n  if (node->moveCount > 32 || (node->state.hash.high == target->state.hash.high && node->state.hash.low == target->state.hash.low)) {\n    return node->moveCount;\n  } else {\n    Node*   newNode;\n    Node* foundNode;\n    Dir dir;\n    \n    // Up\n    dir = UP;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n    \n    // Down\n    dir = DOWN;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n    \n    // Left\n    dir = LEFT;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n    \n    // Right\n    dir = RIGHT;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n\n    return search(map, queue, target);\n  }\n}\n\nNode* move(Node* node, Dir dir) {\n  Node* newNode = (Node*)malloc(sizeof(Node));\n\n  newNode->state.hash = node->state.hash;\n  newNode->emptyPos.x = node->emptyPos.x + dx[dir];\n  newNode->emptyPos.y = node->emptyPos.y + dy[dir];\n  \n  switch (dir) {\n  case UP:\n    if (node->emptyPos.y != 0) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  case DOWN:\n    if (node->emptyPos.y != N - 1) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  case LEFT:\n    if (node->emptyPos.x != 0) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  case RIGHT:\n    if (node->emptyPos.x != N - 1) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  }\n  //fprintf(stderr, \"Done Movement\\n\");\n  \n  return newNode;\n}\n\nvoid initHM(HashMap* map) {\n  map->size = 1000007;\n  map->body = (Element*)calloc(map->size, sizeof(Element));\n  if (map->body == NULL) {\n    //fprintf(stderr, \"Cannot allocate memory for hashmap\\n\");\n    exit(-1);\n  }\n  //fprintf(stderr, \"Done HashMap Initialization\\n\");\n}\n\nunsigned int hash(HashMap* map, Node* node) {\n  unsigned int value = 0;\n  for (int i = 0; i < N*N; i++) {\n    value *= 37;\n    value += node->state.piece[i];\n    value %= map->size;\n  }\n  return value;\n}\n\nNode* find(HashMap* map, Node* node) {\n  unsigned int index = hash(map, node);\n  Element* element = map->body[index].next;\n  \n  //fprintf(stderr, \"Start HashMap Search...\\n\");\n  //fprintf(stderr, \"%u\\n\", index);\n  while (element != NULL) {\n    if (element->value->state.hash.high == node->state.hash.high && element->value->state.hash.low == node->state.hash.low) {\n      //fprintf(stderr, \"Done HashMap Search -> true\\n\");\n      return element->value;\n    }\n    element = element->next;\n  }\n\n  //fprintf(stderr, \"Done HashMap Search -> false\\n\");\n  return NULL;\n}\n\nvoid insert(HashMap* map, Node* node) {\n  //fprintf(stderr, \"Start HashMap Insertion\\n\");\n  if (find(map, node) == NULL) {\n    unsigned int index = hash(map, node);\n    \n    Element* element = &map->body[index];\n    while (element->next != NULL) {\n      element = element->next;\n    }\n    \n    Element* newElement = (Element*)malloc(sizeof(Element));\n    newElement->value = node;\n    newElement->next  = NULL;\n\n    element->next = newElement;\n  }\n  //fprintf(stderr, \"Done HashMap Insertion\\n\");\n}\n\nvoid initQueue(Queue* queue) {\n  queue->size = 1000007;\n  queue->body = (Node**)malloc(sizeof(Node*)*queue->size);\n  queue->head = queue->size - 1;\n  queue->tail = 0;\n\n  //fprintf(stderr, \"Done Queue Initialization\\n\");\n}\n\nbool enqueue(Queue* queue, Node* node) {\n  if (isFull(queue)) {\n    return false;\n  }\n\n  queue->body[queue->tail++] = node;\n  queue->tail %= queue->size;\n\n  return true;\n}\n\nNode* dequeue(Queue* queue) {\n  if (isEmpty(queue)) {\n    return NULL;\n  }\n\n  queue->head = (queue->head + 1) % queue->size;\n  return queue->body[queue->head];\n}\n\nbool isEmpty(Queue* queue) {\n  return (queue->head + 1) % queue->size == queue->tail;\n}\n\nbool isFull(Queue* queue) {\n  return queue->head == queue->tail;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //åããåã®ãã¼ã\n  node *next; //ãªã¹ãä¸ã®æ¬¡ã®ãã¼ã\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tã«openãªã¹ãã®åé ­ãæ¸¡ã\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint p[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid emp(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&p[i][j]);\n    }\n    emp(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = p[i][j];\n        }\n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) p[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    }\n     printf(\"%d\\n\",a);\n     return 0;\n}\n  \nvoid emp(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!p[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \nvoid swap(int *a1,int *b1) {\n    int tmp;\n    tmp = *a1;\n    *a1 = *b1;\n    *b1 = tmp;\n}\n \nint cal() {\n    int i,a2,sum=0;\n    for(i=0; i<9; i++) {\n        a2 = p[i/3][i%3];\n        if(a2) {\n            a2--;\n            sum += abs(i/3 - a2/3) + abs(i%3 - a2%3);\n        }\n   }\n    return sum;\n}\n \nint dfs(int x,int y,int p1,int d,const int lim) {\n    int i,h,nx,ny,res;\n    h = cal();\n    if(h==0) return d;\n    if(d+h>lim) return -1;\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        if(~p1 && i==(p1+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        swap(&p[y][x],&p[ny][nx]);\n        res = dfs(nx,ny,i,d+1,lim);\n        if(~res) return res;\n        swap(&p[y][x],&p[ny][nx]);\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n//\n\n\n// Util\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n//\n\n\n// Red Black Tree\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n//\n\n\n// Node\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mynode *data) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(&data->key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    rb_link_node(&data->node, parent, new);\n    rb_insert(&data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n//\n\n\n// List\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list) {\n    list->next = list;\n    list->prev = list;\n}\n\nstatic inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) {\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    prev->next = new;\n}\n\nstatic inline void list_add(struct list_head *new, struct list_head *head) {\n    __list_add(new, head, head->next);\n}\n\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head) {\n    __list_add(new, head->prev, head);\n}\n\nstatic inline void __list_del(struct list_head *prev, struct list_head *next) {\n    next->prev = prev;\n    prev->next = next;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry) {\n    __list_del(entry->prev, entry->next);\n}\n\nstatic inline void list_del(struct list_head *entry) {\n    __list_del_entry(entry);\n    entry->next = NULL;\n    entry->prev = NULL;\n}\n\nstatic inline int list_empty(const struct list_head *head) {\n    return head->next == head;\n}\n\n#define list_entry(ptr, type, member) container_of(ptr, type, member)\n#define list_first_entry(ptr, type, member) list_entry((ptr)->next, type, member)\n//\n\nstruct my_list {\n    struct mykey key;\n    struct list_head list;\n};\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\nstruct mynode node[200000];\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    static int num = 0;\n    node[0].key = s;\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, node + num++);\n    struct list_head head;\n    INIT_LIST_HEAD(&head);\n    struct my_list *data = malloc(sizeof(struct my_list));\n    data->key = s;\n    list_add_tail(&data->list, &head);\n    while(!list_empty(&head)) {\n        data = list_first_entry(&head, struct my_list, list);\n        struct mykey key = data->key;\n        list_del(&data->list);\n        free(data);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            node[num].key = next_key;\n            if(my_insert(&mytree, node + num) == 0) num++;\n            data = malloc(sizeof(struct my_list));\n            data->key = next_key;\n            list_add_tail(&data->list, &head);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n#define N2 9\n\nint kei(int,int,int,int);\nint f[9];\n\nint main()\n{\n\tint i,a;\n\tfor(i=0;i<N2;i++){\n\t\tscanf(\"%d\",&f[i]);\n\t\tif(f[i]==0)a=i;\n\t}\n\tprintf(\"%d\\n\",k(a,0,10,1));\n\treturn 0;\n}\n\nint k(int a,int b,int c,int d)\n{\n\tint min=999,sum=0,i,m;\n\tif((d==b || c==10) && a==8){\t\n\t\tfor(i=0;i<8;i++){\n\t\t\tif(f[i]!=i+1){\n\t\t\t\tsum++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sum==0)return b;\n\t}\n\twhile(b<d){\n\t\n\t\tif((a+1)%3!=0 && c!=a+1){\n\t\t\tm=f[a+1];\n\t\t\tf[a+1]=f[a];\n\t\t\tf[a]=m;\n\t\t\tm=k(a+1,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a+1];\n\t\t\tf[a+1]=m;\n\t\t}\n\t\tif((a-1)%N!=2 && a!=0 && c!=a-1){\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-1];\n\t\t\tf[a-1]=m;\n\t\t\tm=k(a-1,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-1];\n\t\t\tf[a-1]=m;\n\t\t}\n\t\tif(a-N>=0 && c!=a-N){\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-N];\n\t\t\tf[a-N]=m;\n\t\t\tm=k(a-N,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-N];\n\t\t\tf[a-N]=m;\n\t\t}\n\t\tif(a+N<N2 && c!=a+N){\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a+N];\n\t\t\tf[a+N]=m;\n\t\t\tm=k(a+N,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a+N];\n\t\t\tf[a+N]=m;\n\t\t}\n\t\tif(c==10)d++;\t\t\n\t\telse return min;\n\t}\n\treturn min;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAX 2000000\n#define INFTY (1<<30)\n??\nint H, A[MAX+1];\n??\nvoid swap(int *a, int *b) {\n????????int t;\n????????t = *a;\n????????*a = *b;\n????????*b = t;\n}\n??\nvoid maxHeapify(int i) {\n????????int largest;\n????????int l = 2 * i;\n????????int r = 2 * i + 1;\n????????if (l <= H && A[l] > A[i]) largest = l;\n????????else largest = i;\n????????if (r <= H && A[r] > A[largest]) largest = r;\n????\n????????if (largest != i) {\n????????????????swap(&A[i], &A[largest]);\n????????????????maxHeapify(largest);\n????????}\n}\n??\nint extract() {\n????????int maxv;\n????????if ( H < 1 ) return -INFTY;\n????????maxv = A[1];\n????????A[1] = A[H--];\n????????maxHeapify(1);\n????????return maxv;\n}\n??\nvoid increaseKey(int i, int key) {\n????????if(key < A[i]) return;\n????????A[i] = key;\n????????while(i > 1 && A[i / 2] < A[i]) {\n????????????????swap(&A[i], &A[i / 2]);\n????????????????i = i / 2;\n????????}\n}\n??\nvoid insert(int key) {\n????????H++;\n????????A[H] = -INFTY;\n????????increaseKey(H, key);\n}\n??\nint main() {\n????????int key;\n????????char com[10];\n??\n????????while(1) {\n????????????????scanf(\"%s\", com);\n????????????????if(com[0] == 'e' && com[1] == 'n') break;\n????????????????if(com[0] == 'i') {\n????????????????????????scanf(\"%d\", &key);\n????????????????????????insert(key);\n????????????????}else {\n????????????????????????printf(\"%d\\n\", extract());\n????????????????}\n????????}\n??\n????????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n/*----------       å®æ°å®ç¾©       ----------*/\n\n#define BOARD_SIZE          3       // ããºã«ã®è¡æ°ï¼åæ°ï¼\n#define PANEL_NUM           9       // ãã¹ã®ç·æ°\n#define MAX_PATTERN         362880  // èããããããºã«ã®çµã¿åããæ° (9ã®éä¹)\n#define MOVE_DIRECTION_NUM  4       // ç§»åæ¹åã®æ°\n#define MALLOC_ERR         -1       // ã¡ã¢ãªç¢ºä¿å¤±æ\n#define SEARCH_FAILURE     -2       // æ¢ç´¢å¤±æ\n\n\n/*----------      æ§é ä½å®£è¨      ----------*/\n\n/*\n *  ããºã«ç¤é¢ã®æå ±ããã¤æ§é ä½\n */\ntypedef struct {\n    int field[PANEL_NUM];   // ããºã«ã®éç½®\n    int space_position;     // ç©ºç½ã®ä½ç½®\n    int num_moves;          // ææ°\n} Puzzle;\n\n/*\n *  ã­ã¥ã¼ãå®è£ããããã®æ§é ä½\n */\ntypedef struct {\n    Puzzle *data;\n    int head;\n    int tail;\n} Queue;\n\n\n/*----------   ãã­ãã¿ã¤ãå®£è¨   ----------*/\n\nbool Init(Queue *queue);\nbool isEmpty(Queue *queue);\nvoid Push(Queue *queue, Puzzle puzzle);\nPuzzle Pop(Queue *queue);\nint CalcHashValue(int *field);\nint BreadthFirstSearch(Puzzle *start);\nvoid swap(int*a,int*b);\n\n\n/*----------      ã¡ã¤ã³å¦ç      ----------*/\n\nint main() {\n    Puzzle start;\n\n    // åæéç½®ã®èª­ã¿è¾¼ã¿\n    for(int i = 0; i < PANEL_NUM; i++ ){\n        scanf(\"%d\", &start.field[i]);\n        if(start.field[i] == 0){\n            start.space_position = i;\n        }\n    }\n\n    int answer = BreadthFirstSearch(&start); // å¹åªåæ¢ç´¢ã§æç­ææ°ãæ±ãã\n\n    if(answer == MALLOC_ERR){\n        printf(\"malloc error\\n\");\n    }\n    else if(answer == SEARCH_FAILURE){\n        printf(\"æ¢ç´¢å¤±ær\\n\");\n    }\n    else{\n        printf(\"%d\\n\", answer);\n    }\n    return EXIT_SUCCESS;\n}\n\n\n/*----------       é¢æ°å®ç¾©       ----------*/\n\n/*\n *  å¹åªåæ¢ç´¢ã§ããºã«ã®æç­ææ°ãæ±ãã\n *\n *  æ»ãå¤ï¼\n *      æ¢ç´¢ã«æåããå ´å    æç­ææ°\n *      mallocã«å¤±æããå ´å  MALLOC_ERR\n *      æ¢ç´¢ã«å¤±æããå ´å    SEARCH_FAILURE\n */\nint BreadthFirstSearch(Puzzle *start) {\n    start->num_moves = 0;\n\n    Queue queue;\n\n    if(!Init(&queue)){\n        return MALLOC_ERR;\n    }\n    Push(&queue, *start);\n\n    bool *hash_table = (bool*) malloc(sizeof(bool) * MAX_PATTERN);  // ä¸åº¦æ¢ç´¢ããéç½®ãè¦ãã¦ããããã®ãã¼ãã«\n    if(!hash_table){\n    \tfree(queue.data);\n        return MALLOC_ERR;\n    }\n\n    int goal_field[PANEL_NUM] = {1, 2, 3, 4, 5, 6, 7, 8, 0};   // ã´ã¼ã«ã®éç½®\n    int goal_hash_value = CalcHashValue(goal_field);         // ã´ã¼ã«ã®ããã·ã¥å¤\n\n    hash_table[CalcHashValue(start->field)] = true;\n\n    // ä¸ãå·¦ãä¸ãå³ã®ç©ºç½ã®ç§»åæ¹åãå®ç¾©\n    const int move_direction_x[MOVE_DIRECTION_NUM] = {-1, 0, 1, 0};\n    const int move_direction_y[MOVE_DIRECTION_NUM] = {0, -1, 0, 1};\n\n    while(!isEmpty(&queue)){\n        Puzzle now = Pop(&queue); // ã­ã¥ã¼ã®åé ­ã®ç¤é¢ãåãåºã\n\n        // ç¾å¨ã®ããã·ã¥å¤ã¨ã´ã¼ã«ã®ããã·ã¥å¤ãä¸è´ãããçµäº\n        if(CalcHashValue(now.field) == goal_hash_value){\n        \tfree(queue.data);\n        \tfree(hash_table);\n        \treturn now.num_moves;\n        }\n\n        int now_space_pos_x = now.space_position / BOARD_SIZE;\n        int now_space_pos_y = now.space_position % BOARD_SIZE;\n\n        // ä¸ä¸å·¦å³ã®4æ¹åã«ç©ºç½ãç§»åããéã®ç¤é¢ãã­ã¥ã¼ã«è¿½å ãã\n        for(int i = 0; i < MOVE_DIRECTION_NUM; i++){\n            int moved_space_pos_x = now_space_pos_x + move_direction_x[i];\n            int moved_space_pos_y = now_space_pos_y + move_direction_y[i];\n\n            if(moved_space_pos_x < 0 || moved_space_pos_y < 0 || moved_space_pos_x >= BOARD_SIZE || moved_space_pos_y >= BOARD_SIZE){\n                continue;  // ç§»åå¾ã®ç©ºç½ã®ä½ç½®ãããºã«ã®æ ããåºã¦ããå ´åã¯æ¬¡ã¸\n            }\n\n            Puzzle next = now; // ç©ºç½ãç§»åããéã®ç¤é¢ãä½æ\n\n            int moved_space_posision = moved_space_pos_x * BOARD_SIZE + moved_space_pos_y;\n\n            // ç©ºç½ä½ç½®ã®ç§»å\n            swap(&next.field[now.space_position], &next.field[moved_space_posision]);\n\n            next.space_position = moved_space_posision;\n\n            int next_puzzle_hash_value = CalcHashValue(next.field);  // åãããç¤é¢ã®ããã·ã¥å¤\n\n            // ç¤é¢ãéè¤ãã¦ããããèª¿ã¹ã\n            if(!hash_table[next_puzzle_hash_value]){\n            \t// éè¤ãç¡ããã°ããã·ã¥ãã¼ãã«ãæ´æ°ããç¤é¢ãã­ã¥ã¼ã«è¿½å ãã\n                hash_table[next_puzzle_hash_value] = true;\n                next.num_moves++;\n                Push(&queue, next);\n            }\n        }\n    }\n\n    // ã´ã¼ã«ç¤é¢ã«ãã©ãçããã«ãã­ã¥ã¼ãç©ºã«ãªã£ãå ´åã¯æ¢ç´¢å¤±æ\n    free(queue.data);\n    free(hash_table);\n    return SEARCH_FAILURE;\n}\n\n/*\n *  ã­ã¥ã¼ãåæåãã\n *\n *  æ»ãå¤ï¼\n *      åæåã«æåããã° trueãå¤±æããã° false\n */\nbool Init(Queue *queue) {\n    queue->head = 0;\n    queue->tail = 0;\n    queue->data = (Puzzle*) malloc(sizeof(Puzzle) * MAX_PATTERN);\n    if(!queue->data){\n        return false;\n    }\n    return true;\n}\n\n/*\n *  ã­ã¥ã¼ãç©ºãã©ããèª¿ã¹ã\n *\n *  æ»ãå¤ï¼\n *      ç©ºã§ããã° trueãããããªããã° false\n */\nbool isEmpty(Queue *queue) {\n    return queue->head == queue->tail;\n}\n\n/*\n *  ã­ã¥ã¼ã«è¦ç´ ãè¿½å ãã\n *\n *  æ»ãå¤:\n *      ãªã\n */\nvoid Push(Queue *queue, Puzzle puzzle) {\n    queue->data[queue->tail] = puzzle;\n    queue->tail = (queue->tail + 1) % MAX_PATTERN;\n}\n\n/*\n *  ã­ã¥ã¼ã®åé ­è¦ç´ ãåãåºã\n *\n *  æ»ãå¤ï¼\n *      ã­ã¥ã¼ã®åé ­è¦ç´ ã®ããºã«\n */\nPuzzle Pop(Queue *queue) {\n    Puzzle puzzle = queue->data[queue->head];\n    queue->head = (queue->head + 1) % MAX_PATTERN;\n    return puzzle;\n}\n\n/*\n *  ããºã«ç¤é¢ã®ããã·ã¥å¤ãè¨ç®ãã\n *\n *  æ»ãå¤ï¼\n *      ç¤é¢ã®ããã·ã¥å¤\n */\nint CalcHashValue(int *field) {\n    int res = 0;\n    int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1};\n    int fac_idx = 0;\n    bool used_num[PANEL_NUM] = {};\n    for(int i = 0; i < PANEL_NUM; i++){\n        int count = 0;\n        used_num[field[i]] = true;\n        for(int j = 0; j < field[i] ; j++){\n            if(used_num[j]){\n                continue;\n            }\n            count++;\n        }\n        res += count * fac[fac_idx++];\n    }\n    return res;\n}\n\n/*\n *  å¤ãå¥ãæ¿ãã\n *\n *  æ»ãå¤:\n *      ãªã\n */\nvoid swap(int*a,int*b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { char a[10]; } Board;\n\nBoard  board, *history;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nMotion motion[9][5] = {\n   {{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint minstep = 31;\n\nvoid search(int step, int space, int nhistories)\n{\n  int i, j;\n  if (strncmp(board.a, \"123456780\", 8)==0) {\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    for (j=0; j<nhistories; j++) {\n      if (strcmp(board.a, history[j].a)==0) return;\n    }\n    history[nhistories++] = board; \n    //    puts(board);\n\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n      if (m.pos==0 && board.a[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board.a[0]=='1'&&board.a[1]=='2'&&board.a[2]=='3') continue;\n      if ((m.dir==U&&m.pos<3)||(m.dir==D&&m.pos>5)||(m.dir==L&&m.pos%3==0) || (m.dir==R && m.pos%3==2)) continue;\n\n      board.a[space] = board.a[m.pos];\n      //      board.a[m.pos] = '0';\n      search(step+1, m.pos, nhistories);\n      board = history[nhistories-1];\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[0],&board.a[1],&board.a[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[3],&board.a[4],&board.a[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[6],&board.a[7],&board.a[8]);\n  history = (Board*)malloc(sizeof(Board)*31);\n  search(0, strchr(board.a, '0')-board.a, 0);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n#define size 3\n#define size2 9\n#define size3 100000\n#define max 36\n\ntypedef struct {\n  char b[size][size],m,cost;\n  int  space[2];\n} Pz;\n\nint head=0, tail=0;\nPz q[size3];\n\nvoid enq(Pz pz){\n  q[tail]=pz;\n  tail = (tail+1)%size3;\n}\n\nPz deq(void){\n  int t;\n  \n  t = head;\n  head = (head+1)%size3;\n\n  return q[t];\n}\n\nint check(Pz pz){\n  int i,j;\n\n  pz.b[pz.space[0]][pz.space[1]] = size2;\n  \n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      if(pz.b[i][j] != i*size + j + 1){\n\treturn 0;\n      }\n    }\n  }\n\n  return 1;\n}\n\nint distance(Pz pz){\n  int i,j,sum=0,t   ;\n\n  /*for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      printf(\"%d \",pz.b[i][j]);\n    }\n    printf(\"\\n\");\n  }*/\n  \n  pz.b[pz.space[0]][pz.space[1]] = size2;\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      t=pz.b[i][j]-1;\n      sum += abs(i - t/size) + abs(j - t%size);\n      //printf(\"%d \",tt);\n    }\n  }\n\n  //printf(\"sum %d\\n\",sum);\n  return sum;\n}\nint main(){\n  int i,j,tate,yoko,dis=0,count=0;\n  char tmpc;\n  Pz inisial, tmpp, tmpp2;\n\n  //nyu ryoku\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      scanf(\"%d\",&inisial.b[i][j]);\n      if(inisial.b[i][j]==0){\n\tinisial.space[0] = i;\n\tinisial.space[1] = j;\n      }\n    }\n  }\n  inisial.cost = 0;\n  inisial.m = '0';\n\n  enq(inisial);\n\n  //printf(\"%d\\n\",distance(inisial));\n  \n  if(check(inisial)!=1){\n    while(head!=tail){\n      tmpp2 = tmpp = deq();\n      tate = tmpp.space[0];\n      yoko = tmpp.space[1];\n\n      //printf(\"\\n\");\n      //printf(\"%d %d\\n\",head,tail);\n      /*for(i=0;i<size;i++){\n\tfor(j=0;j<size;j++){\n\t  printf(\"%d \",tmpp.b[i][j]);\n\t}\n\tprintf(\"\\n\");\n      }\n      //printf(\"\\n\");\n      \n      //count++;\n      //*/\n      if(tate != 0 && tmpp.m != '1'){\n\ttmpc = tmpp2.b[tate-1][yoko];\n\ttmpp2.b[tate-1][yoko] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[0] = tmpp2.space[0] - 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '2';\n\t  enq(tmpp2);\n\t}\n      }\n      tmpp2=tmpp;\n\n      if(tate < size-1 && tmpp.m != '2'){\n\ttmpc = tmpp2.b[tate+1][yoko];\n\ttmpp2.b[tate+1][yoko] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[0] = tmpp2.space[0] + 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '1';\n\t  enq(tmpp2);\n\t}\n      }\n      tmpp2=tmpp;\n\n      if(yoko != 0 && tmpp.m != '3'){\n\ttmpc = tmpp2.b[tate][yoko-1];\n\ttmpp2.b[tate][yoko-1] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[1] = tmpp2.space[1] - 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '4';\n\t  enq(tmpp2);\n\t}\n      }\n      tmpp2=tmpp;\n\n      if(yoko < size-1 && tmpp.m != '4'){\n\ttmpc = tmpp2.b[tate][yoko+1];\n\ttmpp2.b[tate][yoko+1] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[1] = tmpp2.space[1] + 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '3';\n\t  enq(tmpp2);\n\t}\n      }\n    }\n  }\n\n  printf(\"%d\\n\",dis);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  \n#define SIZE 3\n#define LIM 32\n#define HN 362897\n  \nstruct dep {\n    int depth, key;\n};\n  \nint ans[SIZE][SIZE] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}};\n  \nint min = LIM;\nstruct dep h[HN];\n  \nint hash1(int k) {\n    return k % HN;\n}\n\nint hash2(int k) {\n    return 1 + k % (HN - 1);\n}\n\nint hash(int k, int i) {\n    return (hash1(k) + i * hash2(k)) % HN;\n}\n  \nvoid dfs(int p[SIZE][SIZE], int n) {\n    int i, j, i1, j1, a = 0, b = 1;\n    int f = 0;\n    int tmp[SIZE][SIZE];\n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            if (ans[i][j] != p[i][j]) f++;\n            if(p[i][j] == 0) {\n                i1 = i;\n                j1 = j;\n            }\n            a += p[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if (f == 0) {\n        if(min >= n) {\n            min = n;\n        }\n        return;\n    }\n    if(n > min) return;\n    i = 0;\n    while(1) {\n        b = hash(a, i);\n        if (h[b].key == 0) {\n            h[b].key = a;\n            h[b].depth = n;\n            break;\n        }\n        else if (h[b].key == a) {\n            if (h[b].depth > n) {\n                h[b].depth = n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n      \n    if(i1 > 0 && i1 < SIZE) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 - 1][j1];\n        tmp[i1 - 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 > 0 && j1 < SIZE) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 - 1];\n        tmp[i1][j1 - 1] = f;\n        dfs(tmp, n + 1);\n    }\n      \n    if(i1 >= 0 && i1 < SIZE - 1) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 + 1][j1];\n        tmp[i1 + 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 >= 0 && j1 < SIZE - 1) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 + 1];\n        tmp[i1][j1 + 1] = f;\n        dfs(tmp, n + 1);\n    }\n}\n  \nint main(void)\n{\n    int i, j;\n    int p[SIZE][SIZE];\n      \n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            scanf(\"%d\", &p[i][j]);\n        }\n    }\n    dfs(p, 0);\n      \n    printf(\"%d\\n\", min);\n      \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint P[N][N],G[N][N];\nint X[4]={0,1,0,-1};\nint Y[4]={1,0,-1,0};\n\nvoid Empty(int *,int *);\nvoid Swap(int *,int *);\nint DFS(int ,int ,int ,int ,const int );\nint cal();\n\nint main()\n{\n  int i,j,a;\n  int h,ans,row,col;\n\n  for(i = 0;i < N; i++){\n    for(j = 0;j < N; j++){\n      scanf(\"%d\",&a);\n      P[i][j] = a;\n    }\n  }\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      G[i][j] = -1;\n    }\n  }\n\n  Empty(&row,&col);\n\n  for(h=0;h<100;h++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        G[i][j] = P[i][j];\n      }\n    }\n    ans = DFS(row,col,-1,0,h);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        P[i][j] = G[i][j];\n      }\n    }\n    ans = -1;\n    if(h == 99)\n      printf(\"%d\\n\\n\",ans);\n  }\n\n  return 0;\n}\n\nvoid Empty(int *row,int *col)\n{\n  int i,j;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!P[i][j]){\n        *row = j;\n        *col = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid Swap(int *a,int *b)\n{\n  int tmp;\n\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint DFS(int x,int y,int p,int deep,const int lim)\n{\n  int i,len,emc;\n  int x2,y2;\n\n  len = cal();\n\n  if(len == 0)\n    return deep;\n  if(deep + len > lim)\n    return -1;\n\n  for(i=0; i<N+1; i++){\n    x2 = x+X[i];\n    y2 = y+Y[i];\n    if(p != -1 && i == (p+2)%4)\n      continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3))\n      continue;\n\n    Swap(&P[y][x],&P[y2][x2]);\n\n    emc = DFS(x2,y2,i,deep+1,lim);\n\n    if(emc != -1)\n      return emc;\n\n    Swap(&P[y][x],&P[y2][x2]);\n  }\n\n  return -1;\n}\n\nint cal()\n{\n  int i,e,C = 0;\n\n  for(i=0;i<9;i++){\n    e = P[i/3][i%3];\n    if(e){\n      e--;\n      C += abs(i/3-e/3) + abs(i%3-e%3);\n    }\n  }\n  return C;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  \n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag] != 0) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint distance(char *s_new) {\n  char s[] = \"123456780\";\n  int i;\n  int sum = 0;\n  for(i = 0; i < 9; i++) {\n    int a = 0;\n    int b = 0;\n    while(s[a]-'0' != i) a++;\n    while(s_new[b]-'0' != i) b++;\n    sum += abs(a/3-b/3) + abs(a%3-b%3);\n  }\n  return sum;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int right,left,up,down,min;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    right = distance(s_right);\n  }else{\n    right = INT_MAX;\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n    left = distance(s_left);\n  }else{\n    left = INT_MAX;\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    up = distance(s_up);\n  }else{\n    up = INT_MAX;\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    down = distance(s_down);\n  }else{\n    down = INT_MAX;\n  }\n\n  min = right;\n  if(min > left) min = left;  \n  if(min > up) min = up;  \n  if(min > down) min = down;\n\n  if(right == min) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n  }\n  if(left == min) {\n    if((k = create(s_left,flag[tag]+1))) return k;\n  }\n  if(up == min) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n  }\n  if(down == min) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n  }\n\n  free(s);\n  if(s_right != NULL) free(s_right);\n  if(s_left != NULL) free(s_left);\n  if(s_up != NULL) free(s_up);\n  if(s_down != NULL) free(s_down);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {;}\n  return k;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define M 3\n\ntypedef struct{\n  int A[M][M];\n}Pazzle;\n\nPazzle P;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint heuristic(Pazzle P){\n  int i,j;\n  int hx,hy,sum=0;\n\n  for(i=0; i<M; i++){\n    for(j=0; j<M; j++){\n      if(P.A[i][j] == 0)continue;\n      \n      hx = (P.A[i][j]-1)%M-j;\n      hy = (P.A[i][j]-1)/M-i;\n\n      if(hx < 0)sum -= hx;\n      else sum += hx;\n\n      if(hy < 0)sum -= hy;\n      else sum += hy;\n    }\n  }\n\n  return sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int n){\n  int i,temp;\n  int x0,y0,ans=-1,h;\n\n  h = heuristic(P);\n\n  if(h == 0)return cnt;\n  if(cnt + h > max)return -1;\n\n  for(i=0; i<4; i++){\n    x0 = x + dx[i];\n    y0 = y + dy[i];\n\n    if((i == (n+2)%4 && n != -1) || !(0<=x0 && x0<M && 0<=y0 && y0<M))continue;\n    temp = P.A[y][x];\n    P.A[y][x] = P.A[y0][x0];\n    P.A[y0][x0] = temp;\n\n    ans = dfs(x0,y0,max,cnt+1,i);\n\n    if(ans != -1)return ans;\n    temp = P.A[y][x];\n    P.A[y][x] = P.A[y0][x0];\n    P.A[y0][x0] = temp;\n  }\n\n  return -1;\n}\n\nint main(){\n  int i,j;\n  int kx,ky,ans,a;\n  Pazzle tP;\n\n  for(i=0; i<M; i++){\n    for(j=0; j<M; j++){\n      scanf(\"%d\",&a);\n      P.A[i][j] = a;\n      if(a == 0){\n\tkx = j;\n\tky = i;\n      }\n    }\n  }\n\n  tP = P;\n\n  for(i=1; i<46; i++){\n    P=tP;\n    ans = dfs(kx,ky,i,0,-1);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n \n    int ori[Total] ={};\n    \n    \n    int i = 0;\n    int num_0 = 0;\n    int x,y = 0;\n     \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        ori[i]=val[i];\n        \n        if(val[i] == 0)\n        {\n            num_0 = i;\n        }\n    }\n    \n    x = tate - (num_0/yoko);\n    y = yoko - (num_0%yoko);\n    \n        // åæå\n        for(i=0; i<Total; i++)\n        {\n            val[i]=ori[i];\n        }\n        num = num_0;\n        cnt = 0;\n        \n    for(i=1; i<35; i++)\n    {\n        if( serch(x,y,i) )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n        \n//  printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);        \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(cnt >= MaxCnt)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x != 0)\n                {\n                    down_0();\n                    x = x-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    up_0();\n                    x = x+1;\n                }\n                break;\n            case 1:\n                if(y != 0)\n                {\n                    right_0();\n                    y = y-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    left_0();\n                    y = y+1;\n                }\n                break;\n            case 2:\n                if(y < yoko-1)\n                {\n                    left_0();\n                    y = y+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    right_0();\n                    y = y-1;\n                }\n                break;\n            case 3:\n                if(x < tate-1)\n                {\n                    up_0();\n                    x = x+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    down_0();\n                    x = x-1;\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n  char s[10];\n  int t;\n  int x;\n  struct node *next;\n  struct node *back;\n}Node;\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(Node *root, char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  Node *p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->t = t;\n  int i;\n  for(i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      p->x = i;\n      break;\n    }\n  }\n  root->back->next = p;\n  p->back = root->back;\n  p->next = root;\n  root->back = p;\n  return -1;\n}\n\nint cal(Node *root) {\n  char *s_new;\n  int k;\n  if((s_new = move_right(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  if((s_new = move_left(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  if ((s_new = move_up(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  if((s_new = move_down(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  Node *tmp = root->next;\n  tmp->next->back = root;\n  root->next = tmp->next;\n  free(tmp);\n  return -1;\n}\n  \n\nint solve(char s0[]) {\n  int t;\n  Node root;\n  root.next = &root;\n  root.back = &root;\n  if((t = create(&root,s0,0)) != -1) return t;\n  \n  while(1) {\n    if((t = cal(&root)) != -1) break;\n  }\n  return t;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n  char s[10];\n  int f;\n  struct node *next;\n  struct node *back;\n}Node;\n\nvoid move_up(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-3];\n  s[x-3] = tmp;\n}\n\nvoid move_left(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-1];\n  s[x-1] = tmp;\n}\n\nvoid move_right(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+1];\n  s[x+1] = tmp;\n}\n\nvoid move_down(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+3];\n  s[x+3] = tmp;\n}\n\nint heuristic(char s[]) {\n  int h,i,d;\n  h = 0;\n  for (i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      h += 2-i%3 + 2-i/3;\n    }\n    else {\n      d = abs(s[i]-'0'-1 - i);\n      h += d%3 + d/3; \n    }\n  }\n  return h;\n}\n\nNode *add_list(Node *begin, char s[], int f) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) {\n      if(p->f > f) p->f = f;\n      return begin;\n    }\n    p = p->next;\n  }\n  \n  p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->f = f;  \n  if(begin != NULL) begin->back = p;\n  p->next = begin;\n  p->back = NULL;\n  return p;\n}\n\nNode *remove_node(Node *begin, Node *p) {\n  if(p == begin) {\n    if(p->next != NULL) p->next->back = NULL;\n    return p->next;\n  }\n  p->back->next = p->next;\n  if(p->next != NULL) p->next->back = p->back;\n  return begin;\n}\n\nNode *move_node(Node *begin, Node *p) {\n  p->back = NULL;\n  p->next = begin;\n  if(begin != NULL) begin->back = p;\n  return p;\n}\n\nNode *search_node(Node *begin, char s[]) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) break;\n    p = p->next;\n  }\n  return p;\n}\n\nvoid open_node(Node **open, Node **close, char s[], int g) {\n  int f;\n  Node *p;\n  f = g + 1 + heuristic(s);\n  p = search_node(*close,s);\n  if(p != NULL ) {\n    if(p->f > f) {\n      p->f = f;\n      *close = remove_node(*close,p);\n      *open = move_node(*open,p);\n    }\n  }\n  else {\n    *open = add_list(*open,s,f);\n  }\n}\n\nint solve(char s0[]) {\n  int x,g,min_f;\n  char s[10];\n  Node *open = NULL;\n  Node *close = NULL;\n  Node *p,*min;\n  open = add_list(open,s0,heuristic(s0));\n  while(1) {\n    p = open;\n    min_f = p->f;\n    min = p;\n    while(p != NULL) {\n      if(p->f < min_f) {\n  \tmin_f = p->f;\n  \tmin = p;\n      }\n      p = p->next;\n    }\n    strcpy(s,min->s);\n    //printf(\"%s\\n\",s);\n    if(strcmp(s,\"123456780\") == 0) break;\n    g = min->f - heuristic(s);\n    open = remove_node(open,min);\n    close = move_node(close,min);\n    for (x = 0; x < 9; x++) if(s[x] == '0') break;\n    if(x > 2) {\n      move_up(s,x);\n      open_node(&open,&close,s,g);\n      move_down(s,x-3);\n    }\n    if(x < 6) {\n      move_down(s,x);\n      open_node(&open,&close,s,g);\n      move_up(s,x+3);\n    }\n    if(x%3 < 2) {\n      move_right(s,x);\n      open_node(&open,&close,s,g);\n      move_left(s,x+1);\n    }\n    if(x%3 > 0) {\n      move_left(s,x);\n      open_node(&open,&close,s,g);\n      move_right(s,x-1);\n    }\n  }\n  return min->f;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 3\n#define MAX 15\n\ntypedef struct{\n  int A[N][N];\n}Pazzle;\n\nPazzle P;\n\nint d_x[4]={0,1,0,-1},d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n  int h;\n  h=*A;\n  *A=*B;\n  *B=h;\n}\n\nint check(Pazzle P){\n  int sum=0,i,j,h_y,h_x;\n\n  for( i=0 ; i<N ; i++ ){\n    for( j=0 ; j<N ; j++ ){\n      if( P.A[i][j]==0 )\n        continue;\n      h_y=(P.A[i][j]-1)/N-i;\n      h_x=(P.A[i][j]-1)%N-j;\n      if( h_y<0 )\n        sum-=h_y;\n      else\n        sum+=h_y;\n      if( h_x<0 )\n        sum-=h_x;\n      else\n        sum+=h_x;\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int max,int count,int m){\n  int i,h,x_0,y_0,ans=-1;\n\n  h=check(P);\n\n  if( h==0 ) return count;\n  if( count+h>max ) return -1; \n  for( i=0 ; i<4 ; i++ ){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if(( m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N )) continue;  \n\n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n\n    ans=dfs(x_0,y_0,max,count+1,i);\n\n    if( ans!=-1 ) return ans;       \n\n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n\n  }   \n  return -1;\n}\n\nint main(void){\n  Pazzle t_P;\n  int  i,j,anser,x_0,y_0;\n\n  for( i=0 ; i<N ; i++ ){\n    if( i<N )break;\n  }\n  \n  for( i=0 ; i<N ; i++ ){\n    for( j=0 ; j<N ; j++ ){\n      scanf(\"%d\",&P.A[i][j]);\n      if( P.A[i][j]==0 ){\n\tx_0=j;\n\ty_0=i;           \n      }        \n    }\n  }\n\n  t_P=P;\n\n  for( i=1 ; i<46 ; i++ ){\n    P=t_P;\n    anser=dfs(x_0,y_0,i,0,-1);\n    if(anser!=-1){\n        printf(\"%d\\n\",anser); \n        break;\n        }\n  }\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid Empty(int *, int *);\nvoid swap(int *, int *);\nint Cal();\nint DFS(int, int, int, int, int);\n\nint main(){\n  int i, j, l;\n  int x, y, a;\n\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      scanf(\"%d\",&Puzzle[i][j]);\n    }\n  }\n\n  Empty(&x,&y);\n\n  for(l = 0 ; l < 100 ; l++){\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n\ttmp[i][j] = Puzzle[i][j];\n      }\n    }\n\n    a = DFS(x, y, -1, 0, l);\n    if(a != -1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n\tPuzzle[i][j] = tmp[i][j];\n      }\n    }\n    \n    a = -1;\n    if(l == 99) printf(\"%d\\n\",a);\n  }\n\n  return 0;\n}\n\nvoid Empty(int *x, int *y){\n  int i, j;\n\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      if(!Puzzle[i][j]){\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n  \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\nint Cal(){\n  int i, a;\n  int sum = 0;\n\n  for(i = 0 ; i < 9 ; i++){\n    a = Puzzle[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n    }\n  }\n\n  return sum;\n}\n\nint DFS(int x, int y, int p, int dep, int limit){\n  int i, h, nx, ny, res;\n\n  h = Cal();\n  \n  if(h == 0) return dep;\n  if(dep + h > limit) return -1;\n\n  for(i = 0 ; i < 4 ; i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n\n    if(~p && i == (p+2)%4) continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3)) continue;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n    res = DFS(nx, ny, i, dep+1, limit);\n    if(~res) return res;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n  }\n\n  return -1;\n}\n    \n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 20\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n\nextern inline void down_0(void);    // 0 ãä¸ã«ç§»å\nextern inline void up_0(void);      // 0 ãä¸ã«ç§»å\nextern inline void right_0(void);   // 0 ãå³ã«ç§»å\nextern inline void left_0(void);    // 0 ãå·¦ã«ç§»å\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;        // 0 ã®ä½ç½®ãç¤ºã\nint val[Total] ={}; // æ°å¤éå\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    // æå­åã®åãè¾¼ã¿\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    // å³ä¸ã«è¡ãããã« 0 ãä½ååããã°ãããã\n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=0; i<TryCnt; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§ã´ã¼ã«ã¨ä¸è´ãã¦ãããç¢ºèª\n    if(MaxCnt==0)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ã´ã¼ã«ã¨ä¸ä¸è´\n                return 0;\n            }\n        }\n        // ã´ã¼ã«ã¨ä¸è´ï¼ï¼\n        return 1;\n    }\n    \n    \n    // 0 ã®ç§»å\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n                \n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n                \n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n                \n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n                \n            default:\n                // ä½ãããªãã\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++){\n    \n    for(j=0; j<3; j++){\n      \n      if(!puz[i][j]){\n\t\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n   \nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\n  \nint dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,nx,ny,res;   \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1; \n    for(i=0; i<4; i++){\n        nx = x+dx[i];\n        ny = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;       \n        swap(&puz[y][x],&puz[ny][nx]);\n    }   \n    return -1;\n}  \n    \nint main() {\n    int i,j,ans,x,y,l;\n      \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++)\n\t  scanf(\"%d\",&puz[i][j]);\n    }\n       \n    empty(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++)\n\t      tmp[i][j] = puz[i][j];\n        }\n          \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n          \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++)\n\t      puz[i][j] = tmp[i][j];\n        }\n          \n        ans = -1;\n\t\n        if(l==99)\n\t  printf(\"%d\\n\",ans);\n    }\n      \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n//     +-+-+-+       +-+-+-+\n//     |1|3|0|       |1|2|3|\n//     +-+-+-+       +-+-+-+\n//     |4|2|5|       |4|5|6|\n//     +-+-+-+       +-+-+-+\n//     |7|8|6|       |7|8|0|\n//     +-+-+-+       +-+-+-+\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 30;\n\nconst Motion candidate[9][5] = //ç©ºãã¦ãããã¹ã®ä½ç½®ã«å¯¾ããç§»åã§ãããã¼ã¹ã¨ãã®æ¹å\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    //    puts(board);\n    //    printf(\"%d\\n%c%c%c\\n%c%c%c\\n%c%c%c\\n---\\n\", nhistories, board[0],board[1],board[2],  board[3],board[4],board[5],  board[6],board[7],board[8]);\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // åã¨åãéç½®ã«ãªã£ãã®ã§æ¬¡ã®æãè©¦ã\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 8\ntypedef struct{\n    int A[N][N];\n\n}Pazzle;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\nvoid swap(int *,int *);\nint check(Pazzle);\nint dfs(int ,int ,int ,int ,Pazzle );\n\nint main(void){\n    Pazzle P,t_P;\n    int  i,j,ans;\n    int x0,y0;\n\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&P.A[i][j]);\n            if(P.A[i][j]==0){\n                x0=j;\n                y0=i;\n                \n            }\n            \n        }\n    }\n    t_P=P;\n    for(i=1;i<100;i++){\n        P=t_P;\n    ans=dfs(x0,y0,i,0,P);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n    }\n    return 0;\n}\n\nint dfs(int x,int y,int max,int cnt,Pazzle P){\n         int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;   \n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1; \n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if(!(0<=x_0 && x_0<3 && 0<=y_0 && y_0<3)) continue;    \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,P);\n    if(ans!=-1) return ans;       \n     swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }   \n  return -1;\n}\n\nvoid swap(int *A,int *B){\n int hoge;\n hoge=*A;\n *A=*B;\n *B=hoge;\n \n \n}\nint check(Pazzle P){\n    int sum=0,i,j,hy,hx;\n    for(i=0;i<N;i++){\n \n    for(j=0;j<N;j++){\n        if(P.A[i][j]==0)\n        continue;\n        hy=(P.A[i][j]-1)/N-i;\n        hx=(P.A[i][j]-1)%N-j;\n        if(hy<0)\n        sum-=hy;\n        else\n        sum+=hy;\n        if(hx<0)\n        sum-=hx;\n        else\n        sum+=hx;\n \n \n}\n}\n \nreturn sum;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define N 3\n#define MAX 1000\n#define INF -1\n\n\n\ntypedef struct {\n  int ban[N*N], sp, MD, p[N][N];  \n}Record;\n\n\n\nvoid IDA(Record); \nint Manhat(Record);\nint dfs(int, int);\n\n\n\n\n\nint cnt = 0, ans[N][N], size, limit, stack[N], time, path[100];\nint dx[4] = {0, -1, 0, 1}; //åæ¹å\nint dy[4] = {1, 0, -1, 0}; //åæ¹å\nint MDT[N*N][N*N];\nchar dir[4] = {'r','u','l','d'}; //å³ãä¸ãå·¦ãä¸\nchar an[100];\nRecord data, in;\n\n\nint main () {\n  int i, j, k = 0, m = 0, l = 0;\n\n\n  for(i = 0 ; i < N*N ; i++) {\n    for(j = 0 ; j < N*N ; j++) {\n      m = i / N - j / N;\n      l = i % N - j % N;\n\n      if(m < 0) m = -1 * m;\n      if(l < 0) l = -1 * l;\n      MDT[i][j] = m + l;\n    }\n  }\n\n\n\n  for(i = 0 ; i < N*N ; i++) {\n      scanf(\"%d\",&in.ban[i]);\n\n      if(in.ban[i] == 0) {\n\tin.ban[i] = N*N;\n\tin.sp = i;\n      }\n    \n      //if(i * j != (N-1)*(N-1)) ans[i][j] = ++k;\n  }\n\n  IDA(in);\n \n\n  printf(\"%d\\n\",strlen(an));\n\n  return 0;\n}\n\n\n\nint Manhat(Record A) {\n  int d = 0, i;\n  \n  for(i = 0 ; i < N * N ; i++) {\n    if(A.ban[i] == N*N) continue;\n    d += MDT[i][A.ban[i]-1];\n  }\n\n  return d;\n}\n\n\n\n\n\n\nint dfs(int def, int prev) {\n  int sx = 0, sy = 0, i, j, tx = 0, ty = 0, max = 0, min = 0, t1;\n  Record tmp;\n\n  //printf(\"test\\n\");\n  if(data.MD == 0) return 1;\n\n  if(def + data.MD > limit) return -1;\n\n  sx = data.sp / N;\n  sy = data.sp % N;\n\n  for(i = 0 ; i < 4 ; i++) {\n    tx = sx + dx[i];\n    ty = sy + dy[i];\n\n    if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n    if(prev > i) {\n      max = prev;\n      min = i;\n    }\n\n    else {\n      max = i;\n      min = prev;\n    }\n\n    if(max - min == 2) continue;\n\n    tmp = data;\n    data.MD -= MDT[tx * N + ty][data.ban[tx * N + ty]-1]; //æ­£è§£ã«è¿ã¥ãã¦ããã\n    data.MD += MDT[sx * N + sy][data.ban[tx * N + ty]-1];\n    t1 = data.ban[tx * N + ty];\n    data.ban[tx * N + ty] = data.ban[sx * N + sy];\n    data.ban[sx * N + sy] = t1;\n\n    data.sp = tx * N + ty;\n\n    if(dfs(def + 1, i) == 1) {\n      path[def] = i;\n      return 1;\n    }\n\n    data = tmp;\n  }\n  \n\n  return -1;\n}\n\n\nvoid IDA(Record A) {\n  int i, cnt = 0, j = 0;\n  \n  in.MD = Manhat(in);\n\n  for(limit = in.MD ; limit <= 100 ; limit++) {\n    data = in;\n\n    if(dfs(0, -100) == 1) {\n      for(i = 0 ; i < limit ; i++) {\n   \n\tan[j] = dir[path[i]];\n\tj++;\n      }\n      //printf(\"test\\n\");\n      an[j] = '\\0';\n      return;\n    }\n\n  }\n  \n}\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 3\n#define N2 9\n#define LIMIT 31\n\ntypedef struct { char b[N2+1]; } Board;\nBoard board;\nint minstep;\ntypedef enum { R, U, L, D } Direction;\ntypedef struct { int pos; Direction dir; } Motion;\n\nconst Motion motion[N2][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nconst int rr[4][5] = {{0,0,1,0,0},{0,0,0,1,0},{1,0,0,0,0},{0,1,0,0,0}};\n\nint dd[N2][N2];\nint dist(char *b)\n{\n  int i, n, d = 0;\n  for (i=0; i<N2; i++) {\n    n = b[i]-1;\n    if (n<0)   continue;\n    d += dd[n][i];\n  }\n  return d;\n}\n\nvoid search(int step, Motion prev)\n{\n  int i, d=0;\n  d = dist(board.b);\n  if (step+d>minstep) return;\n  if (d==0) {\n    printf(\"%d\\n\", step);\n    exit(0);\n  }\n  Board board_bak = board;\n  for (i=0; motion[prev.pos][i].pos>=0; i++) {\n    Motion m = motion[prev.pos][i];\n    if (rr[m.dir][prev.dir]) continue; //åã«æ»ãã®ãé²æ­¢\n    board.b[prev.pos] = board.b[m.pos];\n    board.b[m.pos] = 0;\n    search(step+1, m);\n    board = board_bak;\n  }\n}\n\nint main()\n{\n  int i, j;\n  for (i=0; i<N2; i++)\n    for (j=0; j<N2; j++)\n      dd[i][j] = abs(i%N-j%N) + abs(i/N-j/N);\n\n  Motion m;\n  m.dir = 4;\n  Board ini_board;\n  for (i=0; i<N2; i++) {\n    fscanf(stdin, \"%hd\", (short int*)&ini_board.b[i]);\n    if (ini_board.b[i]==0) m.pos = i;\n  }\n  for (minstep=dist(ini_board.b); minstep<=LIMIT; minstep++) {\n    board = ini_board;\n    search(0, m);\n  }\n  puts(\"no result.\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define MOD 1999993\n\nconst int dy[4]={-1,1,0,0},dx[4]={0,0,-1,1};\n\nstruct P{\n\tint tile[9];\n\tint step, O;\n\tstruct P *next,*prev;\n};\ntypedef struct P* puzzle;\n\n//{{{ Hash\nint mem[2000000];\nint h1(int key){\n\treturn key%MOD;\n}\nint h2(int key){\n\treturn 1+key%(MOD-1);\n}\nint Hash(int* array, int col, char com){\n\tint i,key=0,pos;\n\tfor(i=0;i<9;i++)key=key*10 + array[i];\n\n\tpos=( h1(key) + col*h2(key) )%MOD;\n\tif(com=='M'){\n\t\t//Memo\n\t\tif(mem[pos]==0)mem[pos]=key;\n\t\telse return Hash(array,col+1, 'M');\n\n\t\treturn 0;\n\t}else if(com=='F'){\n\t\t//Find\n\t\tif(mem[pos]==key)return 1;\n\t\telse if(mem[pos]==0)return 0;\n\t\telse return Hash(array,col+1,'F');\n\t}\n\t\n}\n//}}}\n//{{{ Queue\npuzzle head;\nvoid Push(struct P in){\n\tint i,key=0,digit=1;\n\tpuzzle data=(puzzle)malloc(sizeof(struct P));\n\tfor(i=0;i<9;i++){\n\t\tdata->tile[i]=in.tile[i];\n\t\tkey+=digit*(in.tile[i]);\n\t\tdigit*=10;\n\t}\n\tHash(in.tile,0,'M');\n\tdata->step = in.step;\n\tdata->O = in.O;\n\n\tHash(in.tile, 0,'M');\n\n\tdata->next=head;\n\tdata->prev=(head->prev);\n\t(head->prev)->next=data;\n\t(head->prev)=data;\n\n\treturn;\n\n}\n\nstruct P Pop(void){\n\tif(head->next == head){\n\t\tprintf(\"empty!!\\n\");\n\t\texit(1);\n\t}\n\tint i;\n\tstruct P out;\n\tfor(i=0;i<9;i++){\n\t\tout.tile[i]=(head->next)->tile[i];\n\t}\n\tout.step=(head->next)->step;\n\tout.O=(head->next)->O;\n\n\tpuzzle del=head->next;\n\thead->next=(del)->next;\n\thead->next->prev = head;\n\tfree(del);\n\t//(head->next)->prev=head;\n\n\treturn out;\n}\n//}}}\n\nint Check(struct P x){\n\tint i;\n\tfor(i=0;i<9;i++){\n\t\tif(x.tile[i]!=(i+1)%9)return 0;\n\t}\n\n\treturn 1;\n}\n\nvoid Solve(void){\n\tint i,j,y,x,nY,nX,tmp;\n\tstruct P u,v;\n\n\twhile(head->prev != head){\n\t\tu=Pop();\n\t\tif(Check(u)){\n\t\t\tprintf(\"%d\\n\",u.step);\n\t\t\texit(0);\n\t\t}\n\t\ty=u.O/3;\tx=u.O%3;\n\t\tfor(i=0;i<4;i++){\n\t\t\tnY=y+dy[i],nX=x+dx[i];\n\t\t\tif(nY<0||nX<0||nY>=3||nX>=3)continue;\n\n\t\t\tv=u;\n\t\t\tv.step++;\n\t\t\t// O ã®swap\n\t\t\t\tv.O = 3*nY + nX;\n\t\t\t\ttmp=v.tile[3*nY + nX];\n\t\t\t\tv.tile[3*nY + nX]=v.tile[3*y + x];\n\t\t\t\tv.tile[3*y + x]=tmp;\n\t\t\t\t\n\t\t\tif(Hash(v.tile,0,'F'))continue;\n\t\t\t\n\t\t\tPush(v);\n\t\t}\n\t}\n\treturn;\n}\n\nsigned main(){\n\tfor(int i=0;i<4;i++){\n\t}\n\tint i;\n\thead=(puzzle)malloc(sizeof(struct P));\n\n\thead->next=head;\thead->prev = head;\n\thead->step=-1;\n\n\tstruct P in;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&(in.tile[i]));\n\t\tif(in.tile[i]==0)in.O=i;\n\t}\n\tin.step=0;\n\tPush(in);\n\tSolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint P[N][N],T[N][N];\nint X[N+1]={0,1,0,-1};\nint Y[N+1]={1,0,-1,0};\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main()\n{\n  int i,j;\n  int h,ans,row,col;\n\n  for(i=0; i<N; i++){\n    for(j=0; j<N; j++){\n      scanf(\"%d\",&P[i][j]);\n    }\n  }\n\n  empty(&row,&col);\n\n  for(h=0; h<100; h++){\n    for(i=0; i<N; i++){\n      for(j=0; j<N; j++){\n        T[i][j] = P[i][j];\n      }\n    }\n    ans = dfs(row,col,-1,0,h);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0; i<N; i++){\n      for(j=0; j<N; j++){\n        P[i][j] = T[i][j];\n      }\n    }\n    ans = -1;\n    if(h==99)\n      printf(\"%d\\n\\n\",ans);\n  }\n\n  return 0;\n}\n\nvoid empty(int *row,int *col)\n{\n  int i,j;\n\n  for(i=0; i<N; i++){\n    for(j=0; j<N; j++){\n      if(!P[i][j]){\n        *row = j;\n        *col = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b)\n{\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint cal()\n{\n  int i,e;\n  int C=0;\n\n  for(i=0; i<9; i++){\n    e = P[i/3][i%3];\n    if(e){\n      e--;\n      C += abs(i/3-e/3) + abs(i%3-e%3);\n    }\n  }\n  return C;\n}\n\nint dfs(int x,int y,int p,int deep,const int limt)\n{\n  int i,len,emc;\n  int x2,y2;\n\n  len = cal();\n\n  if(len==0)\n    return deep;\n  if(deep+len > limt)\n    return -1;\n\n  for(i=0; i<N+1; i++){\n    x2 = x+X[i];\n    y2 = y+Y[i];\n    if(~p && i==(p+2)%4)\n      continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3))\n      continue;\n\n    swap(&P[y][x],&P[y2][x2]);\n\n    emc = dfs(x2,y2,i,deep+1,limt);\n\n    if(~emc)\n      return emc;\n\n    swap(&P[y][x],&P[y2][x2]);\n  }\n\n  return -1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_LENGTH 100\nint ini[3][3];\nint changed[3][3];\nint dxn[4] = {0, 1, 0, -1};\nint dyn[4] = {1, 0, -1, 0};\nvoid makeEmpty(int *row, int *column)\n{\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            if(!ini[i][j]){*column = i;*row = j;}\n        }\n    }\n}\nint calculate()\n{\n    int countSum = 0;\n    for(int i=0;i<9;i++)\n    {\n        int temp = ini[i/3][i%3];\n        if(temp)\n        {\n            temp--;\n            countSum += abs(i/3-temp/3)+abs(i%3-temp%3);\n        }\n    }\n    return countSum;\n}\nint depthFirstSearch(int x, int y, int k, int depth, const int limit)\n{\n    int length;\n    length = calculate();\n    if (length == 0)return depth;\n    if (depth + length > limit)return -1;\n    for (int i = 0; i < 4; i++)\n    {\n        int a = x + dxn[i];\n        int b = y + dyn[i];\n        if (~k && i == (k + 2) % 4)continue;\n        if (!(0 <= a && a < 3 && 0 <= b && b < 3))continue;\n        int tem = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=tem;\n        int res = depthFirstSearch(a, b, i, depth + 1, limit);\n        if (~res)return res;\n        int te = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=te;\n    }\n    return -1;\n}\nint main() {\n    int row, column=0;\n    int step;\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++){scanf(\"%d\", &ini[i][j]);}\n    }\n    makeEmpty(&row, &column);\n    for(int l=0;l<MAX_LENGTH;l++)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){changed[i][j]=ini[i][j];}\n        }\n        if((step = depthFirstSearch(row, column, -1, 0, l))!=-1)\n        {\n            printf(\"%d\\n\", step);\n            break;\n        }\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){ini[i][j]=changed[i][j];}\n        }\n        step = -1;\n        if(l==MAX_LENGTH-1){printf(\"%d\\n\", step);}\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\n\n\n\n\nvoid copy(int m[3][3], int t[3][3]) {\n    int i, j;\n    \n    for(i = 0; i < 3; i++)\n        for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n    int i, sum = 0;\n    for(i = 0; i < 9; i++) {\n        int v = mas[i/3][i%3];\n        if(v) {\n            v--;\n            sum += abs(i/3-v/3)+abs(i%3-v%3);\n        }\n    }\n    return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint is_in(int x, int y) {\n    return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n    int i, h = calc();\n    if(h == 0) return dep;\n    if(dep+h > lim) return -1;\n    \n    for(i = 0; i < 4; i++) {\n        int nx = x+dx[i], ny = y+dy[i], res;\n        if(~p && i == (p+2)%4) continue;\n        if(!is_in(nx, ny)) continue;\n        swap(&mas[y][x], &mas[ny][nx]);\n        res = dfs(nx, ny, i, dep+1, lim);\n        if(~res) return res;\n        swap(&mas[y][x], &mas[ny][nx]);\n    }\n    \n    return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n    int i, j;\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            if(!mas[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\nint solve() {\n    int x, y, lim, ans;\n    get_empty(&x, &y);\n    for(lim = 0; lim < 50; lim++) {\n        copy(cpy, mas);\n        if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n        copy(mas, cpy);\n    }\n    return -1;\n}\n\nint main() {\n    int i, j;\n    for(i = 0; i < 3; i++)\n        for(j = 0; j < 3; j++)\n            scanf(\"%d\", &mas[i][j]);\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  \n#define N 3\n#define LIM 32\n#define HN 362897\n  \nstruct dep{\n    int depth,key;\n};\n  \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n  \nint min = LIM;\nstruct dep h[HN];\n  \nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n  \n  \nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i1,j1,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i1=i;\n                j1=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n      \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n      \n    if(i1>0 && i1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1-1][j1];\n        tmp[i1-1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>0 && j1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1-1];\n        tmp[i1][j1-1]=f;\n        dfs(tmp, n+1);\n    }\n      \n    if(i1>=0 && i1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1+1][j1];\n        tmp[i1+1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>=0 && j1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1+1];\n        tmp[i1][j1+1]=f;\n        dfs(tmp, n+1);\n    }\n      \n}\n  \nint main()\n{\n    int i,j;\n    int p[N][N];\n      \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n      \n    printf(\"%d\\n\",min);\n      \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint a[10];\nint fact[10]={1,1,2,6,24,120,720,5040,40320};\n\nint dp[362880];\nvoid swap(int i,int j){\n\tint t=a[i];\n\ta[i]=a[j];\n\ta[j]=t;\n}\n\nint f(){\n\tint ans=0,b=0;\n\tfor(int i=8;i>=0;i--){\n\t\tans+=__builtin_popcount(b&((1<<a[i])-1))*fact[8-i];\n\t\tb|=1<<a[i];\n\t}\n\treturn ans;\n}\nvoid g(int n){\n\tint b=0;\n\tfor(int i=0;i<9;i++)a[i]=i;\n\tfor(int i=0;i<9;i++){\n\t\tint x=n/fact[8-i];\n\t\tn%=fact[8-i];\n\t\tfor(int j=x;j>0;j--)swap(i+j,i+j-1);\n\t}\n}\n\nint que[363000],quecnt;\nvoid check(int p,int k){\n\tint x=f();\n\tif(!dp[x]){\n\t\tdp[x]=k+1;\n\t\tque[quecnt++]=x*10+p;\n\t}\n}\nint calc(){\n\tfor(int i=0;i<quecnt;i++){\n\t\tint x=que[i]/10;\n\t\tint p=que[i]%10;\n\t\tif(x==0)return dp[x]-1;\n\t\tg(x);\n\t\tif(p  <6)swap(p,p+3),check(p+3,dp[x]),swap(p,p+3);\n\t\tif(p  >2)swap(p,p-3),check(p-3,dp[x]),swap(p,p-3);\n\t\tif(p%3<2)swap(p,p+1),check(p+1,dp[x]),swap(p,p+1);\n\t\tif(p%3>0)swap(p,p-1),check(p-1,dp[x]),swap(p,p-1);\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint p;\n\tfor(int i=0;i<9;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tif(t)a[i]=t-1;\n\t\telse{\n\t\t\ta[i]=8;\n\t\t\tp=i;\n\t\t}\n\t}\n\tcheck(p,0);\n\tprintf(\"%d\\n\",calc());\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 3\n#define N2 9\n#define LIMIT 31\n\ntypedef struct { char b[N2+1]; } Board;\nBoard board;\nint minstep;\ntypedef enum { R, U, L, D } Direction;\ntypedef struct { int pos; Direction dir; } Motion;\n\nconst Motion motion[N2][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nconst int rr[4][5] = {{0,0,1,0,0},{0,0,0,1,0},{1,0,0,0,0},{0,1,0,0,0}};\n\nint dd[N2][N2];\nint dist(char *b)\n{\n  int i, n, d = 0;\n  for (i=0; i<N2; i++) {\n    n = b[i]-1;\n    if (n<0)   continue;\n    d += dd[n][i];\n  }\n  return d;\n}\n\nvoid search(int step, Motion prev)\n{\n  int i, d=0;\n  d = dist(board.b);\n  if (step+d>minstep) return;\n  if (d==0) {\n    printf(\"%d\\n\", step);\n    exit(0);\n  }\n  Board board_bak = board;\n  for (i=0; motion[prev.pos][i].pos>=0; i++) {\n    Motion m = motion[prev.pos][i];\n    if (rr[m.dir][prev.dir]) continue; //åã«æ»ãã®ãé²æ­¢\n    board.b[prev.pos] = board.b[m.pos];\n    board.b[m.pos] = 0;\n    search(step+1, m);\n    board = board_bak;\n  }\n}\n\nint main()\n{\n  int i, j;\n  for (i=0; i<N2; i++)\n    for (j=0; j<N2; j++)\n      dd[i][j] = abs(i%N-j%N) + abs(i/N-j/N);\n  \n  Motion m;\n  m.dir = 4;\n  Board ini_board;\n  for (i=0; i<N2; i++) {\n    fscanf(stdin, \"%hd\", (short int*)&ini_board.b[i]);\n    if (ini_board.b[i]==0) m.pos = i;\n  }\n  for (minstep=dist(ini_board.b); minstep<=LIMIT; minstep++) {\n    board = ini_board;\n    search(0, m);\n  }\n  puts(\"no result.\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nvoid empty(int *x,int *y){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!puz[i][j]){\n\t*x=j;\n\t*y=i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp=*a;\n \n  *a=*b;\n  *b=tmp;\n}\n\nint cal(){\n  int v,i,sum=0;\n  for(i=0;i<9;i++){\n    v=puz[i/3][i%3];\n    if(v){\n      v--;\n      sum += abs(i/3-v/3) + abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  \n  int i,h,nx,ny,res;\n\n  h=cal();\n  \n  if(h==0){\n    return dep;\n  }\n  \n  if(dep+h > lim){\n    return -1;\n  }\n  \n  for(i=0;i<4;++i){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    \n    if(~p && i==(p+2)%4)\n      continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))\n      continue;\n    \n    swap(&puz[y][x],&puz[ny][nx]);\n    \n    res=dfs(nx,ny,i,dep+1,lim);\n    \n    if(~res){\n      return res;\n    }\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\n\nint main(){\n  \n  int i,j,ans,x,y,l;\n  \n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puz[i][j]);\n    }\n  }\n  \n  empty(&x,&y);\n\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=puz[i][j];\n    }\n    }\n    ans=dfs(x,y,-1,0,l);\n\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpuz[i][j]=tmp[i][j];\n    }\n    }\n    ans=-1;\n\n    if(l==99){\n      printf(\"%d\\n\",ans);\n  }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\n\ntypedef struct node * Node;\n\n#define NIL NULL\n#define N 3\n#define N2 9\n#define M 10000000\n\nNode root;\n\ntypedef struct{\n  int f[N2];\n  int space;\n  int path;\n}Puzzle;\n\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint sum,head=0,tail=0;\nPuzzle Q[M];\n\nvoid push(Puzzle a){\n  Q[tail]=a;\n  tail=(tail+1)%M;\n}\n\nPuzzle pop(void){\n  head=(head+1)%M;\n  return Q[head-1];\n}\n\n\nint isTarget(Puzzle p){\n  int i;\n  for(i=0;i<N2;i++){\n    if(p.f[i]!=(i+1)) return 0;\n  }\n  return 1;\n}\n\nNode treeSearch(Node u, int k){\n  if(u==NIL || k==u->key) return u; \n  if(k < u->key) return treeSearch(u->left,k);\n  else return treeSearch(u->right,k);\n}\n\nint search(Puzzle a){\n  int i,m=1,k;\n  sum=0;\n  for(i=0;i<N2;i++){\n    sum+=a.f[i]*m;\n    m*=10;\n  }\n  if(treeSearch(root,sum)==NIL) return -1;\n  else return 1;\n}\n\n\n\nvoid insert(int k){\n  Node y=NIL;\n  Node x=root;\n  Node z;\n\n  z=malloc(sizeof(struct node));\n  z->key=k;\n  z->left=NIL;\n  z->right=NIL;\n \n  while(x!=NIL){\n    y=x;\n    if(z->key < x->key) x=x->left;\n    else x=x->right;\n  }\n  z->parent=y;\n\n  if(y==NIL) root=z;\n  else if(z->key < y->key) y->left=z;\n  else y->right=z;\n}\n\n\nint bfs(Puzzle s){\n  Puzzle u,v;\n  int r,x;\n  s.path=0;\n  push(s);\n\n  while(head!=tail){\n    u=pop();\n    //     printf(\"%d %d %d\\n%d %d %d\\n%d %d %d\\n\",u.f[0],u.f[1],u.f[2],u.f[3],u.f[4],u.f[5],u.f[6],u.f[7],u.f[8]);\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N, sy=u.space%N;\n    for(r=0;r<4;r++){\n      int tx=sx+dx[r], ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      \n      x=v.f[u.space];\n      v.f[u.space]=v.f[tx*N + ty];\n      v.f[tx*N + ty]=x;\n     \n      v.space=tx*N + ty;\n      if(search(v)==-1){\n\tv.path++;\n\tpush(v);\n\tinsert(sum);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n\n  printf(\"%d\\n\",bfs(in));\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h> \n#define N 3\n  \nint search(int board[N][N], int min, int limit, int r_0, int c_0);\nint search(int board[N][N], int min, int limit, int r_0, int c_0){\n  int md_c;\n  int num;\n  int res[4];\n  if (min == 0){\n    return 0;\n  }\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else {\n\tres[0]++;\n      }\n    }\n    else{\n      res[0] = -1;\n    }\n  }\n  else{\n    res[0] = -1;\n  }\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[1]++;\n      }\n    }\n    else{\n      res[1] = -1;\n    }\n  } \n  else{\n    res[1] = -1;\n  }\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[2]++;\n      }\n    }\n    else{\n      res[2] = -1;\n    }\n  }\n  else{\n    res[2] = -1;\n  }\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      }\n      else{\n\tres[3]++;\n      }\n    }\n    else{\n      res[3] = -1;\n    }\n  }\n  else{\n    res[3] = -1;\n  }\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1){\n    return -1;\n  }\n  else if (res[0] != -1){\n    return res[0];\n  }\n  else if (res[1] != -1){\n    return res[1];\n  }\n  else if (res[2] != -1){\n    return res[2];\n  }\n  else return{\n      res[3];\n    }\n}\nint main(int argc, char *argv[]){\n  int board[N][N],md,i,j,r,c,r_0,c_0,found,res;\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++){\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  }\n\t  else{\n\t    md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  }\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1){\n\tbreak;\n      }\n    }\n  }\n  \n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n    }\n    else {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n    }\n    if (res != -1) break;\n  }  \n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint DFS(int,int,int , int);\n\nint tag();\nvoid change(int *, int *);\n\nint xarr[4]={-1,0,1,0},yarr[4]={0,-1,0,1};\nint array[3][3],sum;\nint main(){\n  int i,j,zerox,zeroy;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&array[i][j]);\n      if(array[i][j]==0){\n\n\tzerox=j;\n\tzeroy=i;\n      }\n    }\n  }\n\n  for(sum=0;sum<32;sum++){\n    if(DFS(0,10,zerox,zeroy)==1) break;\n  }\n  printf(\"%d\\n\",sum);  /*output*/\n  return 0;\n}\nint  DFS(int dep, int prev, int zerox, int zeroy){\n  int i,xx,yy,ta;\n  ta=tag();\n  if(ta==0) return 1;\n  if(dep+ta>sum) return -1;\n\n    for(i=0;i<4;i++){\n      if(i-prev==-2 || i-prev==2) continue;\n      xx=zerox+xarr[i];\n      yy=zeroy+yarr[i];\n      if(xx<0 || yy<0 || xx>=3 || yy>=3) continue;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n\n      if(DFS(dep+1,i,xx,yy)==1) return 1;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n\n    }\n    return -1;\n\n}\n\n\n\nint tag(){\n  int i,j,num=0;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(array[i][j]==0) continue;\n      num+=abs((array[i][j]-1)/3-i)+abs((array[i][j]-1)%3-j);\n\n\n    }\n  }\n  return num;\n}\n\n/*exchange array[zeroy][zerox] and array[yy][xx]*/\nvoid change(int * num1, int *num2){\n  int ch;\n  ch=*num1;\n  *num1=*num2;\n  *num2=ch;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\tint ret;\n\tint i, j, temp;\n\tint seikai[9][2] =\n\t{\n\t\t{0,0},\n\t\t{0,1},\n\t\t{0,2},\n\t\t{1,0},\n\t\t{1,1},\n\t\t{1,2},\n\t\t{2,0},\n\t\t{2,1},\n\t\t{2,2}\n\t};\n\n\tret = 0;\n\tfor(i = 0; i < 3; i++){\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tscanf(\"%d\", &temp);\n\t\t\tif(temp != 0){\n\t\t\t\tret += abs(seikai[(temp - 1)][0] - i);\n\t\t\t\tret += abs(seikai[(temp - 1)][1] - j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // abs()\n\nint puzz[3][3];\nint temp[3][3];\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n\nvoid\nempty(int *x, int *y)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tif (!puzz[i][j])\n\t\t\t{\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nswap(int *a, int *b)\n{\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nint\ncal()\n{\n\tint sum = 0;\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tint a = puzz[i / 3][i % 3];\n\t\tif (a)\n\t\t{\n\t\t\ta--;\n\t\t\tsum += abs(i / 3 - a / 3) + abs(i % 3 - a % 3);\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint\ndfs(int x, int y, int p, int dep, const int lim)\n{\n\tint h = cal();\n\tif (h == 0)\n\t\treturn dep;\n\n\tif (dep + h > lim)\n\t\treturn -1;\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (p != -1 && i == (p + 2) % 4)\n\t\t\tcontinue;\n\n\t\tif (0 <= nx && nx < 3 && 0 <= ny && ny < 3)\n\t\t{\n\t\t\tswap(&puzz[y][x], &puzz[ny][nx]);\n\t\t\tint res = dfs(nx, ny, i, dep + 1, lim);\n\t\t\tif (res != -1)\n\t\t\t\treturn res;\n\n\t\t\tswap(&puzz[y][x], &puzz[ny][nx]);\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tscanf(\"%d\", &puzz[i][j]);\n\t}\n\n\tint x = 0, y = 0;\n\tempty(&x, &y);\n\n\tfor (int l = 0; l < 100; ++l)\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 3; ++j)\n\t\t\t\ttemp[i][j] = puzz[i][j];\n\t\t}\n\n\t\tint ans = dfs(x, y, -1, 0, l);\n\t\tif (ans != -1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 3; ++j)\n\t\t\t\tpuzz[i][j] = temp[i][j];\n\t\t}\n\n\t\tans = -1;\n\t\tif (l == 99)\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\nBoard *history;\nint nhistories=0;\ntypedef enum { U, D, L, R } Direction;\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\nint minstep = INT_MAX;\nconst Motion candidate[9][5] = \n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n  \n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    \n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return; \n    if (step>0 && strcmp(board, ini_board)==0) return; \n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) \n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define base 100000000\nint target = 123456780;\n\nint input[9];\nint n = 3;\nint nSq = 9;\n\nint qh = 0; qt = 0;\nlong long queue[200000];\nint qLength = 200000;\n\nint max = 200000;\nint T[200000];\n\ntypedef struct node {\n\tstruct node* parent;\n\tint hash;\n} node_t;\n\nnode_t* source = NULL;\n\nnode_t* newNode(int);\nint toState(int[]);\nvoid* toArray(int*, int);\n\nint getZeroPos(int);\nint swap(int, int, int);\nint getNext(long long*, node_t*);\n\nvoid getPath(node_t*);\n\nvoid bfs(node_t*);\n\nint isEmpty();\nvoid enqueue(node_t*);\nnode_t* dequeue();\n\nint hashSearch(int);\nint hashInsert(int);\nint hash(int, int);\n\nint main() {\n\tint i, j;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++)\tscanf(\"%d\", &input[i * n + j]);\n\t}\n\tint state = toState(input);\n\tif (state == target) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint hashK = hashInsert(state);\n\tsource = newNode(hashK);\n\tbfs(source);\n\n\treturn 0;\n}\n\nnode_t* newNode(int hashK) {\n\tnode_t* node = (node_t*)malloc(sizeof(node_t));\n\tnode->parent = NULL;\n\tnode->hash = hashK;\n\treturn node;\n}\n\nint toState(int from[]) {\n\tint result = 0;\n\tint weight = base;\n\n\tfor (int i = 0; i < (n * n); i++) {\n\t\tresult += from[i] * weight;\n\t\tweight /= 10;\n\t}\n\treturn result;\n}\n\nvoid* toArray(int* store, int state) {\n\tint weight = base;\n\n\tfor (int i = 0; i < (n * n); i++) {\n\t\tstore[i] = (int)(state / weight);\n\t\tstate %= weight;\n\t\tweight /= 10;\n\t}\n}\n\nint getZeroPos(int state) {\n\tint weight = base;\n\tfor (int i = 0; i < nSq; i++) {\n\t\tif (state / weight == 0) return i;\n\t\tstate %= weight;\n\t\tweight /= 10;\n\t}\n\texit(0);\n}\n\nint swap(int originalState, int zero_pos, int with_pos) {\n\tint newState;\n\tint swapArray[9];\n\ttoArray(&swapArray, originalState);\n\n\tint temp = *(swapArray + with_pos);\n\t*(swapArray + with_pos) = *(swapArray + zero_pos);\n\t*(swapArray + zero_pos) = temp;\n\n\tnewState = toState(swapArray);\n\n\treturn newState;\n}\n\nint getNext(long long* states, node_t* current) {\n\tint count = 0;\n\n\tint current_state = T[current->hash];\n\n\tint zero_pos = getZeroPos(current_state);\n\tint row = zero_pos / n;\n\tint col = zero_pos % n;\n\n\tif (row != 0) {\t//swap with above\n\t\tint newState = swap(current_state, zero_pos, zero_pos - 3);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (row != 2) {\t//swap with below\n\t\tint newState = swap(current_state, zero_pos, zero_pos + 3);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (col != 0) {\t//swap with left\n\t\tint newState = swap(current_state, zero_pos, zero_pos - 1);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (col != 2) {\t//swap with right\n\t\tint newState = swap(current_state, zero_pos, zero_pos + 1);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid getPath(node_t* from) {\n\tint distance = 0;\n\tnode_t* cur = from;\n\twhile (cur->parent != NULL) {\n\t\tcur = cur->parent;\n\t\tdistance++;\n\t}\n\tprintf(\"%d\\n\", distance);\n\texit(0);\n}\n\nvoid bfs(node_t* start) {\n\tenqueue(start);\n\n\twhile (!isEmpty()) {\n\t\tnode_t* init = dequeue();\n\t\tlong long states[4];\n\t\tint length = getNext(&states, init);\n\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tnode_t* cur = states[i];\n\t\t\tif (T[cur->hash] == target)\tgetPath(cur);\n\t\t\tenqueue(cur);\n\t\t}\n\t}\n}\n\n\nint isEmpty() {\n\tif (qt == qh) return 1;\n\treturn 0;\n}\n\nvoid enqueue(node_t* x) {\n\tqueue[qt] = x;\n\tif (qt + 1 == qLength) qt = 0;\n\telse qt++;\n}\n\nnode_t* dequeue() {\n\tnode_t* x = queue[qh];\n\tif (qh + 1 == qLength) qh = 0;\n\telse qh++;\n\treturn x;\n}\n\n\nint hashInsert(int k) {\n\tint i = 0;\n\twhile (1) {\n\t\tint hashKey = hash(k, i);\n\t\tif (T[hashKey] == 0) {\n\t\t\tT[hashKey] = k;\n\t\t\treturn hashKey;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nint hashSearch(int k) {\n\tint i = 0;\n\twhile (1) {\n\t\tint hashKey = hash(k, i);\n\t\tif (T[hashKey] == k) return hashKey;\n\t\tif (T[hashKey] == 0) return -1;\n\t\tif (i >= max) exit(10);\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nint hash(int k, int i) {\n\tint hash1 = k % 199999;\n\tint hash2 = 1 + k % 199967;\n\tint ans = ((hash1 + i * hash2) % 199999);\n\tif (ans < 0) ans *= -1;\n\treturn ans;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 5) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 876543\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;//\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/1000;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint Pz[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!Pz[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = Pz[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&Pz[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=Pz[i][j];\n      }\n    }\n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tPz[i][j]=tmp[i][j];\n      }\n    }\n\n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  break;\n\t}\n      }\n      if (board[r][c] == i) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 3\n \nint p[N][N];\nint temp[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nint dfs(int, int, int, int, int);\nint calc();\nvoid swap(int *,int *);\n \nint main()\n{\n  int i, j;\n  int x, y;\n  int n, count = 0;\n\n  for(i = 0; i < N; i++)\n    {\n      for(j = 0; j < N; j++)\n\t{\n\t  scanf(\"%d\",&p[i][j]);\n\t  if(p[i][j] == 0)\n\t    {\n\t      x = j;\n\t      y = i;\n\t    }\n\t}\n    }\n  \n  while(1)\n    {\n      for(i = 0; i < N; i++)\n\t{\n\tfor(j = 0; j < N; j++)\n\t  {\n\t  temp[i][j] = p[i][j];\n\t  }\n\t}\n      \n      n = dfs(x, y, -1, 0, count);\n      \n      if(n != -1)\n\t{\n\t  printf(\"%d\\n\", n);\n\t  break;\n\t}\n      \n      for(i = 0; i < N; i++)\n\t{\n\t  for(j = 0; j < N; j++)\n\t    {\n\t      p[i][j] = temp[i][j];\n\t    }\n\t}\n      \n      n = -1;\n      \n      if(count++ == 99)\n\t{\n\t  printf(\"%d\\n\", n);\n\t  break;\n\t}\n    }\n  \n    return 0;\n}\n\n\nint dfs(int x, int y, int key, int dep, int lim)\n{\n  int i;\n  int nx, ny;\n  int h, ans;\n  \n  h = calc();\n  \n  if(h == 0)return dep;\n  if(dep + h > lim)return -1;\n  \n  for(i = 0; i < 4; i++)\n    {\n      nx = x + dx[i];\n      ny = y + dy[i];\n\n      if(0 > nx || nx >= N || 0 > ny || ny >= N)continue;\n      if(key > 0 && i == (key+2) % 4)continue;\n   \n      swap(&p[y][x], &p[ny][nx]);\n      \n      ans = dfs(nx, ny, i, dep+1, lim);\n      \n      if(ans != 0 && ans != -1)return ans;\n      \n      swap(&p[y][x], &p[ny][nx]);\n    }\n  \n  return -1;\n}\n\nint calc()\n{\n  int i;\n  int n, sum = 0;\n  \n  for(i = 0; i < 9; i++)\n      {\n        n = p[i/N][i%N];\n\t\n        if(n != 0)\n\t  {\n            n--;\n            sum += abs(i/N - n/N) + abs(i%N - n%N);\n\t  }\n    }\n  \n  return sum;\n}\n\nvoid swap(int *a, int *b)\n{\n  int cpy;\n  \n  cpy = *a;\n  *a = *b;\n  *b = cpy;\n\n  return;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, current;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n\nint main()\n{\n\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 15\ntypedef struct{\n    int A[N][N];\n}Pazzle;\nPazzle P;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n int hoge;\n hoge=*A;\n *A=*B;\n *B=hoge;\n\n\n}\n\nint check(Pazzle P){\n    int sum=0,i,j,hy,hx;\n    for(i=0;i<N;i++){\n\n    for(j=0;j<N;j++){\n        if(P.A[i][j]==0)\n        continue;\n        hy=(P.A[i][j]-1)/N-i;\n        hx=(P.A[i][j]-1)%N-j;\n        if(hy<0)\n        sum-=hy;\n        else\n        sum+=hy;\n        if(hx<0)\n        sum-=hx;\n        else\n        sum+=hx;\n\n\n}\n}\n\nreturn sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int m){\n         int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;\n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1;\n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];\n\n    if((m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N)) continue;\n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,i);\n    if(ans!=-1) return ans;\n     swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }\n  return -1;\n}\n\nint main(void){\n    Pazzle t_P;\n    int  i,j,ans;\n    int x0,y0;\n\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&P.A[i][j]);\n            if(P.A[i][j]==0){\n                x0=j;\n                y0=i;\n\n            }\n\n        }\n    }\n    t_P=P;\n    for(i=1;i<46;i++){\n        P=t_P;\n    ans=dfs(x0,y0,i,0,-1);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#define N 3\n#define N2 9\n#define LEN 10000000\n\ntypedef struct Puzzle{\n  int f[N2];\n  int space;\n  int path;\n} Puzzle ;\n\nint V[LEN];\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n//static const char dir[4]={'u','l','d','r'};\n\nstruct Puzzle Q[LEN];\nint head = 0, tail = 0;\n\nvoid enqueue(Puzzle x){\n   Q[tail]=x;\n   tail=(tail+1)%LEN;\n}\n\nPuzzle dequeue(){\n  Puzzle x=Q[head];\n  head=(head+1)%LEN;\n  return x;\n}\n\nint chim(Puzzle p){\n  int i, j,muri, count,n=0;\n  for(i=0,muri=1;i<N2;muri*=++i){\n    for(j=0,count=0;j<i;j++){\n      if(p.f[j]<p.f[i])count++;\n    }\n    n+=count*muri;\n  }\n  return n;\n}\n\nint isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n  \tif(p.f[i] != (i+1)) return 0;\n  }\n  return 1;\n}\n\nint bfs(Puzzle spc){\n  struct Puzzle u,v;\n  spc.path=0;\n  enqueue(spc);\n  V[chim(spc)]=1;\n  \n  while(head != tail){ \n  int sx,sy,tx,ty,z,r;\n    u=dequeue();\n    if(isTarget(u)){\n        return u.path;\n    }\n     sx=u.space/N;\n     sy=u.space%N;\n    for(r=0;r<4;r++){\n       tx=sx+dx[r];\n       ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>= N)continue;\n      v=u;\n      z=v.f[u.space];\n      v.f[u.space]=v.f[tx*N+ty];\n      v.f[tx*N+ty]=z;\n      v.space=tx*N+ty;\n      if(V[chim(v)] != 1){\n\tV[chim(v)] = 1;\n\tv.path++;//=dir[r];\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  Puzzle in;\n  \n  for(int i = 0; i < N2; i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\nint answer;\nanswer = bfs(in);\nprintf(\"%d\\n\",answer );\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 102400\n#define Hash_size 1024\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/* \n * File:   main.c\n * Author: kundaikwangwari\n *\n * Created on August 1, 2019, 9:38 AM\n */\n\n\n#include <stdio.h>\n#define N 3\n#define MAX 8\n#define NIL -1\n\n\ntypedef struct{\n    int Board[N][N];\n}Data;\n\n\n\nint xdistance[4]={0,1,0,-1};\nint ydistance[4]={1,0,-1,0};\n\nint IsValid(Data Puzzle){\n    \n    int sum=0,ytransitions,xtransitions;\n    for(int i=0;i<N;i++){\n \n    for(int j=0;j<N;j++){\n        if(Puzzle.Board[i][j]==0)continue;\n        ytransitions=(Puzzle.Board[i][j]-1)/N-i;\n        xtransitions=(Puzzle.Board[i][j]-1)%N-j;\n        if(ytransitions<0) sum-=ytransitions;\n        else sum+=ytransitions;\n        if(xtransitions<0) sum-=xtransitions;\n        else sum+=xtransitions;\n}\n}\n \nreturn sum;\n}\n\n\nvoid SwapPositions(int *A,int *B){\n int temp;\n temp=*A;\n *A=*B;\n *B=temp;\n \n \n}\n\n\nint DepthFirstSearch(int x,int y,int max,int count,Data Puzzle){\n    \n  int heuristic = IsValid(Puzzle), xtotal,ytotal, Sol=NIL;   \n  if(heuristic==0) return count;\n  if(count+heuristic>max) return NIL; \n  for(int i=0;i<4;i++){\n    xtotal=x+xdistance[i];\n    ytotal=y+ydistance[i];      \n   \n    if(!(0<=xtotal && xtotal<3 && 0<=ytotal && ytotal<3)) continue;\n    \n    SwapPositions(&Puzzle.Board[y][x],&Puzzle.Board[ytotal][xtotal]);\n    Sol=DepthFirstSearch(xtotal,ytotal,max,count+1,Puzzle);\n    if(Sol!= NIL) return Sol;  \n    \n     SwapPositions(&Puzzle.Board[y][x],&Puzzle.Board[ytotal][xtotal]);\n  }   \n  return NIL;\n}\n\n\n\n\nint main(void){\n    Data Puzzle,tempPuzzle;\n    int xstart,ystart;\n\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            scanf(\"%d\",&Puzzle.Board[i][j]);\n            if(Puzzle.Board[i][j]==0){\n                xstart=j;\n                ystart=i;   \n            }\n        }\n    }\n    tempPuzzle=Puzzle;\n    for(int i=1;i<100;i++){\n        Puzzle=tempPuzzle;\n    int Sol=DepthFirstSearch(xstart,ystart,i,0,Puzzle);\n    if(Sol!=NIL){\n        printf(\"%d\\n\",Sol);\n        break;\n    }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define D 100\n\nstruct node{\n  int data[N][N];\n  struct node *p;\n};\nstruct xy{\n  int x;\n  int y;\n};\n\nstruct node root;\nint mv[4][2]={0,1,0,-1,-1,0,1,0};\n\nint man(int n,int x,int y){\n  int nx, ny;\n\n  nx=(n-1)%N;\n  ny=(n-1)/N;\n  x=x-nx;\n  if(x<0)\n   x*=-1;\n y=y-ny;\n if(y<0)\n   y*=-1;\n return x+y;\n}\n\nint judge(struct node *n){\n  int i, j=0;\n  if(n==NULL)\n   return -1;\n for(i=0;i<N*N;i++){\n  if(n->data[i%N][i/N]==0)\n   continue;\n if(n->data[i%N][i/N]!=i+1) \n  j+=man(n->data[i%N][i/N],i%N,i/N);\n}\n\nreturn j;\n}\n\nstruct xy blank(struct node *n){\n  struct xy ddd;\n  int i;\n\n  for(i=0;i<N*N;i++)\n    if(n->data[i%N][i/N]==0)\n     break;\n\n   ddd.x=i%N;\n   ddd.y=i/N;\n\n   return ddd;\n }\n\nstruct node *mk(struct node *n,struct xy b, struct xy m){\n  struct node *aaa;\n  int i;\n  \n  aaa=malloc(sizeof(struct node));\n\n  for(i=0;i<N*N;i++) \n    aaa->data[i%N][i/N]=n->data[i%N][i/N];\n  \n  aaa->data[b.x][b.y]=aaa->data[m.x][m.y];\n  aaa->data[m.x][m.y]=0;\n  aaa->p=n;\n  return aaa;\n}\n\nint puzzle(struct node *n,struct node *bp, int g,int d){\n  int h=judge(n), i, j;\n  struct xy bl, m;\n  struct node *mm;\n  \n  if(h==0)\n   return g;\n if(g+h>d) \n  return -1;\nbl=blank(n);\nfor(i=0;i<4;i++){\n  m.x=bl.x+mv[i][0];\n  m.y=bl.y+mv[i][1];\n  if(m.x<0 || m.y<0 || m.x==N || m.y==N ) \n    continue;\n  mm=mk(n,bl,m);\n  if(bp!=NULL){\n    for(j=0;j<N*N;j++)\n      if(mm->data[j%N][j/N]!=bp->data[j%N][j/N])\n       break;\n     if(j==N*N){\n      free(mm);\n      continue;\n    }\n  }  \n  j=puzzle(mm,mm->p,g+1,d);\n  if(j>0) return j;\n}\nreturn -1;\n}\n\nint main(){\n  int i, ans;\n  struct node *n, *m;\n  for(i=0;i<N*N;i++)\n   scanf(\"%d\",&root.data[i%N][i/N]);\n root.p=NULL;\n for(i=judge(&root);i<=D;i++){\n  ans=puzzle(&root,NULL,0,i);\n  if(ans>0) break;\n}\nprintf(\"%d\\n\",ans);\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n   \nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\n  \nint dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,nx,ny,res;   \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1; \n    for(i=0; i<4; i++){\n        nx = x+dx[i];\n        ny = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;       \n        swap(&puz[y][x],&puz[ny][nx]);\n    }   \n    return -1;\n}  \n  \nint main() {\n    int i,j,ans,x,y,l;\n      \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n       \n    empty(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n          \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n          \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n          \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n      \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}   \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;   \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1; \n  for(i=0; i<4; i++){\n    nx = x+dx[i];\n    ny = y+dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;       \n    swap(&puz[y][x],&puz[ny][nx]);\n  }   \n  return -1;\n}    \nint main() {\n  int i,j,ans,x,y,l;\n       \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n  }\n        \n  empty(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n    }\n           \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n           \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n    }\n           \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n       \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0; i<4; i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n  }\n  \n  empty(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n    }\n    \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n    }\n    \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *x,int *y)\n{\n  int i,j;\n  for(i=0; i<3; i++)\n    {\n      for(j=0; j<3; j++)\n\t{\n\t  if(!puz[i][j])\n\t    {\n\t      *x = j;\n\t      *y = i;\n\t      return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b)\n{\n  int tmp;\n     \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n \n \nint cal()\n{\n  int i,a,sum=0;\n     \n  for(i=0; i<9; i++)\n    {\n      a = puz[i/3][i%3];\n      if(a)\n\t{\n\t  a--;\n\t  sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n     \n  return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim)\n{\n  int i,h,nx,ny,res;\n     \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n     \n  for(i=0; i<4; i++)\n    {\n      nx = x+dx[i];\n      ny = y+dy[i];\n         \n      if(~p && i==(p+2)%4) continue;\n      if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n      swap(&puz[y][x],&puz[ny][nx]);\n      res = dfs(nx,ny,i,dep+1,lim);\n      if(~res) return res;\n         \n      swap(&puz[y][x],&puz[ny][nx]);\n    }\n    \n  return -1;\n}\n\n\n \nint main() {\n  int i,j; // roop\n  int ans,x,y,l;\n     \n  for(i=0; i<3; i++)\n    {\n      for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n     \n     \n    empty(&x,&y);\n    for(l=0; l<100; l++)\n      {\n        for(i=0; i<3; i++)\n\t  {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n\t  }\n        \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1)\n\t  {\n            printf(\"%d\\n\",ans);\n            break;\n\t  }\n        \n        for(i=0; i<3; i++)\n\t  {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n\t  }\n         \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n      }\n     \n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \nint m[3][3];\nint cpy[3][3];\n \nvoid input(void){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&m[i][j]);\n    }\n  }\n}\nvoid output(void){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      printf(\"%3d\",m[i][j]);\n      puts(\"\");\n    }\n }\n}\nvoid copy(int a[3][3],int b[3][3]){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      a[i][j] = b[i][j];\n    }\n }\n}\nint calc(void){\n  int i,sum = 0;\n  for(i=0;i<9;i++){\n    int a = m[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)+abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n \nvoid swap(int *a, int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\nint in(int a,int b){\n  return 0<=a&&a<3&&0<=b&&b<3;\n}\nint df(int a,int b,int p,int d,const int lim){\n  int i , h=calc();\n  if(h == 0)return d;\n  if(d+h > lim)return -1;\n \n  for(i=0;i<4;i++){\n    int x= a+dx[i],y=b+dy[i];\n    int res;\n    if(~p && i == (p+2)%4)continue;\n    if(!in(x,y))continue;\n    swap(&m[b][a],&m[y][x]);\n    res = df(x,y,i,d+1,lim);\n    if(~res)return res;\n    swap(&m[b][a],&m[y][x]);\n  }\n  return -1;\n}\n \nvoid empty(int *a, int *b){\n  int i,j;\n   for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!m[i][j]){\n    *a = j;\n    *b = i;\n    return;\n      }\n    }\n   }\n}\nint s(void){\n  int a,b,lim,x;\n  empty(&a,&b);\n  for(lim = 0;lim < 50;lim++){\n    copy(cpy,m);\n    if((x = df(a,b,-1,0,lim)) != -1)return x;\n    copy(m,cpy);\n  }\n  return -1;\n}\nint main(){\n  input();\n  printf(\"%d\\n\",s());\n \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n\n\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mykey *key) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    struct mynode *new_data = malloc(sizeof(struct mynode));\n    new_data->key = *key;\n\n    rb_link_node(&new_data->node, parent, new);\n    rb_insert(&new_data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n\n// Queue\n#define QueueKey struct mykey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, &s);\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        struct mykey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            my_insert(&mytree, &next_key);\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 1024\n#define Hash_size 1024\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\n \nint main() {\n  int i,j,ans,x,y,l;\n       \n  for(i=0; i<3; i++) for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n\n        \n  empty(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n    }\n           \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n           \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n    }\n           \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n       \n  return 0;\n}\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}   \n\nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;   \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1; \n  for(i=0; i<4; i++){\n    nx = x+dx[i];\n    ny = y+dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;       \n    swap(&puz[y][x],&puz[ny][nx]);\n  }   \n  return -1;\n}   \n  \n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n  #include <stdlib.h>\n  int puzle[3][3];\n  int tmp[3][3];\n  int d1[4]={0,1,0,-1};\n  int d2[4]={1,0,-1,0};\n\n  void empty(int *x,int *y){\n    int i,j;\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        if(!puzle[i][j]){\n  \t*x=j;\n  \t*y=i;\n  \treturn;\n        }\n      }\n    }\n  }\n\n  void swap(int *a,int *b){\n    int tmp=*a;\n    *a=*b;\n    *b=tmp;\n  }\n\n  int cal(){\n    int a,i,sum=0;\n    for(i=0;i<9;i++){\n      a=puzle[i/3][i%3];\n      if(a){\n        a--;\n        sum += abs(i/3-a/3) + abs(i%3-a%3);\n      }\n    }\n    return sum;\n  }\n\n  int dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,n1,n2,res;\n    h=cal();\n    if(h==0){\n      return dep;\n    }\n    if(dep+h > lim){\n      return -1;\n    }\n    for(i=0;i<4;++i){\n      n1=x+d1[i];\n      n2=y+d2[i];\n\n      if(~p && i==(p+2)%4)\n        continue;\n      if(!(0 <= n1 && n1 < 3 && 0 <= n2 && n2 < 3))\n        continue;\n      swap(&puzle[y][x],&puzle[n2][n1]);\n      res=dfs(n1,n2,i,dep+1,lim);\n\n      if(~res){\n        return res;\n      }\n      swap(&puzle[y][x],&puzle[n2][n1]);\n    }\n    return -1;\n  }\n\n  int main(){\n    int ans,x,y,l,i,j;\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        scanf(\"%d\",&puzle[i][j]);\n      }\n    }\n    empty(&x,&y);\n    for(l=0;l<100;l++){\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n  \ttmp[i][j]=puzle[i][j];\n      }\n    }\n      ans=dfs(x,y,-1,0,l);\n      if(ans!=-1){\n        printf(\"%d\\n\",ans);\n        break;\n      }\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n  \tpuzle[i][j]=tmp[i][j];\n      }\n      }\n      ans=-1;\n      if(l==99){\n        printf(\"%d\\n\",ans);\n    }\n    }\n    return 0;\n  }\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n#define MAX 182000\n#define MEMO_MAX 380000000\n#define MIN 54481005 //ããºã«ã9é²æ°ã«ç½®æããæã®æå°\n#define TRUE 1\n#define FALSE -1\n\ntypedef struct{\n  int p[N][N]; //ããºã«ã®ç¶æãä¿å­\n  int dis; //ææ°\n  int u, d, l, r; //ãã§ã«é·ç§»ããæ¹åãè¡¨ããã©ã°\n}puzzle;\n\nint BFS(void);\nvoid copy(int a[N][N], int b[N][N]);\nvoid swap(int *, int *);\nint judge(int a[N][N]);\nvoid enqueue(puzzle);\npuzzle dequeue(void);\nvoid print(puzzle);\n\nint head = 0;\nint tail = 0;\nint ans[N][N] = {{1, 2, 3},\n\t\t {4, 5, 6},\n\t\t {7, 8, 0}}; //å®æå½¢ \npuzzle q[MAX]; //ã­ã¥ã¼\npuzzle s; //u, d, l, r, disã¯ãã®æç¹ã§åæåããã¦ã\nchar memo[MEMO_MAX] = {}; //çæããç¤é¢ãä¿å­ãã¦ãã\n\nint main(){\n  int i, j;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\", &s.p[i][j]);\n    }\n  }\n\n  BFS();\n  \n  return 0;\n}\n\nint BFS(){\n  puzzle v;\n  int cnt; //å®æå½¢ã¨ä¸è´ãã¦ããæ°å­ã®æ°\n  int i0, j0; //ç©ºç½ã®ä½ç½®\n  int i, j;\n\n  enqueue(s);\n\n  while(1){\n    \n    v = dequeue();\n    //sã®åæå\n    s.u = s.d = s.l = s.r = 0;\n    s.dis = 0;\n\n    //ããºã«ãå®æãããçµäº\n    cnt = 0;\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tif(v.p[i][j] == ans[i][j]) cnt++;\n      }\n    }\n    if(cnt == N * N){\n      printf(\"%d\\n\", v.dis);\n      return 0;\n    }\n\n    //ç©ºç½ã®ä½ç½®ãç¹å®\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tif(v.p[i][j] == 0){\n\t  i0 = i;\n\t  j0 = j;\n\t}\n      }\n    }\n\n    //ä¸\n      if(i0 != 0 && v.u == 0){\n\tcopy(s.p, v.p); //vã®ããºã«ã®ç¶æãã³ãã¼ãã\n\tswap(&(s.p[i0][j0]), &(s.p[i0-1][j0]));\n\tif(judge(s.p) == TRUE){\n\t  s.d = 1; //ä¸ã«è¡ããªãããã«ãã(ç¡é§ã«å¾å¾©ããªãããã«)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n      //ä¸\n      if(i0 != N-1 && v.d == 0){\n\tcopy(s.p, v.p); //vã®ããºã«ã®ç¶æãã³ãã¼ãã\n\tswap(&(s.p[i0][j0]), &(s.p[i0+1][j0]));\n\tif(judge(s.p) == TRUE){\n\t  s.u = 1; //ä¸ã«è¡ããªãããã«ãã(ç¡é§ã«å¾å¾©ããªãããã«)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n      //å³\n      if(j0 != N-1 && v.l == 0){\n\tcopy(s.p, v.p); //vã®ããºã«ã®ç¶æãã³ãã¼ãã\n\tswap(&(s.p[i0][j0]), &(s.p[i0][j0+1]));\n\tif(judge(s.p) == TRUE){\n\t  s.r = 1; //å·¦ã«è¡ããªãããã«ãã(ç¡é§ã«å¾å¾©ããªãããã«)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n      //å·¦\n      if(j0 != 0 && v.r == 0){\n\tcopy(s.p, v.p); //vã®ããºã«ã®ç¶æãã³ãã¼ãã\n\tswap(&(s.p[i0][j0]), &(s.p[i0][j0-1]));\n\tif(judge(s.p) == TRUE){\n\t  s.l = 1; //å³ã«è¡ããªãããã«ãã(ç¡é§ã«å¾å¾©ããªãããã«)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n    \n  }\n\n};\n\nvoid copy(int a[N][N], int b[N][N]){\n  int i, j;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      a[i][j] = b[i][j];\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int v;\n  v = *a;\n  *a = *b;\n  *b = v;\n}\n\nint judge(int a[N][N]){\n  long long key = 0; //ããã·ã¥\n  int x, y = 1;\n  int i, j;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      x = a[i][j] + 1;\n      key += x * y;\n      y *= 9;\n    }\n  }\n\n  key -= MIN;\n  \n  //\\0ã¯free, nã¯notfree\n  if(memo[key] == '\\0'){\n    memo[key] = 'n';\n    return TRUE;\n  }\n  else return FALSE;\n}\n\nvoid enqueue(puzzle x){\n  q[tail] = x;\n  if(tail == MAX-1) tail = 0;\n  else tail++;\n}\n\npuzzle dequeue(void){\n  puzzle x;\n  x = q[head];\n  if(head == MAX-1) head = 0;\n  else head++;\n  return x;\n}\n\nvoid print(puzzle s){\n  int i, j;\n  static int x = 1;\n  printf(\"%d\\n\", x);\n  x++;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      printf(\"%d \", s.p[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n// Node\ntypedef struct NodeKey {\n    int board[9];\n    int space;\n    int cnt;\n} NodeKey;\n// lt: -1, gt: 1, eq: 0\nint cmp_node(const NodeKey *l, const NodeKey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        else if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\n\n// Treap\ntypedef struct Node {\n    NodeKey key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, const NodeKey key, const int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(cmp_node(&key, &root->key) == 0) return root;\n    if(cmp_node(&key, &root->key) == -1) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, const NodeKey key, const int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(Node *root, const NodeKey key) {\n    while(root != NULL && cmp_node(&key, &root->key)) {\n        if(cmp_node(&key, &root->key) == -1) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\n\n\n// Queue\n#define QueueKey NodeKey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\n// solve\nint bfs(NodeKey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    BST BST;\n    bst_init(&BST);\n    bst_insert(&BST, s, rand());\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        NodeKey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            NodeKey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(bst_find(BST.root, next_key)) continue;\n\n            next_key.cnt++;\n            bst_insert(&BST, next_key, rand());\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    NodeKey initial;\n    initial.cnt = 0;\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n#define LEN 362880\nint head = 0, tail = 0;\nint que[LEN];\n\nint start[9]; //åæç¶æ\t\nint goal = 46233;\t//æçµç¶æ\nint search[362880] = { 0 };\t//æ¢ç´¢æ¸ã¿\nint board[362880][9];\t//ç¤é¢ã®ç¶æ\nint d[362880];\t//æé\nint oya; //è¦ªã®ãã³ãã¼\nint dummy[9];\t//ç¤é¢ã³ãã¼ç¨\nint p0[362880];\t//0ã®ä½ç½®ãè¨æ¶\n\n/*ç¤é¢ã®é£æ¥ãªã¹ã*/\nint next[9][5] = { {2, 1, 3},\n\t\t\t\t   {3, 0, 2, 4},\n                   {2, 1, 5},\n\t\t\t\t   {3, 0, 4, 6},\n                   {4, 1, 3, 5, 7},\n\t\t\t\t   {3, 2, 4, 8},\n                   {2, 3, 7},\n                   {3, 4, 6, 8},\n\t\t\t\t   {2, 5, 7}\n};\n\n/*ã­ã¥ã¼ã®å®è£*/\nint isempty() {\n\treturn head == tail;\n}\n\nvoid enqueue(int x) {\n\tque[tail] = x;\n\tif ((tail + 1) == LEN)\n\t\ttail = 0;\n\telse\n\t\ttail++;\n}\n\nint dequeue() {\n\tint x;\n\tx = que[head];\n\tif ((head + 1) == LEN)\n\t\thead = 0;\n\telse\n\t\thead++;\n\treturn x;\n}\n\n/*0ã®ãã¹ãæ¢ç´¢*/\nint a_mas0(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*ç¤é¢ãã³ãã¼*/\nvoid board_copy(int a[], int b[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tb[i] = a[i];\n}\n\n/*éä¹ãè¨ç®*/\nint n_factorial(int n) {\n\tif (n == 1)\n\t\treturn 1;\n\treturn n * n_factorial(n - 1);\n}\n\n/*ç¤é¢è¨æ¶ã®ããã«ä½¿ç¨*/\nvoid a_location(int a[], int s) {\n\tfor (int i = s + 1; i < 9; i++)\n\t\tif (a[s] < a[i])\n\t\t\ta[i]--;\n}\n\n/*ç¤é¢ã®ç¶æãæ°å¤ã«å¤æ*/\nint assign_number(int a[]) {\n\tint b[9];\n\tint num = 0;\n\tint pos = 8;\n\tboard_copy(a, b);\n\tfor (int i = 8; i > 0; i--) {\n\t\tnum = num + b[8 - i] * n_factorial(i);\n\t\ta_location(b, 8 - i);\n\t\tif (a[8 - i] == 0)\n\t\t\tpos = 8 - i;\n\t}\n\tp0[num] = pos;\n\treturn num;\n}\n\n/*ãã¹ã®ç§»å*/\nvoid move(int *a, int *b) {\n\tint box;\n\tbox = *a;\n\t*a = *b;\n\t*b = box;\n}\n\n/*ç¤é¢ã®è¡¨ç¤º*/\nvoid puzzle_print(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tprintf(\"%d \", a[i]);\n\tprintf(\"\\n\");\n}\n\n/*0ã®ä½ç½®ãæ¢ç´¢*/\nint zero_position(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*å¹åªåæ¢ç´¢*/\nint bsf() {\n\tint num;\n\tint pos;\n\twhile (isempty() != 1) {\n\t\toya = dequeue();\n\t\tpos = p0[oya];\n\t\tfor (int i = 1; i <= next[pos][0]; i++) {\n\t\t\tboard_copy(board[oya], dummy);\t//oyaã®ç¤é¢ãdummyã«ã³ãã¼\n\t\t\tmove(&dummy[pos], &dummy[next[pos][i]]);\t//dummyã®ç¤é¢ãç§»å\n\t\t\tnum = assign_number(dummy);\t//ç§»åããç¤é¢ãæ°å¤ã«å¤æ\n\t\t\tif (num == goal){\t//æçµç¶æãçºè¦\n\t\t\t\td[num] = d[oya] + 1;\t\n\t\t\t\tsearch[num] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (search[num] != 1) {\t//æçµç¶æã§ãªã\n\t\t\t\tsearch[num] = 1;\n\t\t\t\tboard_copy(dummy, board[num]);\n\t\t\t\td[num] = d[oya] + 1;\n\t\t\t\tenqueue(num);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i = 0;\n\tint num;\n\t\n\t/*åæç¶æã®è¨­å®*/\n\tfor (i = 0; i < 9; i++)\n\t\tscanf(\"%d\", &start[i]);\n\tnum = assign_number(start);\t//åæç¶æã®æ°å¤\n\tboard_copy(start, board[num]);\t//åæç¶æã®ç¤é¢ãè¨æ¶\n\tsearch[num] = 1;\t//åæç¶æã®æ°å¤ãè¨æ¶(1ããã¦ã)\n\td[num] = 0;\t//åæç¶æã®æéã0ã«è¨­å®\n\tenqueue(num); //åæç¶æã®æ°å¤ãã­ã¥ã¼ã«æ ¼ç´\n\t\n\t/*æ¢ç´¢éå§*/\n\tif (num == goal)\n\t\tprintf(\"0\\n\");\n\telse if (bsf() == 1)\n\t\tprintf(\"%d\\n\", d[goal]);\n\telse\n\t\tprintf(\"ãªã\\n\"); \n\t\n\t\n\twhile (1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n \n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define N 3\n \nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n \nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n \n  if (min == 0) return 0;\n \n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n    board[r_0-1][c_0] = num;\n    board[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n \n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n    board[r_0+1][c_0] = num;\n    board[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n \n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n    board[r_0][c_0-1] = num;\n    board[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n \n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n \n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0, found;\n  int res;\n \n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n \n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n    if (board[r][c] == i) {\n      if (i == 0) {\n        r_0 = r;\n        c_0 = c;\n      } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n      found = 1;\n      break;\n    }\n      }\n      if (found == 1) break;\n    }\n  }\n \n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n \n    if (res != -1) break;\n  }\n \n  printf(\"%d\\n\", res);\n \n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define Q_MAX 362880\n#define N 3\n#define N2 9\n\ntypedef struct puzzle\n{\n\tint board[N2];\n\tint space;\n\tint path;\n} Puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nPuzzle Q[Q_MAX];\nint head, tail, V[Q_MAX];\n\nint empty();\nvoid enq(Puzzle);\nPuzzle front();\nint check(Puzzle);\nint isTarget(Puzzle);\nint BFS(Puzzle);\nvoid swap(int *, int *);\n\nint main()\n{\n\tint i, ans;\n\tPuzzle p;\n\n\tfor (i = 0; i < N2; i++)\n\t{\n\t\tscanf(\"%d\", &p.board[i]);\n\t\tif (p.board[i] == 0)\n\t\t{\n\t\t\tp.board[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\n\tans = BFS(p);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\nint empty()\n{\n\treturn head == tail;\n}\n\nvoid enq(Puzzle p)\n{\n\tQ[tail] = p;\n\ttail = (tail + 1) % Q_MAX;\n}\n\nPuzzle front()\n{\n\tPuzzle p;\n\n\tp = Q[head];\n\thead = (head + 1) % Q_MAX;\n\treturn p;\n}\n\nint check(Puzzle p)\n{\n\tint i, j, f, count, res = 0;\n\n\tfor (i = 0, f = 1; i < N2; f *= ++i)\n\t{\n\t\tfor (j = 0, count = 0; j < i; j++)\n\t\t{\n\t\t\tif (p.board[j] < p.board[i])\n\t\t\t\tcount++;\n\t\t}\n\t\tres += count * f;\n\t}\n\treturn res;\n}\n\nint isTarget(Puzzle p)\n{\n\tint i;\n\n\tfor (i = 0; i < N2; i++)\n\t{\n\t\tif (p.board[i] != (i + 1))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint BFS(Puzzle q)\n{\n\tint sx, sy, tx, ty, r, tmp;\n\tint i;\n\tPuzzle u, v;\n\n\tq.path = 0;\n\tenq(q);\n\tV[check(q)] = 1;\n\twhile (!empty())\n\t{\n\t\tu = front();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\tfor (r = 0; r < 4; r++)\n\t\t{\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\ttmp = v.board[u.space];\n\t\t\tv.board[u.space] = v.board[tx * N + ty];\n\t\t\tv.board[tx * N + ty] = tmp;\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[check(v)])\n\t\t\t{\n\t\t\t\tV[check(v)] = 1;\n\t\t\t\tv.path++;\n\t\t\t\tenq(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n  \n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \n \nint main() {\n    int i,j,ans,x,y,l;\n     \n    //puzzle input\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n     \n     \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n         \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n         \n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n         \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n     \n    //ans output\n    //printf(\"%d\\n\",ans);\n     \n    return 0;\n}\n \n \nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b) {\n    int tmp;\n     \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \n \nint cal() {\n    int i,a,sum=0;\n     \n    for(i=0; i<9; i++) {\n        a = puz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n     \n    return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n     \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n     \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n         \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n         \n        swap(&puz[y][x],&puz[ny][nx]);\n    }\n     \n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n \n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n \n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    } \n    return 0;\n}\n \nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n \nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n  \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n  \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n  \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n \n    return -1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n \nusing namespace std;\n \n#define N 3\n#define N2 9\n \nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n     \n    bool operator < (const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n \nstatic const int dx[4]={-1,0,1,0};\n \nstatic const int dy[4]={0,-1,0,1};\n \nstatic const char dir[4]={'u','a','d','r'};\n \nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n    return true;\n}\n \n \nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n     \n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n     \n    return \"unsolvable\";\n}\n \n \nint main(){\n    Puzzle in;\n     \n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n     \n    string ans = bfs(in);\n     \n    cout<<ans.size()<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 362880\n#define FALSE 0\n#define TRUE 1\n\ntypedef struct {\n  int num[9];\n  int space;\n  int moves;\n} PUZZLE;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint V[MAX];\n\nPUZZLE Q[MAX];\nint head,tail;\n\nint emp(){\n  if(head == tail) return TRUE;\n  return FALSE;\n}\n\nvoid push(PUZZLE p){\n  Q[tail] = p;\n  tail = (tail+1)%MAX; //Ring Buffer\n}\n\nPUZZLE pop(){\n  PUZZLE p;\n  p = Q[head];\n  head = (head+1)%MAX;\n  return p;\n}\n\nvoid swap(int *x,int *y){\n  int tmp;\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\nint count(PUZZLE p){\n  int i, j, fac, cnt, result = 0;\n  for(i = 0, fac = 1; i < 9; fac*= ++i){\n    for(j = 0, cnt = 0; j < i; j++){\n      if(p.num[j] < p.num[i]) cnt++;\n    }\n    result += cnt*fac;\n  }\n  \n  return result;\n}\n  \n\nint check_goal(PUZZLE p){\n  int i;\n  for(i  = 0; i < 9; i++){\n    if(p.num[i] != (i + 1)) return FALSE;\n  }\n  return TRUE;\n}\n\nint BFS(PUZZLE s){\n  int sx,sy,tx,ty,r;\n  PUZZLE u,v;\n\n  s.moves = 0;\n\n  push(s);\n\n  V[count(s)] = 1;\n\n  while(emp() != TRUE){\n    u = pop();\n    if(check_goal(u) == TRUE) return u.moves;\n    sx = u.space/N;\n    sy = u.space%N;\n\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n\n      swap(&v.num[u.space], &v.num[tx*N + ty]);\n      v.space = tx*N + ty;\n\n      if(V[count(v)] != TRUE){\n\tV[count(v)] = 1;\n\tv.moves++;\n\tpush(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  int i;\n  PUZZLE in;\n\n  for(i = 0; i < 9; i++){\n    scanf(\"%d\",&in.num[i]);\n    if(in.num[i] == 0){\n      in.num[i] = 9;\n      in.space = i;\n    }\n  }\n\n  printf(\"%d\\n\",BFS(in));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define M 4\n\nint a[N][N],temp[N][N],dx[M]={0,1,0,-1},dy[M]={1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!a[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int *a, int *b) {\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\nint cal() {\n  int i,u,sum=0;\n  for(i=0;i<9;i ++){\n    u=a[i/N][i%N];\n    if(u != 0){\n      u--;\n      sum += abs(i/N - u/N)+abs(i%N - u%N);\n    }\n  }\n  return sum;\n}\nint dfs(int x, int y, int p, int d, const int lim) {\n  int i,v,nx,ny,res;\n  v=cal();\n  if(v == 0) return d;\n\n  if(d+v > lim) return -1;\n\n  for(i=0;i<M;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p&&i == (p+2)%M) continue;\n    if(!(0 <= nx && nx < N && 0 <= ny && ny < N)) continue;\n    swap(&a[y][x],&a[ny][nx]);\n    res=dfs(nx,ny,i,d+1,lim);\n       if(~res) return res;\n\n    swap(&a[y][x],&a[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&a[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<N;i++){\n        for(j =0;j<N;j++){\n        temp[i][j] = a[i][j];\n      }\n    }\n    ans = dfs(x,y,-1,0,l);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        a[i][j]=temp[i][j];\n      }\n    }\n    ans = -1;\n    if(l == 99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}\n        \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3];\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n  int main(){\n    int ans,x,y,l,i,j;\n  \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        scanf(\"%d\",&puzle[i][j]);\n      }\n    }\n    empty(&x,&y);\n    for(l=0;l<100;l++){\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    tmp[i][j]=puzle[i][j];\n      }\n    }\n      ans=dfs(x,y,-1,0,l);\n      if(ans!=-1){\n        printf(\"%d\\n\",ans);\n        break;\n      }\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    puzle[i][j]=tmp[i][j];\n      }\n      }\n      ans=-1;\n      if(l==99){\n        printf(\"%d\\n\",ans);\n    }\n    }\n    return 0;            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0, found;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //åããåã®ãã¼ã\n  node *next; //ãªã¹ãä¸ã®æ¬¡ã®ãã¼ã\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tã«openãªã¹ãã®åé ­ãæ¸¡ã\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\\n\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define LIM 50\nint buf[N][N];\nint tmp[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *,int *);\nvoid swap(int *,int*);\nint cal();\nint dfs(int,int,int,int,int);\n\nint main(){\n  int i,j,k,x,y,ans;\n  for(i = 0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&buf[i][j]);\n    }\n  }\n  empty(&x,&y);\n  \n  for(k = 0;k<LIM;k++){\n\n    for(i = 0;i<N;i++){\n      for(j = 0;j<N;j++){\n\ttmp[i][j] = buf[i][j];\n      }\n    }\n    \n    ans = dfs(x,y,-1,0,k);\n    if(ans !=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n\n    for(i =0;i<N;i++){\n      for(j=0;j<N;j++){\n\tbuf[i][j] = tmp[i][j];\n      }\n    }\n    \n    ans = -1;\n\n    if(k == 49){\n      printf(\"%d\\n\",ans);\n    }\n  }\n\t\n  return 0;\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\n\nint dfs(int x,int y,int p,int depth,int lim){\n  int i,h,nx,ny,res;\n  h = cal();\n  if(h==0) {return depth;}\n  if(depth +h >lim) {return -1;}\n  \n  for(i=0;i<4;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p && i ==(p+2)%4) continue;\n    if(!(0 <=nx && nx <3 && 0 <=ny && ny <3)) continue;\n\n    swap(&buf[y][x],&buf[ny][nx]);\n    \n    res = dfs(nx,ny,i,depth+1,lim);\n    \n    if(~res) {return res;}\n    swap(&buf[y][x],&buf[ny][nx]);\n  }\n  return -1;\n}\n\nint cal(){\n  int i,a,sum=0;\n  for(i = 0;i<9;i++){\n    a = buf[i/3][i%3];\n    if(a) {\n      a--;\n      sum += abs(i/3 - a/3) +abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\n\n\n\n\nvoid empty(int *x ,int *y){\n  int i,j;\n  for(i = 0 ;i <N ;i++){\n    for(j = 0;j<N;j++){\n      if(buf[i][j]==0)\n\t{\n\t  *x = j;\n\t  *y = i;\n\t  return ;\n\t}\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn -1;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint i;\n\tint x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8, s[0].v = 0;\n\ttop = 0, end = 1;\n\tinsert(s[0].s, s[0].x, 0);\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x, v = s[top].v;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x == gx && a == gs) break;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (t < 0 || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx, s[end].v = nv;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //åããåã®ãã¼ã\n  node *next; //ãªã¹ãä¸ã®æ¬¡ã®ãã¼ã\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tã«openãªã¹ãã®åé ­ãæ¸¡ã\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\\n\", open->p->g);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \n#define S 9\n \nint board[S];\nint rows = 3, cols = 3, zeroIndex;\n \n\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n \n \n  if (moves < (x + y))\n    return 0;\n \n  if (!moves) {\n    for (i = 0; i < S - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n \n    return 1;\n  }\n \n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n \n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n \n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n \n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n \n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n \n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n \n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n \n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n \n  return 0;\n}\n \nint main() {\n  int j, x, y, current;\n \n  for (j = 0; j < S; j++) {\n    scanf(\"%d\", &board[j]);\n    if (!board[j])\n      zeroIndex = j;\n  }\n \n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n \n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 30000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 21\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 3\n#define N2 9\n#define LEN 362880\n\ntypedef struct Puzzle\n{\n  int f[N2];\n  int space;\n  int path;\n}P;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nint V[LEN];\nP Q[LEN];\nint head = 0;\nint tail = 0;\n\nvoid enqueue(P);\nP dequeue(void);\nint bfs(P);\nint isTarget(P);\nint henkan(P);\n\nint main()\n{\n  P in;\n\n  int i, ans;\n\n  for(i = 0; i < N2; i++)\n    {\n      scanf(\"%d\",&in.f[i]);\n\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n\n  ans = bfs(in);\n\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\nvoid enqueue(P num)\n{\n  int next = (tail+1)%LEN;\n\n  Q[tail] = num;\n  tail = next;\n}\n\nP dequeue(void)\n{\n  P val;\n  \n  val = Q[head];\n  head = (head+1)%LEN;\n  \n  return val;\n}\n\nint bfs(P s)\n{\n  P u, v;\n  int sx, sy, tx, ty, r, temp;\n\n  s.path = 0;\n  enqueue(s);\n  V[henkan(s)] = 1;\n\n  while(head != tail)\n    {\n     \n      u = dequeue();\n      if(isTarget(u))return u.path;\n      sx = u.space/N;\n      sy = u.space%N;\n\n      for(r = 0; r < 4; r++)\n\t{\n\t  tx = sx + dx[r];\n\t  ty = sy + dy[r];\n\t  if( tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t  v = u;\n\t  temp = v.f[u.space];\n\t  v.f[u.space] = v.f[tx * N + ty];\n\t  v.f[tx * N + ty] = temp;\n\t  v.space = tx * N + ty;\n\t  if(!V[henkan(v)])\n\t    {\n\t      V[henkan(v)] = 1;\n\t      v.path++;\n\t      enqueue(v);\n\t    }\n\t}\n    }\n  return -1;\n}\n\nint isTarget(P p)\n{\n  int i;\n  \n  for(i = 0; i < N2; i++)\n    {\n      if(p.f[i] != (i+1))return 0;\n    }\n  return 1;\n}\n\nint henkan(P v)\n{\n  int i, j, a, count, order = 0;\n\n  for(i = 0, a = 1; i < N2; a*=++i)\n    {\n      for(j = 0, count = 0; j < i; j++)\n\t{\n\t  if(v.f[j] < v.f[i])count++;\n\t}\n      order += count*a;\n    }\n  return order;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Pz[3][3],tmp[3][3],Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  \n  int i,j;\n  \n  for(i = 0;i < 3;i++){\n    for(j = 0;j < 3;j++){\n      if(!Pz[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  \n  int tmp;\n  \n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  \n  int i,a,b=0;\n  \n  for(i = 0;i < 9;i++){\n    a = Pz[i/3][i%3];\n    if(a){\n      a--;\n      b += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }\n  \n  return b;\n  \n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  \n  int i,I,A,B,result;\n  \n  I = check();\n  if(I == 0){\n    return D;\n  }\n  if(D + I > shin){\n    return -1;\n  }\n\n  for(i = 0;i < 4;i++){\n    A = a + Dx[i];\n    B = b + Dy[i];\n    if(~P && i==(P+2)%4) continue;\n    if(!(0 <= A && A < 3 && 0 <= B && B < 3)) continue;\n    swap(&Pz[b][a],&Pz[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result) return result;\n    swap(&Pz[b][a],&Pz[B][A]);\n  }\n  \n  return -1;\n  \n}\n\nint main(){\n  \n  int i,j,a,b,c,d;\n\n  for(i = 0;i < 3;i++){\n    for(j = 0;j < 3;j++){\n      scanf(\"%d\",&Pz[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(c = 0;c < 100;c++){\n    for(i = 0;i < 3;i++){\n      for(j = 0;j < 3;j++) tmp[i][j]=Pz[i][j];\n    }\n    d = defain(a,b,-1,0,c);\n    if(d != -1){\n      printf(\"%d\\n\",d);\n      break;\n    }\n\n    for(i = 0;i < 3;i++){\n      for(j = 0;j < 3;j++) Pz[i][j]=tmp[i][j];\n    }\n\n    d = -1;\n    if(c == 99) printf(\"%d\\n\",d);\n  }\n\n  return 0;\n  \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define TRUE  1\n#define FALSE 0\n#define FORWARD  1\n#define BACKWARD 2\n#define SIZE  9\n#define NIL   (-1)\n\n/* ç¶ææ° (9! / 2) */\n#define MAX_STATE 181440\n\n/* é£æ¥ãªã¹ã */\nconst char adjacent[SIZE][5] = {\n  1, 3,-1,-1,-1,\n  0, 4, 2,-1,-1,\n  1, 5,-1,-1,-1,\n  0, 4, 6,-1,-1,\n  1, 3, 5, 7,-1,\n  2, 4, 8,-1,-1,\n  3, 7,-1,-1,-1,\n  4, 6, 8,-1,-1,\n  5, 7,-1,-1,-1,\n};\n\n/* ã­ã¥ã¼ */\nchar state[MAX_STATE + 1][SIZE];      /* +1 ã¯ã¯ã¼ã¯é å */\nchar space_postion[MAX_STATE];\nint  prev_state[MAX_STATE];\nint  number_table[MAX_STATE];\n\n/* åä¸å±é¢ãã§ãã¯ãã¼ãã« */\nchar check_table[MAX_STATE * 2];\n\n/* åæç¶æ */\nchar init_state[SIZE];\n\n/* çµäºç¶æ */\nchar final_state[SIZE] = {\n  1, 2, 3, 4, 5, 6, 7, 8, 0\n};\n\nint count=0;\n\nvoid print_answer_forward(int n)\n{\n  if(n > 1) print_answer_forward(prev_state[n]);\n  count++;\n}\n\nvoid print_answer_backward( int n )\n{\n  do{\n    n = prev_state[n];\n    count++;\n  }\n\n  while( prev_state[n] != -1 );\n}\n\nvoid print_answer( int pos1, int num1, int num2 )\n{\n  /* num2 ã®ä½ç½®ãè¦ã¤ãã */\n  int pos2 = pos1 - 1;\n\n  while( num2 != number_table[pos2] ) pos2--;\n\n  if( check_table[num1] == FORWARD ){\n    print_answer_forward( pos1 );\n    print_answer_backward( pos2 );\n  }\n  else{\n    print_answer_forward( pos2 );\n    print_answer_backward( pos1 );\n  }\n}\n\n/* çªå·ã«å¤æ */\nint change_number( char *board )\n{\n  char work[SIZE];\n  static int fact_table[SIZE] = {\n    40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n  };\n  int j, k, value = 0;\n  memcpy( work, board, SIZE );\n  for( j = 0; j < SIZE - 1; j++ ){\n    value += fact_table[j] * work[j];\n    for( k = j + 1; k < SIZE; k++ ){\n      if( work[j] < work[k] ) work[k]--;\n    }\n  }\n  return value;\n}\n\n/* ã­ã¥ã¼ã®åæå */\nvoid init_queue( void )\n{\n  int num;\n\n  /* ã¹ã¿ã¼ã */\n  memcpy( state[0], init_state, SIZE );\n  space_postion[0] = 7;\n  prev_state[0] = -1;\n  num = change_number( init_state );\n  number_table[0] = num;\n  check_table[ num ] = FORWARD;\n\n  /* ã´ã¼ã« */\n  memcpy( state[1], final_state, SIZE );\n  space_postion[1] = 8;\n  prev_state[1] = -1;\n  num = change_number( final_state );\n  number_table[1] = num;\n  check_table[ num ] = BACKWARD;\n}\n\n/* æ¢ç´¢ */\nvoid search( void )\n{\n  int front = 0, rear = 2;\n\n  /* åæå */\n  init_queue();\n\n  while( front < rear ){\n    int s = space_postion[front];\n    int num1 = number_table[front];\n    int num2, i, n;\n\n    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){\n      /* ç¶æãã³ãã¼ */\n      memcpy( state[rear], state[front], SIZE );\n      /* ç§»å */\n      state[rear][s] = state[rear][n];\n      state[rear][n] = 0;\n      space_postion[rear] = n;\n      prev_state[rear] = front;\n      num2 = change_number( state[rear] );\n\n      if( !check_table[num2] ){\n\t/* ç»é² */\n        number_table[rear] = num2;\n        check_table[num2] = check_table[num1];\n\trear++;\n      }\n      else if( check_table[num1] != check_table[num2] ){\n        /* è§£ãè¦ã¤ãã£ã */\n        print_answer( rear, num1, num2 );\n        return;\n      }\n    }\n    front++;\n  }\n}\n\nint main()\n{\n  int i;\n  \n  for(i = 0; i < 9; i++){\n    scanf(\"%d\", &init_state[i]);\n  }\n  \n  search();\n  printf(\"count = %d\\n\", count-1);  \n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint data[9],first[9],limit = 32, cnt = 0;\nint process(int, int);\nint check();\nvoid change1(int, int);\nvoid change2(int, int);\nvoid debug(int, int);\n\nint main(){\n\n  int i;\n\n  for(i = 0; i < 9; i++)\n  {\n    scanf(\"%d\",&data[i]);\n    first[i] = data[i];\n  }\n\n\n\n  for(i = 0; i < 9; i++)\n  {\n    if(data[i] == 0)break;\n  }\n\n  process(i, -1);\n\n  printf(\"%d\\n\",limit);\n\n  return 0;\n}\n\nint process(int x, int back)\n{\n  int i, a;\n  //debug(x,back);\n  if(cnt >= limit)return 0;\n  if(check() == 1)return 1;\n\n  switch(x){\n    /*\n    case 0:\n    printf(\"x = %d, back = %d\\n\",x,back);\n    if(back != 1)\n    {\n      change1(0,1);\n      process(1,0);\n      change2(0,1);\n    }\n    if(back != 3)\n    {\n      change1(0,3);\n      process(1,0);\n      change2(0,3);\n    }\n    return 0;\n    */\n    case 0:\n    if(back != 1 && data[x] == 0)\n    {\n      change1(0,1);\n      process(1,0);\n      change2(0,1);\n    }\n    if(back != 3 && data[x] == 0)\n    {\n      change1(0,3);\n      process(3,0);\n      change2(0,3);\n    }\n    return 0;\n\n    case 1:\n    //if(cnt == 1)printf(\"x = %d, back = %d\\n\",x,back);\n    if(back != 0 && data[x] == 0)\n    {\n      change1(1,0);\n      process(0,1);\n      change2(1,0);\n    }\n    if(back != 2 && data[x] == 0)\n    {\n      change1(1,2);\n      process(2,1);\n      change2(1,2);\n    }\n    if(back != 4 && data[x] == 0)\n    {\n      change1(1,4);\n      process(4,1);\n      change2(1,4);\n    }\n    return 0;\n\n    case 2:\n    if(back != 1 && data[x] == 0)\n    {\n      change1(2,1);\n      process(1,2);\n      change2(2,1);\n    }\n    if(back != 5 && data[x] == 0)\n    {\n      change1(2,5);\n      process(5,2);\n      change2(2,5);\n    }\n    return 0;\n\n    case 3:\n    if(back != 0 && data[x] == 0)\n    {\n      change1(3,0);\n      process(0,3);\n      change2(3,0);\n    }\n    if(back != 4 && data[x] == 0)\n    {\n      change1(3,4);\n      process(4,3);\n      change2(3,4);\n    }\n    if(back != 6 && data[x] == 0)\n    {\n      change1(3,6);\n      process(6,3);\n      change2(3,6);\n    }\n    return 0;\n\n    case 4:\n    if(back != 1 && data[x] == 0)\n    {\n      change1(4,1);\n      process(1,4);\n      change2(4,1);\n    }\n    if(back != 3 && data[x] == 0)\n    {\n      change1(4,3);\n      process(3,4);\n      change2(4,3);\n    }\n    if(back != 5 && data[x] == 0)\n    {\n      change1(4,5);\n      process(5,4);\n      change2(5,4);\n    }\n    if(back != 7 && data[x] == 0)\n    {\n      change1(4,7);\n      process(7,4);\n      change2(4,7);\n    }\n    return 0;\n\n    case 5:\n    if(back != 2 && data[x] == 0)\n    {\n      change1(5,2);\n      process(2,5);\n      change2(5,2);\n    }\n    if(back != 4 && data[x] == 0)\n    {\n      change1(5,4);\n      process(4,5);\n      change2(5,4);\n    }\n    if(back != 8 && data[x] == 0)\n    {\n      change1(5,8);\n      process(8,5);\n      change2(5,8);\n    }\n    return 0;\n\n    case 6:\n    if(back != 3 && data[x] == 0)\n    {\n      change1(6,3);\n      process(3,6);\n      change2(6,3);\n    }\n    if(back != 7 && data[x] == 0)\n    {\n      change1(6,7);\n      process(7,6);\n      change2(6,7);\n    }\n    return 0;\n\n    case 7:\n    if(back != 4 && data[x] == 0)\n    {\n      change1(7,4);\n      process(4,7);\n      change2(7,4);\n    }\n    if(back != 6 && data[x] == 0)\n    {\n      change1(7,6);\n      process(6,7);\n      change2(7,6);\n    }\n    if(back != 8 && data[x] == 0)\n    {\n      change1(7,8);\n      process(8,7);\n      change2(7,8);\n    }\n    return 0;\n\n    case 8:\n    if(back != 5 && data[x] == 0)\n    {\n      change1(8,5);\n      process(5,8);\n      change2(8,5);\n    }\n    if(back != 7 && data[x] == 0)\n    {\n      change1(8,7);\n      process(7,8);\n      change2(8,7);\n    }\n    return 0;\n  }\n  return 0;\n}\n\nvoid change1(int x, int y)\n{\n  int temp;\n  cnt++;\n  temp = data[x];\n  data[x] = data[y];\n  data[y] = temp;\n}\n\nvoid change2(int x, int y)\n{\n  int temp;\n  cnt--;\n  temp = data[x];\n  data[x] = data[y];\n  data[y] = temp;\n}\n\n\nint check()\n{\n  int i;\n  for(i = 0; i < 8; i++)\n  {\n    if(data[i] != i + 1)return 0;\n  }\n  limit = cnt;\n  return 1;\n}\n\nvoid debug(int x, int back)\n{\n  int i;\n  if(cnt == 1)printf(\"--------------------------------\\n\\n\\n\\n\");\n  printf(\"cnt = %2d || limit = %2d || x:%d  back:%d ||%d â %d\\n\",cnt,limit,x,back,back,x);\n  for(i = 0; i < 9; i++)\n  {\n    printf(\"%d \",data[i]);\n    if(i % 3 == 2)printf(\"\\n\");\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n \n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n   \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n\n#define N 3\n#define true 1\n#define false 0\n\n\nint x[4]={0,-1,0,1};\nint y[4]={1,0,-1,0};\nint l;\nint w[N][N];\n\n\nvoid swap(int *,int *);\nint abc();\nint dfs(int,int,int,int);\nvoid Solved(int,int);\n\nint main()\n{\n  int i,j,ax,ay;\n   \n   for(i=0;i<N;i++){\n     for(j=0;j<N;j++){\n       scanf(\"%d\",&w[i][j]);\n        if(w[i][j]==0){\n\t  ay=i;\n\t    ax=j;\n\t}\n        }\n   }\n     \n   Solved(ay,ax);\n     \n     return 0;\n}\n\n\nvoid swap(int *s,int *t)\n{\n  int tmp=*s;\n  \n  *s=*t;\n  *t=tmp;\n  \n  return ;\n}\n\n\nint abc()\n{\n  int i,j,s=0,r;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(w[i][j]==0)continue;\n    r=w[i][j]-1;\n    \n    s+=abs(r/N-i)+abs(r%N-j);\n    \n    }\n  }\n  \n  return s;\n}\n\n\nint dfs(int d,int p,int ay,int ax)\n{\n  int i,m=abc();\n  \n  if(m==0)return true;\n  \n  if(d+m>l)return false;\n  \n  for(i=0;i<4;i++){\n    if(abs(i-p)==2)continue;\n    \n    int tx=ax+x[i],ty=ay+y[i];\n    \n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n    \n    if(dfs(d+1,i,ty,tx))return true;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n  }\n  \n  return false;\n}\n\n\nvoid Solved(int ay,int ax)\n{\n  for(l=0;;l++){\n    if(dfs(0,99,ay,ax)){\n      printf(\"%d\\n\",l);\n      return ;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n   \nint mas[3][3];\nint cpy[3][3];\n  \n   \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n   \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n   \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n   \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n   \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n   \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n   \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n   \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n   \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n   \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n   \n  return -1;\n}\n   \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n   \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<31; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint A[10];\nint fa[10]={1,1,2,6,24,120,720,5040,40320};\n\nint DP[362880];\nvoid swap(int i,int j){\n  int t=A[i];\n  A[i]=A[j];\n  A[j]=t;\n}\n\nint F(){\n  int ans=0,b=0;\n  for(int i=8;i>=0;i--){\n    ans+=__builtin_popcount(b&((1<<A[i])-1))*fa[8-i];\n    b|=1<<A[i];\n  }\n  return ans;\n}\nvoid G(int n){\n  int b=0;\n  for(int i=0;i<9;i++)A[i]=i;\n  for(int i=0;i<9;i++){\n    int x=n/fa[8-i];\n    n%=fa[8-i];\n    for(int j=x;j>0;j--)swap(i+j,i+j-1);\n  }\n}\n\nint que[363000],quecnt;\nvoid ck(int p,int k){\n  int x=F();\n  if(!DP[x]){\n    DP[x]=k+1;\n    que[quecnt++]=x*10+p;\n  }\n}\nint calc(){\n  for(int i=0;i<quecnt;i++){\n    int x=que[i]/10;\n    int p=que[i]%10;\n    if(x==0)return DP[x]-1;\n    G(x);\n    if(p<6)swap(p,p+3),ck(p+3,DP[x]),swap(p,p+3);\n    if(p>2)swap(p,p-3),ck(p-3,DP[x]),swap(p,p-3);\n    if(p%3<2)swap(p,p+1),ck(p+1,DP[x]),swap(p,p+1);\n    if(p%3>0)swap(p,p-1),ck(p-1,DP[x]),swap(p,p-1);\n  }\n  return -1;\n}\n\nint main(){\n  int p;\n  for(int i=0;i<9;i++){\n    int t;\n    scanf(\"%d\",&t);\n    if(t)A[i]=t-1;\n    else{\n      A[i]=8;\n      p=i;\n    }\n  }\n  ck(p,0);\n  printf(\"%d\\n\",calc());\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puzzle[3][3];\nint temp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++) {\n    for(j=0;j<3;j++) scanf(\"%d\",&puzzle[i][j]);\n  }\n     \n  empty(&x,&y);\n  for(l=0;l<100;l++) {\n       \n    for(i=0;i<3;i++) {\n      for(j=0;j<3;j++) temp[i][j]=puzzle[i][j];\n    }\n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1) {\n      printf(\"%d\\n\",ans);\n      break;\n    }\n \n    for(i=0;i<3;i++) {\n      for(j=0;j<3;j++) puzzle[i][j] = temp[i][j];\n    }\n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }    \n  return 0;\n}\n \n \nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++) {\n    for(j=0;j<3;j++) {\n      if(!puzzle[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n \n \nvoid swap(int *a,int *b) {\n  int temp;\n     \n  temp=*a;\n  *a=*b;\n  *b=temp;\n}\n \n \nint cal(){\n  int i,a,sum=0;\n     \n  for(i=0;i<9;i++) {\n    a=puzzle[i/3][i%3];\n    if(a) {\n      a--;\n      sum+=abs(i/3-a/3)+abs(i%3-a%3);\n    }\n  }\n     \n  return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n  int i,h,nx,ny,res;\n     \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n     \n  for(i=0;i<4;i++) {\n    nx=x+dx[i];\n    ny=y+dy[i];\n         \n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n         \n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n  }\n     \n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  if(h == 0) return dep;\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nconst Board ini_board = \"130425786\";\nBoard board = \"130425786\";\nconst Board target = \"123456780\";\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = INT_MAX;\n\nconst Motion candidate[9][5] = \n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (board[m.pos]==target[m.pos]) return -1;\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step<minstep) minstep=step;\n    \n  } else {\n\n    int s2;\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0)\n\t  break;// goto next;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      //    next:\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, 2);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n \n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar * VAR00 ;\nint VAR01 , VAR02 ;\nint * VAR03 ;\nint VAR04 [ 10 ] ;\n\nint FUNC00 ( int ARG00 ) {\n  if ( ARG00 == 0 ) return 1 ;\n  return FUNC00 ( ARG00 - 1 ) * ARG00 ;\n}\n\nint FUNC01 ( char * ARG01 ) {\n  int VAR05 = 0 ;\n  int VAR06 ;\n  for ( VAR06 = 0 ; VAR06 < 9 ; VAR06 ++ ) {\n    int VAR07 , VAR08 ;\n    VAR07 = 0 ;\n    for ( VAR08 = 0 ; VAR08 < VAR06 ; VAR08 ++ ) {\n      if ( ARG01 [ VAR08 ] < ARG01 [ VAR06 ] ) VAR07 ++ ;\n    }\n    VAR05 += VAR04 [ 8 - VAR06 ] * ( ARG01 [ VAR06 ] - '0' - VAR07 ) ;\n  }\n  return VAR05 ;\n}\n\nchar * FUNC02 ( int ARG02 ) {\n  int VAR09 ;\n  char * VAR10 ;\n  VAR10 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  for ( VAR09 = 0 ; VAR09 < 9 ; VAR09 ++ ) {\n    VAR10 [ VAR09 ] = ARG02 % VAR04 [ 9 - VAR09 ] / VAR04 [ 8 - VAR09 ] + '0' ;\n  }\n  VAR10 [ 9 ] = '\\0' ;\n  for ( VAR09 = 7 ; VAR09 >= 0 ; VAR09 -- ) {\n    int VAR11 ;\n    for ( VAR11 = 8 ; VAR11 > VAR09 ; VAR11 -- ) {\n      if ( VAR10 [ VAR09 ] <= VAR10 [ VAR11 ] ) VAR10 [ VAR11 ] ++ ;\n    }\n  }\n  return VAR10 ;\n}\n\n\nchar * FUNC03 ( char ARG03 [ ] , int ARG04 ) {\n  if ( ARG04 < 3 ) return NULL ;\n  char * VAR12 ;\n  VAR12 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR12 , ARG03 ) ;\n  VAR12 [ ARG04 ] = ARG03 [ ARG04 - 3 ] ;\n  VAR12 [ ARG04 - 3 ] = ARG03 [ ARG04 ] ;\n  return VAR12 ;\n}\n\nchar * FUNC04 ( char ARG05 [ ] , int ARG06 ) {\n  if ( ARG06 % 3 == 0 ) return NULL ;\n  char * VAR13 ;\n  VAR13 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR13 , ARG05 ) ;\n  VAR13 [ ARG06 ] = ARG05 [ ARG06 - 1 ] ;\n  VAR13 [ ARG06 - 1 ] = ARG05 [ ARG06 ] ;\n  return VAR13 ;\n}\n\nchar * FUNC05 ( char ARG07 [ ] , int ARG08 ) {\n  if ( ARG08 % 3 == 2 ) return NULL ;\n  char * VAR14 ;\n  VAR14 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR14 , ARG07 ) ;\n  VAR14 [ ARG08 ] = ARG07 [ ARG08 + 1 ] ;\n  VAR14 [ ARG08 + 1 ] = ARG07 [ ARG08 ] ;\n  return VAR14 ;\n}\n\nchar * FUNC06 ( char ARG09 [ ] , int ARG10 ) {\n  if ( ARG10 > 5 ) return NULL ;\n  char * VAR15 ;\n  VAR15 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR15 , ARG09 ) ;\n  VAR15 [ ARG10 ] = ARG09 [ ARG10 + 3 ] ;\n  VAR15 [ ARG10 + 3 ] = ARG09 [ ARG10 ] ;\n  return VAR15 ;\n}\n\nint FUNC07 ( char ARG11 [ ] , int ARG12 ) {\n  if ( strcmp ( ARG11 , \"123456780\" ) == 0 ) return ARG12 ;\n  int VAR16 = FUNC01 ( ARG11 ) ;\n  if ( VAR00 [ VAR16 ] ) return 0 ;\n  VAR00 [ VAR16 ] = ARG12 ;\n  VAR03 [ VAR02 ] = VAR16 ;\n  VAR02 ++ ;\n  return 0 ;\n}\n\nint FUNC08 ( char * ARG13 ) {\n  int VAR17 = 0 ;\n  while ( ARG13 [ VAR17 ] != '0' ) VAR17 ++ ;\n  return VAR17 ;\n}\n\nint FUNC09 ( ) {\n  char * VAR18 , * VAR19 , * VAR20 , * VAR21 ;\n  int VAR22 , VAR23 ;\n\n  VAR23 = VAR03 [ VAR01 ] ;\n  char * VAR24 = FUNC02 ( VAR23 ) ;\n  int VAR25 = FUNC08 ( VAR24 ) ;\n\n  if ( ( VAR18 = FUNC05 ( VAR24 , VAR25 ) ) != NULL ) {\n    if ( ( VAR22 = FUNC07 ( VAR18 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n    free ( VAR18 ) ;\n  }\n  if ( ( VAR19 = FUNC04 ( VAR24 , VAR25 ) ) != NULL ) {\n     if ( ( VAR22 = FUNC07 ( VAR19 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n     free ( VAR19 ) ;\n  }\n  if ( ( VAR20 = FUNC03 ( VAR24 , VAR25 ) ) != NULL ) {\n    if ( ( VAR22 = FUNC07 ( VAR20 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n    free ( VAR20 ) ;\n  }\n  if ( ( VAR21 = FUNC06 ( VAR24 , VAR25 ) ) != NULL ) {\n    if ( ( VAR22 = FUNC07 ( VAR21 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n    free ( VAR21 ) ;\n  }\n  free ( VAR24 ) ;\n  VAR01 ++ ;\n  return 0 ;\n}\n\n\nint FUNC10 ( char ARG14 [ ] ) {\n  int VAR26 ;\n  if ( ( VAR26 = FUNC07 ( ARG14 , 1 ) ) ) return VAR26 ;\n\n  while ( ! ( VAR26 = FUNC09 ( ) ) ) {\n    if ( VAR01 == VAR02 ) break ;\n  }\n  return VAR26 ;\n}\n\nint main ( )\n{\n\n  int VAR27 , VAR28 ;\n  char VAR29 [ 10 ] ;\n  for ( VAR27 = 0 ; VAR27 < 10 ; VAR27 ++ ) VAR04 [ VAR27 ] = FUNC00 ( VAR27 ) ;\n  VAR00 = ( char * ) malloc ( sizeof ( char ) * VAR04 [ 9 ] ) ;\n  memset ( VAR00 , 0 , VAR04 [ 9 ] ) ;\n  VAR03 = ( int * ) malloc ( sizeof ( int ) * VAR04 [ 9 ] ) ;\n  VAR01 = 0 ;\n  VAR02 = 0 ;\n  for ( VAR27 = 0 ; VAR27 < 9 ; VAR27 ++ ) {\n    scanf ( \"%d\" , & VAR28 ) ;\n    VAR29 [ VAR27 ] = VAR28 + '0' ;\n  }\n  VAR29 [ 9 ] = '\\0' ;\n  printf ( \"%d\\n\" , FUNC10 ( VAR29 ) - 1 ) ;\n\n  return 0 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define MAX 362880\n#define N 3\n#define N2 9\n\ntypedef struct puzzle{\n  int f[N2];\n  int space;\n  int path;\n}puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\npuzzle Q[MAX];\nint head, tail, V[MAX];\n\nint empty()\n{\n  return head == tail;\n}\n\nvoid enqueue(puzzle x)\n{\n  Q[tail] = x;\n  tail = (tail+1)%MAX;\n}\n\npuzzle front()\n{\n  puzzle x;\n\n  x = Q[head];\n  head = (head+1)%MAX;\n\n  return x;\t\n}\n\nint cheak(puzzle p)\n{\n  int i, j, fac, count, res = 0;\n\n  for(i = 0, fac = 1; i < N2; fac*= ++i){\n    for(j = 0, count = 0; j < i; j++)\n      if(p.f[j] < p.f[i])\n\tcount++;\n    res += count*fac;\n  }\n\t\n  return res;\t\n}\n\nint isTarget(puzzle p)\n{\n  int i;\n\n  for (i = 0; i < N2; i++)\n    if(p.f[i] != (i + 1))\n      return 0;\n  return 1;\n}\n\nint bfs(puzzle s)\n{\n  int sx, sy, tx, ty, r, temp;\n  puzzle u, v;\n\t\n  s.path = 0;\n  enqueue(s);\n  V[cheak(s)] = 1;\n  while(!empty()){\n    u = front();\n    if( isTarget(u))\n      return u.path;\n    sx = u.space / N;\n    sy = u.space % N;\n    for (r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)\n\tcontinue;\n      v = u;\t\t\n      temp = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = temp;\t\n      v.space = tx * N + ty;\n      if(!V[cheak(v)]){\n\tV[cheak(v)] = 1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\t\n  return -1;\n}\n\nint main()\n{\n  int i, a;\n  puzzle p;\n\t\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &p.f[i]);\n    if( p.f[i] == 0){\n      p.f[i] = N2;\n      p.space = i;\n    }\n  }\n\t\n  a = bfs(p);\n  printf(\"%d\\n\",a);\n\t\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3;\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,1);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \n#define Ni 3\n \nint Pz[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n \nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!Pz[i][j]){\n    *a = j;\n    *b=i;\n      }\n    }\n  }\n}\n \nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n \nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = Pz[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n \nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n \n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n  }\n  return -1;\n}\n \nint main(){\n  int i,j,li,TA,a,b;\n \n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&Pz[i][j]);\n    }\n  }\n \n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n    tmp[i][j]=Pz[i][j];\n      }\n    }\n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n    Pz[i][j]=tmp[i][j];\n      }\n    }\n \n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3];\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,1);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n//     +-+-+-+       +-+-+-+\n//     |1|3|0|       |1|2|3|\n//     +-+-+-+       +-+-+-+\n//     |4|2|5|       |4|5|6|\n//     +-+-+-+       +-+-+-+\n//     |7|8|6|       |7|8|0|\n//     +-+-+-+       +-+-+-+\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 50;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    puts(board);\n    //    printf(\"%d\\n%c%c%c\\n%c%c%c\\n%c%c%c\\n---\\n\", nhistories, board[0],board[1],board[2],  board[3],board[4],board[5],  board[6],board[7],board[8]);\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // åã¨åãéç½®ã«ãªã£ãã®ã§æ¬¡ã®æãè©¦ã\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n????\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=400000;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\nint main()\n{\n  int i, j, k;\n  int qhead=0;\n  int qtail=0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*100000000+j*10000000+k*1000000;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100000+j*10000+k*1000;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  printf(\"ini: %u\\n\", board.b);\n  short int *used = (short int*)malloc(sizeof(short int)*87654321);\n  for (i=0; i<87654321; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    \n    if (board.b==123456780)   break;\n\n    k=board.b/10;\n    if ((used[k] & (1<<(board.b%10)))==(1<<(board.b%10))) continue;\n    used[k] |= (1<<(board.b%10));\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n//      printf(\"spc=%d, pos=%d: %u -> \", space, m.pos, b.b);\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      \n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step=board.step+1;\n      printf(\"%u\\n\", b.b);\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid empty(int *, int *);\nvoid swap(int *, int *);\nint cal();\nint dfs(int, int, int, int, int);\n\nint main(){\n  int i,j,k;\n  int x,y,a;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puzzle[i][j]);\n    }\n  }\n\n  empty(&x,&y);\n\n  for(k=0;k<100;k++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=puzzle[i][j];\n      }\n    }\n\n    a=dfs(x,y,-1,0,k);\n    if(a!=-1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpuzzle[i][j]=tmp[i][j];\n      }\n    }\n    \n    a=-1;\n    if(k==99) printf(\"%d\\n\",a);\n  }\n\n  return 0;\n}\n\nvoid empty(int *x, int *y){\n  int i,j;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(puzzle[i][j]==0){\n\t*x=j;\n\t*y=i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n  \n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\n\nint cal(){\n  int i,x;\n  int sum=0;\n\n  for(i=0;i<9;i++){\n    x=puzzle[i/3][i%3];\n    if(x){\n      x--;\n      sum+=abs((i/3)-(x/3))+abs((i%3)-(x%3));\n    }\n  }\n\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,int limit){\n  int i,h,nx,ny,res;\n\n  h=cal();\n  \n  if(h==0) return dep;\n  if(dep+h>limit) return -1;\n\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n\n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n\n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n    res=dfs(nx,ny,i,dep+1,limit);\n    if(~res) return res;\n\n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n  }\n\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid Empty(int *, int *);\nvoid swap(int *, int *);\nint Cal();\nint DFS(int, int, int, int, int);\n\nint main(){\n  int i, j, l;\n  int x, y, a;\n\nfor(i=0;i<3;i++)\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      scanf(\"%d\",&Puzzle[i][j]);\n    }\n  }\n\n  Empty(&x,&y);\n\n  for(l = 0 ; l < 100 ; l++){\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n tmp[i][j] = Puzzle[i][j];\n      }\n    }\n\n    a = DFS(x, y, -1, 0, l);\n    if(a != -1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n Puzzle[i][j] = tmp[i][j];\n      }\n    }\n\n    a = -1;\n    if(l == 99) printf(\"%d\\n\",a);\n  }\n\n  return 0;\n}\n\nvoid Empty(int *x, int *y){\n  int i, j;\n\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      if(!Puzzle[i][j]){\n *x = j;\n *y = i;\n return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\nint Cal(){\n  int i, a;\n  int sum = 0;\n\n  for(i = 0 ; i < 9 ; i++){\n    a = Puzzle[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n    }\n  }\n\n  return sum;\n}\n\nint DFS(int x, int y, int p, int dep, int limit){\n  int i, h, nx, ny, res;\n\n  h = Cal();\n\n  if(h == 0) return dep;\n  if(dep + h > limit) return -1;\n\n  for(i = 0 ; i < 4 ; i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n\n    if(~p && i == (p+2)%4) continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3)) continue;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n    res = DFS(nx, ny, i, dep+1, limit);\n    if(~res) return res;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n  }\n\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define N 3\n\nint pl[N][N],tmp[N][N];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid em(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid SW(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint cal(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n\nint df(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = cal();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n    result = df(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pl[i][j]);\n    }\n  }\n\n    em(&a,&b);\n    for(li=0;li<100;li++){\n      for(i=0;i<3;i++){\n\tfor(j=0;j<3;j++){\n\t  tmp[i][j]=pl[i][j];\n\t}\n      }\n\tTA = df(a,b,-1,0,li);\n\tif(TA!=-1){\n\t  printf(\"%d\\n\",TA);\n\t  break;\n\t}\n\n\tfor(i=0;i<3;i++){\n\t  for(j=0;j<3;j++){\n\t    pl[i][j]=tmp[i][j];\n\t  }\n\t}\n\n\tTA = -1;\n\tif(li==99){\n\t      printf(\"%d\\n\",TA);\n\t    }\n      }\n\n    return 0;\n\t    }\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Puzzle[3][3];\nint tmp[3][3];\nint da[4] = {0, 1, 0, -1};\nint db[4] = {1, 0, -1, 0};\nint Roop(int);\nvoid Kara(int *, int *);\n\n\n\nvoid swap(int *, int *);\n\n\n\nint ABC(int, int, int, int, int);\n\n\n\n\nint Cal(){\n  int i, a;\n  int sum = 0;\n\n  for(i = 0 ; i < 9 ; i++){\n    a = Puzzle[i/3][i%3];\n    if(a){\n\n\n\n\n\n      a=a-1;\n      sum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n    }\n  }\n\n  return sum;\n}\n\n\n\n\n\n\n\nint main(){\n  int i=0,j, l;\n  int gya;\n  int far;\n  int a;\n\n  while( i < 3){\n    for(j = 0 ; j < 3 ; j++){\n      scanf(\"%d\",&Puzzle[i][j]);\n    }\n    i++;\n  }\n\n  Kara(&gya,&far);\n  l=0;\n  while(l < 100){\n\n    \n    for(i = 0 ; i < 3 ; i++){\n\n\n       \n      for(j = 0 ; j < 3 ; j++){\n\ttmp[i][j] = Puzzle[i][j];\n      }\n    }\n\n    a = ABC(gya, far, -1, 0, l);\n    if(a != -1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n    i=0;\n    while(i < 3){\n      for(j = 0 ; j < 3 ; j++){\n\tPuzzle[i][j] = tmp[i][j];\n      }\n      i++;\n    }\n    \n    a = -1;\n    if(l == 99) printf(\"%d\\n\",a);\n    l++;\n  }\n\n  return 0;\n}\n\nvoid Kara(int *gya, int *far){\n  int i=0, j;\n\n  while(i < 3){\n    for(j = 0 ; j < 3 ; j++){\n      if(!Puzzle[i][j]){\n\t*gya = j;\n\t*far = i;\n\treturn;\n      }\n    }\n    i++;\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n  \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\n\nint ABC(int a, int b, int p, int hukasa, int seigen){\n\n\n\n\n\n  int i, h, na, nb, res;\n\n  h = Cal();\n  \n  if(h == 0) return hukasa;\n\n\n\n\n\n  if(hukasa + h > seigen) return -1;\n\nfor(i=0;i < 4;i++){\n    na = a + da[i];\n    nb = b + db[i];\n\n    if(~p && i == (p+2)%4) continue;\n    if(!(0 <= na && na < 3 && 0 <= nb && nb < 3)) continue;\n\n    swap(&Puzzle[b][a], &Puzzle[nb][na]);\n\n\n\n\n\n\n\n\n    res = ABC(na, nb, i, hukasa+1, seigen);\n    if(~res) return res;\n\n    swap(&Puzzle[b][a], &Puzzle[nb][na]);\n  }\n\n  return -1;\n}\n    \nint Roop(int c){\nc++;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define TRUE 1\n#define FALSE 0\n#define N 3\n\n\nint P[N][N];\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint lim;\n\nint SUM();\nvoid pazz(int,int);\nvoid change(int,int,int,int);\nint bfs(int,int,int,int);\n\nint SUM()\n{\n  int i,j,num,sum=0;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(P[i][j] == 0)\n\tcontinue;\n      num = P[i][j] - 1;\n      sum += abs(num/N-i) + abs(num%N-j);\n    }\n  }\n  return sum;\n}\n\n\nvoid pazz(int x,int y)\n{\n  for(lim=0;;lim++) {\n    if(bfs(0,99,y,x)) {\n      printf(\"%d\\n\",lim);\n      return;\n    }\n  }\n}\n\nvoid change(int a,int b,int c,int d)\n{\n  int x;\n\n  x = P[a][b];\n  P[a][b] = P[c][d];\n  P[c][d] = x;\n}\n\nint bfs(int d,int p, int y,int x)\n{\n  int i,j;\n  int l,m,n;\n\n  l = SUM();\n  if(l == 0)\n    return TRUE;\n  if(lim < d + l)\n    return FALSE;\n\n  for(i=0;i<4;i++) {\n    if(abs(i-p) == 2)\n      continue;\n    m = x + dx[i];\n    n = y + dy[i];\n    if(m < 0 || n < 0 || m >= N || n >= N)\n      continue;\n    change(n,m,y,x);\n    \n\n    if(bfs(d+1,i,n,m))\n      return TRUE;\n    change(n,m,y,x);\n  }\n    return FALSE;\n}\n    \n    \n \n  int main()\n  {\n    int i,j,x,y;\n\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) {\n\tscanf(\"%d\",&P[i][j]);\n\tif(P[i][j] == 0) {\n\t  y = i;\n\t  x = j;\n\t}\n      }\n    }\n    pazz(x,y);\n  \n    return 0;\n  }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  \n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint distance(char *s_new) {\n  char s[] = \"123456780\";\n  int i;\n  int sum = 0;\n  for(i = 0; i < 9; i++) {\n    int a = 0;\n    int b = 0;\n    while(s[a]-'0' != i) a++;\n    while(s_new[b]-'0' != i) b++;\n    sum += abs(a/3-b/3) + abs(a%3-b%3);\n  }\n  return sum;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int right,left,up,down,min;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    right = distance(s_right);\n    if((k = create(s_right,flag[tag]+1))) return k;\n  }else{\n    right = INT_MAX;\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n    left = distance(s_left);\n     if((k = create(s_left,flag[tag]+1))) return k;\n  }else{\n    left = INT_MAX;\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    up = distance(s_up);\n    if((k = create(s_up,flag[tag]+1))) return k;\n  }else{\n    up = INT_MAX;\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    down = distance(s_down);\n    if((k = create(s_down,flag[tag]+1))) return k;\n  }else{\n    down = INT_MAX;\n  }\n  /*\n  min = right;\n  if(min > left) min = left;  \n  if(min > up) min = up;  \n  if(min > down) min = down;\n\n  if(right == min) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n  }\n  if(left == min) {\n    if((k = create(s_left,flag[tag]+1))) return k;\n  }\n  if(up == min) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n  }\n  if(down == min) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n  }\n  */\n\n  free(s);\n  if(s_right != NULL) free(s_right);\n  if(s_left != NULL) free(s_left);\n  if(s_up != NULL) free(s_up);\n  if(s_down != NULL) free(s_down);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define eMax 100000000\n#define existing 1234567\n#define true 1\n#define false 0\n#define nil -1\n#define Qsize 50000\n#define Psize 9\n#define N 3\ntypedef struct{\n  int state[Psize];\n  int space;\n  int path;\n} puzzule;\nint bfs(puzzule);\nint isTarget(puzzule);\nint exist(puzzule);\nint hashu(int *); //ããã·ã¥å¤ãçæããé¢æ°\nvoid enqueue(puzzule);\npuzzule dequeue(void);\nint goal[Psize] = {1, 2, 3, 4, 5, 6, 7, 8, Psize};\nint dx[N+1] = {-1, 0, 1, 0}, dy[N+1] = {0, -1, 0, 1};\nint head = 0, tail = 0;\nint e[eMax];\npuzzule queue[Qsize];\n\nint main()\n{\n  puzzule in;\n  int i;\n\n  for(i = 0 ; i < Psize ; i++){\n    scanf(\"%d\",&in.state[i]);\n    if(in.state[i] == 0){\n      in.state[i] = Psize;\n      in.space = i; }\n  }\n  \n  printf(\"%d\\n\",bfs(in));\n\n  return 0;\n}\n\nvoid enqueue(puzzule p)\n{\n  int next;\n\n  next = (tail + 1) % Qsize;\n\n  if(next != head){\n    queue[tail] = p;\n    tail = next; }\n\n}\n\npuzzule dequeue(void)\n{\n  puzzule p;\n\n  if(head != tail){\n    p = queue[head];\n    head = (head + 1) % Qsize;\n    return p; }\n  \n  }\n\nint bfs(puzzule p)\n{\n  puzzule u, v;\n  int sx, sy, tx, ty;\n  int i, ForChange;\n  \n  p.path = 0;\n  e[hashu(p.state)] = existing;\n  enqueue(p);\n\n  while(head != tail){\n    u = dequeue(); \n    if(isTarget(u) == true) return u.path;\n    sx = u.space / N;\n    sy = u.space % N;\n    for(i = 0 ; i <= N ; i++){\n      tx = sx + dx[i];      \n      ty = sy + dy[i];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      ForChange = v.state[u.space];\n      v.state[u.space] = v.state[tx * N + ty];\n      v.state[tx * N + ty] = ForChange;\n      v.space = tx * N + ty;\n      if(exist(v) != true){\n\tv.path += 1;\n\tenqueue(v); }\n    }  \n  }\n  \n  return nil;\n}\n\nint exist(puzzule p)\n{\n  if(e[hashu(p.state)] == existing) return true;\n  e[hashu(p.state)] = existing;\n\n  return false;\n}\n\nint isTarget(puzzule p)\n{\n  int i;\n  \n  for(i = 0 ; i < Psize ; i++){ \n    if(p.state[i] != goal[i]) return false; }\n  \n  return true;\n}\n\nint hashu(int *table)\n{\n  int  i, j, hash = 0, work[Psize];\n  int FACTOR[Psize] = {40320,5040,720,120,24,6,2,1,1}; // i!ã®ä¸¦ã³ã«ãªã£ã¦ããã\n  \n  for (i=0; i < Psize; i++) work[i] = table[i];\n    for (i=0; i < Psize; i++) {\n    hash += work[i] * FACTOR[i];\n    for (j=i+1; j < Psize; j++)\n      if (work[i] < work[j]) work[j]--;\n  }\n    \n    return hash;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n\nint p[N][N],t[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!p[i][j]){\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int t;\n  t = *a;\n  *a = *b;\n  *b = t;\n}\n\nint cal(){\n  int i,a,sum=0;\n  for(i=0;i<9;i++){\n    a = p[i/N][i%N];\n    if(a){\n      a--;\n      sum += abs(i/N - a/N) + abs(i%N - a%N);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int pp,int dep,const int l){\n  int i,h,sx,sy,res;\n  h = cal();\n  if(h == 0)return dep;\n  if(dep+h>l)return -1;\n  for(i=0;i<4;i++){\n    sx = x+dx[i];\n    sy = y+dy[i];\n    if(~pp && i == (pp+2)%4)continue;\n    if(!(0<=sx && sx<N && 0<=sy && sy<N))continue;\n    swap(&p[y][x],&p[sy][sx]);\n    res = dfs(sx,sy,i,dep+1,l);\n    if(~res)return res;\n    swap(&p[y][x],&p[sy][sx]);\n  }\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,k;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(k=0;k<100;k++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        t[i][j] = p[i][j];\n      }\n    }\n    ans = dfs(x,y,-1,0,k);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    else {\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          p[i][j] = t[i][j];\n        }\n      }\n      ans = -1;\n      if(k == (100-1)){\n        printf(\"%d\\n\",ans);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint P[3][3],tmp[3][3];\nint Dx[4] = {0,1,0,-1};\nint Dy[4] = {1,0,-1,0};\nvoid emp(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!P[i][j]) {\n\t*x = j;\n\t*y = i;\n      }\n    }\n  }\n}\nvoid swap(int *s,int *v){\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n}   \nint calc(){\n  int i,t,sum=0; \n  for(i=0; i<9; i++){\n    t = P[i/3][i%3];\n    if(t){\n      t--;\n      sum += abs(i/3 - t/3) + abs(i%3 - t%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int d,const int lim){\n  int i,hi,x2,y2,res;   \n  hi = calc();\n  if(hi==0) {\n    return d;\n  }\n  if(d+hi>lim) {\n    return -1;\n  }\n  for(i=0; i<4; i++){\n    x2 = x+Dx[i];\n    y2 = y+Dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n    swap(&P[y][x],&P[y2][x2]);\n    res = dfs(x2,y2,i,d+1,lim);\n    if(~res) {\n      return res;\n    }\n    swap(&P[y][x],&P[y2][x2]);\n  }   \n  return -1;\n}    \nint main() {\n  int i,j,l,ans,x,y;\n        \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++) scanf(\"%d\",&P[i][j]);\n  }\n         \n  emp(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = P[i][j];\n    }\n            \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n            \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) P[i][j] = tmp[i][j];\n    }\n            \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n        \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n  int i,j;\n  int h,ans,row,col;\n      \n  for(i=0; i<MAX; i++){\n    for(j=0; j<MAX; j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0; h<100; h++){\n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\ttemp[i][j] = pane[i][j];\n    }    \n    ans = dfs(row,col,-1,0,h);    \n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }    \n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\tpane[i][j] = temp[i][j];\n    }    \n    ans = -1;\n    if(h==99) printf(\"%d\\n\\n\",ans);\n  }      \n  return 0;\n}\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0; i<MAX; i++)\n    for(j=0; j<MAX; j++)\n      if(!pane[i][j]){\n\t*row = j;\n\t*col = i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0; i<9; i++){\n    e = pane[i/3][i%3];\n    if(e){\n      e--;\n      count += abs(i/3 - e/3) + abs(i%3 - e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i;\n  int len;\n  int x_2,y_2;\n  int emc;   \n  len = cal();\n  if(len==0) return deep;\n  if(deep+len > limt) return -1; \n  for(i=0; i<4; i++){\n    x_2 = x+d_x[i];\n    y_2 = y+d_y[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc = dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n}  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define n 3\n\ntypedef struct{\n    int A[n][n];\n}puzzle;\n\nint X[4]={0,1,0,-1};\nint Y[4]={1,0,-1.0};\n\npuzzle p;\n\nint huri();\nint dfs(int, int, int, int, int);\nvoid target(puzzle);\n\nint main(){\n    int i,j,k,x,y,t;\n    puzzle T;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            scanf(\"%d\",&p.A[i][j]);\n            if(p.A[i][j]==0){\n                x=j;\n                y=i;\n            }\n        }\n    }\n    T=p;\n    for(i=1;i<46;i++){\n        p=T;\n        t=dfs(x,y,i,0,-1);\n        if(t!=-1){\n            printf(\"%d\\n\",t);\n            break;\n        }\n    }\n    return 0;\n}\n\nint huri(){\n    int i,j,sum=0,s,t;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            if(p.A[i][j]==0)continue;\n            t=(p.A[i][j]-1)/n-i;\n            s=(p.A[i][j]-1)%n-j;\n            if(s<0)sum=sum-s;\n            else sum=sum+s;\n            if(t<0)sum=sum-t;\n            else sum=sum+t;\n        }\n    }\n    return sum;\n}\nint dfs(int s, int t, int max, int count, int r){\n    int i,tmp,x,y,time,l;\n    l=huri();\n    if(l==0)return count;\n    else if(count+l>max)return -1;\n    for(i=0;i<4;i++){\n        x=s+X[i];\n        y=t+Y[i];\n        if((x<0||n<=x||y<0||3<=y)||(i==(r+2)%4 && r!=-1))continue;\n        tmp=p.A[t][s];\n        p.A[t][s]=p.A[y][x];\n        p.A[y][x]=tmp;\n        time=dfs(x,y,max,count+1,i);\n        if(time != -1)return time;\n        tmp=p.A[t][s];\n        p.A[t][s]=p.A[y][x];\n        p.A[y][x]=tmp;\n    }\n    return -1;\n}\n"
  },
  {
    "language": "C",
    "code": "//8 ããºã«\n//Ebitani Akira\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint array[3][3];\nint tmp[3][3];\nint Tx[4] = {0,1,0,-1};\nint Ty[4] = {1,0,-1,0};\n\n\nvoid emp(int *,int *) ;\nint calc(void);\nvoid swap(int *, int *);\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n    int i, j;\n    int l, flg;\n    int x, y;\n\n    for(i = 0 ; i < 3 ; i++){\n        for(j = 0 ; j < 3 ; j++) scanf(\"%d\", &array[i][j]);\n    }\n\n    emp(&x, &y);\n    for(l = 0 ; l < 100 ; l++){\n        for(i = 0 ; i < 3 ; i++){\n            for(j = 0 ; j < 3 ; j++){\n               tmp[i][j] = array[i][j];\n             }\n        }\n\n        flg = dfs(x, y, -1, 0, l);\n        if(flg != -1){\n            printf(\"%d\\n\", flg);\n            break;\n        }\n\n        for(i = 0 ; i < 3 ; i++){\n            for(j = 0 ; j < 3 ; j++){\n\n            array[i][j] = tmp[i][j];\n          }\n        }\n\n        flg = -1;\n\n\n        if(l == 99) printf(\"%d\\n\",flg);\n    }\n\n    return 0;\n}\n\nvoid emp(int *x,int *y) {\n\n  int i, j;\n  for(i = 0 ; i < 3 ; i++) {\n    for(j = 0 ; j < 3 ; j++) {\n      if(! array[i][j]) {\n\n        *x = j;\n        *y = i;\n      }\n    }\n  }\n\n}\n\n\nvoid swap(int *s, int *v){\n\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n\n}\n\n\nint calc(){\n\n  int i;\n  int sum=0;\n  int X;\n\n  for(i = 0 ; i < 9 ; i++){\n    X = array[i/3][i%3];\n    if(X){\n      X--;\n      sum += abs(i/3 - X/3) + abs(i % 3 - X % 3);\n    }\n  }\n  return sum;\n}\n\n\nint dfs(int x,int y,int p,int d,const int l){\n\n    int i,h;\n    int x2, y2, res;\n\n    h = calc();\n    if(h==0) {\n        return d;\n    }\n    if(d+h > l) {\n        return -1;\n    }\n    for(i = 0 ; i < 4 ; i++){\n        x2 = x + Tx[i];\n        y2 = y + Ty[i];\n\n        if(~p && i == (p+2) % 4){\n          continue;\n        }\n\n        if(!(0 <= x2 && 0 <=y2 && x2 < 3 && y2 < 3)){\n           continue;\n         }\n\n        swap(&array[y][x], &array[y2][x2]);\n        res = dfs(x2, y2, i, d+1, l);\n\n        if(~res) {\n            return res;\n        }\n        swap(&array[y][x], &array[y2][x2]);\n    }\n    return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 876543\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/1000;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m[3][3];\nint cpy[3][3];\n\nvoid input(void){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&m[i][j]);\n    }\n  }\n}\nvoid output(void){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      printf(\"%3d\",m[i][j]);\n      puts(\"\");\n    }\n }\n}\nvoid copy(int a[3][3],int b[3][3]){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      a[i][j] = b[i][j];\n    }\n }\n}\nint calc(void){\n  int i,sum = 0;\n  for(i=0;i<9;i++){\n    int a = m[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)+abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid swap(int *a, int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\nint in(int a,int b){\n  return 0<=a&&a<3&&0<=b&&b<3;\n}\nint df(int a,int b,int p,int d,const int lim){\n  int i , h=calc();\n  if(h == 0)return d;\n  if(d+h > lim)return -1;\n\n  for(i=0;i<4;i++){\n    int x= a+dx[i],y=b+dy[i];\n    int res;\n    if(~p && i == (p+2)%4)continue;\n    if(!in(x,y))continue;\n    swap(&m[b][a],&m[y][x]);\n    res = df(x,y,i,d+1,lim);\n    if(~res)return res;\n    swap(&m[b][a],&m[y][x]);\n  }\n  return -1;\n}\n\nvoid empty(int *a, int *b){\n  int i,j;\n   for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!m[i][j]){\n\t*a = j;\n\t*b = i;\n\treturn;\n      }\n    }\n   }\n}\nint s(void){\n  int a,b,lim,x;\n  empty(&a,&b);\n  for(lim = 0;lim < 50;lim++){\n    copy(cpy,m);\n    if((x = df(a,b,-1,0,lim)) != -1)return x;\n    copy(m,cpy);\n  }\n  return -1;\n}\nint main(){\n  input();\n  printf(\"%d\\n\",s());\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 3\n#define N2 9\n#define MAX 100 \n#define true 1\n#define false -1\n\nint puzzle[N][N];\nint tmp[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid swap(int *a,int *b) {\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint ca() {\n  int i,k,sum=0;\n  for(i=0;i<N2;i++) {\n    if((k=puzzle[i/3][i%3])) {\n      k--;\n      sum+=abs(i/3-k/3)+abs(i%3-k%3);\n    }\n  }\n  return sum;\n}\n\nint DFS(int x,int y,int p,int dep,const int lim) {\n  int i,h,tx,ty,res,j;\n  h=ca();\n  if(h==0) return dep;\n  if(dep+h>lim){\n    return false;\n  }\n  for(i=0;i<4;i++) {\n    tx=x+dx[i];\n    ty=y+dy[i];\n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=tx && tx<3 && 0<=ty && ty<3))continue;\n    swap(&puzzle[y][x],&puzzle[ty][tx]);\n    res=DFS(tx,ty,i,dep+1,lim);\n    if(~res)return res;\n    swap(&puzzle[y][x],&puzzle[ty][tx]);\n  }\n  \n  return false;\n}\n\nint main(){\n  int i,j,c,k;\n  int x,y,r;\n  \n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&puzzle[i][j]);\n      if(!puzzle[i][j]){\n\tx=j;\n\ty=i;\n      }\n    }\n  }\n  \n  for(k=0;k<MAX;k++) {\n    memcpy(tmp,puzzle,sizeof(puzzle));\n    c=DFS(x,y,false,0,k);\n    if(c!=false)\n      break;\n    memcpy(puzzle,tmp,sizeof(tmp));\n  }\n\n  printf(\"%d\\n\",c);\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define N 3\n#define S 9\n\ntypedef struct P{\n  int f[S],space,m;\n}Puzzle;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n\nint MDT[S][S];\n\nint limit;\nint path[100];\nPuzzle st;\n\nint get(Puzzle Z){\n  int i,sum=0;\n  for(i=0;i<S;i++){\n    if(Z.f[i] == S) continue;\n    sum+=MDT[i][Z.f[i]-1];\n  }\n  return sum;\n}\n\nint max(int a,int b){\n  if(a<b) return b;\n  else return a;\n}\nint min(int a,int b){\n  if(a<b) return a;\n  else return b;\n}\nvoid swap(int *a,int *b){\n  int t;\n  t=*a;\n  *a=*b;\n  *b=t;\n}\n\nchar dfs(int df,int p){\n  int sx,sy,tx,ty,i;\n  Puzzle tmp;\n\n  if(st.m==0)return 1;\n  if(df+st.m>limit)return 0;\n\n  sx=st.space/N;\n  sy=st.space%N;\n\n  for(i=0;i<4;i++){\n    tx=sx+dx[i];\n    ty=sy+dy[i];\n\n    if(tx<0||tx>=N||ty<0||ty>=N) continue;\n    if(max(p,i)-min(p,i)==2)continue;\n    tmp=st;\n\n    st.m-=MDT[tx*N+ty][st.f[tx*N+ty]-1];\n    st.m+=MDT[sx*N+sy][st.f[tx*N+ty]-1];\n\n    //printf(\"st.m=%d\\n\",st.m);\n\n    swap(&st.f[tx*N+ty],&st.f[sx*N+sy]);\n\n    st.space=tx*N+ty;\n    if(dfs(df+1,i)){\n      path[df]=i;\n      return 1;\n    }\n    st=tmp;\n  }\n  return 0;\n}\n\nint id(Puzzle in){\n  int i;\n  int ans=0;\n\n  in.m=get(in);\n\n  for(limit=in.m;limit<=100;limit++){\n      //  printf(\"aaa\\n\");\n    st=in;\n    if(dfs(0,-100)){\n      ans=0;;\n      for(i=0;i<limit;i++) ans++;\n      return ans;\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i,j;\n  Puzzle in; \n  for(i=0;i<S;i++) for(j=0;j<S;j++) MDT[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n  for(i=0;i<S;i++){\n    //printf(\"aaa\\n\");\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=S;\n      in.space=i;\n    }\n  }\n  printf(\"%d\\n\",id(in));\n\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nconst int Max = 3;\nint a[4][2]= {0,-1,1,0,0,1,-1,0};\nint last[9][2]= {{2,2},{0,0},{0,1},{0,2},{1,0},{1,1},{1,2},{2,0},{2,1}}; // ç®æ ç¶æçæ°å­æå¨ä½ç½®\nint k[Max][Max],k2[Max*Max],flag=0,limit,Mi;   // kç¨æ¥ä¿å­å«æ°ç ç¶æï¼k2ç¨æ¥è®¡ç®æ¼å·´é¡¿è·ç¦»\nint add(int k[Max][Max])       // æ¼åé¡¿è·ç¦»ä¸º ææçæ°å­è¦èµ°å°ç®æ ç¶æï¼æå°è¦å0æ¢çæ¬¡æ°ï¼\n{\n    int i,j;\n    int sum = 0;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n        {\n            if(k[i][j]!=0)     //å¤æ­æ¼åé¡¿è·ç¦»ä¸è½å¤æ­0ï¼\n                sum += abs(i-last[k[i][j]][0])+abs(j - last[k[i][j]][1]);  //æ±æ¼åé¡¿è·ç¦»\n        }\n    return sum;\n}\nvoid dfs(int y,int x,int len,int f)     // x,yå½å0çåæ  len ä¸ºå·²ç»èµ°äºå æ­¥äºï¼fä¸ºå½ä¸ä¸æ¬¡çæç´¢æ¹å\n{\n    int s = add(k);                     // æ±å½åç¶æçæ¼åé¡¿è·ç¦»\n    if(flag) return;                    // å¦ææ¾å°ç¬¦åçç»æï¼ä¸å¨æç´¢\n    if(len<=limit)\n    {\n        if(s==0)                        //æ¼åé¡¿è·ç¦»ä¸ºé¶ï¼ä¸ºç®æ ç¶æ\n        {\n            flag=1;\n            Mi=len;\n            return ;\n        }\n        if(len==limit) return;          //éå½å°äºæ¬è½®ç»ç¹ï¼ç»æ\n    }\n    for(int i=0; i<4; i++)\n    {\n        int tx = x + a[i][0];\n        int ty = y + a[i][1];\n        if(tx>=0&&ty>=0&&ty<3&&tx<3&&((f==-1)||i!=(f+2)%4))\n        {\n            swap(k[y][x],k[ty][tx]);    // è®©ä¸ä¸ä¸ªæ°ä¸ 0 äº¤æ¢ä½ç½®\n            if(len+add(k)<=limit)       // IDA* å¼åå°ï¼å½åèµ°çæ­¥æ° å ä¸ å½åç¶æå°è¾¾æ ç¶æçæå°æ­¥æ°ï¼\n            {\n                // è¦å°äºç­äºå½åæä¸¾å°çæå°ç ä»èµ·å§ç¶æå°è¾¾ç®æ ç¶æçæ­¥æ°ï¼ä¸è½è¶è¿ï¼\n                dfs(ty,tx,len+1,i);\n                if(flag) return ;\n            }\n            swap(k[y][x],k[ty][tx]);    //è¿å\n        }\n    }\n}\nint main()\n{\n    int i,j;\n    while(~scanf(\"%d\",&k2[0]))\n    {\n        int y,x;\n        k[0][0] = k2[0];\n        if(k2[0]==0)    //è®°å½ 0 æå¨çä½ç½®\n        {\n            y = 0;\n            x = 0;\n        }\n        for(i=1; i<Max*Max; i++)\n        {\n            scanf(\"%d\",&k2[i]);\n            k[i/3][i%3] = k2[i];//æè¾å¥çæ°å­å°äºç»´æ°ç»\n            if(k2[i]==0)        //è®°å½ 0 æå¨çä½ç½®\n            {\n                y = i/3;\n                x = i%3;\n            }\n        }\n        flag = 0;\n        limit = add(k);        // å½åè¦è¾¾å°ç®æ ç¶æçæå°æ­¥æ°ï¼\n        while(!flag&&limit<=36)\n        {\n            dfs(y,x,0,-1);\n            if(!flag)          //å¦ææ¬è½®æ²¡ææ»¡è¶³çæ¡ä»¶ï¼æ©å¤§æç´¢èå´\n                limit ++;      // æ·±æåºçº¿ +1\n        }\n        if(flag)\n            printf(\"%d\\n\",Mi);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\nint ansArr[N][N]={{1,2,3},\n\t\t  {4,5,6},\n\t\t  {7,8,0}};\nint tempArr[N][N];\nint curMinCost=40;\nvoid calcMinCost(int,int);\nint get0Row(void);\nint get0Col(void);\nint isCorrect(void);\nvoid printArr(void);//debugging\nint main(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      scanf(\"%d\",&tempArr[i][j]);\n  calcMinCost(0,0);\n  printf(\"%d\\n\",curMinCost);\n  return 0;\n}\nvoid calcMinCost(int cost,int lastMove)\n{\n  int row,col;\n  //printArr();\n  if(cost>=curMinCost) return;\n  if(isCorrect()==1)\n    {\n      curMinCost=cost;\n      return;\n    }\n  row=get0Row();\n  col=get0Col();\n  if(row!=N-1&&lastMove!=3)//slide up\n    {\n      tempArr[row][col]=tempArr[row+1][col];\n      tempArr[row+1][col]=0;\n      calcMinCost(cost+1,1);\n      tempArr[row+1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=N-1&&lastMove!=4)//slide left\n    {\n      tempArr[row][col]=tempArr[row][col+1];\n      tempArr[row][col+1]=0;\n      calcMinCost(cost+1,2);\n      tempArr[row][col+1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(row!=0&&lastMove!=1)//slide down\n    {\n      tempArr[row][col]=tempArr[row-1][col];\n      tempArr[row-1][col]=0;\n      calcMinCost(cost+1,3);\n      tempArr[row-1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=0&&lastMove!=2)//slide right\n    {\n      tempArr[row][col]=tempArr[row][col-1];\n      tempArr[row][col-1]=0;\n      calcMinCost(cost+1,4);\n      tempArr[row][col-1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n}\nint get0Row(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return i;\n}\nint get0Col(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return j;\n}\nint isCorrect(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(ansArr[i][j]!=tempArr[i][j]) return 0;\n  return 1;\n}\nvoid printArr(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  printf(\"%d \",tempArr[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint dfs(int,int,int , int);\n\nint tag();\nvoid change(int *, int *);\n\nint xarr[4]={-1,0,1,0},yarr[4]={0,-1,0,1};\nint array[3][3],sum;\nint main(){\n  int i,j,zerox,zeroy;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&array[i][j]);\n      if(array[i][j]==0){\n\t\n\tzerox=j;\n\tzeroy=i;\t\n      }\n    }\n  }\n  \n  for(sum=0;sum<32;sum++){\n    if(dfs(0,10,zerox,zeroy)==1) break;\n  }\n  printf(\"%d\\n\",sum);  /*output*/\n  return 0;\n}\nint  dfs(int dep, int prev, int zerox, int zeroy){\n  int i,xx,yy,ta;\n  ta=tag();\n  if(ta==0) return 1;\n  if(dep+ta>sum) return -1;\n  \n    for(i=0;i<4;i++){\n      if(i-prev==-2 || i-prev==2) continue;\n      xx=zerox+xarr[i];\n      yy=zeroy+yarr[i];\n      if(xx<0 || yy<0 || xx>=3 || yy>=3) continue;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n      \n      if(dfs(dep+1,i,xx,yy)==1) return 1;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n      \n    }\n    return -1;\n    \n}\n\n\n\nint tag(){\n  int i,j,num=0;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(array[i][j]==0) continue;\n      num+=abs((array[i][j]-1)/3-i)+abs((array[i][j]-1)%3-j);\n      \n \n    }\n  }\n  return num;\n}\n\n/*exchange array[zeroy][zerox] and array[yy][xx]*/\nvoid change(int * num1, int *num2){  \n  int ch;\n  ch=*num1;\n  *num1=*num2;\n  *num2=ch;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define N2 9\n#define true 1\n#define false 0\n\nint P[N][N],lim;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n\nvoid solve(int,int);\nint isTarget(void);\nint bfs(int,int,int,int);\n\nint main()  \n{\n  int i,j,px,py;\n for(i=0;i<N;i++){\n   for(j=0;j<N;j++){\n   scanf(\"%d\",&P[i][j]);\n   if(P[i][j]==0){\n     px=i;\n     py=j;  }}\n }\n solve(px,py);\n\n return 0;\n}\n\nvoid solve(int px,int py)\n{\n for(lim=0;;lim++){\n   if(bfs(0,99,px,py)){\n     printf(\"%d\\n\",lim);\n     return;}\n                  }\n}\n\nint isTarget()\n{\n  int i,j,sum=0,x,s,t;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(P[i][j]==0)continue;\n    x=P[i][j]-1;\n    s=x/N-i;\n    if(s<0)s=s*(-1);\n    t=x%N-j;\n    if(t<0)t=t*(-1);\n    sum+=s+t;}}\n  return sum;\n}\n\nint bfs(int depth,int prev,int px,int py)\n{\n  int h,r,tx,ty,p,q,z;\n  h=isTarget();\n  if(h==0)return true;\n  if(depth+h>lim)return false;\n \n    for(r=0;r<4;r++){\n      if((r-prev)==2 && (r-prev)==-2)continue;  \n      tx=px+dx[r];\n      ty=py+dy[r];\n      if(tx<0 || ty<0 || tx >=N || ty>=N)continue;\n      \n      z=P[tx][ty];\n      P[tx][ty]=P[px][py];\n      P[px][py]=z;\n     \n      if(bfs(depth+1,r,tx,ty))return true;\n      z=P[tx][ty];\n      P[tx][ty]=P[px][py];\n      P[px][py]=z;\n\t\t\t }\n  return false;\n}\n\n\n\n  \n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, current;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board;// = \"130425786\";\nBoard board;// = \"130425786\";\nconst Board target = \"123456780\";\n\n//Board history[30000];\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = INT_MAX;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  //  printf(\"[%c%c]\\n\", board[m.pos], \"UDLR\"[m.dir]);\n  if (board[m.pos]==target[m.pos]) return -1;\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step<minstep) minstep=step;\n    \n  } else {\n\n    int s2;\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  int space = strchr(board, '0')-board;\n  \n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, space);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puzz[3][3];\nint temp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y){\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(!puzz[i][j]){\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nint cal(){\n  int sum = 0;\n  for(int i=0;i<9;++i){\n    int a = puzz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  int h=cal();\n  if(h==0)return dep;\n\n  if(dep+h>lim)return -1;\n\n  for(int i=0;i<4;++i){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n\n    if(p!=-1 && i==(p+2)%4)continue;\n    \n    if(0<=nx && nx<3 && 0<=ny && ny < 3){\n      swap(&puzz[y][x],&puzz[ny][nx]);\n      int res=dfs(nx,ny,i,dep+1,lim);\n      if(res!=-1)return res;\n\n      swap(&puzz[y][x],&puzz[ny][nx]);\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,l;\n  \n  for(i=0;i<3;++i){\n    for(j=0;j<3;++j)scanf(\"%d\",&puzz[i][j]);\n  }\n\n  int x=0,y=0;\n  empty(&x,&y);\n\n  for(l=0;l<100;++l){\n    for(i=0;i<3;++i){\n      for(j=0;j<3;++j)temp[i][j] = puzz[i][j];\n    }\n \n    int ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n    for(i=0;i<3;++i){\n      for(j=0;j<3;++j)puzz[i][j] = temp[i][j];\n    }\n\n    ans  = -1;\n    if(l==99)printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<45; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // æå¤§æ°ã§æã¡åã\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // ä¸ä¸å·¦å³ã§4ååã\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : å®æ\n// FALSE : å¤±æ\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0, found;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \nstruct dep{\n    int depth,key;\n};\n \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i1,j1,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i1=i;\n                j1=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n     \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n     \n    if(i1>0 && i1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1-1][j1];\n        tmp[i1-1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>0 && j1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1-1];\n        tmp[i1][j1-1]=f;\n        dfs(tmp, n+1);\n    }\n     \n    if(i1>=0 && i1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1+1][j1];\n        tmp[i1+1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>=0 && j1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1+1];\n        tmp[i1][j1+1]=f;\n        dfs(tmp, n+1);\n    }\n     \n}\n \nint main()\n{\n    int i,j;\n    int p[N][N];\n     \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n     \n    printf(\"%d\\n\",min);\n     \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define N 3\n#define N2 9\n#define MAX 500000\n\ntypedef struct Puzzle{\n  int f[N2];\n  int space;\n  int path;\n} Puzzle ;\n\nint bfs(Puzzle s);\nvoid swap(int x, int y);\nvoid enqueue(Puzzle x);\nint sort(Puzzle p);\nint isTarget(Puzzle p);\n\nint V[MAX];\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint main(){\n  Puzzle in;\n  int ans;\n\n  for(int i = 0; i < N2; i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\t\n\n   ans = bfs(in);\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\nvoid swap(int x, int y){\n  int z;\n  z = x;\n  x = y;\n  y = z;\n}\n\n\nstruct Puzzle Q[MAX];\nint head = 0, tail = 0;\n\nvoid enqueue(Puzzle x){\nint next;\n   next = (tail+1)%MAX;  \n  Q[tail] = x;\n  tail = next;\n}\n\nPuzzle dequeue(){\n  Puzzle t; \n  t = Q[head];\n  head = (head+1)%MAX;\n  return t;\n}\n\nint sort(Puzzle p){\n  int i, j, key, count, n = 0;\n  for(i = 0, key = 1; i < N2; key *= ++i){\n    for(j = 0, count = 0; j < i; j++){\n      if(p.f[j] < p.f[i])count++;\n    }\n    n += count * key;\n  }\n  return n;\n}\n\nint isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n  \tif(p.f[i] != (i+1)) return 0;\n  }\n  return 1;\n}\n\nint bfs(Puzzle s){\n  struct Puzzle u, v;\n  s.path = 0;\n  enqueue(s);\n  V[sort(s)] = 1;\n  \n\n  while(head != tail){ \n  int sx, sy, tx, ty, num, r;\n    u = dequeue();\n    if(isTarget(u) )return u.path;\n     sx = u.space / N;\n     sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n       tx = sx + dx[r];\n       ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n      v = u;\n       num = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = num;\n      v.space = tx * N + ty;\n      if(V[sort(v)] != 1){\n\tV[sort(v)] = 1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 3\n#define NN N*N\n#define BACK 0\n#define FOUND 1\n\nint dfs(int *);\nint visit(int *, int);\nint heuristic(int *);\nvoid printpuzzle(int *);\nvoid puzzlecopy(int *, int *);\nint zettaichi(int);\n\n\nint d; //depthlimit\nint goal[NN+1];\n\nint main()\n{\n  int i, j, number;\n  int g; // current depth\n  int puzzle[NN+1]; //æ·»å­ï¼ã¯ã¤ãããªãããï¼ï¼\n  \n  puzzle[0] = 0;\n  for(i = 1; i <= NN; i++) {\n    scanf(\"%d\",&puzzle[i]);\n  }\n\n  d = heuristic(puzzle);\n  \n  goal[0] = 0;\n  goal[NN] = 0;\n   for(i = 1; i < NN; i++) {\n     goal[i] = i;\n  }\n\n\n  dfs(puzzle);\n\n  return 0;\n}\n\nint heuristic(int *puzzle)\n{\n  int i, j, x, tatecost, yokocost, totalcost = 0;\n\n  for(i = 1; i <= NN; i++) {\n    if(puzzle[i] != 0) {\n      tatecost = zettaichi((i-1)/3 - (puzzle[i]-1)/3);\n      yokocost = zettaichi((i+2)%3 - (puzzle[i]+2)%3);\n\t\n\ttotalcost += tatecost + yokocost;\n    }\n  }\n\n  return totalcost;\n}\n\nvoid printpuzzle(int *puzzle)\n{\n  int i, j, number = 1;\n  \n  for(i = 0; i < N; i++) {\n    for(j = 0; j < N; j++) {\n      printf(\" %d\",puzzle[number]);\n      number++;\n    }\n    printf(\"\\n\");\n  }\n  \n}\n\nint dfs(int *puzzle)\n{\n  int i;\n\n  while(1) {\n    if(visit(puzzle, 0) == FOUND) break;\n    d++;\n  }\n\n  return i;\n}\n\nint visit(int *puzzle, int g)\n{\n  int i, blanknumber, status, found;\n  int copypuzzle[NN+1];\n\n  found = 1;\n  for(i = 1; i <= NN; i++) {\n    if(puzzle[i] != goal[i]) {\n      found = 0;\n      break;\n    }\n  }\n  if(found == 1) {\n    printf(\"%d\\n\",g);\n    return FOUND;\n  }\n  \n  if(g + heuristic(puzzle) > d) return BACK;\n\n  //ç©ºç½ä½ç½®ã®ç¢ºèª\n  for(i = 1; i <= NN; i++) {\n    if(puzzle[i] == 0) {\n      blanknumber = i;\n      break;\n    }\n  }\n\n  //0ãä¸ã¨äº¤æ\n  if((blanknumber-1)/3 != 2) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber+3];\n    copypuzzle[blanknumber+3] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  //0ãå³ã¨äº¤æ\n  if((blanknumber+2)%3 != 2) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber+1];\n    copypuzzle[blanknumber+1] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  //0ãå·¦ã¨äº¤æ\n  if((blanknumber+2)%3 != 0) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber-1];\n    copypuzzle[blanknumber-1] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  //0ãä¸ã¨äº¤æ\n  if((blanknumber-1)/3 != 0) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber-3];\n    copypuzzle[blanknumber-3] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  return BACK;\n}\n\n\nint zettaichi(int x)\n{\n  if(x < 0) x = -x;\n  return x;\n}\n\nvoid puzzlecopy(int *puzzle, int *copypuzzle)\n{\n  int i;\n  \n  for(i = 1; i <= NN; i++) {\n    copypuzzle[i] = puzzle[i];\n  }\n}\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 300007 // 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 30000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 21\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<stdbool.h>\n#define N 3\n#define M 9\n#define MAX 362880 \nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\ntypedef struct{\n  int f[M];\n  int path;\n  int none;\n}pazzle;\npazzle A[MAX];\nint B[MAX];\nint head,tail;\n\nint empty(void);\nint check(pazzle);\npazzle front(void);\nvoid push(pazzle);\nbool isTarget(pazzle);\nint bfs(pazzle);\n\nint main(){\n  pazzle X;\n  int answer,i;\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&X.f[i]);\n    if(X.f[i]==0){\n      X.f[i]=M;\n      X.none=i;\n    }\n  }\n  answer=bfs(X);\n  printf(\"%d\\n\",answer);\n  return 0;\n}\n\nint bfs(pazzle X){\n  int sx,sy,tx,ty,i,temp;\n  pazzle a,b;\n  X.path=0;\n  push(X);\n  B[check(X)]=1;\n  while(!empty()){\n    a=front();\n    if(isTarget(a))\n      return a.path;\n    sx=a.none/N;\n    sy=a.none%N;\n    for(i=0;i<4;i++){\n      tx=sx+dx[i];\n      ty=sy+dy[i];\n      if(tx<0||ty<0||tx>=N||ty>=N)\n\tcontinue; \n      b=a;\n      temp=b.f[a.none];\n      b.f[a.none]=b.f[tx*N+ty];\n      b.f[tx*N+ty]=temp;\n      b.none=tx*N+ty;\n      if(!B[check(b)]){\n\tB[check(b)]=1;\n\tb.path++;\n\tpush(b);\n      }\n    }\n  }\n  return -1;\n}\n\nbool isTarget(pazzle X){\n  int i,j;\n  for(i=0;i<M;i++){\n    if(X.f[i]!=(i+1))\n      return false;\n  }\n  return true;\n}\n\nvoid push(pazzle X){\n  A[tail]=X;\n  tail=(tail+1)%MAX;\n}\n\npazzle front(void){\n  pazzle x;\n  x=A[head];\n  head=(head+1)%MAX;\n  return x;\n}\n\nint check(pazzle x){\n  int i,j,z,count,result=0;\n  for(i=0,z=1;i<M;z*=++i){\n    for(j=0,count=0;j<i;j++){\n      if(x.f[j]<x.f[i])\n\tcount++;\n    }\n    result+=count*z;\n  }\n  return result;\n}\n\nint empty(void){\n  return head==tail;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n\nextern inline void down_0(void);    // 0 ãä¸ã«ç§»å\nextern inline void up_0(void);      // 0 ãä¸ã«ç§»å\nextern inline void right_0(void);   // 0 ãå³ã«ç§»å\nextern inline void left_0(void);    // 0 ãå·¦ã«ç§»å\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;        // 0 ã®ä½ç½®ãç¤ºã\nint val[Total] ={}; // æ°å¤éå\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    // æå­åã®åãè¾¼ã¿\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    // å³ä¸ã«è¡ãããã« 0 ãä½ååããã°ãããã\n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=0; i<TryCnt; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    if(MaxCnt < (x + y) )\n    {\n        return 0;\n    }\n    \n    // æå¤§æ°ã§ã´ã¼ã«ã¨ä¸è´ãã¦ãããç¢ºèª\n    if(MaxCnt==0)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ã´ã¼ã«ã¨ä¸ä¸è´\n                return 0;\n            }\n        }\n        // ã´ã¼ã«ã¨ä¸è´ï¼ï¼\n        return 1;\n    }\n    \n    \n    // 0 ã®ç§»å\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n                \n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n                \n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n                \n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n                \n            default:\n                // ä½ãããªãã\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 5) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>         \n#include <stdlib.h>         \n#define N 3\n#define NIL -1\n#define NN 100\n\nint p8[N][N];\nint temp[N][N];\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\nvoid et(int *,int *);\nint cl();\nvoid swap(int *,int *);\nint dfs(int,int,int,int, int);\n\n\nint main(){\n  int i,j,d,a,x=0,y=0;\n  for (i = 0; i < N; ++i){\n    for (j = 0; j < N; ++j){\n      scanf(\"%d\", &p8[i][j]);\n    }\n\t}\n  et(&x, &y);\n\n  for (d = 0; d < NN; d++){\n    for (i = 0; i < N; i++){\n      for(j = 0; j < N; j++){\n\ttemp[i][j] = p8[i][j];\n      }\n    }\n    a = dfs(x, y, -1, 0, d);\n    if (a != -1){  \n      printf(\"%d\\n\", a);\n      break;\n    }\n\n    for (i = 0; i < N; ++i){\n      for(j = 0; j < N; ++j){\n       p8[i][j] = temp[i][j];\n      }\n    }\n    a = NIL;\n    if (d == NN-1)\n      printf(\"%d\\n\", a);\n  }\n\n\n  return 0;\n}\nvoid et(int *x, int *y){\n  int i,j;\n  for (i = 0; i < N; i++){\n    for (j = 0; j < N; j++){\n      if (!p8[i][j]){\n\t*x = j;\n\t*y = i;\n\t\n\treturn;\n      }\n    }\n  }\n}\n\nint cl(){\n\n  int sm = 0,i,a;\n  for (i = 0; i < 9; ++i){\n     a = p8[i / 3][i % 3];\n    if (a){\n      a--;\n      sm += abs(i / 3 - a / 3) + abs(i % 3 - a % 3);\n    }\n  }\n  return sm;\n}\n\nint dfs(int x, int y, int p, int dp, int lim){\n  int h,i,y1,x1,re;\n  h = cl();\n  if (h == 0)\n    return dp;\n\n  if (dp + h > lim) return NIL;\n  for (i = 0; i < 4; ++i){\n     x1 = x + dx[i];\n     y1 = y + dy[i];\n    if (p != NIL && i == (p + 2) % 4)continue;\n    if (0 <= x1 && x1 < N && 0 <= y1 && y1 < N){\n      swap(&p8[y][x], &p8[y1][x1]);\n      re = dfs(x1, y1, i, dp + 1, lim);\n      if (re != NIL)return re;\n      \n      swap(&p8[y][x], &p8[y1][x1]);\n    }\n  }\n\n  return NIL;\n}\nvoid swap(int *a, int *b){\n\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n\n#define N 3\n#define M 9\n#define MAX 10000000\n\n\n struct Puzzle{\n  int f[M];\n  int path;\n  int space;\n};\n\ntypedef struct Puzzle puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\npuzzle Q[MAX];\nint head,tail,ori[MAX];\n\nint empty(void);\nvoid enqueue(puzzle );\npuzzle dequeue(void);\nint cheak(puzzle );\nint isTarget(puzzle );\nint bfs(puzzle p);\n\nint main()\n{\n  int i,x;\n  puzzle p;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&p.f[i]);\n    if(p.f[i]==0){\n      p.f[i]=M;\n      p.space=i;\n    }\n  }\n\n  x=bfs(p);\n\n  printf(\"%d\\n\",x);\n\n  return 0;\n\n}\n\nint empty()\n{\n  return head==tail;\n}\n\nvoid enqueue(puzzle x)\n{\n  Q[tail]=x;\n  tail=(tail+1)%MAX;\n}\n\npuzzle dequeue()\n{\n  puzzle x;\n\n  x=Q[head];\n  head=(head+1)%MAX;\n\n  return x;\n\n}\n\nint cheak(puzzle p)\n{\n  int i,j,fac,count,num=0;\n\n  for(i=0,fac=1;i<M;fac*=++i){\n    for(j=0,count=0;j<i;j++)\n      if(p.f[j]<p.f[i]) count++;\n      num+=count*fac;\n}\n\n  return num;\n\n}\n\nint isTarget(puzzle p)\n{\n  int i;\n\n  for(i=0;i<M;i++)\n    if(p.f[i]!=(i+1)) return 0;\n    return 1;\n}\n\nint bfs(puzzle p)\n{\n  int x,y,tx,ty,r,temp;\n  puzzle u, v;\n\n  p.path=0;\n  enqueue(p);\n  ori[cheak(p)]=1;\n\n  while(!empty()){\n    u=dequeue();\n    if(isTarget(u)) return u.path;\n    x=u.space/N;\n    y=u.space%N;\n\n    for(r=0;r<4;r++){\n      tx=x+dx[r];\n      ty=y+dy[r];\n      if(tx<0 || tx>=N || ty<0 || ty >= N) continue;\n      v=u;\n      temp=v.f[u.space];\n      v.f[u.space]=v.f[tx*N+ty];\n      v.f[tx*N+ty]=temp;\n      v.space=tx*N+ty;\n      if(!ori[cheak(v)]){\n\t       ori[cheak(v)]=1;\n\t       v.path++;\n\t       enqueue(v);\n      }\n    }\n  }\n\n  return -1;\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX 3\nint ar[MAX][MAX];\nint tmp[MAX][MAX];\nint arx[4]={0,1,0,-1};\nint ary[4]={1,0,-1,0};\nvoid judgeof0(int *,int *);\nvoid swap(int *,int *);\nint cal(void);\nint dfs(int,int,int,int,const int);\n\nint main(){\n  int i,j,ans,x,y,k;\n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++){\n      scanf(\"%d\",&ar[i][j]);\n    }\n  }\n  judgeof0(&x,&y);\n  for(i=0;i<100;i++){\n    for(j=0;j<MAX;j++){\n      for(k=0;k<MAX;k++){\n\ttmp[j][k]=ar[j][k];\n      }\n    }\n  \n  ans=dfs(x,y,-1,0,i);\n  if(ans!=-1){\n    printf(\"%d\\n\",ans);\n    break;\n  }\n  for(j=0;j<MAX;j++){\n    for(k=0;k<MAX;k++){\n      ar[j][k]=tmp[j][k];\n    }\n  }\n  ans=-1;\n  if(i==99)printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\nvoid judgeof0(int x[],int y[]){\n  int i,j;\n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++){\n      if(!ar[i][j]){\n\t*x=j;\n\t*y=i;\n\treturn;\n      }\n    }\n  }\n\n}\n\nvoid swap(int x[],int y[]){\n  int tmp;\n  tmp=*x;\n  *x=*y;\n  *y=tmp;\n\n}\nint cal(){\n  int i,tmp,sum=0;\n  for(i=0;i<9;i++){\n    tmp=ar[i/MAX][i%MAX];\n    if(tmp){\n      tmp--;\n      sum+=abs((i/MAX)-(tmp/MAX))+abs((i%MAX)-(tmp%MAX));\n    }\n\n  }\n\n  return sum;\n}\n\nint dfs(int x,int y,int t,int dep,const int lim){\n  int i,x1,y1,res,h;\n  h=cal();\n  if(h==0)return dep;\n  if(dep+h>lim)return -1;\n  for(i=0;i<4;i++){\n    x1=x+arx[i];\n    y1=y+ary[i];\n  \n  if(~t && i==(t+2)%9){\n    continue;\n  }\n  if(!(x1>=0&&x1<MAX&&y1>=0&&y1<MAX)){\n    continue;\n  }\n  swap(&ar[y][x],&ar[y1][x1]);\n  res=dfs(x1,y1,i,dep+1,lim);\n  if(~res){\n    return res;\n  }\n  swap(&ar[y][x],&ar[y1][x1]);\n}\n  return -1;\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N - 1; i++) {\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  break;\n\t}\n      }\n      if (board[r][c] == i) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = 9;\n        int i;\n        char[] s = new char[n];\n        for (i=0;i<n;i++) {\n            s[i] = (char)('0' + scan.nextInt());\n        }\n\n        String ans = \"123456780\";\n        int[] d = {-3, 3, -1, 1};\n\n        HashMap<String, Integer> hm = new HashMap<String, Integer>();\n\n        Queue<String> q = new ArrayDeque<String>();\n        q.add(toString(s));\n        hm.put(toString(s), 0);/*sãã­ã¼ã§ï¼ãå¤*/\n\n        while (!q.isEmpty()) {\n            String u = q.remove();/*åé ­ãåå¾ãã¦åé¤*/\n            if (u.equals(ans)) {\n                System.out.println(hm.get(u));\n                break;\n            }\n\n            StringBuffer str = new StringBuffer(u);\n            int zero = str.indexOf(\"0\");/*ï¼ãåºç¾ããä½ç½®ã®ã¤ã³ããã¯ã¹*/\n            for (i=0;i<d.length;i++) {\n                if (zero+d[i]>=0 && zero+d[i]<n && !(d[i]==-1 && (zero+d[i])%3==2) && !(d[i]==1 && (zero+d[i])%3==0)) {\n                    str.setCharAt(zero, str.charAt(zero + d[i]));/*æ°å­ã®å¥ãæ¿ã*/\n                    str.setCharAt(zero + d[i], '0');\n                    if (!hm.containsKey(str.toString())) {/*ã­ã¼ãå­å¨ããã*/\n                        q.add(str.toString());\n                        hm.put(str.toString(), hm.get(u) + 1);\n                    }\n                    str.setCharAt(zero + d[i], str.charAt(zero));\n                    str.setCharAt(zero, '0');\n                }\n            }\n        }\n    }\n\n    static String toString(char[] s) {\n        String ret = \"\";\n        int i;\n        for (i=0;i<s.length;i++) {\n            ret += s[i];\n        }\n\n        return ret;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while (count<3){\n            s = sc.nextLine();\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iterNew.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint[] input = new int[9];\n\t\tString[] first = s.nextLine().split(\" \");\n\t\tinput[0] = Integer.parseInt(first[0]);\n\t\tinput[1] = Integer.parseInt(first[1]);\n\t\tinput[2] = Integer.parseInt(first[2]);\n\n\t\tString[] second = s.nextLine().split(\" \");\n\t\tinput[3] = Integer.parseInt(second[0]);\n\t\tinput[4] = Integer.parseInt(second[1]);\n\t\tinput[5] = Integer.parseInt(second[2]);\n\n\t\tString[] three = s.nextLine().split(\" \");\n\t\tinput[6] = Integer.parseInt(three[0]);\n\t\tinput[7] = Integer.parseInt(three[1]);\n\t\tinput[8] = Integer.parseInt(three[2]);\n\n\t\tSystem.out.println(solve(input));\n\t}\n\n\tpublic static int solve(int[] input) {\n\t\tint cnt = 0;\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\tLinkedList<Integer> cntQueue = new LinkedList<Integer>();\n\t\tHashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();\n\t\tqueue.offer(input);\n\t\tcntQueue.offer(0);\n\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[] ban = queue.poll();\n\t\t\tcnt = cntQueue.poll();\n\t\t\t//??????\n\t\t\tif(check(ban))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\t\t\tif(ban[i] == 0)\n\t\t\t\t\t\tzeroIndex = i;\n\t\t\t\t}\n\n\t\t\t\tswitch (zeroIndex) {\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 0:\n\t\t\t\t\tint[] copyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tint hash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????Â´???\n\t\t\t\tcase 1:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 2:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????Â´???\n\t\t\t\tcase 3:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//???????????????????????Â´???\n\t\t\t\tcase 4:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????Â´???\n\t\t\t\tcase 5:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 6:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????Â´???\n\t\t\t\tcase 7:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 8:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tstatic int[] value = {84, 19, 129, 67, 28, 222, 83, 80, 21};\n\tpublic static int hash(int[] ban) {\n\t\tint total = 0;\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\ttotal += (ban[i]*value[i]);\n\t\t}\n\t\treturn total%123;\n\t}\n\n\n\n\tpublic static boolean check(int[] ban) {\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\tif(i!=8 && ban[i]!=(i+1))\n\t\t\t\treturn false;\n\t\t\tif(i==8 && ban[i]!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = 9;\n\t\tchar[] s = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = (char)('0' + sc.nextInt());\n\t\t}\n\t\t\n\t\tString ans = \"123456780\";\n\t\tint[] d = {-3, 3, -1, 1};\n\t\t\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\n\t\tQueue<String> q = new ArrayDeque<String>();\n\t\tq.add(toString(s));\n\t\thm.put(toString(s), 0);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tif (u.equals(ans)) {\n\t\t\t\tSystem.out.println(hm.get(u));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tStringBuffer str = new StringBuffer(u);\n\t\t\tint zero = str.indexOf(\"0\");\n\t\t\tassert (zero != -1);\n\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\tif (zero + d[i] >= 0 && zero + d[i] < n && !(d[i] == -1 && zero + d[i] % 3 == 2) && !(d[i] == 1 && zero + d[i] % 3 == 0)) {\n\t\t\t\t\tstr.setCharAt(zero, str.charAt(zero + d[i]));\n\t\t\t\t\tstr.setCharAt(zero + d[i], '0');\n\t\t\t\t\tif (!hm.containsKey(str.toString())) {\n\t\t\t\t\t\tq.add(str.toString());\n\t\t\t\t\t\thm.put(str.toString(), hm.get(u) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tstr.setCharAt(zero + d[i], str.charAt(zero));\n\t\t\t\t\tstr.setCharAt(zero, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        sc.close();\n\t}\n\t\n\tprivate static String toString(char[] s) {\n\t\tString ret = \"\";\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tret += s[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Queue<Puzzle> queue=new LinkedList<Puzzle>();\n\tstatic Map<String, Integer> map=new HashMap<>();\n\tstatic int[][] goal;\n\t\n\tstatic class Puzzle{\n\t\tint[][] p=new int[4][4];\n\t\tint step;\n\t\tPuzzle(int[][] p, int step){\n\t\t\tthis.step=step;\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tthis.p[i][j]=p[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int bfs() {\n\t\tint minstep=0;\n\t\tint[][] dt={{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[][] field=new int[4][4];\n\t\t\tString str=\"\";\n\t\t\tint r=0, c=0;\n\t\t\tPuzzle q=queue.remove();\n\t\t\tboolean tf=true;\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tfield[i][j]=q.p[i][j];\n\t\t\t\t\tstr+=String.valueOf(field[i][j]);\n\t\t\t\t\tif(q.p[i][j]==0) {\n\t\t\t\t\t\tr=i;\n\t\t\t\t\t\tc=j;\n\t\t\t\t\t}\n\t\t\t\t\tif(q.p[i][j]!=goal[i][j]) {\n\t\t\t\t\t\ttf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tminstep=q.step;\n\t\t\tif(tf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map.get(str)!=null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap.put(str, minstep);\n\t\t\t\n\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\tif(r+dt[i][0]>2 || r+dt[i][0]<0 || c+dt[i][1]>2 || c+dt[i][1]<0){\n\t\t            continue;\n\t\t        }\n\t\t\t\tint swap=field[r][c];\n\t\t\t\tfield[r][c]=field[r+dt[i][0]][c+dt[i][1]];\n\t\t\t\tfield[r+dt[i][0]][c+dt[i][1]]=swap;\n\t\t\t\tqueue.add(new Puzzle(field, minstep+1));\n\t\t\t\tswap=field[r][c];\n\t\t\t\tfield[r][c]=field[r+dt[i][0]][c+dt[i][1]];\n\t\t\t\tfield[r+dt[i][0]][c+dt[i][1]]=swap;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn minstep;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tgoal=new int[4][4];\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tgoal[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] start=new int[4][4];\n\t\t\tint count=1;\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tstart[i][j]=count%9;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue.add(new Puzzle(start, 0));\n\t\t\tSystem.out.println(bfs());\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tclass Pazzle {\n\t\tint y, x;\n\t\tint[][] board;\n\t\tPazzle(int y, int x, int[][] board) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.board = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tthis.board[i][j] = board[i][j];\n\t\t}\n\t\tPazzle(Pazzle p) {\n\t\t\tthis.y = p.y;\n\t\t\tthis.x = p.x;\n\t\t\tboard = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tboard[i][j] = p.board[i][j];\n\t\t}\n\t\tString boardToString() {\n\t\t\tString str = \"\";\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tstr += Integer.toString(board[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\tvoid swapBoard(int ny, int nx) {\n\t\t\tint tmp = board[y][x];\n\t\t\tboard[y][x] = board[ny][nx];\n\t\t\tboard[ny][nx] = tmp;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t\tvoid printDebug() {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tSystem.out.print(board[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tfinal int N = 3;\n\tint[][] board;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tboard = new int[N][N];\n\t\tint y = 0, x = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tboard[i][j] = scan.nextInt();\n\t\t\t\tif (board[i][j] == 0) {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue<Pazzle> que = new LinkedList<Pazzle>();\n\t\tHashSet<String> hash = new HashSet<String>();\n\t\tque.add(new Pazzle(y, x, board));\n\t\tString ansPazzle = \"123456780\";\n\t\tint ans = 0;\n\t\tint[] dy = { 1, 0, -1, 0 };\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\twhile (!que.isEmpty()) {\n\t\t\tint length = que.size();\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tPazzle p = que.poll();\n\t\t\t\tString boardStr = p.boardToString();\n\t\t\t\tif (boardStr.equals(ansPazzle)) {\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thash.add(boardStr);\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint ny = p.y + dy[j];\n\t\t\t\t\tint nx = p.x + dx[j];\n\t\t\t\t\tif (ny >= 0 && nx >= 0 && ny < N && nx < N) {\n\t\t\t\t\t\tPazzle np = new Pazzle(p);\n\t\t\t\t\t\tnp.swapBoard(ny, nx);\n\t\t\t\t\t\tif (hash.contains(np.boardToString()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tque.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            close.remove(iterNode);\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements  Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue-y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\tprivate int[] up = {-1,0};\n\tprivate int[] down = {1,0};\n\tprivate int[] left = {0,-1};\n\tprivate int[] right = {0,1};\n\t\n\tpublic static int sum=0;\n\tprivate final int UP = 0;\n\tprivate final int DOWN = 2;\n\tprivate final int LEFT = 1;\n\tprivate final int RIGHT = 3;\n\t\n\tprivate static int SIZE = 3;\n\t\n\t\n\tprivate int[][] targetPoints; \n\t\n\t\n\tprivate static int[] moves = new int[100000];\n\t\n\tprivate static long ans = 0;\n\t\n\t\n\tprivate static int[][] tState = {\n\t\t{1 ,2 ,3 } ,\n\t\t{4, 5 ,6 } ,\n\t\t{7, 8 ,0 } ,\n\t};\n\t\n\tprivate static int[][] sState;\n\t\n\n\t\n\tprivate static int blank_row,blank_column;\n\t\n\tpublic Main(int[][] state) {\n\t\tSIZE = state.length;\n\t\ttargetPoints = new int[SIZE * SIZE][2];\n\t\t\n\t\tthis.sState = state;\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\tblank_row = i;\n\t\t\t\t\tblank_column = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\ttargetPoints[tState[i][j]][0] = i; \n\t\t\t\t\n\t\t\t\ttargetPoints[tState[i][j]][1] = j; \n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tsState = new int[SIZE][SIZE];\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++)\n\t\t\t\tsState[i][j]=sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tMain idaAlgorithm = new Main(sState);\n\t\t\n\t\n\t\tint j = idaAlgorithm.getHeuristic(sState);\n\t\t\n\t\tint i = -1;\n\t\t\n\t\t\n\t\tfor(ans=j;;ans++) {\n\t\t\tif(idaAlgorithm.solve(sState\n\t\t\t\t\t,blank_row,blank_column,0,i,j)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tif(ans != 0) {\n\t\t\tint[][] matrix = idaAlgorithm.move(sState,moves[0]);\n\t\t\tfor(int k=1;k<ans;k++) {\n\t\t\t\tmatrix = idaAlgorithm.move(matrix, moves[k]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\n\tpublic int[][] move(int[][]state,int direction) {\n\t\tint row = 0;\n\t\tint column = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\trow = i;\n\t\t\t\t\tcolumn = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch(direction) {\n\t\tcase UP:\n\t\t\tstate[row][column] = state[row-1][column];\n\t\t\tstate[row-1][column] = 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tstate[row][column] = state[row+1][column];\n\t\t\tstate[row+1][column] = 0;\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tstate[row][column] = state[row][column-1];\n\t\t\tstate[row][column-1] = 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tstate[row][column] = state[row][column+1];\n\t\t\tstate[row][column+1] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsum++;\n\t\treturn state;\n\t}\n\t\n\t\n\t\n\t\n\tpublic boolean solve(int[][] state,int blank_row,int blank_column,\n\t\t\tint dep,long d,long h) {\n\t\t\n\t\tlong h1;\n\t\t\n\t\t\n\t\tboolean isSolved = true;\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++) {\n\t\t\t\tif(state[i][j] != tState[i][j]) {\n\t\t\t\t\tisSolved = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isSolved) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(dep == ans) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\n\t\tint blank_row1 = blank_row;\n\t\tint blank_column1  = blank_column;\n\t\tint[][] state2 = new int[SIZE][SIZE];\n\n\t\tfor(int direction=0;direction<4;direction++) {\n\t\t\tfor(int i=0;i<state.length;i++) {\n\t\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\t\tstate2[i][j] = state[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(direction != d && (d%2 == direction%2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(direction == UP) {\n\t\t\t\tblank_row1 = blank_row + up[0];\n\t\t\t\tblank_column1 = blank_column + up[1];\n\t\t\t} else if(direction == DOWN) {\n\t\t\t\tblank_row1 = blank_row + down[0];\n\t\t\t\tblank_column1 = blank_column + down[1];\n\t\t\t} else if(direction == LEFT) {\n\t\t\t\tblank_row1 = blank_row + left[0];\n\t\t\t\tblank_column1 = blank_column + left[1];\n\t\t\t} else {\n\t\t\t\tblank_row1 = blank_row + right[0];\n\t\t\t\tblank_column1 = blank_column + right[1];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(blank_column1 < 0 || blank_column1 == SIZE\n\t\t\t\t\t|| blank_row1 < 0 || blank_row1 == SIZE) {\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\tstate2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n\t\t\tstate2[blank_row1][blank_column1] = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(direction == DOWN && blank_row1 \n\t\t\t\t\t> targetPoints[state[blank_row1][blank_column1]][0]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == UP && blank_row1 \n\t\t\t\t\t< targetPoints[state[blank_row1][blank_column1]][0]){\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == RIGHT && blank_column1 \n\t\t\t\t\t> targetPoints[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == LEFT && blank_column1 \n\t\t\t\t\t< targetPoints[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else { \n\t\t\t\t\n\t\t\t\th1 = h + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(h1+dep+1>ans) { \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmoves[dep] = direction;\n\t\t\t\n\t\t\t\n\t\t\tif(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tpublic int getHeuristic(int[][] state) {\n\t\tint heuristic = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] != 0) {\n\t\t\t\t\theuristic = heuristic + \n\t\t\t\t\t\t\tMath.abs(targetPoints[state[i][j]][0] - i)\n\t\t\t\t\t\t\t+ Math.abs(targetPoints[state[i][j]][1] - j);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn heuristic;\n\t}\n\t\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while ((s = sc.nextLine())!=null&&count<3){\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static final int SIZE = 3;\n\tpublic static final int ALL_SIZE = SIZE * SIZE;\n\t\n\tpublic static int[] factor=  {\n\t\t1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880\n\t}; //0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\t\n\t//å®å¨æå°ããã·ã¥ãä½ã.\n\tpublic static int hash(int[] A){\n\t\tint[] A_ = new int[A.length];\n\t\tSystem.arraycopy(A, 0, A_, 0, A.length);\n\t\t\n\t\tint ret = 0;\n\t\t\n\t\tfor(int i = 0; i < A_.length; i++){\n\t\t\tret += A_[i] * factor[(A.length - i - 1)];\n\t\t\t\n\t\t\tfor(int j = i + 1; j < A_.length; j++){\n\t\t\t\tif(A_[j] >= A_[i]){ A_[j]--; }\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int[] unhash(int hash){\n\t\tint[] ret = new int[ALL_SIZE];\n\t\t\n\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\tret[i] = hash / factor[ALL_SIZE - i - 1];\n\t\t\thash -= factor[ALL_SIZE - i - 1] * ret[i];\n\t\t}\n\t\t\n\t\tfor(int i = ALL_SIZE - 1; i >= 0; i--){\n\t\t\tfor(int j = i + 1; j < ALL_SIZE; j++){\n\t\t\t\tif(ret[i] <= ret[j]) ret[j]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\tpublic static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0});\n\tpublic static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n\t\n\tpublic static final int[] moves = new int[]{1, -1, SIZE, -SIZE};\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//System.out.println(Arrays.toString(unhash(GOAL)));\n\t\t\n\t\tint[] visited = new int[MAX];\n\t\tArrays.fill(visited, Integer.MAX_VALUE);\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\n\t\tint[] input = new int[ALL_SIZE];\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tinput[i * SIZE + j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int hash_input = hash(input);\n\t\tqueue.add(hash_input);\n\t\tvisited[hash_input] = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal int hashed = queue.poll();\n\t\t\t\n\t\t\tif(hashed == GOAL){\n\t\t\t\tSystem.out.println(visited[hashed]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int dist = visited[hashed];\n\t\t\t\n\t\t\tint[] ret = unhash(hashed);\n\t\t\t\n\t\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\t\tif(ret[i] == 0){\n\t\t\t\t\tfor(int move : moves){\n\t\t\t\t\t\tif(i + move >= 0 && i + move < ALL_SIZE){\n\t\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\t\tret[i] = ret[i + move];\n\t\t\t\t\t\t\tret[i + move] = tmp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\t\tret[i] = ret[i + move];\n\t\t\t\t\t\t\tret[i + move] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue(endStatus);\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iterNew.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue(int[][] endStatus)\n    {\n        int k=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j] != endStatus[i][j])\n                {\n                    k+=1;\n                }\n            }\n        }\n        return k;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tclass Pazzle {\n\t\tint y, x;\n\t\tint[][] board;\n\t\tPazzle(int y, int x, int[][] board) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.board = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tthis.board[i][j] = board[i][j];\n\t\t}\n\t\tPazzle(Pazzle p) {\n\t\t\tthis.y = p.y;\n\t\t\tthis.x = p.x;\n\t\t\tboard = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tboard[i][j] = p.board[i][j];\n\t\t}\n\t\tString boardToString() {\n\t\t\tString str = \"\";\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tstr += Integer.toString(board[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\tvoid swapBoard(int ny, int nx) {\n\t\t\tint tmp = board[y][x];\n\t\t\tboard[y][x] = board[ny][nx];\n\t\t\tboard[ny][nx] = tmp;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t\tvoid printDebug() {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tSystem.out.print(board[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tfinal int N = 3;\n\tint[][] board;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tboard = new int[N][N];\n\t\tint y = 0, x = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tboard[i][j] = scan.nextInt();\n\t\t\t\tif (board[i][j] == 0) {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue<Pazzle> que = new LinkedList<Pazzle>();\n\t\tHashSet<String> hash = new HashSet<String>();\n\t\tque.add(new Pazzle(y, x, board));\n\t\tString ansPazzle = \"123456780\";\n\t\tint ans = 0;\n\t\tint[] dy = { 1, 0, -1, 0 };\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\twhile (!que.isEmpty()) {\n\t\t\tint length = que.size();\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tPazzle p = que.poll();\n\t\t\t\tString boardStr = p.boardToString();\n\t\t\t\tif (boardStr.equals(ansPazzle)) {\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thash.add(boardStr);\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint ny = p.y + dy[j];\n\t\t\t\t\tint nx = p.x + dx[j];\n\t\t\t\t\tif (ny >= 0 && nx >= 0 && ny < N && nx < N) {\n\t\t\t\t\t\tPazzle np = new Pazzle(p);\n\t\t\t\t\t\tnp.swapBoard(ny, nx);\n\t\t\t\t\t\tif (hash.contains(np.boardToString()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tque.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (100,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue - y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus)\n    {\n        this.startStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n//    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "package sample;\n\nimport java.util.Scanner;\n\n/**\n * IDA*?Â±??Â§Â£15puzzle????Â¢?\n * IDA*??Â´??????IDDFS???A*???????????Â¶???IDDFS??Â§??Â¶????Â±??Â§Â£????Â¨??????????????????????A*???????????????\"?????????\"????Â´Â¢???\n * IDA*?????\\????Â§Â£????????Â£??Â±??????A*???????????Â¶????????????\"??Â±???\"?????????????Â¢?????Â§Â£???\"????????????\"???\n * ???\"????????????\"???????????Â£?Â¢????????Â£???????????????Â¨\"????????????\"??????????????Â°???????Â§Â£?????????????????????????Â°Â±??Â§????????Â£???\n * ?????????A*???????????????????????????????????Â¨?????Â±????????Â¨???IDDFS????????\\???IDA*?????Â±?????????????Â´Â¢?????????????????????????????Â¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class IDAStarAlgorithm {\n\n    //????????Â£??Â¨????????????????????????????Â§???Â¨?????????????????Â°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??Â¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????Â¢??Â£???????????Â¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????Â§???Â¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??Â¨?????Â°????Â§???Â¨??\\???????????Â¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????Â£???\"????????Â£???\"\n\n    //????????Â¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public IDAStarAlgorithm(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????Â°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????Â°?????????????????Â°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    /**\n     * ??Â¨???????Â¢????????Â§Â£??Â§\n     * @param state ??Â¶???\n     */\n    private boolean canSolve(int[][] state) {\n        if(state.length % 2 == 1) { //????Â¢???????????\\???Â°\n            return (getInversions(state) % 2 == 0);\n        } else { //????Â¢????????????Â¶??Â°\n            if((state.length - blank_row) % 2 == 1) { //??????????????Â°,?????????????\\???Â°???\n                return (getInversions(state) % 2 == 0);\n            } else { //??????????????Â°,??????????????Â¶??Â°???\n                return (getInversions(state) % 2 == 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        IDAStarAlgorithm idaAlgorithm = new IDAStarAlgorithm(sState);\n//            System.out.println(\"--????Â¢?????Â§Â£???????Â§??Â±??Â§Â£--\");\n            //??\\??????????????????????Â§?????Â°???Â£?????Â°\n            int j = idaAlgorithm.getHeuristic(sState);\n//            System.out.println(\"????Â§?manhattan??????:\" + j);\n            int i = -1;//?????????????Â§???Â¨??????\n\n//            long time = System.currentTimeMillis();\n            //?????Â£?????Â±\"????Â°???Â£?????Â°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n//            System.out.println(\"?Â±??Â§Â£??Â¨??Â¶:\"+(System.currentTimeMillis() - time));\n\n//            idaAlgorithm.printMatrix(sState);\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n//        printMatrix(state);\n        return state;\n    }\n\n//    public void printMatrix(int[][] matrix) {\n//        System.out.println(\"------------\");\n//        for(int i=0;i<matrix.length;i++) {\n//            for(int j=0;j<matrix.length;j++) {\n//                System.out.print(matrix[i][j] + \" \");\n//            }\n//            System.out.println();\n//        }\n//    }\n\n    /**\n     * ?Â±??Â§Â£??????\n     * @param state ????????Â¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????Â±???\n     * @param d ???????Â¬??Â§???Â¨?????????\n     * @param h ????????Â¶?????Â°????????Â°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????Â¨???????Â¢?????Â§Â£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??Â¨?????Â¨???\"??????\"?Â§???Â¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??Â¬??Â°?Â§???Â¨?????????????Â¬??Â§???Â¨??????????\\????????????????????Â§????????????Â¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????Â£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????Â¢??????????????????????Â§???Â¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????Â£??Â¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????Â§???????????????Â¨????????????????Â§???Â¨????????????????????Â°????????Â°????????Â§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????Â£??Â±????Â±??Â§Â£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????Â°??Â°????????Â°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n\n    /**\n     * ??????????Â¢????\"???????????????\"\n     * @param state\n     */\n    private int getInversions(int[][] state) {\n        int inversion = 0;\n        int temp = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                int index = i* state.length + j + 1;\n                while(index < (state.length * state.length)) {\n                    if(state[index/state.length][index%state.length] != 0\n                            && state[index/state.length]\n                            [index%state.length] < state[i][j]) {\n                        temp ++;\n                    }\n                    index ++;\n                }\n                inversion = temp + inversion;\n                temp = 0;\n            }\n        }\n        return inversion;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * IDA*?Â±??Â§Â£15puzzle????Â¢?\n * IDA*??Â´??????IDDFS???A*???????????Â¶???IDDFS??Â§??Â¶????Â±??Â§Â£????Â¨??????????????????????A*???????????????\"?????????\"????Â´Â¢???\n * IDA*?????\\????Â§Â£????????Â£??Â±??????A*???????????Â¶????????????\"??Â±???\"?????????????Â¢?????Â§Â£???\"????????????\"???\n * ???\"????????????\"???????????Â£?Â¢????????Â£???????????????Â¨\"????????????\"??????????????Â°???????Â§Â£?????????????????????????Â°Â±??Â§????????Â£???\n * ?????????A*???????????????????????????????????Â¨?????Â±????????Â¨???IDDFS????????\\???IDA*?????Â±?????????????Â´Â¢?????????????????????????????Â¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????Â£??Â¨????????????????????????????Â§???Â¨?????????????????Â°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??Â¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????Â¢??Â£???????????Â¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????Â§???Â¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??Â¨?????Â°????Â§???Â¨??\\???????????Â¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????Â£???\"????????Â£???\"\n\n    //????????Â¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????Â°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????Â°?????????????????Â°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        Main idaAlgorithm = new Main(sState);\n            //??\\??????????????????????Â§?????Â°???Â£?????Â°\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;//?????????????Â§???Â¨??????\n            //?????Â£?????Â±\"????Â°???Â£?????Â°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n        return state;\n    }\n\n\n    /**\n     * ?Â±??Â§Â£??????\n     * @param state ????????Â¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????Â±???\n     * @param d ???????Â¬??Â§???Â¨?????????\n     * @param h ????????Â¶?????Â°????????Â°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????Â¨???????Â¢?????Â§Â£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??Â¨?????Â¨???\"??????\"?Â§???Â¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??Â¬??Â°?Â§???Â¨?????????????Â¬??Â§???Â¨??????????\\????????????????????Â§????????????Â¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????Â£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????Â¢??????????????????????Â§???Â¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????Â£??Â¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????Â§???????????????Â¨????????????????Â§???Â¨????????????????????Â°????????Â°????????Â§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????Â£??Â±????Â±??Â§Â£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????Â°??Â°????????Â°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iterNew.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tPuzzle puzzle = new Puzzle();\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tint v = scanner.nextInt();\n\t\t\tpuzzle.map[i] = v;\n\t\t\tif (v == 0) {\n\t\t\t\tpuzzle.space = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(slove(puzzle));\n\t}\n\n\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tprivate int slove(Puzzle in) {\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\tDeque<Puzzle> deque = new ArrayDeque<Puzzle>();\n\t\tSet<Puzzle> set = new HashSet<Main.Puzzle>();\n\t\tset.add(in);\n\t\tdeque.offer(in);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tu = deque.poll();\n\t\t\tif (isTrue(u)) {\n\t\t\t\treturn u.count;\n\t\t\t}\n\t\t\tint y = u.space / N;\n\t\t\tint x = u.space % N;\n\t\t\tfor (int[] a : dxy) {\n\t\t\t\tint dy = y + a[0];\n\t\t\t\tint dx = x + a[1];\n\t\t\t\tif (dy < 0 || dx < 0 || N <= dy || N <= dx)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u.clone();\n\t\t\t\tswap(v, u.space, dy * N + dx);\n\t\t\t\tv.space = dy * N + dx;\n\t\t\t\tif (!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tv.count++;\n\t\t\t\t\tdeque.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate boolean isTrue(Puzzle u) {\n\t\tfor (int i = 0; i < N2 - 1; i++) {\n\t\t\tif (u.map[i] != i + 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint t = v.map[i];\n\t\tv.map[i] = v.map[space];\n\t\tv.map[space] = t;\n\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] map = new int[N2];\n\t\tint space;\n\t\tint count = 0;\n\n\t\t@Override\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tclonePuzzle.map = Arrays.copyOf(map, N2);\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + Arrays.hashCode(map);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPuzzle other = (Puzzle) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (!Arrays.equals(map, other.map))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "    import java.io.*; \n    import java.util.*; \n    public class Main {\n        public static final int SIZE = 3; \n        public static final int ALL_SIZE = SIZE * SIZE; \n        public static int[] factor= { 1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880 };\n        public static int hash(int[] A){ \n            int[] A_ = new int[A.length]; \n            System.arraycopy(A, 0, A_, 0, A.length); \n            int ret = 0; \n            for(int i = 0; i < A_.length; i++){ \n                ret += A_[i] * factor[(A.length - i - 1)]; \n                for(int j = i + 1; j < A_.length; j++){ \n                    if(A_[j] >= A_[i]){ \n                        A_[j]--; \n                    } \n                } \n            } \n            return ret; \n        } \n        public static int[] unhash(int hash){ \n            int[] ret = new int[ALL_SIZE]; \n            for(int i = 0; i < ALL_SIZE; i++) { \n                ret[i] = hash / factor[ALL_SIZE - i - 1]; \n                hash -= factor[ALL_SIZE - i - 1] * ret[i]; \n            } \n            for(int i = ALL_SIZE - 1; i >= 0; i--){ \n                for(int j = i + 1; j < ALL_SIZE; j++){ \n                    if(ret[i] <= ret[j]) \n                        ret[j]++; \n                } \n            } \n            return ret; \n        } \n        public static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0}); \n        public static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n        public static void main(String[] args) throws IOException { \n            Scanner sc = new Scanner(System.in);\n            int[] visited = new int[MAX]; \n            Arrays.fill(visited, Integer.MAX_VALUE); \n            LinkedList<Integer> queue = new LinkedList<>(); \n            int[] input = new int[ALL_SIZE]; \n            for(int i = 0; i < SIZE; i++){ \n                for(int j = 0; j < SIZE; j++){ \n                    input[i * SIZE + j] = sc.nextInt(); \n                } \n            } \n            final int hash_input = hash(input); \n            queue.add(hash_input); \n            visited[hash_input] = 0; \n            while(!queue.isEmpty()){ \n                final int hashed = queue.poll(); \n                if(hashed == GOAL){ \n                    System.out.println(visited[hashed]); \n                    break; \n                } \n                final int dist = visited[hashed]; \n                int[] ret = unhash(hashed); \n                for(int i = 0; i < ALL_SIZE; i++){ \n                    if(ret[i] == 0){ \n                        if(i % 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                        } \n                        if(i % 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                            queue.add(next_hash); } tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                        } \n                        if(i / 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                        } \n                        if(i / 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                        } \n                    } \n                } \n            } \n        } \n        public static class Scanner { \n            private BufferedReader br; \n            private StringTokenizer tok; \n            public Scanner(InputStream is) throws IOException { \n                br = new BufferedReader(new InputStreamReader(is)); \n            } \n            private void getLine() throws IOException { \n                while (!hasNext()) { \n                    tok = new StringTokenizer(br.readLine()); \n                } \n            } \n            private boolean hasNext() { \n                return tok != null && tok.hasMoreTokens(); \n            } \n            public String next() throws IOException { \n                getLine(); \n                return tok.nextToken(); \n            } \n            public int nextInt() throws IOException {\n                return Integer.parseInt(next()); \n            } \n            public long nextLong() throws IOException { \n                return Long.parseLong(next()); \n            } \n            public void close() throws IOException { \n                br.close(); \n            }\n        }\n    }\n    }\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????Â´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??Â¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????Â£????????Â¢??Â°??????????Â¬???????????????????????????Â§?????????\n\t\t//??????????Â¬???????????????????????????Â¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?Â¬????????????????????????\\??????????????Â£????????Â¢??Â°??????????Â°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?Â¬????????????????????????????????????Â§????????Â¨???????Â¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?Â¬?????Â¬????null??????\n\t\t\tfield temp = this.next.elem; //???????Â¬?????????Â£????????????temp???\n\t\t\tthis.next = null; //???????Â¬????null?????????\n\t\t\treturn temp; //???????Â¬??????Â£?????????temp?????????\n\t\t}else return this.next.pop(); //?Â¬?????Â¬????null??Â§????????Â£??????????Â¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????Â§????????????????????Â´????n?????????\n\n\t/**/\n\t//???????????\\??????????????Â¢??Â°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????Â¢????????Â°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????Â§????????Â°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????Â§????????Â°??????????????Â£????????????cell???val??Â¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????Â¨???val???cell??????????????????????????Â§??????cell???????????????dehash??Â§???????????Â¨????Â¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????Â£????????????????Â§??????Â§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?Â§????????????????????Â¨??????Â¨???\n\n\t\t//?Â§??????Â§?????????????????????????????????????Â¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????Â¨??????Â¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in).useDelimiter(\"[\\\\s]+\");\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tcell[3i+j] = scan.nextInt();\n\t\t//for?????Â°???????????Â§cell??\\???\n\n\t\tst = new field(cell, hashkey(cell)); //??Â¨????????Â¢?????Â¨?????????????????Â¨???????????\\??????????????Â£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??Â¢?Â´Â¢??Â¨???\n\n\t\t//??????????????????????Â¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????Â£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??Â¢?Â´Â¢?????Â°???1?Â¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????Â¬???????????Â£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????Â£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??Â¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??Â¨???????????????floor?Â§?????????Â¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint[] input = new int[9];\n\t\tString[] first = s.nextLine().split(\" \");\n\t\tinput[0] = Integer.parseInt(first[0]);\n\t\tinput[1] = Integer.parseInt(first[1]);\n\t\tinput[2] = Integer.parseInt(first[2]);\n\n\t\tString[] second = s.nextLine().split(\" \");\n\t\tinput[3] = Integer.parseInt(second[0]);\n\t\tinput[4] = Integer.parseInt(second[1]);\n\t\tinput[5] = Integer.parseInt(second[2]);\n\n\t\tString[] three = s.nextLine().split(\" \");\n\t\tinput[6] = Integer.parseInt(three[0]);\n\t\tinput[7] = Integer.parseInt(three[1]);\n\t\tinput[8] = Integer.parseInt(three[2]);\n\n\t\tSystem.out.println(solve(input));\n\t}\n\n\tpublic static int solve(int[] input) {\n\t\tint cnt = 0;\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\tLinkedList<Integer> cntQueue = new LinkedList<Integer>();\n\t\tqueue.offer(input);\n\t\tcntQueue.offer(0);\n\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[] ban = queue.poll();\n\t\t\tcnt = cntQueue.poll();\n\t\t\t//??????\n\t\t\tif(check(ban))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\t\t\tif(ban[i] == 0)\n\t\t\t\t\t\tzeroIndex = i;\n\t\t\t\t}\n\n\t\t\t\tswitch (zeroIndex) {\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 0:\n\t\t\t\t\tint[] copyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????Â´???\n\t\t\t\tcase 1:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 2:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????Â´???\n\t\t\t\tcase 3:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//???????????????????????Â´???\n\t\t\t\tcase 4:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????Â´???\n\t\t\t\tcase 5:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 6:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????Â´???\n\t\t\t\tcase 7:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 8:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tpublic static boolean check(int[] ban) {\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\tif(i!=8 && ban[i]!=(i+1))\n\t\t\t\treturn false;\n\t\t\tif(i==8 && ban[i]!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tstatic int SIZE = 3;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tPuzzle p = new Puzzle();\n\n\t\tfor (int i = 0; i < SIZE*SIZE; i++) {\n\t\t\tp.board[i] = scanner.nextInt();\n\t\t\tif(p.board[i] == 0)\n\t\t\t\tp.space = i;\n\t\t}\n\n\t\tint steps = solve(p);\n\t\tSystem.out.println(steps);\n\t}\n\n    int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tprivate int solve(Puzzle p) {\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\n\t\tDeque<Puzzle> queue = new ArrayDeque<>();\n\t\tqueue.offer(p);\n\n\t\tSet<Puzzle> set = new HashSet<Main.Puzzle>();\n\t\tset.add(p);\n\n\t\twhile(!queue.isEmpty()) {\n\t\t\tu = queue.poll();\n\t\t\t\n\t\t\tif(isSolution(u)) \n\t\t\t\treturn u.countStep;\n\n\t\t\tint y = u.space/SIZE;\n\t\t\tint x = u.space%SIZE;\n\n\t\t\tfor(int[] d : dxy) {\n\t\t\t\tint dy = y + d[0];\n\t\t\t\tint dx = x + d[1];\n\n\t\t\t\tif(dy < 0 || dx < 0 || SIZE <= dy || SIZE <= dx) \n\t\t\t\t\tcontinue;\n\n\t\t\t\tv = u.clone();\n\t\t\t\tmove(v, u.space, dy*SIZE+dx);\n\t\t\t\tv.space = dy*SIZE+dx;\n\n\t\t\t\tif(!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tv.countStep++;\n\t\t\t\t\tqueue.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate boolean isSolution(Puzzle p) {\n\t\tfor (int i = 0; i < SIZE*SIZE-1; i++) {\n\t\t\tif(p.board[i] != i+1)\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate void move(Puzzle p, int space, int i) {\n\t\tint tmp = p.board[i];\n\t\tp.board[i] = p.board[space];\n\t\tp.board[space] = tmp;\n\t}\n\n\n\tclass Puzzle implements Cloneable {\n\t\tint[] board = new int[SIZE*SIZE];\n\t\tint space;\n\t\tint countStep = 0;\n\n\t\t@Override\n\t\tpublic Puzzle clone(){\n\t\t\ttry {\n\t\t\t\tPuzzle newPuzzle = (Puzzle)super.clone();\n\t\t\t\tnewPuzzle.board = Arrays.copyOf(board, SIZE*SIZE);\n\t\t\t\treturn newPuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime*result + getOuterType().hashCode();\n\t\t\tresult = prime*result + Arrays.hashCode(board);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(this == obj)\n\t\t\t\treturn true;\n\n\t\t\tif(obj == null)\n\t\t\t\treturn false;\n\n\t\t\tif(getClass() != obj.getClass())\n\t\t\t\treturn false;\n\n\t\t\tPuzzle p = (Puzzle)obj;\n\t\t\t\n\t\t\tif(!getOuterType().equals(p.getOuterType()))\n\t\t\t\treturn false;\n\n\t\t\tif(!Arrays.equals(board, p.board))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/12.\n */\nimport java.util.Scanner;\n\n/**\n * IDA* for 8 or 15 puzzle\n * f(x) = h(x) +depth(g(x))\n * @author huzhejie\n *\n */\npublic class Main {\n\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    /*\n    store the position of the each point of the target state\n     */\n    private int[][] targetPoints;\n\n    /*\n    f(x),total cost\n     */\n    private static int cost;\n\n    //target state\n    private static int[][] tState = {{1,2,3},{4,5,6},{7,8,0}};\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        /*\n        get the position of blank point\n         */\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n        /*\n        get the position(x,y) by using a two-dimensional array.\n        e.g. 2's position is (2,1),\n        targetPoints [2][0] = 2-1 =1,targetPoints[2][1]=1-1=0\n         */\n        for(int i=0;i<tState.length;i++) {\n            for(int j=0;j<tState.length;j++) {\n                targetPoints[tState[i][j]][0] = i;\n\n                targetPoints[tState[i][j]][1] = j;\n            }\n        }\n    }\n    public boolean checkState(int[][] state){\n        boolean b =true;\n        for(int i = 0;i<SIZE;i++)\n            for(int j=0;j<SIZE;j++){\n                if(!(state[i][j]==tState[i][j]))\n                    b = false;\n            }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3&&(s=sc.nextLine())!=null){\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Main idaAlgorithm = new Main(sState);\n\n        if(idaAlgorithm.checkState(sState)){\n            System.out.println(step);\n        }\n        else{\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;\n\n            for (cost = j; ; cost++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            System.out.println(cost);\n        }\n    }\n    /**\n     *\n     * @param state\n     * @param blank_row the row-coordinate of 0 in ths state\n     * @param blank_column the column-coordinate of 0 in ths state\n     * @param dep the depth of the state\n     * @param d the direction of the last move\n     * @param h the value of h(x)\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,int d,int h) {\n        /*\n        the value of h(x) after moving\n         */\n        int h1;\n\n        /*\n        make a comparison with the target state\n         */\n        boolean isSolved = checkState(state);\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == cost) {\n            return false;\n        }\n\n        /*\n        the position of the blank point after moving\n         */\n        int blank_row1 ;\n        int blank_column1;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            /*\n            check whether the direction of this movement is opposite of the direction of the last move or not\n             */\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            /*\n            border check\n             */\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            /*\n            swap position\n             */\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            /*\n            calculate the h(x)\n             */\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n            /*\n            if f(x) increases,prune\n             */\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            /*\n            do the iteration with depth increasing\n             */\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * get the value of h(x)\n     * @param state\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\nclass Main{\n    public static void main(String[] Args) throws IOException{\n        final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        final int[] board = new int[9];\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n        for(int i = 0; i<9; i++){\n            if(i==3||i==6) st = new StringTokenizer(br.readLine(), \" \");\n            board[i] = Integer.parseInt(st.nextToken());\n        }\n        final Deque<state> q = new ArrayDeque<state>();\n        final BitSet cl = new BitSet(362880);\n        q.add(new state(board, 0));\n        cl.set(hash(board));\n        int minstep = -1;\n        while(!q.isEmpty()){\n            final state stat = q.remove();\n            if(hash(stat.board)==46233){\n                minstep = stat.step;\n                break;\n            }\n            int f;\n            for(f = 0; f<9&&stat.board[f]!=0; f++);\n            if(f%3!=0){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f-1];\n                next[f-1] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n            if(f%3!=2){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f+1];\n                next[f+1] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n            if(f>2){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f-3];\n                next[f-3] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n            if(f<6){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f+3];\n                next[f+3] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n        }\n        System.out.println(minstep);\n    }\n    private static int hash(int[] board){\n        int h = board[0];\n        for(int i = 1; i<8; i++){\n            h *= 9-i;\n            h += board[i];\n            for(int j = 0; j<i; j++){\n                if(board[j]<board[i]) --h;\n            }\n        }\n        return h;\n    }\n}\n\nclass state{\n    final int[] board;\n    final int step;\n    state(int[] board, int step){\n        this.board = board;\n        this.step = step;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while ((s = sc.nextLine())!=null&&count<3){\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n/**\n * IDA*?Â±??Â§Â£15puzzle????Â¢?\n * IDA*??Â´??????IDDFS???A*???????????Â¶???IDDFS??Â§??Â¶????Â±??Â§Â£????Â¨??????????????????????A*???????????????\"?????????\"????Â´Â¢???\n * IDA*?????\\????Â§Â£????????Â£??Â±??????A*???????????Â¶????????????\"??Â±???\"?????????????Â¢?????Â§Â£???\"????????????\"???\n * ???\"????????????\"???????????Â£?Â¢????????Â£???????????????Â¨\"????????????\"??????????????Â°???????Â§Â£?????????????????????????Â°Â±??Â§????????Â£???\n * ?????????A*???????????????????????????????????Â¨?????Â±????????Â¨???IDDFS????????\\???IDA*?????Â±?????????????Â´Â¢?????????????????????????????Â¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????Â£??Â¨????????????????????????????Â§???Â¨?????????????????Â°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??Â¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????Â¢??Â£???????????Â¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????Â§???Â¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??Â¨?????Â°????Â§???Â¨??\\???????????Â¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????Â£???\"????????Â£???\"\n\n    //????????Â¶???\n    private static int[][] tState = {\n            {1 ,2 ,3 } ,\n            {4 ,5 ,6 } ,\n            {7 ,8, 0 }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????Â°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????Â°?????????????????Â°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        boolean b =true;\n        for(int i = 0;i<3;i++)\n            for(int j=0;j<3;j++){\n                if(!(sState[i][j]==tState[i][j]))\n                    b = false;\n            }\n        if(b){\n            System.out.println(step);\n        }\n        else {\n\n            Main idaAlgorithm = new Main(sState);\n            //??\\??????????????????????Â§?????Â°???Â£?????Â°\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;//?????????????Â§???Â¨??????\n            //?????Â£?????Â±\"????Â°???Â£?????Â°\"\n            for (ans = j; ; ans++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            int[][] matrix = idaAlgorithm.move(sState, moves[0]);\n            step++;\n            for (int k = 1; k < ans; k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step++;\n            }\n            System.out.println(step);\n        }\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n        return state;\n    }\n\n\n    /**\n     * ?Â±??Â§Â£??????\n     * @param state ????????Â¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????Â±???\n     * @param d ???????Â¬??Â§???Â¨?????????\n     * @param h ????????Â¶?????Â°????????Â°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????Â¨???????Â¢?????Â§Â£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??Â¨?????Â¨???\"??????\"?Â§???Â¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??Â¬??Â°?Â§???Â¨?????????????Â¬??Â§???Â¨??????????\\????????????????????Â§????????????Â¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????Â£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????Â¢??????????????????????Â§???Â¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????Â£??Â¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????Â§???????????????Â¨????????????????Â§???Â¨????????????????????Â°????????Â°????????Â§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????Â£??Â±????Â±??Â§Â£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????Â°??Â°????????Â°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n/**\n * IDA*?Â±??Â§Â£15puzzle????Â¢?\n * IDA*??Â´??????IDDFS???A*???????????Â¶???IDDFS??Â§??Â¶????Â±??Â§Â£????Â¨??????????????????????A*???????????????\"?????????\"????Â´Â¢???\n * IDA*?????\\????Â§Â£????????Â£??Â±??????A*???????????Â¶????????????\"??Â±???\"?????????????Â¢?????Â§Â£???\"????????????\"???\n * ???\"????????????\"???????????Â£?Â¢????????Â£???????????????Â¨\"????????????\"??????????????Â°???????Â§Â£?????????????????????????Â°Â±??Â§????????Â£???\n * ?????????A*???????????????????????????????????Â¨?????Â±????????Â¨???IDDFS????????\\???IDA*?????Â±?????????????Â´Â¢?????????????????????????????Â¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????Â£??Â¨????????????????????????????Â§???Â¨?????????????????Â°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??Â¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????Â¢??Â£???????????Â¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????Â§???Â¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??Â¨?????Â°????Â§???Â¨??\\???????????Â¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????Â£???\"????????Â£???\"\n\n    //????????Â¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????Â°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????Â°?????????????????Â°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    /**\n     * ??Â¨???????Â¢????????Â§Â£??Â§\n     * @param state ??Â¶???\n     */\n    private boolean canSolve(int[][] state) {\n        if(state.length % 2 == 1) { //????Â¢???????????\\???Â°\n            return (getInversions(state) % 2 == 0);\n        } else { //????Â¢????????????Â¶??Â°\n            if((state.length - blank_row) % 2 == 1) { //??????????????Â°,?????????????\\???Â°???\n                return (getInversions(state) % 2 == 0);\n            } else { //??????????????Â°,??????????????Â¶??Â°???\n                return (getInversions(state) % 2 == 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        Main idaAlgorithm = new Main(sState);\n//            System.out.println(\"--????Â¢?????Â§Â£???????Â§??Â±??Â§Â£--\");\n            //??\\??????????????????????Â§?????Â°???Â£?????Â°\n            int j = idaAlgorithm.getHeuristic(sState);\n//            System.out.println(\"????Â§?manhattan??????:\" + j);\n            int i = -1;//?????????????Â§???Â¨??????\n\n//            long time = System.currentTimeMillis();\n            //?????Â£?????Â±\"????Â°???Â£?????Â°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n//            System.out.println(\"?Â±??Â§Â£??Â¨??Â¶:\"+(System.currentTimeMillis() - time));\n\n//            idaAlgorithm.printMatrix(sState);\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n//        printMatrix(state);\n        return state;\n    }\n\n//    public void printMatrix(int[][] matrix) {\n//        System.out.println(\"------------\");\n//        for(int i=0;i<matrix.length;i++) {\n//            for(int j=0;j<matrix.length;j++) {\n//                System.out.print(matrix[i][j] + \" \");\n//            }\n//            System.out.println();\n//        }\n//    }\n\n    /**\n     * ?Â±??Â§Â£??????\n     * @param state ????????Â¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????Â±???\n     * @param d ???????Â¬??Â§???Â¨?????????\n     * @param h ????????Â¶?????Â°????????Â°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????Â¨???????Â¢?????Â§Â£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??Â¨?????Â¨???\"??????\"?Â§???Â¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??Â¬??Â°?Â§???Â¨?????????????Â¬??Â§???Â¨??????????\\????????????????????Â§????????????Â¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????Â£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????Â¢??????????????????????Â§???Â¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????Â£??Â¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????Â§???????????????Â¨????????????????Â§???Â¨????????????????????Â°????????Â°????????Â§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????Â£??Â±????Â±??Â§Â£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????Â°??Â°????????Â°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n\n    /**\n     * ??????????Â¢????\"???????????????\"\n     * @param state\n     */\n    private int getInversions(int[][] state) {\n        int inversion = 0;\n        int temp = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                int index = i* state.length + j + 1;\n                while(index < (state.length * state.length)) {\n                    if(state[index/state.length][index%state.length] != 0\n                            && state[index/state.length]\n                            [index%state.length] < state[i][j]) {\n                        temp ++;\n                    }\n                    index ++;\n                }\n                inversion = temp + inversion;\n                temp = 0;\n            }\n        }\n        return inversion;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus)\n    {\n        this.startStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n//    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int time = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tHS hs = new HS();\n\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\ths.SetIni(x, y, scan.nextInt());\n\n\t\tSystem.out.println(hs.solve());\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass HS {\n\tclass Bd {\n\t\tbyte[][] pn = new byte[3][3];\n\t\tint oper = 0;\n\t\tint diff = 0;\n\n\t\tpublic int getKey() {\n\t\t\tint key = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tkey *= 10;\n\t\t\t\t\tkey += pn[x][y];\n\t\t\t\t}\n\t\t\treturn key;\n\t\t}\n\n\t\tpublic int eval() {\n\t\t\tint ret = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tint p = pn[x][y];\n\t\t\t\t\tif (p != 0)\n\t\t\t\t\t\tret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);\n\t\t\t\t}\n\t\t\tdiff = ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void copy(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tpn[x][y] = b.pn[x][y];\n\t\t\tdiff = b.diff;\n\t\t\toper = b.oper;\n\t\t}\n\n\t\tprivate boolean up() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y + 1];\n\t\t\t\t\t\tpn[x][y + 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean down() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 1; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y - 1];\n\t\t\t\t\t\tpn[x][y - 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean right() {\n\t\t\tfor (int x = 1; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x - 1][y];\n\t\t\t\t\t\tpn[x - 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean left() {\n\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x + 1][y];\n\t\t\t\t\t\tpn[x + 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean move(int op) {\n\t\t\tswitch (op) {\n\t\t\tcase (0):\n\t\t\t\treturn up();\n\t\t\tcase (1):\n\t\t\t\treturn down();\n\t\t\tcase (2):\n\t\t\t\treturn right();\n\t\t\tcase (3):\n\t\t\t\treturn left();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean isSame(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (b.pn[x][y] != pn[x][y])\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate Bd bd = new Bd();\n\tprivate int[] gx = { 2, 0, 1, 2, 0, 1, 2, 0, 1 };\n\tprivate int[] gy = { 2, 0, 0, 0, 1, 1, 1, 2, 2 };\n\t// private ArrayList<Bd> hist = new ArrayList<Bd>();\n\tprivate Map<Integer, Integer> hist = new HashMap<>();\n\tprivate PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());\n\n\tclass Qcomparator implements Comparator<Bd> {\n\t\t@Override\n\t\tpublic int compare(Bd b1, Bd b2) {\n\t\t\tif (b1.diff + b1.oper > b2.diff + b2.oper)\n\t\t\t\treturn 1;\n\t\t\telse if (b1.diff + b1.oper == b2.diff + b2.oper)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic void SetIni(int x, int y, int a) {\n\t\tbd.pn[x][y] = (byte) a;\n\t}\n\n\tpublic int solve() {\n\t\tBd b = new Bd();\n\t\tb.copy(bd);\n\t\tb.eval();\n\t\tpqueue.add(b);\n\t\thist.put(b.getKey(), 0);\n\t\treturn search();\n\t}\n\n\tprivate int search() {\n\t\twhile (true) {\n\t\t\tBd b = pqueue.poll();\n\t\t\tif (b == null)\n\t\t\t\treturn -1;\n\n\t\t\t// printBd(b);\n\n\t\t\tif (b.diff == 0)\n\t\t\t\treturn b.oper;\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tBd nb = new Bd();\n\t\t\t\tnb.copy(b);\n\t\t\t\tif (nb.move(i))\n\t\t\t\t\taddQueue(nb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean addQueue(Bd b) {\n\t\tint k = b.getKey();\n\t\tif (hist.containsKey(k)) {\n\t\t\tint oper = hist.get(k);\n\t\t\tif (oper > b.oper) {\n\t\t\t\thist.put(k, b.oper);\n\t\t\t\tpqueue.add(b);\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t}\n\t\thist.put(k, b.oper);\n\t\tpqueue.add(b);\n\t\treturn true;\n\t}\n\n\tprivate void printBd(Bd b) {\n\t\tSystem.out.println(\"----------------\");\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tSystem.out.println(\"- \" + b.pn[0][y] + \" \" + b.pn[1][y] + \" \" + b.pn[2][y] + \" -\");\n\t\tSystem.out.println(\"------- diff \" + b.diff + \" oper \" + b.oper + \" queue \" + pqueue.size());\n\t\tif (pqueue.size() > 100000)\n\t\t\tSystem.exit(0);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint[] input = new int[9];\n\t\tString[] first = s.nextLine().split(\" \");\n\t\tinput[0] = Integer.parseInt(first[0]);\n\t\tinput[1] = Integer.parseInt(first[1]);\n\t\tinput[2] = Integer.parseInt(first[2]);\n\n\t\tString[] second = s.nextLine().split(\" \");\n\t\tinput[3] = Integer.parseInt(second[0]);\n\t\tinput[4] = Integer.parseInt(second[1]);\n\t\tinput[5] = Integer.parseInt(second[2]);\n\n\t\tString[] three = s.nextLine().split(\" \");\n\t\tinput[6] = Integer.parseInt(three[0]);\n\t\tinput[7] = Integer.parseInt(three[1]);\n\t\tinput[8] = Integer.parseInt(three[2]);\n\n\t\tSystem.out.println(solve(input));\n\t}\n\n\tpublic static int solve(int[] input) {\n\t\tint cnt = 0;\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\tLinkedList<Integer> cntQueue = new LinkedList<Integer>();\n\t\tHashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();\n\t\tqueue.offer(input);\n\t\tcntQueue.offer(0);\n\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[] ban = queue.poll();\n\t\t\tcnt = cntQueue.poll();\n\t\t\t//??????\n\t\t\tif(check(ban))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\t\t\tif(ban[i] == 0)\n\t\t\t\t\t\tzeroIndex = i;\n\t\t\t\t}\n\n\t\t\t\tswitch (zeroIndex) {\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 0:\n\t\t\t\t\tint[] copyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tint hash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????Â´???\n\t\t\t\tcase 1:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 2:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????Â´???\n\t\t\t\tcase 3:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//???????????????????????Â´???\n\t\t\t\tcase 4:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????Â´???\n\t\t\t\tcase 5:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 6:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????Â´???\n\t\t\t\tcase 7:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????Â´???\n\t\t\t\tcase 8:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tstatic int[] value = {8400, 1999, 129, 67222, 281, 2, 832, 8, 21};\n\tpublic static int hash(int[] ban) {\n\t\tint total = 1;\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\ttotal = 31*total + ban[i];\n\t\t}\n\t\treturn total;\n\t}\n\n\n\n\tpublic static boolean check(int[] ban) {\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\tif(i!=8 && ban[i]!=(i+1))\n\t\t\t\treturn false;\n\t\t\tif(i==8 && ban[i]!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n * dijkstra algorithm for single source shortest path\n */\npublic class Main {\n    /**\n     * the main execution part of dijkstra algorithm\n     * @param source source vertex\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static void dijkstra(Vertex source){\n        source.minDistance = 0;\n        PriorityQueue<Vertex> queue = new PriorityQueue<Vertex>();\n        queue.add(source);\n        while(!queue.isEmpty()){\n            Vertex v = queue.poll();\n            for(Edge edge:v.nighbors){\n                int newDist = v.minDistance +edge.weight;\n                /*\n                make a comparision with new distance\n                 */\n                if(edge.target.minDistance>newDist){\n                    /*\n                    change the value of minDistance of the target vertex of the directed edge\n                     */\n                    queue.remove(edge.target);\n                    edge.target.minDistance = newDist;\n                    queue.add(edge.target);\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int l = 1;\n        String str;\n        /*\n        read the data and make the graph\n         */\n        try {\n            str = br.readLine();\n            Graph g = new Graph(Integer.parseInt(str.split(\" \")[0]));\n            int source  = Integer.parseInt(str.split(\" \")[2]);\n            int edge = Integer.parseInt(str.split(\" \")[1]);\n            while ((str = br.readLine()) != null&&l<=edge){\n                String record[] = str.split(\" \");\n                g.addEdge(Integer.parseInt(record[0]),Integer.parseInt(record[1]),Integer.parseInt(record[2]));\n                l++;\n            }\n            br.close();\n        /*\n        execute dijkstra algorithm\n         */\n            dijkstra(g.vertices.get(source));\n        /*\n        output the result\n        */\n            for(Vertex v:g.vertices.values()){\n                if(v.minDistance == Integer.MAX_VALUE)\n                    System.out.println(\"INF\");\n                else\n                    System.out.println(v.minDistance);\n            }\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n\n}\nclass Edge{\n    /*\n    the target vertex of the edge\n     */\n    public final Vertex target;\n    /*\n    the weight of the edge\n     */\n    public final int weight;\n\n    public Edge(Vertex target,int weight){\n        this.target = target;\n        this.weight = weight;\n    }\n}\nclass Graph{\n    /*\n    the set of the vertices of the graph\n     */\n    Map<Integer,Vertex> vertices;\n    public Graph(int vertexNumber){\n        vertices = new LinkedHashMap<Integer, Vertex>();\n        for(int i = 0;i<vertexNumber;i++){\n            vertices.put(i,new Vertex(i));\n        }\n    }\n\n    /**\n     * add an edge into the graph\n     * @param source the start vertex of the edge\n     * @param target the target vertex of the edge\n     * @param weight the weight of the edge\n     */\n    public void addEdge(int source,int target,int weight){\n        Vertex v = vertices.get(source);\n        Edge edge = new Edge(vertices.get(target),weight);\n        v.nighbors.add(edge);\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass Vertex implements Comparable<Vertex>{\n    /*\n    the id of vertex\n     */\n    int id;\n    /*\n    minimal distance from the source to this vertex\n     */\n    int minDistance = Integer.MAX_VALUE;\n    /*\n    stores edges whose start vertex's id equals to this vertex's id\n     */\n    ArrayList<Edge> nighbors;\n\n    public Vertex(int id){\n        this.id = id;\n        this.nighbors = new ArrayList<Edge>();\n    }\n    public int compareTo(Vertex o) {\n        return Integer.compare(minDistance,o.minDistance);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n//    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public List<Node>  close =new ArrayList<Node> ();\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, List<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements  Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue-y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "package sample;\n\nimport java.util.Scanner;\n\n/**\n * IDA*?Â±??Â§Â£15puzzle????Â¢?\n * IDA*??Â´??????IDDFS???A*???????????Â¶???IDDFS??Â§??Â¶????Â±??Â§Â£????Â¨??????????????????????A*???????????????\"?????????\"????Â´Â¢???\n * IDA*?????\\????Â§Â£????????Â£??Â±??????A*???????????Â¶????????????\"??Â±???\"?????????????Â¢?????Â§Â£???\"????????????\"???\n * ???\"????????????\"???????????Â£?Â¢????????Â£???????????????Â¨\"????????????\"??????????????Â°???????Â§Â£?????????????????????????Â°Â±??Â§????????Â£???\n * ?????????A*???????????????????????????????????Â¨?????Â±????????Â¨???IDDFS????????\\???IDA*?????Â±?????????????Â´Â¢?????????????????????????????Â¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????Â£??Â¨????????????????????????????Â§???Â¨?????????????????Â°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??Â¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????Â¢??Â£???????????Â¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????Â§???Â¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??Â¨?????Â°????Â§???Â¨??\\???????????Â¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????Â£???\"????????Â£???\"\n\n    //????????Â¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????Â°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????Â°?????????????????Â°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    /**\n     * ??Â¨???????Â¢????????Â§Â£??Â§\n     * @param state ??Â¶???\n     */\n    private boolean canSolve(int[][] state) {\n        if(state.length % 2 == 1) { //????Â¢???????????\\???Â°\n            return (getInversions(state) % 2 == 0);\n        } else { //????Â¢????????????Â¶??Â°\n            if((state.length - blank_row) % 2 == 1) { //??????????????Â°,?????????????\\???Â°???\n                return (getInversions(state) % 2 == 0);\n            } else { //??????????????Â°,??????????????Â¶??Â°???\n                return (getInversions(state) % 2 == 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        Main idaAlgorithm = new Main(sState);\n//            System.out.println(\"--????Â¢?????Â§Â£???????Â§??Â±??Â§Â£--\");\n            //??\\??????????????????????Â§?????Â°???Â£?????Â°\n            int j = idaAlgorithm.getHeuristic(sState);\n//            System.out.println(\"????Â§?manhattan??????:\" + j);\n            int i = -1;//?????????????Â§???Â¨??????\n\n//            long time = System.currentTimeMillis();\n            //?????Â£?????Â±\"????Â°???Â£?????Â°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n//            System.out.println(\"?Â±??Â§Â£??Â¨??Â¶:\"+(System.currentTimeMillis() - time));\n\n//            idaAlgorithm.printMatrix(sState);\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n//        printMatrix(state);\n        return state;\n    }\n\n//    public void printMatrix(int[][] matrix) {\n//        System.out.println(\"------------\");\n//        for(int i=0;i<matrix.length;i++) {\n//            for(int j=0;j<matrix.length;j++) {\n//                System.out.print(matrix[i][j] + \" \");\n//            }\n//            System.out.println();\n//        }\n//    }\n\n    /**\n     * ?Â±??Â§Â£??????\n     * @param state ????????Â¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????Â±???\n     * @param d ???????Â¬??Â§???Â¨?????????\n     * @param h ????????Â¶?????Â°????????Â°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????Â¨???????Â¢?????Â§Â£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??Â¨?????Â¨???\"??????\"?Â§???Â¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??Â¬??Â°?Â§???Â¨?????????????Â¬??Â§???Â¨??????????\\????????????????????Â§????????????Â¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????Â£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????Â¢??????????????????????Â§???Â¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????Â£??Â¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????Â§???????????????Â¨????????????????Â§???Â¨????????????????????Â°????????Â°????????Â§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????Â£??Â±????Â±??Â§Â£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????Â°??Â°????????Â°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n\n    /**\n     * ??????????Â¢????\"???????????????\"\n     * @param state\n     */\n    private int getInversions(int[][] state) {\n        int inversion = 0;\n        int temp = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                int index = i* state.length + j + 1;\n                while(index < (state.length * state.length)) {\n                    if(state[index/state.length][index%state.length] != 0\n                            && state[index/state.length]\n                            [index%state.length] < state[i][j]) {\n                        temp ++;\n                    }\n                    index ++;\n                }\n                inversion = temp + inversion;\n                temp = 0;\n            }\n        }\n        return inversion;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????Â´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??Â¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????Â£????????Â¢??Â°??????????Â¬???????????????????????????Â§?????????\n\t\t//??????????Â¬???????????????????????????Â¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?Â¬????????????????????????\\??????????????Â£????????Â¢??Â°??????????Â°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?Â¬????????????????????????????????????Â§????????Â¨???????Â¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?Â¬?????Â¬????null??????\n\t\t\tfield temp = this.next.elem; //???????Â¬?????????Â£????????????temp???\n\t\t\tthis.next = null; //???????Â¬????null?????????\n\t\t\treturn temp; //???????Â¬??????Â£?????????temp?????????\n\t\t}else return this.next.pop(); //?Â¬?????Â¬????null??Â§????????Â£??????????Â¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????Â§????????????????????Â´????n?????????\n\n\t/**/\n\t//???????????\\??????????????Â¢??Â°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????Â¢????????Â°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????Â§????????Â°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????Â§????????Â°??????????????Â£????????????cell???val??Â¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????Â¨???val???cell??????????????????????????Â§??????cell???????????????dehash??Â§???????????Â¨????Â¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????Â£????????????????Â§??????Â§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?Â§????????????????????Â¨??????Â¨???\n\n\t\t//?Â§??????Â§?????????????????????????????????????Â¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????Â¨??????Â¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tfor(int i=0; i<9; i++)\n\t\t\tcell[i] = scan.nextInt();\n\n\t\tst = new field(cell, hashkey(cell)); //??Â¨????????Â¢?????Â¨?????????????????Â¨???????????\\??????????????Â£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??Â¢?Â´Â¢??Â¨???\n\n\t\t//??????????????????????Â¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????Â£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??Â¢?Â´Â¢?????Â°???1?Â¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????Â¬???????????Â£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????Â£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??Â¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??Â¨???????????????floor?Â§?????????Â¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while ((s = sc.nextLine())!=null&&count<3){\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.hvalue - y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Main {\n\n  final byte ROW       = 3;\n  final byte MATRIX    = 9;\n  final byte DIRECTION = 4;\n  final byte[] dx = {-1, 0, 1, 0};\n  final byte[] dy = { 0,-1, 0, 1};\n  final String[] dir = {\"u\",\"l\",\"d\",\"r\"};\n\n  public static void main(String[] args) {\n    \n    new Main().run();\n  }\n\n  public void run() {\n\n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      Puzzule first;\n      String[] line ;\n      byte[] inPuzzle = new byte[MATRIX];\n      int posSpace = 0;\n\n      for(int i=0; i<MATRIX; ) {\n        line = br.readLine().split(\" \");\n        for(int j=0; j<ROW; j++, i++) {\n          inPuzzle[i] = (byte)Integer.parseInt(line[j]);\n          if(inPuzzle[i] == 0) {\n            inPuzzle[i] = (byte)MATRIX;\n            posSpace = i;\n          }\n        }\n      }\n\n      first = new Puzzule(inPuzzle, (byte)posSpace);\n      System.out.println( bfs(first).length() );\n    }\n    catch(IOException e) {\n      System.err.println(e);\n    }\n  }\n\n  private String bfs(Puzzule s) {\n    Queue<Puzzule> queue = new ArrayDeque<>();\n    Set<Puzzule> set = new HashSet<>();\n    Puzzule u, v;\n    queue.offer(s);\n    set.add(s);\n\n    byte sx,sy,tx,ty;\n    while(!queue.isEmpty()) {\n      u = queue.poll();\n\n      if(u.isTarget()) {\n        // System.out.println(queue.size());\n        // System.out.println(set.size());\n        return u.path;\n      }\n\n      sx = (byte)(u.space / ROW);\n      sy = (byte)(u.space % ROW);\n      for(int i=0; i<DIRECTION; i++) {\n        tx = (byte)(sx + dx[i]);\n        ty = (byte)(sy + dy[i]);\n        if(tx<0 || ty<0 || tx>=ROW || ty>=ROW)\n          continue;\n        \n        v = u.clone();\n        v.swap(u.space, tx*ROW+ty);\n        if(set.add(v)) {\n          v.path += dir[i];\n          queue.offer(v);\n        }\n      }\n    }\n\n    return \"unsolvable.\";\n  }\n\n  class Puzzule implements Cloneable {\n\n    byte[] mat;\n    byte   space;\n    String path;\n    long   state;\n\n    public Puzzule() {\n      mat = null;\n      space = 0;\n      path = \"\";\n      state = 0;\n    }\n    public Puzzule(byte[] mat, byte space) {\n      this.mat = mat;\n      this.space = space;\n      path = \"\";\n      updateState();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if(obj == this) return true;\n      if(obj == null) return false;\n      if(!(obj instanceof Puzzule)) return false;\n\n      Puzzule ref = (Puzzule)obj;\n\n      return this.state == ref.state ? true : false;\n    }\n    @Override\n    public int hashCode() {\n      int result = 31;\n\n      return result * 17 + Long.valueOf(state).hashCode();\n    }\n    @Override\n    public Puzzule clone() {\n      Puzzule ret = new Puzzule();\n      ret.mat   = this.mat.clone();\n      ret.space = this.space;\n      ret.path  = this.path;\n      ret.state = this.state;\n\n      return ret;\n    }\n\n    public boolean isTarget() {\n      for(int i=0; i<MATRIX; i++)\n        if(mat[i]!=(i+1)) return false;\n\n      return true;\n    }\n    public void swap(int a, int b) {\n      byte t = mat[a]; mat[a] = mat[b]; mat[b] = t;\n      space = (byte)b;\n      updateState();\n    }\n    public void updateState() {\n      state = 0;\n      for (byte var : mat) {\n        state = state * 10 + var;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tScanner sc = new Scanner(System.in);\n\t\n\tfinal int N = 3;\n\tint[][] board;\n\tString ans = \"123456780\";\n    int count = 0;\n    int[] dy = {1, 0, -1, 0};\n    int[] dx = {0, 1, 0, -1};\n    \n\t\n\tQueue<Pazzle> Q = new LinkedList<Pazzle>();\n    HashSet<String> H = new HashSet<String>();\n\t\n\tclass Pazzle{\n\t\tint y, x;\n\t\tint[][] board;\n\t\tPazzle(int y, int x, int[][] board){\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.board = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++) { for(int j=0; j<N; j++) { this.board[i][j] = board[i][j]; } }\n\t\t}\n\t\t\n\t\tPazzle(Pazzle p){\n\t\t\tthis.y = p.y;\n\t\t\tthis.x = p.x;\n\t\t\tboard = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++) { for(int j=0; j<N; j++) { board[i][j] = p.board[i][j]; } }\n\t\t}\n\t\t\n\t\tpublic String getString() {\n\t\t\tString str = \"\";\n\t\t\tfor(int i=0; i<N; i++) { for(int j=0; j<N; j++) { str += Integer.toString(board[i][j]); } }\n\t\t\treturn str;\n\t\t}\n\t\t\n\t\tpublic void swap(int ny, int nx) {\n\t\t\tint tmp = board[y][x];\n\t\t\tboard[y][x] = board[ny][nx];\n\t\t\tboard[ny][nx] = tmp;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t\t\n\t\tpublic void printBoard() {\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) { System.out.print(board[i][j]+\" \"); }\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic void solve() {\n\t\tboard = new int[N][N];\n\t\tint y = 0, x = 0;\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tboard[i][j] = sc.nextInt();\n\t\t\t\tif(board[i][j] == 0) { y = i; x = j; }\n\t\t\t}\n\t\t}\n\t\t\n        Q.add(new Pazzle(y,x,board));\n        \n        while( !Q.isEmpty() ) {\n        \t\tint length = Q.size();\n        \t\tfor(int i=0; i<length; i++) {\n        \t\t\tPazzle p = Q.poll();\n        \t\t\tString str = p.getString();\n        \t\t\tif( str.equals(ans) ) { System.out.println(count); return; }\n        \t\t\tH.add(str);\n        \t\t\t\n        \t\t\tfor(int j=0; j<4; j++) {\n        \t\t\t\tint ny = p.y + dy[j];\n        \t\t\t\tint nx = p.x + dx[j];\n        \t\t\t\tif(ny>=0 && nx>=0 && ny<N && nx<N) {\n        \t\t\t\t\tPazzle np = new Pazzle(p);\n        \t\t\t\t\tnp.swap(ny, nx);\n        \t\t\t\t\tif( H.contains( np.getString() ) ) { continue; }\n        \t\t\t\t\tQ.add(np);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tcount++;\n        }\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.solve();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static Scanner sc = new Scanner(System.in);\n\tstatic final int PUZZLE_SIZE = 9;\n\tstatic final int PUZZLE_WIDTH = 3;\n\tstatic long[] fac = new long[PUZZLE_SIZE];\n\tstatic long GOAL_HASH;\n\n\tstatic HashMap<Long, State> hmap = new HashMap<>();\n\tstatic PriorityQueue<State> que = new PriorityQueue<>((a, b) -> (a.m+a.h) - (b.m+b.h));\t//A*algorithm\n\n\tpublic static void main(String[] args) {\n\t\tArrayList<Integer> A = new ArrayList<>();\n\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\tA.add((i+1)%PUZZLE_SIZE);\n\t\t}\n\t\tGOAL_HASH = getHash(A);\n\n\t\tA.clear();\n\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\tA.add(sc.nextInt());\n\t\t}\n\n\t\tState init = new State(A, 0);\n\t\thmap.put(init.hash, init);\n\t\tque.add(init);\n\n\t\twhile(true) {\n\t\t\tque.poll().heuristicSearch();\n\t\t}\n\t}\n\n\tstatic class State {\n\t\tArrayList<Integer> A;\n\t\tlong hash;\n\t\tint m;\t//???????????Â§???????Â°??????Â°\n\t\tint h;\t//?????\\??????????????Â£????????Â¢??Â°\n\n\t\tState(ArrayList<Integer> A, int m) {\n\t\t\tthis.A = A;\n\t\t\tthis.m = m;\n\t\t\tthis.hash = getHash(A);\n\t\t\tthis.h = calcHeuristic();\n\n\t\t\t//???????????Â¶\n\t\t\tif(hash == GOAL_HASH) {\n\t\t\t\tSystem.out.println(m);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\n\t\tpublic void heuristicSearch() {\n\t\t\tArrayList<Integer> Ac = new ArrayList<>(A);\n//\t\t\tSystem.out.println(hash + \" \" + m + \" \" + h);\n//\t\t\tSystem.out.println(Ac);\n\n\t\t\t//up\n\t\t\tif(Ac.indexOf(0) >= PUZZLE_WIDTH) {\n//\t\t\t\tSystem.out.println(\"up\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) - PUZZLE_WIDTH;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//down\n\t\t\tAc = new ArrayList<>(A);\n\t\t\tif(Ac.indexOf(0) < PUZZLE_SIZE - PUZZLE_WIDTH) {\n//\t\t\t\tSystem.out.println(\"down\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) + PUZZLE_WIDTH;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//left\n\t\t\tAc = new ArrayList<>(A);\n\t\t\tif(Ac.indexOf(0) % PUZZLE_WIDTH != 0) {\n//\t\t\t\tSystem.out.println(\"left\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) - 1;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//right\n\t\t\tAc = new ArrayList<>(A);\n\t\t\tif(Ac.indexOf(0) % PUZZLE_WIDTH != PUZZLE_WIDTH - 1) {\n//\t\t\t\tSystem.out.println(\"right\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) + 1;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate int calcHeuristic() {\n\t\t\tint heuristic = 0;\n\t\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\t\tint idx_1 = A.indexOf(i);\n\t\t\t\tint idx_2 = (i-1+PUZZLE_SIZE)%PUZZLE_SIZE;\n\t\t\t\tint d_1 = Math.abs((idx_1 % PUZZLE_WIDTH - idx_2 % PUZZLE_WIDTH));\n\t\t\t\tint d_2 = Math.abs((idx_1 / PUZZLE_WIDTH - idx_2 / PUZZLE_WIDTH));\n\t\t\t\theuristic +=  d_1 + d_2;\t//ex d=8 -> heu=2+2\n\t\t\t}\n\t\t\treturn heuristic;\n\t\t}\n\t}\n\n\tpublic static long getHash(ArrayList<Integer> A) {\n\t\tlong hash = 0;\n\t\tArrayList<Integer> set = new ArrayList<>();\n\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\tset.add(i);\n\t\t}\n\t\tfor(int i=PUZZLE_SIZE-1; i>=1; i--) {\n\t\t\thash += set.indexOf(A.get(i)) * factorial(i);\n\t\t\tset.remove(set.indexOf(A.get(i)));\n\t\t}\n\t\treturn hash;\n\t}\n\n\tprivate static long factorial(int k) {\n\t\tif(k == 1) {\n\t\t\treturn 1;\n\t\t} else if(fac[k] != 0) {\n\t\t\treturn fac[k];\n\t\t} else {\n\t\t\treturn k * factorial(k-1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (100,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.hvalue - y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/12.\n */\npackage sample;\n\nimport java.util.Scanner;\n\n/**\n * IDA* for 8 or 15 puzzle\n * f(x) = h(x) +depth(g(x))\n * @author huzhejie\n *\n */\npublic class Main {\n\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    /*\n    store the position of the each point of the target state\n     */\n    private int[][] targetPoints;\n\n    /*\n    f(x),total cost\n     */\n    private static int cost;\n\n    //target state\n    private static int[][] tState = {{1 ,2 ,3 },{4 ,5 ,6 },{7 ,8, 0}};\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        /*\n        get the position of blank point\n         */\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n        /*\n        get the position(x,y) by using a two-dimensional array.\n        e.g. 2's position is (2,1),\n        targetPoints [2][0] = 2-1 =1,targetPoints[2][1]=1-1=0\n         */\n        for(int i=0;i<tState.length;i++) {\n            for(int j=0;j<tState.length;j++) {\n                targetPoints[tState[i][j]][0] = i;\n\n                targetPoints[tState[i][j]][1] = j;\n            }\n        }\n    }\n    public boolean checkState(int[][] state){\n        boolean b =true;\n        for(int i = 0;i<SIZE;i++)\n            for(int j=0;j<SIZE;j++){\n                if(!(state[i][j]==tState[i][j]))\n                    b = false;\n            }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3&&(s=sc.nextLine())!=null){\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Main idaAlgorithm = new Main(sState);\n\n        if(idaAlgorithm.checkState(sState)){\n            System.out.println(step);\n        }\n        else{\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;\n\n            for (cost = j; ; cost++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            System.out.println(cost);\n        }\n    }\n    /**\n     *\n     * @param state\n     * @param blank_row the row-coordinate of 0 in ths state\n     * @param blank_column the column-coordinate of 0 in ths state\n     * @param dep the depth of the state\n     * @param d the direction of the last move\n     * @param h the value of h(x)\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,int d,int h) {\n        /*\n        the value of h(x) after moving\n         */\n        int h1;\n\n        /*\n        make a comparison with the target state\n         */\n        boolean isSolved = checkState(state);\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == cost) {\n            return false;\n        }\n\n        /*\n        the position of the blank point after moving\n         */\n        int blank_row1 ;\n        int blank_column1;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            /*\n            check whether the direction of this movement is opposite of the direction of the last move or not\n             */\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            /*\n            border check\n             */\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            /*\n            swap position\n             */\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            /*\n            calculate the h(x)\n             */\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n            /*\n            if f(x) increases,prune\n             */\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            /*\n            do the iteration with depth increasing\n             */\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * get the value of h(x)\n     * @param state\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n                \n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                    return true;\n            }\n        }\n        return false;\n    }\n\n//    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n//        Iterator<Node> iter = closeList.iterator();\n//        while(iter.hasNext())\n//        {\n//            Node iterNode = iter.next();\n//            if(iterNode.equal(newNode.status))\n//            {\n//                if(newNode.gvalue < iterNode.gvalue)\n//                {\n//                    iterNode.parent = newNode.parent;\n//                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n//                    iter.remove();\n//                    open.add(newNode);\n//                    return true;\n//                }\n//            }\n//        }\n//        return false;\n//    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "    import java.io.*; \n    import java.util.*; \n    public class Main {\n        public static final int SIZE = 3; \n        public static final int ALL_SIZE = SIZE * SIZE; \n        public static int[] factor= { 1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880 };\n        public static int hash(int[] A){ \n            int[] A_ = new int[A.length]; \n            System.arraycopy(A, 0, A_, 0, A.length); \n            int ret = 0; \n            for(int i = 0; i < A_.length; i++){ \n                ret += A_[i] * factor[(A.length - i - 1)]; \n                for(int j = i + 1; j < A_.length; j++){ \n                    if(A_[j] >= A_[i]){ \n                        A_[j]--; \n                    } \n                } \n            } \n            return ret; \n        } \n        public static int[] unhash(int hash){ \n            int[] ret = new int[ALL_SIZE]; \n            for(int i = 0; i < ALL_SIZE; i++) { \n                ret[i] = hash / factor[ALL_SIZE - i - 1]; \n                hash -= factor[ALL_SIZE - i - 1] * ret[i]; \n            } \n            for(int i = ALL_SIZE - 1; i >= 0; i--){ \n                for(int j = i + 1; j < ALL_SIZE; j++){ \n                    if(ret[i] <= ret[j]) \n                        ret[j]++; \n                } \n            } \n            return ret; \n        } \n        public static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0}); \n        public static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n        public static void main(String[] args) throws IOException { \n            Scanner sc = new Scanner(System.in);\n            int[] visited = new int[MAX]; \n            Arrays.fill(visited, Integer.MAX_VALUE); \n            LinkedList<Integer> queue = new LinkedList<>(); \n            int[] input = new int[ALL_SIZE]; \n            for(int i = 0; i < SIZE; i++){ \n                for(int j = 0; j < SIZE; j++){ \n                    input[i * SIZE + j] = sc.nextInt(); \n                } \n            } \n            final int hash_input = hash(input); \n            queue.add(hash_input); \n            visited[hash_input] = 0; \n            while(!queue.isEmpty()){ \n                final int hashed = queue.poll(); \n                if(hashed == GOAL){ \n                    System.out.println(visited[hashed]); \n                    break; \n                } \n                final int dist = visited[hashed]; \n                int[] ret = unhash(hashed); \n                for(int i = 0; i < ALL_SIZE; i++){ \n                    if(ret[i] == 0){ \n                        if(i % 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                        } \n                        if(i % 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                            queue.add(next_hash); } tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                        } \n                        if(i / 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                        } \n                        if(i / 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                        } \n                    } \n                } \n            } \n        } \n        public static class Scanner { \n            private BufferedReader br; \n            private StringTokenizer tok; \n            public Scanner(InputStream is) throws IOException { \n                br = new BufferedReader(new InputStreamReader(is)); \n            } \n            private void getLine() throws IOException { \n                while (!hasNext()) { \n                    tok = new StringTokenizer(br.readLine()); \n                } \n            } \n            private boolean hasNext() { \n                return tok != null && tok.hasMoreTokens(); \n            } \n            public String next() throws IOException { \n                getLine(); \n                return tok.nextToken(); \n            } \n            public int nextInt() throws IOException {\n                return Integer.parseInt(next()); \n            } \n            public long nextLong() throws IOException { \n                return Long.parseLong(next()); \n            } \n            public void close() throws IOException { \n                br.close(); \n            }\n        }\n    }\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int time = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tHS hs = new HS();\n\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\ths.SetIni(x, y, scan.nextInt());\n\n\t\tSystem.out.println(hs.solve());\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass HS {\n\tclass Bd {\n\t\tint[][] pn = new int[3][3];\n\t\tint oper = 0;\n\t\tint diff = 0;\n\n\t\tpublic int eval() {\n\t\t\tint ret = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tint p = pn[x][y];\n\t\t\t\t\tif (p != 0)\n\t\t\t\t\t\tret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);\n\t\t\t\t}\n\t\t\tdiff = ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void copy(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tpn[x][y] = b.pn[x][y];\n\t\t\tdiff = b.diff;\n\t\t\toper = b.oper;\n\t\t}\n\n\t\tprivate boolean up() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y + 1];\n\t\t\t\t\t\tpn[x][y + 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean down() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 1; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y - 1];\n\t\t\t\t\t\tpn[x][y - 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean right() {\n\t\t\tfor (int x = 1; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x - 1][y];\n\t\t\t\t\t\tpn[x - 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean left() {\n\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x + 1][y];\n\t\t\t\t\t\tpn[x + 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean move(int op) {\n\t\t\tswitch (op) {\n\t\t\tcase (0):\n\t\t\t\treturn up();\n\t\t\tcase (1):\n\t\t\t\treturn down();\n\t\t\tcase (2):\n\t\t\t\treturn right();\n\t\t\tcase (3):\n\t\t\t\treturn left();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean isSame(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (b.pn[x][y] != pn[x][y])\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate Bd bd = new Bd();\n\tprivate int[] gx = { 2, 0, 1, 2, 0, 1, 2, 0, 1 };\n\tprivate int[] gy = { 2, 0, 0, 0, 1, 1, 1, 2, 2 };\n\tprivate ArrayList<Bd> hist = new ArrayList<Bd>();\n\tprivate PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());\n\n\tclass Qcomparator implements Comparator<Bd> {\n\t\t@Override\n\t\tpublic int compare(Bd b1, Bd b2) {\n\t\t\tif (b1.diff + b1.oper > b2.diff + b2.oper)\n\t\t\t\treturn 1;\n\t\t\telse if (b1.diff + b1.oper == b2.diff + b2.oper)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic void SetIni(int x, int y, int a) {\n\t\tbd.pn[x][y] = a;\n\t}\n\n\tpublic int solve() {\n\t\tBd b = new Bd();\n\t\tb.copy(bd);\n\t\tb.eval();\n\t\tpqueue.add(b);\n\t\thist.add(b);\n\t\treturn search();\n\t}\n\n\tprivate int search() {\n\t\twhile (true) {\n\t\t\tBd b = pqueue.poll();\n\t\t\tif (b == null)\n\t\t\t\treturn -1;\n\n\t//\t\tprintBd(b);\n\n\t\t\tif (b.diff == 0)\n\t\t\t\treturn b.oper;\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tBd nb = new Bd();\n\t\t\t\tnb.copy(b);\n\t\t\t\tif (nb.move(i))\n\t\t\t\t\taddQueue(nb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean addQueue(Bd b) {\n\t\tfor (int i = 0; i < hist.size(); i++)\n\t\t\tif (b.isSame(hist.get(i)))\n\t\t\t\tif (b.oper < hist.get(i).oper) {\n\t\t\t\t\thist.get(i).oper = b.oper;\n\t\t\t\t\tpqueue.add(b);\n\t\t\t\t\treturn true;\n\t\t\t\t} else\n\t\t\t\t\treturn false;\n\t\tpqueue.add(b);\n\t\treturn true;\n\t}\n\n\tprivate void printBd(Bd b) {\n\t\tSystem.out.println(\"----------------\");\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tSystem.out.println(\"- \" + b.pn[0][y] + \" \" + b.pn[1][y] + \" \" + b.pn[2][y] + \" -\");\n\t\tSystem.out.println(\"------- diff \" + b.diff + \" oper \" + b.oper);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tPuzzle puzzle = new Puzzle();\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tint v = scanner.nextInt();\n\t\t\tpuzzle.map[i] = v;\n\t\t\tif (v == 0) {\n\t\t\t\tpuzzle.space = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(slove(puzzle));\n\t}\n\n\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tprivate int slove(Puzzle in) {\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\tDeque<Puzzle> deque = new ArrayDeque<Puzzle>();\n\t\tSet<Puzzle> set = new HashSet<Main.Puzzle>();\n\t\tset.add(in);\n\t\tdeque.offer(in);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tu = deque.poll();\n\t\t\tif (isTrue(u)) {\n\t\t\t\treturn u.count;\n\t\t\t}\n\t\t\tint y = u.space / N;\n\t\t\tint x = u.space % N;\n\t\t\tfor (int[] a : dxy) {\n\t\t\t\tint dy = y + a[0];\n\t\t\t\tint dx = x + a[1];\n\t\t\t\tif (dy < 0 || dx < 0 || N <= dy || N <= dx)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u.clone();\n\t\t\t\tswap(v, u.space, dy * N + dx);\n\t\t\t\tv.space = dy * N + dx;\n\t\t\t\tif (!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tv.count++;\n\t\t\t\t\tdeque.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate boolean isTrue(Puzzle u) {\n\t\tfor (int i = 0; i < N2 - 1; i++) {\n\t\t\tif (u.map[i] != i + 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint t = v.map[i];\n\t\tv.map[i] = v.map[space];\n\t\tv.map[space] = t;\n\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] map = new int[N2];\n\t\tint space;\n\t\tint count = 0;\n\n\t\t@Override\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tclonePuzzle.map = Arrays.copyOf(map, N2);\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + Arrays.hashCode(map);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPuzzle other = (Puzzle) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (!Arrays.equals(map, other.map))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = 9;\n\t\tchar[] s = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = (char)('0' + sc.nextInt());\n\t\t}\n\t\t\n\t\tString ans = \"123456780\";\n\t\tint[] d = {-3, 3, -1, 1};\n\t\t\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\n\t\tQueue<String> q = new ArrayDeque<String>();\n\t\tq.add(toString(s));\n\t\thm.put(toString(s), 0);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tif (u.equals(ans)) {\n\t\t\t\tSystem.out.println(hm.get(u));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tStringBuffer str = new StringBuffer(u);\n\t\t\tint zero = str.indexOf(\"0\");\n\t\t\tassert (zero != -1);\n\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\tif (zero + d[i] >= 0 && zero + d[i] < n && !(d[i] == -1 && (zero + d[i]) % 3 == 2) && !(d[i] == 1 && (zero + d[i]) % 3 == 0)) {\n\t\t\t\t\tstr.setCharAt(zero, str.charAt(zero + d[i]));\n\t\t\t\t\tstr.setCharAt(zero + d[i], '0');\n\t\t\t\t\tif (!hm.containsKey(str.toString())) {\n\t\t\t\t\t\tq.add(str.toString());\n\t\t\t\t\t\thm.put(str.toString(), hm.get(u) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tstr.setCharAt(zero + d[i], str.charAt(zero));\n\t\t\t\t\tstr.setCharAt(zero, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        sc.close();\n\t}\n\t\n\tprivate static String toString(char[] s) {\n\t\tString ret = \"\";\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tret += s[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????Â´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??Â¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????Â£????????Â¢??Â°??????????Â¬???????????????????????????Â§?????????\n\t\t//??????????Â¬???????????????????????????Â¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?Â¬????????????????????????\\??????????????Â£????????Â¢??Â°??????????Â°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?Â¬????????????????????????????????????Â§????????Â¨???????Â¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?Â¬?????Â¬????null??????\n\t\t\tfield temp = this.next.elem; //???????Â¬?????????Â£????????????temp???\n\t\t\tthis.next = null; //???????Â¬????null?????????\n\t\t\treturn temp; //???????Â¬??????Â£?????????temp?????????\n\t\t}else return this.next.pop(); //?Â¬?????Â¬????null??Â§????????Â£??????????Â¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????Â§????????????????????Â´????n?????????\n\n\t/**/\n\t//???????????\\??????????????Â¢??Â°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????Â¢????????Â°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????Â§????????Â°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????Â§????????Â°??????????????Â£????????????cell???val??Â¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????Â¨???val???cell??????????????????????????Â§??????cell???????????????dehash??Â§???????????Â¨????Â¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????Â£????????????????Â§??????Â§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?Â§????????????????????Â¨??????Â¨???\n\n\t\t//?Â§??????Â§?????????????????????????????????????Â¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????Â¨??????Â¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in).useDelimiter(\"[\\\\s]+\");\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tcell[3*i+j] = scan.nextInt();\n\t\t//for?????Â°???????????Â§cell??\\???\n\n\t\tst = new field(cell, hashkey(cell)); //??Â¨????????Â¢?????Â¨?????????????????Â¨???????????\\??????????????Â£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??Â¢?Â´Â¢??Â¨???\n\n\t\t//??????????????????????Â¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????Â£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??Â¢?Â´Â¢?????Â°???1?Â¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????Â¬???????????Â£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????Â£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??Â¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??Â¨???????????????floor?Â§?????????Â¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (100,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tPuzzle in = new Puzzle();\n\t\tScanner scanner = new Scanner(System.in);\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tin.f[i] = scanner.nextInt();\n\t\t\tif (in.f[i] == 0) {\n\t\t\t\tin.f[i] = N2;\n\t\t\t\tin.space = i;\n\t\t\t}\n\t\t}\n\t\tString ans = bfs(in);\n\t\tSystem.out.println(ans.length());\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tchar[] dir = { 'u', 'l', 'd', 'r' };\n\n\tprivate String bfs(Puzzle s) {\n\t\tDeque<Puzzle> Q = new ArrayDeque<Main.Puzzle>();\n\t\tMap<Puzzle, Boolean> V = new HashMap<Main.Puzzle, Boolean>();\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\ts.path = \"\";\n\t\tQ.push(s);\n\t\tV.put(s, true);\n\t\twhile (!Q.isEmpty()) {\n\t\t\tu = Q.poll();\n\t\t\tif (isTarget(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; r++) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = (Puzzle) u.clone();\n\t\t\t\tswap(v, u.space, tx * N + ty);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!V.containsKey(v) || !V.get(v)) {\n\t\t\t\t\tV.put(v, true);\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"unslovable\";\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint tmp = v.f[space];\n\t\tv.f[space] = v.f[i];\n\t\tv.f[i] = tmp;\n\t}\n\n\tprivate boolean isTarget(Puzzle p) {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (p.f[i] != (i + 1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] f = new int[N2];\n\t\tint space;\n\t\tString path;\n\t\t\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tint[] clonef = Arrays.copyOf(f, f.length);\n\t\t\t\tclonePuzzle.f = clonef;\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError(e.toString());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + Arrays.hashCode(f);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPuzzle other = (Puzzle) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (!Arrays.equals(f, other.f))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\t\t\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int time = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tHS hs = new HS();\n\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\ths.SetIni(x, y, scan.nextInt());\n\n\t\tSystem.out.println(hs.solve());\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass HS {\n\tclass Bd {\n\t\tint[][] pn = new int[3][3];\n\n\t\tpublic int eval() {\n\t\t\tint ret = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tint p = pn[x][y];\n\t\t\t\t\tif (p != 0)\n\t\t\t\t\t\tret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);\n\t\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void copy(Bd bd) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tpn[x][y] = bd.pn[x][y];\n\t\t}\n\n\t\tprivate boolean up() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y + 1];\n\t\t\t\t\t\tpn[x][y + 1] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean down() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 1; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y - 1];\n\t\t\t\t\t\tpn[x][y - 1] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean right() {\n\t\t\tfor (int x = 1; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x - 1][y];\n\t\t\t\t\t\tpn[x - 1][y] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean left() {\n\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x + 1][y];\n\t\t\t\t\t\tpn[x + 1][y] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean move(int op) {\n\t\t\tswitch (op) {\n\t\t\tcase (0):\n\t\t\t\treturn up();\n\t\t\tcase (1):\n\t\t\t\treturn down();\n\t\t\tcase (2):\n\t\t\t\treturn right();\n\t\t\tcase (3):\n\t\t\t\treturn left();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean same(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (b.pn[x][y] != pn[x][y])\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate Bd bd = new Bd();\n\tprivate int[] gx = { 2, 0, 1, 2, 0, 1, 2, 0, 1 };\n\tprivate int[] gy = { 2, 0, 0, 0, 1, 1, 1, 2, 2 };\n\tprivate ArrayList<Bd> hist = new ArrayList<Bd>();\n\n\tpublic void SetIni(int x, int y, int a) {\n\t\tbd.pn[x][y] = a;\n\t}\n\n\tpublic int solve() {\n\t\tBd b = new Bd();\n\t\tb.copy(bd);\n\t\thist.add(0, b);\n\t\tsearch(b);\n\t\treturn hist.size() - 1;\n\t}\n\n\tprivate boolean search(Bd b) {\n\t\t// printBd(b);\n\n\t\tif (b.eval() == 0)\n\t\t\treturn true;\n\n\t\tint[] pri = new int[4];\n\t\tBd[] nb = new Bd[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tnb[i] = new Bd();\n\t\t\tnb[i].copy(b);\n\t\t\tif (nb[i].move(i) && newPat(nb[i]))\n\t\t\t\tpri[i] = nb[i].eval();\n\t\t\telse\n\t\t\t\tpri[i] = -1;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint imin = -1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\tif (pri[i] != -1 && pri[i] < min) {\n\t\t\t\t\tmin = pri[i];\n\t\t\t\t\timin = i;\n\t\t\t\t}\n\t\t\tif (imin == -1)\n\t\t\t\tbreak;\n\n\t\t\tpri[imin] = -1;\n\t\t\thist.add(0, nb[imin]);\n\t\t\tif (search(nb[imin]))\n\t\t\t\treturn true;\n\t\t\thist.remove(0);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean newPat(Bd b) {\n\t\tfor (int i = 0; i < hist.size(); i++)\n\t\t\tif (b.same(hist.get(i)))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tprivate void printBd(Bd b) {\n\t\tSystem.out.println(\"----------------\");\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tSystem.out.println(\"- \" + b.pn[0][y] + \" \" + b.pn[1][y] + \" \" + b.pn[2][y] + \" -\");\n\t\tSystem.out.println(\"------- \" + b.eval() + \" hist \" + hist.size());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n  public static final int N = 9;\n  public static void main(String args[]){\n    Scanner sc = new Scanner(System.in);\n    char c[] = new char[N];\n    String end = \"123456780\";\n    String puzzle=\"\";\n    // int right = 1, left = -1, on = -3, under = 3;\n    int index[] = {1,-1,-3,3};\n    HashMap<String, Integer> hash = new HashMap<String, Integer>();\n    Queue<String> queue = new ArrayDeque<String>();\n    for(int i = 0; i<N; i++){\n      c[i] += (char)(sc.nextInt()+48);\n      puzzle +=c[i];\n    }\n    // for(int i = 0; i<N; i++){\n    //   System.out.print(c[i]);\n    // }\n    // puzzle = toString(c);\n    queue.add(puzzle);\n    hash.put(puzzle,0);\n\n    while(!queue.isEmpty()){\n      String comfirm = queue.remove();\n      if(comfirm.equals(end)){\n        // String comfirm = queue.remove();\n        System.out.println(hash.get(comfirm));\n        break;\n      }\n\n      StringBuffer s = new StringBuffer(comfirm);\n      int vacancy = s.indexOf(\"0\");\n      for(int i = 0; i<4; i++){\n        if(vacancy + index[i] >= 0 && vacancy + index[i]<N){//ç¯å²å¤ã§ãªãï¼ä¸ä¸ï¼\n          if( !((index[i] == -1)&& ((index[i]+vacancy) % 3==2))  &&  !((index[i] == 1) &&((index[i]+vacancy) % 3 == 0))  ){//å·¦å³ã®ç¯å²å¤ç¢ºèª\n            //äº¤æä½æ¥­ãã¦å­å¨ããªããã°ã­ã¥ã¼ã¨ããã·ã¥è¿½å ã\n            s.setCharAt(vacancy, s.charAt(vacancy + index[i]));\n            s.setCharAt(vacancy + index[i], '0');\n            if (!hash.containsKey(s.toString())) {\n              queue.add(s.toString());\n              hash.put(s.toString(), hash.get(comfirm)+1);\n            }\n            //ããã¦æ»ãã\n            s.setCharAt(vacancy + index[i], s.charAt(vacancy));\n            s.setCharAt(vacancy, '0');\n          }\n        }\n      }\n\n      // @Override\n      // public String toString() {\n      // }\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * IDA* for 8 or 15 puzzle\n * f(x) = h(x) +depth(g(x))\n *\n */\npublic class Main {\n\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    /*\n    store the position of the each point of the target state\n     */\n    private int[][] targetPoints;\n\n    /*\n    f(x),total cost\n     */\n    private static int cost;\n\n    //target state\n    private static int[][] tState = {{1 ,2 ,3 },{4 ,5 ,6 },{7 ,8, 0}};\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        /*\n        get the position of blank point\n         */\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n        /*\n        get the position(x,y) by using a two-dimensional array.\n        e.g. 2's position is (2,1),\n        targetPoints [2][0] = 2-1 =1,targetPoints[2][1]=1-1=0\n         */\n        for(int i=0;i<tState.length;i++) {\n            for(int j=0;j<tState.length;j++) {\n                targetPoints[tState[i][j]][0] = i;\n\n                targetPoints[tState[i][j]][1] = j;\n            }\n        }\n    }\n    public boolean checkState(int[][] state){\n        boolean b =true;\n        for(int i = 0;i<SIZE;i++)\n            for(int j=0;j<SIZE;j++){\n                if(!(state[i][j]==tState[i][j]))\n                    b = false;\n            }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3&&(s=sc.nextLine())!=null){\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Main idaAlgorithm = new Main(sState);\n\n        if(idaAlgorithm.checkState(sState)){\n            System.out.println(step);\n        }\n        else{\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;\n\n            for (cost = j; ; cost++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            System.out.println(cost);\n        }\n    }\n    /**\n     *\n     * @param state\n     * @param blank_row the row-coordinate of 0 in ths state\n     * @param blank_column the column-coordinate of 0 in ths state\n     * @param dep the depth of the state\n     * @param d the direction of the last move\n     * @param h the value of h(x)\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,int d,int h) {\n        /*\n        the value of h(x) after moving\n         */\n        int h1;\n\n        /*\n        make a comparison with the target state\n         */\n        boolean isSolved = checkState(state);\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == cost) {\n            return false;\n        }\n\n        /*\n        the position of the blank point after moving\n         */\n        int blank_row1 ;\n        int blank_column1;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            /*\n            check whether the direction of this movement is opposite of the direction of the last move or not\n             */\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            /*\n            border check\n             */\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            /*\n            swap position\n             */\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            /*\n            calculate the h(x)\n             */\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n            /*\n            if f(x) increases,prune\n             */\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            /*\n            do the iteration with depth increasing\n             */\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * get the value of h(x)\n     * @param state\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = 9;\n\t\tchar[] s = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = (char)('0' + sc.nextInt());\n\t\t}\n\t\t\n\t\tString ans = \"123456780\";\n\t\tint[] d = {-3, 3, -1, 1};\n\t\t\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\n\t\tQueue<String> q = new ArrayDeque<String>();\n\t\tq.add(toString(s));\n\t\thm.put(toString(s), 0);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tif (u.equals(ans)) {\n\t\t\t\tSystem.out.println(hm.get(u));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tStringBuffer str = new StringBuffer(u);\n\t\t\tint zero = str.indexOf(\"0\");\n\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\tif (zero + d[i] >= 0 && zero + d[i] < n) {\n\t\t\t\t\tstr.setCharAt(zero, str.charAt(zero + d[i]));\n\t\t\t\t\tstr.setCharAt(zero + d[i], '0');\n\t\t\t\t\tif (!hm.containsKey(str.toString())) {\n\t\t\t\t\t\tq.add(str.toString());\n\t\t\t\t\t\thm.put(str.toString(), hm.get(u) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tstr.setCharAt(zero + d[i], str.charAt(zero));\n\t\t\t\t\tstr.setCharAt(zero, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        sc.close();\n\t}\n\t\n\tprivate static String toString(char[] s) {\n\t\tString ret = \"\";\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tret += s[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue - y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\nclass Main {\n\n\t\n\tprivate int[] up = {-1,0};\n\tprivate int[] down = {1,0};\n\tprivate int[] left = {0,-1};\n\tprivate int[] right = {0,1};\n\t\n\tpublic static int sum = 0;\n\tprivate final int UP = 0;\n\tprivate final int DOWN = 2;\n\tprivate final int LEFT = 1;\n\tprivate final int RIGHT = 3;\n\t\n\tprivate static int SIZE = 3;\n\t\n\t\n\tprivate int[][] target; \n\t\n\t\n\tprivate static int[] moves = new int[100000];\n\t\n\tprivate static long ans = 0;\n\t\n\t\n\tprivate static int[][] tState = {\n\t\t{1 ,2 ,3 } ,\n\t\t{4, 5 ,6 } ,\n\t\t{7, 8 ,0 } ,\n\t};\n\t\n\tprivate static int[][] sState;\n\t\n\n\t\n\tprivate static int blank_row,blank_column;\n\t\n\tpublic Main(int[][] state) {\n\t\tSIZE = state.length;\n\t\ttarget = new int[SIZE * SIZE][2];\n\t\t\n\t\tthis.sState = state;\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\tblank_row = i;\n\t\t\t\t\tblank_column = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\ttarget[tState[i][j]][0] = i; \n\t\t\t\t\n\t\t\t\ttarget[tState[i][j]][1] = j; \n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tsState = new int[SIZE][SIZE];\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++)\n\t\t\t\tsState[i][j]=sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tMain idaAlgorithm = new Main(sState);\n\t\t\n\t\n\t\tint j = idaAlgorithm.getHeuristic(sState);\n\t\t\n\t\tint i = -1;\n\t\t\n\t\t\n\t\tfor(ans=j;;ans++) {\n\t\t\tif(idaAlgorithm.solve(sState\n\t\t\t\t\t,blank_row,blank_column,0,i,j)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tif(ans != 0) {\n\t\t\tint[][] matrix = idaAlgorithm.move(sState,moves[0]);\n\t\t\tfor(int k=1;k<ans;k++) {\n\t\t\t\tmatrix = idaAlgorithm.move(matrix, moves[k]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\n\tpublic int[][] move(int[][]state,int direction) {\n\t\tint row = 0;\n\t\tint column = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\trow = i;\n\t\t\t\t\tcolumn = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch(direction) {\n\t\tcase UP:\n\t\t\tstate[row][column] = state[row-1][column];\n\t\t\tstate[row-1][column] = 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tstate[row][column] = state[row+1][column];\n\t\t\tstate[row+1][column] = 0;\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tstate[row][column] = state[row][column-1];\n\t\t\tstate[row][column-1] = 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tstate[row][column] = state[row][column+1];\n\t\t\tstate[row][column+1] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsum++;\n\t\treturn state;\n\t}\n\t\n\t\n\t\n\t\n\tpublic boolean solve(int[][] state,int blank_row,int blank_column,\n\t\t\tint dep,long d,long h) {\n\t\t\n\t\tlong h1;\n\t\t\n\t\tboolean isSolved = true;\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++) {\n\t\t\t\tif(state[i][j] != tState[i][j]) {\n\t\t\t\t\tisSolved = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isSolved) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(dep == ans) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\n\t\tint blank_row1 = blank_row;\n\t\tint blank_column1  = blank_column;\n\t\tint[][] state2 = new int[SIZE][SIZE];\n\n\t\tfor(int direction=0;direction<4;direction++) {\n\t\t\tfor(int i=0;i<state.length;i++) {\n\t\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\t\tstate2[i][j] = state[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(direction != d && (d%2 == direction%2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(direction == UP) {\n\t\t\t\tblank_row1 = blank_row + up[0];\n\t\t\t\tblank_column1 = blank_column + up[1];\n\t\t\t} else if(direction == DOWN) {\n\t\t\t\tblank_row1 = blank_row + down[0];\n\t\t\t\tblank_column1 = blank_column + down[1];\n\t\t\t} else if(direction == LEFT) {\n\t\t\t\tblank_row1 = blank_row + left[0];\n\t\t\t\tblank_column1 = blank_column + left[1];\n\t\t\t} else {\n\t\t\t\tblank_row1 = blank_row + right[0];\n\t\t\t\tblank_column1 = blank_column + right[1];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(blank_column1 < 0 || blank_column1 == SIZE\n\t\t\t\t\t|| blank_row1 < 0 || blank_row1 == SIZE) {\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\tstate2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n\t\t\tstate2[blank_row1][blank_column1] = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(direction == DOWN && blank_row1 \n\t\t\t\t\t> target[state[blank_row1][blank_column1]][0]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == UP && blank_row1 \n\t\t\t\t\t< target[state[blank_row1][blank_column1]][0]){\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == RIGHT && blank_column1 \n\t\t\t\t\t> target[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == LEFT && blank_column1 \n\t\t\t\t\t< target[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else { \n\t\t\t\t\n\t\t\t\th1 = h + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(h1+dep+1>ans) { \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmoves[dep] = direction;\n\t\t\t\n\t\t\t\n\t\t\tif(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tpublic int getHeuristic(int[][] state) {\n\t\tint he = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] != 0) {\n\t\t\t\t\the = he + \n\t\t\t\t\t\t\tMath.abs(target[state[i][j]][0] - i)\n\t\t\t\t\t\t\t+ Math.abs(target[state[i][j]][1] - j);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn he;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main {\n\t// Main\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] board = new int[9];\n\t\tStringTokenizer st = new StringTokenizer(br.readLine(),\" \");\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (i==3||i==6) {\n\t\t\t\tst = new StringTokenizer(br.readLine(), \" \");\n\t\t\t}\n\t\t\tboard[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tDeque<state> mainq = new ArrayDeque<state>();\n\t\tBitSet cl = new BitSet(500000);\n\t\tmainq.add(new state(board, 0));\n\t\tcl.set(hashBoard(board));\n\t\tint minStep = -1;\n\t\twhile(!mainq.isEmpty()){\n\t\t\tfinal state s = mainq.remove();\n\t\t\tif (hashBoard(s.board) == 46233) {\n\t\t\t\tminStep = s.move;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint pos;\n\t\t\tfor(pos = 0; pos<9 && s.board[pos] != 0; pos++);\n\t\t\t\n\t\t\tif (pos%3 != 0) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos-1];\n\t\t\t\tnext[pos-1] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pos%3 != 2) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos+1];\n\t\t\t\tnext[pos+1] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pos > 2) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos - 3];\n\t\t\t\tnext[pos-3] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pos < 6) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos + 3];\n\t\t\t\tnext[pos+3] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t} //end while\n\tSystem.out.println(minStep);\t\n\t}// End Main\n\t\n\t// Hash the game board state\n\tprivate static int hashBoard(int[] board){\n\t\tint h = board[0];\n\t\tfor (int i = 1; i < 8; i++) {\n\t\t\th = h*(9-i);\n\t\t\th = h+board[i];\n\t\t\tfor (int a = 0; a < i; a++) {\n\t\t\t\tif (board[a]<board[i]) {\n\t\t\t\t\t--h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}// End Hash Board\n}\n\n\n\n\n\n// State Class\nclass state{\n\tfinal int[] board;\n\tfinal int move;\n\tstate(int[] board, int move){\n\t\tthis.board = board;\n\t\tthis.move = move;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n \npublic class Main {\n \n    public static void main(String[] args) throws IOException {\n        // TODO ?????????????????????????????????????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n         \n        int input = 0;\n        for(int i = 0; i < 3; i++){\n            String[] tmpStr = br.readLine().split(\" \");\n            for(int j = 0; j < 3; j++){\n                int number = Integer.parseInt(tmpStr[j]);\n                //?????????????????\\???????????Â§0???9???????????????\n                if(number == 0){\n                    number = 9;\n                }\n                input += number * Math.pow(10, 8 - (i*3 + j));\n            }\n        }\n        //???????????????????????????\n        //System.out.println(swapTiles(123496758, DOWN));\n        /*\n        boolean[] tmpResult = checkAvailable(921436795);\n        if(tmpResult[UP]){\n        \tSystem.out.println(\"UP OK\");\n        }\n        if(tmpResult[RIGHT]){\n        \tSystem.out.println(\"RIGHT OK\");\n        }\n        if(tmpResult[DOWN]){\n        \tSystem.out.println(\"DOWN OK\");\n        }\n        if(tmpResult[LEFT]){\n        \tSystem.out.println(\"LEFT OK\");\n        }\n        */\n        \n        //System.out.println(input);\n        \n        searchPath(input, 0, START);\n        //System.out.println(\"END\");\n        System.out.println(minimumTurn.get(123456789));\n    }\n     \n    static int call = 0;\n    static void recursiveTest(int depth){\n        char[][] test = new char[3][3];\n         \n        call++;\n        System.out.println(\"depth is \"+depth+\" call \"+call);\n        if(depth == 32){\n            return;\n        }\n        recursiveTest(depth + 1);\n        recursiveTest(depth + 1);\n        recursiveTest(depth + 1);\n        recursiveTest(depth + 1);\n    }\n    \n    static HashMap<Integer, Integer> minimumTurn = new HashMap<Integer, Integer>();\n    static final int finish = 123456789;\n    static int currentMin = Integer.MAX_VALUE;\n    \n    static int searchPath(int condition, int depth, int direction){\n    \t//?????Â§??????????????Â£?????????????????Â±??????????????????\n    \tif(depth >= currentMin || depth >= 32){\n    \t\treturn 0;\n    \t}\n    \t//??????????\\?\n    \tif(direction != START){\n    \t\tcondition = swapTiles(condition, direction);\n    \t}\n    \t//System.out.println(condition+\" depth = \"+depth + \" hash size \"+ minimumTurn.size());\n    \tif(!minimumTurn.containsKey(condition) || minimumTurn.get(condition) > depth){\n    \t\tminimumTurn.put(condition, depth);\n    \t}\n    \t\n    \t//????Â§?????????????????????Â§??????\n    \telse if(minimumTurn.get(condition) <= depth){\n    \t\treturn 0;\n    \t}\n    \t\n    \t//??Â¢?Â´Â¢?????????????????Â§??????\n    \tif(condition == finish){\n    \t\t///System.exit(0);\n    \t\tcurrentMin = depth;\n    \t\treturn 1;\n    \t}\n    \tboolean[] available = checkAvailable(condition);\n    \tint result = 0;\n    \t//???\n    \tif(direction != DOWN && available[UP]){\n    \t\tsearchPath(condition, depth + 1, UP);\n    \t}\n    \t//???\n    \tif(direction != LEFT && available[RIGHT]){\n    \t\tsearchPath(condition, depth + 1, RIGHT);\n    \t}\n    \t//???\n    \tif(direction != UP && available[DOWN]){\n    \t\tsearchPath(condition, depth + 1, DOWN);\n    \t}\n    \t//???\n    \tif(direction != RIGHT && available[LEFT]){\n    \t\tsearchPath(condition, depth + 1, LEFT);\n    \t}\n    \treturn 0;\n    }\n    \n    private static int swapTiles (int condition, int direction){\n    \tchar[] condChar = Integer.toString(condition).toCharArray();\n    \t\n    \tint index9 = Integer.toString(condition).indexOf('9');\n    \tint targetIndex;\n    \tif(direction == UP){\n    \t\ttargetIndex = index9 - 3;\n    \t}\n    \telse if(direction == RIGHT){\n    \t\ttargetIndex = index9 + 1;\n    \t}\n    \telse if(direction == DOWN){\n    \t\ttargetIndex = index9 + 3;\n    \t}\n    \telse{\n    \t\ttargetIndex = index9 - 1;\n    \t}\n    \t\n    \tchar tmp = condChar[index9];\n    \tcondChar[index9] = condChar[targetIndex];\n    \tcondChar[targetIndex] = tmp;\n    \t\t\t\n    \t\n    \treturn Integer.parseInt(new String(condChar));\n    }\n    \n    static final int UP = 0;\n    static final int RIGHT = 1;\n    static final int DOWN = 2;\n    static final int LEFT = 3;\n    static final int START = 4;\n    \n    private static boolean[] checkAvailable(int condition){\n    \tboolean [] result = new boolean[4];\n    \tArrays.fill(result, true);\n    \t\n    \tString condStr = Integer.toString(condition);\n    \tint index9 = condStr.indexOf('9');\n    \t\n    \tif(index9 == 0 || index9 == 1 || index9 == 2 ){\n    \t\tresult[UP] = false;\n    \t}\n    \tif(index9 == 2 || index9 == 5 || index9 == 8){\n    \t\tresult[RIGHT] = false;\n    \t}\n    \tif(index9 == 6 || index9 == 7 || index9 == 8){\n    \t\tresult[DOWN] = false;\n    \t}\n    \tif(index9 == 0 || index9 == 3 || index9 == 6){\n    \t\tresult[LEFT] = false;\n    \t}\n    \t\n    \treturn result;\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements  Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue-y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????Â´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?Â¨???????????????Â¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????Â°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????Â¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??Â¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????Â£????????Â¢??Â°??????????Â¬???????????????????????????Â§?????????\n\t\t//??????????Â¬???????????????????????????Â¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?Â¬????????????????????????\\??????????????Â£????????Â¢??Â°??????????Â°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?Â¬????????????????????????????????????Â§????????Â¨???????Â¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?Â¬?????Â¬????null??????\n\t\t\tfield temp = this.next.elem; //???????Â¬?????????Â£????????????temp???\n\t\t\tthis.next = null; //???????Â¬????null?????????\n\t\t\treturn temp; //???????Â¬??????Â£?????????temp?????????\n\t\t}else return this.next.pop(); //?Â¬?????Â¬????null??Â§????????Â£??????????Â¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????Â§????????????????????Â´????n?????????\n\n\t/**/\n\t//???????????\\??????????????Â¢??Â°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????Â¢????????Â°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????Â§????????Â°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????Â§????????Â°??????????????Â£????????????cell???val??Â¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????Â¨???val???cell??????????????????????????Â§??????cell???????????????dehash??Â§???????????Â¨????Â¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????Â£????????????????Â§??????Â§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?Â§????????????????????Â¨??????Â¨???\n\n\t\t//?Â§??????Â§?????????????????????????????????????Â¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????Â¨??????Â¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in).useDelimiter(\"[\\\\s]+\");\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tcell[3*i+j] = scan.nextInt();\n\t\t//for?????Â°???????????Â§cell??\\???\n\n\t\tst = new field(cell, hashkey(cell)); //??Â¨????????Â¢?????Â¨?????????????????Â¨???????????\\??????????????Â£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??Â¢?Â´Â¢??Â¨???\n\n\t\t//??????????????????????Â¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????Â£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??Â¢?Â´Â¢?????Â°???1?Â¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????Â¬???????????Â£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????Â£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????Â¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????Â¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length-1);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??Â¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??Â¨???????????????floor?Â§?????????Â¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static final int SIZE = 3;\n\tpublic static final int ALL_SIZE = SIZE * SIZE;\n\t\n\tpublic static int[] factor=  {\n\t\t1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880\n\t}; //0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\t\n\t//å®å¨æå°ããã·ã¥ãä½ã.\n\tpublic static int hash(int[] A){\n\t\tint[] A_ = new int[A.length];\n\t\tSystem.arraycopy(A, 0, A_, 0, A.length);\n\t\t\n\t\tint ret = 0;\n\t\t\n\t\tfor(int i = 0; i < A_.length; i++){\n\t\t\tret += A_[i] * factor[(A.length - i - 1)];\n\t\t\t\n\t\t\tfor(int j = i + 1; j < A_.length; j++){\n\t\t\t\tif(A_[j] >= A_[i]){ A_[j]--; }\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int[] unhash(int hash){\n\t\tint[] ret = new int[ALL_SIZE];\n\t\t\n\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\tret[i] = hash / factor[ALL_SIZE - i - 1];\n\t\t\thash -= factor[ALL_SIZE - i - 1] * ret[i];\n\t\t}\n\t\t\n\t\tfor(int i = ALL_SIZE - 1; i >= 0; i--){\n\t\t\tfor(int j = i + 1; j < ALL_SIZE; j++){\n\t\t\t\tif(ret[i] <= ret[j]) ret[j]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\tpublic static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0});\n\tpublic static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//System.out.println(Arrays.toString(unhash(GOAL)));\n\t\t\n\t\tint[] visited = new int[MAX];\n\t\tArrays.fill(visited, Integer.MAX_VALUE);\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\n\t\tint[] input = new int[ALL_SIZE];\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tinput[i * SIZE + j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int hash_input = hash(input);\n\t\tqueue.add(hash_input);\n\t\tvisited[hash_input] = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal int hashed = queue.poll();\n\t\t\t\n\t\t\tif(hashed == GOAL){\n\t\t\t\tSystem.out.println(visited[hashed]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int dist = visited[hashed];\n\t\t\t\n\t\t\tint[] ret = unhash(hashed);\n\t\t\t\n\t\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\t\tif(ret[i] == 0){\n\t\t\t\t\tif(i % 3 != 0){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - 1];\n\t\t\t\t\t\tret[i - 1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - 1];\n\t\t\t\t\t\tret[i - 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i % 3 != 2){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + 1];\n\t\t\t\t\t\tret[i + 1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + 1];\n\t\t\t\t\t\tret[i + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i / 3 != 0){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - SIZE];\n\t\t\t\t\t\tret[i - SIZE] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - SIZE];\n\t\t\t\t\t\tret[i - SIZE] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i / 3 != 2){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + SIZE];\n\t\t\t\t\t\tret[i + SIZE] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + SIZE];\n\t\t\t\t\t\tret[i + SIZE] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100,nodeComparator);\n    public List<Node>  close =new ArrayList<Node> ();\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????Â¨???????????Â°?????????????????Â°???g??? ???????Â°??????Â°??Â¨???g????????????????????????\n        //???????????????????????????????????Â¢?????Â°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, List<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) > depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\nimport java.util.List;\n\n/**\n * A* for 8 puzzle\n * f(x) = h(x) +step(g(x))\n * @author huzhejie\n *\n */\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startState=new int[3][3];\n        /*\n        read the data and build the startState two-dimentional array\n         */\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Astar test = new Astar(startState);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    /*\n    store the start state\n     */\n    public int[][] startState;\n\n    /*\n    end state\n     */\n    public int[][] endState = {{1,2,3},{4,5,6},{7,8,0}};\n\n    /*\n    node comparator\n     */\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n\n    /*\n    a open list that stores the states that have not been checked\n     */\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n\n    /*\n    a close list that stores two-dimentional arrays that have been checked\n     */\n    public Set<int[][]>  close =new HashSet<int[][]>();\n\n\n    public Astar(int[][] startState)\n    {\n        this.startState = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startState[i][j] = startState[i][j];\n            }\n        }\n    }\n\n    /**\n     * initialize A* with giving values to the start node(start state)\n     */\n\n    private void initStart()\n    {\n        Node startNode = new Node(startState);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        open.add(startNode);\n    }\n\n    /**\n     * check if the node(state) has been checked before\n     * @param lNode\n     * @param newNodeParent\n     * @return\n     */\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        if(newNodeParent != null&&lNode.equal(newNodeParent.state))\n        {\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * initialize the child nodes of the new nodes by moving in four diffirent directions\n     * @param newNode\n     * @param newNodeChild\n     */\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        /*\n        zeroPosition is from 0 to 8.\n        e.g. if it is 2,then the position of blank block is (3,1)(third column,first row)\n         */\n        int zeroPosition;\n        zeroPosition = newNode.getBlankPosition();\n\n        /*\n        check if the blank block can be moved leftwards\n         */\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.state[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n        }\n\n        /*\n        check if the blank block can be moved rightwards\n         */\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.state[zeroPosition/3][(zeroPosition%3)-1] = 0;\n\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n\n        }\n\n        /*\n        check if the blank block can be moved downwards\n         */\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3+1][zeroPosition%3];\n            lNode.state[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n        }\n\n        /*\n        check if the blank block can be moved upwards\n         */\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3-1][zeroPosition%3];\n            lNode.state[zeroPosition/3-1][zeroPosition%3] = 0;\n\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n\n    /**\n     * update open list\n     * @param NodeList  the child nodes list of the new node\n     */\n    private void updateOpenList(List<Node> NodeList){\n        for(Node childNode:NodeList) {\n            if (isInCloseList(childNode.state, close));\n            else open.add(childNode);\n        }\n    }\n\n    /**\n     * check if the state is already checked\n     * @param state  the state that is to be checked\n     * @param closeList close list\n     * @return\n     */\n    private boolean isInCloseList(int[][] state, Set<int[][]> closeList)\n    {\n        if(closeList.contains(state)){\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     *  the main execution part of the A* algorithm\n     */\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode.state);\n            if (newNode.equal(endState)) {\n                int step = 0;\n                while (newNode.parent!=null) {\n                    newNode = newNode.parent;\n                    step += 1;\n                }\n                System.out.println(step);\n                break;\n            }\n            List<Node> newNodeChild =new ArrayList<Node>();\n            initChild(newNode,newNodeChild);\n            updateOpenList(newNodeChild);\n        }\n    }\n}\n\n/**\n * node comparator\n */\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\n\n\nclass Node\n{\n    /*\n    the prarent node of this node\n     */\n    Node parent;\n\n    /*\n    state of the node\n     */\n    public int[][] state = new int[3][3];\n\n    /*\n    the value of g(x)\n     */\n    int gvalue;\n\n    /*\n    the value of h(x)\n     */\n    int hvalue;\n\n\n    public Node(int[][] state)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.state[i][j] = state[i][j];\n            }\n        }\n    }\n\n    /**\n     * get the position of the blank block\n     * @return\n     */\n    public int getBlankPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(state[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    /**\n     * check if the state is equal to the end state\n     * @param endState\n     * @return\n     */\n    public boolean equal(int[][] endState)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(state[i][j]!= endState[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * calculate the h(x) of the node\n     * @return\n     */\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(state[i][j]!=0)\n                    sum+=Math.abs(i-(state[i][j]-1)/3)+Math.abs(j-(state[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tPuzzle in = new Puzzle();\n\t\tScanner scanner = new Scanner(System.in);\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tin.f[i] = scanner.nextInt();\n\t\t\tif (in.f[i] == 0) {\n\t\t\t\tin.f[i] = N2;\n\t\t\t\tin.space = i;\n\t\t\t}\n\t\t}\n\t\tString ans = bfs(in);\n\t\tSystem.out.println(ans.length());\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tchar[] dir = { 'u', 'l', 'd', 'r' };\n\n\tprivate String bfs(Puzzle s) {\n\t\tDeque<Puzzle> Q = new ArrayDeque<Main.Puzzle>();\n\t\tMap<Puzzle, Boolean> V = new HashMap<Main.Puzzle, Boolean>();\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\ts.path = \"\";\n\t\tQ.push(s);\n\t\tV.put(s, true);\n\t\twhile (!Q.isEmpty()) {\n\t\t\tu = Q.poll();\n\t\t\tif (isTarget(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; r++) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = (Puzzle) u.clone();\n\t\t\t\tswap(v, u.space, tx * N + ty);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!V.containsKey(v) || !V.get(v)) {\n\t\t\t\t\tV.put(v, true);\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"unslovable\";\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint tmp = v.f[space];\n\t\tv.f[space] = v.f[i];\n\t\tv.f[i] = tmp;\n\t}\n\n\tprivate boolean isTarget(Puzzle p) {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (p.f[i] != (i + 1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] f = new int[N2];\n\t\tint space;\n\t\tString path;\n\t\t\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tint[] clonef = Arrays.copyOf(f, f.length);\n\t\t\t\tclonePuzzle.f = clonef;\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError(e.toString());\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    final static int LineN=3;\n    final static int FullN=9;\n    final static int[] dx={-1,0,1,0};\n    final static int[] dy={0,-1,0,1};\n    final static long Goalhash=1234567890;\n    final static String[] dir={\"u\",\"l\",\"d\",\"r\"};//up left down right\n    static Queue<Puzzle> que= new ArrayDeque<Puzzle>();\n    static Map<Long,Puzzle> mp= new LinkedHashMap<Long,Puzzle>(16,0.75f,true);\n    public static void main(String[]args){\n\tint i;\n\tString path;\n\tPuzzle nyu= new Puzzle(FullN);\n\tScanner sca = new Scanner(System.in);\n\tfor(i=0;i<FullN;i++){\n\t    nyu.f[i]=sca.nextInt();\n\t    if(nyu.f[i]==0){\n\t\tnyu.f[i]=FullN;//0<->9\n\t\tnyu.space=i;\n\t    }\n\t}\n\tnyu.path=\"\";\n\tpath=play(nyu);\n\tSystem.out.println(path.length());\n    }\n    static long makemyhash(Puzzle p){\n\tint i;\n\tlong ha=0;\n\tfor(i=0;i<FullN;i++){\n\t    ha+=p.f[i];//making hash;\n\t    ha*=10;\n\t}\n\tif(p.f[0]==1&&p.kotei==false)p.kotei=true;//fixing 1 to f[0]\n \treturn ha;\n    }\n    \n    static String play(Puzzle first){\n\tint sx,sy,i,hzi,tx,ty;\n\tlong hzhash;\n\tPuzzle u,v;\n\tque.add(first);\n\tmp.put(makemyhash(first),first);\n\twhile(!que.isEmpty()){\n\t    u=que.poll();\n\t    if(makemyhash(u)==Goalhash)return u.path;\n\t    sx=u.space/LineN;//5->1(calculate x index of 0)\n\t    sy=u.space%LineN;//5->2(calculate y index of 0)\n\t    for(i=0;i<4;i++){\n\t\ttx=sx+dx[i];//calculate movement x\n\t\tty=sy+dy[i];\n\t\tif(tx<0||ty<0||tx>=LineN||ty>=LineN)continue;\n\t      \tif(tx==0&&ty==0&&u.kotei==true)continue;\n\t\tv=myclone(u);\n\t\thzi=v.f[v.space];\n\t\tv.f[v.space]=v.f[tx*LineN+ty];//changing\n\t\tv.f[tx*LineN+ty]=hzi;\n\t\tv.space=tx*LineN+ty;\n\t\tv.hash=hzhash=makemyhash(v);\n\t\tif(mp.containsKey(hzhash)==false){\n\t\t    mp.put(hzhash,v);\n\t\t    v.path+=dir[i];//add char\n\t\t    que.add(v);\n\t       \t}else{\n\t\t}\n\t    }\n\t}\n\treturn \"impossible\";\n    }\n    public static Puzzle myclone(Puzzle p){\n\tint i;\n\tPuzzle im=new Puzzle(FullN);\n\tfor(i=0;i<FullN;i++){\n\t     im.f[i]=p.f[i];\n\t}\n\tim.space=p.space;\n\tim.path=p.path;\n\tim.kotei=p.kotei;\n      \tim.hash=p.hash;\n\treturn im;\n    }\n}\nclass Puzzle{\n     public int f[];\n     public int space;\n     public String path;\n    public long hash;\n    public boolean kotei=false;\n    Puzzle(int n){\n\tf=new int[n];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle : IComparable\n    {\n        internal int[] f;\n        internal int space, MD, cost;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = cost = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n            space = source.space;\n            MD = source.MD;\n            cost = source.cost;\n        }\n\n        public override int GetHashCode()\n        {\n            return MakeString(f).GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return MakeString(f) == MakeString(other.f);\n        }\n\n        public int CompareTo(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return (other.cost + other.MD) - (cost + MD);\n        }\n\n        private string MakeString(int[] arr)\n        {\n            StringBuilder sb = new StringBuilder();\n            foreach (var item in arr) sb.Append(item);\n            return sb.ToString();\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        //readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n        }\n\n        public int Astar(Puzzle p)\n        {\n            PriorityQueue<Puzzle> PQ = new PriorityQueue<Puzzle>();\n            p.MD = GetAllMD(p);\n\n            HashSet<Puzzle> V = new HashSet<Puzzle>();\n\n            PQ.Enqueue(p);\n\n            Puzzle u, v;\n\n            while (PQ.Count() > 0)\n            {\n                u = PQ.Dequeue();\n\n                if (u.MD == 0) return u.cost;\n\n                V.Add(u);\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    v = new Puzzle(u);\n\n                    int indexT = tx + ty * w;\n                    int indexS = sx + sy * w;\n\n                    v.MD -= MDT[indexT, v.f[indexT] - 1];\n                    v.MD += MDT[indexS, v.f[indexT] - 1];\n\n                    int temp = v.f[indexT];\n                    v.f[indexT] = v.f[indexS];\n                    v.f[indexS] = temp;\n\n                    v.space = indexT;\n\n                    if (!V.Contains(v))\n                    {\n                        v.cost++;\n                        PQ.Enqueue(v);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n            Console.WriteLine(NP.Astar(s));\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count() { return size; }\n\n        private int Compare(T x, T y) { return y.CompareTo(x); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToList();\n        \n        empty.AdjacentNumbers\n            .Zip(children, (i, board) => \n            {\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == i));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        static void Main(string[] args)\n        {\n            var n = 3;\n            var n2 = n * n;\n            var masu = new int[n, n];\n            for (var i = 0; i < n; ++i)\n            {\n                var num = Sarray();\n                for (var j = 0; j < n; ++j)\n                    masu[i, j ] = (int)num[j];\n            }\n            var e = new EPuzzle(masu);\n            WriteLine(e.bfs().Length);\n        }\n        class EPuzzle\n        {\n            public class Puzzle :IEquatable<Puzzle>\n            {\n                public int space;\n                public string path;\n                public int[] f;\n                public Puzzle(int N2, int space, int MD)\n                {\n                    this.space = space;\n                    f = new int[N2];\n                    path = string.Empty;\n                }\n                public Puzzle(Puzzle p)\n                {\n                    space = p.space;\n                    path = p.path;\n                    f = new int[p.f.Length];\n                    Array.Copy(p.f, f, p.f.Length);\n                }\n                public bool Equals(Puzzle other) => this.f.SequenceEqual(other.f);\n                public override int GetHashCode() => f.Aggregate(0, (acc, i) => unchecked(acc * 457 + i * 389));\n            }\n            readonly int[] dx = new int[] { 0, -1, 0, 1 };//Height\n            readonly int[] dy = new int[] { 1, 0, -1, 0 };//Width\n            readonly string dir = \"ruld\";\n            readonly int N;\n            readonly int N2;\n            Puzzle p;\n            public EPuzzle(int[,] inp)\n            {\n                N = inp.GetLength(0);\n                N2 = N * N;\n                p = new Puzzle(N2, 0, 0);\n                for(var i=0;i<N;++i)\n                    for(var j=0;j<N;++j)\n                    {\n                        p.f[i * N + j] = inp[i, j];\n                        if (p.f[i * N + j] == 0)\n                        {\n                            p.space = i * N + j;\n                            p.f[i * N + j] = N2;\n                        }\n                    }\n            }\n            bool isTarget(Puzzle p)\n            {\n                for (var i = 0; i < N2; ++i)\n                    if (p.f[i] != i + 1) return false;\n                return true;\n            }\n            public string bfs()\n            {\n                var Q = new Queue<Puzzle>();\n                var V = new HashSet<Puzzle>();\n\n                Q.Enqueue(p);\n                V.Add(p);\n\n                while(Q.Any())\n                {\n                    var u = Q.Dequeue();\n                    if (isTarget(u)) return u.path;\n                    var sx = u.space / N;\n                    var sy = u.space % N;\n                    for (var r = 0; r < 4; ++r)\n                    {\n                        var tx = sx + dx[r];\n                        var ty = sy + dy[r];\n                        if (tx < 0 || ty < 0 || N <= tx || N <= ty) continue;\n                        var v = new Puzzle(u);\n\n                        v.f[u.space] = v.f[tx * N + ty];\n                        v.f[tx * N + ty] = N2;\n                        v.space = tx * N + ty;\n\n                        if (!V.Contains(v))\n                        {\n                            v.path += dir[r];\n                            V.Add(v);\n                            Q.Enqueue(v);\n                        }\n                    }\n                }\n                return \"unsolvable\";\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic string s { get; set; }\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int step { get; set; }\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tvar map = new int[3, 3];\n\t\tvar sx = 0;  var sy = 0;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tmap[i, j] = int.Parse(line[j]);\n\t\t\t\tif (map[i,j] == 0) { sx = i; sy = j; };\n\t\t\t}\n\t\t}\n\t\tvar ans = goBfs(map, sx, sy);\n\t\tConsole.WriteLine(ans);\n\t}\n\tstatic int goBfs (int [,] map, int sx , int sy)\n\t{\n\t\tvar hs = new HashSet<string>();\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar q = new Queue<P>();\n\t\tvar t = MapToString(map);\n\t\tq.Enqueue(new P { s = t, x = sx,y = sy,step = 0});\n\t\ths.Add(t);\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar w = q.Dequeue();\n\t\t\tif (w.s == \"123456780\") return w.step;\n\t\t\tvar tmap = StringToMap(w.s);\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = w.x + dx[i];\n\t\t\t\tvar ny = w.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < 3 && ny >= 0 && ny < 3)\n\t\t\t\t{\n\t\t\t\t\ttmap[w.x, w.y] = tmap[nx, ny];\n\t\t\t\t\ttmap[nx, ny] = 0;\n\t\t\t\t\tvar tt= MapToString(tmap);\n\t\t\t\t\tif (hs.Add(tt)) q.Enqueue(new P { s = tt, x = nx, y = ny, step = w.step + 1 });\n\t\t\t\t\ttmap[nx, ny] = tmap[w.x, w.y];\n\t\t\t\t\ttmap[w.x, w.y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tstatic string MapToString (int [,] map)\n\t{\n\t\tvar s = \"\";\n\t\tforeach (var x in map) s += x;\n\t\treturn s;\n\t}\n\tstatic int[,] StringToMap (string s)\n\t{\n\t\tvar map = new int[3, 3];\n\t\tvar p = 0;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\tmap[i, j] = s[p++] - '0';\n\t\treturn map;\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        /*\n        var watch = new Stopwatch();\n        watch.Start();\n        */\n        TextReader reader;\n        string filename = \"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed))continue;\n            all_list.Add(longed);\n            if(longed==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        /*\n        watch.Stop();\n        Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????Â§?\");\n        */\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace ALDS1_13_C\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            const int VSize = 3;\n            const int HSize = 3;\n            int[,] board = new int[VSize, HSize];\n            NPuzzle np = new NPuzzle();\n\n            for (int i = 0 ; i < VSize ; i++)\n            {\n                int[] tmp = ReadIntAr();\n                for (int j = 0 ; j < HSize ; j++)\n                {\n                    board[i, j] = tmp[j];\n                }\n            }       \n           Console.WriteLine(np.FindShortestRange(board));\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\nnamespace CompProgLib\n{\n    public class NPuzzle\n    {\n        public int VSize;\n        public int HSize;\n        public const int MAX_DISTANCE = 45;\n\n        public class Node : IComparable<Node>\n        {\n\n            public int[,] Board { get; private set; }\n            public int Distance { get; private set; }\n            public int EvaluationValue { get; private set; }\n\n            public Node(int[,] board, int distance,int evaluationValue)\n            {\n                Board = board;\n                Distance = distance;\n                EvaluationValue = evaluationValue;\n            }\n\n            public int CompareTo(Node other)\n            {\n                return -1 * ((EvaluationValue+ Distance) - (other.EvaluationValue+ other.Distance));\n                //return -1 * ((int)(Math.Pow(EvaluationValue, 0.5) + Distance) - ((int)Math.Pow(other.EvaluationValue, 0.5) + other.Distance)); \n                //return -1 * ((EvaluationValue) - (other.EvaluationValue));\n                //return -1 * ((Distance) - (other.Distance));\n            }\n\n        }\n\n        public int FindShortestRange(int[,] board)\n        {\n\n            //åºç¾ããç¤é¢ã®è¨é²\n            HashSet<int> visited = new HashSet<int>();\n\n            PriorityQueue<Node> pq = new PriorityQueue<Node>();\n            Node start = new Node(board, 0,GetEvaluationValue(board));\n            visited.Add(GetHash(board));\n            pq.Enqueue(start);\n\n            while (pq.Count > 0)\n            {\n                Node tmp = pq.Dequeue();\n                for (int i = 0 ; i < tmp.Board.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < tmp.Board.GetLength(1) ; j++)\n                    {\n                        if (tmp.Board[i, j] == 0)\n                        {\n                            //å·¦ç§»å\n                            if (j != 0)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i, j - 1];\n                                newBoard[i, j - 1] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n\n                            //å³ç§»å\n                            if (j != tmp.Board.GetLength(1) - 1)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i, j + 1];\n                                newBoard[i, j + 1] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n\n                            //ä¸ç§»å\n                            if (i != 0)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i - 1, j];\n                                newBoard[i - 1, j] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n\n                            //ä¸ç§»å\n                            if (i != tmp.Board.GetLength(0) - 1)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i + 1, j];\n                                newBoard[i + 1, j] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (tmp.EvaluationValue == 0)\n                {\n                    return tmp.Distance;\n                }\n\n            }\n            return 0;\n        }\n\n        private int GetEvaluationValue(int[,] board)\n        {\n            int res = 0;\n            for (int i = 0 ; i < board.GetLength(0) ; i++)\n            {\n                for (int j = 0 ; j < board.GetLength(1) ; j++)\n                {\n                    if (board[i, j] != 0)\n                    {\n                        res += Math.Abs((board[i, j] - 1) / board.GetLength(1) - i);//ç¸¦æ¹å\n                        res += Math.Abs((board[i, j] - 1) % board.GetLength(1) - j);//æ¨ªæ¹å\n                    }\n                }\n            }\n            return res;\n        }\n\n        private int GetHash(int[,] board)\n        {\n\n            string tmp = \"\";\n            for (int i = 0 ; i < board.GetLength(0) ; i++)\n            {\n                for (int j = 0 ; j < board.GetLength(1) ; j++)\n                {\n                    tmp += board[i, j].ToString(\"0000\");\n                }\n            }\n            return tmp.GetHashCode();\n           // return board.ToString().GetHashCode();\n        }\n    }\n}\n\nnamespace CompProgLib\n{\n    public class PriorityQueue<T> where T : IComparable<T>\n\n    {\n\n        private List<T> Buffer { get; set; }\n\n        public int Count { get { return Buffer.Count; } }\n\n        public PriorityQueue() { Buffer = new List<T>(); }\n        public PriorityQueue(int capacity) { Buffer = new List<T>(capacity); }\n\n\n        /// <summary>\n        /// ãã¼ãåããã¦ããéåãªã¹ãã«æ°ããè¦ç´ ãè¿½å ããã\n        /// </summary>\n        public void Enqueue(T item)\n        {\n            int n = Buffer.Count;\n            Buffer.Add(item);\n\n            while (n != 0)\n            {\n                int i = (n - 1) / 2;\n                if (Buffer[n].CompareTo(Buffer[i]) > 0)\n                {\n                    T tmp = Buffer[n]; Buffer[n] = Buffer[i]; Buffer[i] = tmp;\n                }\n                n = i;\n            }\n        }\n\n        /// <summary>\n        /// ãã¼ãããæå¤§å¤ãåãåºããåé¤ããã\n        /// </summary>\n        public T Dequeue()\n        {\n            T ret = Buffer[0];\n            int n = Buffer.Count - 1;\n            Buffer[0] = Buffer[n];\n            Buffer.RemoveAt(n);\n\n            for (int i = 0, j ; (j = 2 * i + 1) < n ;)\n            {\n                if ((j != n - 1) && (Buffer[j].CompareTo(Buffer[j + 1]) < 0))\n                    j++;\n                if (Buffer[i].CompareTo(Buffer[j]) < 0)\n                {\n                    T tmp = Buffer[j]; Buffer[j] = Buffer[i]; Buffer[i] = tmp;\n                }\n                i = j;\n            }\n            return ret;\n        }\n\n        /// <summary>\n        /// ãã¼ãããæå¤§å¤ãåç§ããã\n        /// </summary>\n        public T Peek()\n        {\n            if (Count == 0) throw new InvalidOperationException();\n            return this.Buffer[0];\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (3000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tDictionary<int[], bool> puzzleState = new Dictionary<int[], bool> (3000, equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area, true);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move (puzzleState);\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tpuzzleState.Add (element.Area, true);\n\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ( Dictionary<int[], bool> dictionary )\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tList<Puzzle> puzzle = new List<Puzzle> (createCount);\n\n\t\t\tfor (int lp = 0; lp < createCount; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tif (!dictionary.ContainsKey (copyArea))\n\t\t\t\t{\n\t\t\t\t\tpuzzle.Add (new Puzzle (copyArea, Count + 1, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn puzzle.ToArray ();\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcreateCount = -1;\n\t\t\t\t\tindexArray = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\treturn base.GetHashCode ();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n\n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        var all_dict = new Dictionary<long, int>();\n        \n        //????????????????????Â´?????????????????????????????Â£????????????????????Â¨??????\n        //???????????Â¢??????????????????1???????????????????????Â¶??????????Â§?????????Â¨????????Â¢?Â´Â¢???????????????-2?????????????Â°????????????????\n        queue.Enqueue(new State{table = Goal, cnt = -1});\n        queue.Enqueue(new State{table = Board, cnt = 1});\n        all_dict[Board2Long(Goal)] = -1;\n        all_dict[Board2Long(Board)] = 1;\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed)){\n                //??Â¢????????Â£?????????????????Â¨????????Â´?????????????????Â°?????Â£???????????Â°???????????Â¢?????Â£????????Â¨??????????????Â§??????\n                //????????????????????Â£??Â§??????????????Â§????????Â´????????????????????????????????????????Â£????????????????????????????\n                if( (all_dict[longed]<0 && 0<curr.cnt) || curr.cnt<0 && 0<(all_dict[longed]) ){\n                    var other = Math.Abs(all_dict[longed]);\n                    var me = Math.Abs(curr.cnt);\n                    Console.WriteLine(other+me-2);\n                    break;\n                }else{\n                    continue;\n                }\n            }\n            \n            all_list.Add(longed);\n            all_dict[longed] = curr.cnt;\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        var ad = _cnt>0 ? 1 : -1;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=ad, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (3000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tDictionary<int[], bool> puzzleState = new Dictionary<int[], bool> (3000, equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area, true);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move (puzzleState);\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tpuzzleState.Add (element.Area, true);\n\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ( Dictionary<int[], bool> dictionary )\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tList<Puzzle> puzzle = new List<Puzzle> (createCount);\n\n\t\t\tfor (int lp = 0; lp < createCount; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tif (!dictionary.ContainsKey (copyArea))\n\t\t\t\t{\n\t\t\t\t\tpuzzle.Add (new Puzzle (copyArea, Count + 1, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn puzzle.ToArray ();\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcreateCount = -1;\n\t\t\t\t\tindexArray = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\t//return base.GetHashCode ();\n\t\t\treturn item[0] + item[1] * 10 + item[2] * 100 + item[3] * 1000;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n//        var sw = new Stopwatch();\n        while (true)\n        {\n            max++;\n//            max.Dump(\"?????????max?????????\");\n//            sw.Restart();\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"move\");\n//            sw.Restart();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"all\");\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n//        var sw = Stopwatch.StartNew();\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n//        sw.Stop();\n//        sw.ElapsedMilliseconds.Dump(\"clone\");\n//        sw.Restart();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n                return 0;\n            })\n            .ToArray();\n        \n//        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n//        {\n//            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n//        }\n            return children.Where(x => x != null).ToArray();\n        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((number, i) => \n            {\n                var board = children[i];\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == i));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B2\n{\n    class Program\n    {\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n\n        static void Main(string[] args)\n        {\n            var cnt = 0;\n            int[] Puzzle = new int[11];\n            for (int i = 0; i < 3; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < 3; j++)\n                {\n                    Puzzle[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        Puzzle[cnt - 1] = 9;\n                        Puzzle[9] = cnt - 1;\n                    } \n                }\n            }\n            bfs(Puzzle);\n            \n        }\n        static void bfs(int[] s)\n        {\n            //index 0-10\n            var Q = new Queue<string>();\n            //index 0-8\n            var V = new HashSet<string>();\n            \n            Q.Enqueue(string.Join(\" \",s));\n            V.Add(string.Join(\" \",s.Take(9)));\n            \n            while (Q.Any())\n            {\n                int[] u = Q.Dequeue().Split().Select(int.Parse).ToArray();\n                //Console.WriteLine(string.Concat(u));\n                if (string.Concat(u.Take(9)) == \"123456789\")\n                {\n                    Console.WriteLine(u[10]);\n                    return;\n                }\n                int sx = u[9] / 3;\n                int sy = u[9] % 3;\n                for (int r = 0; r <= 3; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\n                    var position = (tx * 3 + ty);\n                    var nowspace = u[9];\n\n                    swap(u, position, nowspace);\n                    u[9] = position;\n                    var k = string.Join(\" \", u.Take(9));\n\n                    if (!V.Contains(k))\n                    {\n                        V.Add(k);\n                        u[10]++;\n                        Q.Enqueue(string.Join(\" \", u));\n                        u[10]--;\n                    }\n                    u[9] = nowspace;\n                    swap(u, position, nowspace);\n\n                }\n                //Console.WriteLine(string.Join(\" & \",Q));\n            }\n            Console.WriteLine(\"WA\");\n        }\n        static void swap(int[] s, int x, int y)\n        {\n            var t = s[x];\n            s[x] = s[y];\n            s[y] = t;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            \"move\".Measure(() => {\n                boards = boards.SelectMany(x => x.Move(max))\n                    .ToArray();\n            });\n            \n            var correct = false;\n            \"correct\".Measure(() => {\n                correct = boards.Any(x => x.Nodes.All(node => node.IsCorrect()));\n            });\n            \n            if (correct) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        int sx, sy;\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n                if(line[j]==0){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        internal int[] f;\n        internal int space, MD;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n        }\n\n        public Puzzle(Puzzle other)\n        {\n            f = (int[])other.f.Clone();\n\n            space = other.space;\n            MD = other.MD;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int Limit = 50;\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int limit;\n        int[] path;\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n            path = new int[Limit];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n                }\n            }\n        }\n\n        public string IterativeDeeping(Puzzle p)\n        {\n            StringBuilder ret = new StringBuilder();\n            Puzzle state;\n\n            p.MD = GetAllMD(p);\n\n            for (limit = p.MD; limit <= Limit; limit++)\n            {\n                state = new Puzzle(p);\n\n                if (DFS(state, 0, -50))\n                {\n                    for (int i = 0; i < limit; i++)\n                    {\n                        ret.Append(dir[path[i]]);\n                    }\n                    return ret.ToString();\n                }\n            }\n            return null;\n        }\n\n        private bool DFS(Puzzle state, int depth, int prev)\n        {\n            if (state.MD == 0) return true;\n\n            if (depth + state.MD > limit) return false;\n\n            int sx = state.space % w;\n            int sy = state.space / w;\n\n            Puzzle tempState;\n\n            for (int r = 0; r < 4; r++)\n            {\n                int tx = sx + moveX[r];\n                int ty = sy + moveY[r];\n\n                if (!IsValid(tx, ty)) continue;\n\n                if (Math.Abs(prev - r) == 2) continue;\n\n                tempState = new Puzzle(state);\n\n                int indexT = tx + ty * w;\n                int indexS = sx + sy * w;\n\n                state.MD -= MDT[indexT, state.f[indexT] - 1];\n                state.MD += MDT[indexS, state.f[indexT] - 1];\n\n                int temp = state.f[indexT];\n                state.f[indexT] = state.f[indexS];\n                state.f[indexS] = temp;\n\n                state.space = indexT;\n\n                if (DFS(state, depth + 1, r))\n                {\n                    path[depth] = r;\n                    return true;\n                }\n\n                state = new Puzzle(tempState);\n            }\n            return false;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.IterativeDeeping(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        foreach (var re in resetEvents)\n            re.WaitOne();\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        ThreadPool.SetMinThreads(8, 8);\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle : IComparable\n    {\n        internal int[] f;\n        internal int space, MD, cost;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = cost = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n            space = source.space;\n            MD = source.MD;\n            cost = source.cost;\n        }\n\n        public override int GetHashCode()\n        {\n            return string.Join(\"\", f).GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return string.Join(\"\", f) == string.Join(\"\", other.f);\n        }\n\n        public int CompareTo(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return (other.cost + other.MD) - (cost + MD);\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n        }\n\n        public int Astar(Puzzle p)\n        {\n            PriorityQueue<Puzzle> PQ = new PriorityQueue<Puzzle>();\n            p.MD = GetAllMD(p);\n\n            HashSet<Puzzle> V = new HashSet<Puzzle>();\n\n            PQ.Enqueue(p);\n\n            Puzzle u, v;\n\n            while (PQ.Count() > 0)\n            {\n                u = PQ.Dequeue();\n\n                if (u.MD == 0) return u.cost;\n\n                V.Add(u);\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    v = new Puzzle(u);\n\n                    int indexT = tx + ty * w;\n                    int indexS = sx + sy * w;\n\n                    v.MD -= MDT[indexT, v.f[indexT] - 1];\n                    v.MD += MDT[indexS, v.f[indexT] - 1];\n\n                    int temp = v.f[indexT];\n                    v.f[indexT] = v.f[indexS];\n                    v.f[indexS] = temp;\n\n                    v.space = indexT;\n\n                    if (!V.Contains(v))\n                    {\n                        v.cost++;\n                        PQ.Enqueue(v);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n            Console.WriteLine(NP.Astar(s));\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count() { return size; }\n\n        private int Compare(T x, T y) { return y.CompareTo(x); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            \n            // Console.WriteLine(all_list.Count());\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                Console.WriteLine(all_list.Count());\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    // Console.WriteLine(ToStringForList(curr.table) + \" -> \" + ToStringForList(NexMap.table));\n                    if(all_list.Contains(ToStringForList(NexMap.table)))continue;\n                    all_list.Add(ToStringForList(NexMap.table));\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        foreach (var re in resetEvents)\n            re.WaitOne();\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        WaitHandle.WaitAll(resetEvents);\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n \nnamespace ALDS1_13_B2\n{\n    class Program\n    {\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n \n        static void Main(string[] args)\n        {\n            var cnt = 0;\n            int[] Puzzle = new int[11];\n            for (int i = 0; i < 3; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < 3; j++)\n                {\n                    Puzzle[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        Puzzle[cnt - 1] = 9;\n                        Puzzle[9] = cnt - 1;\n                    } \n                }\n            }\n            bfs(Puzzle);\n             \n        }\n        static bool checker(int[] a)\n        {\n        \tfor(int i = 0; i < 9; i++)\n        \t{\n        \t\tif(a[i] == i+1)continue;\n        \t\treturn false;\n        \t}\n        \treturn true;\n        }\n        static void bfs(int[] s)\n        {\n            //index 0-10\n            var Q = new Queue<string>();\n            //index 0-8\n            var V = new SortedSet<string>();\n            \n            string m = s[0].ToString(), n;\n            for(int i = 1;i < 11; i++)\n            {\n            \tm += \" \" + s[i].ToString();\n            }\n            n = m.Substring(0, 17);\n            Q.Enqueue(m);\n            V.Add(n);\n             \n            while (Q.Any())\n            {\n                int[] u = Q.Dequeue().Split().Select(int.Parse).ToArray();\n                \n                //Console.WriteLine(string.Concat(u));\n                if (checker(u))\n                {\n                    Console.WriteLine(u[10]);\n                    return;\n                }\n                int sx = u[9] / 3;\n                int sy = u[9] % 3;\n                for (int r = 0; r <= 3; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n \n                    var position = (tx * 3 + ty);\n                    var nowspace = u[9];\n \n                    swap(u, position, nowspace);\n                    u[9] = position;\n                    \n                    n = u[0].ToString();\n                    for(int i = 1; i < 9; i++)\n                    {\n                    \tn += \" \" + u[i].ToString();\n                    }\n                    if (!V.Contains(n))\n                    {\n                        V.Add(n);\n                        u[10]++;\n                        for(int j = 9; j < 11; j++)\n                        {\n                        \tn += \" \" +u[j].ToString();\n                        }\n                        Q.Enqueue(n);\n                        u[10]--;\n                    }\n                    u[9] = nowspace;\n                    swap(u, position, nowspace);\n \n                }\n                //Console.WriteLine(string.Join(\" & \",Q));\n            }\n            Console.WriteLine(\"WA\");\n        }\n        static void swap(int[] s, int x, int y)\n        {\n            var t = s[x];\n            s[x] = s[y];\n            s[y] = t;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        var watch = new Stopwatch();\n        watch.Start();\n        TextReader reader;\n        string filename = \"\";\n        //filename = @\"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var stack = new Stack<State>();\n        stack.Push(new State{table = Board, cnt = 0});\n\n        //????????Â±?????Â§????????Â¢??????????Â´????????????Â¢????????Â£?????????????Â¨?????????????\n        //??????????????Â¶?????????????????????????????\\???????????????\n        \n        int point = 0;\n        for(; point<10000; point++){\n            bool flag = false;\n            while(stack.Count()>0){\n                var curr = stack.Pop();\n                var longed = Board2Long(curr.table);\n                if(curr.cnt>point) continue;\n                if(Board2Long(curr.table)==Target){\n                    Console.WriteLine(curr.cnt);\n                    flag = true;\n                    break;\n                }\n                var Now = curr.GetPos();\n                var cx = Now.X;\n                var cy = Now.Y;\n                for(int i=0; i<4; i++){\n                    var nx = cx+STEPS[i+1]; \n                    var ny = cy+STEPS[i];\n                    if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                        var Nex = new Pos{Y = ny, X = nx};\n                        var NexMap = curr.Swap(Nex, Now);\n                        if(longed!=Board2Long(NexMap.table))stack.Push(NexMap);\n                    }\n                }\n            }\n            \n            if(flag){\n                break;\n            }else{\n                stack.Push(new State{table = Board, cnt = 0});\n            }\n        }\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public int GetManhattanDist(){\n        int ret = 0;\n        \n        return ret;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        internal int[] f;\n        internal int space, MD;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n        }\n\n        public Puzzle(Puzzle other)\n        {\n            f = (int[])other.f.Clone();\n\n            space = other.space;\n            MD = other.MD;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int Limit = 50;\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int limit;\n        int[] path;\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n            path = new int[Limit];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n                }\n            }\n        }\n\n        public string IterativeDeeping(Puzzle p)\n        {\n            StringBuilder ret = new StringBuilder();\n            Puzzle state;\n\n            p.MD = GetAllMD(p);\n\n            for (limit = p.MD; limit <= Limit; limit++)\n            {\n                state = new Puzzle(p);\n\n                if (DFS(state, 0, -50))\n                {\n                    for (int i = 0; i < limit; i++)\n                    {\n                        ret.Append(dir[path[i]]);\n                    }\n                    return ret.ToString();\n                }\n            }\n            return null;\n        }\n\n        private bool DFS(Puzzle state, int depth, int prev)\n        {\n            if (state.MD == 0) return true;\n\n            if (depth + state.MD > limit) return false;\n\n            int sx = state.space % w;\n            int sy = state.space / w;\n\n            Puzzle tempState;\n\n            for (int r = 0; r < 4; r++)\n            {\n                int tx = sx + moveX[r];\n                int ty = sy + moveY[r];\n\n                if (!IsValid(tx, ty)) continue;\n\n                if (Math.Abs(prev - r) == 2) continue;\n\n                tempState = new Puzzle(state);\n\n                int indexT = tx + ty * w;\n                int indexS = sx + sy * w;\n\n                state.MD -= MDT[indexT, state.f[indexT] - 1];\n                state.MD += MDT[indexS, state.f[indexT] - 1];\n\n                int temp = state.f[indexT];\n                state.f[indexT] = state.f[indexS];\n                state.f[indexS] = temp;\n\n                state.space = indexT;\n\n                if (DFS(state, depth + 1, r))\n                {\n                    path[depth] = r;\n                    return true;\n                }\n\n                state = tempState;\n            }\n            return false;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.IterativeDeeping(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B\n{\n    class Program\n    {\n        const int N = 3;\n        const int N2 = 9;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n        static char[] dir = { 'u', 'l', 'd', 'r' };\n        static int cnt;\n\n        class Puzzle\n        {\n            internal int[] f;\n            internal int space;\n            internal string path;\n            \n            public Puzzle()\n            {\n                f = new int[N2];\n                space = -1;\n                path = \"\";\n            } \n        }\n        static void Main(string[] args)\n        {\n            var P = new Puzzle();\n            for (int i = 0; i < N; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < N; j++)\n                {\n                    P.f[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        P.f[cnt - 1] = N2;\n                        P.space = cnt - 1;\n                    }\n                }\n            }\n            bfs(P);\n        }\n\n        static void bfs(Puzzle s)\n        {\n            var Q = new Queue<Puzzle>();\n\n            string st = \"\";\n            for (int i = 0; i < 9; i++)\n            {\n                st += s.f[i].ToString();\n            }\n            var V = new HashSet<string>();\n\n            var u = new Puzzle();\n            var v = new Puzzle();\n\n            Q.Enqueue(s);\n            V.Add(st);\n       \n\n            while (Q.Any())\n            {\n                u = Q.Dequeue();\n\n                \n                if(isTarget(u))\n                {\n                    Console.WriteLine(u.path.Length);\n                    return;\n                }\n\n                int sx = u.space / N;\n                int sy = u.space % N;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n                    var us = u.space;\n                    var vs = tx * N + ty;\n\n                    v = new Puzzle();\n                    for (int i = 0; i < 9; i++)\n                    {\n                        v.f[i] = u.f[i];\n                    }\n                    int tt = v.f[us];\n                    v.f[us] = v.f[vs];\n                    v.f[vs] = tt;\n\n\n                    v.space = vs;\n                    v.path = u.path;\n  \n\n                    st = \"\";\n                    for (int i = 0; i < 9; i++)\n                    {\n                        st += v.f[i].ToString();\n                    }\n\n                    if (!V.Contains(st))\n                    {\n                        V.Add(st);\n                        v.path += dir[r];\n                        Q.Enqueue(v);\n                     }\n                }\n            }\n\n            Console.WriteLine(\"unsolvable\");\n        }\n\n\n        static bool isTarget(Puzzle p)\n        {\n            for (int i = 0; i < N2; i++)\n            {\n                if (p.f[i] != (i + 1)) return false;\n            }\n            return true;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board}.AsEnumerable();\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max));\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        return children.Where(x => x != null).ToArray();\n//        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n//        {\n//            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n//        }\n//        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (3000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tDictionary<int[], bool> puzzleState = new Dictionary<int[], bool> (3000, equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area, true);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move (puzzleState);\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tpuzzleState.Add (element.Area, true);\n\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ( Dictionary<int[], bool> dictionary )\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tList<Puzzle> puzzle = new List<Puzzle> (createCount);\n\n\t\t\tfor (int lp = 0; lp < createCount; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tif (!dictionary.ContainsKey (copyArea))\n\t\t\t\t{\n\t\t\t\t\tpuzzle.Add (new Puzzle (copyArea, Count + 1, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn puzzle.ToArray ();\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcreateCount = -1;\n\t\t\t\t\tindexArray = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\t//return base.GetHashCode ();\n\t\t\treturn\n\t\t\t\titem[0] +\n\t\t\t\titem[1] * 10 +\n\t\t\t\titem[2] * 100 +\n\t\t\t\titem[3] * 1000 +\n\t\t\t\titem[4] * 10000 +\n\t\t\t\titem[5] * 100000;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;  //StringBuilder?????????????????????????????Â°????????????????????????\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();   //List??????HashSet????????Â´???????????????\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var state = ToStringForList(curr.table); //ToStringForList?????????????????Â°state????????????????????Â¨??Â§????????????????????Â§??????????????????????????????\n            if(all_list.Contains(state)) continue;\n            else all_list.Add(state);\n            if(state==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        //var ret = new StringBuilder();\n        var ret = \"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //ret.Append(map[i, j]);\n                ret+=map[i,j];\n            }\n        }\n        //return ret.ToString();\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (100);\n\t\t\tEqual equal = new Equal ();\n\t\t\tHashSet<int[]> puzzleState = new HashSet<int[]> (equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move ();\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tif (!puzzleState.Contains (element.Area))\n\t\t\t\t\t{\n\t\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t\t\tpuzzleState.Add (element.Area);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ()\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tPuzzle[] puzzle = new Puzzle[createCount];\n\n\t\t\tfor (int lp = 0; lp < puzzle.Length; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tpuzzle[lp] = new Puzzle (copyArea, (int) (Count + 1), index);\n\t\t\t}\n\n\t\t\treturn puzzle;\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount = 0;\n\t\t\tindexArray = null;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\treturn base.GetHashCode ();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == adj));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board};\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max)).ToArray();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n        \n        if (MoveCount == max)\n            return children.Where(x => x != null).ToArray();\n        \n        return children.Where(x => x != null)\n            .SelectMany(x => x.Move(max))\n            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Where(x => x != null)\n            .Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        //var watch = new Stopwatch();\n        //watch.Start();\n        string filename = \"\";\n        //filename = @\"\";\n        TextReader reader;\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(Board2Long(curr.table)))continue;\n            else all_list.Add(Board2Long(curr.table));\n            if(Board2Long(curr.table)==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        //watch.Stop();\n        //Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????Â§?\");\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    \n    //AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    /*\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n \nnamespace ALDS1_13_B2\n{\n    class Program\n    {\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n \n        static void Main(string[] args)\n        {\n            var cnt = 0;\n            int[] Puzzle = new int[11];\n            for (int i = 0; i < 3; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < 3; j++)\n                {\n                    Puzzle[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        Puzzle[cnt - 1] = 9;\n                        Puzzle[9] = cnt - 1;\n                    } \n                }\n            }\n            bfs(Puzzle);\n             \n        }\n        static bool checker(int[] a)\n        {\n        \tfor(int i = 0; i < 9; i++)\n        \t{\n        \t\tif(a[i] == i+1)continue;\n        \t\treturn false;\n        \t}\n        \treturn true;\n        }\n        static void bfs(int[] s)\n        {\n            //index 0-10\n            var Q = new Queue<string>();\n            //index 0-8\n            var V = new HashSet<string>();\n            \n            string m = s[0].ToString(), n;\n            for(int i = 1;i < 11; i++)\n            {\n            \tm += \" \" + s[i].ToString();\n            }\n            n = m.Substring(0, 17);\n            Q.Enqueue(m);\n            V.Add(n);\n             \n            while (Q.Any())\n            {\n                int[] u = Q.Dequeue().Split().Select(int.Parse).ToArray();\n                \n                //Console.WriteLine(string.Concat(u));\n                if (checker(u))\n                {\n                    Console.WriteLine(u[10]);\n                    return;\n                }\n                int sx = u[9] / 3;\n                int sy = u[9] % 3;\n                for (int r = 0; r <= 3; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n \n                    var position = (tx * 3 + ty);\n                    var nowspace = u[9];\n \n                    swap(u, position, nowspace);\n                    u[9] = position;\n                    \n                    n = u[0].ToString();\n                    for(int i = 1; i < 9; i++)\n                    {\n                    \tn += \" \" + u[i].ToString();\n                    }\n                    if (!V.Contains(n))\n                    {\n                        V.Add(n);\n                        u[10]++;\n                        for(int j = 9; j < 11; j++)\n                        {\n                        \tn += \" \" +u[j].ToString();\n                        }\n                        Q.Enqueue(n);\n                        u[10]--;\n                    }\n                    u[9] = nowspace;\n                    swap(u, position, nowspace);\n \n                }\n                //Console.WriteLine(string.Join(\" & \",Q));\n            }\n            Console.WriteLine(\"WA\");\n        }\n        static void swap(int[] s, int x, int y)\n        {\n            var t = s[x];\n            s[x] = s[y];\n            s[y] = t;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        /*\n        var watch = new Stopwatch();\n        watch.Start();\n        */\n        TextReader reader;\n        string filename = \"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        var all_dict = new Dictionary<long, int>();\n        \n        //????????????????????Â´?????????????????????????????Â£????????????????????Â¨??????\n        //???????????Â¢??????????????????1???????????????????????Â¶??????????Â§?????????Â¨????????Â¢?Â´Â¢???????????????-2?????????????Â°????????????????\n        queue.Enqueue(new State{table = Goal, cnt = -1});\n        queue.Enqueue(new State{table = Board, cnt = 1});\n        all_dict[Board2Long(Goal)] = -1;\n        all_dict[Board2Long(Board)] = 1;\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed)){\n                //??Â¢????????Â£?????????????????Â¨????????Â´?????????????????Â°?????Â£???????????Â°???????????Â¢?????Â£????????Â¨??????????????Â§??????\n                //????????????????????Â£??Â§??????????????Â§????????Â´????????????????????????????????????????Â£????????????????????????????\n                if( (all_dict[longed]<0 && 0<curr.cnt) || curr.cnt<0 && 0<(all_dict[longed]) ){\n                    var other = Math.Abs(all_dict[longed]);\n                    var me = Math.Abs(curr.cnt);\n                    Console.WriteLine(other+me-2);\n                    break;\n                }else{\n                    continue;\n                }\n            }\n            \n            all_list.Add(longed);\n            all_dict[longed] = curr.cnt;\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        /*\n        watch.Stop();\n        Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????Â§?\");\n        */\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        var ad = _cnt>0 ? 1 : -1;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=ad, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n//        var sw = new Stopwatch();\n        while (true)\n        {\n            max++;\n//            max.Dump(\"?????????max?????????\");\n//            sw.Restart();\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"move\");\n//            sw.Restart();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"all\");\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n//        var sw = Stopwatch.StartNew();\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n//        sw.Stop();\n//        sw.ElapsedMilliseconds.Dump(\"clone\");\n//        sw.Restart();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n                return 0;\n            })\n            .ToArray();\n        \n//        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n//        {\n//            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n//        }\n            return children.Where(x => x != null).ToArray();\n        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n            \n             var firstLineCompleted = boards\n                //.Where(x => x.Nodes[0].Current == 1 && x.Nodes[1].Current == 2 && x.Nodes[2].Current == 3)\n                .Where(x => x.Nodes[0].Current == 1)\n                .ToArray();\n            if (firstLineCompleted.Any())\n            {\n                boards = firstLineCompleted;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n            \n            var firstLineCompleted = boards\n                .Where(x => x.Nodes[0].Current == 1 && x.Nodes[1].Current == 2 && x.Nodes[2].Current == 3)\n                .ToArray();\n            if (firstLineCompleted.Any())\n            {\n                boards = firstLineCompleted;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class State\n    {\n        internal int[,] map;\n        internal string moveLog;\n        internal char preMove;\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        public NPuzzle(int h, int w)\n        {\n            n = h * w;\n            this.h = h;\n            this.w = w;\n        }\n\n        public string Solve(State s)\n        {\n            Queue<State> que = new Queue<State>();\n            que.Enqueue(s);\n\n            while (que.Count > 0)\n            {\n                State cur = que.Dequeue();\n\n                if (IsGoal(cur)) return cur.moveLog;\n\n                KeyValuePair<int, int> spacePos = FindSpace(cur);\n                int x = spacePos.Value;\n                int y = spacePos.Key;\n\n                if (x != 0 && cur.preMove != 'l')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x - 1] = 0;\n                    saved.map[y, x] = cur.map[y, x - 1];\n                    saved.moveLog = cur.moveLog + \"r\";\n                    saved.preMove = 'r';\n                    que.Enqueue(saved);\n                }\n\n                if (x != w - 1 && cur.preMove != 'r')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x + 1] = 0;\n                    saved.map[y, x] = cur.map[y, x + 1];\n                    saved.moveLog = cur.moveLog + \"l\";\n                    saved.preMove = 'l';\n                    que.Enqueue(saved);\n                }\n\n                if (y != 0 && cur.preMove != 'u')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y - 1, x] = 0;\n                    saved.map[y, x] = cur.map[y - 1, x];\n                    saved.moveLog = cur.moveLog + \"d\";\n                    saved.preMove = 'd';\n                    que.Enqueue(saved);\n                }\n\n                if (y != h - 1 && cur.preMove != 'd')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y + 1, x] = 0;\n                    saved.map[y, x] = cur.map[y + 1, x];\n                    saved.moveLog = cur.moveLog + \"u\";\n                    saved.preMove = 'u';\n                    que.Enqueue(saved);\n                }\n            }\n            return null;\n        }\n\n        private KeyValuePair<int, int> FindSpace(State s)\n        {\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (s.map[i, j] == 0) return new KeyValuePair<int, int>(i, j);\n                }\n            }\n            return new KeyValuePair<int, int>(-1, -1);\n        }\n\n        private bool IsGoal(State s)\n        {\n            int mustNumber = 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    ++mustNumber;\n\n                    if (mustNumber != n && s.map[i, j] != mustNumber) return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            State s = new State();\n            s.map = new int[h, w];\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    s.map[i, j] = input[j];\n                }\n            }\n\n            string ans = NP.Solve(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (100);\n\t\t\tHashSet<int[]> puzzleState = new HashSet<int[]> ();\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move ();\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tif (!puzzleState.Contains (element.Area))\n\t\t\t\t\t{\n\t\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t\t\tpuzzleState.Add (element.Area);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ()\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tPuzzle[] puzzle = new Puzzle[createCount];\n\n\t\t\tfor (int lp = 0; lp < puzzle.Length; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tpuzzle[lp] = new Puzzle (copyArea, Count + 1, index);\n\t\t\t}\n\n\t\t\treturn puzzle;\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount = -1;\n\t\t\tindexArray = null;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        //var watch = new Stopwatch();\n        //watch.Start();\n        TextReader reader;\n        string filename = \"\";\n        //filename = @\"/Volumes/ExtremeDrive/CSharpProj/AOJ/ALDS/ALDS1_13B.txt\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(Board2Long(curr.table)))continue;\n            else all_list.Add(Board2Long(curr.table));\n            if(Board2Long(curr.table)==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        //watch.Stop();\n        //Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????Â§?\");\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Puzzle\n    {\n        internal int[] f;\n        internal int space;\n        internal string path;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = default(int);\n            path = default(string);\n        }\n\n        public Puzzle(Puzzle other)\n        {\n            int len = other.f.Length;\n            f = new int[len];\n            other.f.CopyTo(f, 0);\n\n            space = other.space;\n            path = other.path;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n        }\n\n        public string Solve(Puzzle s)\n        {\n            Queue<Puzzle> que = new Queue<Puzzle>();\n            HashSet<Puzzle> visited = new HashSet<Puzzle>();\n\n            que.Enqueue(s);\n            visited.Add(s);\n\n            while (que.Count > 0)\n            {\n                Puzzle u = que.Dequeue();\n\n                if (IsTarget(u)) return u.path;\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    Puzzle v = new Puzzle(u);\n\n                    int temp = v.f[u.space];\n                    v.f[u.space] = v.f[tx + ty * w];\n                    v.f[tx + ty * w] = temp;\n\n                    v.space = tx + ty * w;\n\n                    if (!visited.Contains(v))\n                    {\n                        visited.Add(v);\n                        v.path += dir[r];\n                        que.Enqueue(v);\n                    }\n                }\n            }\n            return null;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private bool IsTarget(Puzzle p)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != i + 1) return false;\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.Solve(s);\n\n            Console.WriteLine(ans.Length);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n            \n             var firstLineCompleted = boards\n                 .Where(x => x.Nodes[0].Current == 1 && x.Nodes[1].Current == 2 && x.Nodes[2].Current == 3 && x.Nodes[3].Current == 4)\n               .ToArray();\n            if (firstLineCompleted.Any())\n            {\n                boards = firstLineCompleted;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        /*\n        var watch = new Stopwatch();\n        watch.Start();\n        */\n        TextReader reader;\n        string filename = \"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed))continue;\n            all_list.Add(longed);\n            if(longed==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        /*\n        watch.Stop();\n        Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????Â§?\");\n        */\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        WaitHandle.WaitAll(resetEvents.ToArray());\n   }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;  //StringBuilder?????????????????????????????Â°????????????????????????\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();   //List??????HashSet????????Â´???????????????\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var state = ToStringForList(curr.table); //ToStringForList?????????????????Â°state????????????????????Â¨??Â§????????????????????Â§??????????????????????????????\n            if(all_list.Contains(state)) continue;\n            else all_list.Add(state);\n            if(state==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret = new StringBuilder();\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret.Append(map[i, j]);\n            }\n        }\n        return ret.ToString();\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class State\n    {\n        internal int[,] map;\n        internal string moveLog;\n        internal char preMove;\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        public NPuzzle(int h, int w)\n        {\n            n = h * w;\n            this.h = h;\n            this.w = w;\n        }\n\n        public string Solve(State s)\n        {\n            Queue<State> que = new Queue<State>();\n            que.Enqueue(s);\n\n            while (que.Count > 0)\n            {\n                State cur = que.Dequeue();\n\n                if (IsGoal(cur)) return cur.moveLog;\n\n                KeyValuePair<int, int> spacePos = FindSpace(cur);\n                int x = spacePos.Value;\n                int y = spacePos.Key;\n\n                if (x != 0 && cur.preMove != 'l')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x - 1] = 0;\n                    saved.map[y, x] = cur.map[y, x - 1];\n                    saved.moveLog = cur.moveLog + \"r\";\n                    saved.preMove = 'r';\n                    que.Enqueue(saved);\n                }\n\n                if (x != w - 1 && cur.preMove != 'r')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x + 1] = 0;\n                    saved.map[y, x] = cur.map[y, x + 1];\n                    saved.moveLog = cur.moveLog + \"l\";\n                    saved.preMove = 'l';\n                    que.Enqueue(saved);\n                }\n\n                if (y != 0 && cur.preMove != 'u')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y - 1, x] = 0;\n                    saved.map[y, x] = cur.map[y - 1, x];\n                    saved.moveLog = cur.moveLog + \"d\";\n                    saved.preMove = 'd';\n                    que.Enqueue(saved);\n                }\n\n                if (y != h - 1 && cur.preMove != 'd')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y + 1, x] = 0;\n                    saved.map[y, x] = cur.map[y + 1, x];\n                    saved.moveLog = cur.moveLog + \"u\";\n                    saved.preMove = 'u';\n                    que.Enqueue(saved);\n                }\n            }\n            return null;\n        }\n\n        private KeyValuePair<int, int> FindSpace(State s)\n        {\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (s.map[i, j] == 0) return new KeyValuePair<int, int>(i, j);\n                }\n            }\n            return new KeyValuePair<int, int>(-1, -1);\n        }\n\n        private bool IsGoal(State s)\n        {\n            int mustNumber = 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    ++mustNumber;\n\n                    if (mustNumber != n && s.map[i, j] != mustNumber) return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            State s = new State();\n            s.map = new int[h, w];\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    s.map[i, j] = input[j];\n                }\n            }\n\n            string ans = NP.Solve(s);\n\n            Console.WriteLine(ans.Length);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board}.AsEnumerable();\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max));\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n        \n        if (MoveCount == max)\n            return children.Where(x => x != null).ToArray();\n        \n        return children.Where(x => x != null)\n            .SelectMany(x => x.Move(max))\n            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board}.AsEnumerable();\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max));\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n        \n        if (MoveCount == max)\n            return children.Where(x => x != null).ToArray();\n        \n        return children.Where(x => x != null)\n            .SelectMany(x => x.Move(max))\n            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        int sx, sy;\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n                if(line[j]==0){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle : IComparable\n    {\n        internal int[] f;\n        internal int space, MD, cost;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = cost = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n            space = source.space;\n            MD = source.MD;\n            cost = source.cost;\n        }\n\n        public override int GetHashCode()\n        {\n            return MakeString(f).GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return MakeString(f) == MakeString(other.f);\n        }\n\n        public int CompareTo(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return (other.cost + other.MD) - (cost + MD);\n        }\n\n        private string MakeString(int[] arr)\n        {\n            StringBuilder sb = new StringBuilder();\n            foreach (var item in arr) sb.Append(item);\n            return sb.ToString();\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n        }\n\n        public int Astar(Puzzle p)\n        {\n            PriorityQueue<Puzzle> PQ = new PriorityQueue<Puzzle>();\n            p.MD = GetAllMD(p);\n\n            HashSet<Puzzle> V = new HashSet<Puzzle>();\n\n            PQ.Enqueue(p);\n\n            Puzzle u, v;\n\n            while (PQ.Count() > 0)\n            {\n                u = PQ.Dequeue();\n\n                if (u.MD == 0) return u.cost;\n\n                V.Add(u);\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    v = new Puzzle(u);\n\n                    int indexT = tx + ty * w;\n                    int indexS = sx + sy * w;\n\n                    v.MD -= MDT[indexT, v.f[indexT] - 1];\n                    v.MD += MDT[indexS, v.f[indexT] - 1];\n\n                    int temp = v.f[indexT];\n                    v.f[indexT] = v.f[indexS];\n                    v.f[indexS] = temp;\n\n                    v.space = indexT;\n\n                    if (!V.Contains(v))\n                    {\n                        v.cost++;\n                        PQ.Enqueue(v);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n            Console.WriteLine(NP.Astar(s));\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count() { return size; }\n\n        private int Compare(T x, T y) { return y.CompareTo(x); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        //var watch = new Stopwatch();\n        //watch.Start();\n        string filename = \"\";\n        //filename = @\"\";\n        TextReader reader;\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(Board2Long(curr.table)))continue;\n            else all_list.Add(Board2Long(curr.table));\n            if(Board2Long(curr.table)==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        //watch.Stop();\n        //Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????Â§?\");\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board};\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max)).ToArray();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n            return children.Where(x => x != null).ToArray();\n        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace lec13BandC\n{\n    public class Board\n    {\n        public int[] state;\n        public int space;\n        public int score;\n        public int index;\n\n        public Board()\n        {\n            state = new int[Program.N];\n            index = 0;\n        }\n\n        public void NumberIn(int n)\n        {\n            if (n == 0) { space = index; state[index] = 0; }\n            else { state[index] = n; }\n            index++;\n        }\n\n        public void Copy(Board t)\n        {\n            t.space = this.space;\n            t.score = this.score;\n            for (int i = 0; i < Program.N; i++)\n            {\n                t.state[i] = this.state[i];\n            }\n        }\n        \n        public void ScoreCheck()\n        {\n            score = 0;\n            for (int i = 0; i < Program.N; i++)\n            {\n                int  t = this.state[i]; if(t == 0) { continue; }\n                score += Program.Ruler[i,t];\n            }\n        }\n    }\n\n\n    class Program\n    {\n        public static int NO = -999;\n        public static int N;\n        public static int[,] Ruler;\n        public static int [] LIMIT_ARRAY= { 0,0,3,31,80};\n        public static int ans;\n        public static Board now;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            NO = input.Length;\n            N = NO * NO;\n            Board start = new Board();\n\n            foreach (var str in input)\n            {\n                start.NumberIn(int.Parse(str));\n            }\n\n            for (int i = 1; i < NO; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                foreach (var str in input)\n                { \n                    start.NumberIn(int.Parse(str));\n                }\n            }\n\n            MakeOfRuler();\n            start.ScoreCheck();\n            now = new Board();\n            start.Copy(now);\n\n            for (ans = start.score; ans <= LIMIT_ARRAY[NO]; ans++)\n            {\n                start.Copy(now);\n                if (PazzleSrearch(0 , 999) == true)\n                {\n                    Console.WriteLine(ans);\n                    break;\n                }\n\n            }\n\n            Console.ReadLine();\n        }\n\n\n        static bool PazzleSrearch(int dep ,int prej)\n        {\n            if (now.score == 0)\n            {\n                return true;\n            }\n            else if (now.score + dep > ans)\n            {\n                return false;\n            }\n\n            Board tmp = new Board();\n            int z = now.space;\n\n            for (int j = 0; j < 4; j++)\n            {\n                int v = -100;\n                \n                switch (j)\n                {\n                    case 0:\n                        if (z < NO) { continue; }\n                        v = z  - NO;\n                        break;\n                    case 1:\n                        if ((z + 1) % NO == 0) { continue; }\n                        v = z + 1;\n                        break;\n                    case 2:\n                        if ((z + NO) >= N) { continue; }\n                        v = z + NO;\n                        break;\n                    case 3:\n                        if (z % NO == 0) { continue; }\n                        v = z - 1;\n                        break;\n                }\n                if (Math.Abs(prej - j) == 2) { continue; }\n\n                now.Copy(tmp);\n\n                now.score -= Ruler[v, now.state[v] ];\n                now.score += Ruler[z, now.state[v] ];\n\n\n                int t = now.state[v];\n                now.state[v] = now.state[z];\n                now.state[z] = t;\n\n                now.space = v;\n\n                if (PazzleSrearch(dep + 1 , j) == true)\n                {\n                    return true;\n                }\n                tmp.Copy(now);\n            }\n\n            return false;\n        }\n        \n        static void MakeOfRuler()\n        {\n            Ruler = new int[N, N];\n            for (int i = 0; i < N; i++)\n            {\n                for (int j =0; j< N; j++)\n                {\n                    int k  = Math.Abs(i / NO - j / NO) + Math.Abs(i % NO - j % NO);\n                    int tj = j + 1;\n                    if (tj == N) { tj = 0; }\n                    Ruler[i, tj] = k;\n                }\n            }\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            \n            // Console.WriteLine(all_list.Count());\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                // Console.WriteLine(all_list.Count());\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    // Console.WriteLine(ToStringForList(curr.table) + \" -> \" + ToStringForList(NexMap.table));\n                    if(all_list.Contains(ToStringForList(NexMap.table)))continue;\n                    all_list.Add(ToStringForList(NexMap.table));\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        foreach (var re in resetEvents)\n            re.WaitOne();\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (1000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tHashSet<int[]> puzzleState = new HashSet<int[]> (equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move ();\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tif (puzzleState.Add (element.Area))\n\t\t\t\t\t{\n\t\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ()\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tPuzzle[] puzzle = new Puzzle[createCount];\n\n\t\t\tfor (int lp = 0; lp < puzzle.Length; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tpuzzle[lp] = new Puzzle (copyArea, Count + 1, index);\n\t\t\t}\n\n\t\t\treturn puzzle;\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount = 0;\n\t\t\tindexArray = null;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\treturn base.GetHashCode ();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    public static void Main()\n    {\n        ulong data = 0UL;\n        int pos = 0;\n        int shift = 64;\n        for (int i = 0; i < 3; i++)\n        {\n            foreach (var item in Console.ReadLine().Split().Select(ulong.Parse))\n            {\n                shift -= 4;\n                data |= item << shift;\n                if (item == 0) pos = shift / 4;\n            }\n            shift -= 4;\n        }\n        Dictionary<ulong, int> dists = new Dictionary<ulong, int>();\n        PriorityQueue<Board, int> pqueue = new PriorityQueue<Board, int>(x => dists[x.Data]);\n        //Stack<Board> pqueue = new Stack<Board>();\n        dists.Add(data, 0);\n        pqueue.Push(new Board() { Data = data, Pos = pos });\n        while (pqueue.Count > 0)\n        {\n            var board = pqueue.Pop();\n            var dist = dists[board.Data];\n            foreach (var next in board.Next)\n            {\n                if (!dists.ContainsKey(next.Data)) dists.Add(next.Data, int.MaxValue);\n                if (dists[next.Data] <= dist + 1) continue;\n                //if (45 < dist + next.IncorrectCount) continue;\n                dists[next.Data] = dist + 1;\n                if (next.Data == Board.CorrectData) goto end;\n                pqueue.Push(next);\n            }\n        }\n        end:;\n        Console.WriteLine(dists[Board.CorrectData]);\n    }\n}\n\n\nclass PriorityQueue<TValue, TKey> where TKey : IComparable<TKey>\n{\n    public int Count { get; private set; }\n    private Func<TValue, TKey> KeySelector;\n    private bool Descendance;\n    private TValue[] data = new TValue[65536];\n    private TKey[] keys = new TKey[65536];\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public PriorityQueue(Func<TValue, TKey> keySelector, bool descendance = false) { KeySelector = keySelector; Descendance = descendance; }\n    public TValue Top\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get { ValidateNonEmpty(); return data[1]; }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public TValue Pop()\n    {\n        var top = Top;\n        var item = data[Count];\n        var key = keys[Count--];\n        int index = 1;\n        while (true)\n        {\n            if ((index << 1) >= Count)\n            {\n                if (index << 1 > Count) break;\n                if (key.CompareTo(keys[index << 1]) > 0 ^ Descendance)\n                { data[index] = data[index << 1]; keys[index] = keys[index << 1]; index <<= 1; }\n                else break;\n            }\n            else\n            {\n                var nextIndex = keys[index << 1].CompareTo(keys[(index << 1) + 1]) <= 0 ^ Descendance ? (index << 1) : (index << 1) + 1;\n                if (key.CompareTo(keys[nextIndex]) > 0 ^ Descendance)\n                { data[index] = data[nextIndex]; keys[index] = keys[nextIndex]; index = nextIndex; }\n                else break;\n            }\n        }\n        data[index] = item;\n        keys[index] = key;\n        return top;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Push(TValue item)\n    {\n        var key = KeySelector(item);\n        int index = ++Count;\n        if (data.Length == Count) Extend(data.Length * 2);\n        while ((index >> 1) != 0)\n        {\n            if (keys[index >> 1].CompareTo(key) > 0 ^ Descendance)\n            { data[index] = data[index >> 1]; keys[index] = keys[index >> 1]; index >>= 1; }\n            else break;\n        }\n        data[index] = item;\n        keys[index] = key;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Extend(int newSize)\n    {\n        TValue[] newData = new TValue[newSize];\n        TKey[] newKeys = new TKey[newSize];\n        data.CopyTo(newData, 0);\n        keys.CopyTo(newKeys, 0);\n        data = newData;\n        keys = newKeys;\n    }\n    private void ValidateNonEmpty() { if (Count == 0) throw new IndexOutOfRangeException(); }\n}\n\nstruct Board\n{\n    public const ulong CorrectData = 0x1230456078000000;\n    public ulong Data;\n    public int Pos;\n\n    public IEnumerable<Board> Next\n    {\n        get\n        {\n            if ((Pos & 2) != 0) yield return new Board() { Data = Swap(Data, Pos, Pos - 1), Pos = Pos - 1 };\n            if ((Pos & 3) != 3) yield return new Board() { Data = Swap(Data, Pos, Pos + 1), Pos = Pos + 1 };\n            if (8 <= Pos) yield return new Board() { Data = Swap(Data, Pos, Pos - 4), Pos = Pos - 4 };\n            if (Pos < 12) yield return new Board() { Data = Swap(Data, Pos, Pos + 4), Pos = Pos + 4 };\n        }\n    }\n\n    public int IncorrectCount => NonZeroCellCount(Data ^ CorrectData);\n    static private int NonZeroCellCount(ulong data)\n    {\n        if (data == 0) return 0;\n        data |= data >> 1;\n        data |= data >> 2;\n        data &= 0x1111111111111111UL;\n        data *= 0x1111111111111111UL;\n        data >>= 60;\n        if (data == 0) data = 16;\n        return (int)data;\n    }\n\n    static private ulong Swap(ulong data, int pos1, int pos2)\n    {\n        var xoredData = ((data >> pos1 * 4) ^ (data >> pos2 * 4)) & 0xf;\n        data ^= xoredData << pos1 * 4;\n        data ^= xoredData << pos2 * 4;\n        return data;\n    }\n\n    public override string ToString() => Data.ToString(\"x\");\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        // Console.WriteLine(StrGoal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<int>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            // Console.WriteLine(all_list.Count());\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                // Console.WriteLine(all_list.Count());\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    // Console.WriteLine(ToStringForList(curr.table) + \" -> \" + ToStringForList(NexMap.table));\n                    if(all_list.Contains(ToStringForList(NexMap.table)))continue;\n                    all_list.Add(ToStringForList(NexMap.table));\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static int ToStringForList(int[,] map){\n        var ret=0;\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret = ret * 10 + map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == adj));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;  //StringBuilder?????????????????????????????Â°????????????????????????\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();   //List??????HashSet????????Â´???????????????\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var state = ToStringForList(curr.table); //ToStringForList?????????????????Â°state????????????????????Â¨??Â§????????????????????Â§??????????????????????????????\n            if(all_list.Contains(state)) continue;\n            else all_list.Add(state);\n            if(state==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret = new StringBuilder();\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret.Append(map[i, j]);\n            }\n        }\n        return ret.ToString();\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Puzzle\n    {\n        internal int[] f;\n        internal int space, MD;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n\n            space = source.space;\n            MD = source.MD;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int Limit = 50;\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int limit;\n        int[] path;\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n            path = new int[Limit];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n                }\n            }\n        }\n\n        public string IterativeDeeping(Puzzle p)\n        {\n            StringBuilder ret = new StringBuilder();\n            Puzzle state;\n\n            p.MD = GetAllMD(p);\n\n            for (limit = p.MD; limit <= Limit; limit++)\n            {\n                state = new Puzzle(p);\n\n                if (DFS(state, 0, -50))\n                {\n                    for (int i = 0; i < limit; i++)\n                    {\n                        ret.Append(dir[path[i]]);\n                    }\n                    return ret.ToString();\n                }\n            }\n            return null;\n        }\n\n        private bool DFS(Puzzle state, int depth, int prev)\n        {\n            if (state.MD == 0) return true;\n\n            if (depth + state.MD > limit) return false;\n\n            int sx = state.space % w;\n            int sy = state.space / w;\n\n            Puzzle tempState;\n\n            for (int r = 0; r < 4; r++)\n            {\n                int tx = sx + moveX[r];\n                int ty = sy + moveY[r];\n\n                if (!IsValid(tx, ty)) continue;\n\n                if (Math.Abs(prev - r) == 2) continue;\n\n                tempState = new Puzzle(state);\n\n                int indexT = tx + ty * w;\n                int indexS = sx + sy * w;\n\n                state.MD -= MDT[indexT, state.f[indexT] - 1];\n                state.MD += MDT[indexS, state.f[indexT] - 1];\n\n                int temp = state.f[indexT];\n                state.f[indexT] = state.f[indexS];\n                state.f[indexS] = temp;\n\n                state.space = indexT;\n\n                if (DFS(state, depth + 1, r))\n                {\n                    path[depth] = r;\n                    return true;\n                }\n\n                state = tempState;\n            }\n            return false;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.IterativeDeeping(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        int sx, sy;\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n                if(line[j]==0){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "class Node {\n  constructor(board = [], zeroIndex = null, parent = null) {\n    this.board = board;\n    this.zeroIndex = zeroIndex || this.getZeroIndex();\n    this.parent = parent;\n  }\n\n  getZeroIndex() {return this.board.indexOf(0);}\n\n  get depth() {\n    let node = this, depth = 0;\n    while ((node = node.parent)) depth++;\n    return depth;\n  }\n}\n\nclass EightPazzle {\n  init() {\n    EightPazzle.inited = true;\n    EightPazzle.correct_board = [1, 2, 3, 4, 5, 6, 7, 8, 0];\n    EightPazzle.adjLists = [\n      [1, 3], [0, 2, 4], [1, 5],\n      [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n      [3, 7], [4, 6, 8], [5, 7]\n    ];\n  }\n\n  constructor(begin_board) {\n    EightPazzle.inited || this.init();\n    this.cache = {begin_board: true};\n    this.queue = [new Node(begin_board)];\n  }\n\n  solve() {\n    const cb = EightPazzle.correct_board.toString();\n    const isCorrect = (n) => n.board.toString() === cb;\n    if (isCorrect(this.queue[0])) return this.queue[0];\n\n    let node, newNode, board, zeroIdx, flg;\n    while ((node = this.queue.shift()) !== undefined) {\n      zeroIdx = node.zeroIndex;\n      \n      flg = EightPazzle.adjLists[zeroIdx].some(next => {\n        board = [].concat(node.board);\n        board[zeroIdx] = [board[next], board[next] = board[zeroIdx]][0];\n        newNode = new Node(board, next, node);\n        if (!this.cache[board]) {\n          if (isCorrect(newNode)) return true;\n          this.cache[board] = true;\n          this.queue.push(newNode);\n        }\n        return false;\n      });\n      if (flg) return newNode;\n    }\n  }\n}\n\n(function main() {\n  const board = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split(/[ \\n]/).map(Number);\n  const E = new EightPazzle(board);\n  console.log(E.solve().depth);\n})();\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function puzzle(){\n   var obj={};\n   obj[\"123456780\"]=0;\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   var V=[1,2,3,4,5,6,7,8,0];\n   var P=[[V,0]];\n   while(P.length>0){\n      var A=P.shift();\n      var arr=A[0];\n      var cnt=A[1];\n      var index=arr.indexOf(0);\n      var y=Math.floor(index/3);\n      var x=index%3;\n      var yx=[arr.slice(0,3),arr.slice(3,6),arr.slice(6,9)];\n      for(var i=0;i<4;i++){\n         var yy=y+dy[i];\n         var xx=x+dx[i];\n         if(yy<0 || xx<0 || yy>=3 || xx>=3)continue;\n         yx[y][x]=yx[yy][xx];\n         var card=yx[yy][xx];\n         yx[yy][xx]=0;\n         var YX=yx[0].concat(yx[1],yx[2]);\n         var str=YX.join(\"\");\n         if(obj.hasOwnProperty(str)==false){\n               obj[str]=cnt+1;\n               P.push([YX,cnt+1]);\n         }\n         yx[yy][xx]=card;\n         yx[y][x]=0;\n      }\n   }\n   return obj;\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar str=(input.trim()).replace(/\\n|\\s/g,\"\");\nvar PUZZLE=puzzle();\nconsole.log(PUZZLE[str]);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nconst assert = require('assert');\n\nconst SIZE = 9;\n\ninit = require('fs').readFileSync(config.input, 'ascii')\n  .trim()\n  .split(config.newline)\n  .join('')\n  .replace(/ /g, '');\ngoal = [];\nfor (i = 1; i < SIZE; i++) goal.push(i);\ngoal = goal.join('') + '0';\n\ncnt = 0;\nstep = {};\nnext = [];\nfunction register_string(str, next, cnt) {\n  if (!step.hasOwnProperty(str)) {\n    step[str] = cnt;\n    next.push(str);\n  }\n}\nregister_string(init, next, cnt);\n\nfunction switch_array(ary, i, j) {\n  var tmp = ary[i];\n  ary[i] = ary[j];\n  ary[j] = tmp;\n}\n\nfunction register(ary, next, i, j, cnt) {\n  switch_array(ary, i, j);\n  register_string(ary.join(''), next, cnt);\n  switch_array(ary, i, j);\n}\n\nfunction widen(cur) {\n  var next = [], i, ary, idx0;\n  cnt++;\n  for (i in cur) {\n    ary = cur[i].split('');\n    idx0 = ary.indexOf('0');\n    if (idx0 === 0) {\n      register(ary, next, 0, 1, cnt);\n      register(ary, next, 0, 3, cnt);\n    } else if (idx0 === 1) {\n      register(ary, next, 1, 0, cnt);\n      register(ary, next, 1, 2, cnt);\n      register(ary, next, 1, 4, cnt);\n    } else if (idx0 === 2) {\n      register(ary, next, 2, 1, cnt);\n      register(ary, next, 2, 5, cnt);\n    } else if (idx0 === 3) {\n      register(ary, next, 3, 0, cnt);\n      register(ary, next, 3, 4, cnt);\n      register(ary, next, 3, 6, cnt);\n    } else if (idx0 === 4) {\n      register(ary, next, 4, 1, cnt);\n      register(ary, next, 4, 3, cnt);\n      register(ary, next, 4, 5, cnt);\n      register(ary, next, 4, 7, cnt);\n    } else if (idx0 === 5) {\n      register(ary, next, 5, 2, cnt);\n      register(ary, next, 5, 4, cnt);\n      register(ary, next, 5, 8, cnt);\n    } else if (idx0 === 6) {\n      register(ary, next, 6, 3, cnt);\n      register(ary, next, 6, 7, cnt);\n    } else if (idx0 === 7) {\n      register(ary, next, 7, 4, cnt);\n      register(ary, next, 7, 6, cnt);\n      register(ary, next, 7, 8, cnt);\n    } else if (idx0 === 8) {\n      register(ary, next, 8, 5, cnt);\n      register(ary, next, 8, 7, cnt);\n    }\n  }\n  return next;\n}\n\nwhile (next.indexOf(goal) === -1)\n  next = widen(next);\nconsole.log(cnt);"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\nq = [[k = create_hash(brd), 0]]\nans = -1\nset = Set.new([])\nset.add(k)\nuntil q.empty?\n  key, cnt = q.shift\n  if key == Goal\n    ans = cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      q << [k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    goal.size.times{|i|\n      d += (@mat.index(goal[i]) - i).abs\n    }\n    return d\n  end\nend\n\ndef cal(mat)\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if mat[i] != goal[i]\n    }\n    return d\nend\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  it = q.extract\n  p it\n  if it.cost == 0 then\n    puts it.step\n    exit\n  end\n  done[it.mat.join(\" \")] = true\n  idx = it.mat.index(0)\n\n  #Down\n  unless idx < 3 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-3] = mat[idx-3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \n  #Up\n  unless idx > 5 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+3] = mat[idx+3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Left\n  unless idx % 3 == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-1] = mat[idx-1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Right\n  unless idx % 3 == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+1] = mat[idx+1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Puzzle\n  attr_accessor :mat, :cost\n  def initialize(mat)\n    @mat = mat\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost < other.cost ? true : false\n  end\n  def <(other)\n    return self.cost > other.cost ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat)\nq = Heep.new\nq.insert(ini)\n\nsteps = 0\ndone = {}\nloop do\n  newq = Heep.new\n  loop do\n    break if q.size == 0\n    theMat = q.extract\n    p theMat\n    if theMat.cost == 0 then\n      puts steps\n    end\n    done[theMat.mat.join(\" \")] = true\n    idx = theMat.mat.index(0)\n    #Down\n    unless idx < 3 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Up\n    unless idx > 5 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Left\n    unless idx % 3 == 0 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Right\n    unless idx % 3 == 2 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n  end\n  q = newq\n  steps += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\n\ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\n$heap = []\n$n = 0\ninsert [judge(brd, 0), brd, 0]\nset = Set.new([])\nset.add(brd)\nwhile $n > 0\n  val, b, cnt = extract\n  if val == cnt\n    p cnt\n    break\n  end\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    nb = b.dup\n    unless set.include?(nb)\n      set.add(nb)\n      insert [judge(b, cnt+1), nb, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\n\ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\n$heap = []\n$n = 0\ninsert [judge(brd, 0), brd, 0]\nset = SortedSet.new([])\nset.add(brd)\nwhile $n > 0\n  val, b, cnt = extract\n  next if val > 45\n  if val == cnt\n    p cnt\n    break\n  end\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    nb = b.dup\n    unless set.include?(nb)\n      set.add(nb)\n      insert [judge(b, cnt+1), nb, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# ???????????Â¢??Â¶?????????\nend_panels = []\n3.times do |i|\n  end_panels << STDIN.gets.chomp.split(' ').map(&:to_i)\nend\nend_panels.flatten!\n\nstart_panels = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nwidth = 3\nheight = 3\n$queue = [[true, []], [false, []]]\nforward_cache = {}\nbackward_cache = {}\n\ndef add_queue(is_forward, dicts, dict)\n  dicts2 = dicts.dup\n  dicts2 << dict\n  $queue << [is_forward, dicts2]\nend\n\nwhile true do\n  # ?Â§????\n  q = $queue.shift\n  is_forward, dicts = q[0], q[1]\n  if is_forward\n    panels = start_panels.dup\n  else\n    panels = end_panels.dup\n  end\n  z = panels.index(0)\n  dicts.each do |d|\n    case d\n    when :u then panels[z], panels[z-3] = panels[z-3], panels[z]\n    when :d then panels[z], panels[z+3] = panels[z+3], panels[z]\n    when :l then panels[z], panels[z-1] = panels[z-1], panels[z]\n    when :r then panels[z], panels[z+1] = panels[z+1], panels[z]\n    end\n    z = panels.index(0)\n  end\n#pp dicts\n  # ??????????????????\n  if is_forward && backward_cache.key?(panels)\n    puts dicts.size + backward_cache[panels].size\n    break\n  elsif !is_forward && forward_cache.key?(panels)\n    puts dicts.size + forward_cache[panels].size\n    break\n  end\n  if is_forward\n    if !forward_cache.key?(panels) || forward_cache[panels].size > dicts.size\n      forward_cache[panels] = dicts\n    end\n  else\n    if !backward_cache.key?(panels) || backward_cache[panels].size > dicts.size\n      backward_cache[panels] = dicts\n    end\n  end\n\n  # ?Â¬??????Â¢?Â´Â¢?????????\n  if z / width != 0 \\\n     && dicts[-1] != :d\n     # && dicts[-3, 3] != [:l, :d, :r] \\\n     # && dicts[-3, 3] != [:r, :d, :l]\n    add_queue(is_forward, dicts, :u)\n  end\n  if z / width != height - 1 \\\n     && dicts[-1] != :u\n     # && dicts[-3, 3] != [:l, :u, :r] \\\n     # && dicts[-3, 3] != [:r, :u, :l]\n    add_queue(is_forward, dicts, :d)\n  end\n  if z % width != 0 \\\n     && dicts[-1] != :r\n     # && dicts[-3, 3] != [:u, :r, :d] \\\n     # && dicts[-3, 3] != [:d, :r, :u]\n    add_queue(is_forward, dicts, :l)\n  end\n  if z % width != width - 1 \\\n     && dicts[-1] != :l\n     # && dicts[-3, 3] != [:u, :l, :d] \\\n     # && dicts[-3, 3] != [:d, :l, :u]\n    add_queue(is_forward, dicts, :r)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Puzzle\n  attr_accessor :mat, :cost\n  def initialize(mat)\n    @mat = mat\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost < other.cost ? true : false\n  end\n  def <(other)\n    return self.cost > other.cost ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat)\nq = Heep.new\nq.insert(ini)\n\nsteps = 0\ndone = {}\nloop do\n  newq = Heep.new\n  loop do\n    break if q.size == 0\n    theMat = q.extract\n    if theMat.cost == 0 then\n      puts steps\n    end\n    done[theMat.mat.join(\" \")] = true\n    idx = theMat.mat.index(0)\n    #Down\n    unless idx < 3 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Up\n    unless idx > 5 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Left\n    unless idx % 3 == 0 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Right\n    unless idx % 3 == 2 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n  end\n  q = newq\n  steps += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\n\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\n$heap = []\n$n = 0\ninsert [judge(brd, 0), k = create_hash(brd), 0]\nset = Set.new([])\nset.add(k)\nwhile $n > 0\n  val, key, cnt = extract\n  if val == cnt\n    p cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      insert [judge(b, cnt+1), k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# frozen_string_literal: true\nrequire 'set'\n\nchecked_puzzles = Set.new\ncurrent_puzzles = Set.new\n\ninput_puzzle = 3.times.map{gets.split.map(&:to_i)}.flatten\ncurrent_puzzles.add(input_puzzle)\ncount = 0\n\ngoal_puzzle = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nloop do\n  next_puzzles = Set.new\n  current_puzzles.each do |puzzle|\n    if puzzle == goal_puzzle\n      puts count\n      exit\n    end\n\n    zero_point = puzzle.index(0)\n    y, x = zero_point.divmod(3)\n    if x != 2\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point + 1]\n      tmp_puzzle[zero_point + 1] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n    if x != 0\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point - 1]\n      tmp_puzzle[zero_point - 1] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n    if y != 2\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point + 3]\n      tmp_puzzle[zero_point + 3] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n    if y != 0\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point - 3]\n      tmp_puzzle[zero_point - 3] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n  end\n  checked_puzzles.merge(current_puzzles)\n  current_puzzles = next_puzzles - checked_puzzles\n  count += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "def calc_number(puzzle)\n  nums = puzzle.dup\n  puzzle.each_with_index do |x, i_x|\n    puzzle[i_x..-1].each_with_index do |y, i_y|\n      nums[i_x + i_y] -= 1 if y > x\n    end\n  end\n\n  number = 0\n  nums.each_with_index do |x, i_x|\n    factorial = (nums.size - 1 - i_x).downto(1).inject(:*)\n    number += factorial * x if factorial != nil\n  end\n  return number\nend\n\ndef find_zero(puzzle)\n  return puzzle.index(0)\nend\n\nSWAP_CHOICE = [[1, 3],    [0, 2, 4],    [1, 5], \n               [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n               [3, 7],    [4, 6, 8],    [5, 7]]\n\nGOAL_STATE = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# main\ninit_state = []\n3.times do \n  init_state.concat(gets.chomp.split.map(&:to_i))\nend\n\nstates = Array.new(9.downto(1).inject(:*), false)\nstates[calc_number(init_state)] = true\nqueue = [[init_state, 0]]\n\nwhile queue.size > 0 do\n  state = queue.shift\n  break if state[0] == GOAL_STATE\n  zero_position = find_zero(state[0])\n  swap_positions = SWAP_CHOICE[zero_position]\n\n  swap_positions.each do |swap_position|\n    new_state = [state[0].dup, state[1]]\n    new_state[0][zero_position], new_state[0][swap_position] = \n      new_state[0][swap_position], new_state[0][zero_position]\n    new_number = calc_number(new_state[0])\n    next if states[new_number] == true\n    new_state[1] += 1\n    queue << new_state\n    states[new_number] = true\n  end\nend\n\np state[1]"
  },
  {
    "language": "Ruby",
    "code": "class EightPuzzle\n  DX = [0, -1, 0, 1]\n  DY = [-1, 0, 1, 0]\n  TARGET = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n  class Puzzle\n    attr_accessor :place, :sp, :cnt\n\n    def initialize(place)\n      @place = place\n      @sp = place.index(0)\n      @cnt = 0\n    end\n\n    def initialize_copy(obj)\n      @place = obj.place.dup\n      @sp = obj.sp\n      @cnt = obj.cnt\n    end\n  end\n\n  def initialize\n    place = []\n    3.times do\n      place << gets.split.map(&:to_i)\n    end\n    place.flatten!\n    @puz = Puzzle.new(place)\n    @q = []\n    @s = {}\n  end\n\n  def solve\n    @q << @puz\n    @s[@puz.place] = true\n\n    while !@q.empty?\n      puz = @q.shift\n      return puz.cnt if puz.place == TARGET\n      sx = puz.sp % 3\n      sy = puz.sp / 3\n      (0..3).each do |i|\n        x = sx + DX[i]\n        y = sy + DY[i]\n        next if x < 0 || 2 < x || y < 0 || 2 < y\n        v = puz.dup\n        v.place[puz.sp], v.place[3 * y + x] = v.place[3 * y + x], v.place[puz.sp]\n        v.sp = 3 * y + x\n        unless @s[v.place]\n          @s[v.place] = true\n          v.cnt += 1\n          @q << v\n        end\n      end\n    end\n  end\nend\n\nep = EightPuzzle.new\nputs ep.solve"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\ndef judge(brd)\n  ret = 0\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\nq = [[judge(brd), k = create_hash(brd), 0]]\nans = -1\nset = Set.new([])\nset.add(k)\nuntil q.empty?\n  arr = q.min{ |a, b| a <=> b }\n  q.delete(arr)\n  _, key, cnt = arr\n  if key == Goal\n    ans = cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      q << [judge(b), k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  def initialize(state, direction, count=-1)\n    @state = state\n    @count = count\n    @direction = direction\n  end\n\n  def calc_number\n    nums = @state.dup\n    @state.each_with_index do |x, i_x|\n      @state[i_x..-1].each_with_index do |y, i_y|\n        nums[i_x + i_y] -= 1 if y > x\n      end\n    end\n\n    number = 0\n    nums.each_with_index do |x, i_x|\n      factorial = (nums.size - 1 - i_x).downto(1).inject(:*)\n      number += factorial * x if factorial != nil\n    end\n    return number\n  end\n\n  def find_zero\n    return @state.index(0)\n  end\n\n  def print_puzzle\n    puts state[0..2].join(' ')\n    puts state[3..5].join(' ')\n    puts state[6..8].join(' ')\n  end\n\n  attr_accessor :state, :count, :direction\nend\n\nclass Dictionary\n  def initialize(num)\n    @visited_dict = Array.new(num, 1)\n    @count_dict = Array.new(num, 0)\n  end\n\n  attr_reader :visited_dict, :count_dict\n\n  def visited?(index, direction)\n    return @visited_dict[index] != 1 && @visited_dict[index] % direction == 0\n  end\n\n  def visit(puzzle)\n    index = puzzle.calc_number\n    direction = puzzle.direction\n    count = puzzle.count\n    @visited_dict[index] *= direction\n    @count_dict[index] += count\n  end\n\n  def get_count(puzzle)\n    return count_dict[puzzle.calc_number]\n  end\nend\n\nSWAP_CHOICE = [[1, 3],    [0, 2, 4],    [1, 5], \n               [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n               [3, 7],    [4, 6, 8],    [5, 7]]\n\nGOAL_STATE = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nFORWARD = 2\nBACKWARD = 3\n\n# main\ninit_state = []\n3.times do \n  init_state.concat(gets.chomp.split.map(&:to_i))\nend\n\nqueue = []\ninit_puzzle = Puzzle.new(init_state, FORWARD, 0)\ngoal_puzzle = Puzzle.new(GOAL_STATE, BACKWARD, 0)\nqueue << init_puzzle \nqueue << goal_puzzle\n\ndict = Dictionary.new(9.downto(1).inject(:*))\ndict.visit(init_puzzle)\ndict.visit(goal_puzzle)\n\nwhile queue.size > 0 do\n  puzzle = queue.shift\n  index = puzzle.calc_number\n  if dict.visited?(index, FORWARD) && dict.visited?(index, BACKWARD) then\n    puts dict.count_dict[index] \n    break\n  end\n\n  zero_position = puzzle.find_zero\n  swap_positions = SWAP_CHOICE[zero_position]\n\n  swap_positions.each do |swap_pos|\n    new_puzzle = Puzzle.new(puzzle.state.dup, \n                            puzzle.direction, \n                            puzzle.count + 1)\n    new_puzzle.state[zero_position], new_puzzle.state[swap_pos] = \n      new_puzzle.state[swap_pos], new_puzzle.state[zero_position]\n    next if dict.visited?(new_puzzle.calc_number, new_puzzle.direction)\n\n    queue << new_puzzle\n    dict.visit(new_puzzle)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :s, :cou, :direction\n  def initialize(s, direction, cou=-1)\n    @s = s\n    @cou = cou\n    @direction = direction\n  end\n\n  def calc\n    nums = @s.dup\n    @s.each_with_index do |x, i_x|\n      @s[i_x..-1].each_with_index do |y, i_y|\n        nums[i_x + i_y] -= 1 if y > x\n      end\n    end\n    number = 0\n    nums.each_with_index do |x, i_x|\n      factorial = (nums.size - 1 - i_x).downto(1).inject(:*)\n      number += factorial * x if factorial != nil\n    end\n    return number\n  end\n\n  def zero\n    return @s.index(0)\n  end\nend\n\nclass Dic\n  attr_reader :visit, :cou\n  def initialize(num)\n    @visit = Array.new(num, 1)\n    @cou = Array.new(num, 0)\n  end\n  def visited?(id, direction)\n    return @visit[id] != 1 && @visit[id] % direction == 0\n  end\n  def visit(puzzle)\n    id = puzzle.calc\n    direction = puzzle.direction\n    cou = puzzle.cou\n    @visit[id] *= direction\n    @cou[id] += cou\n  end\n\n  def get(puzzle)\n    return cou[puzzle.calc]\n  end\nend\n\nmove = [[1, 3],\n        [0, 2, 4],\n        [1, 5],\n        [0, 4, 6],\n        [1, 3, 5, 7],\n        [2, 4, 8],\n        [3, 7],\n        [4, 6, 8],\n        [5, 7]]\n\ncol = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nf = 2\nb = 3\n\n# main\ninit_s = []\n3.times do\n  init_s.concat(gets.chomp.split.map(&:to_i))\nend\n\nqueue = []\ninit = Puzzle.new(init_s, f, 0)\ngoal = Puzzle.new(col, b, 0)\nqueue << init\nqueue << goal\n\ndict = Dic.new(9.downto(1).inject(:*))\ndict.visit(init)\ndict.visit(goal)\n\nwhile queue.size > 0 do\n  puzzle = queue.shift\n  id = puzzle.calc\n  if dict.visited?(id, f) && dict.visited?(id, b) then\n    puts dict.cou[id]\n    break\n  end\n\n  zero = puzzle.zero\n  swap = move[zero]\n\n  swap.each{|swap_pos|\n    new = Puzzle.new(puzzle.s.dup,puzzle.direction,puzzle.cou+1)\n    new.s[zero], new.s[swap_pos] = new.s[swap_pos], new.s[zero]\n    next if dict.visited?(new.calc, new.direction)\n    queue << new\n    dict.visit(new)\n  }\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  theMat = q.extract\n  if theMat.cost == 0 then\n    puts theMat.step\n    exit\n  end\n  done[theMat.mat.join(\" \")] = true\n  idx = theMat.mat.index(0)\n  #Down\n  unless idx < 3 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\n  #Up\n  unless idx > 5 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\n  #Left\n  unless idx % 3 == 0 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\n  #Right\n  unless idx % 3 == 2 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# frozen_string_literal: true\nrequire 'set'\n\ndef array_to_puzzle(list)\n  Array.new(9) { |i| list[i] << (i * 4) }.inject(:+)\nend\n\ndef puzzle_point(puzzle, point)\n  puzzle & (0xF << point)\nend\n\ndef clear_point(puzzle, point_list)\n  point_list.inject(puzzle) do |acc, point|\n    acc & ~(0xF << point)\n  end\nend\n\ndef find_zero_point(puzzle)\n  0.step(32, 4).find { |point| puzzle_point(puzzle, point).zero? }\nend\n\nchecked_puzzles = Set.new\ncurrent_puzzles = Set.new\n\ninput_puzzle = array_to_puzzle(Array.new(3) { gets.split.map(&:to_i) }.flatten)\ncurrent_puzzles.add(input_puzzle)\ncount = 0\n\ngoal_puzzle = array_to_puzzle([1, 2, 3, 4, 5, 6, 7, 8, 0])\n\nloop do\n  next_puzzles = Set.new\n  current_puzzles.each do |puzzle|\n    if puzzle == goal_puzzle\n      puts count\n      exit\n    end\n\n    zero_point = find_zero_point(puzzle)\n    y, x = (zero_point / 4).divmod(3)\n    if x != 2\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point + 4]) |\n                       (puzzle_point(puzzle, zero_point + 4) >> 4))\n    end\n    if x != 0\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point - 4]) |\n                       (puzzle_point(puzzle, zero_point - 4) << 4))\n    end\n    if y != 2\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point + 12]) |\n                       (puzzle_point(puzzle, zero_point + 12) >> 12))\n    end\n    if y != 0\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point - 12]) |\n                       (puzzle_point(puzzle, zero_point - 12) << 12))\n    end\n  end\n  checked_puzzles.merge(current_puzzles)\n  current_puzzles = next_puzzles - checked_puzzles\n  count += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\nq = [[judge(brd, 0), k = create_hash(brd), 0]]\nans = -1\nset = Set.new([])\nset.add(k)\nuntil q.empty?\n  arr = q.min{ |a, b| a <=> b }\n  q.delete(arr)\n  _, key, cnt = arr\n  if key == Goal\n    ans = cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      q << [judge(b, cnt+1), k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :cost\n  def initialize(mat)\n    @mat = mat\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost < other.cost ? true : false\n  end\n  def <(other)\n    return self.cost > other.cost ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat)\nq = Heep.new\nq.insert(ini)\n\nsteps = 0\ndone = {}\nloop do\n  newq = Heep.new\n  loop do\n    break if q.size == 0\n    theMat = q.extract\n    if theMat.cost == 0 then\n      puts steps\n      exit\n    end\n    done[theMat.mat.join(\" \")] = true\n    idx = theMat.mat.index(0)\n    #Down\n    unless idx < 3 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Up\n    unless idx > 5 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Left\n    unless idx % 3 == 0 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Right\n    unless idx % 3 == 2 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n  end\n  q = newq\n  steps += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "# ???????????Â¢??Â¶?????????\ntarget_panels = []\n3.times do |i|\n  target_panels << STDIN.gets.chomp.split(' ').map(&:to_i)\nend\ntarget_panels.flatten!\n\nfirst_panels = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nwidth = 3\nheight = 3\n$queue = []\n\ndef add_queue(dicts, dict)\n  dicts2 = dicts.dup\n  dicts2 << dict\n  $queue << dicts2\nend\n\nwhile true do\n  # ?Â§????\n  panels = first_panels.dup\n  z = panels.index(0)\n  dicts = $queue.shift || []\n  dicts.each do |d|\n    case d\n    when :u then panels[z], panels[z-3] = panels[z-3], panels[z]\n    when :d then panels[z], panels[z+3] = panels[z+3], panels[z]\n    when :l then panels[z], panels[z-1] = panels[z-1], panels[z]\n    when :r then panels[z], panels[z+1] = panels[z+1], panels[z]\n    end\n    z = panels.index(0)\n  end\n  # ??????????????????\n  if panels == target_panels\n    puts dicts.size\n    break\n  end\n  # ?Â¬??????Â¢?Â´Â¢?????????\n  if z / width != 0 && dicts[-1] != :d\n    add_queue(dicts, :u)\n  end\n  if z / width != height - 1 && dicts[-1] != :u\n    add_queue(dicts, :d)\n  end\n  if z % width != 0 && dicts[-1] != :r\n    add_queue(dicts, :l)\n  end\n  if z % width != width - 1 && dicts[-1] != :l\n    add_queue(dicts, :r)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    goal.size.times{|i|\n      d += (@mat.index(goal[i]) - i).abs\n    }\n    return d\n  end\nend\n\ndef cal(mat)\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if mat[i] != goal[i]\n    }\n    return d\nend\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  it = q.extract\n  if it.cost == 0 then\n    puts it.step\n    exit\n  end\n  done[it.mat.join(\" \")] = true\n  idx = it.mat.index(0)\n\n  #Down\n  unless idx < 3 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-3] = mat[idx-3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \n  #Up\n  unless idx > 5 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+3] = mat[idx+3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Left\n  unless idx % 3 == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-1] = mat[idx-1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Right\n  unless idx % 3 == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+1] = mat[idx+1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|n|\n      m = @mat.index(goal[n])\n      y1, x1 = n.divmod(3)\n      y2, x2 = m.divmod(3)\n      d += (y1-y2).abs + (x1-x2).abs\n    }\n    return d\n  end\nend\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i],mat[3*i+1],mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  it = q.extract\n  if it.cost == 0 then\n    p it.step\n    exit\n  else\n    done[it.mat.join(\"\")] = true\n  end\n  idx = it.mat.index(0)\n  y, x = idx.divmod(3)\n  #Down\n  unless y == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-3] = mat[idx-3], mat[idx]\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Up\n  unless y == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+3] = mat[idx+3], mat[idx]\n    tmp = Puzzle.new(mat, it.step+1)\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \n  #Left\n  unless x == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-1] = mat[idx-1], mat[idx]\n    tmp = Puzzle.new(mat, it.step+1)\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Right\n  unless x == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+1] = mat[idx+1], mat[idx]\n    tmp = Puzzle.new(mat, it.step+1)\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs() int {\n\tfor {\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs()\n\tfmt.Println(cost)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc Up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc Down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc Left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc Right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc nextInt() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := Up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := Down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := Left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := Right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(nextInt())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport(\n\t\"fmt\"\n)\n// import \"time\"\n\n// ãã¼ãã®ç¶æ\ntype Board = [9]int\n// ããºã«å¨ä½\ntype Puzzle struct {\n\tBrd Board\n\tZero int\n\tMoved int\n}\nvar FINISH_STATE Board = Board{ 1, 2, 3, 4, 5, 6, 7, 8, 0 }\nfunc (this *Puzzle) IsDone() bool {\n\treturn this.Brd == FINISH_STATE\n}\n\nfunc FindZero(board* Board) int {\n\tfor i, v := range board {\n\t\tif v == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\tfmt.Println(\"Error 0 Not found\")\n\treturn -1\n}\n\n\n// ç§»åå¯è½ã\nfunc (this *Puzzle) CanUp() bool {\n\treturn 2 < this.Zero\n}\n\nfunc (this *Puzzle) CanDown() bool {\n\treturn this.Zero < 6\n}\n\nfunc (this *Puzzle) CanLeft() bool {\n\treturn this.Zero % 3 != 0\n}\n\nfunc (this *Puzzle) CanRight() bool {\n\treturn this.Zero % 3 != 2\n}\n\n// ç§»åå¾ã®ç¶æã\nfunc (this *Puzzle) Up() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, -3), this.Zero - 3, this.Moved + 1 }\n}\nfunc (this *Puzzle) Down() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, +3), this.Zero + 3, this.Moved + 1 }\n}\nfunc (this *Puzzle) Left() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, -1), this.Zero -1, this.Moved + 1 }\n}\nfunc (this *Puzzle) Right() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, 1), this.Zero + 1, this.Moved + 1 }\n}\n// common move\nfunc Move(board Board, zero int, direction int) Board {\n\tboard[zero], board[zero + direction] = board[zero + direction], board[zero]\n\treturn board\n}\n\n\ntype Memo struct {\n\tData map[int][]Board\n}\nfunc NewMemo() Memo{\n\t// var data [9][9][]Board = [9][9][]Board{}\n\t// for i := 0; i < 9; i++ {\n\t// \tfor j := 0; j < 9; j++ {\n\t// \t\tdata[i][j] = make([]Board, 0)\n\t// \t}\n\t// }\n\treturn Memo{ make(map[int][]Board) }\n}\nfunc (m *Memo) Add(board Board) {\n\tindex := board[0] * 10000 + board[1] * 1000 + board[2] * 100 + board[3] * 10 + board[4] * 1\n\tm.Data[index] = append(m.Data[index], board)\n}\n\nfunc (m *Memo) HasTried(board *Board) bool {\n\tindex := board[0] * 10000 + board[1] * 1000 + board[2] * 100 + board[3] * 10 + board[4] * 1\n\tfor _, state := range m.Data[index] {\n\t\tif state == *board {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\n\nfunc Solve(board Board) int {\n\t// prepare\n\tqueue := make([]Puzzle, 0)\n\tpzl := Puzzle{ board, FindZero(&board), 0 }\n\tqueue = append(queue, pzl)\n\tmemo := NewMemo()\n\n\tcount := 0\n\tfor len(queue) != 0 {\n\t\tcount++\n\t\t// before := time.Now()\n\n\t\te := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif e.IsDone() {\n\t\t\t// fmt.Printf(\"count:%d\\n\", count)\n\t\t\treturn e.Moved\n\t\t} else {\n\t\t\t// memo = append(memo, e.Brd)\n\t\t\tmemo.Add(e.Brd)\n\t\t}\n\t\tif e.CanUp() {\n\t\t\t// fmt.Println(\"up\")\n\t\t\tnewPzl := e.Up()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\tif e.CanDown() {\n\t\t\t// fmt.Println(\"down\")\n\t\t\tnewPzl := e.Down()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\tif e.CanLeft() {\n\t\t\t// fmt.Println(\"left\")\n\t\t\tnewPzl := e.Left()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\tif e.CanRight() {\n\t\t\t// fmt.Println(\"right\")\n\t\t\tnewPzl := e.Right()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\t// fmt.Printf(\"spend: %v\\n\", time.Now().Sub(before))\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tvar board Board\n\tfor i := 0; i < 9; i++ {\n\t\tvar v int\n\t\tfmt.Scanf(\"%d\", &v)\n\t\tboard[i] = v\n\t}\n\tresult := Solve(board)\n\tfmt.Println(result)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tN    = 3\n\tBASE = 10007\n\tMOD  = 1000000007\n)\n\ntype Puzzle struct {\n\tboard [N * N]int // (x, y). (0, 0) = 0,  (1, 0) = 1, (0, 1) = 3\n}\n\ntype SolveContext struct {\n\tcurrent *Puzzle\n\tcount   int\n}\n\ntype Position struct {\n\tx int\n\ty int\n}\n\nfunc NewPuzzle(b [N * N]int) *Puzzle {\n\treturn &Puzzle{board: b}\n}\n\nfunc (puzzle *Puzzle) hash() int {\n\tarr := puzzle.board\n\tsum := arr[0]\n\tfor i := 1; i < len(arr); i++ {\n\t\tsum = sum*BASE + arr[i]\n\t\tif sum > MOD {\n\t\t\tsum = sum % MOD\n\t\t}\n\t}\n\treturn sum\n}\n\nfunc (puzzle *Puzzle) isSolved() bool {\n\tsolvedBoard := [N * N]int{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\treturn puzzle.board == solvedBoard\n}\n\nfunc swap(puzzle *Puzzle, one, two Position) *Puzzle {\n\tswapped := NewPuzzle(puzzle.board)\n\tswapped.board[one.y*N+one.x], swapped.board[two.y*N+two.x] =\n\t\tswapped.board[two.y*N+two.x], swapped.board[one.y*N+one.x]\n\treturn swapped\n}\n\nfunc (puzzle *Puzzle) getEmptyPosition() *Position {\n\tfor i := 0; i < N; i++ {\n\t\tfor j := 0; j < N; j++ {\n\t\t\tif puzzle.board[i*N+j] == 0 {\n\t\t\t\treturn &Position{x: j, y: i}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (puzzle *Puzzle) nextPuzzles() []*Puzzle {\n\temptyPosition := puzzle.getEmptyPosition()\n\tif emptyPosition == nil {\n\t\tpanic(fmt.Errorf(\"emptyPostion must not be empty\"))\n\t}\n\tbasePosition := *emptyPosition\n\tdirections := [][2]int{[2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}} // []{x, y}\n\tnexts := []*Puzzle{}\n\tfor _, dir := range directions {\n\t\tnextPosition := Position{basePosition.x + dir[0], basePosition.y + dir[1]}\n\t\tif nextPosition.x >= 0 && nextPosition.x <= N-1 &&\n\t\t\tnextPosition.y >= 0 && nextPosition.y <= N-1 {\n\t\t\tnexts = append(nexts, swap(puzzle, basePosition, nextPosition))\n\t\t}\n\t}\n\treturn nexts\n}\n\nfunc solve(initialPuzzle *Puzzle) int {\n\tinitial := SolveContext{initialPuzzle, 0}\n\tvisited := make(map[int]*struct{})\n\tstack := []SolveContext{initial}\n\tvar solved SolveContext\n\tfor len(stack) > 0 {\n\t\tsolveContext := stack[0]\n\t\tcurrent := solveContext.current\n\t\tcount := solveContext.count\n\t\tvisited[current.hash()] = &struct{}{}\n\t\tstack = stack[1:]\n\t\tif current.isSolved() {\n\t\t\tsolved = solveContext\n\t\t\tbreak\n\t\t}\n\t\tfor _, v := range current.nextPuzzles() {\n\t\t\tif visited[v.hash()] == nil {\n\t\t\t\tnextContext := SolveContext{v, count + 1}\n\t\t\t\tstack = append(stack, nextContext)\n\t\t\t}\n\t\t}\n\t}\n\treturn solved.count\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tvar arr [N * N]int\n\tfor i := 0; i < len(arr); i++ {\n\t\tx, err := nextInt(sc)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tarr[i] = x\n\t}\n\n\tpuzzle := NewPuzzle(arr)\n\tfmt.Println(solve(puzzle))\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td [9]byte\n\tc int\n}\n\nvar queue = []item{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif top.d == goal {\n\t\t\treturn top.c\n\n\t\t}\n\n\t\tok, ur := up(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]int) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]int{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]int) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td [9]int\n\tc int\n}\n\nvar queue = []item{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif top.d == goal {\n\t\t\treturn top.c\n\n\t\t}\n\n\t\tok, ur := up(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]int\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = next()\n\t}\n\tqueue = append(queue, item{state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\n\tif len(os.Args) > 1 {\n\t\tfp, _ = os.Open(os.Args[1])\n\t\tif len(os.Args) > 2 {\n\t\t\twfp, _ = os.Create(os.Args[2])\n\t\t}\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\n\tpath := make([]string, 9)\n\n\tfor i := 0; i < 9; i++ {\n\t\tpath[i] = getNextString(scanner)\n\t}\n\n\tq := make([]Pair, 0)\n\n\tq = append(q, Pair{\n\t\tpath: strings.Join(path, \"\"),\n\t\tc:    0,\n\t})\n\n\tvisited := make(map[string]int, 0)\n\tans := 0\n\tvisited[q[0].path] = 1\n\tfor len(q) > 0 {\n\t\tp := q[0]\n\t\tq = q[1:]\n\t\tif p.path == \"123456780\" {\n\t\t\tans = p.c\n\t\t\tbreak\n\t\t}\n\t\tfor i := 0; i < 9; i++ {\n\t\t\tif p.path[i] == '0' {\n\t\t\t\tif i-3 >= 0 {\n\t\t\t\t\tap := swap(p.path, i, i-3)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i+3 < 9 {\n\t\t\t\t\tap := swap(p.path, i, i+3)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i%3 != 0 {\n\t\t\t\t\tap := swap(p.path, i, i-1)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i%3 != 2 {\n\t\t\t\t\tap := swap(p.path, i, i+1)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Fprintln(writer, ans)\n\twriter.Flush()\n}\n\ntype Pair struct {\n\tpath string\n\tc    int\n}\n\nfunc swap(s string, i, j int) string {\n\tsp := strings.Split(s, \"\")\n\tsp[i], sp[j] = sp[j], sp[i]\n\treturn strings.Join(sp, \"\")\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"container/heap\"\n)\n\ntype State struct {\n\tPuzzle []int\n\tZero int\n\tPrev int\n\tTurn int\n\tDis int\n\tCost int\n}\n\ntype PriorityQueue []*State\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\treturn pq[i].Cost < pq[j].Cost\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\t*pq = append(*pq, x.(*State))\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\tn := len(*pq)\n\tpop := (*pq)[n-1]\n\t*pq = (*pq)[0:n-1]\n\treturn pop\n}\n\nfunc main() {\n\tn := 9\n\tpuzzle := make([]int, n)\n\tvar zero int\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Scan(&puzzle[i])\n\t\tif puzzle[i] == 0 {\n\t\t\tpuzzle[i] = n\n\t\t\tzero = i\n\t\t}\n\t}\n\n\tturn := 0\n\tdis := dist(&puzzle)\n\tif dis == 0 {\n\t\tfmt.Println(turn)\n\t\treturn\n\t}\n\tque := PriorityQueue{&State{puzzle, zero, -1, turn, dis, turn + dis}}\n\theap.Init(&que)\n\tdir := []int{-3,-1,1,3}\n\tfor que.Len() > 0 {\n\t\tpop := heap.Pop(&que).(*State)\n\t\tfor i := 0; i < len(dir); i++ {\n\t\t\tnext := (*pop).Zero + dir[i]\n\t\t\tif next == (*pop).Prev {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif next < 0 || n <= next {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (next%3 - (*pop).Zero%3) * dir[i] < 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tp := make([]int, n)\n\t\t\tcopy(p, (*pop).Puzzle)\n\t\t\tp[next], p[(*pop).Zero] = p[(*pop).Zero], p[next]\n\t\t\tturn = (*pop).Turn + 1\n\t\t\tdis = dist(&p)\n\t\t\tif dis == 0 {\n\t\t\t\tfmt.Println(turn)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\theap.Push(&que, &State{p, next, (*pop).Zero, turn, dis, turn + dis})\n\t\t}\n\t}\n}\n\nfunc dist(p *[]int) int {\n\tsum := 0\n\tn := len(*p)\n\tfor i := 0; i < n; i++ {\n\t\tv := (*p)[i] - 1\n\t\tsum += abs(v/3 - i/3)\n\t\tsum += abs(v%3 - i%3)\n\t}\n\treturn sum / 2\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\n\t\t}\n\n\t\tok, ur := up(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tN    = 3\n\tBASE = 10007\n\tMOD  = 1000000007\n)\n\ntype Puzzle struct {\n\tboard [N * N]int // (x, y). (0, 0) = 0,  (1, 0) = 1, (0, 1) = 3\n}\n\ntype SolveContext struct {\n\tcurrent  *Puzzle\n\tprevious *Puzzle\n\tcount    int\n}\n\ntype Position struct {\n\tx int\n\ty int\n}\n\nfunc NewPuzzle(b [N * N]int) *Puzzle {\n\treturn &Puzzle{board: b}\n}\n\nfunc (puzzle *Puzzle) toInt() int {\n\tarr := puzzle.board\n\tsum := arr[0]\n\tfor i := 1; i < len(arr); i++ {\n\t\tsum = sum*BASE + arr[i]\n\t\tif sum > MOD {\n\t\t\tsum = sum % MOD\n\t\t}\n\t}\n\treturn sum\n}\n\nfunc (puzzle *Puzzle) isSolved() bool {\n\tsolvedBoard := [N * N]int{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\treturn puzzle.board == solvedBoard\n}\n\nfunc swap(puzzle *Puzzle, one, two Position) *Puzzle {\n\tswapped := NewPuzzle(puzzle.board)\n\tswapped.board[one.y*N+one.x], swapped.board[two.y*N+two.x] =\n\t\tswapped.board[two.y*N+two.x], swapped.board[one.y*N+one.x]\n\treturn swapped\n}\n\nfunc (puzzle *Puzzle) getEmptyPosition() *Position {\n\tfor i := 0; i < N; i++ {\n\t\tfor j := 0; j < N; j++ {\n\t\t\tif puzzle.board[i*N+j] == 0 {\n\t\t\t\treturn &Position{x: j, y: i}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (puzzle *Puzzle) nextPuzzles() []*Puzzle {\n\temptyPosition := puzzle.getEmptyPosition()\n\tif emptyPosition == nil {\n\t\tpanic(fmt.Errorf(\"emptyPostion must not be empty\"))\n\t}\n\tbasePosition := *emptyPosition\n\tdirections := [][2]int{[2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}} // []{x, y}\n\tnexts := []*Puzzle{}\n\tfor _, dir := range directions {\n\t\tnextPosition := Position{basePosition.x + dir[0], basePosition.y + dir[1]}\n\t\tif nextPosition.x >= 0 && nextPosition.x <= N-1 &&\n\t\t\tnextPosition.y >= 0 && nextPosition.y <= N-1 {\n\t\t\tnexts = append(nexts, swap(puzzle, basePosition, nextPosition))\n\t\t}\n\t}\n\treturn nexts\n}\n\nfunc solve(initialPuzzle *Puzzle) int {\n\tinitial := SolveContext{initialPuzzle, nil, 0}\n\tvisited := make(map[int]*struct{})\n\tstack := []SolveContext{initial}\n\tvar solved SolveContext\n\tfor len(stack) > 0 {\n\t\tsolveContext := stack[0]\n\t\tcurrent := solveContext.current\n\t\tcount := solveContext.count\n\t\tvisited[current.toInt()] = &struct{}{}\n\t\tstack = stack[1:]\n\t\tif current.isSolved() {\n\t\t\tsolved = solveContext\n\t\t\tbreak\n\t\t}\n\t\tfor _, v := range current.nextPuzzles() {\n\t\t\tif visited[v.toInt()] == nil {\n\t\t\t\tnextContext := SolveContext{v, current, count + 1}\n\t\t\t\tstack = append(stack, nextContext)\n\t\t\t}\n\t\t}\n\t}\n\treturn solved.count\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tvar arr [N * N]int\n\tfor i := 0; i < len(arr); i++ {\n\t\tx, err := nextInt(sc)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tarr[i] = x\n\t}\n\n\tpuzzle := NewPuzzle(arr)\n\tfmt.Println(solve(puzzle))\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\ntype Puzzle struct {\n\tnumbers     []int\n\tiZero       int\n\tpathHistory string\n}\n\nfunc (p Puzzle) toString() string {\n\ts := \"\"\n\tfor i := 0; i < len(p.numbers); i++ {\n\t\ts += strconv.Itoa(p.numbers[i])\n\t}\n\treturn s\n}\n\nfunc newPuzzle(size int) Puzzle {\n\tpuzzle := Puzzle{}\n\tpuzzle.numbers = make([]int, size)\n\treturn puzzle\n}\n\nfunc (p *Puzzle) isSolved() bool {\n\tfor i := 0; i <= 7; i++ {\n\t\tif p.numbers[i] != i+1 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (p *Puzzle) swap(i, j int) {\n\tp.numbers[i], p.numbers[j] = p.numbers[j], p.numbers[i]\n}\n\nfunc copy(p1, p2 *Puzzle) {\n\tp1.numbers = append([]int{}, p2.numbers...)\n\tp1.iZero = p2.iZero\n\tp1.pathHistory = p2.pathHistory\n}\n\nvar d = []int{1, -3, -1, 3}\n\nfunc newQueue() Queue {\n\tqueue := Queue{}\n\tqueue.array = []Puzzle{}\n\treturn queue\n}\n\ntype Queue struct {\n\tarray []Puzzle\n}\n\nfunc (q *Queue) push(p Puzzle) {\n\tq.array = append(q.array, p)\n}\n\nfunc (q *Queue) pop() Puzzle {\n\tp := q.array[0]\n\tq.array = q.array[1:len(q.array)]\n\treturn p\n}\n\nfunc (q *Queue) isEmpty() bool {\n\treturn len(q.array) == 0\n}\n\nfunc bfs(start Puzzle) string {\n\tqueue := newQueue()\n\tqueue.push(start)\n\n\thistory := map[string]bool{}\n\thistory[start.toString()] = true\n\n\tfor !queue.isEmpty() {\n\t\tu := queue.pop()\n\t\tif u.isSolved() {\n\t\t\treturn u.pathHistory\n\t\t}\n\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tdi := d[i]\n\n\t\t\tiZeroOld := u.iZero\n\t\t\tiZeroNew := u.iZero + di\n\n\t\t\tif iZeroNew < 0 || iZeroNew >= 9 || (di == -1 && iZeroOld%3 == 0) || (di == 1 && iZeroOld%3 == 2) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tv := Puzzle{}\n\t\t\tcopy(&v, &u)\n\t\t\tv.swap(iZeroOld, iZeroNew)\n\n\t\t\tif !history[v.toString()] {\n\t\t\t\thistory[v.toString()] = true\n\t\t\t\tv.iZero = iZeroNew\n\t\t\t\tv.pathHistory += strconv.Itoa(iZeroOld)\n\t\t\t\t// fmt.Println(v.toString())\n\t\t\t\tqueue.push(v)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"failed\"\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tpuzzle := newPuzzle(9)\n\tfor j := 0; j < 9; j++ {\n\t\tpuzzle.numbers[j] = nextInt()\n\t\tif puzzle.numbers[j] == 0 {\n\t\t\tpuzzle.iZero = j\n\t\t}\n\t}\n\n\tnUpdates := bfs(puzzle)\n\n\tfmt.Println(len(nUpdates))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\n\nvar up=[2]int{-1,0}\nvar down=[2]int{1,0}\nvar left=[2]int{0,-1}\nvar right=[2]int{0,1}\n\nconst size int =3\n\nconst UP int =0\nconst DOWN int =2\nconst LEFT int =1\nconst RIGHT int =3\n\nvar targetPoints [size*size][2]int\n\nvar movesHistory [100000]int\nvar ans=0\nvar tState =[][]int {//aim state\n\t{1 ,2 ,3} ,\n\t{4 ,5 ,6} ,\n\t{7 ,8,0}}\nvar STEP_SUM=0\nvar sState [][]int  //Init state\nvar blank_row,blank_column int\nfunc main(){\n\tvar in = bufio.NewReader(os.Stdin)\n\tvar out = bufio.NewWriter(os.Stdout)\n\tsState=make([][]int,size)\n\tfor i,_ := range sState {\n\t\tsState[i]=make([]int,size)\n\t}\n\tfor i := 0; i < size; i++ {\n\t\tfmt.Fscanf(in, \"%d %d %d\\n\", &sState[i][0], &sState[i][1],&sState[i][2])\n\t}\n\tgetPoint()\n\tj:=getHeuristic(sState)\n\ti:=-1\n\tfor ans = j; ; ans++ {\n\t\tif solve(sState,blank_row,blank_column,0,i,j) {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor k:=0;k<ans;k++ {\n\t\tmove(sState, movesHistory[k])\n\t}\n\tfmt.Fprintln(out,STEP_SUM)\n\tout.Flush()\n}\nfunc getPoint(){\n\tfor i:=0;i<size;i++ {\n\t\tfor j:=0;j<size;j++ {\n\t\t\tif sState[i][j] == 0 {\n\t\t\t\tblank_row = i;\n\t\t\t\tblank_column = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor i:=0;i<size;i++ { //get aim coordinate\n\t\tfor j:=0;j<size;j++ {\n\t\t\ttargetPoints[tState[i][j]][0] = i; //y-coordinate\n\t\t\ttargetPoints[tState[i][j]][1] = j; //x-coordinate\n\t\t}\n\t}\n}\nfunc getHeuristic(state [][]int) int {\n\theuristic := 0;\n\tfor i:=0;i<len(state);i++ {\n\t\tfor j:=0;j<len(state[i]);j++ {\n\t\t\tif state[i][j] != 0 {\n\t\t\t\theuristic = heuristic +\tint(math.Abs(float64(targetPoints[state[i][j]][0] - i))+math.Abs(float64(targetPoints[state[i][j]][1] - j)))\n\t\t\t}\n\t\t}\n\t}\n\treturn heuristic;\n}\n\nfunc solve(state [][]int, blank_row, blank_column, dep, d, h int) bool{\n\t//compare with aim matrix, check same or not, if same mean it's solved.\n\tisSolved := true\n\tfor i:=0;i<size;i++ {\n\t\tfor j:=0;j<size;j++ {\n\t\t\tif state[i][j] != tState[i][j] {\n\t\t\t\tisSolved = false\n\t\t\t}\n\t\t}\n\t}\n\tif isSolved {\n\t\treturn true\n\t}\n\tif dep == ans {\n\t\treturn false\n\t}\n\t//For express \"blank\" moved coordinate location\n\tblank_row1:= blank_row\n\tblank_column1:= blank_column\n\tstate2 := make([][]int,size)\n\tfor i,_ := range state2 {\n\t\tstate2[i]=make([]int,size)\n\t}\n\tfor direction:=0;direction<4;direction++ {\n\t\tfor i:=0;i<len(state);i++ {\n\t\t\tfor j:=0;j<len(state);j++ {\n\t\t\t\tstate2[i][j] = state[i][j]\n\t\t\t}\n\t\t}\n\t\t//if backtrace same with last time. end this situation.\n\t\tif direction != d && (d%2 == direction%2) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif direction == UP {\n\t\t\tblank_row1 = blank_row + up[0]\n\t\t\tblank_column1 = blank_column + up[1]\n\t\t} else if direction == DOWN {\n\t\t\tblank_row1 = blank_row + down[0]\n\t\t\tblank_column1 = blank_column + down[1]\n\t\t} else if direction == LEFT {\n\t\t\tblank_row1 = blank_row + left[0]\n\t\t\tblank_column1 = blank_column + left[1]\n\t\t} else {\n\t\t\tblank_row1 = blank_row + right[0]\n\t\t\tblank_column1 = blank_column + right[1]\n\t\t}\n\n\t\t//check the edge\n\t\tif blank_column1 < 0 || blank_column1 == size|| blank_row1 < 0 || blank_row1 == size {\n\t\t\tcontinue\n\t\t}\n\n\t\t//swap blank and right now moved locate coordinate\n\t\tstate2[blank_row][blank_column] = state2[blank_row1][blank_column1]\n\t\tstate2[blank_row1][blank_column1] = 0\n\t\tvar h1 int\n\t\t//check the blank whether close the aim coordinate\n\t\tif direction == DOWN && blank_row1> targetPoints[state[blank_row1][blank_column1]][0] {\n\t\t\th1 = h - 1\n\t\t} else if direction == UP && blank_row1< targetPoints[state[blank_row1][blank_column1]][0] {\n\t\t\th1 = h - 1\n\t\t} else if direction == RIGHT && blank_column1> targetPoints[state[blank_row1][blank_column1]][1] {\n\t\t\th1 = h - 1\n\t\t} else if direction == LEFT && blank_column1< targetPoints[state[blank_row1][blank_column1]][1] {\n\t\t\th1 = h - 1\n\t\t} else {\n\t\t\t//bad situation make the step bigger.\n\t\t\th1 = h + 1\n\t\t}\n\t\tif h1+dep+1>ans { //pruning\n\t\t\tcontinue\n\t\t}\n\t\tmovesHistory[dep] = direction\n\n\t\tif solve(state2, blank_row1, blank_column1, dep+1, direction, h1) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\nfunc move(state [][]int,direction int)  {\n\trow := 0\n\tcolumn := 0\n\tfor i:=0;i<len(state);i++ {\n\t\tfor j:=0;j<len(state);j++ {\n\t\t\tif state[i][j] == 0 {\n\t\t\t\trow = i\n\t\t\t\tcolumn = j\n\t\t\t}\n\t\t}\n\t}\n\tswitch direction {\n\tcase UP:\n\t\tstate[row][column] = state[row-1][column]\n\t\tstate[row-1][column] = 0\n\t\tbreak\n\tcase DOWN:\n\t\tstate[row][column] = state[row+1][column]\n\t\tstate[row+1][column] = 0\n\t\tbreak\n\tcase LEFT:\n\t\tstate[row][column] = state[row][column-1]\n\t\tstate[row][column-1] = 0\n\t\tbreak\n\tcase RIGHT:\n\t\tstate[row][column] = state[row][column+1]\n\t\tstate[row][column+1] = 0\n\t\tbreak\n\t}\n\tSTEP_SUM++\n}\n"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2, n_limit) = (3, 9, 31)\n\nlet area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet goal = Array.init n2 (fun i -> (i + 1) mod n2)\n\nlet md = Array.make_matrix n2 n2 0\n\nlet initialize_md () =\n  for i = 0 to n2 - 2 do\n    for j = 0 to n2 - 1 do\n      md.(i+1).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet idastar a limit space lower =\n  let rec doit i space moved lower =\n    if i = limit then\n      if a <> goal then ()\n      else begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\";\n        exit 0;\n      end\n    else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - md.(x).(j) + md.(x).(space) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space) <- 0;\n        end) area.(space) in\n  doit 0 space [-1] lower\n\nlet findi a x =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then assert false\n    else if a.(i) = x then i\n    else doit (i + 1) in\n  doit 0\n\nlet () =\n  initialize_md ();\n  let a = Array.init n2 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let space = findi a 0 in\n  let lower =\n    Array.fold_left (fun (i, sum) e -> (i + 1, sum + md.(e).(i))) (0, 0) a |> snd in\n  for limit = lower to n_limit do\n    idastar a limit space lower\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { tbl : int array; space : int; md : int }\n\nlet dfs puzzle limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let (sx, sy) = (pzl.space / n1, pzl.space mod n1) in\n      let { tbl; md } = pzl in\n      let swap tbl i j = let t = tbl.(i) in tbl.(i) <- tbl.(j); tbl.(j) <- t in\n      let rec move r =\n        if r = 4 then false\n        else\n          let (tx, ty) = (sx + dx.(r), sy + dy.(r)) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let (space, num) = (tx * n1 + ty, sx * n1 + sy) in\n            let md = md - mdt.(space).(tbl.(space) - 1) in\n            let md = md + mdt.(num).(tbl.(space) - 1) in\n            let tbl = Array.copy tbl in\n            swap tbl space num;\n            if doit (depth + 1) r { tbl; space; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end in\n      move 0\n    end in\n  doit 0 (-n_limit) puzzle\n\nlet idastar tbl space =\n  let (_, md) =\n    Array.fold_left (fun (i, sum) e ->\n      (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n      (0, 0) tbl in\n  let pzl = { tbl; space; md } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done;\n  let tbl = Array.make n2 0 in\n  let rec doit i space =\n    if i = n2 then space\n    else begin\n      let x = Scanf.scanf \"%d \" (fun i -> i) in\n      let (x, space) = if x = 0 then (n2, i) else (x, space) in\n      tbl.(i) <- x;\n      doit (i + 1) space\n    end in\n  doit 0 0 |> idastar tbl |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n(* let (n1, n2) = (4, 16) *)\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { tbl : int array; space : int; md : int }\n\nlet dfs puzzle limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let rec move r =\n        if r = 4 then false\n        else\n          let (sx, sy) = (pzl.space / n1, pzl.space mod n1) in\n          let (tx, ty) = (sx + dx.(r), sy + dy.(r)) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { tbl; space; md } = pzl in\n            let (space, num) = (tx * n1 + ty, sx * n1 + sy) in\n            let md = md - mdt.(space).(tbl.(space)-1) in\n            let md = md + mdt.(num).(tbl.(space)-1) in\n            let tbl = Array.copy tbl in\n            let t = tbl.(space) in\n            tbl.(space) <- tbl.(num);\n            tbl.(num) <- t;\n            if doit (depth + 1) r { tbl; space; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end in\n      move 0\n    end in\n  doit 0 (-n_limit) puzzle\n\nlet idastar tbl space =\n  let (_, md) =\n    Array.fold_left (fun (i, sum) e ->\n      (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n      (0, 0) tbl in\n  let pzl = { tbl; space; md } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done;\n  let tbl = Array.make n2 0 in\n  let rec doit i space =\n    if i = n2 then space\n    else begin\n      let x = Scanf.scanf \"%d \" (fun i -> i) in\n      let (x, space) = if x = 0 then (n2, i) else (x, space) in\n      tbl.(i) <- x;\n      doit (i + 1) space\n    end in\n  doit 0 0 |> idastar tbl |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet m_d =\n  [| [|0; 0; 0; 0; 0; 0; 0; 0; 0|]\n   ; [|0; 1; 2; 1; 2; 3; 2; 3; 4|]\n   ; [|1; 0; 1; 2; 1; 2; 3; 2; 3|]\n   ; [|2; 1; 0; 3; 2; 1; 4; 3; 2|]\n   ; [|1; 2; 3; 0; 1; 2; 1; 2; 3|]\n   ; [|2; 1; 2; 1; 0; 1; 2; 1; 2|]\n   ; [|3; 2; 1; 2; 1; 0; 3; 2; 1|]\n   ; [|2; 3; 4; 1; 2; 3; 0; 1; 2|]\n   ; [|3; 2; 3; 2; 1; 2; 1; 0; 1|] |]\n\nlet idastar a limit space_i lower goal =\n  let moved = [-1] in\n  let rec doit i space_i moved lower =\n    if i = limit then begin\n      if a = goal then begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\"; exit 0\n      end;\n    end else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - m_d.(x).(j) + m_d.(x).(space_i) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space_i) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space_i) <- 0;\n        end) area.(space_i) in\n  doit 0 space_i moved lower\n\nlet () =\n  let a = Array.init 9 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let rec f i =\n    if i = 9 then assert false\n    else if a.(i) = 0 then i\n    else f (i + 1) in\n  let space_i = f 0 in\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  let rec g i acc =\n    if i = 9 then acc\n    else g (i + 1) (acc + m_d.(a.(i)).(i)) in\n  let lower = g 0 0 in\n  for limit = lower to 31 do\n    idastar a limit space_i lower goal;\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2, n_limit) = (3, 9, 31)\n\nlet goal = Array.init n2 (fun i -> (i + 1) mod n2)\n\nlet area = Array.make n2 []\n\nlet md = Array.make_matrix n2 n2 0\n\nlet initialize_area () =\n  for i = 0 to n2 - 1 do\n    let lst = [] in\n    let lst = if i + n1 < n2 then (i + n1) :: lst else lst in\n    let lst = if (i + 1) mod n1 <> 0 then (i + 1) :: lst else lst in\n    let lst = if i - 1 >= 0 && (i - 1) mod n1 <> n1 - 1 then (i - 1) :: lst else lst in\n    let lst = if i - n1 >= 0 then (i - n1) :: lst else lst in\n    area.(i) <- lst;\n  done\n\nlet initialize_md () =\n  for i = 0 to n2 - 2 do\n    for j = 0 to n2 - 1 do\n      md.(i+1).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet idastar a limit space lower =\n  let rec doit i space moved lower =\n    if i = limit then\n      if a <> goal then ()\n      else begin\n        Printf.printf \"%d\\n\" limit;\n        exit 0;\n      end\n    else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = moved then ()\n        else\n          let lower = lower - md.(x).(j) + md.(x).(space) in\n          if lower + i > limit then ()\n          else begin\n            a.(j) <- 0;\n            a.(space) <- x;\n            doit (i + 1) j x lower;\n            a.(j) <- x;\n            a.(space) <- 0;\n          end)\n      area.(space) in\n  doit 0 space (-1) lower\n\nlet findi a x =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then assert false\n    else if a.(i) = x then i\n    else doit (i + 1) in\n  doit 0\n\nlet () =\n  initialize_area ();\n  initialize_md ();\n  let a = Array.init n2 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let space = findi a 0 in\n  let lower =\n    Array.fold_left (fun (i, sum) e -> (i + 1, sum + md.(e).(i))) (0, 0) a |> snd in\n  for limit = lower to n_limit do\n    idastar a limit space lower\n  done"
  },
  {
    "language": "OCaml",
    "code": "let area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet md = Array.make_matrix 9 9 0\n\nlet initialize_md () =\n  for i = 0 to 7 do\n    for j = 0 to 8 do\n      md.(i+1).(j) <- abs (i / 3 - j / 3) + abs (i mod 3 - j mod 3)\n    done\n  done\n\nlet idastar a limit space_i lower goal =\n  let rec doit i space_i moved lower =\n    if i = limit then begin\n      if a = goal then begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\"; exit 0\n      end;\n    end else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - md.(x).(j) + md.(x).(space_i) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space_i) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space_i) <- 0;\n        end) area.(space_i) in\n  doit 0 space_i [-1] lower\n\nlet () =\n  initialize_md ();\n  let a = Array.init 9 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let rec f i =\n    if i = 9 then assert false\n    else if a.(i) = 0 then i\n    else f (i + 1) in\n  let space_i = f 0 in\n  let rec g i acc =\n    if i = 9 then acc\n    else g (i + 1) (acc + md.(a.(i)).(i)) in\n  let lower = g 0 0 in\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  for limit = lower to 31 do\n    idastar a limit space_i lower goal;\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\n\ntype puzzle = { tbl : int array; space : int; md : int }\n\nlet dfs puzzle limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let (sx, sy) = (pzl.space / n1, pzl.space mod n1) in\n      let { tbl; md } = pzl in\n      let swap tbl i j = let t = tbl.(i) in tbl.(i) <- tbl.(j); tbl.(j) <- t in\n      let rec move r =\n        if r = 4 then false\n        else\n          let (tx, ty) = (sx + dx.(r), sy + dy.(r)) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let (space, num) = (tx * n1 + ty, sx * n1 + sy) in\n            let md = md - mdt.(space).(tbl.(space) - 1) in\n            let md = md + mdt.(num).(tbl.(space) - 1) in\n            let tbl = Array.copy tbl in\n            swap tbl space num;\n            if doit (depth + 1) r { tbl; space; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end in\n      move 0\n    end in\n  doit 0 (-n_limit) puzzle\n\nlet idastar tbl space =\n  let (_, md) =\n    Array.fold_left (fun (i, sum) e ->\n      (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n      (0, 0) tbl in\n  let pzl = { tbl; space; md } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then limit\n    else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done;\n  let tbl = Array.make n2 0 in\n  let rec doit i space =\n    if i = n2 then space\n    else begin\n      let x = Scanf.scanf \"%d \" (fun i -> i) in\n      let (x, space) = if x = 0 then (n2, i) else (x, space) in\n      tbl.(i) <- x;\n      doit (i + 1) space\n    end in\n  doit 0 0 |> idastar tbl |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let area =\n  [| [1; 3]\n   ; [0; 2; 4]\n   ; [1; 5]\n   ; [0; 4; 6]\n   ; [1; 3; 5; 7]\n   ; [2; 4; 8]\n   ; [3; 7]\n   ; [4; 6; 8]\n   ; [5; 7] |]\n\nlet m_d =\n  [| [|0; 0; 0; 0; 0; 0; 0; 0; 0|]\n   ; [|0; 1; 2; 1; 2; 3; 2; 3; 4|]\n   ; [|1; 0; 1; 2; 1; 2; 3; 2; 3|]\n   ; [|2; 1; 0; 3; 2; 1; 4; 3; 2|]\n   ; [|1; 2; 3; 0; 1; 2; 1; 2; 3|]\n   ; [|2; 1; 2; 1; 0; 1; 2; 1; 2|]\n   ; [|3; 2; 1; 2; 1; 0; 3; 2; 1|]\n   ; [|2; 3; 4; 1; 2; 3; 0; 1; 2|]\n   ; [|3; 2; 3; 2; 1; 2; 1; 0; 1|] |]\n\nlet h a =\n  let rec doit i acc =\n    if i = 9 then acc\n    else doit (i + 1) (acc + m_d.(a.(i)).(i))\n  in doit 0 0\n\nlet idx_by_val x a =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then raise Not_found\n    else if x = a.(i) then i\n    else doit (i + 1)\n  in doit 0\n\nlet solve a =\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  let rec idastar i limit space_i moved lower =\n    if i = limit then begin\n      if a = goal then (Printf.printf \"%d\\n\" (List.length moved - 1); exit 0)\n    end else\n      let move j =\n        let x = a.(j) in\n        if x <> List.hd moved then\n          let new_lower = lower - m_d.(x).(j) + m_d.(x).(space_i) in\n          if new_lower + i <= limit then begin\n            a.(j) <- 0;\n            a.(space_i) <- x;\n            idastar (i + 1) limit j (x :: moved) new_lower;\n            a.(j) <- x;\n            a.(space_i) <- 0;\n          end in\n      List.iter move area.(space_i)\n  in\n  let lower = h a in\n  let rec doit limit =\n    if limit < 32 then begin\n      idastar 0 limit (idx_by_val 0 a) [-1] lower;\n      doit (limit + 1)\n    end in\n  doit lower\n\nlet () =\n  solve (Array.init 9 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)))"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2, n_limit) = (3, 9, 31)\n\nlet area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet md = Array.make_matrix n2 n2 0\n\nlet initialize_md () =\n  for i = 0 to n2 - 2 do\n    for j = 0 to n2 - 1 do\n      md.(i+1).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet idastar a limit space_i lower goal =\n  let rec doit i space_i moved lower =\n    if i = limit then begin\n      if a = goal then begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\";\n        exit 0;\n      end\n    end else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - md.(x).(j) + md.(x).(space_i) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space_i) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space_i) <- 0;\n        end) area.(space_i) in\n  doit 0 space_i [-1] lower\n\nlet () =\n  initialize_md ();\n  let a = Array.init n2 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let rec f i =\n    if i = n2 then assert false\n    else if a.(i) = 0 then i\n    else f (i + 1) in\n  let space_i = f 0 in\n  let rec g i acc =\n    if i = n2 then acc\n    else g (i + 1) (acc + md.(a.(i)).(i)) in\n  let lower = g 0 0 in\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  for limit = lower to n_limit do\n    idastar a limit space_i lower goal\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { f : int array; space : int; md : int }\n\nlet initialize_mdt () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet get_all_md f =\n  Array.fold_left (fun (i, sum) e ->\n    (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n    (0, 0) f\n  |> snd\n\nlet dfs pzl limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let sx = pzl.space / n1 in\n      let sy = pzl.space mod n1 in\n      let rec move r =\n        if r = 4 then false\n        else begin\n          let tx = sx + dx.(r) in\n          let ty = sy + dy.(r) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { f; space; md } = pzl in\n            let a = tx*n1 + ty in\n            let b = sx*n1 + sy in\n            let md = md - mdt.(a).(f.(a) - 1) in\n            let md = md + mdt.(b).(f.(a) - 1) in\n            let newf = Array.copy f in\n            let t = newf.(a) in\n            newf.(a) <- newf.(b);\n            newf.(b) <- t;\n            if doit (depth + 1) r { f = newf; space = a; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end\n        end in\n      move 0\n    end in\n  doit 0 (-n_limit) pzl\n\nlet idastar f space =\n  let pzl = { f; space; md = get_all_md f } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  initialize_mdt ();\n  let f = Array.make n2 0 in\n  let space = ref 0 in\n  for i = 0 to n2 - 1 do\n    f.(i) <- Scanf.scanf \"%d \" (fun i -> i);\n    if f.(i) = 0 then begin\n      f.(i) <- n2;\n      space := i;\n    end\n  done;\n  idastar f !space |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "open Printf\nopen Scanf\n\nlet id x = x\n\ntype state = {mv : int; sp : int; bd : int array}\n\nlet () =\n  let goal = [|1;2;3;4;5;6;7;8;0|] in\n  let isp = ref 0 in\n  let bd = Array.init 9 (fun i -> let v = scanf \"%d \" id in if v = 0 then isp := i; v) in\n  let que = Queue.create () in\n  let ht = Hashtbl.create 100 in\n  let rec loop () =\n    if Queue.is_empty que then failwith \"8 puzzle\"\n    else\n      let st = Queue.pop que in\n      if st.bd = goal then st.mv\n      else begin\n          List.iter (fun (dx, dy) ->\n                     let x, y = (st.sp/3, st.sp mod 3) in\n                     let nx, ny = (dx + x, dy + y) in\n                     if 0 <= nx && nx <= 2 && 0 <= ny && ny <= 2 then\n                       let nsp = 3 * nx + ny in\n                       let nbd = Array.copy st.bd in\n                       begin\n                         nbd.(st.sp) <- st.bd.(nsp);\n                         nbd.(nsp) <- 0;\n                         if Hashtbl.mem ht nbd then ()\n                         else\n                           let nst = {mv = st.mv + 1; sp = nsp; bd = nbd} in Queue.push nst que;\n                                                                             Hashtbl.add ht nbd true\n                       end\n                    ) [(1,0);(0,1);(-1,0);(0,-1)];\n          loop ()\n        end                  \n  in\n  Queue.push {mv = 0; sp = !isp; bd = bd} que;\n  Hashtbl.add ht bd true;\n  loop () |> printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { f : int array; space : int; md : int }\n\nlet initialize_mdt () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet get_all_md f =\n  Array.fold_left (fun (i, sum) e ->\n    (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n    (0, 0) f\n  |> snd\n\nlet dfs pzl limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let sx = pzl.space / n1 in\n      let sy = pzl.space mod n1 in\n      let rec move r =\n        if r = 4 then false\n        else begin\n          let tx = sx + dx.(r) in\n          let ty = sy + dy.(r) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { f; space; md } = pzl in\n            let a = tx*n1 + ty in\n            let b = sx*n1 + sy in\n            let md = md - mdt.(a).(f.(a) - 1) in\n            let md = md + mdt.(b).(f.(a) - 1) in\n            let t = f.(a) in\n            f.(a) <- f.(b);\n            f.(b) <- t;\n            if doit (depth + 1) r { f; space = a; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end\n        end in\n      move 0\n    end in\n  doit 0 (-n_limit) pzl\n\nlet idastar f space =\n  let pzl = { f; space; md = get_all_md f } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  initialize_mdt ();\n  let f = Array.make n2 0 in\n  let space = ref 0 in\n  for i = 0 to n2 - 1 do\n    f.(i) <- Scanf.scanf \"%d \" (fun i -> i);\n    if f.(i) = 0 then begin\n      f.(i) <- n2;\n      space := i;\n    end\n  done;\n  idastar f !space |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n(* let (n1, n2) = (4, 16) *)\n\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { f : int array; space : int; md : int }\n\nlet initialize_mdt () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet get_all_md f =\n  Array.fold_left (fun (i, sum) e ->\n    (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n    (0, 0) f\n  |> snd\n\nlet dfs pzl limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let sx = pzl.space / n1 in\n      let sy = pzl.space mod n1 in\n      let rec move r =\n        if r = 4 then false\n        else begin\n          let tx = sx + dx.(r) in\n          let ty = sy + dy.(r) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { f; space; md } = pzl in\n            let a = tx*n1 + ty in\n            let b = sx*n1 + sy in\n            let md = md - mdt.(a).(f.(a) - 1) in\n            let md = md + mdt.(b).(f.(a) - 1) in\n            let newf = Array.init n2 (fun i -> f.(i)) in\n            let t = newf.(a) in\n            newf.(a) <- newf.(b);\n            newf.(b) <- t;\n            if doit (depth + 1) r { f = newf; space = a; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end\n        end in\n      move 0\n    end in\n  doit 0 (-n_limit) pzl\n\nlet idastar f space =\n  let pzl = { f; space; md = get_all_md f } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  initialize_mdt ();\n  let f = Array.make n2 0 in\n  let space = ref 0 in\n  for i = 0 to n2 - 1 do\n    f.(i) <- Scanf.scanf \"%d \" (fun i -> i);\n    if f.(i) = 0 then begin\n      f.(i) <- n2;\n      space := i;\n    end\n  done;\n  idastar f !space |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\nimport std.string;\nimport std.typecons;\nimport std.math;\nimport std.random;\nimport std.range;\nimport std.functional;\nimport std.container;\nstruct Puzzle\n{\n    int[9] panel;\n    size_t toHash() const @safe pure nothrow\n    {\n        size_t hash = 0;\n        foreach (i; panel)\n        {\n            hash *= 10;\n            hash += i;\n        }\n        return hash;\n    }\n    bool opEquals(ref const Puzzle s) const @safe pure nothrow\n    {\n        return equal(panel[0..$], s.panel[0..$]);\n    }\n    int c;\n}\nint[] dx = [-1, 0, 1, 0];\nint[] dy = [0, -1, 0, 1];\nvoid main()\n{\n    bool[Puzzle] set;\n    auto queue = DList!Puzzle();\n    Puzzle initial;\n    foreach (i; 0..9)\n    {\n        scanf(\"%d\", &initial.panel[i]);\n    }\n    set[initial] = true;\n    queue.insertBack(initial);\n    while (!queue.empty)\n    {\n        auto u = queue.front;\n        queue.removeFront;\n        if (u.panel[0..$].equal([1, 2, 3, 4, 5, 6, 7, 8, 0]))\n        {\n            writeln(u.c);\n            break;\n        }\n        auto sp = u.panel[0..$].countUntil(0);\n        auto sx = sp % 3;\n        auto sy = sp / 3;\n        foreach (r; 0..4)\n        {\n            auto tx = sx + dx[r];\n            auto ty = sy + dy[r];\n            if (tx < 0 || tx >= 3 || ty < 0 || ty >= 3)\n                continue;\n            auto temp = u;\n            temp.panel[sp].swap(temp.panel[tx + ty * 3]);\n            if (temp !in set)\n            {\n                set[temp] = true;\n                temp.c++;\n                queue.insertBack(temp);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.conv, std.range, std.stdio, std.string;\nimport std.container, std.typecons;\n\nconst auto n = 3;\nconst auto bits = 4;\n\nvoid main()\n{\n  auto b = 0UL;\n  foreach (i; 0..n) {\n    auto rd = readln.split.to!(int[]);\n    foreach (j, d; rd)\n      b = b.setDigit(i * n + j, d);\n  }\n\n  auto g = goal;\n\n  auto vi = [b: true];\n  auto qi = new DList!bl(bl(b, 0));\n  while (!qi.empty) {\n    auto q = qi.front; qi.removeFront;\n    if (q.b == g) {\n      writeln(q.l);\n      break;\n    }\n      \n    auto i = q.b.findZero;\n\n    void insertQueue(bl q, size_t j)\n    {\n      auto c = q.b.swapDigit(i, j);\n      if (c !in vi) {\n        qi.insertBack(bl(c, q.l + 1));\n        vi[c] = true;\n      }\n    }\n\n    if (i / n > 0)     insertQueue(q, i - n);\n    if (i / n < n - 1) insertQueue(q, i + n);\n    if (i % n > 0)     insertQueue(q, i - 1);\n    if (i % n < n - 1) insertQueue(q, i + 1);\n  }\n}\n\nalias Tuple!(ulong, \"b\", int, \"l\") bl;\n\nulong goal()\n{\n  auto r = 0UL;\n  foreach (i; 0..n*n-1)\n    r = r.setDigit(i, i + 1);\n  return r;\n}\n\nulong setDigit(ulong b, size_t i, int val)\n{\n  return b & (~(((1UL << bits) - 1) << i * bits)) | (val.to!ulong << i * bits);\n}\n\nint digit(ulong b, size_t i)\n{\n  return (b >> i * bits) & ((1UL << bits) - 1);\n}\n\nulong swapDigit(ulong b, size_t i, size_t j)\n{\n  auto x = b.digit(i), y = b.digit(j);\n  return b.setDigit(i, y).setDigit(j, x);\n}\n\nptrdiff_t findZero(ulong b)\n{\n  foreach (i; 0..n*n)\n    if (b.digit(i) == 0)\n      return i;\n  return -1;\n}"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n\n            if not hash_code in closed:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2]+x[3])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+c_dWithH) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nN = 3\nM = []\nfor i in range(N):\n    M.append(list(map(int, input().split())))\n\nA = (1, 2, 3, 4, 5, 6, 7, 8, 0)\ndef h(M):\n    c = 0\n    it = iter(A).__next__\n    for i in range(N):\n        for v in M[i]:\n            if v != it():\n                c += 1\n    return c\ndef f(M):\n    M0 = []\n    for m in M:\n        M0.extend(m)\n    return tuple(M0)\n\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\nci = cj = -1\nfor i in range(N):\n    for j in range(N):\n        if M[i][j] == 0:\n            ci = i; cj = j\nque = [(h(M), 0, ci, cj, M)]\nU = set(f(M))\nwhile que:\n    hc, c, cr, cc, M = heappop(que)\n    if hc == c:\n        print(c)\n        break\n    for dr, dc in dd:\n        nr = cr+dr; nc = cc+dc\n        if not 0 <= nr < N or not 0 <= nc < N:\n            continue\n        MM = [m[:] for m in M]\n        MM[cr][cc] = MM[nr][nc]\n        MM[nr][nc] = 0\n        s = f(MM)\n        if s in U:\n            continue\n\n        U.add(s)\n        heappush(que, (h(MM)+c+1, c+1, nr, nc, MM))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n#coding:utf-8\n\ndef _downheap(buff, n):\n\tsize = len(buff)\n\twhile True:\n\t\tc = 2 * n + 1\n\t\tif c >= size: break\n\t\tif c + 1 < size:\n\t\t\tif buff[c] > buff[c + 1]: c += 1\n\t\tif buff[n] <= buff[c]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[c]\n\t\tbuff[c] = temp\n\t\tn = c\n\n# ???????????????\ndef _upheap(buff, n):\n\twhile True:\n\t\tp = (n - 1) / 2\n\t\tif p < 0 or buff[p] <= buff[n]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[p]\n\t\tbuff[p] = temp\n\t\tn = p\n\nclass PQueue:\n\tdef __init__(self, buff = []):\n\t\tself.buff = buff[:]   # ?????????\n\t\tfor n in xrange(len(self.buff) / 2 - 1, -1, -1):\n\t\t\t_downheap(self.buff, n)\n\n\t# ??????????????????\n\tdef push(self, data):\n\t\tself.buff.append(data)\n\t\t_upheap(self.buff, len(self.buff) - 1)\n\n\t# ????Â°???????????????????\n\tdef pop(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\tvalue = self.buff[0]\n\t\tlast = self.buff.pop()\n\t\tif len(self.buff) > 0:\n\t\t\t# ????????????????Â§????\n\t\t\tself.buff[0] = last\n\t\t\t_downheap(self.buff, 0)\n\t\treturn value\n\n\t# ????Â°????????Â±???????\n\tdef peek(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\treturn self.buff[0]\n\n\t# ??????\n\tdef isEmpty(self): return len(self.buff) == 0\n\n\nimport time\n\n# ??Â£??\\?????????\nadjacent = (\n\t(1, 3),\t   # 0\n\t(0, 2, 4),\t# 1\n\t(1, 5),\t   # 2\n\t(0, 4, 6),\t# 3\n\t(1, 3, 5, 7), # 4\n\t(2, 4, 8),\t# 5\n\t(3, 7),\t   # 6\n\t(4, 6, 8),\t# 7\n\t(5, 7)\t\t# 8\n)\n\n# ?????Â°\nOPEN = 0\nCLOSE = 1\nFORE = 0\nBACK = 1\n\n# ?????Â¢??Â¨?????????\ndef make_distance_table(board, wide):\n\tsize = len(board)\n\ttable = [[0] * size for _ in xrange(size)]\n\tfor i in xrange(size):\n\t\tp = board[i]\n\t\tif p == 0: continue\n\t\tx1 = i / wide\n\t\ty1 = i % wide\n\t\tfor j in xrange(size):\n\t\t\tx2 = j / wide\n\t\t\ty2 = j % wide\n\t\t\ttable[p][j] += max(x1 - x2, x2 - x1)\n\t\t\ttable[p][j] += max(y1 - y2, y2 - y1)\n\treturn table\n\n# ?????Â¢????Â±???????\ndef get_distance(board, distance):\n\tv = 0\n\tfor x in xrange(9):\n\t\tp = board[x]\n\t\tif p == 0: continue\n\t\tv += distance[p][x]\n\treturn v\n\n# ?Â±???Â¢?????????\nclass State:\n\tdef __init__(self, board, space, prev, move, dir, kind = OPEN):\n\t\tself.board = board\n\t\tself.space = space\n\t\tself.prev = prev\n\t\tself.move = move\n\t\tself.dir = dir\n\t\tself.kind = kind\n\t\tif dir == FORE:\n\t\t\tdt = start_distance\n\t\telse:\n\t\t\tdt = goal_distance\n\t\tif prev is None:\n\t\t\tself.cost = move + get_distance(board, dt)\n\t\telse:\n\t\t\tp = board[prev.space]\n\t\t\tself.cost = prev.cost + 1 - dt[p][space] + dt[p][prev.space]\n\n\tdef __cmp__(x, y):\n\t\treturn x.cost - y.cost\n\n# ???????????? A* ??Â¢?????Â´?????????\ndef a_star_search(start, goal):\n\tglobal start_distance, goal_distance\n\tq = PQueue()\n\ttable ={}\n\t# ?????????????????????\n\tstart_distance = make_distance_table(goal, 3)\n\ta = State(start, start.index(0), None, 0, FORE)\n\tq.push(a)\n\ttable[tuple(start)] = a\n\t# ??Â´???????????????\n\tgoal_distance = make_distance_table(start, 3)\n\ta = State(goal, goal.index(0), None, 0, BACK)\n\tq.push(a)\n\ttable[tuple(goal)] = a\n\twhile not q.isEmpty():\n\t\ta = q.pop()\n\t\tif a.kind == CLOSE: continue   # ????Â£????????????Â§??????\n\t\tfor x in adjacent[a.space]:\n\t\t\tb = a.board[:]\n\t\t\tb[a.space] = b[x]\n\t\t\tb[x] = 0\n\t\t\tkey = tuple(b)\n\t\t\tif key in table:\n\t\t\t\t# ???????Â±???Â¢?????????\n\t\t\t\tc = table[key]\n\t\t\t\tif a.dir != c.dir:\n\t\t\t\t\t# ??????\n\t\t\t\t\tif a.dir == FORE:\n\t\t\t\t\t\tprint print_answer(a)+print_answer_goal(c)-1\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint print_answer(c)+print_answer_goal(a)-1\n\t\t\t\t\treturn\n\t\t\t\t# ?????Â¢???????????????????????Â°?????????????????Â°??????\n\t\t\t\tif c.move > a.move + 1:\n\t\t\t\t\t# ??Â´??Â°??????\n\t\t\t\t\tif c.kind == OPEN:\n\t\t\t\t\t\tc.kind = CLOSE\n\t\t\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\t\t\ttable[key] = c\n\t\t\t\t\telse:\n\t\t\t\t\t\tc.prev = a\n\t\t\t\t\t\tc.cost = c.cost - c.move + a.move + 1\n\t\t\t\t\t\tc.move = a.move + 1\n\t\t\t\t\t\tc.kind = OPEN\n\t\t\t\t\t# ??????????????????\n\t\t\t\t\tq.push(c)\n\t\t\telse:\n\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\tq.push(c)\n\t\t\t\ttable[key] = c\n\t\t# a ???????????????????Â±??????????\n\t\ta.kind = CLOSE\n\n# ???????????Â¨???\ndef print_answer(x):\n\tif x is not None:\n\t\treturn 1+print_answer(x.prev)\n\t\t#print x.board\n\treturn 0\n\ndef print_answer_goal(x):\n\tr=0\n\twhile x is not None:\n\t\t#print x.board\n\t\tx = x.prev\n\t\tr+=1\n\treturn r\n\n# ??????\ngoal = [1,2,3,4,5,6,7,8,0]\na = []\ntry:\n\twhile True:\n\t\ta+=[int(e) for e in raw_input().split()]\nexcept EOFError:\n\tpass\n\n#s = time.clock()\na_star_search(a, goal)\n#e = time.clock()\n#print \"%.3f\" % (e - s)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nimport copy\n\n\ndef get_completed_board(height, width):\n    return [[str((y * width + x + 1) % (width * height)) for x in range(width)] for y in range(height)]\n\n\ndef serialize_board(board):\n    return \":\".join(list(map(lambda cell: \",\".join(cell), board)))\n\n\ndef get_empty_pos(board):\n    for y, row in enumerate(board):\n        for x, cell in enumerate(row):\n            if cell == \"0\":\n                return (x, y)\n\n\ndef get_all_possible_next_boards(board, height, width, empty_pos=None):\n    if empty_pos is None:\n        empty_pos = get_empty_pos(board)\n    next_boards = []\n    # å·¦ã¨ã®å¥ãæ¿ã\n    if empty_pos[0] > 0:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0] - 1] = \\\n            next_board[empty_pos[1]][empty_pos[0] - 1], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0] - 1, empty_pos[1])))\n    # å³ã¨ã®å¥ãæ¿ã\n    if empty_pos[0] < width - 1:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0] + 1] = \\\n            next_board[empty_pos[1]][empty_pos[0] + 1], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0] + 1, empty_pos[1])))\n    # ä¸ã¨ã®å¥ãæ¿ã\n    if empty_pos[1] > 0:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1] - 1][empty_pos[0]] = \\\n            next_board[empty_pos[1] - 1][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0], empty_pos[1] - 1)))\n    # ä¸ã¨ã®å¥ãæ¿ã\n    if empty_pos[1] < height - 1:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1] + 1][empty_pos[0]] = \\\n            next_board[empty_pos[1] + 1][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0], empty_pos[1] + 1)))\n    return next_boards\n\n\ndef resolve(board, height, width):\n    # æ¢ç¥ã®ç¤é¢ãä¿å­\n    known_serialized_boards = set([])\n    # æ­£è§£ã®ç¤é¢ãä¿å­\n    completed_serialized_board = serialize_board(get_completed_board(width, height))\n    step_count = 0\n    current_boards = [(board, None)]\n    while step_count <= 45:\n        next_boards = []\n        for board, empty_pos in current_boards:\n            serialized_board = serialize_board(board)\n            # æ­£ç­ããã£ãå ´åã¯ã¹ãããæ°ãè¿ãã¦çµäº\n            if serialized_board == completed_serialized_board:\n                return step_count\n            # æ¢ç¥ã®ç¤é¢ã¯å¾ç¶ã®å¦çå¯¾è±¡ã¨ããªã\n            if serialized_board in known_serialized_boards:\n                continue\n            else:\n                known_serialized_boards.add(serialized_board)\n            # æ¬¡ã®ã¹ãããã§ã®ç¾ãå¾ãå±é¢ãå¨ã¦åå¾\n            next_boards.extend(get_all_possible_next_boards(board, height, width, empty_pos))\n        current_boards = next_boards\n        step_count = step_count + 1\n        # print((step_count, len(known_serialized_boards), len(current_boards)))\n    return None\n\n\ndef main():\n    inputStr = sys.stdin.read()\n    lines = inputStr.split(\"\\n\")\n    lines = filter(lambda line: line, lines)\n    board = list(map(lambda line: line.split(\" \"), lines))\n    height = len(board)\n    width = len(board[0])\n    step_count = resolve(board, height, width)\n    print(step_count)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": " \ngoal = ((1, 2, 3), (4, 5, 6), (7, 8, 0))\n\nparents = {}\ntotal = {}\nflag = True\n\ninitial = []\nposition = []\nfor i in range(3):\n\ta, b, c = map(int, input().split())\n\tif a == 0:\n\t\tposition.extend([i, 0])\n\telif b == 0:\n\t\tposition.extend([i, 1])\n\telif c == 0:\n \t\tposition.extend([i, 2])\n\tinitial.append( (a, b, c) )\n\nparents[tuple(initial)] = position\ntotal[tuple(initial)] = 1\n\ncount = 0\n\nif tuple(initial) == goal:\n\tflag = False\n\nwhile flag:\n\tcount += 1\n\tchildren = {}\n\tfor par_key in parents.keys():\n\t\tposition = parents[par_key]\n\n\t\tif position[0] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]+1][position[1]]\n\t\t\tchild[position[0]+1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]+1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[0] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]-1][position[1]]\n\t\t\tchild[position[0]-1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]-1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]+1]\n\t\t\tchild[position[0]][position[1]+1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]+1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]-1]\n\t\t\tchild[position[0]][position[1]-1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]-1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\tparents = children\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nend_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nqueue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = {}\nvisited[hashnum(ini_state)] = [0, 0]\nvisited[answer] = [0, 1]\ntrial = 0\nended = 0\nwhile queue:\n    new_queue = []\n    trial += 1\n    for q in queue:\n        if ended:\n            break\n        state, zero_x, zero_y, direction = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm in visited and direction != visited[perm][1]:\n                    print(trial + visited[perm][0])\n                    ended = 1\n                    break\n                elif perm not in visited:\n                    visited[perm] = [trial, direction]\n                    new_queue.append([new_state, new_x, new_y, direction])\n    queue = new_queue"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n        \n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\nfrom collections import deque\n\ndef main():\n    s = []\n    for _ in range(3):\n        s += list(map(int,input().split()))\n    goal = [1,2,3,4,5,6,7,8,0]\n    st = set()\n    inf = 1000000007\n    move = [[1,3], #0ãiçªç®ã«ããæã«äº¤æã§ããä½ç½®\n            [0,2,4],\n            [1,5],\n            [0,4,6],\n            [1,3,5,7],\n            [2,4,8],\n            [3,7],\n            [4,6,8],\n            [5,7]]\n\n    def bfs():\n        k = 0\n        for i in range(9):\n            if s[i] == 0: k = i #ç©ºã®ä½ç½®\n        dq = deque()\n        dq.append([s, k, 0]) #å±é¢ã0ã®ä½ç½®ãã¹ãããæ°\n        st.add(''.join(map(str, s)))\n        while dq:\n            state = dq.popleft()\n            t, i, steps = state[0], state[1], state[2]\n            if t == goal: return steps\n            for j in move[i]:\n                u = copy.copy(t)\n                u[i], u[j] = u[j], u[i] #0ãç§»å\n                if ''.join(map(str, u)) in st:continue #åä¸å±é¢ããã£ãã®ã§ã¹ã­ãã\n                dq.append([u, j, steps+1])\n                st.add( ''.join(map(str, u)))\n\n    print (bfs())\n\nif __name__ == '__main__':\n    main()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = tuple(sum([input().split() for _ in range(N)], []))\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = {MAP}\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        yx = y * N + x\n        for ny, nx in ((y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)):\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = list(deepcopy(M))\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                CM = tuple(CM)\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+simpleHS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    if(c_puz[8] == 0):\n        count+=1\n    return count\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(8)]\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\nimport copy\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9: self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        if is_target(u): return u.path\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3: continue\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if not V.get(v, None):\n                V[v] = True\n                v.path += dir[r]\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans = bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nadjacent = (\n    (1, 3),        # 0\n    (0, 2, 4),     # 1\n    (1, 5),        # 2\n    (0, 4, 6),     # 3\n    (1, 3, 5, 7),  # 4\n    (2, 4, 8),     # 5\n    (3, 7),        # 6\n    (4, 6, 8),     # 7\n    (5, 7)         # 8\n)\n\n\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev:\n            continue\n        b = board[:]\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\nfrom heapq import heappop, heappush\n\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# ???????????Â¨????????Â°\nFORE = 1\nBACK = 0\n\n\ndef search(start):\n    table = {}\n\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(end)] = (BACK, 0)\n\n    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]\n    while heap:\n        i, board, space, prev, direction = heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction:\n                    print(table[key][1] + i)\n                    return\n                continue\n            table[key] = (direction, i)\n            if b == end:\n                print(i)\n                return\n            heappush(heap, (i, b, nxt, space, direction))\n\n\ndef main():\n    start = (map(int, readline().split()) for _ in range(3))\n    start = [y for x in start for y in x]\n    search(start)\nmain()"
  },
  {
    "language": "Python",
    "code": "N = 3\n#f = [input().split() for _ in range(3)]\nf = input().split()\nf += input().split()\nf += input().split()\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = [[f, f.index(\"0\"), 0]]\n#T = {f: True}\nT = set(f)\n\nwhile len(Q) > 0:\n    board = Q.pop(0)\n    if board[0] == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"0\"]:\n        break\n    # int//int = int\n    # location of zero\n    x, y = board[1]//N, board[1]%N\n    for dx, dy in dd:\n        tx, ty = x+dx, y+dy\n        # 0ã¨swapå¾boardã®ç¯å²å¤ã«åºããé¤å¤\n        if tx<0 or ty<0 or tx>=N or ty>=N:\n            continue\n        new = board[:]\n        # n1 is location of zero on string\n        # n2 is location of zero after moving on string\n        n1, n2 = board[1], tx*N+ty\n        new[1] = n2\n        # swap\n        if n1 > n2:\n            n1, n2 = n2, n1\n        # swaped string\n        new[0] = new[0][0:n1] + list(new[0][n2]) + new[0][n1+1:n2] + list(new[0][n1]) + new[0][n2+1:]\n        hashstr = \"\".join(new[0])\n        if hashstr not in T:\n        #if new[0] not in T.keys():\n        #if not T.get(new[0], False):\n            #T[new[0]] = True\n            T.add(hashstr)\n            new[2] += 1\n            Q.append(new)\n\nprint(board[2])\n\n"
  },
  {
    "language": "Python",
    "code": "# å¹åªåæ¢ç´¢ #åæ¹åæ¢ç´¢\nimport sys\nimport queue\n\nSPACE = 0\n\nadjacents_list = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef mininum_steps(start, goal):\n    if start == goal:\n        return 0\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    history = [tuple(start)]\n    while not q.empty():\n        state = q.get()\n        for adjacent in adjacents_list[state.space]:\n            board = state.board[:]\n            board[state.space] = board[adjacent]\n            board[adjacent] = SPACE\n            if tuple(board) in history:\n                 continue\n            if board == goal:\n                return go_back(state)\n            history.append(tuple(board))\n            next_state = State(board, adjacent, state)\n            q.put(next_state)\n\nstep = 0\ndef go_back(state):\n    global step\n    if state is not None:\n        step += 1\n        go_back(state.prev)\n    return step\n\n\ninitial_board = list(map(int, sys.stdin.read().split()))\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nprint(mininum_steps(initial_board, goal))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom itertools import chain\nfrom operator import mul\n\nexp10 = [10 ** a for a in range(8, -1, -1)]\nmovables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]\n\ndestination = 123456780\n\n\ndef swap(board, move_from, move_to):\n    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)\n\n\nboard0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))\np0 = ('0' + str(board0))[-9:].index('0')\n\nappeared = ({board0: 0}, {destination: 0})\nqueue = []\nqueue.extend((0, 0, move_from, p0, board0) for move_from in movables[p0])\nqueue.extend((0, 1, move_from, 8, destination) for move_from in movables[8])\nheapq.heapify(queue)\n\nwhile True:\n    total_cost, direction, move_from, move_to, board = heapq.heappop(queue)\n    if board in appeared[not direction]:\n        print(total_cost + appeared[not direction][board])\n        break\n    new_board = swap(board, move_from, move_to)\n    if new_board in appeared[direction]:\n        continue\n    appeared[direction][new_board] = total_cost + 1\n    for move_from2 in movables[move_from]:\n        if move_from2 != move_to:\n            heapq.heappush(queue, (total_cost + 1, direction, move_from2, move_from, new_board))"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n\n            if not hash_code in closed:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2]+x[3])\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\nadjacent=((1,3), (0,2,4), (1,5), (0,4,6), (1,3,5,7), (2,4,8), (3,7), (4,6,8), (5,7))\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef bf_search(start, GOAL):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    table = {}\n    table[tuple(start)] = True\n    while not q.empty():\n        a = q.get()\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n            key = tuple(b)\n            if key in table: continue\n            c = State(b,x,a)\n            if b == GOAL:\n                return print_answer(c)\n            q.put(c)\n            table[key] = True\n\ncnt = -1\ndef print_answer(x):\n    global cnt\n    if x is not None:\n        cnt += 1\n        print_answer(x.prev)\n    return str(cnt)\n\nGOAL = [1,2,3,4,5,6,7,8,0]\nstart = []\nfor i in range(3):\n x,y,z = map(int, input().split())\n start += [x,y,z]\n\nprint(bf_search(start, GOAL))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\ngenerated_state = {init: 0}\n\ndef bfs(root):\n    s = 0\n    configure = [root]\n    while '123456780' not in configure:\n        q = iter(configure)\n        configure = []\n        s += 1\n        for c in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if '123456780' in generated_state:\n                break\n    print(s)\n\nbfs(init)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) > depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush\n\n\nadjacent = (\n    (1, 3),        # ä½ç½® 0 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (0, 2, 4),     # ä½ç½® 1 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (1, 5),        # ä½ç½® 2 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (0, 4, 6),     # ä½ç½® 3 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (1, 3, 5, 7),  # ä½ç½® 4 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (2, 4, 8),     # ä½ç½® 5 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (3, 7),        # ä½ç½® 6 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (4, 6, 8),     # ä½ç½® 7 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n    (5, 7)         # ä½ç½® 8 ã« 0ãå­å¨ããã¨ãã«å¥ãæ¿ãå¯è½ãªä½ç½®\n)\n\n\ndef move(board, space, prev_space):\n    for next_space in adjacent[space]:\n        if next_space == prev_space:\n            continue\n        next_board = board[:]\n        next_board[space], next_board[next_space] = next_board[next_space], 0\n        yield next_board, next_space\n\n\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ndiscovered_state = set()  # ãã§ã«ç¥ã£ã¦ããç¶æãè¨é²ãã\n\n\ndef search(start):\n    discovered_state.add(tuple(start))\n    heap = [(0, start, start.index(0), None)]  # ä»ã®ç¶æã¸å°éããæé åæ°\n\n    while heap:\n        i, board, space, prev = heappop(heap)\n\n        if board == end:\n            return i\n\n        i += 1\n        for next_board, next_space in move(board, space, prev):\n            if tuple(next_board) in discovered_state:\n                continue\n            discovered_state.add(tuple(next_board))\n            heappush(heap, (i, next_board, next_space, space))\n\n\ndef main():\n    start = []\n    for _ in range(3):\n        start.extend(list(map(int, sys.stdin.readline().strip().split())))\n    ans = search(start)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nCORRECT_STATE = \"123456780\"\n\n\nclass PuzzleState:\n    __slots__ = ['state', 'spc_x', 'spc_y', 'depth']\n\n    def __init__(self, state: str, depth=0):\n        self.state = state\n        index = state.find('0')\n        self.spc_x = index % 3\n        self.spc_y = index // 3\n        self.depth = depth\n\n    def swap_state(self, ch_x, ch_y):\n        conv_char = self.state[ch_y * 3 + ch_x]\n        self.state = self.state.replace('0', 'X')\n        self.state = self.state.replace(conv_char, '0')\n        self.state = self.state.replace('X', conv_char)\n        self.spc_x, self.spc_y = ch_x, ch_y\n\n    def is_correct(self):\n        return self.state == CORRECT_STATE\n\n    def __repr__(self):\n        return f'{self.state}'\n\n\nmove = [(0, -1), (0, 1), (-1, 0), (1, 0)]\ndef puzzle8_breadth_first_search(puzzle: PuzzleState):\n    mem_state = {puzzle.state: ''}\n    p_queue = deque()\n    p_queue.append(puzzle)\n\n    while len(p_queue) != 0:\n        u = p_queue.popleft()\n        if u.is_correct():\n            #print(\"CORRECT\")\n            return u.depth\n        for mx, my in move:\n            sp_new_x = u.spc_x + mx\n            sp_new_y = u.spc_y + my\n            if not(0 <= sp_new_x <= 2 and 0 <= sp_new_y <= 2):\n                continue\n            new_puzzle = PuzzleState(u.state, depth=u.depth+1)\n            new_puzzle.swap_state(sp_new_x, sp_new_y)\n\n            if new_puzzle.state not in mem_state:\n                mem_state[new_puzzle.state] = ''\n                p_queue.append(new_puzzle)\n    return False\n\n\ndef main():\n    input_text = \"\"\n    for i in range(3):\n        input_text += \"\".join(input().split())\n\n    # 8 puzzle main\n    ans_puzzle = puzzle8_breadth_first_search(PuzzleState(input_text))\n    print(ans_puzzle)\n    return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((sumCost(costs),0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        cost = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        _costs = items[6]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+cost) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import deque\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN = 3\n# ã°ãªãããæåããæå­åã¨ãã¦1æ¬¡åã§ä¿æãã\ngrid = '*' * (N+2)\nfor i in range(N):\n    grid += '*' + input().replace(' ', '') + '*'\ngrid += '*' * (N+2)\nstart = grid.find('0')\n\n# å®æå½¢ã®ç¤é¢\ngoal = '******123**456**780******'\nque = deque()\nque.append((grid, 0, start))\n# ãã®ç¤é¢ã«è³ãç§»åã³ã¹ã\nmemo = {}\nwhile len(que):\n    grid, cost, cur = que.popleft()\n    if grid in memo:\n        continue\n    memo[grid] = cost\n    grid = list(grid)\n    # 4æ¹åè¦ã\n    for direction in (-1, 1, -(N+2), N+2):\n        nxt = cur + direction\n        if grid[nxt] != '*':\n            grid[cur], grid[nxt] = grid[nxt], grid[cur]\n            que.append((''.join(grid), cost+1, nxt))\n            grid[cur], grid[nxt] = grid[nxt], grid[cur]\n\nprint(memo[goal])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or c_depth > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(8)]\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(swap_puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+c_dWithH) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\nf = lambda x: \"\\n\".join(\" \".join(map(str, x[i])) for i in range(3))\ndef MAIN():\n    MAP = [list(map(int, input().split())) for _ in range(N)]\n    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    ans = 0\n    dp = deque([[0, MAP]])\n    LOG = [MAP]\n    while dp:\n        cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        y, x = divmod(sum(M, []).index(0), N)\n        cnt += 1\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = deepcopy(M)\n                CM[y][x], CM[ny][nx] = CM[ny][nx], CM[y][x]\n                if not CM in LOG:\n                    dp.append([cnt, CM])\n                    LOG.append(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nqueue = [[ini_state, zero_x, zero_y]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = set()\nvisited |= {hashnum(ini_state)}\ntrial = 0\nwhile answer not in visited:\n    new_queue = []\n    trial += 1\n    for q in queue:\n        state, zero_x, zero_y = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm == answer:\n                    print(trial)\n                    exit()\n                if perm not in visited:\n                    visited |= {perm}\n                    new_queue.append([new_state, new_x, new_y])\n    queue = new_queue\n    \n# print(trial)"
  },
  {
    "language": "Python",
    "code": "\nfrom heapq import heappop, heappush\nfrom copy import deepcopy\n\n\nclass Board:\n    def __init__(self, size, nums):\n        self.size = size\n        self.nums = nums\n        self.code = self._code()\n\n    def __eq__(self, other):\n        return self.code == other.code\n\n    def __lt__(self, other):\n        return self.code < other.code\n\n    def __gt__(self, other):\n        return self.code > other.code\n\n    def __hash__(self):\n        nums = tuple(self.nums[i][j]\n                     for i in range(self.size)\n                     for j in range(self.size))\n        hash(nums)\n\n    def same(self, other):\n        if other is None:\n            return False\n        if self.__class__ != other.__class__:\n            return False\n\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != other.nums[i][j]:\n                    return False\n        return True\n\n    def solved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if (i, j) != self._validpos(self.nums[i][j]):\n                    return False\n        return True\n\n    def _validpos(self, num):\n        if num > 0:\n            return ((num-1) // self.size, (num-1) % self.size)\n        else:\n            return (self.size-1, self.size-1)\n\n    def _code(self):\n        code = 0\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != 0:\n                    vi, vj = self._validpos(self.nums[i][j])\n                    code += abs(vi - i) + abs(vj - j)\n        return code\n\n    def find(self, num):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] == num:\n                    return (i, j)\n        raise IndexError()\n\n    def move(self, p1, p2):\n        i1, j1 = p1\n        i2, j2 = p2\n        nums = deepcopy(self.nums)\n        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]\n        return self.__class__(self.size, nums)\n\n    def moves(self):\n        i, j = self.find(0)\n        if i > 0:\n            yield self.move((i, j), (i-1, j))\n        if j > 0:\n            yield self.move((i, j), (i, j-1))\n        if i < self.size-1:\n            yield self.move((i, j), (i+1, j))\n        if j < self.size-1:\n            yield self.move((i, j), (i, j+1))\n\n    def __str__(self):\n        s = ''\n        for i in range(self.size):\n            for j in range(self.size):\n                s += ' {}'.format(self.nums[i][j])\n            s += '\\n'\n        return s\n\n\nclass EightPuzzle:\n    def __init__(self, board):\n        self.board = Board(3, board)\n        self.steps = 0\n\n        if not self.board.solved():\n            self._solve()\n\n    def _solve(self):\n        bs = []\n        heappush(bs, (self.board, 0, None))\n\n        while len(bs) > 0:\n            b, step, pb = heappop(bs)\n            for nb in b.moves():\n                if nb.solved():\n                    self.steps = step+1\n                    return\n                elif nb.same(pb):\n                    continue\n                else:\n                    heappush(bs, (nb, step+1, b))\n\n\ndef run():\n    board = []\n    for i in range(3):\n        board.append([int(i) for i in input().split()])\n\n    eight_puzzle = EightPuzzle(board)\n    print(eight_puzzle.steps)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj)\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = tuple(sum([input().split() for _ in range(N)], []))\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = {MAP}\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        cnt += 1\n        yx = y * N + x\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = list(deepcopy(M))\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                CM = tuple(CM)\n                if not CM in LOG:\n                    if CM == goal:\n                        print(cnt)\n                        dp = []\n                        break\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return pzl.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\nprint(b_start.node, b_start.f)\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nadjacent = (\n    (1, 3),        # 0\n    (0, 2, 4),     # 1\n    (1, 5),        # 2\n    (0, 4, 6),     # 3\n    (1, 3, 5, 7),  # 4\n    (2, 4, 8),     # 5\n    (3, 7),        # 6\n    (4, 6, 8),     # 7\n    (5, 7)         # 8\n)\n\n\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev:\n            continue\n        b = board[:]\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\nfrom heapq import heappop, heappush\n\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# ???????????Â¨????????Â°\nFORE = 1\nBACK = 0\n\n\ndef search(start):\n    if start == end:\n        return 0\n    table = {}\n\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(end)] = (BACK, 0)\n\n    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]\n    while heap:\n        i, board, space, prev, direction = heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction:\n                    return table[key][1] + i\n                continue\n            table[key] = (direction, i)\n            if b == end:\n                return i\n            heappush(heap, (i, b, nxt, space, direction))\n\n\ndef main():\n    start = (map(int, readline().split()) for _ in range(3))\n    start = [y for x in start for y in x]\n    print(search(start))\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\nrow = 3\nmaxx = 9\n\n\nclass Puzzle():\n    def __init__(self,f=None,space=None,path=''):\n        self.f=f\n        self.space=space\n        self.path=path\n        \n    def __hash__(self):  \n        ss=''\n        for i in range(1,len(self.f),2):\n            ss.join(str(self.f[i]))\n        return hash(ss)\n    \n  \n    def __eq__(self, other):  \n        if self.f== other.f :  \n            return True  \n        return False      \n    \n    def __str__(self):\n        return str(self.f)\n\n   \ndx = [ -1, 0, 1, 0 ]\ndy= [ 0, -1, 0 ,1 ]\ndirect = [ 'u','l','d','r']\n\n\ndef isTarget(p) :\n    for i in range(maxx):\n        if (p.f[i] != (i + 1)):\n            return False;\n    return True;\n\ndef bfs(s): \n    global row\n    global maxx\n    global dx\n    global dy\n    global direct\n    global Q\n    \n    V={}\n    #Puzzle u, v;\n    s.path = \"\"\n    Q.append(s)\n    V[s] = True\n\n    while (len(Q)!=0): \n        u =Q.popleft()\n        if (isTarget(u)):\n            return u.path\n        \n        sx = u.space // row\n        sy = u.space % row\n        for r in range(4):\n            tx = sx + dx[r]\n            ty = sy + dy[r]\n\n            if (tx < 0 or ty < 0 or tx >= row or ty >= row):\n                continue;\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx * row + ty]=v.f[tx * row + ty],v.f[u.space]\n            v.space = tx * row + ty\n            \n            #if v in V:\n                #print(v)\n                \n            if  (not( v in V))  or V[v]!=True :\n                   V[v] = True;\n                   v.path += direct[r];\n                   Q.append(v)\n\n    return \"unsolveable\"\n\nstart=Puzzle()\nstart.f=[None for i in range(maxx)]\nQ=deque()\n\n\nfor i in range(3) :\n    start.f[i*3:i*3+3]=[int(x) for x in input().split()]\n    \nfor i in range(maxx):\n    if (start.f[i] == 0):\n        start.f[i] = maxx\n        start.space = i\n    \nans = bfs(start)\nif (ans!=\"unsolveable\"):\n    print(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x = (i+1)%3\n        y = (i+1)//3\n        if y == 3:\n            y = 0\n        dx = abs(node_list[i]%3 - x)\n        dy = abs(node_list[i]//3 - y)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.node, b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys, itertools\nf = sys.stdin\n\nstart = [line.split() for line in f]\nstart = tuple(int(x) for y in start for x in y)\nend =(1, 2, 3, 4, 5, 6,7, 8, 0)\n\nd = {start:0}\n\ndef next_board(b):\n    brank = b.index(0)\n    if brank % 3:\n        yield b[:brank - 1] + (b[brank], b[brank - 1]) + b[brank + 1:]\n    if brank // 3:\n        yield b[:brank - 3] + (b[brank],)+ b[brank - 2:brank] +  (b[brank - 3],) + b[brank + 1:]\n    if brank % 3 != 2:\n        yield b[:brank] + (b[brank + 1], b[brank]) + b[brank + 2:]\n    if brank // 3 != 2:\n        yield b[:brank] + (b[brank + 3],)+ b[brank + 1:brank + 3] +  (b[brank],) + b[brank + 4:]\n\nqueue = set([start])\nwhile len(queue):\n    u = queue.pop()\n    for b in next_board(u):\n        if b not in d or d[b] > d[u] + 1:\n            d[b] = d[u] + 1\n            queue.update([b])\n        \nprint(d[end])"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n\tif n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.put(v)\n\nprint(u[2])\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef move(P):\n    for i in range(3):\n        for j in range(3):\n            if P[i][j] == 0:\n                r,c = i,j\n    if not r == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r-1][c] = tmp[r-1][c],tmp[r][c]\n        yield tmp\n    if not r == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r+1][c] = tmp[r+1][c],tmp[r][c]\n        yield tmp\n    if not c == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c-1] = tmp[r][c-1],tmp[r][c]\n        yield tmp\n    if not c == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c+1] = tmp[r][c+1],tmp[r][c]\n        yield tmp\n\ndef dpkey(P):\n    tmp = \"\"\n    for i in P:\n        for j in i:\n            tmp += str(j)\n    return tmp\n\nA = [[int(i) for i in input().split()] for _ in range(3)]\ndp = {dpkey(A) : 1}\nd = deque([(A,0)])\nc = 0\nflag = True\nwhile(flag):\n    tmp,c = d.pop()\n    for i in move(tmp):\n        key = dpkey(i)\n        if key == \"123456780\":\n            ans = c + 1\n            flag = False\n        elif not key in dp:\n            dp[key] = 1\n            d.appendleft((i,c+1))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom heapq import heappop, heappush\nFORE = 1\nBACK = 0\nadjacent = ((1,3), (0,2,4), (1,5), (0,4,6), (1,3,5,7), (2,4,8), (3,7), (4,6,8), (5,7))\nstart = [int(a) for _ in range(3) for a in stdin.readline().split()]\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev: continue\n        b = board[:]\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\ndef search(start):\n    if start == end: return 0\n    table = {}\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(end)] = (BACK, 0)\n    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]\n    while heap:\n        i, board, space, prev, direction = heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction: return table[key][1] + i\n                continue\n            table[key] = (direction, i)\n            if b == end: return i\n            heappush(heap, (i, b, nxt, space, direction))\nprint(search(start))"
  },
  {
    "language": "Python",
    "code": "import sys, collections\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**10\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    S = []\n    SOLVED = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n    for _ in range(3):\n        S += LI()\n\n    neighbor = (\n        (1, 3),      \n        (0, 2, 4),   \n        (1, 5),      \n        (0, 4, 6),   \n        (1, 3, 5, 7),\n        (2, 4, 8),   \n        (3, 7),      \n        (4, 6, 8),   \n        (5, 7)       \n    )\n\n    dist = dict()\n    que = collections.deque()\n    S = tuple(S)\n    que.append((S, S.index(0)))\n    dist[S] = 0\n    while que:\n        c, idx_0 = que.popleft()\n        if c == SOLVED:\n            break\n        for i in neighbor[idx_0]:\n            c_l = list(c)\n            c_l[idx_0], c_l[i] = c_l[i], c_l[idx_0]\n            n = tuple(c_l)\n            if not n in dist:\n                que.append((n, i))\n                dist[n] = dist[c] + 1\n\n    print(dist[SOLVED])\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2 and prev_move != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0 and prev_move != 3):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2 and prev_move != 4):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# å¹åªåæ¢ç´¢ #åæ¹åæ¢ç´¢\nimport sys\nimport queue\n\nSPACE = 0\n\nadjacents_list = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef mininum_steps(start, goal):\n    if start == goal:\n        return 0\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    history = {}\n    history[tuple(start)] = True\n    while not q.empty():\n        state = q.get()\n        for adjacent in adjacents_list[state.space]:\n            board = state.board[:]\n            board[state.space] = board[adjacent]\n            board[adjacent] = SPACE\n            if tuple(board) in history:\n                 continue\n            if board == goal:\n                return go_back(state)\n            history[tuple(board)] = True\n            next_state = State(board, adjacent, state)\n            q.put(next_state)\n\nstep = 0\ndef go_back(state):\n    global step\n    if state is not None:\n        step += 1\n        go_back(state.prev)\n    return step\n\n\ninitial_board = list(map(int, sys.stdin.read().split()))\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nprint(mininum_steps(initial_board, goal))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN = 3\nM = 3\nboard = []\nexpected = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\nqueue = deque()\nbqueue = deque()\n\nhistory = set()\n# todo æ°å­ã§è¡¨ã\n# todo 2åæä½ã«ãã\n\n\ndef swap(x1, y1, x2, y2, b):\n    # 2æ¬¡åéåãæµãã³ãã¼ãããªãã¦\n    t = [x[:] for x in b]\n    t[x1][y1], t[x2][y2] = t[x2][y2], t[x1][y1]\n    return t\n\n\ndef p2i(b):\n    tmp = 0\n    for i in range(N):\n        for j in range(M):\n            tmp += b[i][j] * 10**(3*i+j)\n    return tmp\n\n\ndef bfs():\n    if expected == board:\n        print(0)\n        exit(0)\n\n    while len(queue):\n        pazzle = queue.popleft()\n        cost = bqueue.popleft()\n        # 0ã®å ´æãæ¢ã\n        xz = None\n        yz = None\n        for i in range(N):\n            for j in range(M):\n                if pazzle[i][j] == 0:\n                    xz, yz = i, j\n        # åãããã¨ã®ã§ããæ¹åãå¨ã¦èª¿ã¹ã\n        xm = [1, 0, 0, -1]\n        ym = [0, -1, 1, 0]\n        for k in range(4):\n            if 0 <= xz + xm[k] < N and 0 <= yz + ym[k] < N:\n                # ï¼æåããã¦ãã£ããçµäºããªãã£ããæ¬¡ã®æã«è¡ãã\n                t = swap(xz, yz, xz + xm[k], yz + ym[k], pazzle)\n                ipz = p2i(t)\n                if 87654321 == ipz:\n                    print(cost+1)\n                    exit(0)\n                # ä»ã¾ã§ã«åºã¦ãªããªãã­ã¥ã¼ã«è¿½å \n                if ipz not in history:\n                    queue.append(t)\n                    history.add(ipz)\n                    bqueue.append(cost+1)\n\n\nfor i in range(N):\n    board.append(list(map(int, input().split())))\nqueue.append(board)\nbqueue.append(0)\nbfs()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\n# Bidirectional search using breadth-first search\ndef solve(start, goal):\n    if start == goal:\n        return 0\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n    step = {start: 0, goal: 0}\n    s = 0\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n    while True:\n        q = iter(c_d)\n        c_d = []\n        s += 1\n        for c, d in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n\nprint(solve(init, '123456780'))"
  },
  {
    "language": "Python",
    "code": "# 8 Puzzle\nimport copy\n[N, d] = [3, 0]\nstart = []\ngoal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]\ngoal[2][2] = 0\nfor i in range(N):\n    start.append(list(map(int, input().split())))\n\n\ndef manhattan(value, pairs):\n    h = 0\n\n    if value == 1:\n        h = (pairs[0] + pairs[1])\n    if value == 2:\n        h = (pairs[0] + abs(pairs[1] - 1))\n    if value == 3:\n        h = (pairs[0] + abs(pairs[1] - 2))\n    \n    if value == 4:\n        h = (abs(pairs[0] - 1) + pairs[1])\n    if value == 5:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) \n    if value == 6:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))\n        \n    if value == 7:\n        h = (abs(pairs[0] - 2) + pairs[1])      \n    if value == 8:\n        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))\n        \n    return h\n\ns_h = 0\nfor i in range(N):\n    for j in range(N):\n        s_h += manhattan(start[i][j], [i, j])\n\nfor i in range(N):\n        check = start[i].count(0)\n        if check != 0:\n            [s_r, s_c] = [i, start[i].index(0)]\n            break\n        if i == 3:\n            print(\"Error\")\n\nwhile True:\n    d += 1\n    flag = 0\n    queue = [[s_h, start, 0, [s_r, s_c], flag]]\n    \n    while len(queue) != 0:\n        short_n = queue.pop(0)\n        h = short_n[0] - short_n[2]\n        state = short_n[1]\n        g = short_n[2]\n        [r, c] = short_n[3]\n        flag = short_n[4]\n        \n        if h == 0:\n            print(short_n[2])\n            break\n       \n        if r - 1 >= 0 and flag != 3:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])\n            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r - 1, c], 1])\n        \n        if c + 1 < N and flag != 4:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])\n            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c + 1], 2])\n\n        if r + 1 < N and flag != 1:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])\n            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r + 1, c], 3])\n        \n        if c - 1 >= 0 and flag != 2:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])\n            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c - 1], 4])\n                \n        queue.sort(key = lambda data:data[0])\n        queue.sort(key = lambda data:data[2], reverse = True)\n\n        data = []\n        g_data = []\n\n    if state == goal:\n        break\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    def isTarget(p):\n        for i in range(N2):\n            if p[i] != i+1:\n                return False\n        return True\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n#coding:utf-8\n\ndef _downheap(buff, n):\n\tsize = len(buff)\n\twhile True:\n\t\tc = 2 * n + 1\n\t\tif c >= size: break\n\t\tif c + 1 < size:\n\t\t\tif buff[c] > buff[c + 1]: c += 1\n\t\tif buff[n] <= buff[c]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[c]\n\t\tbuff[c] = temp\n\t\tn = c\n\n# ???????????????\ndef _upheap(buff, n):\n\twhile True:\n\t\tp = (n - 1) / 2\n\t\tif p < 0 or buff[p] <= buff[n]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[p]\n\t\tbuff[p] = temp\n\t\tn = p\n\nclass PQueue:\n\tdef __init__(self, buff = []):\n\t\tself.buff = buff[:]   # ?????????\n\t\tfor n in xrange(len(self.buff) / 2 - 1, -1, -1):\n\t\t\t_downheap(self.buff, n)\n\n\t# ??????????????????\n\tdef push(self, data):\n\t\tself.buff.append(data)\n\t\t_upheap(self.buff, len(self.buff) - 1)\n\n\t# ????Â°???????????????????\n\tdef pop(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\tvalue = self.buff[0]\n\t\tlast = self.buff.pop()\n\t\tif len(self.buff) > 0:\n\t\t\t# ????????????????Â§????\n\t\t\tself.buff[0] = last\n\t\t\t_downheap(self.buff, 0)\n\t\treturn value\n\n\t# ????Â°????????Â±???????\n\tdef peek(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\treturn self.buff[0]\n\n\t# ??????\n\tdef isEmpty(self): return len(self.buff) == 0\n\n# ?????Â°\nOPEN = 0\nCLOSE = 1\nFORE = 0\nBACK = 1\n\nX=3\nY=3\n\nadjacent=[]\nfor coor in range(X*Y):\n\tlst=[]\n\tx=coor%X\n\ty=coor/X\n\tif 0<x: lst.append(coor-1)\n\tif x<X-1: lst.append(coor+1)\n\tif 0<y: lst.append(coor-X)\n\tif y<Y-1: lst.append(coor+X)\n\tadjacent.append(lst)\n\n# ?????Â¢??Â¨?????????\ndef make_distance_table(board, wide):\n\tsize = len(board)\n\ttable = [[0] * size for _ in xrange(size)]\n\tfor i in xrange(size):\n\t\tp = board[i]\n\t\tif p == 0: continue\n\t\tx1 = i / wide\n\t\ty1 = i % wide\n\t\tfor j in xrange(size):\n\t\t\tx2 = j / wide\n\t\t\ty2 = j % wide\n\t\t\ttable[p][j] += max(x1 - x2, x2 - x1)\n\t\t\ttable[p][j] += max(y1 - y2, y2 - y1)\n\treturn table\n\n# ?????Â¢????Â±???????\ndef get_distance(board, distance):\n\tv = 0\n\tfor x in xrange(X*Y):\n\t\tp = board[x]\n\t\tif p == 0: continue\n\t\tv += distance[p][x]\n\treturn v\n\n# ?Â±???Â¢?????????\nclass State:\n\tdef __init__(self, board, space, prev, move, dir, kind = OPEN):\n\t\tself.board = board\n\t\tself.space = space\n\t\tself.prev = prev\n\t\tself.move = move\n\t\tself.dir = dir\n\t\tself.kind = kind\n\t\tif dir == FORE:\n\t\t\tdt = start_distance\n\t\telse:\n\t\t\tdt = goal_distance\n\t\tif prev is None:\n\t\t\tself.cost = move + get_distance(board, dt)\n\t\telse:\n\t\t\tp = board[prev.space]\n\t\t\tself.cost = prev.cost + 1 - dt[p][space] + dt[p][prev.space]\n\n\tdef __cmp__(x, y):\n\t\treturn x.cost - y.cost\n\n# ???????????? A* ??Â¢?????Â´?????????\ndef a_star_search(start, goal):\n\tglobal start_distance, goal_distance\n\tq = PQueue()\n\ttable ={}\n\t# ?????????????????????\n\tstart_distance = make_distance_table(goal, X)\n\ta = State(start, start.index(0), None, 0, FORE)\n\tq.push(a)\n\ttable[tuple(start)] = a\n\t# ??Â´???????????????\n\tgoal_distance = make_distance_table(start, X)\n\ta = State(goal, goal.index(0), None, 0, BACK)\n\tq.push(a)\n\ttable[tuple(goal)] = a\n\twhile not q.isEmpty():\n\t\ta = q.pop()\n\t\tif a.kind == CLOSE: continue   # ????Â£????????????Â§??????\n\t\tfor x in adjacent[a.space]:\n\t\t\tb = a.board[:]\n\t\t\tb[a.space] = b[x]\n\t\t\tb[x] = 0\n\t\t\tkey = tuple(b)\n\t\t\tif key in table:\n\t\t\t\t# ???????Â±???Â¢?????????\n\t\t\t\tc = table[key]\n\t\t\t\tif a.dir != c.dir:\n\t\t\t\t\t# ??????\n\t\t\t\t\tif a.dir == FORE:\n\t\t\t\t\t\tprint print_answer(a)+print_answer_goal(c)-1\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint print_answer(c)+print_answer_goal(a)-1\n\t\t\t\t\treturn\n\t\t\t\t# ?????Â¢???????????????????????Â°?????????????????Â°??????\n\t\t\t\tif c.move > a.move + 1:\n\t\t\t\t\t# ??Â´??Â°??????\n\t\t\t\t\tif c.kind == OPEN:\n\t\t\t\t\t\tc.kind = CLOSE\n\t\t\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\t\t\ttable[key] = c\n\t\t\t\t\telse:\n\t\t\t\t\t\tc.prev = a\n\t\t\t\t\t\tc.cost = c.cost - c.move + a.move + 1\n\t\t\t\t\t\tc.move = a.move + 1\n\t\t\t\t\t\tc.kind = OPEN\n\t\t\t\t\t# ??????????????????\n\t\t\t\t\tq.push(c)\n\t\t\telse:\n\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\tq.push(c)\n\t\t\t\ttable[key] = c\n\t\t# a ???????????????????Â±??????????\n\t\ta.kind = CLOSE\n\n# ???????????Â¨???\ndef print_answer(x):\n\tif x is not None:\n\t\treturn 1+print_answer(x.prev)\n\t\t#print x.board\n\treturn 0\n\ndef print_answer_goal(x):\n\tr=0\n\twhile x is not None:\n\t\t#print x.board\n\t\tx = x.prev\n\t\tr+=1\n\treturn r\n\n# ??????\ngoal = [1,2,3,4,5,6,7,8,0]\na = []\ntry:\n    while True:\n        a+=[int(e) for e in raw_input().split()]\nexcept EOFError:\n    pass\n\na_star_search(a, goal)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\nfrom copy import deepcopy\n\n\nclass Board:\n    def __init__(self, size, nums):\n        self.size = size\n        self.nums = nums\n        self.code = self._code()\n\n    def __eq__(self, other):\n        return self.code == other.code\n\n    def __lt__(self, other):\n        return self.code < other.code\n\n    def __gt__(self, other):\n        return self.code > other.code\n\n    def __hash__(self):\n        nums = tuple(self.nums[i][j]\n                     for i in range(self.size)\n                     for j in range(self.size))\n        return hash(nums)\n\n    def same(self, other):\n        if other is None:\n            return False\n        if self.__class__ != other.__class__:\n            return False\n\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != other.nums[i][j]:\n                    return False\n        return True\n\n    def solved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if (i, j) != self._validpos(self.nums[i][j]):\n                    return False\n        return True\n\n    def _validpos(self, num):\n        if num > 0:\n            return ((num-1) // self.size, (num-1) % self.size)\n        else:\n            return (self.size-1, self.size-1)\n\n    def _code(self):\n        code = 0\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != 0:\n                    vi, vj = self._validpos(self.nums[i][j])\n                    code += abs(vi - i) + abs(vj - j)\n        return code\n\n    def find(self, num):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] == num:\n                    return (i, j)\n        raise IndexError()\n\n    def move(self, p1, p2):\n        i1, j1 = p1\n        i2, j2 = p2\n        nums = deepcopy(self.nums)\n        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]\n        return self.__class__(self.size, nums)\n\n    def moves(self):\n        i, j = self.find(0)\n        if i > 0:\n            yield self.move((i, j), (i-1, j))\n        if j > 0:\n            yield self.move((i, j), (i, j-1))\n        if i < self.size-1:\n            yield self.move((i, j), (i+1, j))\n        if j < self.size-1:\n            yield self.move((i, j), (i, j+1))\n\n    def __str__(self):\n        s = ''\n        for i in range(self.size):\n            for j in range(self.size):\n                s += ' {}'.format(self.nums[i][j])\n            s += '\\n'\n        return s\n\n\nclass EightPuzzle:\n    def __init__(self, board):\n        self.board = Board(3, board)\n        self.steps = 0\n\n        if not self.board.solved():\n            self._solve()\n\n    def _solve(self):\n        bs = []\n        checked = {}\n        heappush(bs, (self.board.code, self.board, 0))\n\n        while len(bs) > 0:\n            w, b, step = heappop(bs)\n            if 0 < self.steps <= step:\n                continue\n            checked[b] = step\n            for nb in b.moves():\n                if nb.solved():\n                    self.steps = step+1\n                    return\n                elif nb in checked and checked[nb] <= step:\n                    continue\n                else:\n                    heappush(bs, (nb.code + step + 1, nb, step+1))\n\n\ndef run():\n    board = []\n    for i in range(3):\n        board.append([int(i) for i in input().split()])\n\n    eight_puzzle = EightPuzzle(board)\n    print(eight_puzzle.steps)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle()\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if not (0<= tx < N and 0 <= ty < N):\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\nN = 3\nFORE = 1\nBACK = 0\n\nboard_goal = [i for i in range(1, N ** 2)] + [0]\n\n\nBOARD_ADJACENT = (\n    (1, 3),        # 0\n    (0, 2, 4),     # 1\n    (1, 5),        # 2\n    (0, 4, 6),     # 3\n    (1, 3, 5, 7),  # 4\n    (2, 4, 8),     # 5\n    (3, 7),        # 6\n    (4, 6, 8),     # 7\n    (5, 7)         # 8\n)\n\n\ndef slove(board_start):\n    if board_start == board_goal:\n        return 0\n\n    dict_board_state = {}\n    dict_board_state[tuple(board_start)] = (FORE, 0)\n\n    heap_board = [(0, board_start, board_start.index(0), None, FORE)]\n\n    while heap_board:\n        cnt_move, board, space_now, space_prev, direction = heapq.heappop(heap_board)\n        cnt_move += 1\n\n        for board_next, space_next in next_board(board, space_now, space_prev):\n            key = tuple(board_next)\n            if key in dict_board_state:\n                continue\n\n            dict_board_state[key] = (direction, cnt_move)\n            if board_next == board_goal:\n                return cnt_move\n\n            heapq.heappush(heap_board, (cnt_move, board_next, space_next, space_now, direction))\n\n            \ndef next_board(board, space_now, space_prev):\n    for space_next in BOARD_ADJACENT[space_now]:\n        if space_next == space_prev:\n            continue\n\n        board_next = board[:]\n        board_next[space_now], board_next[space_next] = board_next[space_next], 0\n        yield board_next, space_next\n\n\n\nboard_input = []\n\nfor _ in range(N):\n    board_input.extend(list(map(int, input().split())))\n\n\nprint(slove(board_input))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef move(P):\n    for i in range(3):\n        for j in range(3):\n            if P[i][j] == 0:\n                r,c = i,j\n    if not r == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r-1][c] = tmp[r-1][c],tmp[r][c]\n        yield tmp\n    if not r == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r+1][c] = tmp[r+1][c],tmp[r][c]\n        yield tmp\n    if not c == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c-1] = tmp[r][c-1],tmp[r][c]\n        yield tmp\n    if not c == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c+1] = tmp[r][c+1],tmp[r][c]\n        yield tmp\n\ndef dpkey(P):\n    tmp = \"\"\n    for i in P:\n        for j in i:\n            tmp += str(j)\n    return tmp\n\nA = [[int(i) for i in input().split()] for _ in range(3)]\ndp = {dpkey(A) : 1}\nd = deque([(A,0)])\nc = 0\nflag = True\nwhile(flag):\n    tmp,c = d.pop()\n    for i in move(tmp):\n        key = dpkey(i)\n        if key == \"123456780\":\n            ans = c + 1\n            flag = False\n        elif not key in dp:\n            dp[key] = 1\n            d.appendleft((i,c+1))\nif dpkey(A) == \"123456780\":\n    ans = 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\n\ndef gen_hash(panel):\n    _hash = \"\"\n    for i in range(3):\n        for j in range(3):\n            _hash += str(panel[i][j])\n    return _hash\n\n\ndef get_matchings(_hash):\n    ans = \"123456780\"\n    cnt = 0\n    for i in range(9):\n        if _hash[i] == str(ans[i]):\n            cnt += 1\n    return cnt\n\n\ndef bfs(panel):\n    swap_candidates = {\n        0: (1, 3),\n        1: (0, 2, 4),\n        2: (1, 5),\n        3: (0, 4, 6),\n        4: (1, 3, 5, 7),\n        5: (2, 4, 8),\n        6: (3, 7),\n        7: (4, 6, 8),\n        8: (5, 7)\n    }\n    dq = deque()\n    dq.append((gen_hash(panel), 0))\n    seen = set()\n    seen.add(gen_hash(panel))\n    while dq:\n        _hash, cnt = dq.popleft()\n        if get_matchings(_hash) == 9:\n            return cnt\n        z_ptr = _hash.index(\"0\")\n        for n_ptr in swap_candidates[z_ptr]:\n            next_hash = list(_hash)\n            next_hash[z_ptr], next_hash[n_ptr] = next_hash[n_ptr], next_hash[z_ptr]\n            next_hash = \"\".join(next_hash)\n            if next_hash not in seen:\n                seen.add(next_hash)\n                dq.append((next_hash, cnt + 1))\n\n\npanel = []\nfor _ in range(3):\n    panel.append([int(i) for i in input().split()])\n\nans = bfs(panel)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport queue\n\n# ??Â£??\\?????????\nadjacent =(\n    (1,3),     # 0\n    (0,2,4),   # 1\n    (1,5),     # 2\n    (0,4,6),   # 3\n    (1,3,5,7), # 4\n    (2,4,8),   # 5\n    (3,7),     # 6\n    (4,6,8),   # 7\n    (5,7)      # 8\n)\n\n# ?Â±???Â¢?????????\nclass State:\n    def __init__(self,board,space,prev):\n        self.board = board # ?????Â¢?????Â¨?????????\n        self.space = space # ?????Â´????????????(0?????????)\n        self.prev = prev   # 1??????????Â±???Â¢(State??????????????Â§??????)\n\ndef bf_search(start,end):\n    q = queue.Queue()\n    q.put(State(start,start.index(0),None)) #item???Q?????\\??????\n    table = {} # ??????????????????\n    table[tuple(start)] = True # ???????Â±???Â¢????????Â§???????????????????????????\n\n    while not q.empty(): # empty()???Q???????????Â´??????True????????????????????Â§????????Â´??????False?????????\n        a = q.get() # Q??????item????????????????????????????????????\n        for i in adjacent[a.space]: # i????????????0?????????\n            b = a.board[:] # ???????????Â¢???b????????????\n            b[a.space] = b[i] # ?Â¬?????????Â¢?????????\n            b[i] = 0          # ?Â¬?????????Â¢?????????\n            \n            \n            key = tuple(b) # b???????????Â¨??????table????????Â¨??????????Â¢??????????\n            if key in table:\n                continue # ?????Â¨?????????for?????????????????Â£?????Â°???????????Â¢b?????????\n\n            # table????????Â¨???????????Â´????????Â°???????Â±???Â¢c?????????\n            # b?????Â°???????????Â¢?????Â¨????????????i????????????0????????????a???1??????????Â±???Â¢\n            c = State(b,i,a) \n\n            # b???end????????Â´?????????printAns()??Â§???????????Â°?????Â¨???\n            if b == end:\n                return printAns(c)\n\n            # ?????Â´???????????Â£??????Q???c????????????\n            q.put(c)\n            # key????????Â£???True?????????\n            table[key] = True\n\ncount = -1\ndef printAns(c):\n    global count\n    if c is not None: \n        count += 1\n        printAns(c.prev) # c.prev??????????????????????????Â¨????????Â£????????Â°?????Â°??????\n    return count\n\n\n# ??????????????????????????????\nend = [1,2,3,4,5,6,7,8,0]\n\n# ??\\???\nstart = [ int(n) for _ in range(3) for n in stdin.readline().split() ]\n\nif start == end:\n    print(0)\nelse:\n    print(bf_search(start,end))"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+HS(c_puz)) > depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\ndef check_goal(p):\n    return p == [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\ndef up(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero - 3]\n    q[zero - 3] = 0\n    return q\n\n\ndef low(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero + 3]\n    q[zero + 3] = 0\n    return q\n\n\ndef right(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero + 1]\n    q[zero + 1] = 0\n    return q\n\n\ndef left(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero - 1]\n    q[zero - 1] = 0\n    return q\n\n\ndef cost(p, n_mov):\n    c = n_mov\n    for i in range(9):\n        if p[i] != (i + 1) % 9:\n            c += 1\n    return c\n\n\ndef solve(p):\n    ans = 0\n    zero = p.index(0)\n    will = list()\n    done = [p]\n    while not check_goal(p):\n        ans += 1\n        if zero >= 3 and up(p) not in done:\n            done.append(up(p))\n            heapq.heappush(will, (up(p), ans))\n        if zero <= 5 and low(p) not in done:\n            done.append(low(p))\n            heapq.heappush(will, (low(p), ans))\n        if zero % 3 <= 1 and right(p) not in done:\n            done.append(right(p))\n            heapq.heappush(will, (right(p), ans))\n        if zero % 3 >= 1 and left(p) not in done:\n            done.append(left(p))\n            heapq.heappush(will, (left(p), ans))\n        p, ans = heapq.heappop(will)\n        zero = p.index(0)\n    return ans\n\n\np = list(map(int, input().split()))\np.extend(list(map(int, input().split())))\np.extend(list(map(int, input().split())))\nprint(solve(p))\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 50;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // åã¨åãéç½®ã«ãªã£ãã®ã§æ¬¡ã®æãè©¦ã\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append(sumcost,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        c_dWithH, items = q.pop(0)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN = 3\nN2 = 9\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndirc = ['u', 'l', 'd', 'r']\n\nclass Puzzle:\n    def __init__(self, f=None, space=None, path=None):\n        if f is None:\n            self.f = []\n        else:\n            self.f = f\n        self.space = space\n        self.path = path\n\n    def __lt__(self, p):\n        for i in range(N2):\n            if self.f[i] == p.f[i]:\n                continue\n            return self.f[i] > p.f[i]\n        return False\n\n\ndef isTarget(p):\n    for i in range(N2):\n        if p.f[i] != (i + 1):\n            return False\n    return True\n\n\ndef bfs(s):\n    q = deque()\n    dic = {}\n    s.path = ''\n    q.append(s)\n    dic[tuple(s.f)] = True\n\n    while len(q) != 0:\n        u = q.popleft()\n        if isTarget(u):\n            return u.path\n        sx = u.space // N\n        sy = u.space % N\n        for r in range(4):\n            tx = sx + dx[r]\n            ty = sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                continue\n            v = Puzzle(u.f[:], u.space, u.path)\n            v.f[u.space], v.f[tx * N + ty] = v.f[tx * N + ty], v.f[u.space]\n            v.space = tx * N + ty\n            key = tuple(v.f)\n            if key not in dic:\n                dic[key] = True\n                v.path += dirc[r]\n                q.append(v)\n\n    return 'unsolvable'\n\n\nif __name__ == '__main__':\n    p = Puzzle()\n    for i in range(N):\n        line = [int(v) for v in input().split()]\n        for j in range(N):\n            if line[j] == 0:\n                line[j] = N2\n                p.space = i * N + j\n        p.f.extend(line)\n\n    ans = bfs(p)\n    print(len(ans))\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n \nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n \n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n \nimport sys\n \nstart = list(map(int, sys.stdin.read().split()))\n \nprint(solve(start))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom itertools import chain\nfrom operator import mul\n\nexp10 = [10 ** a for a in range(8, -1, -1)]\nmovables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]\n\ndestination = 123456780\n\n\ndef swap(board, move_from, move_to):\n    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)\n\n\nboard0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))\np0 = str(board0).index('0')\n\nappeared = {board0}\nqueue = list((0, move_from, p0, board0) for move_from in movables[p0])\nheapq.heapify(queue)\n\nwhile True:\n    total_cost, move_from, move_to, board = heapq.heappop(queue)\n    if board == destination:\n        print(total_cost)\n        break\n    new_board = swap(board, move_from, move_to)\n    if new_board in appeared:\n        continue\n    for move_from2 in movables[move_from]:\n        if move_from2 != move_to:\n            heapq.heappush(queue, (total_cost + 1, move_from2, move_from, new_board))"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop()\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n            \n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\nimport time\n\nN=3\nN2=9\ndiry=[0,1,0,-1]\ndirx=[1,0,-1,0]\npos=[[2,2],[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1]]\nmove=[[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n\nclass Puzzle:\n    board=\"\"\n    space=0\n\n    def __init__(self,board,space):\n        self.board=board\n        self.space=space\n\n    #ç¤é¢ãè¡¨ç¤º\n    def showBoard(self):\n        for i in range(N2):\n            if self.board[i]!=0:\n                print(self.board[i],end=' ')\n            else:\n                print('  ',end='')\n            if i%3==2:\n                print()\n        print()\n\nclass State:\n    pz=None\n    g=0\n    h=0\n    f=0\n    pr=None\n\n    def __init__(self,pz,g,h=0,pr=None):\n        self.pz=pz\n        self.g=g\n        self.h=h\n        self.f=g+h\n        self.pr=pr\n\n    #åæç¤é¢ãã1æãã¤è¡¨ç¤º\n    def showRoot(self):\n        if self.pr!=None:\n            self.pr.showRoot()\n        self.pz.showBoard()\n\n    def __lt__(self,other):\n        if self.f==other.f:\n            return self.g>other.g\n        return self.f<other.f\n\n#æ­£è§£ã¨ã®ãã³ããã¿ã³è·é¢\ndef h2(p):\n    count=0\n    for i in range(N2):\n        n=int(p.board[i])\n        count+=abs(pos[n][0]-i//N)+abs(pos[n][1]-i%N)\n    return count\n\n#h1ãç¨ãããã¥ã¼ãªã¹ãã£ãã¯æ¢ç´¢\ndef heuristic(pz,h):\n    closedList=set()\n    s=State(pz,0,h(pz),None)\n    q=queue.PriorityQueue()\n    q.put(s)\n    while not q.empty():\n        s=q.get()\n        if s.pz.board in closedList:\n            continue\n        if s.pz.board=='123456780':\n            return s.g\n        space=s.pz.space\n        for next in move[space]:\n            nb=list(s.pz.board)\n            nb[space],nb[next]=nb[next],nb[space]\n            newb=''.join(nb)\n            if not newb in closedList:\n                np=Puzzle(newb,next)\n                ns=State(np,s.g+1,h(np),s)\n                q.put(ns)\n        closedList.add(s.pz.board)\n    return -1\n\n#åæç¤é¢ã®èª­ã¿è¾¼ã¿\ns=''\nfor i in range(3):\n    s+=input()\ninitialBoard=s.replace(' ','')\n\n#ç©ºç½ã®è¨­å®\nspace=initialBoard.find('0')\n\n#Puzzleãªãã¸ã§ã¯ãã®ä½æ\ninitialPuzzle=Puzzle(initialBoard,space)\n\nif initialBoard=='123456780':\n    print(0)\nelse:\n    print(heuristic(initialPuzzle,h2))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = sum([input().split() for _ in range(N)], [])\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ['1', '2', '3', '4', '5', '6', '7', '8', '0']\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = [MAP]\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        yx = y * N + x\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = deepcopy(M)\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.append(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nfrom copy import deepcopy\n\n\nclass State:\n    def dup(self):\n        ns = State()\n        ns.b = self.b[:]\n        ns.z = self.z\n        ns.c = self.c\n        return ns\n\n\ndef read_board():\n    s = State()\n    s.b = [int(x) for x in stdin.read().split()]\n    s.z = s.b.index(0)\n    s.c = 0\n    return s\n\n\ndef move_zero(s, h):\n    ns = s.dup()\n    ns.z += h\n    ns.b[s.z], ns.b[ns.z] = ns.b[ns.z], ns.b[s.z]\n    ns.c += 1\n    return ns\n\n\ndef push_hands(q, s):\n    if s.z % 3 != 0:\n        q.append(move_zero(s, -1))\n    if s.z % 3 != 3 - 1:\n        q.append(move_zero(s, 1))\n    if s.z // 3 != 0:\n        q.append(move_zero(s, -3))\n    if s.z // 3 != 3 - 1:\n        q.append(move_zero(s, 3))\n\n\ndef solve(s):\n    hist = set()\n    q = deque([])\n    while True:\n        t = tuple(s.b)\n        if t == (1, 2, 3, 4, 5, 6, 7, 8, 0):\n            return s.c\n        if t not in hist:\n            push_hands(q, s)\n            hist.add(t)\n        s = q.popleft()\n\n\ndef main():\n    b = read_board()\n    print(solve(b))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nMOVE = {'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0)}\n\ndef next(numbers):\n    for d in 'UDLR':\n        z = numbers.index(0)\n        tx, ty = z % 3 + MOVE[d][0], z \n        if 0 <= tx < 3 and 0 <= ty < 3:\n            t = ty * 3 + tx\n            result = list(numbers)\n            result[z], result[t] = numbers[t], 0\n            yield d, tuple(result)\n\ndef bfs(puzzle):\n    queue = deque([(puzzle, '')])\n    seen = set()\n    while queue:\n        numbers, route = queue.popleft()\n        seen.add(numbers)\n        if numbers == (1, 2, 3, 4, 5, 6, 7, 8, 0):\n            return route\n        for direction, new_numbers in next(numbers):\n            if new_numbers not in seen:\n                queue.append((new_numbers, route + direction))\n    return route\n\npuzzle = ()\nfor i in range(3):\n    a,b,c = map(int, input().split())\n    puzzle += (a,b,c)\n\nprint(len(bfs(puzzle)))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        k = abs(i-k)\n        if(k >= 3):\n            value += (int)(k/3)\n        value += k - (int)(k/3)*3\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nadjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev  = prev\n\n\ndef bf_search(start):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n\n    table = {}\n    table[tuple(start)] = True\n\n    while not q.empty():\n        a = q.get()\n\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n\n            key = tuple(b)\n\n            if key in table: continue\n\n            c = State(b, x, a)\n\n            if b == GOAL:\n                print_answer(c)\n                return\n\n            q.put(c)\n            table[key] = True\n\n\n# æé ã®è¡¨ç¤º\ndef print_answer(x):\n    count = 0\n\n    while x.prev != None:\n        x = x.prev\n        count += 1\n\n    print(count)\n\n\n\nif(__name__ == '__main__'):\n    p = []\n    for i in range(3):\n        p.extend([int(x) for x in input().split()])\n\n    bf_search(p)\n\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nimport collections\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n\nimport sys\n\nstart = list(map(int, sys.stdin.read().split()))\n\nprint(solve(start))"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n     0: {3, 1}}\ngoal = 123456780\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    zero = 8 - MAP.find(\"0\")\n    start = int(MAP)\n    if start == goal:\n        return 0\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n    TABLE = {start: (1, 0), goal: (0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nboard = [int(s) for _ in range(3) for s in input().split()]\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ntable = set()\ndef print_board(board):\n    for i in range(0, 9, 3):\n        print(*board[i:i + 3])\n\ndef swap(q, step_q, step, board):\n    key = tuple(board)\n    if key in table:\n        return\n    else:\n        table.add(key)\n\n    empty = board.index(0)\n    def _swap(q, step_q, step, board, k, s):\n        b = board.copy()\n        b[k], b[s] = b[s], b[k]\n        q.append(b)\n        step_q.append(step + 1)\n\n    if empty % 3 != 2:\n        _swap(q, step_q, step, board, empty, empty + 1)\n    if empty % 3 != 0:\n        _swap(q, step_q, step, board, empty, empty - 1)\n    if empty // 3 < 2:\n        _swap(q, step_q, step, board, empty, empty + 3)\n    if empty // 3 > 0:\n        _swap(q, step_q, step, board, empty, empty - 3)\n\n\nq = deque([board])\nstep_q = deque([0])\n# print_board(board)\nwhile q[0] != end:\n    b = q.popleft()\n    step = step_q.popleft()\n    swap(q, step_q, step, b)\n# print_board(q.popleft())\nprint(step_q.popleft())\n"
  },
  {
    "language": "Python",
    "code": "#codinh -utf8\nimport sys\nimport copy\n\ngoal_state=[1,2,3,4,5,6,7,8,0]\nopen_list=[]    #????????Â¢?Â´Â¢??????????????????????Â´?\nclosed_list=[]  #??Â¢?Â´Â¢????????????????????????????Â´?\n\n\ndef getH(a, b): #???????????????????????Â¢????Â¨????\n    h2=0\n    i=0\n    for n in a:\n        if n!=-1:   #????????\\??????????????????????????????????????????????????Â¶????????Â§????????Â¢??????????Â±???????\n            j=b.index(n)\n            dist=j-i\n            dist=abs(dist)  #|i??Â¨j??????dist|: ??Â´???????????Â§????????Â¢\n            if dist==1:     #?????Â¢??????????????Â§?Â¨???????????????????????????????????????Â§????????Â¢?????????\n                if (i==2 and j==3) or (j==2 and i==3) or (i==5 and j==6) or (j==5 and i==6):\n                    dist=3\n            elif dist==3:\n                dist=1\n            elif dist==4:\n                if(i!=2 and j!=6) and (i!=6 and j!=2):\n                    dist=2\n            elif dist==5:\n                dist=3\n            elif dist==6:\n                dist=2\n            elif dist==7:\n                dist=3\n            elif dist==8:\n                dist=4\n            h2+=dist    #?????????????????Â¢?????????\n        i+=1\n    return  h2  #?????Â¢??????????????????\n\ndef findChildState(space, std_node):    #???????????????????????????????????????????????????\n    nxt_space=[]    #????????????????????????????????????????????????????Â´?\n    if space==0:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==1:    #???????????????????????????0??????????????????????????Â£?????Â´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==2:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==3:    #??????????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==4:    #????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==5:    #??????????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==6:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n    elif space==7:    #????????????????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n    elif space==8:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n    child_set=[]\n    for i in nxt_space: #???????????????????????????????????????????????Â¶???child_state?????????\n        child_state=copy.deepcopy(std_node[3])\n        child_state[space], child_state[i]=child_state[i], child_state[space]\n        child_set.append(child_state)   #chld_set??????????????????????????????????????????????????Â¶???????????????????Â´???????\n    return child_set\n\ndef openChildNode(std_node):    #?????Â¶??????????????????????????????openlist????????????\n    child_set=findChildState(std_node[3].index(0), std_node)   #???????????????????????????????????????\n    del open_list[0]    #??????????????????openlist??????????????????\n    closed_list.append(std_node)    #??????????????????closedlist???????????????\n    for i in child_set:\n        g=std_node[0]+1\n        h=getH(i, goal_state)\n        f=g+h\n        child=(g,h,f,i) #?????????????????????????????Â°????????\\??????????????Â£???????????????????????????????????Â¶???????Â¨???????child?????????\n        op=list(map(lambda x: i==x[3], open_list))\n        cl=list(map(lambda x: i==x[3], closed_list))\n        if  (True not in op) and (True not in cl):  #openlist??????closedlist????????????????????Â¨?????????????????Â¶??????????????Â´???\n            open_list.append(child) #openlist?????????\n        elif (True in op):  #openlist?????????????????Â¨?????????????????Â¶??????????????Â´???\n            n=op.index(True)\n            if f<open_list[n][2]:   #????????????????????????????????????????????????????Â°????????????Â°openlist????????????????????Â´??Â°\n                open_list[n]=copy.deepcopy(child)\n        elif (True in cl):  #closedlist?????????????????Â¨?????????????????Â¶??????????????Â´???\n            n=cl.index(True)\n            if f<closed_list[n][2]:   #????????????????????????????????????????????????????Â°????????????Â°closedlist??????????????????openlist?????????\n                del closed_list[n]\n                open_list.append(child)\n\ndef updateStandard():   #openlist??????????????????????Â°???????????????????????????????????Â¨??????????\n    min=100000000\n    std=()\n    if open_list==[]:   #openlist??????????????Â´?????Â¢?Â´Â¢??Â±???\n        return -1\n    for i in open_list: #openlist??????????????????????Â°????????????????????Â´Â¢\n        if i[2]<min:\n            min=i[2]\n            std=copy.deepcopy(i)\n    n=open_list.index(std)  #????????????????Â°???????????????????????????????????Â¨????\n    open_list[0], open_list[n]=open_list[n], open_list[0]   #??????????????????openlist?????????????Â§????\n    return std  #????????????????????????\n\n\na=[]\nfor i in sys.stdin:\n    x=list(map(int, i.split()))\n    for j in x:\n        a.append(j)\n\ng=0     #??????????????Â§?????????????????Â°???0\nh=getH(a, goal_state)  #?????\\??????????????Â£?????????????Â¨????\nf=g+h   #??Â´???????????Â§????Â¨Â±???????????????????Â¨????\nstd_node=(g, h, f, a)   #?????????(??????????????Â°????????\\??????????????Â£??????????????????????????????????????Â¶???)??????????????????????Â¨????\nopen_list.append(std_node)\n\nwhile 1:\n    if std_node[3]==goal_state: #????????????????????????????????Â´???????????Â¶?????Â¨?????Â´????????Â°??Â¢?Â´Â¢??????\n        flag=\"Done\"\n        break\n    openChildNode(std_node) #open_list????????????????????????\n    std=updateStandard()    #openlist?????????????????????f???????Â°???????????????????\n    if std==-1: #openlist???????????Â£?????Â´?????Â¢?Â´Â¢??Â±???\n        flag=\"Failed\"\n        break\n    std_node=copy.deepcopy(std)    #?????????????????????????????????????Â°????????????????????????????????Â¨????\n\n\nif flag==\"Done\":    #??Â¢?Â´Â¢?????????????????Â´????????Â´???????????Â§???????????????????????Â°??Â¨????????Â¶????????Â¨???\n    print(std_node[0])\nelif flag==\"Failed\":    #??Â¢?Â´Â¢?????Â±???????????Â´???????????Â¨?????????\n    print(\"Search failed\")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\nfrom collections import deque\n\ndef main():\n    s = []\n    for _ in range(3):\n        s+=list(map(int,input().split()))\n    g = [1,2,3,4,5,6,7,8,0]\n    st = set()\n    inf = 1000000007\n    move = [[1,3],\n            [0,2,4],\n            [1,5],\n            [0,4,6],\n            [1,3,5,7],\n            [2,4,8],\n            [3,7],\n            [4,6,8],\n            [5,7]]\n\n    def bfs():\n        k = 0\n        for i in range(9):\n            if s[i]==0:k = i\n        dq = deque()\n        dq.append([s,k,0])\n        st.add(''.join(map(str,s)))\n        while dq:\n            state = dq.popleft()\n            t,i,steps = state[0],state[1],state[2]\n            if t==g:return steps\n            for j in move[i]:\n                u = copy.copy(t)\n                u[i],u[j] = u[j],u[i]\n                if ''.join(map(str,u)) in st:continue\n                dq.append([u,j,steps+1])\n                st.add( ''.join(map(str,u)))\n\n    print (bfs())\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n     0: {3, 1}}\ngoal = 123456780\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    if MAP == goal:\n        return 0\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            return cnt\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\nimport copy\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9: self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        if is_target(u): return u.path\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3: continue\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if v not in V.keys():\n                V[v] = True\n                v.path += dir[r]\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans = bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\nfrom copy import deepcopy\n\n\nclass Board:\n    def __init__(self, size, nums):\n        self.size = size\n        self.nums = nums\n        self.code = self._code()\n\n    def __eq__(self, other):\n        return self.code == other.code\n\n    def __lt__(self, other):\n        return self.code < other.code\n\n    def __gt__(self, other):\n        return self.code > other.code\n\n    def __hash__(self):\n        nums = tuple(self.nums[i][j]\n                     for i in range(self.size)\n                     for j in range(self.size))\n        return hash(nums)\n\n    def same(self, other):\n        if other is None:\n            return False\n        if self.__class__ != other.__class__:\n            return False\n\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != other.nums[i][j]:\n                    return False\n        return True\n\n    def solved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if (i, j) != self._validpos(self.nums[i][j]):\n                    return False\n        return True\n\n    def _validpos(self, num):\n        if num > 0:\n            return ((num-1) // self.size, (num-1) % self.size)\n        else:\n            return (self.size-1, self.size-1)\n\n    def _code(self):\n        code = 0\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != 0:\n                    vi, vj = self._validpos(self.nums[i][j])\n                    code += abs(vi - i) + abs(vj - j)\n        return code\n\n    def find(self, num):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] == num:\n                    return (i, j)\n        raise IndexError()\n\n    def move(self, p1, p2):\n        i1, j1 = p1\n        i2, j2 = p2\n        nums = deepcopy(self.nums)\n        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]\n        return self.__class__(self.size, nums)\n\n    def moves(self):\n        i, j = self.find(0)\n        if i > 0:\n            yield self.move((i, j), (i-1, j))\n        if j > 0:\n            yield self.move((i, j), (i, j-1))\n        if i < self.size-1:\n            yield self.move((i, j), (i+1, j))\n        if j < self.size-1:\n            yield self.move((i, j), (i, j+1))\n\n    def __str__(self):\n        s = ''\n        for i in range(self.size):\n            for j in range(self.size):\n                s += ' {}'.format(self.nums[i][j])\n            s += '\\n'\n        return s\n\n\nclass EightPuzzle:\n    def __init__(self, board):\n        self.board = Board(3, board)\n        self.steps = 0\n\n        if not self.board.solved():\n            self._solve()\n\n    def _solve(self):\n        bs = []\n        checked = {}\n        heappush(bs, (self.board, 0))\n\n        while len(bs) > 0:\n            b, step = heappop(bs)\n            if 0 < self.steps <= step:\n                continue\n            checked[b] = step\n            for nb in b.moves():\n                if nb.solved():\n                    if self.steps == 0 or step < self.steps:\n                        self.steps = step+1\n                elif nb in checked and checked[nb] <= step:\n                    continue\n                else:\n                    heappush(bs, (nb, step+1))\n\n\ndef run():\n    board = []\n    for i in range(3):\n        board.append([int(i) for i in input().split()])\n\n    eight_puzzle = EightPuzzle(board)\n    print(eight_puzzle.steps)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    def isTarget(p):\n        for i in range(N2):\n            if p[i] != i+1:\n                return False\n        return True\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.deepcopy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\nimport copy\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9: self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if v not in V.keys():\n                V[v] = True\n                v.path += dir[r]\n                if is_target(v):\n                    return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef movable_state(state):\n    x, y = None, None\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] == 0:\n                x, y = i, j\n                break\n\n    rsts = []\n    for r, c in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\n        if 0 <= r and r < 3 and 0 <= c and c < 3:\n            rst = copy.deepcopy(state)\n            rst[x][y], rst[r][c] = rst[r][c], rst[x][y]\n            rsts.append(rst)\n    return rsts\n\ndef hist_check(state, depth):\n    for i in range(depth-1):\n        for hist in state_history[i]:\n            if hist == state:\n                return True\n    return False\n\npuzzle = [list(map(int, input().split(' '))) for i in range(3)]\nstate_history = [[puzzle]]\n\ngoal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nexchange_num = 0\ndepth = 0\nstill_not = True\nwhile still_not:\n    depth += 1\n    state_history.append([])\n    for hist in state_history[depth-1]:\n        next_states = movable_state(hist)\n        for next_stat in next_states:\n            if hist_check(next_stat, depth): continue\n            if next_stat == goal:\n                still_not = False\n                break\n            state_history[depth].append(next_stat)\n        if not still_not: break\nprint(depth)\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n            else:\n                cost += abs(i - (N-1)) + abs(j - (N-1))\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    #print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    #debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n            if not hash_code in closed:\n                #print(hash_code)\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2] + x[3])\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef decision(a):\n    #print(a)\n    #print(data)\n    #print(count)\n    if a == 123456789:\n        print(count)\n        exit()\n    if a in data:\n        pass\n    else:\n        data[a] = 1\n        kariokiba.append(a)\n        #print(a)\n        #print(data)\n\n\ndef str_create(i, j, h):\n    h = h[:i] + h[j] + h[i+1:j] + h[i] + h[j+1:]\n    #print(h)\n    decision(int(h))\n\n\ndef create(a):\n    #print(a)\n    a = str(a)\n    place = a.find('9')\n    #print(place)\n    b = c = d = e = a\n    if place == 0:\n        str_create(0, 1, b)\n        str_create(0, 3, c)\n    elif place == 1:\n        str_create(0, 1, b)\n        str_create(1, 2, c)\n        str_create(1, 4, d)\n    elif place == 2:\n        str_create(1, 2, b)\n        str_create(2, 5, c)\n    elif place == 3:\n        str_create(0, 3, b)\n        str_create(3, 4, c)\n        str_create(3, 6, d)\n    elif place == 4:\n        str_create(1, 4, b)\n        str_create(3, 4, c)\n        str_create(4, 5, d)\n        str_create(4, 7, e)\n    elif place == 5:\n        str_create(2, 5, b)\n        str_create(4, 5, c)\n        str_create(5, 8, d)\n    elif place == 6:\n        str_create(3, 6, b)\n        str_create(6, 7, c)\n    elif place == 7:\n        str_create(6, 7, b)\n        str_create(4, 7, c)\n        str_create(7, 8, d)\n    elif place == 8:\n        str_create(5, 8, b)\n        str_create(7, 8, c)\n\n\n\ntmp0 = [list(map(int, input().split())) for _ in range(3)]\ndata = {}\ntmp1 = 0\nkariokiba = []\nkariokiba1 = []\nfor i in tmp0:\n    for j in i:\n        if j == 0:\n            j = 9\n        tmp1 *= 10\n        tmp1 += j\ndata[tmp1] = 1\n#print(data)\n#print(tmp1)\ntmp1 = str(tmp1)\ncount = 0\nkariokiba.append(int(tmp1))\n\nif tmp1 == '123456789':\n    print(0)\n    exit()\n'''\ncreate(tmp1)\nprint(kariokiba)\n#print(data)\n\n'''\nwhile True:\n    #print(kariokiba)\n    kariokiba1 = copy.deepcopy(kariokiba)\n    kariokiba.clear()\n    count += 1\n    #print(count)\n    #print(data)\n    for i in kariokiba1:\n        create(i)\n\n\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\nimport heapq as hq\n\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev:\n            continue\n        b = board.copy()\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\n\ndef search(start):\n    FORE = 1\n    BACK = -1\n\n    table = {}\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(goal)] = (BACK, 0)\n\n    heap = [(0, start, start.index(0), None, FORE), (0, goal, goal.index(0), None, BACK)]\n\n    while heap:\n        i, board, space, prev, direction = hq.heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction:\n                    return table[key][1] + i\n            table[key] = (direction, i)\n            hq.heappush(heap, (i, b, b.index(0), nxt, direction))\n\nadjacent = (\n    (1, 3),\n    (0, 2, 4),\n    (1, 5),\n    (0, 4, 6),\n    (1, 3, 5, 7),\n    (2, 4, 8),\n    (3, 7),\n    (4, 6, 8),\n    (5, 7),\n)\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nstart = []\n\nfor _ in range(3):\n    x = list(map(int, input().split()))\n    start += x\n\nprint(search(start))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n        if n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1                                                    \n            Q.put(v)\n\nprint(u[2])\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i-1,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i+1,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j-1,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j+1,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, raw_input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import time\nimport math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __hash__(self):\n        return hash(self.board)\n\n    def __bool__(self):\n        return True\n\nclass Board:\n    # The 8-puzzle board representation #\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n\n        if len(thisMatrix) != len(otherMatrix):\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n\n        return s\n\n\ndef fastSearch(frontier, goalBoard, explored):\n    curNode = frontier.pop(0)\n    explored.add(curNode)\n    if curNode.board == goalBoard:\n        print(curNode.depth)\n        return True\n    aStarExpansion(curNode, frontier, goalBoard, explored)\n    return False\n\n\ndef fastSearchClient(board, goalBoard):\n    frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    explored = set()\n\n    limit = 0\n\n    while (limit < 1000):\n        retval = fastSearch(frontier, goalBoard, explored)\n        if retval:\n            return\n        limit += 1\n    return\n\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\narr = [[1 for i in range(3)] for j in range(3)]\n\nfor i in range(3):\n    arr[i][0], arr[i][1], arr[i][2] = input().split()\n\n\nfor i in range(3):\n    for j in range(3):\n        arr[i][j] = int(arr[i][j])\n\nfastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        cost, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = cost - c_depth\n        if(_sum_cost == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(cost > depth):\n            continue\n\n        c_cost = HS(_i,_j,c_puz[_i*3+_j])\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i-1,_j,c_puz[(_i-1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i-1,_j,swap_puz[(_i-1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i+1,_j,c_puz[(_i+1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i+1,_j,swap_puz[(_i+1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz,)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j-1,c_puz[_i*3+_j-1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j-1,swap_puz[_i*3+_j-1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j+1,c_puz[_i*3+_j+1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j+1,swap_puz[_i*3+_j+1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n\ndef sumCost(puz):\n    value = 0\n    for i in range(3):\n        value += HS(i,0,puz[i*3])\n        value += HS(i,1,puz[i*3+1])\n        value += HS(i,2,puz[i*3+2])\n    return value\n\ndef HS(i,j,num):\n    if(num != 0):\n        k = num-1\n    else:\n        k = 8\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj)\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost = sumCost(puz)\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = HS(puz)\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\nadjacent=((1,3), (0,2,4), (1,5), (0,4,6), (1,3,5,7), (2,4,8), (3,7), (4,6,8), (5,7))\n \nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n \ndef bf_search(start, GOAL):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    table = {}\n    table[tuple(start)] = True\n    while not q.empty():\n        a = q.get()\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n            key = tuple(b)\n            if key in table: continue\n            c = State(b,x,a)\n            if b == GOAL:\n                return print_answer(c)\n            q.put(c)\n            table[key] = True\n \ncnt = -1\ndef print_answer(x):\n    global cnt\n    if x is not None:\n        cnt += 1\n        print_answer(x.prev)\n    return str(cnt)\n \nGOAL = [1,2,3,4,5,6,7,8,0]\nstart = []\nfor i in range(3):\n x,y,z = map(int, input().split())\n start += [x,y,z]\n\nif start == GOAL:\n    print(\"0\")\nelse:\n    print(bf_search(start, GOAL))"
  },
  {
    "language": "Python",
    "code": "# 8 Puzzle\nimport copy\nz = 0\n[N, d] = [3, 0]\ncheck_flag = [[1, 2, 3, 4,  1, 2, 3, 4,  1, 2, 3, 4],\n              [2, 3, 4, 1,  2, 3, 4, 1,  2, 3, 4, 1],\n              [3, 4, 1, 2,  3, 4, 1, 2,  3, 4, 1, 2],\n              [4, 1, 2, 3,  4, 1, 2, 3,  4, 1, 2, 3],\n              [3, 2, 1, 4,  3, 2, 1, 4,  3, 2, 1, 4],\n              [2, 1, 4, 3,  2, 1, 4, 3,  2, 1, 4, 3],\n              [1, 4, 3, 2,  1, 4, 3, 2,  1, 4, 3, 2],\n              [4, 3, 2, 1,  4, 3, 2, 1,  4, 3, 2, 1]]\n\nstart = []\ngoal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]\ngoal[2][2] = 0\nfor i in range(N):\n    start.append(list(map(int, input().split())))\n\n\ndef manhattan(value, pairs):\n    h = 0\n\n    if value == 1:\n        h = (pairs[0] + pairs[1])\n    if value == 2:\n        h = (pairs[0] + abs(pairs[1] - 1))\n    if value == 3:\n        h = (pairs[0] + abs(pairs[1] - 2))\n    \n    if value == 4:\n        h = (abs(pairs[0] - 1) + pairs[1])\n    if value == 5:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) \n    if value == 6:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))\n        \n    if value == 7:\n        h = (abs(pairs[0] - 2) + pairs[1])      \n    if value == 8:\n        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))\n        \n    return h\n\ndef flag_array(flag, input):\n\n    flag.pop(0)\n    flag.append(input)\n    return flag\n\n\ns_h = 0\nfor i in range(N):\n    for j in range(N):\n        s_h += manhattan(start[i][j], [i, j])\n\n# print(s_h)\n\nfor i in range(N):\n        check = start[i].count(0)\n        if check != 0:\n            [s_r, s_c] = [i, start[i].index(0)]\n            break\n        if i == 3:\n            print(\"Error\")\n\nwhile True:\n    d += 1\n    queue = []\n    flag = [0 for i in range(12)]\n    queue.append([s_h, start, 0, [s_r, s_c], flag])\n\n    #while True:\n    while len(queue) != 0:\n        #print(\"Q: \", len(queue), \"depth: \", d)\n        short_n = queue.pop(0)\n        h = short_n[0] - short_n[2]\n        state = short_n[1]\n        g = short_n[2]\n        [r, c] = short_n[3]\n        flag = short_n[4]\n        #print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"state: \", state, \"g+h: \", short_n[0], \"flag: \", flag[len(flag) - 1])\n        #print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"flag: \", flag, \"g+h: \", short_n[0])\n        #if d == 1:\n            #print(short_n[0])\n            #print(state)\n            #print(g)\n\n        if h == 0:\n            print(short_n[2])\n            #print(z)\n            break\n        \"\"\"\n        if flag in check_flag:\n            z += 1\n            continue\n        \"\"\"\n        if r - 1 >= 0 and flag[len(flag) - 1] != 3:\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])\n            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]\n            #if temp[r][c] != goal[r][c]:\n            #[r, c] = [r - 1, c]\n            #if temp\n            #h = manhattan(temp)\n            #print(\"1: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r - 1, c], flag_array(temp_array, 1)])\n        \n        if c + 1 < N and flag[len(flag) - 1] != 4:\n            #print(\"2: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])\n            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"2: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c + 1], flag_array(temp_array, 2)])\n\n        if r + 1 < N and flag[len(flag) - 1] != 1:\n            #print(\"3: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])\n            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"3: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r + 1, c], flag_array(temp_array, 3)])\n        \n        if c - 1 >= 0 and flag[len(flag) - 1] != 2:\n            #print(\"4: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])\n            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c - 1], flag_array(temp_array, 4)])\n                \n        queue.sort(key = lambda data:data[0])\n        queue.sort(key = lambda data:data[2], reverse = True)\n\n        data = []\n        g_data = []\n        #print(queue)\n        \"\"\"\n        for i in range(len(queue)):\n            data.append(str(queue[i][0]))\n            g_data.append(str(queue[i][2]))\n            #print(queue[i])\n        print(\"g+h: \",' '.join(data))\n        print(\"g: \",' '.join(g_data))\n        \"\"\"\n        #if d == 1:\n        #print(len(queue))\n\n    if state == goal:\n        break\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl):\n      return pzl.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 8765432\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/100;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "# 8 Puzzle\nimport copy\nz = 0\n[N, d] = [3, 0]\ncheck_flag = [[1, 2, 3, 4,  1, 2, 3, 4,  1, 2, 3, 4],\n              [2, 3, 4, 1,  2, 3, 4, 1,  2, 3, 4, 1],\n              [3, 4, 1, 2,  3, 4, 1, 2,  3, 4, 1, 2],\n              [4, 1, 2, 3,  4, 1, 2, 3,  4, 1, 2, 3],\n              [3, 2, 1, 4,  3, 2, 1, 4,  3, 2, 1, 4],\n              [2, 1, 4, 3,  2, 1, 4, 3,  2, 1, 4, 3],\n              [1, 4, 3, 2,  1, 4, 3, 2,  1, 4, 3, 2],\n              [4, 3, 2, 1,  4, 3, 2, 1,  4, 3, 2, 1]]\n\nstart = []\ngoal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]\ngoal[2][2] = 0\nfor i in range(N):\n    start.append(list(map(int, input().split())))\n\n\ndef manhattan(value, pairs):\n    h = 0\n\n    if value == 1:\n        h = (pairs[0] + pairs[1])\n    if value == 2:\n        h = (pairs[0] + abs(pairs[1] - 1))\n    if value == 3:\n        h = (pairs[0] + abs(pairs[1] - 2))\n    \n    if value == 4:\n        h = (abs(pairs[0] - 1) + pairs[1])\n    if value == 5:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) \n    if value == 6:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))\n        \n    if value == 7:\n        h = (abs(pairs[0] - 2) + pairs[1])      \n    if value == 8:\n        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))\n        \n    return h\n\ndef flag_array(flag, input):\n\n    flag.pop(0)\n    flag.append(input)\n    return flag\n\n\ns_h = 0\nfor i in range(N):\n    for j in range(N):\n        s_h += manhattan(start[i][j], [i, j])\n\n# print(s_h)\n\nfor i in range(N):\n        check = start[i].count(0)\n        if check != 0:\n            [s_r, s_c] = [i, start[i].index(0)]\n            break\n        if i == 3:\n            print(\"Error\")\n\nwhile True:\n    d += 1\n    queue = []\n    flag = [0 for i in range(12)]\n    queue.append([s_h, start, 0, [s_r, s_c], flag])\n\n    #while True:\n    while len(queue) != 0:\n        #print(\"Q: \", len(queue), \"depth: \", d)\n        short_n = queue.pop(0)\n        h = short_n[0] - short_n[2]\n        state = short_n[1]\n        g = short_n[2]\n        [r, c] = short_n[3]\n        flag = short_n[4]\n        print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"state: \", state, \"g+h: \", short_n[0], \"flag: \", flag[len(flag) - 1])\n        #print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"flag: \", flag, \"g+h: \", short_n[0])\n        #if d == 1:\n            #print(short_n[0])\n            #print(state)\n            #print(g)\n\n        if h == 0:\n            print(short_n[2])\n            print(z)\n            break\n        \"\"\"\n        if flag in check_flag:\n            z += 1\n            continue\n        \"\"\"\n        if r - 1 >= 0 and flag[len(flag) - 1] != 3:\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])\n            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]\n            #if temp[r][c] != goal[r][c]:\n            #[r, c] = [r - 1, c]\n            #if temp\n            #h = manhattan(temp)\n            #print(\"1: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r - 1, c], flag_array(temp_array, 1)])\n        \n        if c + 1 < N and flag[len(flag) - 1] != 4:\n            #print(\"2: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])\n            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"2: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c + 1], flag_array(temp_array, 2)])\n\n        if r + 1 < N and flag[len(flag) - 1] != 1:\n            #print(\"3: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])\n            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"3: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r + 1, c], flag_array(temp_array, 3)])\n        \n        if c - 1 >= 0 and flag[len(flag) - 1] != 2:\n            #print(\"4: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])\n            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c - 1], flag_array(temp_array, 4)])\n                \n        queue.sort(key = lambda data:data[0])\n        queue.sort(key = lambda data:data[2], reverse = True)\n\n        data = []\n        g_data = []\n        #print(queue)\n        \"\"\"\n        for i in range(len(queue)):\n            data.append(str(queue[i][0]))\n            g_data.append(str(queue[i][2]))\n            #print(queue[i])\n        print(\"g+h: \",' '.join(data))\n        print(\"g: \",' '.join(g_data))\n        \"\"\"\n        #if d == 1:\n        #print(len(queue))\n\n    if state == goal:\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\n\nclass P(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n\n    def __hash__(self):\n        return hash(str(self[:]))\n\n\ndef is_target(p):\n    return p[:] == ans[:]\n\n\nN = 3\nN2 = N*N\nans = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# space index\nsi = 0\n\n# move\ndx = (-1, 0, 1, 0)\ndy = (0, -1, 0, 1)\ndirection = ('u', 'l', 'd', 'r')\n\n\ndef bfs(p):\n    Q = deque()\n    Q.append(p)\n    V = set()\n    V.add(p)\n\n    while Q:\n        u = Q.popleft()\n        if u == ans:\n            return u.path\n        sx = u.space // N\n        sy = u.space % N\n        for i in range(4):\n            tx = sx + dx[i]\n            ty = sy + dy[i]\n            if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                continue\n            v = P()\n            v[:] = u[:]\n            v.path = u.path\n            c = int(tx*N+ty)\n            v[u.space] = v[c]\n            v[c] = 9\n            v.space = c\n            if v not in V:\n                V.add(v)\n                v.path += direction[i]\n                Q.append(v)\n\n\np = P()\nfor i in range(N):\n    line = sys.stdin.readline()\n    a, b, c = map(int, line.split())\n    p.append(a)\n    p.append(b)\n    p.append(c)\nfor i in range(N2):\n    if p[i] == 0:\n        p[i] = 9\n        p.space = i\n\nre = bfs(p)\nprint(len(re))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Puzzle:\n    def __init__(self, ls, answer_flag=False):\n        self.piece_vec = list(ls)\n        self.update_value = [-3, 3, -1, 1]\n        for idx, piece in enumerate(ls):\n            if piece == 0:\n                self.space_idx = idx\n        \n        self.space_idx_before_slide = deque()\n        self.manhattan_distance = list()\n        if answer_flag:\n            for i in range(9):\n                self.manhattan_distance.append([(abs(i % 3 - j % 3) + abs(i // 3 - j // 3)) for j in range(9)])\n                    \n        \n    def GetManhattanDistance(self, ans_idx, idx):\n        return self.manhattan_distance[ans_idx][idx]\n        \n    def SumManhattanDistance(self, answer_board):\n        sum_MD = 0\n        for idx, piece in enumerate(self.piece_vec):\n            if piece == 0:\n                continue\n            answer_idx = piece - 1\n            sum_MD += answer_board.GetManhattanDistance(answer_idx, idx)\n        return sum_MD\n    \n    def SlideSpace(self, command):\n        is_frame = [self.space_idx < 3, self.space_idx >= 6, self.space_idx % 3 == 0, self.space_idx % 3 == 2]\n        if is_frame[command]:\n            return False\n        \n        next_space_idx = self.space_idx + self.update_value[command]\n        if len(self.space_idx_before_slide) > 0 and next_space_idx == self.space_idx_before_slide[-1]:\n            return False\n        \n        self.piece_vec[self.space_idx], self.piece_vec[next_space_idx] = self.piece_vec[next_space_idx], self.piece_vec[self.space_idx]\n        self.space_idx_before_slide.append(self.space_idx)\n        self.space_idx = next_space_idx\n        return True\n    \n    def BackState(self):\n        self.piece_vec[self.space_idx], self.piece_vec[self.space_idx_before_slide[-1]] = self.piece_vec[self.space_idx_before_slide[-1]], self.piece_vec[self.space_idx]\n        self.space_idx = self.space_idx_before_slide.pop()\n\ndef SolvePuzzleByDFS(board, answer_board, limit, depth = 0):\n    if board.SumManhattanDistance(answer_board) == 0:\n        return True\n    \n    if depth + board.SumManhattanDistance(answer_board) > limit:\n        return False\n    \n    for command in range(4):\n        if board.SlideSpace(command) == False:\n            continue\n        \n        if SolvePuzzleByDFS(board, answer_board, limit, depth+1):\n            return True\n        board.BackState()\n    \n    return False\n\ndef CalcMinStepOf15Puzzle(board, answer_board):\n    for limit in range(board.SumManhattanDistance(answer_board), 35):\n        if SolvePuzzleByDFS(board, answer_board, limit):\n            return limit\n    \n    return -1\n\ndef main():\n    inputLs = list()\n    answerLs = [ 1, 2, 3,\n                 4, 5, 6, \n                 7, 8, 9]\n    for _ in range(3):\n        inputLs += list(map(int, input().split()))\n\n    start_board = Puzzle(inputLs)\n    answer_board = Puzzle(answerLs, True)\n    \n    min_step = CalcMinStepOf15Puzzle(start_board, answer_board);\n    \n    print(min_step)\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = tuple(sum([input().split() for _ in range(N)], []))\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = {MAP}\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        yx = y * N + x\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = list(deepcopy(M))\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                CM = tuple(CM)\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\nN = 3\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = MAP.find(\"0\")\n    goal = \"123456780\"\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nadjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev  = prev\n\n\ndef bf_search(start):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n\n    table = {}\n    table[tuple(start)] = True\n\n    while not q.empty():\n        a = q.get()\n\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n\n            key = tuple(b)\n\n            if key in table: continue\n\n            c = State(b, x, a)\n\n            if b == GOAL:\n                print_answer(c)\n                return\n\n            q.put(c)\n            table[key] = True\n\n\n# æé ã®è¡¨ç¤º\ndef print_answer(x):\n    count = 0\n\n    while x.prev != None:\n        x = x.prev\n        count += 1\n\n    print(count)\n\n\n\nif(__name__ == '__main__'):\n    p = []\n    for i in range(3):\n        p.extend([int(x) for x in input().split()])\n\n    print(p)\n    bf_search(p)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappush, heappop\nfrom collections import deque\nfrom copy import deepcopy, copy\nN = 3\nm = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef MAIN():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    goal = \"123456780\"\n    if MAP == goal:\n        print(0)\n        return\n    start = MAP.find(\"0\")\n    dp = [(0, MAP, start)]\n    LOG = {MAP}\n    while dp:\n        cnt, M, yx = heappop(dp)\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                if CM == goal:\n                    print(cnt)\n                    return\n                heappush(dp, (cnt, CM, nyx))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((sumcost,0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\nf = lambda x: \"\\n\".join(\" \".join(map(str, x[i])) for i in range(3))\ndef MAIN():\n    MAP = [list(map(int, input().split())) for _ in range(N)]\n    start = divmod(sum(MAP, []).index(0), N)\n    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    ans = 0\n    dp = deque([[start[0], start[1], 0, MAP]])\n    LOG = [MAP]\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = deepcopy(M)\n                CM[y][x], CM[ny][nx] = CM[ny][nx], CM[y][x]\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.append(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\ndef get_patten(B):\n    return ''.join(map(str, B))\n\ndef change_left(index, B):\n    C = B.copy()\n    C[index], C[index - 1] = C[index - 1], C[index]\n    return C\n\ndef change_right(index, B):\n    C = B.copy()\n    C[index], C[index + 1] = C[index + 1], C[index]\n    return C\n\ndef change_top(index, B):\n    C = B.copy()\n    C[index], C[index - 3] = C[index - 3], C[index]\n    return C\n\ndef change_bottom(index, B):\n    C = B.copy()\n    C[index], C[index + 3] = C[index + 3], C[index]\n    return C\n\n# main\nboad = []\nfor i in range(3):\n    boad.extend(map(int, input().split()))\nexist_patten = set()\n\nq = []\nq.append((boad, None, 0))\n\nwhile len(q) > 0:\n    B, prev, count = q.pop(0)\n    p = get_patten(B)\n    if p in exist_patten:\n        continue\n    exist_patten.add(p)\n    if p == '123456780':\n        print(count)\n        exit()\n\n    index = B.index(0)\n\n    if index % 3 != 0 and prev != 'right':\n        C = change_left(index, B)\n        q.append((C, 'left', count + 1))\n\n    if index % 3 != 2 and prev != 'left':\n        C = change_right(index, B)\n        q.append((C, 'right', count + 1))\n\n    if index >= 3 and prev != 'bottom':\n        C = change_top(index, B)\n        q.append((C, 'top', count + 1))\n\n    if index <= 5 and prev != 'top':\n        C = change_bottom(index, B)\n        q.append((C, 'bottom', count + 1))"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nend_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nqueue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = {}\nvisited[hashnum(ini_state)] = [0, 0]\nvisited[answer] = [0, 1]\ntrial = 0\nwhile answer not in visited:\n    new_queue = []\n    trial += 1\n    for q in queue:\n        state, zero_x, zero_y, direction = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm in visited and direction != visited[perm][1]:\n                    print(trial + visited[perm][0])\n                    exit()\n                if perm not in visited:\n                    visited[perm] = [trial, direction]\n                    new_queue.append([new_state, new_x, new_y, direction])\n    queue = new_queue"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappush, heappop\nfrom collections import deque\nfrom copy import deepcopy, copy\nN = 3\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = MAP.find(\"0\")\n    goal = \"123456780\"\n    dp = [(0, MAP, start)]\n    LOG = {MAP}\n    while dp:\n        cnt, M, yx = heappop(dp)\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                heappush(dp, (cnt, CM, nyx))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n\tif n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.put(v)\n\nprint(u[2])\n\n"
  },
  {
    "language": "Python",
    "code": "class Queue:\n    '''\n    ããºã«ãªãã¸ã§ã¯ããæ ¼ç´ããã­ã¥ã¼ã¯ã©ã¹\n    '''\n    def __init__(self, puzzle):\n        self.puzzle_list = []\n\n        self.puzzle_list.append(puzzle)\n\n    def enqueue(self, puzzle):\n        self.puzzle_list.append(puzzle)\n\n    def dequeue(self):\n        return self.puzzle_list.pop(0)\n    def is_empty(self):\n        return len(self.puzzle_list) == 0\n\n\nclass _8Puzzle:\n    def __init__(self, panel_list, state_list, size):\n        self.panel_list = panel_list\n\n        self.state_list = state_list\n        self.state_list.append(panel_list)\n\n        self.size = size\n\n    # ããã«ã®0ãå·¦å³ä¸ä¸ã«ç§»åãããã¨ãã®ããã«éç½®ãè¿ãã¸ã§ãã¬ã¼ã¿ã¼\n    def gene_next_panel(self, puzzle):\n        zero_pos = puzzle.panel_list.index(0)\n        col = zero_pos // self.size\n        raw = zero_pos % self.size\n\n        def __get_next_panel():\n            panel_list = puzzle.panel_list[:]\n            n = panel_list[next_pos]\n            panel_list[next_pos] = 0\n            panel_list[zero_pos] = n\n            return panel_list\n\n        if self.size > col + 1:\n            next_pos = (col + 1) * self.size + raw\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n        if col - 1 >= 0:\n            next_pos = (col - 1) * self.size + raw\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n        if self.size > raw + 1:\n            next_pos = col * self.size + raw + 1\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n        if raw - 1 >= 0:\n            next_pos = col * self.size + raw - 1\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n    def result_print(self):\n        i = 0\n        for s in self.state_list:\n            i += 1\n\n        print(i-1)\n\ndef breadth_first(size, goal, panel_list):\n    puzzle = _8Puzzle(panel_list, [], size)\n    queue = Queue(puzzle)\n    checked_dict = {}\n\n    while queue.is_empty() is False:\n        puzzle = queue.dequeue()\n        num = 0\n        for next_panel in puzzle.gene_next_panel(puzzle):\n            next_puzzle = _8Puzzle(list(next_panel), puzzle.state_list[:], size)\n\n            if next_panel in checked_dict:\n                continue\n\n            if list(next_panel) == goal:\n\n                return next_puzzle\n\n            checked_dict[next_panel] = True\n            queue.enqueue(next_puzzle)\n\nif __name__ == '__main__':\n    size = 3\n    goal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n    input_puzzle = []\n    for i in range(3):\n        _in1, _in2, _in3 = (int(z) for z in input().split())\n        input_puzzle.append(_in1)\n        input_puzzle.append(_in2)\n        input_puzzle.append(_in3)\n\n    if goal == input_puzzle:\n        print(0)\n        exit()\n\n    puzzle = breadth_first(size, goal, input_puzzle)\n\n    puzzle.result_print()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nfrom itertools import chain\n\n\ndef get_completed_board(height, width):\n    return [str((i + 1) % (width * height)) for i in range(width * height)]\n\n\ndef serialize_board(board):\n    return \":\".join(board)\n\n\ndef get_empty_pos(board, width, height):\n    for i, cell in enumerate(board):\n        if cell == \"0\":\n            return i\n\n\ndef get_all_possible_next_boards(board, height, width, empty_pos=None):\n    if empty_pos is None:\n        empty_pos = get_empty_pos(board, height, width)\n    next_boards = []\n    x, y = empty_pos % width, empty_pos // height\n    # å·¦ã¨ã®å¥ãæ¿ã\n    if x > 0:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos - 1\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n    # å³ã¨ã®å¥ãæ¿ã\n    if x < width - 1:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos + 1\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n    # ä¸ã¨ã®å¥ãæ¿ã\n    if y > 0:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos - height\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n    # ä¸ã¨ã®å¥ãæ¿ã\n    if y < height - 1:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos + height\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n\n    return next_boards\n\n\ndef resolve(board, height, width):\n    # æ¢ç¥ã®ç¤é¢ãä¿å­\n    known_serialized_boards = set([serialize_board(board)])\n    # æ­£è§£ã®ç¤é¢ãä¿å­\n    completed_board = get_completed_board(width, height)\n    known_serialized_completed_boards = set([serialize_board(completed_board)])\n    if known_serialized_boards & known_serialized_completed_boards:\n        return 0\n    current_boards = [(board, None)]\n    current_completed_boards = [(get_completed_board(width, height), None)]\n    step_count = 1\n    while step_count <= 45:\n        # ã¤ã³ãããå´ã®ç¤é¢ãä¸ã¤é²ãã\n        next_boards = []\n        for board, empty_pos in current_boards:\n            # æ¬¡ã®ã¹ãããã§ã®ç¾ãå¾ãå±é¢ãå¨ã¦åå¾\n            tmp_next_boards = get_all_possible_next_boards(board, height, width, empty_pos)\n            filtered_next_board = []\n            for board, empty_pos in tmp_next_boards:\n                serialized_board = serialize_board(board)\n                if serialized_board not in known_serialized_boards:\n                    known_serialized_boards.add(serialized_board)\n                    filtered_next_board.append((board, empty_pos))\n            next_boards.extend(filtered_next_board)\n\n        if known_serialized_boards & known_serialized_completed_boards:\n            return step_count\n\n        step_count = step_count + 1\n        current_boards = next_boards\n\n        # æ­£è§£ç¤é¢å´ãï¼ã¤é²ãã\n        next_completed_boards = []\n        for board, empty_pos in current_completed_boards:\n            # æ¬¡ã®ã¹ãããã§ã®ç¾ãå¾ãå±é¢ãå¨ã¦åå¾\n            tmp_next_boards = get_all_possible_next_boards(board, height, width, empty_pos)\n            filtered_next_board = []\n            for board, empty_pos in tmp_next_boards:\n                serialized_board = serialize_board(board)\n                if serialized_board not in known_serialized_completed_boards:\n                    known_serialized_completed_boards.add(serialized_board)\n                    filtered_next_board.append((board, empty_pos))\n            next_completed_boards.extend(filtered_next_board)\n\n        if known_serialized_boards & known_serialized_completed_boards:\n            return step_count\n        step_count = step_count + 1\n        current_completed_boards = next_completed_boards\n\n    return None\n\n\ndef main():\n    inputStr = sys.stdin.read()\n    lines = inputStr.split(\"\\n\")\n    lines = filter(lambda line: line, lines)\n    board = list(map(lambda line: line.split(\" \"), lines))\n    height = len(board)\n    width = len(board[0])\n    board = list(chain.from_iterable(board))\n    print(resolve(board, height, width))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#codinh -utf8\nimport sys\nimport copy\n\ngoal_state=[1,2,3,4,5,6,7,8,0]\nopen_list=[]    #????????Â¢?Â´Â¢??????????????????????Â´?\nclosed_list=[]  #??Â¢?Â´Â¢????????????????????????????Â´?\n\n\ndef getH(a, b): #???????????????????????Â¢????Â¨????\n    h2=0\n    i=0\n    for n in a:\n        if n!=-1:   #????????\\??????????????????????????????????????????????????Â¶????????Â§????????Â¢??????????Â±???????\n            j=b.index(n)\n            dist=j-i\n            dist=abs(dist)  #|i??Â¨j??????dist|: ??Â´???????????Â§????????Â¢\n            if dist==1:     #?????Â¢??????????????Â§?Â¨???????????????????????????????????????Â§????????Â¢?????????\n                if (i==2 and j==3) or (j==2 and i==3) or (i==5 and j==6) or (j==5 and i==6):\n                    dist=3\n            elif dist==3:\n                dist=1\n            elif dist==4:\n                if(i!=2 and j!=6) and (i!=6 and j!=2):\n                    dist=2\n            elif dist==5:\n                dist=3\n            elif dist==6:\n                dist=2\n            elif dist==7:\n                dist=3\n            elif dist==8:\n                dist=4\n            h2+=dist    #?????????????????Â¢?????????\n        i+=1\n    return  h2  #?????Â¢??????????????????\n\ndef findChildState(space, std_node):    #???????????????????????????????????????????????????\n    nxt_space=[]    #????????????????????????????????????????????????????Â´?\n    if space==0:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==1:    #???????????????????????????0??????????????????????????Â£?????Â´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==2:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==3:    #??????????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==4:    #????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==5:    #??????????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==6:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n    elif space==7:    #????????????????????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n    elif space==8:    #?????????????????????????????????????????Â£?????Â´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n    child_set=[]\n    for i in nxt_space: #???????????????????????????????????????????????Â¶???child_state?????????\n        child_state=copy.deepcopy(std_node[3])\n        child_state[space], child_state[i]=child_state[i], child_state[space]\n        child_set.append(child_state)   #chld_set??????????????????????????????????????????????????Â¶???????????????????Â´???????\n    return child_set\n\ndef openChildNode(std_node):    #?????Â¶??????????????????????????????openlist????????????\n    child_set=findChildState(std_node[3].index(0), std_node)   #???????????????????????????????????????\n    del open_list[0]    #??????????????????openlist??????????????????\n    closed_list.append(std_node)    #??????????????????closedlist???????????????\n    for i in child_set:\n        g=std_node[0]+1\n        h=getH(i, goal_state)\n        f=g+h\n        child=(g,h,f,i) #?????????????????????????????Â°????????\\??????????????Â£???????????????????????????????????Â¶???????Â¨???????child?????????\n        op=list(map(lambda x: i==x[3], open_list))\n        cl=list(map(lambda x: i==x[3], closed_list))\n        if  (True not in op) and (True not in cl):  #openlist??????closedlist????????????????????Â¨?????????????????Â¶??????????????Â´???\n            open_list.append(child) #openlist?????????\n        elif (True in op):  #openlist?????????????????Â¨?????????????????Â¶??????????????Â´???\n            n=op.index(True)\n            if f<open_list[n][2]:   #????????????????????????????????????????????????????Â°????????????Â°openlist????????????????????Â´??Â°\n                open_list[n]=copy.deepcopy(child)\n        elif (True in cl):  #closedlist?????????????????Â¨?????????????????Â¶??????????????Â´???\n            n=cl.index(True)\n            if f<closed_list[n][2]:   #????????????????????????????????????????????????????Â°????????????Â°closedlist??????????????????openlist?????????\n                del closed_list[n]\n                open_list.append(child)\n\ndef updateStandard():   #openlist??????????????????????Â°???????????????????????????????????Â¨??????????\n    min=100000000\n    std=()\n    if open_list==[]:   #openlist??????????????Â´?????Â¢?Â´Â¢??Â±???\n        return -1\n    for i in open_list: #openlist??????????????????????Â°????????????????????Â´Â¢\n        if i[2]<min:\n            min=i[2]\n            std=copy.deepcopy(i)\n    n=open_list.index(std)  #????????????????Â°???????????????????????????????????Â¨????\n    open_list[0], open_list[n]=open_list[n], open_list[0]   #??????????????????openlist?????????????Â§????\n    return std  #????????????????????????\n\n\na=[]\nfor i in sys.stdin:\n    x=list(map(int, i.split()))\n    for j in x:\n        a.append(j)\n\ng=0     #??????????????Â§?????????????????Â°???0\nh=getH(a, goal_state)  #?????\\??????????????Â£?????????????Â¨????\nf=g+h   #??Â´???????????Â§????Â¨Â±???????????????????Â¨????\nstd_node=(g, h, f, a)   #?????????(??????????????Â°????????\\??????????????Â£??????????????????????????????????????Â¶???)??????????????????????Â¨????\nopen_list.append(std_node)\n\nwhile 1:\n    openChildNode(std_node) #open_list????????????????????????\n    std=updateStandard()    #openlist?????????????????????f???????Â°???????????????????\n    if std==-1: #openlist???????????Â£?????Â´?????Â¢?Â´Â¢??Â±???\n        flag=\"Failed\"\n        break\n    std_node=copy.deepcopy(std)    #?????????????????????????????????????Â°????????????????????????????????Â¨????\n    if std_node[3]==goal_state: #????????????????????????????????Â´???????????Â¶?????Â¨?????Â´????????Â°??Â¢?Â´Â¢??????\n        flag=\"Done\"\n        break\n\nif flag==\"Done\":    #??Â¢?Â´Â¢?????????????????Â´????????Â´???????????Â§???????????????????????Â°??Â¨????????Â¶????????Â¨???\n    print(std_node[0])\nelif flag==\"Failed\":    #??Â¢?Â´Â¢?????Â±???????????Â´???????????Â¨?????????\n    print(\"Search failed\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n     0: {3, 1}}\ngoal = 123456780\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    zero = 8 - MAP.find(\"0\")\n    start = int(MAP)\n    if MAP == goal:\n        return 0\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n    TABLE = {start: (1, 0), goal: (0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((sumcost,0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2 and prev_move != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0 and prev_move != 3):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2 and prev_move != 4):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i*3\n        ki = (int)(k/3)\n        kj = k - ki*3\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import time import math class Node: def __init__(self, board, parent, fValue, depth): self.board = board self.parent = parent self.fValue = fValue self.depth = depth def __eq__(self, other): return self.board == other.board def __lt__(self, other): return self.fValue < other.fValue def __hash__(self): return hash(self.board) def __bool__(self): return True class Board: # The 8-puzzle board representation # def __init__(self, matrix): self.matrix = matrix for i in range(len(matrix)): if 0 in matrix[i]: self.blankPos = (i, matrix[i].index(0)) def __str__(self): s = \"\" for i in range(len(self.matrix)): s += str(self.matrix[i]) + \"\\n\" return s + \"\\n\" def __eq__(self, other): otherMatrix = other.matrix thisMatrix = self.matrix if len(thisMatrix) != len(otherMatrix): return False for i in range(len(thisMatrix)): if len(thisMatrix[i]) != len(otherMatrix[i]): return False for j in range(len(thisMatrix[i])): if thisMatrix[i][j] != otherMatrix[i][j]: return False return True def duplicate(self): newMatrix = [] for i in range(len(self.matrix)): newMatrix.append([]) for j in range(len(self.matrix[i])): newMatrix[i].append(self.matrix[i][j]) return Board(newMatrix) def findElement(self, elem): for i in range(len(self.matrix)): for j in range(len(self.matrix[i])): if self.matrix[i][j] == elem: return (i, j) return None def slideBlank(self, dir): # dir is a tuple (deltaY,deltaX) if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]: raise ValueError(\"Invalid dir\") newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1]) if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1: return None elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1: return None else: newBoard = self.duplicate() saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0 newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1]) return newBoard def __hash__(self): s = 0 for i in range(len(self.matrix)): for j in range(len(self.matrix[i])): s *= 10 s += self.matrix[i][j] return s def fastSearch(frontier, goalBoard, explored): curNode = frontier.pop(0) explored.add(curNode) if curNode.board == goalBoard: print(curNode.depth) return True aStarExpansion(curNode, frontier, goalBoard, explored) return False def fastSearchClient(board, goalBoard): frontier = [Node(board, None, heuristic(board, goalBoard), 0)] explored = set() limit = 0 while (limit < 1000): retval = fastSearch(frontier, goalBoard, explored) if retval: return limit += 1 return # Function to expand the frontier using aStar # def aStarExpansion(currentNode, frontier, goalBoard, explored): sideLength = len(currentNode.board.matrix) pos = currentNode.board.blankPos depth = currentNode.depth + 1 toInsert = [] # if we can move there, make a node and put it in toInsert if pos[0] != 0: upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard) upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth) toInsert.append(upNode) if pos[0] != sideLength - 1: downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard) downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth) toInsert.append(downNode) if pos[1] != 0: leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard) leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth) toInsert.append(leftNode) if pos[1] != sideLength - 1: rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard) rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth) toInsert.append(rightNode) # if we've already been there, we don't want to try that board again for node in explored: for insertNode in toInsert: if insertNode == node: toInsert.remove(insertNode) # now we are putting the nodes to be inserted into the correct place in frontier for node in toInsert: for i in range(len(frontier) + 1): if i == len(frontier): frontier.append(node) break if frontier[i] > node: frontier.insert(i, node) break def heuristic(currentBoard, goalBoard): currentMatrix = currentBoard.matrix sum = 0 for i in range(len(currentMatrix)): for j in range(len(currentMatrix[i])): cur = currentMatrix[i][j] if cur % 3 == 0: curx = 3 else: curx = cur % 3 if cur != 0: sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1)) return sum arr = [[1 for i in range(3)] for j in range(3)] for i in range(3): arr[i][0], arr[i][1], arr[i][2] = input().split() for i in range(3): for j in range(3): arr[i][j] = int(arr[i][j]) fastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n"
  },
  {
    "language": "Python",
    "code": "N = 3\ndx = [0,-1,0,1]\ndy = [1,0,-1,0]\nlimit = 0\nt = [[0 for i in range(N)] for j in range(N)]\n\ndef getH():\n    sum = 0\n    x = int(0)\n    for i in range(N):\n        for j in range(N):\n            if t[i][j]==0:continue\n            x=t[i][j]-1\n            sum += abs(int(x/N)-i)+abs((int(x%N)-j))\n    return sum\n\ndef dfs( depth, prev,py,px):\n    h=getH()\n    if h == 0 :return True \n    if depth+h > limit: return False\n    for i in range(4):\n        if abs(i-prev) == 2 : continue\n        tx=px+dx[i]\n        ty=py+dy[i]\n        if tx<0 or ty<0 or tx>=N or ty>=N:continue\n        t[ty][tx],t[py][px] = t[py][px],t[ty][tx]\n        if dfs(depth+1,i,ty,tx) :return True\n        t[ty][tx],t[py][px] = t[py][px],t[ty][tx]\n    return False\n\ndef Solve(py, px):\n    global limit\n    limit =0\n    while True:\n        if dfs(0,99,py,px):\n            print(limit)\n            return \n        limit += 1\n \nif __name__=='__main__':\n    for i in range(N):\n        tmp =list(map(int, input().split()))\n        for j in range(N):\n            t[i][j]=tmp[j]\n            if t[i][j]==0:\n                py=i\n                px=j\n    Solve(py,px)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\n# Bidirectional search using breadth-first search\ndef solve(start, goal):\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n    step = {start: 0, goal: 0}\n    s = 0\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n    while True:\n        q = iter(c_d)\n        c_d = []\n        s += 1\n        for c, d in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n\nprint(solve(init, '123456780'))"
  },
  {
    "language": "Python",
    "code": "import copy\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\n\ndef calc_cost(game):\n    cost = 0\n\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\n\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n\n            if tmp_cost <= current[2]:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2])\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n            \n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = sumcost\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+sumCost(_costs)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(puz),(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = q.pop(0)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(swap_puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+c_dWithH) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import time\nimport math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __hash__(self):\n        return hash(self.board)\n\n    def __bool__(self):\n        return True\n\nclass Board:\n    # The 8-puzzle board representation #\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n\n        if len(thisMatrix) != len(otherMatrix):\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n\n        return s\n\n\ndef fastSearch(frontier, goalBoard, explored):\n    curNode = frontier.pop(0)\n    explored.add(curNode)\n    if curNode.board == goalBoard:\n        print(curNode.depth)\n        return True\n    aStarExpansion(curNode, frontier, goalBoard, explored)\n    return False\n\n\ndef fastSearchClient(board, goalBoard):\n    frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    explored = set()\n\n    limit = 0\n\n    while (limit < 1000):\n        retval = fastSearch(frontier, goalBoard, explored)\n        if retval:\n            return\n        limit += 1\n    return\n\n# Function to expand the frontier using aStar #\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\narr = [[1 for i in range(3)] for j in range(3)]\n\nfor i in range(3):\n    arr[i][0], arr[i][1], arr[i][2] = raw_input().split()\n\n\nfor i in range(3):\n    for j in range(3):\n        arr[i][j] = int(arr[i][j])\n\nfastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nfrom typing import List, Tuple\n\n\ndef _generate_goal() -> List[List[int]]:\n    goal = [[0] * 3 for _ in range(3)]\n    for row in range(3):\n        for col in range(3):\n            if 9 == 3 * row + col + 1:\n                goal[row][col] = 0\n            else:\n                goal[row][col] = 3 * row + col + 1\n    return goal\n\n\ndef _find_zero_pos(board: List[List[int]]) -> Tuple[int, int]:\n    for row in range(3):\n        for col in range(3):\n            if 0 == board[row][col]:\n                return (row, col)\n    # Never reaches here.\n    return (-1, -1)\n\n\ndef _swappable_cand(zero_pos: Tuple[int, int]) -> List[Tuple[int, int]]:\n    row, col = zero_pos[0], zero_pos[1]\n    cand_pos_list: List[Tuple[int, int]] = []\n    if 0 != row:\n        cand_pos_list.append((row - 1, col))\n    if 2 != row:\n        cand_pos_list.append((row + 1, col))\n    if 0 != col:\n        cand_pos_list.append((row, col - 1))\n    if 2 != col:\n        cand_pos_list.append((row, col + 1))\n\n    return cand_pos_list\n\n\ndef solve_8puzzle(board: List[List[int]]) -> int:\n    goal = _generate_goal()\n    if board == goal:\n        return 0\n    generated_boards = {tuple(sum(board, [])): 0, tuple(sum(goal, [])): 1}\n    steps = {tuple(sum(board, [])): 0, tuple(sum(goal, [])): 0}\n    step = 0\n    state = [(board, 0), (goal, 1)]\n    while state:\n        state_copied = copy.deepcopy(state)\n        state = []\n        step += 1\n        for s2, d in state_copied:\n            zero_row, zero_col = _find_zero_pos(s2)\n            cand_pos_list = _swappable_cand((zero_row, zero_col))\n            for (row, col) in cand_pos_list:\n                s1 = copy.deepcopy(s2)\n                s1[zero_row][zero_col], s1[row][col] = s1[row][col], 0\n                key = tuple(sum(s1, []))\n                if key in generated_boards:\n                    if generated_boards[key] != d:\n                        return step + steps[key]\n                    continue\n                state.append((s1, d))\n                generated_boards[key] = d\n                steps[key] = step\n    # Never reaches here.\n    return -1\n\n\nif __name__ == \"__main__\":\n    board = [[0] * 3 for _ in range(3)]\n\n    for row in range(3):\n        input_nums = list(map(lambda x: int(x), input().split()))\n        for col in range(3):\n            # if 0 == input_nums[col]:\n            #     zero_pos = (row, col)\n            board[row][col] = input_nums[col]\n\n    print(f\"{solve_8puzzle(board)}\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef movable_state(state):\n    x, y = None, None\n    for i in range(3):\n        for j in range(3):\n            if state[3*i+j] == 0:\n                x, y = i, j\n                break\n\n    rsts = []\n    for r, c in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\n        if 0 <= r and r < 3 and 0 <= c and c < 3:\n            rst = copy.copy(state)\n            rst[3*x+y], rst[3*r+c] = rst[3*r+c], rst[3*x+y]\n            rsts.append(rst)\n    return rsts\n\ndef hist_check(state, depth):\n    for i in range(depth-2, -1, -1):\n        for hist in state_history[i]:\n            if hist == state:\n                return True\n    return False\n\npuzzle = []\nfor i in range(3):\n    puzzle.extend(list(map(int, input().split(' '))))\nstate_history = [[puzzle]]\n\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nexchange_num = 0\ndepth = 0\nstill_not = True\nwhile still_not:\n    depth += 1\n    state_history.append([])\n    for hist in state_history[depth-1]:\n        next_states = movable_state(hist)\n        for next_stat in next_states:\n            if hist_check(next_stat, depth): continue\n            if next_stat == goal:\n                still_not = False\n                break\n            state_history[depth].append(next_stat)\n        if not still_not: break\nprint(depth)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+sumCost(_costs)) >= depth or (c_depth+simpleHS(c_puz) >= depth)):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nMOVE = {'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0)}\n\ndef next(numbers):\n    for d in 'UDLR':\n        z = numbers.index(0)\n        tx, ty = z % 3 + MOVE[d][0], z // 3 + MOVE[d][1]\n        if 0 <= tx < 3 and 0 <= ty < 3:\n            t = ty * 3 + tx\n            result = list(numbers)\n            result[z], result[t] = numbers[t], 0\n            yield d, tuple(result)\n\ndef bfs(puzzle):\n    queue = deque([(puzzle, '')])\n    seen = set()\n    while queue:\n        numbers, route = queue.popleft()\n        seen.add(numbers)\n        if numbers == (1, 2, 3, 4, 5, 6, 7, 8, 0):\n            return route\n        for direction, new_numbers in next(numbers):\n            if new_numbers not in seen:\n                queue.append((new_numbers, route + direction))\n    return route\n\npuzzle = ()\nfor i in range(3):\n    a,b,c = map(int, input().split())\n    puzzle += (a,b,c)\n\nprint(len(bfs(puzzle)))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys\n\n\nM = [list(map(int,input().split())) for _ in range(3)]\n\nstart = 0\nfor i in range(3):\n    for j in range(3):\n        start += M[i][j]*10**((2-i)*3 + (2-j))\nstart = \"{:0>9}\".format(start)\n\ndef make_next_states(h,w,s):\n    ret = []\n    x = [-1,0,1,0]\n    y = [0,-1,0,1]\n    for i in range(4):\n        nh,nw = h+y[i],w+x[i]\n        if (0<=nh<=2) and (0<=nw<=2):\n            swap_ind = nh*3 + nw\n            char = s[swap_ind]\n            next_s = s.replace(char,\"x\").replace(\"0\",char).replace(\"x\",\"0\")\n            ret.append(next_s)\n    return ret\n\nfinished = defaultdict(bool)\nfinished[start] = True\n\nq = deque()\nq.append([start,0])\nwhile 1:\n    s,n = q.popleft()\n    finished[s] = True\n    if s == \"123456780\":\n        break\n    null = s.index(\"0\")\n    null_h = null//3\n    null_w = null%3\n    next_states = make_next_states(null_h,null_w,s)\n    for next_s in next_states:\n        if not finished[next_s]:\n            q.append([next_s,n+1])\n\nprint(n)\n    \n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "def iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "N = 3\n#f = [input().split() for _ in range(3)]\nf = input().split()\nf += input().split()\nf += input().split()\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = [[f, f.index(\"0\"), 0]]\n#T = {f: True}\nT = set(f)\n\nwhile len(Q) > 0:\n    board = Q.pop(0)\n    if board[0] == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"0\"]:\n        break\n    x, y = int(board[1]/N), board[1]%N\n    for dx, dy in dd:\n        tx, ty = x+dx, y+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N:\n            continue\n        new = board[:]\n\n        n1, n2 = board[1], tx*N+ty\n        new[1] = n2\n        # swap\n        if n1 > n2:\n            n1, n2 = n2, n1\n        # swaped string\n        new[0] = new[0][0:n1] + list(new[0][n2]) + new[0][n1+1:n2] + list(new[0][n1]) + new[0][n2+1:]\n        hashstr = \"\".join(new[0])\n        if hashstr not in T:\n            #T[new[0]] = True\n            T.add(hashstr)\n            new[2] += 1\n            Q.append(new)\n\nprint(board[2])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n        if(finding == 1):\n            return\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n        if(finding == 1):\n            return\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n        if(finding == 1):\n            return\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, raw_input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x = (i+1)%3\n        y = (i+1)//3\n        if y == 3:\n            y = 0\n        dx = abs(node_list[i]%3 - x)\n        dy = abs(node_list[i]//3 - y)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nend_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nqueue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = {}\nif hashnum(ini_state) == answer:\n    print(0)\nelse:\n    visited[hashnum(ini_state)] = [0, 0]\n    visited[answer] = [0, 1]\n    trial = 0\n    ended = 0\n    while queue:\n        new_queue = []\n        trial += 1\n        for q in queue:\n            if ended:\n                break\n            state, zero_x, zero_y, direction = q\n            for i in range(len(dx)):\n                new_state = copy.deepcopy(state)\n                new_x = zero_x + dx[i]\n                new_y = zero_y + dy[i]\n                if 0 <= new_x < 3 and 0 <= new_y < 3:\n                    new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                    perm = hashnum(new_state)\n                    if perm in visited and direction != visited[perm][1]:\n                        print(trial + visited[perm][0])\n                        ended = 1\n                        break\n                    elif perm not in visited:\n                        visited[perm] = [trial, direction]\n                        new_queue.append([new_state, new_x, new_y, direction])\n        queue = new_queue"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x = (i+1)%3\n        y = (i+1)//3\n        if y == 3:\n            y = 0\n        dx = abs(node_list[i]%3 - x)\n        dy = abs(node_list[i]//3 - y)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append(sumcost,0,i,j,0,puz)\n    global finding\n\n    while len(q):\n        c_dWithH, items = q.pop(0)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),c_depth+1,_i-1,_j,2,swap_puz)\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),c_depth+1,_i+1,_j,1,swap_puz)\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),c_depth+1,_i,_j-1,4,swap_puz)\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),c_depth+1,_i,_j+1,3,swap_puz)\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle()\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if not (0<= tx < N and 0 <= ty < N):\n                    continue\n                v = Puzzle()\n                v[:] = u[:]\n                v.path = u.path\n                change = tx * N + ty\n                v[u.space], v[change] = v[change], v[u.space]\n                v.space = change\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom heapq import heappop, heappush\n\n\ndef main():\n    *A, = map(int, open(0).read().split())\n    initial = get_hash(A)\n    goal = get_hash([1, 2, 3, 4, 5, 6, 7, 8, 0])\n\n    ans = search(initial, goal)\n    print(ans)\n\n\ndef get_hash(A):\n    board = 0\n    for i, a in enumerate(A):\n        board += a << i*4\n    return board\n\n\ndef gen_move_table():\n    mask = 0b1111\n    dirs = [(-1, 0), (0, -1), (0, 1), (1, 0)]\n    ret = [[] for _ in [0]*9]\n    for y in range(3):\n        for x in range(3):\n            i = 3*y+x\n            for dy, dx in dirs:\n                dr = 3*dy+dx\n                if 0 <= y+dy < 3 and 0 <= x+dx < 3:\n                    sqmask = mask << (i+dr)*4\n                    ret[i].append((dr, sqmask))\n    return ret\n\n\ndef gen_next_board(board, move_table):\n    mask = 0b1111\n    ret = []\n    for i in range(9):\n        piece = board >> 4*i & mask\n        if piece == 0:\n            for move in move_table[i]:\n                ret.append(do_move(board, move))\n    return ret\n\n\ndef do_move(board, move):\n    dr, sqmask = move\n\n    sq = board & sqmask\n    board ^= sq\n    if dr > 0:\n        board ^= sq >> dr*4\n    else:\n        board ^= sq << -dr*4\n\n    return board\n\n\ndef heuristic(board):\n    mask = 0b1111\n    h = 0\n    for i in range(9):\n        y, x = divmod(i, 3)\n\n        piece = board >> 4*i & mask\n        if piece == 0:\n            py, px = 2, 2\n        else:\n            py, px = divmod(piece-1, 3)\n        h += abs(py-y)+abs(px-x)\n\n    return h\n\n\ndef search(initial, goal):\n    move_table = gen_move_table()\n\n    dist = {}\n    q = []\n\n    dist[initial] = 0\n    heappush(q, (heuristic(initial), 0, initial))\n    while q:\n        _, d, board = heappop(q)\n\n        if board == goal:\n            return d\n\n        if board in dist and d > dist[board]:\n            continue\n        dist[board] = d\n\n        for nboard in gen_next_board(board, move_table):\n            nd = d + 1\n            if (\n                nboard not in dist or\n                nboard in dist and nd < dist[nboard]\n            ):\n                heappush(q, (nd+heuristic(nboard), nd, nboard))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ngrid_size = 3\n\ndef generate_next_state(q, visited, current_state, zero_pos, dx, dy):\n\tr = zero_pos // grid_size\n\tc = zero_pos % grid_size\n\tnext_state = current_state[:]\n\tnext_r = r + dx\n\tnext_c = c + dy\n\tif next_r < 0 or next_r >= grid_size:\n\t\treturn None\n\tif next_c < 0 or next_c >= grid_size:\n\t\treturn None\n\tnext_state[next_r * grid_size + next_c], next_state[r * grid_size + c] = next_state[r * grid_size + c], next_state[next_r * grid_size + next_c]\n\tif visited.get(tuple(next_state)) is not None:\n\t\treturn None\n\tq.append(next_state)\n\ndef bfs(initial_state, goal):\n\tvisited = defaultdict()\n\tq = deque()\n\tq.append(initial_state)\n\tstep = 0\n\twhile(len(q) > 0):\n\t\tnode_count = len(q)\n\t\twhile(node_count > 0):\n\t\t\tcurrent_state = q.popleft()\n\t\t\tvisited[tuple(current_state)] = True\n\t\t\t# print(current_state)\n\t\t\tnode_count -= 1\n\t\t\tif current_state == goal:\n\t\t\t\tprint(step)\n\t\t\t\treturn 0\n\t\t\tzero_pos = current_state.index(0)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, 0, -1)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, 0, 1)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, -1, 0)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, 1, 0)\n\n\n\t\tstep += 1\n\ndef init():\n\tinitial_state = []\n\tgoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\tfor i in range(grid_size):\n\t\tinput_list = input().rstrip().split()\n\t\tinitial_state.extend([int(val) for val in input_list])\n\treturn initial_state, goal\n\ninitial_state, goal = init()\nbfs(initial_state, goal)\n\n\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = INT_MAX;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    \n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n    \n  } else {\n\n    int s2;\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0)\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  int space = strchr(board, '0')-board;\n  \n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, space);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        cost, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = cost - c_depth\n        if(_sum_cost == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(cost > depth):\n            continue\n\n        c_cost = HS(_i,_j,c_puz[_i*3+_j])\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i-1,_j,c_puz[(_i-1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i-1,_j,swap_puz[(_i-1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i+1,_j,c_puz[(_i+1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i+1,_j,swap_puz[(_i+1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz,)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j-1,c_puz[_i*3+_j-1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j-1,swap_puz[_i*3+_j-1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j+1,c_puz[_i*3+_j+1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j+1,swap_puz[_i*3+_j+1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n\ndef sumCost(puz):\n    value = 0\n    for i in range(3):\n        value += HS(i,0,puz[i*3])\n        value += HS(i,1,puz[i*3+1])\n        value += HS(i,2,puz[i*3+2])\n    return value\n\ndef HS(i,j,num):\n    if(num != 0):\n        k = num-1\n    else:\n        k = 8\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj)\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost = sumCost(puz)\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\ngenerated_state = {init: 0}\n\ndef bfs(root):\n    s = 0\n    configure = [root]\n    while '123456780' not in configure:\n        q = iter(configure)\n        configure = []\n        s += 1\n        for c in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if '123456780' in generated_state:\n                print(s)\n                break\n\nbfs(init)"
  },
  {
    "language": "Python",
    "code": "class Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumCost(costs),(0,i,j,0,puz,costs)))\n    global finding\n\n    while len(q):\n        cost, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+cost) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i-1,_j,2,swap_puz,swap_cost)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i+1,_j,1,swap_puz,swap_cost)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i,_j-1,4,swap_puz,swap_cost)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i,_j+1,3,swap_puz,swap_cost)))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if v not in V:\n                V[v] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth or (c_depth+simpleHS(c_puz)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2 and finding != 1):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0 and finding != 1):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2 and finding != 1):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nqueue = [[ini_state, zero_x, zero_y]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = set()\nvisited |= {hashnum(ini_state)}\ntrial = 0\nwhile answer not in visited:\n    new_queue = []\n    for q in queue:\n        state, zero_x, zero_y = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm not in visited:\n                    visited |= {perm}\n                    new_queue.append([new_state, new_x, new_y])\n    queue = new_queue\n    trial += 1\nprint(trial)"
  },
  {
    "language": "Python",
    "code": " \ngoal = ((1, 2, 3), (4, 5, 6), (7, 8, 0))\n\nparents = {}\ntotal = {}\nflag = True\n\ninitial = []\nposition = []\nfor i in range(3):\n\ta, b, c = map(int, input().split())\n\tif a == 0:\n\t\tposition.extend([i, 0])\n\telif b == 0:\n\t\tposition.extend([i, 1])\n\telif c == 0:\n \t\tposition.extend([i, 2])\n\tinitial.append( (a, b, c) )\n\nparents[tuple(initial)] = position\ntotal[tuple(initial)] = 1\n\ncount = 0\n\nif tuple(initial) == goal:\n\tflag = False\n\nwhile flag:\n\tcount += 1\n\tchildren = {}\n\tfor par_key in parents.keys():\n\t\tposition = parents[par_key]\n\n\t\tif position[0] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]+1][position[1]]\n\t\t\tchild[position[0]+1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]+1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[0] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]-1][position[1]]\n\t\t\tchild[position[0]-1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]-1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]+1]\n\t\t\tchild[position[0]][position[1]+1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]+1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]-1]\n\t\t\tchild[position[0]][position[1]-1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]-1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\tparents = children\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n"
  },
  {
    "language": "Python",
    "code": "import queue\nboard = []\nfor i in range(3):\n    board.extend(list(map(int, input().split())))\n\nq = queue.PriorityQueue()\nq.put((0, board))\n\nwhile True:\n    entry = q.get()\n    step = entry[0]\n    b = entry[1]\n    if b == [1, 2, 3, 4, 5, 6, 7, 8, 0]:\n        print(step)\n        break\n    i = b.index(0)\n    step += 1\n\n    if i != 0:\n        b_new = list(b)\n        b_new[i - 1], b_new[i] = 0, b_new[i - 1]\n        q.put((step, b_new))\n    if i != len(b) - 1:\n        b_new = list(b)\n        b_new[i], b_new[i + 1] = b_new[i + 1], 0\n        q.put((step, b_new))\n    if i > 2:\n        b_new = list(b)\n        b_new[i - 3], b_new[i] = 0, b_new[i - 3]\n        q.put((step, b_new))\n    if i < 6:\n        b_new = list(b)\n        b_new[i], b_new[i + 3] = b_new[i + 3], 0\n        q.put((step, b_new))\n\n\n"
  },
  {
    "language": "Python",
    "code": "from queue import Queue\ngoal = [1,2,3,4,5,6,7,8,0]\nSIZE = 3\ncmds = ['up','down','left','right']\n\ndef puz_hash(p):\n    hash = ''.join(map(str, p))\n    return hash\n\ndef up(p,z,c):\n    if z >= 3 and c != 'down':\n        p[z], p[z - 3] = p[z - 3], p[z]\n    return p\n\ndef down(p,z,c):\n    if z <= 5 and c != 'up':\n        p[z], p[z + 3] = p[z + 3], p[z]\n    return p\n\ndef left(p,z,c):\n    if z % 3 != 0 and c != 'right':\n        p[z], p[z - 1] = p[z - 1], p[z]\n    return p\n\ndef right(p,z,c):\n    if z % 3 != 2 and c != 'left':\n        p[z], p[z + 1] = p[z + 1], p[z]\n    return p\n\ndef search(p):\n    q = Queue()\n    # init\n    q.put((p,0,''))\n    visited = set()#[]\n\n    while True:\n        if(q.empty()):\n            return None\n        current_p, current_d, prev_move = q.get()\n        current_z = current_p.index(0)\n        current_p_hash = puz_hash(current_p)\n\n        if(current_p_hash in visited):\n            continue\n        if(current_p_hash == goal_hash):\n            return current_d\n        visited.add(current_p_hash)\n\n        next_p = current_p.copy()\n        next_p = up(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[0]))\n\n        next_p = current_p.copy()\n        next_p = down(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[1]))\n\n        next_p = current_p.copy()\n        next_p = left(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[2]))\n\n        next_p = current_p.copy()\n        next_p = right(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[3]))\n\n        # kkkkkusso jikan kakaru\n        # for cmd in cmds:\n        #     next_p = current_p.copy()\n        #     next_p = get_next_states(cmd,next_p,current_z,prev_move)#eval(cmd)(next_p, current_z, prev_move)\n        #     if(next_p is not None):\n        #         print(current_d+1)\n        #         q.put((next_p, current_d+1, cmd))\n\np = []\nfor i in range(3):\n    p.extend(map(int, input().split()))\n\ngoal_hash = puz_hash(goal)\nres = search(p)\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n\nimport sys\n\nstart = list(map(int, sys.stdin.read().split()))\n\nprint(solve(start))"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    #print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    #debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n\n            if not hash_code in closed:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2]+x[3])\n"
  },
  {
    "language": "Python",
    "code": "# å¹åªåæ¢ç´¢ #åæ¹åæ¢ç´¢\nimport sys\nimport queue\n\nSPACE = 0\n\nadjacents_list = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef mininum_steps(start, goal):\n    if start == goal:\n        return 0\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    history = [start]\n    while not q.empty():\n        state = q.get()\n        for adjacent in adjacents_list[state.space]:\n            board = state.board[:]\n            board[state.space] = board[adjacent]\n            board[adjacent] = SPACE\n            if board in history:\n                 continue\n            if board == goal:\n                return go_back(state)\n            history.append(board)\n            next_state = State(board, adjacent, state)\n            q.put(next_state)\n\nstep = 0\ndef go_back(state):\n    global step\n    if state is not None:\n        step += 1\n        go_back(state.prev)\n    return step\n\n\ninitial_board = list(map(int, sys.stdin.read().split()))\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nprint(mininum_steps(initial_board, goal))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ngoal = \"123456780\"\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    start = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    if start == goal:\n        return 0\n    zero = start.find(\"0\")\n    dp = deque([(0, start, zero, 1), (0, goal, 8, 0)])\n    TABLE = {start:(1, 0), goal:(0, 0)}\n    for _ in range(100):\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\n\n\n\"\"\"\nstart : ã¹ã¿ã¼ãã®ç¤é¢ãè¡¨ãéå\n# bf_search([8, 6, 7, 2, 5, 4, 3, 0, 1])\nbf_search([1,2,3,4,5,0,7,8,6])\nbf_search([1,3,0,4,2,5,7,8,6])\n\"\"\"\n\n\ndef bf_search(start):\n    # é£æ¥ãªã¹ã\n    adjacent = (\n        # 0ã®ã³ããã1or3ã¸ç§»åã§ãã\n        (1, 3),  # 0\n        # 1ã®ã³ããã0or2or4ã¸ç§»åã§ãã\n        (0, 2, 4),  # 1\n        (1, 5),  # 2\n        (0, 4, 6),  # 3\n        (1, 3, 5, 7),  # 4\n        (2, 4, 8),  # 5\n        (3, 7),  # 6\n        (4, 6, 8),  # 7\n        (5, 7)  # 8\n    )\n    # æçµçã«è³ãããå½¢\n    GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n    # åæå¤ã®æç¹ã§ã´ã¼ã«ã ã£ãã\n    if start == GOAL:\n        print(0)\n        return\n    \n\n    q = queue.Queue()\n    \n    # ã­ã¥ã¼ã«Stateãªãã¸ã§ã¯ããè¿½å ãã\n    q.put(State(start, start.index(0), None))\n    \n    # table:åä¸å±é¢ãããããã§ãã¯ããããã®è¾æ¸ï¼ããã·ã¥ï¼\n    table = {}\n    \n    # éåãã¿ãã«åã«å¤æãã¦ãããã­ã¼ã¨ãã\n    # Trueãªãä¸åº¦è¦ããã¨ãããç¶æ\n    table[tuple(start)] = True\n\n    # ã´ã¼ã«ã«ãã©ãçãã¾ã§ã«ã¼ã\n    # ã­ã¥ã¼ãç©ºã«ãªã£ã¦ã«ã¼ããçµäºã-> goalã«ãã©ãçããªãã£ã\n    while not q.empty():\n        # ã­ã¥ã¼ããå±é¢ãåãåºãã¦aã«æ ¼ç´\n        a = q.get()\n        #print(a.board)\n        # adjacent[a.space]: åãããã³ãã®ä½ç½®\n        \"\"\"\n        å®æå½¢ããèãã¦\n        ç©ºç½0ã®ã¤ã³ããã¯ã¹ã7ã ã£ããé£æ¥ãªã¹ããã4,6,8ã®æ¹åã¸ãåãããã¨ãã§ããã®ã§\n        \n        æåã®ã«ã¼ãã§xã«4ãå¥ã\n        \"\"\"\n        #print(\"a.apace=\"+str(a.space))\n        for x in adjacent[a.space]:\n            #print(\"x=\"+str(x))\n            # åã®å±é¢ãã³ãã¼(Stateåã§ãªãç¶æã®ã¿ãstartã¨åãã)\n            b = a.board[:]\n\n            b[a.space] = b[x]\n            # 0: ç©ºãå ´æãè¡¨ã\n            b[x] = 0\n            key = tuple(b)\n            # åä¸å±é¢ããªãããã§ãã¯ãããã°continueã§ã«ã¼ããã¹ã­ãã\n            if key in table: continue\n            # åä¸å±é¢ããªããã°æ°ããå±é¢ãçæ\n            c = State(b, x, a)\n            if b == GOAL:\n                # print(\"answer\")\n                min = Min()\n                min.print_answer(c)\n                min.result()\n                return\n            # å±é¢ãè¿½å \n            q.put(c)\n            table[key] = True\n\n\nclass State:\n    def __init__(self, board, space, prev):\n        # ç¤é¢ãè¡¨ãéå\n        self.board = board\n        # ç©ºãå ´æã®ä½ç½®\n        self.space = space\n        # ã²ã¨ã¤åã®å±é¢ï¼Stateãªãã¸ã§ã¯ãï¼\n        self.prev = prev\n\nclass Min:\n    def __init__(self):\n        self.min = 0\n    def increment(self):\n        self.min = self.min + 1\n    def result(self):\n        print(self.min - 1)\n\n    # æé ã®è¡¨ç¤º\n    def print_answer(self,x):\n        if x is not None:\n            self.increment()\n            self.print_answer(x.prev)\n            # print(x.board)\n\n\n\ndef main():\n    p = []  ##appendã®ããã«å®£è¨ãå¿è¦\n    # å¥ååä»\n    i = 0\n    while i < 3:\n        try:\n            p.append(list(map(int, input().split())))\n            i = i + 1\n        except:\n            break;\n    # âãã®å½¢ã«å¤å½¢ããã\n    # start =[1,3,0,4,2,5,7,8,6]\n    start = sum(p,[])\n\n    bf_search(start)\n\n    return\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom itertools import chain\nfrom operator import mul\n\nexp10 = [10 ** a for a in range(8, -1, -1)]\nmovables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]\n\ndestination = 123456780\n\n\ndef swap(board, move_from, move_to):\n    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)\n\n\nboard0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))\np0 = ('0' + str(board0))[-9:].index('0')\n\nappeared = {board0}\nqueue = list((0, move_from, p0, board0) for move_from in movables[p0])\nheapq.heapify(queue)\n\nwhile True:\n    total_cost, move_from, move_to, board = heapq.heappop(queue)\n    if board == destination:\n        print(total_cost)\n        break\n    new_board = swap(board, move_from, move_to)\n    if new_board in appeared:\n        continue\n    for move_from2 in movables[move_from]:\n        if move_from2 != move_to:\n            heapq.heappush(queue, (total_cost + 1, move_from2, move_from, new_board))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n\tif n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.put(v)\n\nprint(u[2])\n"
  },
  {
    "language": "Python",
    "code": "dy = [-1, 0, 1, 0]\ndx = [0, 1, 0, -1]\nt = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n\ndef get_heuri():\n    res = 0\n    for i in range(3):\n        for j in range(3):\n            if t[i][j] == 0:\n                continue\n            a = t[i][j] - 1\n            res += abs(a // 3 - i) + abs(a % 3 - j)\n    return res\n\n\ndef check(depth, prev, py, px, limit):\n    heuri = get_heuri()\n    if heuri + depth > limit:\n        return False\n    if heuri == 0:\n        return True\n    for i in range(4):\n        if abs(i - prev) == 2:\n            continue\n        ny = py + dy[i]\n        nx = px + dx[i]\n        if ny < 0 or nx < 0 or ny >= 3 or nx >= 3:\n            continue\n        t[ny][nx], t[py][px] = t[py][px], t[ny][nx]\n        if check(depth + 1, i, ny, nx, limit):\n            return True\n        t[ny][nx], t[py][px] = t[py][px], t[ny][nx]\n    return False\n\nfor i in range(3):\n    s = list(map(int, input().split()))\n    for j in range(3):\n        if s[j] == 0:\n            py = i\n            px = j\n        t[i][j] = s[j]\nlimit = 0\nwhile True:\n    if check(0, 99, py, px, limit):\n        print(limit)\n        break\n    limit += 1\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __str__(self):\n        return str(self.board)+\"\\nf: \" + str(self.fValue)+ \"\\nsteps: \"+ str(self.depth)+\"\\n\"\n\n    def __bool__(self):\n        return True\n\n    def __hash__(self):\n        return hash(self.board)\n\nclass Board:\n    def __init__(self, matrix):\n        self.matrix = matrix\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n                return\n        raise ValueError(\"Invalid Matrix!\")\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        if type(other) is not Board:\n            return False\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n        if len(thisMatrix) != len(otherMatrix):\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n        return s\n\n\ndef fastSearch(frontier, limit, goalBoard, explored, astar):\n    if not frontier:\n        return True\n    else:\n        curNode = frontier.pop(0)\n        explored.add(curNode)\n        if curNode.board == goalBoard:\n            print(curNode.depth)\n            return curNode\n        elif limit == 0:\n            print(\"Limit Reached\")\n            return True\n        elif astar:\n            aStarExpansion(curNode, frontier, goalBoard, explored)\n            return False\n\ndef fastSearchClient(board, limit, goalBoard, astar):\n    if astar:\n        frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    else:\n        frontier = [Node(board, None, 0, 0)]\n    explored = set()\n    for i in range(limit):\n        retval = fastSearch(frontier, limit - i, goalBoard, explored, astar)\n        if retval:\n            return retval\n    return None\n\n# Function to expand the frontier using aStar #\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    return manhattan(currentBoard)\n\n\ndef manhattan(currentBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\ndef main():\n\n    goalBoard = Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]])\n\n    arr = [[1 for i in range(3)] for j in range(3)]\n\n    for i in range(3):\n        arr[i][0], arr[i][1], arr[i][2] = input().split()\n\n    for i in range(3):\n        for j in range(3):\n            arr[i][j] = int(arr[i][j])\n\n    fastSearchClient(Board(arr), 1000, goalBoard, True)\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        #self[:] = [None] * size\n        self.space = None\n        self.path = \"\"\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    def isTarget(p):\n        for i in range(N2):\n            if p[i] != i+1:\n                return False\n        return True\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = []\n        Q.append(s)\n        V.append(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.append(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+sumCost(_costs)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ngoal = \"123456780\"\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    start = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    if start == goal:\n        return 0\n    zero = start.find(\"0\")\n    dp = deque([(0, start, zero, 1), (0, goal, 8, 0)])\n    TABLE = {start:(1, 0), goal:(0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import time\nimport math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __hash__(self):\n        return hash(self.board)\n\n\nclass Board:\n    # The 8-puzzle board representation #\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        #print other\n\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n\n        if len(thisMatrix) != len(otherMatrix):\n            print \"failing here 0\"\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                print \"failing here 1\"\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    #print \"failing here expected\"\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n\n        return s\n\ndef fastSearch(frontier, goalBoard, explored):\n    if not frontier:\n        return True\n    else:\n        curNode = frontier.pop(0)\n        explored.add(curNode)\n        if curNode.board == goalBoard:\n            print curNode.depth\n            return True\n        aStarExpansion(curNode, frontier, goalBoard, explored)\n        return False\n\n\ndef fastSearchClient(board, goalBoard):\n    frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    explored = set()\n\n    limit = 0\n\n    while (limit < 1000):\n        retval = fastSearch(frontier, goalBoard, explored)\n        if retval:\n            return\n        limit += 1\n    return\n\n# Function to expand the frontier using aStar #\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\n\narr = [[1 for i in range(3)] for j in range(3)]\n\nfor i in range(3):\n    arr[i][0], arr[i][1], arr[i][2] = raw_input().split()\n\n\nfor i in range(3):\n    for j in range(3):\n        arr[i][j] = int(arr[i][j])\n\nfastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ngoal = \"123456780\"\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    if MAP == goal:\n        return 0\n    start = MAP.find(\"0\")\n    dp = deque([(0, MAP, start, 1), (0, goal, 8, 0)])\n    TABLE = {MAP:(1, 0), goal:(0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if CM in TABLE:\n                if TABLE[CM][0] != flg:\n                    return TABLE[CM][1] + cnt\n                continue\n            TABLE[CM] = (flg, cnt)\n            dp.append((cnt, CM, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth or (c_depth+simpleHS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n\nimport sys\n\nstart = list(map(int, sys.stdin.read().split()))\n\nprint(solve(start))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle()\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if not (0<= tx < N and 0 <= ty < N):\n                    continue\n                v = copy.copy(u)\n                change = tx * N + ty\n                v[u.space], v[change] = v[change], v[u.space]\n                v.space = change\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#codinh -utf8\nimport sys\nimport copy\n\ngoal_state=[1,2,3,4,5,6,7,8,0]\nadj=[(1, 3),(0, 2, 4),(1, 5),(0, 4, 6),(1, 3, 5, 7),(2, 4, 8),(3, 7),(4, 6, 8),(5, 7)]\nopen_list=[]    #????????Â¢?Â´Â¢??????????????????????Â´?\nclosed_list=[]  #??Â¢?Â´Â¢????????????????????????????Â´?\n\n\ndef getH(a, b): #???????????????????????Â¢????Â¨????\n    h2=0\n    i=0\n    for n in a:\n        if n!=-1:   #????????\\??????????????????????????????????????????????????Â¶????????Â§????????Â¢??????????Â±???????\n            j=b.index(n)\n            dist=j-i\n            dist=abs(dist)  #|i??Â¨j??????dist|: ??Â´???????????Â§????????Â¢\n            if dist==1:     #?????Â¢??????????????Â§?Â¨???????????????????????????????????????Â§????????Â¢?????????\n                if (i==2 and j==3) or (j==2 and i==3) or (i==5 and j==6) or (j==5 and i==6):\n                    dist=3\n            elif dist==3:\n                dist=1\n            elif dist==4:\n                if(i!=2 and j!=6) and (i!=6 and j!=2):\n                    dist=2\n            elif dist==5:\n                dist=3\n            elif dist==6:\n                dist=2\n            elif dist==7:\n                dist=3\n            elif dist==8:\n                dist=4\n            h2+=dist    #?????????????????Â¢?????????\n        i+=1\n    return  h2  #?????Â¢??????????????????\n\ndef findChildState(space, std_node):    #???????????????????????????????????????????????????\n    ad=adj[space]\n    child_set=[]\n    for i in ad: #???????????????????????????????????????????????Â¶???child_state?????????\n        child_state=copy.deepcopy(std_node[3])\n        child_state[space], child_state[i]=child_state[i], child_state[space]\n        child_set.append(child_state)   #chld_set??????????????????????????????????????????????????Â¶???????????????????Â´???????\n    return child_set\n\ndef openChildNode(std_node):    #?????Â¶??????????????????????????????openlist????????????\n    child_set=findChildState(std_node[3].index(0), std_node)   #???????????????????????????????????????\n    del open_list[0]    #??????????????????openlist??????????????????\n    closed_list.append(std_node)    #??????????????????closedlist???????????????\n    for i in child_set:\n        g=std_node[0]+1\n        h=getH(i, goal_state)\n        f=g+h\n        child=(g,h,f,i) #?????????????????????????????Â°????????\\??????????????Â£???????????????????????????????????Â¶???????Â¨???????child?????????\n        op=list(map(lambda x: i==x[3], open_list))\n        cl=list(map(lambda x: i==x[3], closed_list))\n        if  (True not in op) and (True not in cl):  #openlist??????closedlist????????????????????Â¨?????????????????Â¶??????????????Â´???\n            open_list.append(child) #openlist?????????\n        elif (True in op):  #openlist?????????????????Â¨?????????????????Â¶??????????????Â´???\n            n=op.index(True)\n            if f<open_list[n][2]:   #????????????????????????????????????????????????????Â°????????????Â°openlist????????????????????Â´??Â°\n                open_list[n]=copy.deepcopy(child)\n        elif (True in cl):  #closedlist?????????????????Â¨?????????????????Â¶??????????????Â´???\n            n=cl.index(True)\n            if f<closed_list[n][2]:   #????????????????????????????????????????????????????Â°????????????Â°closedlist??????????????????openlist?????????\n                del closed_list[n]\n                open_list.append(child)\n\ndef updateStandard():   #openlist??????????????????????Â°???????????????????????????????????Â¨??????????\n    min=100000000\n    std=()\n    if open_list==[]:   #openlist??????????????Â´?????Â¢?Â´Â¢??Â±???\n        return -1\n    for i in open_list: #openlist??????????????????????Â°????????????????????Â´Â¢\n        if i[2]<min:\n            min=i[2]\n            std=copy.deepcopy(i)\n    n=open_list.index(std)  #????????????????Â°???????????????????????????????????Â¨????\n    open_list[0], open_list[n]=open_list[n], open_list[0]   #??????????????????openlist?????????????Â§????\n    return std  #????????????????????????\n\n\na=list(map(int, sys.stdin.read().split()))\ng=0     #??????????????Â§?????????????????Â°???0\nh=getH(a, goal_state)  #?????\\??????????????Â£?????????????Â¨????\nf=g+h   #??Â´???????????Â§????Â¨Â±???????????????????Â¨????\nstd_node=(g, h, f, a)   #?????????(??????????????Â°????????\\??????????????Â£??????????????????????????????????????Â¶???)??????????????????????Â¨????\nopen_list.append(std_node)\n\nwhile 1:\n    if std_node[3]==goal_state: #????????????????????????????????Â´???????????Â¶?????Â¨?????Â´????????Â°??Â¢?Â´Â¢??????\n        flag=\"Done\"\n        break\n    openChildNode(std_node) #open_list????????????????????????\n    std=updateStandard()    #openlist?????????????????????f???????Â°??????????????????????????????Â¨??????\n    if std==-1: #openlist???????????Â£?????Â´?????Â¢?Â´Â¢??Â±???\n        flag=\"Failed\"\n        break\n    std_node=copy.deepcopy(std)    #?????????????????????????????????????Â°????????????????????????????????Â¨????\n\n\nif flag==\"Done\":    #??Â¢?Â´Â¢?????????????????Â´????????Â´???????????Â§???????????????????????Â°??Â¨????????Â¶????????Â¨???\n    print(std_node[0])\nelif flag==\"Failed\":    #??Â¢?Â´Â¢?????Â±???????????Â´???????????Â¨?????????\n    print(\"Search failed\")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\n\nf = ''.join(sys.stdin.readline().split())\nf += ''.join(sys.stdin.readline().split())\nf += ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = [[f,f.index('0'),0]]\nV = { f: True }\n\nwhile len(Q)>0:\n    u = Q.pop(0)\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n        if n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.append(v)\n\nprint(u[2])\n"
  },
  {
    "language": "Python",
    "code": "start =  list(map(int, [n for a in [input().split() for i in range(3)] for n in a]))\ngoal = [1, 2, 3, 4, 5 ,6, 7, 8, 0]\n\nadjacent = (\n    (1, 3),\n    (0, 2, 4),\n    (1, 5),\n    (0, 4, 6),\n    (1, 3, 5, 7),\n    (2, 4, 8),\n    (3, 7),\n    (4, 6, 8),\n    (5, 7)\n)\n\nclass State():\n    def __init__(self, board, space, path):\n        self.board = board\n        self.space = space\n        self.path = path\n\ndef main():\n    if start == goal:\n        return 0\n\n    queue = [State(start[:], start.index(0), 0)]\n    stateList = {\"\".join(map(str, start)) : True}\n\n    while len(queue) != 0:\n        state = queue.pop(0)\n        for i in adjacent[state.space]:\n            next_state = State(state.board[:], i, state.path + 1)\n            next_state.board[i], next_state.board[state.space] = next_state.board[state.space], next_state.board[i]\n            state_str = \"\".join(map(str, next_state.board))\n            if stateList.get(state_str) :\n                continue\n            stateList[state_str] = True\n            if next_state.board == goal:\n                return next_state.path\n            queue.append(next_state)\n\nif __name__ == '__main__':\n    result = main()\n    print(result)\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashSet;\nuse std::collections::VecDeque;\nuse std::io::*;\nuse std::str::FromStr;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nconst N: usize = 3;\nconst N2: usize = 9;\n\nconst DX: [i32; 4] = [-1, 0, 1, 0];\nconst DY: [i32; 4] = [0, -1, 0, 1];\nconst DIR: [&str; 4] = [&\"u\", &\"l\", &\"d\", &\"r\"];\n\n#[derive(PartialEq, Eq, Hash, Clone)]\nstruct Puzzle {\n    f: Vec<usize>,\n    space: usize,\n    path: String,\n}\n\nfn is_target(puzzle: Puzzle) -> bool {\n    for index in 0..N2 {\n        if puzzle.f[index] != (index + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn puzzle_key(puzzle: Puzzle) -> String {\n    return puzzle.f.iter().map(|&s| s.to_string()).collect::<String>();\n}\n\nfn bfs(puzzle: Puzzle) -> String {\n    let mut q: VecDeque<Puzzle> = VecDeque::new();\n    let mut v = HashSet::new();\n    let new_puzzle = puzzle;\n    let v_key: String = puzzle_key(new_puzzle.clone());\n    q.push_back(new_puzzle);\n    v.insert(v_key);\n    while q.len() > 0 {\n        let u_puzzle: Puzzle = q.pop_front().unwrap();\n        if is_target(u_puzzle.clone()) {\n            return u_puzzle.path;\n        }\n        let sx = u_puzzle.space / N;\n        let sy = u_puzzle.space % N;\n        for r in 0..4 {\n            let tx: i32 = sx as i32 + DX[r];\n            let ty: i32 = sy as i32 + DY[r];\n            if tx < 0 || ty < 0 || tx >= N as i32 || ty >= N as i32 {\n                continue;\n            }\n            let mut v_puzzle = u_puzzle.clone();\n            v_puzzle\n                .f\n                .swap(u_puzzle.space, tx as usize * N + ty as usize);\n            v_puzzle.space = tx as usize * N + ty as usize;\n            let v_puzzle_key: String = puzzle_key(v_puzzle.clone());\n\n            if !v.contains(&v_puzzle_key) {\n                v.insert(v_puzzle_key);\n                v_puzzle.path = v_puzzle.path + DIR[r];\n                q.push_back(v_puzzle);\n            }\n        }\n    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let mut init_numbers: Vec<usize> = vec![0; N2];\n    let mut init_space: usize = 0;\n    for i in 0..N2 {\n        let number: usize = read();\n        init_numbers[i] = number;\n\n        if init_numbers[i] == 0 {\n            init_numbers[i] = N2;\n            init_space = i;\n        }\n    }\n\n    let puzzle = Puzzle {\n        f: init_numbers,\n        space: init_space,\n        path: \"\".to_string(),\n    };\n\n    let ans: String = bfs(puzzle);\n    println!(\"{}\", ans.len());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "pub fn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\npub fn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\npub fn read_vec2<T: std::str::FromStr>(n: usize) -> Vec<Vec<T>> {\n    (0..n).map(|_| read_vec()).collect()\n}\n\npub fn read_col<T: std::str::FromStr>(n: usize) -> Vec<T> {\n    (0..n).map(|_| read()).collect()\n}\n\nfn fact(n: usize) -> usize {\n    if n == 0 {\n        1\n    } else {\n        n * fact(n - 1)\n    }\n}\n\nfn encode(v: &Vec<u8>) -> usize {\n    let n: usize = v.len();\n    if n == 1 {\n        return 0;\n    }\n    let mut c = 0;\n    for i in 0..n {\n        if v[i] < v[0] {\n            c += 1;\n        }\n    }\n    let mut nv = vec![];\n    for i in 1..n {\n        nv.push(v[i]);\n    }\n    c * fact(n - 1) + encode(&nv)\n}\n\nuse std::collections::VecDeque;\n\nfn next(v: &Vec<u8>, check: &mut Vec<bool>) -> Vec<Vec<u8>> {\n    let mut i = 0;\n    for j in 0..9 {\n        if v[j] == 0 {\n            i = j;\n            break;\n        }\n    }\n    let mut ret = vec![];\n    if i % 3 != 0 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i - 1];\n        n[i - 1] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    if i % 3 != 2 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i + 1];\n        n[i + 1] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    if i > 2 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i - 3];\n        n[i - 3] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    if i < 6 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i + 3];\n        n[i + 3] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut v: Vec<u8> = vec![];\n    let t: Vec<u8> = read_vec();\n    for a in t {\n        v.push(a);\n    }\n    let t: Vec<u8> = read_vec();\n    for a in t {\n        v.push(a);\n    }\n    let t: Vec<u8> = read_vec();\n    for a in t {\n        v.push(a);\n    }\n\n    let goal = encode(&vec![1, 2, 3, 4, 5, 6, 7, 8, 0]);\n\n    let mut check: Vec<bool> = vec![false; 362880];\n    let mut vd = VecDeque::new();\n    check[encode(&v)] = true;\n    vd.push_back((v, 0));\n\n    loop {\n        let (v, d) = vd.pop_front().unwrap();\n        if encode(&v) == goal {\n            println!(\"{}\", d);\n            break;\n        }\n        for n in next(&v, &mut check) {\n            vd.push_back((n, d + 1));\n        }\n    }\n}\n\n"
  }
]