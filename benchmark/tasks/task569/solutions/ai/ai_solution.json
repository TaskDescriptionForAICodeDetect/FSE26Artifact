[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BOARD_SIZE 3\n#define MAX_QUEUE_SIZE 100000\n\ntypedef struct {\n    int board[BOARD_SIZE][BOARD_SIZE];\n    int zero_x, zero_y;\n    int moves;\n} State;\n\nint target[BOARD_SIZE][BOARD_SIZE] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint is_goal(State* state) {\n    return memcmp(state->board, target, sizeof(target)) == 0;\n}\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;\n}\n\nint hash(State* state) {\n    int h = 0;\n    for (int i = 0; i < BOARD_SIZE; i++)\n        for (int j = 0; j < BOARD_SIZE; j++)\n            h = h * 10 + state->board[i][j];\n    return h;\n}\n\nint bfs(State* initial) {\n    State* queue[MAX_QUEUE_SIZE];\n    int visited[1000000] = {0};\n    int front = 0, rear = 0;\n\n    queue[rear++] = initial;\n    visited[hash(initial)] = 1;\n\n    while (front < rear) {\n        State* current = queue[front++];\n\n        if (is_goal(current))\n            return current->moves;\n\n        for (int i = 0; i < 4; i++) {\n            int new_x = current->zero_x + dx[i];\n            int new_y = current->zero_y + dy[i];\n\n            if (is_valid(new_x, new_y)) {\n                State* next = malloc(sizeof(State));\n                memcpy(next, current, sizeof(State));\n\n                next->board[current->zero_x][current->zero_y] = \n                    next->board[new_x][new_y];\n                next->board[new_x][new_y] = 0;\n                next->zero_x = new_x;\n                next->zero_y = new_y;\n                next->moves++;\n\n                int h = hash(next);\n                if (!visited[h]) {\n                    queue[rear++] = next;\n                    visited[h] = 1;\n                } else {\n                    free(next);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    State* initial = malloc(sizeof(State));\n    initial->moves = 0;\n\n    for (int i = 0; i < BOARD_SIZE; i++) {\n        for (int j = 0; j < BOARD_SIZE; j++) {\n            scanf(\"%d\", &initial->board[i][j]);\n            if (initial->board[i][j] == 0) {\n                initial->zero_x = i;\n                initial->zero_y = j;\n            }\n        }\n    }\n\n    int result = bfs(initial);\n    printf(\"%d\\n\", result);\n\n    free(initial);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define SIZE 3\n\ntypedef struct {\n    int board[SIZE][SIZE];\n    int zero_row, zero_col;\n    int g, h;\n} State;\n\ntypedef struct Node {\n    State state;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node *front, *rear;\n} Queue;\n\nint target[SIZE][SIZE] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\nint dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nQueue* create_queue() {\n    Queue *q = (Queue*)malloc(sizeof(Queue));\n    q->front = q->rear = NULL;\n    return q;\n}\n\nint is_empty(Queue *q) {\n    return q->front == NULL;\n}\n\nvoid enqueue(Queue *q, State state) {\n    Node *new_node = (Node*)malloc(sizeof(Node));\n    new_node->state = state;\n    new_node->next = NULL;\n    if (is_empty(q)) {\n        q->front = q->rear = new_node;\n    } else {\n        q->rear->next = new_node;\n        q->rear = new_node;\n    }\n}\n\nState dequeue(Queue *q) {\n    Node *temp = q->front;\n    State state = temp->state;\n    q->front = q->front->next;\n    if (q->front == NULL) {\n        q->rear = NULL;\n    }\n    free(temp);\n    return state;\n}\n\nint is_target(State *state) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (state->board[i][j] != target[i][j]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint heuristic(State *state) {\n    int h = 0;\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (state->board[i][j] != 0) {\n                int val = state->board[i][j] - 1;\n                int target_row = val / SIZE;\n                int target_col = val % SIZE;\n                h += abs(i - target_row) + abs(j - target_col);\n            }\n        }\n    }\n    return h;\n}\n\nState create_state(int board[SIZE][SIZE]) {\n    State state;\n    memcpy(state.board, board, sizeof(state.board));\n    state.g = 0;\n    state.h = heuristic(&state);\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (state.board[i][j] == 0) {\n                state.zero_row = i;\n                state.zero_col = j;\n            }\n        }\n    }\n    return state;\n}\n\nint is_valid(int row, int col) {\n    return row >= 0 && row < SIZE && col >= 0 && col < SIZE;\n}\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint solve(State initial) {\n    Queue *q = create_queue();\n    enqueue(q, initial);\n\n    while (!is_empty(q)) {\n        State current = dequeue(q);\n        if (is_target(&current)) {\n            return current.g;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int new_row = current.zero_row + dir[i][0];\n            int new_col = current.zero_col + dir[i][1];\n            if (is_valid(new_row, new_col)) {\n                State next = current;\n                swap(&next.board[current.zero_row][current.zero_col], &next.board[new_row][new_col]);\n                next.zero_row = new_row;\n                next.zero_col = new_col;\n                next.g = current.g + 1;\n                next.h = heuristic(&next);\n                enqueue(q, next);\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int board[SIZE][SIZE];\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            scanf(\"%d\", &board[i][j]);\n        }\n    }\n    State initial = create_state(board);\n    printf(\"%d\\n\", solve(initial));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\n\nstruct State {\n    vector<vector<int>> board;\n    int zero_row, zero_col;\n    int steps;\n    string hash;\n\n    State(vector<vector<int>> b, int zr, int zc, int s) : board(b), zero_row(zr), zero_col(zc), steps(s) {\n        hash = \"\";\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                hash += to_string(board[i][j]);\n            }\n        }\n    }\n};\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint bfs(vector<vector<int>>& start, vector<vector<int>>& target) {\n    queue<State> q;\n    unordered_set<string> visited;\n\n    int zero_row = -1, zero_col = -1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (start[i][j] == 0) {\n                zero_row = i;\n                zero_col = j;\n                break;\n            }\n        }\n        if (zero_row != -1) break;\n    }\n\n    State initial_state(start, zero_row, zero_col, 0);\n    q.push(initial_state);\n    visited.insert(initial_state.hash);\n\n    string target_hash;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            target_hash += to_string(target[i][j]);\n        }\n    }\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.hash == target_hash) {\n            return current.steps;\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = current.zero_row + dx[i];\n            int new_col = current.zero_col + dy[i];\n\n            if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                vector<vector<int>> new_board = current.board;\n                swap(new_board[current.zero_row][current.zero_col], new_board[new_row][new_col]);\n                State new_state(new_board, new_row, new_col, current.steps + 1);\n\n                if (visited.find(new_state.hash) == visited.end()) {\n                    visited.insert(new_state.hash);\n                    q.push(new_state);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    vector<vector<int>> start(N, vector<int>(N));\n    vector<vector<int>> target = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> start[i][j];\n        }\n    }\n\n    int steps = bfs(start, target);\n    cout << steps << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EightPuzzle {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] initial = new int[3][3];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                initial[i][j] = scanner.nextInt();\n            }\n        }\n        System.out.println(bfs(initial));\n    }\n\n    private static int bfs(int[][] initial) {\n        Queue<int[][]> queue = new LinkedList<>();\n        Queue<Integer> steps = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        String targetState = \"123456780\";\n\n        queue.add(initial);\n        steps.add(0);\n        visited.add(gridToString(initial));\n\n        while (!queue.isEmpty()) {\n            int[][] current = queue.poll();\n            int currentSteps = steps.poll();\n\n            if (gridToString(current).equals(targetState)) {\n                return currentSteps;\n            }\n\n            int[] zeroPos = findZero(current);\n            int x = zeroPos[0];\n            int y = zeroPos[1];\n\n            for (int[] dir : DIRECTIONS) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n\n                if (newX >= 0 && newX < 3 && newY >= 0 && newY < 3) {\n                    int[][] next = copyGrid(current);\n                    next[x][y] = next[newX][newY];\n                    next[newX][newY] = 0;\n                    String nextState = gridToString(next);\n\n                    if (!visited.contains(nextState)) {\n                        visited.add(nextState);\n                        queue.add(next);\n                        steps.add(currentSteps + 1);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    private static String gridToString(int[][] grid) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                sb.append(grid[i][j]);\n            }\n        }\n        return sb.toString();\n    }\n\n    private static int[] findZero(int[][] grid) {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (grid[i][j] == 0) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }\n\n    private static int[][] copyGrid(int[][] grid) {\n        int[][] copy = new int[3][3];\n        for (int i = 0; i < 3; i++) {\n            System.arraycopy(grid[i], 0, copy[i], 0, 3);\n        }\n        return copy;\n    }\n}",
    "timestamp": "2025-08-05 22:11:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EightPuzzle {\n    private static final int[][] GOAL_STATE = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] initialState = new int[3][3];\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                initialState[i][j] = scanner.nextInt();\n            }\n        }\n\n        int steps = solvePuzzle(initialState);\n        System.out.println(steps);\n    }\n\n    private static int solvePuzzle(int[][] initialState) {\n        String start = matrixToString(initialState);\n        String goal = matrixToString(GOAL_STATE);\n\n        Queue<String> queue = new LinkedList<>();\n        Map<String, Integer> visited = new HashMap<>();\n\n        queue.offer(start);\n        visited.put(start, 0);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            int moves = visited.get(current);\n\n            if (current.equals(goal)) {\n                return moves;\n            }\n\n            int[][] currentState = stringToMatrix(current);\n            int zeroRow = -1, zeroCol = -1;\n\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (currentState[i][j] == 0) {\n                        zeroRow = i;\n                        zeroCol = j;\n                        break;\n                    }\n                }\n                if (zeroRow != -1) break;\n            }\n\n            for (int k = 0; k < 4; k++) {\n                int newRow = zeroRow + dx[k];\n                int newCol = zeroCol + dy[k];\n\n                if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {\n                    int[][] newState = copyMatrix(currentState);\n                    newState[zeroRow][zeroCol] = newState[newRow][newCol];\n                    newState[newRow][newCol] = 0;\n\n                    String newStateStr = matrixToString(newState);\n                    if (!visited.containsKey(newStateStr)) {\n                        queue.offer(newStateStr);\n                        visited.put(newStateStr, moves + 1);\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static String matrixToString(int[][] matrix) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] row : matrix) {\n            for (int num : row) {\n                sb.append(num);\n            }\n        }\n        return sb.toString();\n    }\n\n    private static int[][] stringToMatrix(String str) {\n        int[][] matrix = new int[3][3];\n        for (int i = 0; i < 9; i++) {\n            matrix[i / 3][i % 3] = str.charAt(i) - '0';\n        }\n        return matrix;\n    }\n\n    private static int[][] copyMatrix(int[][] matrix) {\n        int[][] copy = new int[3][3];\n        for (int i = 0; i < 3; i++) {\n            System.arraycopy(matrix[i], 0, copy[i], 0, 3);\n        }\n        return copy;\n    }\n}",
    "timestamp": "2025-08-05 22:12:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int TARGET[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\nstruct State {\n    int grid[3][3];\n    int zeroRow, zeroCol;\n    int steps;\n    \n    bool operator==(const State& other) const {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (grid[i][j] != other.grid[i][j]) return false;\n            }\n        }\n        return true;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State& state) const {\n        size_t hash = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                hash = hash * 31 + state.grid[i][j];\n            }\n        }\n        return hash;\n    }\n};\n\nbool isGoal(const State& state) {\n    return memcmp(state.grid, TARGET, sizeof(TARGET)) == 0;\n}\n\nint bfs(State initial) {\n    queue<State> q;\n    unordered_set<State, StateHash> visited;\n    \n    q.push(initial);\n    visited.insert(initial);\n    \n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (isGoal(current)) {\n            return current.steps;\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int newRow = current.zeroRow + dx[k];\n            int newCol = current.zeroCol + dy[k];\n            \n            if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {\n                State next = current;\n                swap(next.grid[current.zeroRow][current.zeroCol], \n                     next.grid[newRow][newCol]);\n                next.zeroRow = newRow;\n                next.zeroCol = newCol;\n                next.steps++;\n                \n                if (visited.find(next) == visited.end()) {\n                    q.push(next);\n                    visited.insert(next);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    State initial;\n    initial.steps = 0;\n    \n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> initial.grid[i][j];\n            if (initial.grid[i][j] == 0) {\n                initial.zeroRow = i;\n                initial.zeroCol = j;\n            }\n        }\n    }\n    \n    int result = bfs(initial);\n    \n    if (result == -1) {\n        cout << \"Unsolvable\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef get_neighbors(state):\n    neighbors = []\n    zero_idx = state.index(0)\n    zero_row, zero_col = divmod(zero_idx, 3)\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for dr, dc in directions:\n        nr, nc = zero_row + dr, zero_col + dc\n        if 0 <= nr < 3 and 0 <= nc < 3:\n            new_zero_idx = nr * 3 + nc\n            new_state = list(state)\n            new_state[zero_idx], new_state[new_zero_idx] = new_state[new_zero_idx], new_state[zero_idx]\n            neighbors.append(tuple(new_state))\n    \n    return neighbors\n\ndef heuristic(state, target):\n    return sum(s != t and s != 0 for s, t in zip(state, target))\n\ndef a_star(initial, target=(1, 2, 3, 4, 5, 6, 7, 8, 0)):\n    pq = []\n    heapq.heappush(pq, (0, 0, initial))\n    came_from = {initial: None}\n    g_score = {initial: 0}\n\n    while pq:\n        _, current_g, current = heapq.heappop(pq)\n        \n        if current == target:\n            return current_g\n        \n        for neighbor in get_neighbors(current):\n            tentative_g = current_g + 1\n            \n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, target)\n                heapq.heappush(pq, (f_score, tentative_g, neighbor))\n                came_from[neighbor] = current\n\n    return -1\n\ninitial_state = tuple(map(int, input().strip().split()))\nprint(a_star(initial_state))",
    "timestamp": "2025-08-13 09:18:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class EightPuzzle {\n\n    static class PuzzleState {\n        int[][] board;\n        int zeroRow, zeroCol;\n        int steps;\n\n        PuzzleState(int[][] board, int zeroRow, int zeroCol, int steps) {\n            this.board = board;\n            this.zeroRow = zeroRow;\n            this.zeroCol = zeroCol;\n            this.steps = steps;\n        }\n\n        String boardKey() {\n            StringBuilder sb = new StringBuilder();\n            for (int[] row : board) {\n                for (int num : row) {\n                    sb.append(num);\n                }\n            }\n            return sb.toString();\n        }\n\n        PuzzleState move(int newRow, int newCol) {\n            int[][] newBoard = new int[3][3];\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    newBoard[i][j] = board[i][j];\n                }\n            }\n            newBoard[zeroRow][zeroCol] = newBoard[newRow][newCol];\n            newBoard[newRow][newCol] = 0;\n            return new PuzzleState(newBoard, newRow, newCol, steps + 1);\n        }\n    }\n\n    public static int minStepsToSolve(int[][] initialBoard) {\n        int[][] targetBoard = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 0}\n        };\n\n        if (Arrays.deepEquals(initialBoard, targetBoard)) {\n            return 0;\n        }\n\n        int initialZeroRow = 0, initialZeroCol = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (initialBoard[i][j] == 0) {\n                    initialZeroRow = i;\n                    initialZeroCol = j;\n                    break;\n                }\n            }\n        }\n\n        PuzzleState initialState = new PuzzleState(initialBoard, initialZeroRow, initialZeroCol, 0);\n\n        Queue<PuzzleState> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.offer(initialState);\n        visited.add(initialState.boardKey());\n\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        while (!queue.isEmpty()) {\n            PuzzleState currentState = queue.poll();\n\n            for (int[] dir : directions) {\n                int newRow = currentState.zeroRow + dir[0];\n                int newCol = currentState.zeroCol + dir[1];\n\n                if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {\n                    PuzzleState newState = currentState.move(newRow, newCol);\n                    if (Arrays.deepEquals(newState.board, targetBoard)) {\n                        return newState.steps;\n                    }\n\n                    String newBoardKey = newState.boardKey();\n                    if (!visited.contains(newBoardKey)) {\n                        visited.add(newBoardKey);\n                        queue.offer(newState);\n                    }\n                }\n            }\n        }\n        return -1; // Should not reach here for solvable puzzles\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] initialBoard = new int[3][3];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                initialBoard[i][j] = scanner.nextInt();\n            }\n        }\n        System.out.println(minStepsToSolve(initialBoard));\n    }\n}",
    "timestamp": "2025-08-13 09:18:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 3\n#define MAX_STATES 362880  // Factorial of 9 (unique permutations of the puzzle)\n\ntypedef struct {\n    int board[N][N];\n    int empty_row, empty_col;\n    int moves;\n} State;\n\nint target[N][N] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\n\n// Direction vectors\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n// Position factorials for unique state hashing\nint factorial[10];\n\n// Check if two states are equal\nint is_equal(int a[N][N], int b[N][N]) {\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            if (a[i][j] != b[i][j])\n                return 0;\n    return 1;\n}\n\n// Compute a unique hash for a given puzzle configuration\nint hash(int board[N][N]) {\n    int used[N * N] = {0};\n    int hash_value = 0;\n    int factor_idx = N * N - 1;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int num = board[i][j];\n            int count = 0;\n            \n            for (int k = 1; k < num; ++k) {\n                if (!used[k]) count++;\n            }\n\n            hash_value += count * factorial[factor_idx];\n            used[num] = 1;\n            factor_idx--;\n        }\n    }\n\n    return hash_value;\n}\n\n// Solve the 8 Puzzle using BFS\nint solve(int initial[N][N]) {\n    State queue[MAX_STATES];\n    int visited[MAX_STATES] = {0};\n\n    int front = 0, rear = 0;\n\n    // Initialize\n    State start_state;\n    memcpy(start_state.board, initial, sizeof(start_state.board));\n    start_state.moves = 0;\n\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            if (initial[i][j] == 0) {\n                start_state.empty_row = i;\n                start_state.empty_col = j;\n                break;\n            }\n\n    queue[rear++] = start_state;\n    visited[hash(initial)] = 1;\n\n    // BFS\n    while (front != rear) {\n        State current = queue[front++];\n        \n        if (is_equal(current.board, target))\n            return current.moves;\n\n        for (int d = 0; d < 4; ++d) {\n            int new_row = current.empty_row + dx[d];\n            int new_col = current.empty_col + dy[d];\n\n            if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                State next = current;\n                next.moves += 1;\n\n                // Perform swap\n                int temp = next.board[new_row][new_col];\n                next.board[new_row][new_col] = next.board[current.empty_row][current.empty_col];\n                next.board[current.empty_row][current.empty_col] = temp;\n\n                next.empty_row = new_row;\n                next.empty_col = new_col;\n\n                if (!visited[hash(next.board)]) {\n                    queue[rear++] = next;\n                    visited[hash(next.board)] = 1;\n                }\n            }\n        }\n    }\n\n    return -1;  // If the target is unreachable\n}\n\nint main() {\n    int initial[N][N];\n    factorial[0] = 1;\n    \n    // Precompute factorials\n    for (int i = 1; i <= 9; ++i) {\n        factorial[i] = factorial[i - 1] * i;\n    }\n\n    // Read the initial state\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            scanf(\"%d\", &initial[i][j]);\n\n    int steps = solve(initial);\n    printf(\"%d\\n\", steps);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:18:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom queue import Queue\n\ndef solve_8_puzzle(initial_state: List[List[int]]) -> int:\n    target_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    \n    def state_to_tuple(state):\n        return tuple(tuple(row) for row in state)\n    \n    def find_zero(state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n    \n    def get_neighbors(state):\n        neighbors = []\n        zero_row, zero_col = find_zero(state)\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for dx, dy in directions:\n            new_row, new_col = zero_row + dx, zero_col + dy\n            \n            if 0 <= new_row < 3 and 0 <= new_col < 3:\n                new_state = [row[:] for row in state]\n                new_state[zero_row][zero_col], new_state[new_row][new_col] = \\\n                    new_state[new_row][new_col], new_state[zero_row][zero_col]\n                neighbors.append(new_state)\n        \n        return neighbors\n    \n    visited = set()\n    queue = Queue()\n    queue.put((initial_state, 0))\n    \n    while not queue.empty():\n        current_state, steps = queue.get()\n        \n        if current_state == target_state:\n            return steps\n        \n        state_tuple = state_to_tuple(current_state)\n        if state_tuple in visited:\n            continue\n        \n        visited.add(state_tuple)\n        \n        for neighbor in get_neighbors(current_state):\n            queue.put((neighbor, steps + 1))\n    \n    return -1\n\ndef main():\n    initial_state = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        initial_state.append(row)\n    \n    print(solve_8_puzzle(initial_state))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:18:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_puzzle(initial_state):\n    target = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n    if tuple(initial_state) == target:\n        return 0\n    \n    visited = set()\n    queue = deque()\n    queue.append((tuple(initial_state), 0))\n    visited.add(tuple(initial_state))\n    \n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        current, steps = queue.popleft()\n        if current == target:\n            return steps\n        \n        zero_pos = current.index(0)\n        x, y = zero_pos // 3, zero_pos % 3\n        \n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 3 and 0 <= ny < 3:\n                new_pos = nx * 3 + ny\n                current_list = list(current)\n                current_list[zero_pos], current_list[new_pos] = current_list[new_pos], current_list[zero_pos]\n                new_state = tuple(current_list)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, steps + 1))\n    \n    return -1\n\ninitial_state = list(map(int, input().split()))\nprint(solve_puzzle(initial_state))",
    "timestamp": "2025-08-13 09:18:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct PuzzleState {\n    vector<int> board;\n    int zeroPos;\n    int steps;\n};\n\nvector<vector<int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nbool isSolvable(vector<int> board) {\n    int inversions = 0;\n    for (int i = 0; i < board.size(); ++i) {\n        if (board[i]) {\n            for (int j = 0; j < i; ++j) {\n                if (board[j] && board[j] > board[i]) {\n                    ++inversions;\n                }\n            }\n        }\n    }\n    return inversions % 2 == 0;\n}\n\nint bfs(vector<int>& start, vector<int>& target) {\n    string targetStr = \"\";\n    for (int i : target) targetStr += to_string(i);\n\n    queue<PuzzleState> q;\n    unordered_map<string, bool> visited;\n\n    int zeroPos = find(start.begin(), start.end(), 0) - start.begin();\n    q.push({start, zeroPos, 0});\n\n    string startStr = \"\";\n    for (int i : start) startStr += to_string(i);\n    visited[startStr] = true;\n\n    while (!q.empty()) {\n        PuzzleState current = q.front(); q.pop();\n        if (current.board == target) return current.steps;\n\n        int row = current.zeroPos / 3;\n        int col = current.zeroPos % 3;\n        \n        for (auto dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {\n                int newZeroPos = newRow * 3 + newCol;\n                swap(current.board[current.zeroPos], current.board[newZeroPos]);\n                \n                string newState = \"\";\n                for (int i : current.board) newState += to_string(i);\n\n                if (!visited[newState]) {\n                    visited[newState] = true;\n                    q.push({current.board, newZeroPos, current.steps + 1});\n                }\n                \n                swap(current.board[current.zeroPos], current.board[newZeroPos]);\n            }\n        }\n    }\n\n    return -1; // Should not be reachable for a solvable puzzle\n}\n\nint main() {\n    vector<int> start(9), target = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    for (int i = 0; i < 9; ++i) {\n        cin >> start[i];\n    }\n\n    if (!isSolvable(start)) {\n        cout << -1 << endl; // Unsolvable\n    } else {\n        int result = bfs(start, target);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:38"
  }
]