[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\n#define long long long // for codeforces\n\nconst long N = 100010;\nconst long INF = 123456789123456789;\n\nstruct edge {\n  int to,w;\n};\n\nvector<edge> G[N];\nlong d[N];\n\nclass LCA {\npublic:\n  int n, ln; // number of nodes and its log\n  vector<vector<int>> parent;\n  vector<int> depth;\n  LCA(int _n, int root=-1) : n(_n), depth(_n){\n    ln=0;\n    while(n>=(1<<ln)) ln++;  // calc log n\n    parent = vector<vector<int>>(ln, vector<int>(n));\n    if(root!=-1) init(root);\n  }\n  void dfs(const int v, const int p, const int w){\n    parent[0][v] = p;\n    depth[v] = w;\n    for(auto to : G[v]) if(to.to != p) dfs(to.to, v, w+1);\n  }\n  void init(const int root){\n    dfs(root, -1, 0);\n    for(int k=0; k+1<ln; k++){\n      for(int v=0; v<n; v++){\n        if(parent[k][v] < 0) parent[k+1][v] = -1;\n        else parent[k+1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n  int query(int u, int v) const {\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<ln; k++){\n      if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    for(int k=ln-1; k>=0; k--){\n      if(parent[k][u] != parent[k][v]){\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n  long dist(const int s, const int t) const {\n    int p = query(s,t);\n    if(s != p && t != p) return d[s] + d[t] - 2*d[p];\n    else return abs(d[s] - d[t]);\n  }\n};\n\nvoid bfs(int v){\n  for(auto e: G[v]) if(d[e.to] == INF) {\n    d[e.to] = d[v] + e.w;\n    bfs(e.to);\n  }\n}\n\nint main(){\n  int n,q;\n  cin>>n>>q;\n\n  rep(i,n-1){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    G[a].pb({b,c});\n    G[b].pb({a,c});\n  }\n\n  const int root = 0;\n  LCA lca(n, root);\n  fill(d, d+n, INF);\n  d[root] = 0;\n  bfs(root);\n\n  rep(_,q){\n    int a,b,c;\n    cin>>a>>b>>c;\n    dbg(a,b,c);\n    a--;b--;c--;\n\n    long ab = lca.dist(a,b);\n    long bc = lca.dist(b,c);\n    long ca = lca.dist(c,a);\n\n    int x,y;\n    if(ab >= bc && ab >= ca) {x=a,y=b;}\n    else if(bc >= ab && bc >= ca) {x=b,y=c;}\n    else {x=a,y=c;}\n\n    int ch;\n\n    int l = lca.query(x,y);\n    long dx = lca.dist(l,x);\n    long dy = lca.dist(l,y);\n    if(dx >= dy) ch = x;\n    else ch = y;\n\n    long ddd = lca.dist(x,y);\n\n    // ch から l までダブリングして求める\n    const auto calc = [&](const int m) {\n      return max(lca.dist(a,m), max(lca.dist(b,m), lca.dist(c,m)));\n    };\n    int mid = ch;\n    for(int k = lca.ln-1; k >= 0; k--){\n      if(lca.parent[k][mid] != -1){\n        int cand = lca.parent[k][mid];\n        if(lca.depth[l] > lca.depth[cand]) continue;\n        if(lca.dist(ch, cand)*2 <= ddd) mid = cand;\n      }\n    }\n\n    long ans = calc(mid);\n    if(lca.parent[0][mid] != -1) ans = min(ans, calc(lca.parent[0][mid]));\n\n    cout << ans << \"\\n\";\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100010;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int dul = D(u,LCA);\n\n        int c,s;\n        if(x <= dul){\n            c = u;\n            s = x;\n        }\n        else{\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        // printf(\" cs %d %d\\n\",c,s);\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n\n        // dbg(c);\n        assert(c >= 0);\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) > g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint32 N, Q;\nvector<PII> G[112345];\nint64 dep[112345], dis[112345];\nint64 par[112345][20];\n\nvoid dfs(int32 v=0, int32 p=-1, int32 d=0, int32 x=0){\n\tdep[v] = d; dis[v] = x;\n\tpar[v][0] = p;\n\tREP(i, G[v].size()){\n\t\tint32 u, di;\n\t\ttie(di, u) = G[v][i];\n\t\tif(u == p){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(u, v, d+1, x+di);\n\t}\n}\n\nvoid build(){\n\tREP(k, 20){\n\t\tREP(i, N){\n\t\t\tif(par[i][k] != -1)\n\t\t\t\tpar[i][k+1] = par[par[i][k]][k];\n\t\t}\n\t}\n}\n\nint32 lca(int32 u, int32 v){\n\tif(dep[u] < dep[v]) swap(u, v);\n\tREP(i, 20){\n\t\tif((dep[u]-dep[v]) >> i & 1) u = par[u][i];\n\t}\n\tif(u == v) return u;\n\tfor(int32 i = 19;i >= 0;i--){\n\t\tif(par[u][i] != -1 && par[u][i] != par[v][i]){\n\t\t\tu = par[u][i];\n\t\t\tv = par[v][i];\n\t\t}\n\t}\n\treturn par[u][0];\n}\n\nint64 dist(int32 u, int32 v){\n\treturn dis[u]+dis[v]-2*dis[lca(u, v)];\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tmemset(dep, -1, sizeof dep);\n\tmemset(par, -1, sizeof par);\n\tmemset(dis, -1, sizeof dis);\n\tcin >> N >> Q;\n\tREP(i, N-1){\n\t\tint32 u, v, w;\n\t\tcin >> u >> v >> w; u--; v--;\n\t\tG[u].push_back(PII(w, v));\n\t\tG[v].push_back(PII(w, u));\n\t}\n\tdfs();\n\tbuild();\n\n\tREP(i, Q){\n\t\tint32 a, b, c;\n\t\tcin >> a >> b >> c; a--; b--; c--;\n\t\tPII p(a, b);\n\t\tif(dist(b, c) > dist(p.fs, p.sc)) p = PII(b, c);\n\t\tif(dist(a, c) > dist(p.fs, p.sc)) p = PII(a, c);\n\t\tint64 w = dist(p.fs, p.sc)/2;\n\t\tint32 r = lca(p.fs, p.sc);\n\t\tif(dis[p.fs] < dis[p.sc]) swap(p.fs, p.sc);\n\t\tint32 u = p.fs;\n\t\tfor(int32 i = 19;i >= 0;i--){\n\t\t\tif(dist(par[u][i], p.fs) < w)\n\t\t\t\tu = par[u][i];\n\t\t}\n\t\tint64 res = INF_LL;\n\t\tres = min(res, max({dist(u, a), dist(u, b), dist(u, c)}));\n\t\tif(par[u][0] != -1){\n\t\t\tu = par[u][0];\n\t\t\tres = min(res, max({dist(u, a), dist(u, b), dist(u, c)}));\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100010;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 16;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int dul = D(u,LCA);\n\n        int c,s;\n        if(x <= dul){\n            c = u;\n            s = x;\n        }\n        else{\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        // printf(\" cs %d %d\\n\",c,s);\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n\n        // dbg(c);\n        assert(c >= 0);\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) > g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100000;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\ninline int D(int u, int v){\n    int l = lca(u,v);\n    return depth[u]+depth[v]-2*depth[l];\n}\n\ninline int WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int c = u,s = x;\n        if(D(u,LCA) < x){\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) >= g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n\n        G[u].pb(v);\n        G[v].pb(u);\n        wG[u].pb({v,w});\n        wG[v].pb({u,w});\n    }\n\n    lca_init(n);\n\n    wd[root] = 0;\n    calc_dist(root,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define swap(i,j) { int tmp = i; i = j; j = tmp; }\n\nint n;\nvector< pair<int, int> > graph[100010];\nvector<int> tree[100010];\nvector<int> subtree[100010];\n\nint par[100010] = {};\nint num[100010] = {};\nint deep[100010] = {};\nint vid[100010];\nint nid[100010];\nint head[100010];\nint team[100010];\nint dist[100010];\nint size[100010] = {};\nint b = 0;\n\nbool used[100010] = {};\nint maketree(int i){\n  used[i] = true;\n  for(int x = 0;x < graph[i].size();x++){\n    if(!used[graph[i][x].first]){\n      par[graph[i][x].first] = i;\n      dist[graph[i][x].first] = graph[i][x].second;\n      tree[i].push_back(graph[i][x].first);\n      maketree(graph[i][x].first);\n    }\n  }\n}\n\nint setnum(int i, int j, int k){\n  dist[i] = j+dist[i];\n  deep[i] = k;\n  if(tree[i].size() == 0) return num[i] = 1;\n\n  int ret = 1;\n  for(int x = 0;x < tree[i].size();x++){\n    ret += setnum(tree[i][x],dist[i],k+1);\n  }\n\n  return num[i] = ret;\n}\n\nvoid dis(int n){\n  memset(team,-1,sizeof(team));\n  priority_queue<pair<int, int> > que;\n  for(int i = 0;i < n;i++){\n    que.push(make_pair(num[i], i));\n  }\n\n  int gnum = 0;\n  int next;\n  int pos = 0;\n  int i;\n  while(!que.empty()){\n    i = que.top().second; que.pop();\n    if(team[i] != -1) continue;\n    team[i] = gnum;\n    size[gnum]++;\n    subtree[gnum].push_back(i);\n    nid[i] = 0;\n    int nn = 1;\n    head[i] = i;\n    vid[i] = pos;\n    pos++;\n    next = i;\n    while(tree[next].size() != 0){\n      int maxi = 0;\n      for(int j = 1;j < tree[next].size();j++){\n        if(num[tree[next][maxi]] < num[tree[next][j]]){\n          maxi = j;\n        }\n      }\n      subtree[gnum].push_back(tree[next][maxi]);\n      team[tree[next][maxi]] = gnum;\n      head[tree[next][maxi]] = i;\n      vid[tree[next][maxi]] = pos;\n      nid[tree[next][maxi]] = nn;\n      size[gnum]++;\n      pos++;\n      nn++;\n      next = tree[next][maxi];\n    }\n    gnum++;\n  }\n  return;\n}\n\nvoid build(int n){\n  maketree(0);\n  setnum(0,0,0);\n  dis(n);\n  return;\n}\n\nint lca(int i, int j){\n  while(1){\n    if(vid[i] > vid[j]) swap(i, j);\n    if(head[i] == head[j]) return i;\n    j = par[head[j]];\n  }\n}\n\nint getdist(int i, int j){\n  return dist[i] + dist[j] - 2 * dist[lca(i, j)];\n}\n\nint getlen(int i, int j){\n  return deep[i] + deep[j] - 2 * deep[lca(i, j)];\n}\n\nint treeSearch(int a, int m){\n  if(size[team[a]] - (size[team[a]]-nid[a]-1) > m){\n    return subtree[team[a]][nid[a]-m];\n  }else{\n    return treeSearch(par[head[a]],m-(size[team[a]]-(size[team[a]]-nid[a]-1)));\n  }\n}\n\nint x, y, z;\nint maxdist(int i){\n  return max(getdist(x,i), max(getdist(y,i),getdist(z,i)));\n}\n\nint ordist(int i,int a){\n  return max(getdist(x,i) * (x != a), max(getdist(y,i) * (y != a) ,getdist(z,i) * (z != a)));\n}\n\nint path(int u, int v, int d){\n  if(d == 0) return 0;\n  int r = lca(u, v);\n  int x = getlen(u, r), y = getlen(r, v);\n  if(d <= x) return treeSearch(u,d);\n  return treeSearch(v,(x+y)-d);\n}\n\nint search(int u, int v, int ans){\n\n  if(ordist(v, u) >= ans) return ans;\n\n  int left = 0;\n  int right = getlen(u, v);\n  int dat, mid;\n\n  while(left+1 < right){\n    mid = (left + right) / 2;\n    dat = path(u,v,mid);\n    if(ordist(dat,u) < getdist(dat,u)){\n      right = mid;\n    }else{\n      left = mid;\n    }\n  }\n\n  return min(ans,min(maxdist(path(u,v,left)),maxdist(path(u,v,right))));\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int q;\n  cin >> n >> q;\n\n  int a, b, c;\n  for(int i = 0;i < n-1;i++){\n    cin >> a >> b >> c;\n    a--; b--;\n    graph[a].push_back(make_pair(b,c));\n    graph[b].push_back(make_pair(a,c));\n  }\n\n  build(n);\n\n  int mid;\n  int ans;\n  for(int i = 0;i < q;i++){\n    cin >> x >> y >> z;\n    x--; y--; z--;\n    a = lca(x,y); b = lca(y,z); c = lca(z,x);\n    mid = deep[a] > deep[b] ? (deep[a] > deep[c] ? a : c) : (deep[b] > deep[c] ? b : c);\n    ans = min(maxdist(x), min(maxdist(y), min(maxdist(z), maxdist(mid))));\n\n    ans = search(x,mid,ans);\n    ans = search(y,mid,ans);\n    ans = search(z,mid,ans);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i, n)       for (i64 i = 0, i##_limit = (n); i < i##_limit; ++i)\n\nusing namespace std;\nusing i64 = int_fast64_t;\ntemplate<class T, class U>inline bool chmax(T &a, const U &b){return b>a && (a=b, true);}\ntemplate<class T, class U>inline bool chmin(T &a, const U &b){return b<a && (a=b, true);}\nconstexpr int INF  = 0x3f3f3f3f;\nconstexpr i64 LINF = 0x3f3f3f3f3f3f3f3fLL;\n\nstruct Edge { // {{{\n    int src, to;\n    int64_t cost = 0;\n\n    inline Edge(int src,  int to, const int64_t &cost) noexcept :\n        src(src), to(to), cost(cost) {}\n\n    inline Edge(int to, const int64_t &cost) noexcept :\n        src(-1), to(to), cost(cost) {}\n\n    inline Edge() noexcept {}\n\n    bool operator< (const Edge &o) const noexcept { return cost < o.cost; }\n    bool operator> (const Edge &o) const noexcept { return o < *this; }\n\n    Edge& operator=(int to) noexcept {\n        this->to = to;\n        return *this;\n    }\n\n    operator int() const noexcept { return to; }\n};\n// }}}\nusing WeightedGraph     = vector<vector<Edge>>;\nusing UnWeightedGraph   = vector<vector<int>>;\n\nclass HeavyLightDecomposition { // {{{\npublic:\n    WeightedGraph G;            // 重み付きグラフ\n    const int V;                // ノード数\n    vector<int> parent;         // 親\n    vector<int> treeSize;       // 自分も含めた部分木のサイズ\n    vector<int> head;           // HL分解後の自分が属するグループ(チェイン)の先頭ノード\n    vector<int> vid;            // 根からDFSしたときにそのノードを訪れた順番\n    vector<int> nodeOfVid;      // vidからノードを逆算する用\n    vector<int64_t> weightSum;  // 根からのコストの総和\n    vector<int> depth;          // 根からの深さ(経由するエッジの数)\n\n    HeavyLightDecomposition() = delete;\n\n    // 空の木を構築する。管理できるノードは [0, V) なので注意。\n    explicit HeavyLightDecomposition(int V) :\n        G(V), V(V),\n        parent(V, -1), treeSize(V), head(V),\n        vid(V), nodeOfVid(V),\n        weightSum(V, 0),\n        depth(V, 0) {}\n\n\n    // u-v間に無向辺を張る。重みは省略可\n    inline void addEdge(int u, int v, int64_t weight = 1) {\n        G[u].emplace_back(u, v, weight);\n        G[v].emplace_back(v, u, weight);\n    }\n\n    // HL分解、その他もろもろ前計算\n    void build(int root = 0) {\n        int timestamp = 0;\n        head[root] = root;\n        dfs_treeSize(root);\n        dfs_HLDecomp(root, timestamp);\n    }\n\n    // u,v の最小共通祖先を求める\n    int lca(int u, int v) const {\n        while(head[u] != head[v]) {\n            if (vid[u] > vid[v]) swap(u, v);\n            v = parent[head[v]];\n        }\n        return (vid[u] < vid[v]) ? u : v;\n    }\n\n    // 根に向かって v から k だけ登ったノードを求める\n    int climb(int v, int k) const {\n        while(1) {\n            const int h = head[v];\n            if (vid[v] - k >= vid[h]) return nodeOfVid[vid[v] - k];\n            k -= vid[v] - vid[h] + 1;\n            v = parent[h];\n        }\n    }\n\n    // u-v間のパスの重みの和を求める\n    int64_t pathWeight(int u, int v) const {\n        return weightSum[u] + weightSum[v] - (2 * weightSum[lca(u, v)]);\n    }\n\n    // u-v間のパスの「エッジの個数」を求める\n    int pathCountEdge(int u, int v) const {\n        return depth[u] + depth[v] - (2 * depth[lca(u, v)]);\n    }\n\nprivate: // {{{\n\n    // treeSize[v], parent[v], depth[v], weightSum[v] を再帰によって計算\n    // v の子の中で最もheavyなやつを G[v] の先頭にもってくる\n    int dfs_treeSize(int v) {\n        treeSize[v] = 1;\n        if (!G[v].empty() && G[v].front().to == parent[v]) swap(G[v].front(), G[v].back());\n        for (auto &e : G[v]) {\n            if (e.to == parent[v]) continue;\n            parent[e.to] = v;\n            depth[e.to] = depth[v] + 1;\n            weightSum[e.to] = weightSum[v] + e.cost;\n            treeSize[v] += dfs_treeSize(e.to);\n            if (treeSize[e.to] > treeSize[G[v].front()]) swap(e, G[v].front());\n        }\n        return treeSize[v];\n    }\n\n    // G[v] の先頭に v の子中で最もheavyなノードがある前提でHL分解し、\n    // vid[v], nodeOfVid[v], head[v] を求める\n    void dfs_HLDecomp(int v, int &timestamp) {\n        vid[v] = timestamp;\n        nodeOfVid[timestamp] = v;\n        ++timestamp;\n        for (const int to : G[v]) {\n            if (to == parent[v]) continue;\n            head[to] = (to == G[v].front() ? head[v] : to);\n            dfs_HLDecomp(to, timestamp);\n        }\n    } // }}}\n}; // }}}\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n    HeavyLightDecomposition G(N+1);\n\n    rep(i, N - 1) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        G.addEdge(u, v, w);\n    }\n\n    // 根のノードを1としてHL分解\n    G.build(1);\n\n    // a-b, a-c, b-c の3つのパスの中で重みが最大のものを探し、\n    // { パスの始点, パスの終点 } のペアを返す。\n    const auto maxWeightPath = [&G](int a, int b, int c) -> pair<int,int> {\n        const auto weightAB = G.pathWeight(a, b);\n        const auto weightAC = G.pathWeight(a, c);\n        const auto weightBC = G.pathWeight(b, c);\n        const auto maxv = max({ weightAB, weightAC, weightBC });\n        if (maxv == weightAB) return { a, b };\n        if (maxv == weightAC) return { a, c };\n        return { b, c };\n    };\n\n    // s からlcaに向かって登る距離を [low, high) で2分探索\n    // (パス[s-lca]上で、weight(s, p) < weight(t, p) を満たし、s からできるだけ離れたノードを探索)\n    // 探索途中のノードも解の候補に含めるので逐次 res を更新する\n    const auto binSearch = [&G](int s, int lca, int t) -> i64 {\n        i64 res = LINF;\n        int low = 0;\n        int high = G.pathCountEdge(s, lca) + 1;\n        while(high - low > 1) {\n            const int mid = (low + high) / 2;\n            const int p = G.climb(s, mid);\n            const auto weightSP = G.pathWeight(s, p);\n            const auto weightTP = G.pathWeight(t, p);\n            chmin(res, max(weightSP, weightTP));\n            if (weightSP < weightTP) {\n                low = mid;\n            } else {\n                high = mid;\n            }\n        }\n        const int p = G.climb(s, low);\n        chmin(res, max(G.pathWeight(s, p), G.pathWeight(t, p)));\n        return res;\n    };\n\n    const auto solve = [&](int a, int b, int c) -> i64 {\n        int s, t;\n        tie(s, t) = maxWeightPath(a, b, c);\n        const int lca = G.lca(s, t);\n        return min(binSearch(s, lca, t), binSearch(t, lca, s));\n    };\n\n    rep(i, Q) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        cout << solve(a, b, c) << \"\\n\";\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100000;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return depth[u]+depth[v]-2*depth[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int c = u,s = x;\n        if(D(u,LCA) < x){\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) >= g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n\n        G[u].pb(v);\n        G[v].pb(u);\n        wG[u].pb({v,w});\n        wG[v].pb({u,w});\n    }\n\n    lca_init(n);\n\n    wd[root] = 0;\n    calc_dist(root,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min(f(a,b,c),f(a,c,b));\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100010;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int dul = D(u,LCA);\n\n        int c,s;\n        if(x <= dul){\n            c = u;\n            s = x;\n        }\n        else{\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        // printf(\" cs %d %d\\n\",c,s);\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n\n        // dbg(c);\n        assert(c >= 0);\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (2*l+r)/3;\n        int m2 = (l+2*r)/3;\n        if(g(m1) > g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n \n \n#define NUM 100005\n \nstruct Edge{\n    Edge(int arg_to,ll arg_cost){\n        to = arg_to;\n        cost = arg_cost;\n    }\n    int to;\n    ll cost;\n};\n \nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint N; //ノードの個数\nint root; //根ノードの番号\nint MAX_LOG_V = 17;\nint POW[18];\nint parent[20][NUM];\nint depth[NUM];\nll COST[NUM];\n \n//parentとdepthを再帰的に設定\nvoid dfs(int node_id,int parent_id,int d,ll sum_cost){\n \n    parent[0][node_id] = parent_id;\n    depth[node_id] = d;\n    COST[node_id] = sum_cost;\n \n    for(int i = 0; i < G[node_id].size(); i++){\n        if(G[node_id][i].to != parent_id){\n            dfs(G[node_id][i].to,node_id,d+1,sum_cost+G[node_id][i].cost);\n        }\n    }\n}\n \n//初期化\nvoid init(){\n    //parent[0]とdepthを初期化する\n    dfs(root,-1,0,0);\n    //parentを初期化する\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int node_id = 0; node_id < N; node_id++){\n            if(parent[k][node_id] < 0)parent[k+1][node_id] = -1; //node_idの2^k上のノードがルートノードより上なら、2^(k+1)上も同様とする\n            else{\n                parent[k+1][node_id] = parent[k][parent[k][node_id]];\n            }\n        }\n    }\n}\n \n//leftとrightのLCAを求める\nint lca(int left,int right){\n    //leftとrightの深さが同じになるまで親を辿る\n    if(depth[left] > depth[right])swap(left,right); //rightの方が深い所にいる\n \n    for(int k = MAX_LOG_V-1; k >= 0; k--){\n        if(depth[right]-depth[left] >= POW[k]){ //たとえば深さの差が39なら、32+4+2+1のように、ノードを上方に移動させる\n            right = parent[k][right];\n        }\n    }\n \n    if(left == right)return left;\n \n    for(int k = MAX_LOG_V-1; k >= 0; k--){\n        if(parent[k][left] == parent[k][right]){\n            //Do nothing\n        }else{\n            left = parent[k][left];\n            right = parent[k][right];\n        }\n    }\n    return parent[0][left]; //最後は、leftの親とrightの親が必ず一致している\n}\n \nll get_cost(int left,int right){\n \n    int LCA = lca(left,right);\n \n    return COST[left]+COST[right]-2*COST[LCA];\n}\n \nint get_node(int base_node,int diff){\n \n    int ret = base_node;\n \n    for(int loop = MAX_LOG_V-1; loop >= 0; loop--){\n        if(diff & (1 << loop)){\n            ret = parent[loop][ret];\n        }\n    }\n    return ret;\n}\n \nll calc_ans(int deeper,int LCA,ll DIST){\n \n    int L = LCA,R = deeper,mid;\n \n    ll ret = HUGE_NUM;\n \n    ll cost_to_mid,REST;\n \n    for(int loop = 0; loop < 20; loop++){\n \n        mid = get_node(R,(depth[R]-depth[L])/2);\n \n        cost_to_mid = COST[deeper]-COST[mid];\n        REST = DIST-cost_to_mid;\n \n        ret = min(ret,max(cost_to_mid,REST));\n \n        if(cost_to_mid == REST){\n \n            return ret;\n \n        }else if(cost_to_mid < REST){\n \n            R = parent[0][mid];\n \n        }else{\n \n            L = mid;\n        }\n    }\n \n    return ret;\n}\n \nll calc(int a,int b,int c){\n \n    ll dist[3];\n \n    dist[0] = get_cost(a,b);\n    dist[1] = get_cost(a,c);\n    dist[2] = get_cost(b,c);\n \n    ll maximum = -HUGE_NUM;\n    int index;\n    for(int i = 0; i < 3; i++){\n        if(maximum < dist[i]){\n            maximum = dist[i];\n            index = i;\n        }\n    }\n \n    int left,right;\n    ll DIST = maximum;\n \n    switch(index){\n    case 0:\n        left = a;\n        right = b;\n        break;\n    case 1:\n        left = a;\n        right = c;\n        break;\n    case 2:\n        left = b;\n        right = c;\n        break;\n    }\n \n    int LCA = lca(left,right);\n \n    ll cost_left = get_cost(left,LCA);\n    ll cost_right = get_cost(right,LCA);\n \n    if(cost_left == cost_right){\n \n        return cost_left;\n    }\n \n    if(cost_left > cost_right){\n \n        return calc_ans(left,LCA,DIST);\n \n    }else{\n \n        return calc_ans(right,LCA,DIST);\n    }\n}\n \nint main(){\n \n    for(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n \n    int num_query;\n \n    scanf(\"%d %d\",&N,&num_query);\n \n    int from,to;\n    ll cost;\n \n    for(int i = 0; i < N-1; i++){\n \n        scanf(\"%d %d %lld\",&from,&to,&cost);\n        from--;\n        to--;\n        G[from].push_back(Edge(to,cost));\n        G[to].push_back(Edge(from,cost));\n    }\n \n    root = 0;\n    init();\n \n    int a,b,c;\n \n    for(int loop = 0; loop < num_query; loop++){\n \n        scanf(\"%d %d %d\",&a,&b,&c);\n        a--;\n        b--;\n        c--;\n \n        printf(\"%lld\\n\",calc(a,b,c));\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100000;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int c = u,s = x;\n        if(D(u,LCA) < x){\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) > g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    vector<int> ans(q);\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n        ans[i] = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n    }\n    rep(i,q) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100000;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\ninline int D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\ninline int WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int c = u,s = x;\n        if(D(u,LCA) < x){\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) >= g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n\n        G[u].pb(v);\n        G[v].pb(u);\n        wG[u].pb({v,w});\n        wG[v].pb({u,w});\n    }\n\n    root = n/2;\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL N, Q;\nUL P[100000][18];\nUL D[100000];\nUL C[100000];\nvector<pair<UL, UL>> E[100000];\n\nUL LCA(UL a, UL b) {\n\tif (C[a] < C[b]) swap(a, b);\n\tUL d = C[a] - C[b];\n\tfor (UL i = 17; i != ~0u; i--) {\n\t\tif ((1u << i) & d) a = P[a][i];\n\t}\n\tif (a == b) return a;\n\tfor (UL i = 17; i != ~0u; i--) {\n\t\tif (P[a][i] == P[b][i]) continue;\n\t\ta = P[a][i]; b = P[b][i];\n\t}\n\treturn P[a][0];\n}\n\npair<UL, UL> MP(UL a, UL b) {\n\tUL X = D[LCA(a, b)];\n\tif (D[a] < D[b]) swap(a, b);\n\tUL Y = D[a] - D[b] + X + X;\n\tfor (UL i = 17; i != ~0u; i--) {\n\t\tif (D[P[a][i]] * 2 <= Y) continue;\n\t\ta = P[a][i];\n\t}\n\tif (X == D[a]) return{ a,a };\n\telse return { a, P[a][0] };\n}\n\nUL Dist(UL a, UL b) {\n\tUL X = D[LCA(a, b)];\n\treturn D[a] + D[b] - X - X;\n}\n\nint main() {\n\tscanf(\"%u%u\", &N, &Q);\n\trep(i, N - 1) {\n\t\tUL u, v, w; scanf(\"%u%u%u\", &u, &v, &w); u--; v--;\n\t\tE[u].push_back({ v, w });\n\t\tE[v].push_back({ u, w });\n\t}\n\t{\n\t\tP[0][0] = 0; D[0] = 0; C[0] = 0;\n\t\tqueue<UL> G; G.push(0);\n\t\twhile (G.size()) {\n\t\t\tUL p = G.front(); G.pop();\n\t\t\tfor (auto& e : E[p]) {\n\t\t\t\tif (P[p][0] == e.first) continue;\n\t\t\t\tP[e.first][0] = p;\n\t\t\t\tD[e.first] = D[p] + e.second;\n\t\t\t\tC[e.first] = C[p] + 1;\n\t\t\t\tG.push(e.first);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 17) rep(j, N) P[j][i + 1] = P[P[j][i]][i];\n\n\trep(q, Q) {\n\t\tUL a, b, c; scanf(\"%u%u%u\", &a, &b, &c); a--; b--; c--;\n\t\tUL ans = ~0u;\n\t\trep(t, 3) {\n\t\t\tauto mp = MP(a, b);\n\t\t\tUL q1 = max(max(Dist(mp.first, a), Dist(mp.first, b)), Dist(mp.first, c));\n\t\t\tUL q2 = max(max(Dist(mp.second, a), Dist(mp.second, b)), Dist(mp.second, c));\n\t\t\tans = min(ans, min(q1, q2));\n\t\t\tswap(a, b); swap(b, c);\n\t\t}\n\t\tprintf(\"%u\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100010;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nint g(int x, int u, int v, int t){\n    int LCA = lca(u,v);\n    int dul = D(u,LCA);\n\n    int c,s;\n    if(x <= dul){\n        c = u;\n        s = x;\n    }\n    else{\n        c = v;\n        s = D(u,v) - x;\n    }\n\n    for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n    return max(max(WD(c,u), WD(c,v)), WD(c,t));\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1,u,v,t) > g(m2,u,v,t)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i,u,v,t));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min(min(f(a,b,c), f(b,c,a)), f(c,a,b));\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0391\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nstruct LCA{\n  const int lg = 12;\n  const int sz = 1<<lg;\n  const int ms = sz-1;\n  int n;\n  vector<int> P,D,E,A,B,T,ht;\n  vector<vector<int> > G,dat;\n  LCA(int n):\n    n(n),P(n,-1),D(n),E(n*2,0),A(n*2,-1),B(n*2/lg+1),T(sz,0),G(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  void dfs(int v,int p,int d){\n    int k=0,u;\n    vector<int> iter(n,0);\n\n    using T = tuple<int, int, int>;\n    stack<T> st;\n\n  START:\n    D[v]=k;\n    A[k]=P[v]=p;\n    E[k++]=d;\n    for(;iter[v]<(int)G[v].size();iter[v]++){\n      u=G[v][iter[v]];\n      if(u==p) continue;\n      st.emplace(v,p,d);\n      p=v;v=u;d=d+1;\n      goto START;\n    END:\n      tie(v,p,d)=st.top();st.pop();\n    }\n\n    A[k]=P[v];\n    E[k++]=d-1;\n\n    if(!st.empty()) goto END;\n  }\n\n  // if it need leftmost, then add: if(E[i]==E[j]) return i<j?i:j;\n  inline int comp(int i,int j){return E[i]<E[j]?i:j;};\n  inline int comp(int i,int j,int k){return comp(comp(i,j),k);};\n\n  void build(int r=0){\n    dfs(r,-1,1);\n\n    B[0]=1;\n    for(int i=1;i<n*2;i++) B[i/lg]|=(E[i-1]<E[i])<<(i%lg);\n\n    for(int b=0;b<sz;b++){\n      int e=0,w=1,&x=T[b];\n      for(int i=0;i<lg;i++){\n        if((b>>i)&1) e++;\n        else e--;\n        if(e<w) e=w,x=i;\n      }\n    }\n\n    int m=(n*2+lg-1)/lg;\n    int h=1;\n    while((1<<h)<m) h++;\n    dat.assign(h,vector<int>(m,-1));\n    ht.assign(m+1,0);\n    for(int j=2;j<=m;j++) ht[j]=ht[j>>1]+1;\n\n    for(int j=0;j<n*2;j++){\n      if(dat[0][j/lg]<0) dat[0][j/lg]=j;\n      dat[0][j/lg]=comp(dat[0][j/lg],j);\n    }\n\n    for(int i=1,p=1;i<h;i++,p<<=1)\n      for(int j=0;j<m;j++)\n        dat[i][j]=comp(dat[i-1][j],dat[i-1][min(j+p,m-1)]);\n  }\n\n  inline int cs(int a,int b){\n    int l=b-a;\n    return comp(dat[ht[l]][a],dat[ht[l]][b-(1<<ht[l])]);\n  }\n\n  inline int es(int i,int l,int r){\n    int x=r-i*lg+1,y=l-i*lg;\n    int b=(((B[i]|(ms<<x))>>y)|(ms<<(lg-y)))&ms;\n    return l+T[b];\n  }\n\n  inline int ls(int i,int l){\n    int k=l-i*lg;\n    int b=((B[i]>>k)|(ms<<(lg-k)))&ms;\n    return l+T[b];\n  }\n\n  inline int rs(int j,int r){\n    int k=r-j*lg+1;\n    int b=(B[j]|(ms<<k))&ms;\n    return j*lg+T[b];\n  }\n\n  inline int rmq(int l,int r){\n    int i=l/lg,j=r/lg;\n    if(i==j) return es(i,l,r);\n    if(i+1==j) return comp(ls(i,l),rs(j,r));\n    return comp(ls(i,l),cs(i+1,j),rs(j,r));\n  }\n\n  int lca(int l,int r){\n    if(l==r) return l;\n    if(D[l]>D[r]) swap(l,r);\n    int x=D[l],y=D[r];\n    int m=rmq(x,y);\n    return m==x?l:A[m];\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct LevelAncestor{\n  int n,h;\n  vector<vector<int> > G,par,lad;\n  vector<int> dep,nxt,len,pth,ord,hs;\n  LevelAncestor(){}\n  LevelAncestor(int n):\n    n(n),G(n),dep(n),nxt(n,-1),len(n),pth(n),ord(n),hs(n+1,0){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n    for(int i=2;i<=n;i++) hs[i]=hs[i>>1]+1;\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  void dfs(int v,int p,int d,int f){\n    if(nxt[v]<0){\n      par[0][nxt[v]=v]=p;\n      len[v]=dep[v]=d;\n      for(int u:G[v]){\n        if(u==p) continue;\n        dfs(u,v,d+1,0);\n        if(len[v]<len[u]) nxt[v]=u,len[v]=len[u];\n      }\n    }\n    if(!f) return;\n    pth[v]=lad.size();\n    lad.emplace_back();\n    for(int k=v;;k=nxt[k]){\n      lad.back().emplace_back(k);\n      pth[k]=pth[v];\n      if(k==nxt[k]) break;\n    }\n    for(;;p=v,v=nxt[v]){\n      for(int u:G[v])\n        if(u!=p&&u!=nxt[v]) dfs(u,v,d+1,1);\n      if(v==nxt[v]) break;\n    }\n  }\n\n  void build(int r=0){\n    dfs(r,-1,0,1);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n        if(par[k][v]<0) par[k+1][v]=-1;\n        else par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n    for(int i=0;i<(int)lad.size();i++){\n      int v=lad[i][0],p=par[0][v];\n      if(~p){\n        int k=pth[p],l=min(ord[p]+1,(int)lad[i].size());\n        lad[i].resize(l+lad[i].size());\n        for(int j=0,m=lad[i].size();j+l<m;j++)\n          lad[i][m-(j+1)]=lad[i][m-(j+l+1)];\n        for(int j=0;j<l;j++)\n          lad[i][j]=lad[k][ord[p]-l+j+1];\n      }\n      for(int j=0;j<(int)lad[i].size();j++)\n        if(pth[lad[i][j]]==i) ord[lad[i][j]]=j;\n    }\n  }\n\n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++){\n      if((dep[v]-dep[u])>>k&1){\n        v=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=h-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n        u=par[k][u];\n        v=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int up(int v,int d){\n    if(d==0) return v;\n    v=par[hs[d]][v];\n    d-=1LL<<hs[d];\n    return lad[pth[v]][ord[v]-d];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nchar buf[256];\nsigned solve(){\n  using ll = long long;\n  int n;\n  scanf(\"%d\",&n);\n  using P = pair<int, int>;\n  vector<vector<P> > G(n);\n  LevelAncestor la(n);\n  for(int i=1;i<n;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;b--;\n    la.add_edge(a,b);\n    G[a].emplace_back(b,c);\n    G[b].emplace_back(a,c);\n  }\n  la.build();\n\n  vector<ll> dep(n,0);\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      for(auto e:G[v]){\n        int u,c;\n        tie(u,c)=e;\n        if(u==p) continue;\n        dep[u]=dep[v]+c;\n        q.emplace(u,v);\n      }\n    }\n  }\n\n  while(scanf(\"%s\",buf)){\n    string s(buf);\n    if(s==\"DONE\"s) break;\n    if(s==\"DIST\"s){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      a--;b--;\n      printf(\"%lld\\n\",dep[a]+dep[b]-2*dep[la.lca(a,b)]);\n    }\n    if(s==\"KTH\"s){\n      int a,b,k;\n      scanf(\"%d %d %d\",&a,&b,&k);\n      a--;b--;k--;\n      int l=la.lca(a,b);\n      int x=la.distance(a,l),y=la.distance(l,b);\n      assert(0<=k&&k<=x+y);\n      printf(\"%d\\n\",(k<=x?la.up(a,k):la.up(b,x+y-k))+1);\n    }\n  }\n  return 0;\n}\n\nsigned SPOJ_QTREE2(){\n  int t;\n  scanf(\"%d\",&t);\n  for(int i=0;i<t;i++) solve();\n  return 0;\n}\n/*\n  verified on 2019/10/25\n  https://www.spoj.com/problems/QTREE2/\n*/\n\nsigned main(){\n  SPOJ_QTREE2();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  using P = pair<int, int>;\n  vector<vector<P> > G(n);\n  LCA lca(n);\n  LevelAncestor la(n);\n  for(int i=1;i<n;i++){\n    int u,v,w;\n    scanf(\"%d %d %d\",&u,&v,&w);\n    u--;v--;\n    lca.add_edge(u,v);\n    la.add_edge(u,v);\n    G[u].emplace_back(v,w);\n    G[v].emplace_back(u,w);\n  }\n\n  lca.build();\n  la.build();\n\n  vector<int> dep(n,0);\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      for(auto e:G[v]){\n        int u,c;\n        tie(u,c)=e;\n        if(u==p) continue;\n        dep[u]=dep[v]+c;\n        q.emplace(u,v);\n      }\n    }\n  }\n\n  auto dist=[&](int u,int v){return dep[u]+dep[v]-2*dep[lca.lca(u,v)];};\n  auto path=\n    [&](int u,int v,int d){\n      if(d==0) return u;\n      int r=lca.lca(u,v);\n      int x=la.distance(u,r),y=la.distance(r,v);\n      if(d<=x) return la.up(u,d);\n      return la.up(v,(x+y)-d);\n    };\n\n  for(int i=0;i<q;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;b--;c--;\n    auto calc=\n      [&](int v,int u=-1){\n        return max({dist(a,v)*(a!=u),\n                    dist(b,v)*(b!=u),\n                    dist(c,v)*(c!=u)});\n      };\n\n    int p=lca.lca(a,b),q=lca.lca(b,c),r=lca.lca(c,a);\n    int v=la.dep[p]>la.dep[q]?p:(la.dep[q]>la.dep[r]?q:r);\n\n    int ans=min({calc(a),calc(b),calc(c),calc(v)});\n    for(int u:{a,b,c}){\n      if(calc(v,u)>=ans) continue;\n      int l=0,r=la.distance(u,v);\n      while(l+1<r){\n        int m=(l+r)>>1;\n        int x=path(u,v,m);\n        if(calc(x,u)<dist(x,u)) r=m;\n        else l=m;\n      }\n      chmin(ans,calc(path(u,v,l)));\n      chmin(ans,calc(path(u,v,r)));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define N 100010\n#define D 18\nll n,q,p[N],len[N],rui[N],dep[N];\nnamespace lca{\n  ll t[N][D];\n  void init(){\n      for(int i=1;i<=n;i++)t[i][0]=p[i];\n      for(int d=1;d<D;d++){\n\t  for(int i=1;i<=n;i++){\n\t      t[i][d]=t[t[i][d-1]][d-1];\n\t  }\n      }\n  }\n  ll ad(ll a,ll k){\n      for(ll d=0;k!=0;d++){\n\t  if(k&1)a=t[a][d];\n\t  k>>=1;\n      }\n      return a;\n  }\n  ll qry(ll a,ll b){\n      if(dep[a]<dep[b])swap(a,b);\n      a=ad(a,dep[a]-dep[b]);\n      if(a==b)return a;\n      for(ll d=D-1;d>=0;d--){\n\t  if(t[a][d]!=t[b][d]){\n\t      a=t[a][d],b=t[b][d];\n\t  }\n      }\n      return p[a];\n  }\n  ll dist(ll a,ll b){\n      ll c=qry(a,b);\n      return rui[a]+rui[b]-2*rui[c];\n  }\n};\n\n\nstruct edge{\n  ll to,cost;  \n};\nedge edges(ll to,ll cost){\n    edge gen;gen.to=to,gen.cost=cost;\n    return gen;\n}\nvector<edge> g[N];\nvoid dfs(ll x,ll from,ll sum,ll d){\n    rui[x]=sum; dep[x]=d;\n    for(auto y:g[x])if(y.to!=from){\n\tp[y.to]=x,len[y.to]=y.cost;\n\tdfs(y.to,x,sum+y.cost,d+1);\n    }\n}\n\nll ldi(ll mid,ll a,ll b,ll c,ll lk,ll rk,ll m){//cout<<\"ldi\"<<mid<<endl;\n    ll ldis;\n    if(mid<=lk)ldis=lca::dist(a,lca::ad(a,mid));\n    else ldis=lca::dist(a,c)+lca::dist(c,lca::ad(b,m-mid));\n    return ldis;\n}\nll rdi(ll mid,ll a,ll b,ll c,ll lk,ll rk,ll m){//cout<<\"rdi\"<<mid<<endl;\n    ll rdis;\n    if(mid>=lk)rdis=lca::dist(b,lca::ad(b,m-mid));\n    else rdis=lca::dist(b,c)+lca::dist(c,lca::ad(a,mid));\n    return rdis;\n}\nint main(){\n    cin>>n>>q;\n    for(int i=0;i<n-1;i++){\n\tll a,b,c;cin>>a>>b>>c;\n\tg[a].push_back(edges(b,c));\n\tg[b].push_back(edges(a,c));\n    }\n    dfs(1,0,0,0); p[1]=1;\n    lca::init();\n    while(q--){\n\tll a,b,c;cin>>a>>b>>c;\n\tll ab=lca::dist(a,b);\n\tll ac=lca::dist(a,c);\n\tll bc=lca::dist(b,c);\n\tif(ab>=ac&&ab>=bc){}\n\telse if(ac>=ab&&ac>=bc){swap(b,c);}\n\telse if(bc>=ab&&bc>=ac){swap(a,c);}\n\tc=lca::qry(a,b);//cout<<\"$$$$$\"<<a<<\" \"<<b<<\" \"<<c<<endl;\n\tll lk=dep[a]-dep[c],rk=dep[b]-dep[c],m=lk+rk;\n\tll l=0,r=m,mid;\n\twhile(l<r-1){\n\t    mid=(l+r)/2;\n\t    ll ldis=ldi(mid,a,b,c,lk,rk,m);\n\t    ll rdis=rdi(mid,a,b,c,lk,rk,m);\n\t    if(ldis<rdis)l=mid;\n\t    else r=mid;\n\t}\n\tll ldis,rdis;\n\tldis=ldi(l,a,b,c,lk,rk,m);\n\trdis=rdi(l,a,b,c,lk,rk,m);\n\tll vl=max(ldis,rdis);\n\tldis=ldi(r,a,b,c,lk,rk,m);\n\trdis=rdi(r,a,b,c,lk,rk,m);\n\tll vr=max(ldis,rdis);\n\tcout<<min(vl,vr)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++ )\nstatic const int N_MAX = 100000;\nstatic const int MAX_LOG_V = 17;\nstatic const int INF = 2000000000;\n\ntypedef long long ll;\n\nint N;\nvector<pair<int, int> > G[N_MAX];\nint root;\n\nint parent[MAX_LOG_V][N_MAX];\nint depth[N_MAX], W[N_MAX];\n\nvoid dfs(int v, int p, int d, int w){\n  parent[0][v] = p;\n  depth[v] = d;\n  W[v] = w;\n  for ( int i = 0; i < G[v].size(); i++ ){\n    if ( G[v][i].first != p ) dfs(G[v][i].first, v, d + 1, w + G[v][i].second);\n  }\n}\n\nvoid init(int V){\n  root = 0;\n  W[root] = 0;\n  dfs(root, -1, 0, 0);\n  for ( int k = 0; k + 1 < MAX_LOG_V; k++ ){\n    for ( int v = 0; v < V; v++ ){\n      if ( parent[k][v] < 0 ) parent[k + 1][v] = -1;\n      else parent[k + 1][v] = parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u, int v){\n  if (depth[u] > depth[v]) swap(u, v);\n  for ( int k = 0; k < MAX_LOG_V; k++ ){\n    if ((depth[v] - depth[u]) >> k & 1 ){\n      v = parent[k][v];\n    }\n  }\n  if ( u == v ) return u;\n  for ( int k = MAX_LOG_V - 1; k >=0 ; k-- ){\n    if (parent[k][u] != parent[k][v] ){\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint getDist(int s, int t){\n  int l = lca(s, t);\n  return W[s] + W[t] - W[l]*2;\n}\n\nint getNode(int B, int H){\n  int v = B;\n  for ( int k = 0; k < MAX_LOG_V; k++ ){\n    if (H >> k & 1) v = parent[k][v];\n  }\n  return v;\n}\nint bsearch(int s, int t, int D ){\n  int B = s;\n  int H = t;\n  int M, left, right;\n  int ans = INF;\n  for ( int i = 0; i < 20; i++ ){\n    M = getNode(s, depth[s] - depth[B] + (depth[B] - depth[H])/2);\n    left = W[s] - W[M];\n    right = D - left;\n    ans = min(ans, max(left, right));\n    if ( left == right ) return ans;\n    else if ( left < right ) B = parent[0][M];\n    else if ( left > right) H = M;\n  }\n  return ans;\n}\n\nint search(int s, int t, int D){\n  int p = s, w = 0, ans = INF;\n  while(1){\n    ans = min(ans, max(w, D-w));\n    if ( p == t ) break;\n    p = parent[0][p];\n    w = W[s] - W[p];\n  }\n  return ans;\n}\n\nint solve(int a, int b, int c){\n  int S = a;\n  int T = b;\n  int d, D= getDist(a, b);\n  d = getDist(a, c);\n  if ( D < d ){\n    S = a;\n    T = c;\n    D = d;\n  }\n  d = getDist(b, c);\n  if ( D < d ){\n    S = b;\n    T = c;\n    D = d;\n  }\n\n  int L = lca(S, T);\n  int SL = getDist(S, L);\n  int LT = getDist(L, T);\n  if ( SL == LT ) return SL;\n  if ( SL > LT ){\n    return bsearch(S, L, D);\n  } else if ( SL < LT ){\n    return bsearch(T, L, D);\n  }\n}\n\nint main(){\n  int Q, u, v, w, a, b, c;\n  cin >> N >> Q;\n  for ( int i = 0; i < N-1; i++ ) {\n    cin >> u >> v >> w;\n    u--; v--;\n    G[u].push_back(make_pair(v, w));\n    G[v].push_back(make_pair(u, w));\n  }\n\n  init(N);\n\n  for ( int i = 0; i < Q; i++ ) {\n    cin >> a >> b >> c; a--; b--; c--;\n    cout << solve(a, b, c) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root), cnum(V), place(V), id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// uとvをつなぐ\n\t// lcaを求めることが主目的なので無向グラフとしている\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\tvoid unite(vector<vector<int>>&e) {\n\t\tT = e;\n\t}\n\t// initする\n\t// コンストラクタだけじゃなくてこれも呼ばないとlcaが求められないぞ\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// uとvのlcaを求める\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// uとvの距離を求める\n\t// edgeを定義しないといけない時はこれじゃダメ\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v] += dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v] + 1;\n\t}\n\n\tvoid dfs2(int v, int p, vector<vector<int>>&doubles, const vector<int>&nums) {\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) dfs2(next, v, doubles, nums);\n\t\t}\n\t\tdoubles[0][v] = nums[v];\n\t\tfor (int j = 1; j < MAXLOGV; ++j) {\n\t\t\tdoubles[j][v] = min(doubles[j][v], doubles[j - 1][v]);\n\t\t}\n\t\tfor (int j = 0; j < MAXLOGV - 1; ++j) {\n\t\t\tdoubles[j + 1][parent[j][v]] = min(doubles[j + 1][parent[j][v]], doubles[j][v]);\n\t\t}\n\t}\n\t//ここでは親から距離2^iの部分木の最小値を求めている\n\tvector<vector<int>>get_doubles(const vector<int>&nums) {\n\t\tvector<vector<int>>doubles(MAXLOGV, vector<int>(V, 1e9));\n\t\tdfs2(root, -1, doubles, nums);\n\t\treturn doubles;\n\t}\n\n\tvoid getid(const int v, const int p, int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// グラフの隣接リスト表現\n\tvector<vector<int> > T;\n\t// 頂点の数\n\tint V;\n\t// 根ノードの番号\n\tint root;\n\n\t// 親ノード\n\tvector<int> parent[MAXLOGV];\n\t// 根からの深さ\n\tvector<int> depth;\n\n\t//子の数\n\tvector<int>cnum;\n\n\t//変換\n\tvector<int>place;\n\tvector<int>id;\n\n};\nvoid dd(const int now, const int from, const long long int now_len,\n\tconst vector<vector<pair<int, long long int>>>&edges,\n\tvector<long long int>&lens) {\n\tlens[now]=now_len;\n\tfor (auto e : edges[now]) {\n\t\tif (e.first != from) {\n\t\t\tdd(e.first,now,now_len+e.second,edges,lens);\n\t\t}\n\t}\n}\n\npair<int,int>solve(const vector<long long int>&lens,Tree&t, int x, int y) {\n\tint r=t.lca(x,y);\n\tlong long int rx_len=lens[x]-lens[r];\n\tlong long int ry_len=lens[y]-lens[r];\n\n\tif (rx_len < ry_len) {\n\t\tswap(x,y);\n\t\tswap(rx_len,ry_len);\n\t}\n\tassert(rx_len>=ry_len);\n\tlong long int half=(rx_len+ry_len)/2;\n\tint now=x;\n\tlong long int sum=0;\n\tfor (int i = 24; i >=0;--i) {\n\t\tint next=t.parent[i][now];\n\t\tlong long int plus=lens[now]-lens[next];\n\t\tif ((sum+plus) * 2 <= rx_len + ry_len) {\n\t\t\tnow=next;\n\t\t\tsum+=plus;\n\t\t}\n\t}\n\treturn make_pair(now,t.parent[0][now]);\n}\nint main() {\n\tint N,Q;cin>>N>>Q;\n\tTree t(N,0);\n\tvector<long long int>lens(N);\n\tvector<vector<pair<int,long long int>>>edges(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u,v,w;cin>>u>>v>>w;\n\t\tu--;v--;\n\t\tt.unite(u,v);\n\t\tedges[u].push_back(make_pair(v,w));\n\t\tedges[v].push_back(make_pair(u,w));\n\t}\n\tt.init();\n\tdd(0,-1,0,edges,lens);\n\n\tfor (int q = 0; q < Q; ++q) {\n\t\tvector<int>cities(3);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin>>cities[i];\n\t\t\tcities[i]--;\n\t\t}\n\n\n\t\tvector<int>candidates;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a=i;\n\t\t\tint b=(i+1)%3;\n\t\t\ta=cities[a];\n\t\t\tb=cities[b];\n\t\t\tauto p=solve(lens,t,a,b);\n\t\t\tcandidates.push_back(p.first);\n\t\t\tcandidates.push_back(p.second);\n\t\t}\n\t\tlong long int answer=1e18;\n\t\tfor (auto cand : candidates) {\n\t\t\tlong long int nanswer=0;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tint alca=t.lca(cities[i],cand);\n\t\t\t\tlong long int need=lens[cand]+lens[cities[i]]-2*\n\t\t\t\t\tlens[alca];\n\t\t\t\tnanswer = max(nanswer, need);\n\n\t\t\t}\n\t\t\tanswer=min(answer,nanswer);\n\t\t}\n\t\tcout<<answer<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++ )\nstatic const int N_MAX = 100000;\nstatic const int MAX_LOG_V = 17;\nstatic const int INF = 2000000000;\n\ntypedef long long ll;\n\nint N;\nvector<pair<int, int> > G[N_MAX];\nint root;\n\nint parent[MAX_LOG_V][N_MAX];\nint depth[N_MAX], W[N_MAX];\n\nvoid dfs(int v, int p, int d, int w){\n  parent[0][v] = p;\n  depth[v] = d;\n  W[v] = w;\n  for ( int i = 0; i < G[v].size(); i++ ){\n    if ( G[v][i].first != p ) dfs(G[v][i].first, v, d + 1, w + G[v][i].second);\n  }\n}\n\nvoid init(int V){\n  root = 0;\n  W[root] = 0;\n  dfs(root, -1, 0, 0);\n  for ( int k = 0; k + 1 < MAX_LOG_V; k++ ){\n    for ( int v = 0; v < V; v++ ){\n      if ( parent[k][v] < 0 ) parent[k + 1][v] = -1;\n      else parent[k + 1][v] = parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u, int v){\n  if (depth[u] > depth[v]) swap(u, v);\n  for ( int k = 0; k < MAX_LOG_V; k++ ){\n    if ((depth[v] - depth[u]) >> k & 1 ){\n      v = parent[k][v];\n    }\n  }\n  if ( u == v ) return u;\n  for ( int k = MAX_LOG_V - 1; k >=0 ; k-- ){\n    if (parent[k][u] != parent[k][v] ){\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint getDist(int s, int t){\n  int l = lca(s, t);\n  return W[s] + W[t] - W[l]*2;\n}\n\nint getNode(int B, int H){ // start from B and height (node num) = H\n  int v = B;\n  for ( int k = 0; k < MAX_LOG_V; k++ ){\n    if (H >> k & 1) v = parent[k][v];\n  }\n  return v;\n}\nint bsearch(int s, int t, int D ){\n  //  cout << \"bsearch \" << s << \"-->\" << t << \"  D = \" << D << endl;\n  int B = s;\n  int H = t;\n  int M, left, right;\n  int ans = INF;\n  for ( int i = 0; i < 20; i++ ){\n    M = getNode(s, depth[s] - depth[B] + (depth[B] - depth[H])/2);\n    left = W[s] - W[M];\n    right = D - left;\n    //    cout << \"B=\" << B << \" H=\" << H << endl;\n    //        cout << \"M=\" << M+1 << endl;\n    //        cout << left << \"/\" << right << endl;\n    ans = min(ans, max(left, right));\n    if ( left == right ) return ans;\n    else if ( left < right ) B = parent[0][M];\n    else if ( left > right) H = M;\n  }\n  return ans;\n}\n\nint search(int s, int t, int D){\n  int p = s, w = 0, ans = INF;\n  while(1){\n    ans = min(ans, max(w, D-w));\n    if ( p == t ) break;\n    p = parent[0][p];\n    w = W[s] - W[p];\n  }\n  return ans;\n}\n\nint solve(int a, int b, int c){\n  int S = a;\n  int T = b;\n  int d, D= getDist(a, b);\n  d = getDist(a, c);\n  if ( D < d ){\n    S = a;\n    T = c;\n    D = d;\n  }\n  d = getDist(b, c);\n  if ( D < d ){\n    S = b;\n    T = c;\n    D = d;\n  }\n\n  // ans is between S and T\n  int L = lca(S, T);\n  int SL = getDist(S, L);\n  int LT = getDist(L, T);\n  if ( SL == LT ) return SL;\n  if ( SL > LT ){\n    return bsearch(S, L, D);\n  } else if ( SL < LT ){\n    return bsearch(T, L, D);\n  }\n}\n\nint main(){\n  int Q, u, v, w, a, b, c;\n  cin >> N >> Q;\n  for ( int i = 0; i < N-1; i++ ) {\n    cin >> u >> v >> w;\n    u--; v--;\n    G[u].push_back(make_pair(v, w));\n    G[v].push_back(make_pair(u, w));\n  }\n\n  init(N);\n\n  for ( int i = 0; i < Q; i++ ) {\n    cin >> a >> b >> c; a--; b--; c--;\n    cout << solve(a, b, c) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct LCA{\n  int n;\n  vector<int> P,D,E,A,T,ht;\n  vector<vector<int> > G,dat;\n  LCA(int n):\n    n(n),P(n,-1),D(n),E(n*2,0),A(n*2,-1),G(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  void dfs(int v,int p,int d,int &k){\n    D[v]=k;\n    A[k]=P[v]=p;\n    E[k++]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1,k);\n    A[k]=P[v];\n    E[k++]=d-1;\n  }\n\n  // if it need leftmost, then add: if(E[i]==E[j]) return i<j?i:j;\n  inline int comp(int i,int j){return E[i]<E[j]?i:j;};\n  \n  void build(int r=0){\n    int k=0;\n    dfs(r,-1,1,k);\n\n    int h=1,m=n*2;\n    while((1<<h)<m) h++;\n    dat.assign(h,vector<int>(m,-1));\n    ht.assign(m+1,0);\n    for(int j=2;j<=m;j++) ht[j]=ht[j>>1]+1;\n    \n    for(int j=0;j<m;j++) dat[0][j]=j;\n    \n    for(int i=1,p=1;i<h;i++,p<<=1)\n      for(int j=0;j<m;j++)\n        dat[i][j]=comp(dat[i-1][j],dat[i-1][min(j+p,m-1)]);\n  }\n\n  inline int rmq(int a,int b){\n    int l=b-a;\n    return comp(dat[ht[l]][a],dat[ht[l]][b-(1<<ht[l])]);\n  }\n  \n  inline int lca(int l,int r){\n    if(l==r) return l;\n    if(D[l]>D[r]) swap(l,r);\n    int x=D[l],y=D[r];\n    int m=rmq(x,y);\n    return m==x?l:A[m];\n  }\n};\n\nstruct LevelAncestor{\n  LCA &tree;\n  int n,h;\n  vector<vector<int> > G,par,lad;\n  vector<int> dep,nxt,len,pth,ord,hs;\n  LevelAncestor(LCA &lca,int n):\n    tree(lca),n(n),G(n),dep(n),nxt(n,-1),len(n),pth(n),ord(n),hs(n+1,0){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n    \n    for(int i=2;i<=n;i++) hs[i]=hs[i>>1]+1;\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  void dfs(int v,int p,int d,int f){\n    if(nxt[v]<0){\n      par[0][nxt[v]=v]=p;\n      len[v]=dep[v]=d;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tdfs(u,v,d+1,0);\n\tif(len[v]<len[u]) nxt[v]=u,len[v]=len[u];\n      }\n    }\n    if(!f) return;\n    pth[v]=lad.size();\n    lad.emplace_back();\n    for(int k=v;;k=nxt[k]){\n      lad.back().emplace_back(k);\n      pth[k]=pth[v];\n      if(k==nxt[k]) break;\n    }\n    for(;;p=v,v=nxt[v]){\t\n      for(int u:G[v])\n\tif(u!=p&&u!=nxt[v]) dfs(u,v,d+1,1);\t\n      if(v==nxt[v]) break;\n    }\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0,1);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n\tif(par[k][v]<0) par[k+1][v]=-1;\n\telse par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n    for(int i=0;i<(int)lad.size();i++){\n      int v=lad[i][0],p=par[0][v];\n      if(~p){\n\tint k=pth[p],l=min(ord[p]+1,(int)lad[i].size());\n\tlad[i].resize(l+lad[i].size());\n\tfor(int j=0,m=lad[i].size();j+l<m;j++)\n\t  lad[i][m-(j+1)]=lad[i][m-(j+l+1)];\n\tfor(int j=0;j<l;j++)\n\t  lad[i][j]=lad[k][ord[p]-l+j+1];\n      }\n      for(int j=0;j<(int)lad[i].size();j++)\n\tif(pth[lad[i][j]]==i) ord[lad[i][j]]=j;\n    }\n  }\n  \n  inline int lca(int u,int v){\n    return tree.lca(u,v);\n  }\n\n  inline int up(int v,int d){\n    if(d==0) return v;\n    v=par[hs[d]][v];\n    d-=1LL<<hs[d];\n    return lad[pth[v]][ord[v]-d];\n  }\n  \n  inline int distance(int u,int v){\n    return dep[u]+dep[v]-dep[tree.lca(u,v)]*2;\n  }\n  \n  inline int path(int u,int v,int d){\n    if(d==0) return u;\n    int r=tree.lca(u,v);\n    int x=distance(u,r),y=distance(r,v);\n    if(d<=x) return up(u,d);\n    return up(v,(x+y)-d);\n  }\n  \n};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  using P = pair<int, int>;\n  vector<vector<P> > G(n);\n  LCA lca(n);\n  LevelAncestor la(lca,n);\n  for(int i=1;i<n;i++){\n    int u,v,w;\n    scanf(\"%d %d %d\",&u,&v,&w);\n    u--;v--;\n    lca.add_edge(u,v);\n    la.add_edge(u,v);\n    G[u].emplace_back(v,w);\n    G[v].emplace_back(u,w);\n  }\n\n  lca.build();\n  la.build();\n\n  vector<int> dep(n,0);\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      for(auto e:G[v]){\n\tint u,c;\n\ttie(u,c)=e;\n\tif(u==p) continue;\n\tdep[u]=dep[v]+c;\n\tq.emplace(u,v);\n      }\n    }\n  }\n  \n  auto dist=[&](int u,int v){return dep[u]+dep[v]-2*dep[lca.lca(u,v)];};\n  for(int i=0;i<q;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;b--;c--;\n    auto calc=[&](int v,int u=-1){\n\t\treturn max({dist(a,v)*(a!=u),\n\t\t\t    dist(b,v)*(b!=u),\n\t\t\t    dist(c,v)*(c!=u)});\n\t      };\n    \n    int p=lca.lca(a,b),q=lca.lca(b,c),r=lca.lca(c,a);\n    int v=la.dep[p]>la.dep[q]?p:(la.dep[q]>la.dep[r]?q:r);\n    \n    int ans=min({calc(a),calc(b),calc(c),calc(v)});\n    for(int u:{a,b,c}){\n      if(calc(v,u)>=ans) continue;\n      int l=0,r=la.distance(u,v);\n      while(l+1<r){\n\tint m=(l+r)>>1;\n\tint x=la.path(u,v,m);\n\tif(calc(x,u)<dist(x,u)) r=m;\n\telse l=m;\n      }\n      chmin(ans,calc(la.path(u,v,l)));\n      chmin(ans,calc(la.path(u,v,r)));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct edge{ int to,cost; };\nint N,Q;\n\nvector<edge> G[100005];\n\nint parent[100005];\nint depth[100005];\nint dist[100005];\n\nint p[30][100005];\nvoid dfs(int pos,int prev,int Depth,int Dist){\n  parent[pos]=prev;\n  depth[pos]=Depth;\n  dist[pos]=Dist;\n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if(e.to==prev)continue;\n    dfs(e.to,pos,Depth+1,Dist+e.cost);\n  }\n}\n\nint lca(int a,int b){\n  if(depth[a]>depth[b])swap(a,b);\n  \n  int s=(depth[b]-depth[a]);\n  for(int i=0;i<30;i++)\n    if(s>>i&1)\n      b=p[i][b];\n  \n  if(a==b)return a;\n  \n  for(int i=29;i>=0;i--){\n    if( p[i][a] != p[i][b] ){\n      a=p[i][a];\n      b=p[i][b];\n    }\n  }\n  return parent[a];\n}\n\nint calc_dist(int a,int b){\n  int c=lca(a,b);\n  return dist[a]-dist[c]+dist[b]-dist[c];\n}\n\nint check(int p,int a,int b,int c){\n  int res=0;\n  res=max(res, calc_dist(p,a));\n  res=max(res, calc_dist(p,b));\n  res=max(res, calc_dist(p,c));\n  return res;\n}\n\nint solve(int a,int b,int c){\n  int x=lca(b,c);\n  if( calc_dist(x,b) > calc_dist(x,c) )swap(b,c);\n  \n  int y=calc_dist(b,c)/2;\n  int z=c;\n  for(int i=29;i>=0;i--){\n    int nz=p[i][z];\n    if(nz!=-1 && (dist[c]-dist[nz]) <= y){\n      z=nz;\n    }\n  }\n  \n  int res=check(z,a,b,c);\n  if( parent[z]!=-1 )\n    res=min(res,check(parent[z],a,b,c));\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  for(int i=0;i<N-1;i++){\n    int u,v,w;\n    scanf(\"%d %d %d\",&u,&v,&w);\n    u--;\n    v--;\n    G[u].push_back( (edge){v,w} );\n    G[v].push_back( (edge){u,w} );\n    \n  }\n  \n  dfs(0,-1,0,0);\n\n  for(int i=0;i<N;i++)\n    p[0][i]=parent[i];\n\n  for(int i=1;i<30;i++){\n    for(int j=0;j<N;j++){\n      int x=p[i-1][j];\n      if(x!=-1)x=p[i-1][x];\n      p[i][j]=x;\n    }\n  }\n\n  for(int i=0;i<Q;i++){\n    int a,b,c;\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    c--;\n    int ans=(1<<30);\n    ans=min(ans, solve(a,b,c) );\n    ans=min(ans, solve(b,a,c) );\n    ans=min(ans, solve(c,a,b) );\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to;\n\tll cost;\n};\n\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint N; //ノードの個数\nint root; //根ノードの番号\nint MAX_LOG_V = 17;\nint POW[18];\nint parent[20][NUM];\nint depth[NUM];\nll COST[NUM];\n\n//parentとdepthを再帰的に設定\nvoid dfs(int node_id,int parent_id,int d,ll sum_cost){\n\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tCOST[node_id] = sum_cost;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to != parent_id){\n\t\t\tdfs(G[node_id][i].to,node_id,d+1,sum_cost+G[node_id][i].cost);\n\t\t}\n\t}\n}\n\n//初期化\nvoid init(){\n\t//parent[0]とdepthを初期化する\n\tdfs(root,-1,0,0);\n\t//parentを初期化する\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1; //node_idの2^k上のノードがルートノードより上なら、2^(k+1)上も同様とする\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n//leftとrightのLCAを求める\nint lca(int left,int right){\n\t//leftとrightの深さが同じになるまで親を辿る\n\tif(depth[left] > depth[right])swap(left,right); //rightの方が深い所にいる\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(depth[right]-depth[left] >= POW[k]){ //たとえば深さの差が39なら、32+4+2+1のように、ノードを上方に移動させる\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\n\tif(left == right)return left;\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] == parent[k][right]){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left]; //最後は、leftの親とrightの親が必ず一致している\n}\n\nll get_cost(int left,int right){\n\n\tint LCA = lca(left,right);\n\n\treturn COST[left]+COST[right]-2*COST[LCA];\n}\n\nint get_node(int base_node,int diff){\n\n\tint ret = base_node;\n\n\tfor(int loop = MAX_LOG_V-1; loop >= 0; loop--){\n\t\tif(diff & (1 << loop)){\n\t\t\tret = parent[loop][ret];\n\t\t}\n\t}\n\treturn ret;\n}\n\nll calc_ans(int deeper,int LCA,ll DIST){\n\n\tint L = LCA,R = deeper,mid;\n\n\tll ret = HUGE_NUM;\n\n\tll cost_to_mid,REST;\n\n\tfor(int loop = 0; loop < 20; loop++){\n\n\t\tmid = get_node(R,(depth[R]-depth[L])/2);\n\n\t\tcost_to_mid = COST[deeper]-COST[mid];\n\t\tREST = DIST-cost_to_mid;\n\n\t\tret = min(ret,max(cost_to_mid,REST));\n\n\t\tif(cost_to_mid == REST){\n\n\t\t\treturn ret;\n\n\t\t}else if(cost_to_mid < REST){\n\n\t\t\tR = parent[0][mid];\n\n\t\t}else{\n\n\t\t\tL = mid;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nll calc(int a,int b,int c){\n\n\tll dist[3];\n\n\tdist[0] = get_cost(a,b);\n\tdist[1] = get_cost(a,c);\n\tdist[2] = get_cost(b,c);\n\n\tll maximum = -HUGE_NUM;\n\tint index;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(maximum < dist[i]){\n\t\t\tmaximum = dist[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\tint left,right;\n\tll DIST = maximum;\n\n\tswitch(index){\n\tcase 0:\n\t\tleft = a;\n\t\tright = b;\n\t\tbreak;\n\tcase 1:\n\t\tleft = a;\n\t\tright = c;\n\t\tbreak;\n\tcase 2:\n\t\tleft = b;\n\t\tright = c;\n\t\tbreak;\n\t}\n\n\tint LCA = lca(left,right);\n\n\tll cost_left = get_cost(left,LCA);\n\tll cost_right = get_cost(right,LCA);\n\n\tif(cost_left == cost_right){\n\n\t\treturn cost_left;\n\t}\n\n\tif(cost_left > cost_right){\n\n\t\treturn calc_ans(left,LCA,DIST);\n\n\t}else{\n\n\t\treturn calc_ans(right,LCA,DIST);\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n\n\tint num_query;\n\n\tscanf(\"%d %d\",&N,&num_query);\n\n\tint from,to;\n\tll cost;\n\n\tfor(int i = 0; i < N-1; i++){\n\n\t\tscanf(\"%d %d %lld\",&from,&to,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,cost));\n\t\tG[to].push_back(Edge(from,cost));\n\t}\n\n\troot = 0;\n\tinit();\n\n\tint a,b,c;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\n\t\tprintf(\"%lld\\n\",calc(a,b,c));\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100010;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\nint D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\nint WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nint g(int x, int u, int v, int t){\n    int LCA = lca(u,v);\n    int dul = D(u,LCA);\n\n    int c,s;\n    if(x <= dul){\n        c = u;\n        s = x;\n    }\n    else{\n        c = v;\n        s = D(u,v) - x;\n    }\n\n    for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n    return max({WD(c,u), WD(c,v), WD(c,t)});\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1,u,v,t) > g(m2,u,v,t)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i,u,v,t));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100000;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\ninline int D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\ninline int WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int c = u,s = x;\n        if(D(u,LCA) < x){\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) >= g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n\n        G[u].pb(v);\n        G[v].pb(u);\n        wG[u].pb({v,w});\n        wG[v].pb({u,w});\n    }\n\n    root = n/2;\n    lca_init(n);\n\n    d[root] = wd[root] = 0;\n    calc_dist(root,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n//ノードの個数\nconst int MAX_V = 100010;\n//ダブリングに必要なサイズ(log(MAX_V))\nconst int MAX_LOG_V = 17;\n//木の隣接リスト表現\nvector<int> G[MAX_V];\n//根のノード番号\nint root = 0;\n\n//親を2^k回辿って到達するノード(根を通り過ぎる場合,-1)\nint parent[MAX_LOG_V][MAX_V];\n//根からの深さ\nint depth[MAX_V];\n\n//現在vに注目、親はp、深さd\nvoid lca_dfs(int v, int p, int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){ //親でなければ子\n            lca_dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\n//初期化\nvoid lca_init(int V){\n    //parent[0]とdepthの初期化\n    lca_dfs(root, -1, 0);\n    //parentの初期化\n    for(int k=0; k+1<MAX_LOG_V; ++k){\n        for(int v=0; v<V; ++v){\n            if(parent[k][v] < 0) parent[k+1][v]=-1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<MAX_LOG_V; ++k){\n        if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=MAX_LOG_V-1; k>=0; --k){\n        if(parent[k][u] != parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nstruct edge{ int to,cost; };\nvector<edge> wG[MAX_V];\n\nvoid ADD(int u, int v, int w){\n    G[u].pb(v);\n    G[v].pb(u);\n    wG[u].pb({v,w});\n    wG[v].pb({u,w});\n}\n\n\nint d[MAX_V];\nint wd[MAX_V];\n\nvoid calc_dist(int x, int par){\n    for(const auto &e:wG[x])if(e.to != par){\n        d[e.to] = d[x] + 1;\n        wd[e.to] = wd[x] + e.cost;\n        calc_dist(e.to, x);\n    }\n}\n\ninline int D(int u, int v){\n    int l = lca(u,v);\n    return d[u]+d[v]-2*d[l];\n}\n\ninline int WD(int u, int v){\n    int l = lca(u,v);\n    return wd[u]+wd[v]-2*wd[l];\n}\n\nconst int INF = 1e9+1;\n// check u-v path\nint f(int u, int v, int t){\n    int LCA = lca(u,v);\n    if(LCA == u) swap(u,v);\n\n    auto g = [&](int x){\n        int dul = D(u,LCA);\n\n        int c,s;\n        if(x <= dul){\n            c = u;\n            s = x;\n        }\n        else{\n            c = v;\n            s = D(u,v) - x;\n        }\n\n        // printf(\" cs %d %d\\n\",c,s);\n        for(int i=MAX_LOG_V-1; i>=0; --i)if(s>>i&1) c = parent[i][c];\n\n        // dbg(c);\n        assert(c >= 0);\n        return max({WD(c,u), WD(c,v), WD(c,t)});\n    };\n\n    int l=0, r=D(u,v);\n    // printf(\" ---- %d %d %d \\n\",u,v,t);\n    // for(int i=l; i<=r; ++i) printf(\" g(%d) = %d\\n\",i,g(i));\n    while(r-l>2){\n        int m1 = (l+r)/2;\n        int m2 = m1+1;\n        if(g(m1) > g(m2)) l = m1;\n        else r = m2;\n    }\n\n    int ret = INF;\n    for(int i=l; i<=r; ++i) ret = min(ret, g(i));\n    return ret;\n}\n\nint main(){\n    int n,q;\n    scanf(\" %d %d\", &n, &q);\n    rep(i,n-1){\n        int u,v,w;\n        scanf(\" %d %d %d\", &u, &v, &w);\n        --u;\n        --v;\n        ADD(u,v,w);\n    }\n\n    lca_init(n);\n\n    d[0] = wd[0] = 0;\n    calc_dist(0,-1);\n\n    rep(i,q){\n        int a,b,c;\n        scanf(\" %d %d %d\", &a, &b, &c);\n        --a;\n        --b;\n        --c;\n\n        int ans = min({f(a,b,c), f(b,c,a), f(c,a,b)});\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\ndef main():\n  n, q = map(int, input().split())\n  edges = [[] for _ in range(n)]\n  for _ in range(n - 1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((v, w))\n    edges[v].append((u, w))\n  \n  height = [None] * n\n  dist = [None] * n\n  parent = [[None] * 20 for _ in range(n)]\n  stack = [(0, 0, 0)]\n  while stack:\n    x, h, d = stack.pop()\n    height[x] = h\n    dist[x] = d\n    for to, w in edges[x]:\n      if height[to] == None:\n        parent[to][0] = x\n        stack.append((to, h + 1, d + w))\n  for j in range(1, 20):\n    for i in range(1, n):\n      if height[i] >= 2 ** j:\n        parent[i][j] = parent[parent[i][j - 1]][j - 1]\n  \n  def adj_height(x, n):\n    if n == 0:\n      return x\n    acc = 1\n    for i in range(20):\n      if acc > n:\n        return adj_height(parent[x][i - 1], n - acc // 2)\n      acc *= 2\n  \n  def _lca(x, y):\n    if x == y:\n      return x\n    for i in range(1 ,20):\n      if parent[x][i] == parent[y][i]:\n        return _lca(parent[x][i - 1], parent[y][i - 1])\n  \n  def lca(x, y):\n    diff = height[x] - height[y]\n    if diff < 0:\n      y = adj_height(y, -diff)\n    elif diff > 0:\n      x = adj_height(x, diff)\n    return _lca(x, y)\n  \n  def bs(index, target):\n    if index == 0:\n      return 0\n    if dist[index] >= target >= dist[parent[index][0]]:\n      return index\n    for i in range(1, 20):\n      if parent[index][i] == None or dist[parent[index][i]] <= target:\n        return bs(parent[index][i - 1], target)\n  \n  def max_dist(x, y, z, r):\n    xr = lca(x, r)\n    yr = lca(y, r)\n    zr = lca(z, r)\n    return max(dist[x] + dist[r] - dist[xr] * 2, \n               dist[y] + dist[r] - dist[yr] * 2,\n               dist[z] + dist[r] - dist[zr] * 2)\n  \n  def _score(x, y, z, xy, yz):\n    dist_x = dist[x]\n    dist_y = dist[y]\n    dist_z = dist[z]\n    dist_xy = dist[xy]\n    dist_yz = dist[yz]\n    dx = dist_x + dist_yz - dist_xy * 2\n    dy = dist_y - dist_yz\n    dz = dist_z - dist_yz\n    if dx >= dy >= dz:\n      if dist_x >= dist_y:\n        r = bs(x, dist_xy + (dist_x - dist_y) / 2)\n        if r == 0:\n          return dist_x\n        return min(max(dist_x - dist[r], dist_y + dist[r] - dist_xy * 2), \n                   max(dist_x - dist[parent[r][0]], dist_y + dist[parent[r][0]] - dist_xy * 2))\n      else:\n        r = bs(yz, dist_xy + (dist_y - dist_x) / 2)\n        if r == 0:\n          return dist_y\n        return min(max(dist_y - dist[r], dist_x + dist[r] - dist_xy * 2), \n                   max(dist_y - dist[parent[r][0]], dist_x + dist[parent[r][0]] - dist_xy * 2))\n  \n    elif dx >= dz >= dy:\n      if dist_x >= dist_z:\n        r = bs(x, dist_xy + (dist_x - dist_z) / 2)\n        if r == 0:\n          return dist_x\n        return min(max(dist_x - dist[r], dist_z + dist[r] - dist_xy * 2), \n                   max(dist_x - dist[parent[r][0]], dist_z + dist[parent[r][0]] - dist_xy * 2))\n      else:\n        r = bs(yz, dist_xy + (dist_z - dist_x) / 2)\n        if r == 0:\n          return dist_z\n        return min(max(dist_z - dist[r], dist_x + dist[r] - dist_xy * 2), \n                   max(dist_z - dist[parent[r][0]], dist_x + dist[parent[r][0]] - dist_xy * 2))\n \n    elif dy >= dx >= dz:\n      r = bs(y, dist_yz + (dy - dx) / 2)\n      if r == 0:\n        return dist_y\n      return min(max(dist_y - dist[r], dist_x + dist[r] - dist_xy * 2), \n                 max(dist_y - dist[parent[r][0]], dist_x + dist[parent[r][0]] - dist_xy * 2))\n \n    elif dy >= dz >= dx:\n      r = bs(y, dist_yz + (dy - dz) / 2)\n      if r == 0:\n        return dist_y\n      return min(max(dist_y - dist[r], dist_z + dist[r] - dist_yz * 2), \n                 max(dist_y - dist[parent[r][0]], dist_z + dist[parent[r][0]] - dist_yz * 2))\n \n    elif dz >= dx >= dy:\n      r = bs(z, dist_yz + (dz - dx) / 2)\n      if r == 0:\n        return dist_z\n      return min(max(dist_z - dist[r], dist_x + dist[r] - dist_xy * 2), \n                 max(dist_z - dist[parent[r][0]], dist_x + dist[parent[r][0]] - dist_xy * 2))\n \n    elif dz >= dy >= dx:\n      r = bs(z, dist_yz + (dz - dy) / 2)\n      if r == 0:\n        return dist_z\n      return min(max(dist_z - dist[r], dist_y + dist[r] - dist_yz * 2), \n                 max(dist_z - dist[parent[r][0]], dist_y + dist[parent[r][0]] - dist_yz * 2))\n  \n  def score(a, b, c):\n    a -= 1\n    b -= 1\n    c -= 1\n    ab = lca(a, b)\n    ac = lca(a, c)\n    bc = lca(b, c)\n    if ab == ac:\n      return _score(a, b, c, ab, bc)\n    elif ab == bc:\n      return _score(b, a, c, ab, ac)\n    else:\n      return _score(c, a, b, ac, ab)\n  \n  for _ in range(q):\n    a, b, c = map(int, input().split())\n    print(score(a, b, c))\n\nmain()\n"
  }
]