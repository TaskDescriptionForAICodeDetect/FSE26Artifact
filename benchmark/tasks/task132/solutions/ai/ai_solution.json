[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100000\n#define LOG 20\n\ntypedef struct {\n    int to, len;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN], next_edge[MAXN * 2], edge_count;\nint depth[MAXN], parent[MAXN][LOG], max_len[MAXN][LOG];\nint N, Q;\n\nvoid add_edge(int u, int v, int len) {\n    edges[edge_count] = (Edge){v, len};\n    next_edge[edge_count] = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int p, int d, int l) {\n    depth[u] = d;\n    parent[u][0] = p;\n    max_len[u][0] = l;\n    for (int i = 1; i < LOG; i++) {\n        parent[u][i] = parent[parent[u][i-1]][i-1];\n        max_len[u][i] = max_len[u][i-1] > max_len[parent[u][i-1]][i-1] ? max_len[u][i-1] : max_len[parent[u][i-1]][i-1];\n    }\n    for (int i = head[u]; i != -1; i = next_edge[i]) {\n        Edge e = edges[i];\n        if (e.to != p) {\n            dfs(e.to, u, d + 1, e.len);\n        }\n    }\n}\n\nint lca(int u, int v, int *max_l) {\n    *max_l = 0;\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    for (int i = LOG - 1; i >= 0; i--) {\n        if (depth[u] - (1 << i) >= depth[v]) {\n            if (max_len[u][i] > *max_l) *max_l = max_len[u][i];\n            u = parent[u][i];\n        }\n    }\n    if (u == v) return u;\n    for (int i = LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            if (max_len[u][i] > *max_l) *max_l = max_len[u][i];\n            if (max_len[v][i] > *max_l) *max_l = max_len[v][i];\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    if (max_len[u][0] > *max_l) *max_l = max_len[u][0];\n    if (max_len[v][0] > *max_l) *max_l = max_len[v][0];\n    return parent[u][0];\n}\n\nint get_max_dist(int u, int v) {\n    int max_l;\n    int ancestor = lca(u, v, &max_l);\n    return depth[u] + depth[v] - 2 * depth[ancestor];\n}\n\nint get_farthest(int a, int b, int c) {\n    int d1 = get_max_dist(a, b);\n    int d2 = get_max_dist(a, c);\n    int d3 = get_max_dist(b, c);\n    int max_d = d1;\n    if (d2 > max_d) max_d = d2;\n    if (d3 > max_d) max_d = d3;\n    return (max_d + 1) / 2;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    edge_count = 0;\n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < N - 1; i++) {\n        int u, v, len;\n        scanf(\"%d %d %d\", &u, &v, &len);\n        u--; v--;\n        add_edge(u, v, len);\n        add_edge(v, u, len);\n    }\n    dfs(0, 0, 0, 0);\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--; c--;\n        int res = get_farthest(a, b, c);\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class CityMeeting {\n    static final int MAX_N = 5005;\n    static List<List<Pair>> graph = new ArrayList<>();\n    static long[][] dist = new long[MAX_N][MAX_N];\n\n    static class Pair {\n        int node, weight;\n        Pair(int node, int weight) {\n            this.node = node;\n            this.weight = weight;\n        }\n    }\n\n    static void dijkstra(int start) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(a.weight, b.weight));\n        Arrays.fill(dist[start], Long.MAX_VALUE);\n        dist[start][start] = 0;\n        pq.offer(new Pair(start, 0));\n\n        while (!pq.isEmpty()) {\n            Pair curr = pq.poll();\n            int u = curr.node;\n            long currDist = curr.weight;\n\n            if (currDist > dist[start][u]) continue;\n\n            for (Pair edge : graph.get(u)) {\n                int v = edge.node;\n                long newDist = currDist + edge.weight;\n\n                if (newDist < dist[start][v]) {\n                    dist[start][v] = newDist;\n                    pq.offer(new Pair(v, (int)newDist));\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            int w = Integer.parseInt(st.nextToken());\n            graph.get(u).add(new Pair(v, w));\n            graph.get(v).add(new Pair(u, w));\n        }\n\n        for (int i = 1; i <= N; i++) {\n            dijkstra(i);\n        }\n\n        int Q = Integer.parseInt(br.readLine());\n        for (int q = 0; q < Q; q++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int c = Integer.parseInt(st.nextToken());\n\n            long minCost = Long.MAX_VALUE;\n            for (int meeting = 1; meeting <= N; meeting++) {\n                long maxDist = Math.max(dist[meeting][a], Math.max(dist[meeting][b], dist[meeting][c]));\n                minCost = Math.min(minCost, maxDist);\n            }\n            System.out.println(minCost);\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:46:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to, length;\n};\n\nvector<vector<Edge>> adj;\nvector<vector<int>> dist;\nint N, LOG;\n\nvoid bfs(int start, vector<int>& d) {\n    d.assign(N + 1, INT_MAX);\n    queue<int> q;\n    q.push(start);\n    d[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (const Edge& e : adj[u]) {\n            if (d[e.to] > d[u] + e.length) {\n                d[e.to] = d[u] + e.length;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N;\n    adj.resize(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].push_back({b, c});\n        adj[b].push_back({a, c});\n    }\n\n    dist.resize(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        bfs(i, dist[i]);\n    }\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        int min_cost = INT_MAX;\n        for (int i = 1; i <= N; ++i) {\n            int current_max = max({dist[i][a], dist[i][b], dist[i][c]});\n            if (current_max < min_cost) {\n                min_cost = current_max;\n            }\n        }\n        cout << min_cost << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_CITIES 1005\n\ntypedef struct {\n    int dest;\n    int length;\n    struct Edge* next;\n} Edge;\n\nint n, m;\nEdge* graph[MAX_CITIES];\nlong long dist[MAX_CITIES][3];\n\nvoid addEdge(int u, int v, int length) {\n    Edge* edge = malloc(sizeof(Edge));\n    edge->dest = v;\n    edge->length = length;\n    edge->next = graph[u];\n    graph[u] = edge;\n}\n\nvoid dijkstra(int start, long long* distances) {\n    int visited[MAX_CITIES] = {0};\n    for (int i = 1; i <= n; i++) {\n        distances[i] = LLONG_MAX;\n    }\n    distances[start] = 0;\n\n    for (int count = 0; count < n; count++) {\n        int u = -1;\n        long long min_dist = LLONG_MAX;\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && distances[v] < min_dist) {\n                min_dist = distances[v];\n                u = v;\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (Edge* edge = graph[u]; edge; edge = edge->next) {\n            int v = edge->dest;\n            if (!visited[v] && distances[u] + edge->length < distances[v]) {\n                distances[v] = distances[u] + edge->length;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, length;\n        scanf(\"%d %d %d\", &u, &v, &length);\n        addEdge(u, v, length);\n        addEdge(v, u, length);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    while (q--) {\n        int cities[3];\n        for (int i = 0; i < 3; i++) {\n            scanf(\"%d\", &cities[i]);\n        }\n\n        for (int i = 0; i < 3; i++) {\n            dijkstra(cities[i], dist[i]);\n        }\n\n        long long min_max_dist = LLONG_MAX;\n        int best_meeting_city = -1;\n\n        for (int meeting_city = 1; meeting_city <= n; meeting_city++) {\n            long long max_dist = 0;\n            for (int i = 0; i < 3; i++) {\n                max_dist = (max_dist > dist[i][meeting_city]) ? max_dist : dist[i][meeting_city];\n            }\n\n            if (max_dist < min_max_dist) {\n                min_max_dist = max_dist;\n                best_meeting_city = meeting_city;\n            }\n        }\n\n        printf(\"%lld\\n\", min_max_dist);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\n\nvector<pair<int, int>> graph[MAXN];\nlong long dist[3][MAXN];\n\nvoid dijkstra(int start, long long* distances) {\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    vector<bool> visited(MAXN, false);\n    \n    fill(distances, distances + MAXN, LLONG_MAX);\n    distances[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        \n        if (visited[u]) continue;\n        visited[u] = true;\n        \n        for (auto& [v, w] : graph[u]) {\n            if (distances[u] + w < distances[v]) {\n                distances[v] = distances[u] + w;\n                pq.push({distances[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int N, M;\n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n    }\n    \n    int Q;\n    cin >> Q;\n    \n    while (Q--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        \n        dijkstra(a, dist[0]);\n        dijkstra(b, dist[1]);\n        dijkstra(c, dist[2]);\n        \n        long long min_cost = LLONG_MAX;\n        int best_meeting_city = -1;\n        \n        for (int meeting_city = 1; meeting_city <= N; meeting_city++) {\n            long long max_dist = max({dist[0][meeting_city], dist[1][meeting_city], dist[2][meeting_city]});\n            \n            if (max_dist < min_cost) {\n                min_cost = max_dist;\n                best_meeting_city = meeting_city;\n            }\n        }\n        \n        cout << min_cost << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, length;\n        Edge(int to, int length) {\n            this.to = to;\n            this.length = length;\n        }\n    }\n\n    static int[][] dist;\n    static List<Edge>[] tree;\n    static int N;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int l = Integer.parseInt(st.nextToken());\n            tree[a].add(new Edge(b, l));\n            tree[b].add(new Edge(a, l));\n        }\n\n        dist = new int[N + 1][N + 1];\n        for (int i = 1; i <= N; i++) {\n            bfs(i);\n        }\n\n        int Q = Integer.parseInt(br.readLine());\n        StringBuilder sb = new StringBuilder();\n        for (int q = 0; q < Q; q++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            int z = Integer.parseInt(st.nextToken());\n            int minCost = Integer.MAX_VALUE;\n            for (int c = 1; c <= N; c++) {\n                int cost = Math.max(dist[x][c], Math.max(dist[y][c], dist[z][c]));\n                if (cost < minCost) {\n                    minCost = cost;\n                }\n            }\n            sb.append(minCost).append(\"\\n\");\n        }\n        System.out.print(sb);\n    }\n\n    static void bfs(int start) {\n        boolean[] visited = new boolean[N + 1];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        visited[start] = true;\n        dist[start][start] = 0;\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (Edge e : tree[u]) {\n                if (!visited[e.to]) {\n                    visited[e.to] = true;\n                    dist[start][e.to] = dist[start][u] + e.length;\n                    queue.add(e.to);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:47:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef dfs(x, parent, depth, dist, tree):\n    for y, length in tree[x]:\n        if y != parent:\n            dist[y] = dist[x] + length\n            depth[y] = depth[x] + 1\n            dfs(y, x, depth, dist, tree)\n\ndef lca(a, b, depth, up):\n    if depth[a] < depth[b]:\n        a, b = b, a\n    for i in range(len(up[0]) - 1, -1, -1):\n        if depth[a] - (1 << i) >= depth[b]:\n            a = up[a][i]\n    if a == b:\n        return a\n    for i in range(len(up[0]) - 1, -1, -1):\n        if up[a][i] != up[b][i]:\n            a = up[a][i]\n            b = up[b][i]\n    return up[a][0]\n\ndef dist_between(a, b, depth, dist, up):\n    lca_node = lca(a, b, depth, up)\n    return dist[a] + dist[b] - 2 * dist[lca_node]\n\ndef create_tree_and_lca(n, roads):\n    tree = defaultdict(list)\n    for u, v, l in roads:\n        tree[u].append((v, l))\n        tree[v].append((u, l))\n\n    depth = [0] * n\n    dist = [0] * n\n    log = max(1, len(bin(n - 1)) - 2)\n    up = [[-1] * (log + 1) for _ in range(n)]\n\n    def dfs_lca(node, parent):\n        up[node][0] = parent\n        for i in range(1, log + 1):\n            if up[node][i - 1] != -1:\n                up[node][i] = up[up[node][i - 1]][i - 1]\n        for neighbor, length in tree[node]:\n            if neighbor != parent:\n                dist[neighbor] = dist[node] + length\n                depth[neighbor] = depth[node] + 1\n                dfs_lca(neighbor, node)\n\n    # Start from an arbitrary node as the root (0 here)\n    dfs_lca(0, -1)\n\n    return tree, depth, dist, up\n\ndef minimal_cost(n, roads, queries):\n    tree, depth, dist, up = create_tree_and_lca(n, roads)\n    \n    results = []\n    for a, b, c in queries:\n        # Compute longest individual distances\n        ab = dist_between(a, b, depth, dist, up)\n        ac = dist_between(a, c, depth, dist, up)\n        bc = dist_between(b, c, depth, dist, up)\n        \n        # Consider all potential meeting points\n        ans = float('inf')\n        for meeting_city in [a, b, c]:\n            if meeting_city == a:\n                max_distance = max(ac, bc)\n            elif meeting_city == b:\n                max_distance = max(ab, ac)\n            else:\n                max_distance = max(ab, bc)\n            ans = min(ans, max_distance)\n        \n        results.append(ans)\n    \n    return results\n\n# Example usage\nn = 5\nroads = [(0, 1, 1), (1, 2, 1), (0, 3, 2), (3, 4, 3)]\nqueries = [(2, 3, 4), (0, 1, 4)]\nprint(minimal_cost(n, roads, queries))",
    "timestamp": "2025-08-13 00:49:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class IazuHighSchool {\n\n    static class City {\n        int id;\n        List<Road> roads = new ArrayList<>();\n\n        City(int id) {\n            this.id = id;\n        }\n    }\n\n    static class Road {\n        City target;\n        int length;\n\n        Road(City target, int length) {\n            this.target = target;\n            this.length = length;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        Map<Integer, City> cities = new HashMap<>();\n\n        for (int i = 1; i <= N; i++) {\n            cities.put(i, new City(i));\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int length = scanner.nextInt();\n            City cityU = cities.get(u);\n            City cityV = cities.get(v);\n            cityU.roads.add(new Road(cityV, length));\n            cityV.roads.add(new Road(cityU, length));\n        }\n\n        int Q = scanner.nextInt();\n        for (int q = 0; q < Q; q++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int c = scanner.nextInt();\n            int result = findMinimumCost(cities, a, b, c, N);\n            System.out.println(result);\n        }\n        scanner.close();\n    }\n\n    private static int findMinimumCost(Map<Integer, City> cities, int a, int b, int c, int totalCities) {\n        int[] distA = dijkstra(cities, a, totalCities);\n        int[] distB = dijkstra(cities, b, totalCities);\n        int[] distC = dijkstra(cities, c, totalCities);\n\n        int minCost = Integer.MAX_VALUE;\n        for (int i = 1; i <= totalCities; i++) {\n            int cost = Math.max(distA[i], Math.max(distB[i], distC[i]));\n            minCost = Math.min(minCost, cost);\n        }\n        return minCost;\n    }\n\n    private static int[] dijkstra(Map<Integer, City> cities, int startId, int totalCities) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        int[] distances = new int[totalCities + 1];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[startId] = 0;\n        pq.add(new int[]{startId, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int currentId = current[0];\n            int currentDist = current[1];\n\n            for (Road road : cities.get(currentId).roads) {\n                int neighborId = road.target.id;\n                int newDist = currentDist + road.length;\n\n                if (newDist < distances[neighborId]) {\n                    distances[neighborId] = newDist;\n                    pq.add(new int[]{neighborId, newDist});\n                }\n            }\n        }\n        return distances;\n    }\n}",
    "timestamp": "2025-08-13 00:49:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 10000\n#define MAX_Q 10000\n\ntypedef struct {\n    int city, length;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_N];\n    int count;\n} Graph;\n\nGraph graph[MAX_N];\nint dist[MAX_N];\n\nvoid add_edge(int u, int v, int length) {\n    graph[u].edges[graph[u].count].city = v;\n    graph[u].edges[graph[u].count].length = length;\n    graph[u].count++;\n}\n\nvoid dfs(int city, int parent) {\n    for (int i = 0; i < graph[city].count; ++i) {\n        Edge e = graph[city].edges[i];\n        if (e.city != parent) {\n            dist[e.city] = dist[city] + e.length;\n            dfs(e.city, city);\n        }\n    }\n}\n\nint find_meeting_city(int a, int b, int c, int n) {\n    int min_cost = INT_MAX;\n    int best_city = -1;\n\n    for (int i = 0; i < n; ++i) {\n        dist[i] = 0;\n        dfs(i, -1);\n\n        int cost_a = dist[a];\n        int cost_b = dist[b];\n        int cost_c = dist[c];\n        int max_cost = cost_a > cost_b ? (cost_a > cost_c ? cost_a : cost_c) : (cost_b > cost_c ? cost_b : cost_c);\n\n        if (max_cost < min_cost) {\n            min_cost = max_cost;\n            best_city = i;\n        }\n    }\n\n    return min_cost;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, length;\n        scanf(\"%d %d %d\", &u, &v, &length);\n        add_edge(u - 1, v - 1, length);\n        add_edge(v - 1, u - 1, length);\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; ++i) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        int cost = find_meeting_city(a - 1, b - 1, c - 1, n);\n        printf(\"%d\\n\", cost);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:49:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = [float('inf')] * len(graph)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n        \n        if current_dist > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef solve_theme(graph, cities):\n    n = len(graph)\n    min_max_dist = float('inf')\n    best_meeting_city = -1\n    \n    for meeting_city in range(n):\n        max_dist = 0\n        \n        for city in cities:\n            distances = dijkstra(graph, city)\n            max_dist = max(max_dist, distances[meeting_city])\n        \n        if max_dist < min_max_dist:\n            min_max_dist = max_dist\n            best_meeting_city = meeting_city\n    \n    return min_max_dist\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    \n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    \n    q = int(input())\n    \n    for _ in range(q):\n        theme_cities = list(map(lambda x: int(x)-1, input().split()))\n        result = solve_theme(graph, theme_cities)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:50:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom math import log2\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b, c = map(int, input[ptr:ptr+3])\n        ptr +=3\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n\n    LOG = int(log2(N)) + 1\n    parent = [[-1]*(N+1) for _ in range(LOG)]\n    depth = [0]*(N+1)\n    dist = [0]*(N+1)\n\n    # BFS to set up parent[0], depth, and dist\n    q = deque([1])\n    parent[0][1] = -1  # 1 is root\n    while q:\n        v = q.popleft()\n        for u, c in adj[v]:\n            if parent[0][u] == -1 and u != parent[0][v]:\n                parent[0][u] = v\n                depth[u] = depth[v] + 1\n                dist[u] = dist[v] + c\n                q.append(u)\n\n    # Binary lifting table\n    for k in range(1, LOG):\n        for v in range(1, N+1):\n            if parent[k-1][v] != -1:\n                parent[k][v] = parent[k-1][parent[k-1][v]]\n\n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u up to depth of v\n        for k in range(LOG-1, -1, -1):\n            if depth[u] - (1 << k) >= depth[v]:\n                u = parent[k][u]\n        if u == v:\n            return u\n        for k in range(LOG-1, -1, -1):\n            if parent[k][u] != -1 and parent[k][u] != parent[k][v]:\n                u = parent[k][u]\n                v = parent[k][v]\n        return parent[0][u]\n\n    def get_distance(u, v):\n        ancestor = lca(u, v)\n        return dist[u] + dist[v] - 2 * dist[ancestor]\n\n    Q = int(input[ptr])\n    ptr +=1\n    for _ in range(Q):\n        a, b, c = map(int, input[ptr:ptr+3])\n        ptr +=3\n        d1 = get_distance(a, b)\n        d2 = get_distance(a, c)\n        d3 = get_distance(b, c)\n        total = (d1 + d2 + d3) // 2\n        min_max = min(max(d1, get_distance(a, c)), max(d2, get_distance(b, c)), max(d3, get_distance(c, a)))\n        print(min_max)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 00:50:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9 + 7;\n\nvoid dfs(int u, int parent, vector<vector<pair<int, int>>> &adj, vector<int> &dist) {\n    for (auto &[v, w] : adj[u]) {\n        if (v != parent) {\n            dist[v] = dist[u] + w;\n            dfs(v, u, adj, dist);\n        }\n    }\n}\n\nint findMinCostCity(int a, int b, int c, vector<vector<pair<int, int>>> &adj, int N) {\n    vector<int> distA(N), distB(N), distC(N);\n    \n    distA[a] = distB[b] = distC[c] = 0;\n    dfs(a, -1, adj, distA);\n    dfs(b, -1, adj, distB);\n    dfs(c, -1, adj, distC);\n    \n    int minCost = INF;\n    for (int i = 0; i < N; ++i) {\n        int cost = max({distA[i], distB[i], distC[i]});\n        minCost = min(minCost, cost);\n    }\n    return minCost;\n}\n\nint main() {\n    int N, Q;\n    cin >> N;\n    \n    vector<vector<pair<int, int>>> adj(N);\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u;\n        --v;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    \n    cin >> Q;\n    for (int i = 0; i < Q; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        --c;\n        \n        int minCost = findMinCostCity(a, b, c, adj, N);\n        cout << minCost << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:15"
  }
]