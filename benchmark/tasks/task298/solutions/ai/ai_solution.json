[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\nint tree[4 * MAX_N];\nint arr[MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node + 1, start, mid);\n        build(2 * node + 2, mid + 1, end);\n        tree[node] = (tree[2 * node + 1] < tree[2 * node + 2]) ? tree[2 * node + 1] : tree[2 * node + 2];\n    }\n}\n\nvoid update(int node, int start, int end, int pos, int val) {\n    if (start == end) {\n        arr[pos] = val;\n        tree[node] = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (pos <= mid) {\n            update(2 * node + 1, start, mid, pos, val);\n        } else {\n            update(2 * node + 2, mid + 1, end, pos, val);\n        }\n        tree[node] = (tree[2 * node + 1] < tree[2 * node + 2]) ? tree[2 * node + 1] : tree[2 * node + 2];\n    }\n}\n\nint query(int node, int start, int end, int l, int r) {\n    if (r < start || l > end) {\n        return INT_MAX;\n    }\n    if (l <= start && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    int left = query(2 * node + 1, start, mid, l, r);\n    int right = query(2 * node + 2, mid + 1, end, l, r);\n    return (left < right) ? left : right;\n}\n\nvoid circular_shift(int l, int r, int n) {\n    if (l >= r) return;\n    int temp = arr[r];\n    for (int i = r; i > l; i--) {\n        arr[i] = arr[i - 1];\n        update(0, 0, n - 1, i, arr[i]);\n    }\n    arr[l] = temp;\n    update(0, 0, n - 1, l, arr[l]);\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    build(0, 0, n - 1);\n    while (q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            circular_shift(l - 1, r - 1, n);\n        } else if (type == 2) {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%d\\n\", query(0, 0, n - 1, l - 1, r - 1));\n        } else if (type == 3) {\n            int pos, val;\n            scanf(\"%d %d\", &pos, &val);\n            update(0, 0, n - 1, pos - 1, val);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    int n;\n    vector<int> min_tree;\n    vector<int> lazy;\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            min_tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            min_tree[node] = min(min_tree[2 * node + 1], min_tree[2 * node + 2]);\n        }\n    }\n\n    void push(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            min_tree[node] += lazy[node];\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void update_range(int node, int start, int end, int l, int r, int val) {\n        push(node, start, end);\n        if (start > end || start > r || end < l) return;\n        if (start >= l && end <= r) {\n            lazy[node] += val;\n            push(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        update_range(2 * node + 1, start, mid, l, r, val);\n        update_range(2 * node + 2, mid + 1, end, l, r, val);\n        min_tree[node] = min(min_tree[2 * node + 1], min_tree[2 * node + 2]);\n    }\n\n    int query_range(int node, int start, int end, int l, int r) {\n        push(node, start, end);\n        if (start > end || start > r || end < l) return INT_MAX;\n        if (start >= l && end <= r) return min_tree[node];\n        int mid = (start + end) / 2;\n        int left = query_range(2 * node + 1, start, mid, l, r);\n        int right = query_range(2 * node + 2, mid + 1, end, l, r);\n        return min(left, right);\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        min_tree.resize(4 * n);\n        lazy.resize(4 * n, 0);\n        build(arr, 0, 0, n - 1);\n    }\n\n    void update(int l, int r, int val) {\n        update_range(0, 0, n - 1, l, r, val);\n    }\n\n    int query(int l, int r) {\n        return query_range(0, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(arr);\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int l, r;\n            cin >> l >> r;\n            int last = arr[r];\n            for (int i = r; i > l; --i) {\n                arr[i] = arr[i - 1];\n            }\n            arr[l] = last;\n            st = SegmentTree(arr);\n        } else if (type == 2) {\n            int l, r;\n            cin >> l >> r;\n            cout << st.query(l, r) << '\\n';\n        } else if (type == 3) {\n            int pos, val;\n            cin >> pos >> val;\n            arr[pos] = val;\n            st = SegmentTree(arr);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class SegmentTree {\n        int[] tree;\n        int[] lazy;\n        int size;\n\n        SegmentTree(int[] arr) {\n            size = arr.length;\n            tree = new int[4 * size];\n            lazy = new int[4 * size];\n            build(arr, 0, 0, size - 1);\n        }\n\n        void build(int[] arr, int node, int left, int right) {\n            if (left == right) {\n                tree[node] = arr[left];\n            } else {\n                int mid = (left + right) / 2;\n                build(arr, 2 * node + 1, left, mid);\n                build(arr, 2 * node + 2, mid + 1, right);\n                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        void push(int node, int left, int right) {\n            if (lazy[node] != 0) {\n                tree[node] += lazy[node];\n                if (left != right) {\n                    lazy[2 * node + 1] += lazy[node];\n                    lazy[2 * node + 2] += lazy[node];\n                }\n                lazy[node] = 0;\n            }\n        }\n\n        void updateRange(int node, int left, int right, int l, int r, int val) {\n            push(node, left, right);\n            if (right < l || left > r) return;\n            if (l <= left && right <= r) {\n                lazy[node] += val;\n                push(node, left, right);\n            } else {\n                int mid = (left + right) / 2;\n                updateRange(2 * node + 1, left, mid, l, r, val);\n                updateRange(2 * node + 2, mid + 1, right, l, r, val);\n                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        int queryMin(int node, int left, int right, int l, int r) {\n            push(node, left, right);\n            if (right < l || left > r) return Integer.MAX_VALUE;\n            if (l <= left && right <= r) {\n                return tree[node];\n            }\n            int mid = (left + right) / 2;\n            return Math.min(\n                queryMin(2 * node + 1, left, mid, l, r),\n                queryMin(2 * node + 2, mid + 1, right, l, r)\n            );\n        }\n\n        void updatePoint(int node, int left, int right, int pos, int val) {\n            push(node, left, right);\n            if (left == right) {\n                tree[node] = val;\n            } else {\n                int mid = (left + right) / 2;\n                if (pos <= mid) {\n                    updatePoint(2 * node + 1, left, mid, pos, val);\n                } else {\n                    updatePoint(2 * node + 2, mid + 1, right, pos, val);\n                }\n                push(2 * node + 1, left, mid);\n                push(2 * node + 2, mid + 1, right);\n                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int q = Integer.parseInt(st.nextToken());\n        int[] arr = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        SegmentTree stree = new SegmentTree(arr);\n        while (q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n            if (type == 1) {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                int last = stree.queryMin(0, 0, n - 1, r, r);\n                stree.updatePoint(0, 0, n - 1, r, stree.queryMin(0, 0, n - 1, l, l));\n                stree.updateRange(0, 0, n - 1, l, r - 1, 0);\n            } else if (type == 2) {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                out.println(stree.queryMin(0, 0, n - 1, l, r));\n            } else if (type == 3) {\n                int pos = Integer.parseInt(st.nextToken()) - 1;\n                int val = Integer.parseInt(st.nextToken());\n                stree.updatePoint(0, 0, n - 1, pos, val);\n            }\n        }\n        out.flush();\n    }\n}",
    "timestamp": "2025-08-05 21:00:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static class SegmentTree {\n        int[] tree;\n        int[] arr;\n        int n;\n\n        SegmentTree(int[] input) {\n            n = input.length;\n            arr = Arrays.copyOf(input, n);\n            tree = new int[4 * n];\n            build(1, 0, n - 1);\n        }\n\n        void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = arr[start];\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(2 * node, start, mid);\n            build(2 * node + 1, mid + 1, end);\n            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);\n        }\n\n        void update(int pos, int val) {\n            updateUtil(1, 0, n - 1, pos, val);\n        }\n\n        void updateUtil(int node, int start, int end, int pos, int val) {\n            if (start == end) {\n                arr[pos] = val;\n                tree[node] = val;\n                return;\n            }\n            int mid = (start + end) / 2;\n            if (pos <= mid)\n                updateUtil(2 * node, start, mid, pos, val);\n            else\n                updateUtil(2 * node + 1, mid + 1, end, pos, val);\n            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);\n        }\n\n        int query(int l, int r) {\n            return queryUtil(1, 0, n - 1, l, r);\n        }\n\n        int queryUtil(int node, int start, int end, int l, int r) {\n            if (r < start || end < l)\n                return Integer.MAX_VALUE;\n            if (l <= start && end <= r)\n                return tree[node];\n            int mid = (start + end) / 2;\n            int left = queryUtil(2 * node, start, mid, l, r);\n            int right = queryUtil(2 * node + 1, mid + 1, end, l, r);\n            return Math.min(left, right);\n        }\n\n        void circularShift(int l, int r) {\n            int temp = arr[r];\n            for (int i = r; i > l; i--)\n                arr[i] = arr[i - 1];\n            arr[l] = temp;\n            build(1, 0, n - 1);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int[] arr = new int[n];\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n\n        SegmentTree segTree = new SegmentTree(arr);\n\n        int q = Integer.parseInt(br.readLine());\n        StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < q; i++) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n\n            if (type == 1) {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                segTree.circularShift(l, r);\n            } else if (type == 2) {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                sb.append(segTree.query(l, r)).append(\"\\n\");\n            } else {\n                int pos = Integer.parseInt(st.nextToken()) - 1;\n                int val = Integer.parseInt(st.nextToken());\n                segTree.update(pos, val);\n            }\n        }\n        System.out.print(sb);\n    }\n}",
    "timestamp": "2025-08-05 21:00:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100005\n\nint arr[MAX_N];\nint tree[4 * MAX_N];\n\nvoid build_tree(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = arr[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    build_tree(2 * node, start, mid);\n    build_tree(2 * node + 1, mid + 1, end);\n    tree[node] = (tree[2 * node] < tree[2 * node + 1]) ? tree[2 * node] : tree[2 * node + 1];\n}\n\nvoid update_tree(int node, int start, int end, int pos, int val) {\n    if (start == end) {\n        arr[pos] = val;\n        tree[node] = val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (pos <= mid)\n        update_tree(2 * node, start, mid, pos, val);\n    else\n        update_tree(2 * node + 1, mid + 1, end, pos, val);\n    tree[node] = (tree[2 * node] < tree[2 * node + 1]) ? tree[2 * node] : tree[2 * node + 1];\n}\n\nint query_tree(int node, int start, int end, int l, int r) {\n    if (r < start || end < l)\n        return INT_MAX;\n    if (l <= start && end <= r)\n        return tree[node];\n    \n    int mid = (start + end) / 2;\n    int left_query = query_tree(2 * node, start, mid, l, r);\n    int right_query = query_tree(2 * node + 1, mid + 1, end, l, r);\n    return (left_query < right_query) ? left_query : right_query;\n}\n\nvoid circular_shift(int l, int r) {\n    int temp = arr[r];\n    for (int i = r; i > l; i--)\n        arr[i] = arr[i-1];\n    arr[l] = temp;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &arr[i]);\n    \n    build_tree(1, 0, n-1);\n    \n    while (q--) {\n        int type, l, r, pos, val;\n        scanf(\"%d\", &type);\n        \n        if (type == 1) {\n            scanf(\"%d %d\", &l, &r);\n            circular_shift(l-1, r-1);\n            build_tree(1, 0, n-1);\n        }\n        else if (type == 2) {\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%d\\n\", query_tree(1, 0, n-1, l-1, r-1));\n        }\n        else if (type == 3) {\n            scanf(\"%d %d\", &pos, &val);\n            update_tree(1, 0, n-1, pos-1, val);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> arr;\n    vector<int> segTree;\n\n    void buildSegTree(int node, int start, int end) {\n        if (start == end) {\n            segTree[node] = arr[start];\n            return;\n        }\n        \n        int mid = start + (end - start) / 2;\n        buildSegTree(2 * node, start, mid);\n        buildSegTree(2 * node + 1, mid + 1, end);\n        \n        segTree[node] = min(segTree[2 * node], segTree[2 * node + 1]);\n    }\n\n    void updateSegTree(int node, int start, int end, int pos, int val) {\n        if (start == end) {\n            arr[pos] = val;\n            segTree[node] = val;\n            return;\n        }\n        \n        int mid = start + (end - start) / 2;\n        if (pos <= mid)\n            updateSegTree(2 * node, start, mid, pos, val);\n        else\n            updateSegTree(2 * node + 1, mid + 1, end, pos, val);\n        \n        segTree[node] = min(segTree[2 * node], segTree[2 * node + 1]);\n    }\n\n    int querySegTree(int node, int start, int end, int l, int r) {\n        if (r < start || end < l)\n            return INT_MAX;\n        \n        if (l <= start && end <= r)\n            return segTree[node];\n        \n        int mid = start + (end - start) / 2;\n        int left = querySegTree(2 * node, start, mid, l, r);\n        int right = querySegTree(2 * node + 1, mid + 1, end, l, r);\n        \n        return min(left, right);\n    }\n\n    void circularShift(int l, int r) {\n        int temp = arr[r];\n        for (int i = r; i > l; i--)\n            arr[i] = arr[i-1];\n        arr[l] = temp;\n    }\n\npublic:\n    Solution(vector<int>& nums) {\n        arr = nums;\n        int n = arr.size();\n        segTree.resize(4 * n);\n        buildSegTree(1, 0, n - 1);\n    }\n\n    void processQuery(int type, int l, int r, int val = 0) {\n        if (type == 1) {\n            circularShift(l, r);\n            buildSegTree(1, 0, arr.size() - 1);\n        } else if (type == 2) {\n            cout << querySegTree(1, 0, arr.size() - 1, l, r) << endl;\n        } else if (type == 3) {\n            updateSegTree(1, 0, arr.size() - 1, l, val);\n        }\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    vector<int> nums(n);\n    for (int i = 0; i < n; i++)\n        cin >> nums[i];\n    \n    Solution sol(nums);\n    \n    while (q--) {\n        int type, l, r, val = 0;\n        cin >> type;\n        \n        if (type == 1) {\n            cin >> l >> r;\n            sol.processQuery(type, l, r);\n        } else if (type == 2) {\n            cin >> l >> r;\n            sol.processQuery(type, l, r);\n        } else if (type == 3) {\n            cin >> l >> val;\n            sol.processQuery(type, l, l, val);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, data):\n        n = len(data)\n        self.n = n\n        self.tree = [0] * (2 * n)\n        for i in range(n):\n            self.tree[i + n] = data[i]\n        for i in range(n - 1, 0, -1):\n            self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, pos, value):\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1])\n\n    def range_minimum(self, left, right):\n        res = float('inf')\n        left += self.n\n        right += self.n + 1\n        while left < right:\n            if left % 2 == 1:\n                res = min(res, self.tree[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                res = min(res, self.tree[right])\n            left //= 2\n            right //= 2\n        return res\n\ndef circular_shift(data, l, r):\n    if l < r:\n        first_value = data[l]\n        for i in range(l, r):\n            data[i] = data[i + 1]\n        data[r] = first_value\n\ndef process_queries(n, arr, queries):\n    seg_tree = SegmentTree(arr)\n    \n    results = []\n    for query in queries:\n        t = query[0]\n        if t == 1:\n            l, r = query[1], query[2]\n            circular_shift(arr, l, r)\n            seg_tree = SegmentTree(arr)  # Rebuild segtree due to change in array\n        elif t == 2:\n            l, r = query[1], query[2]\n            result = seg_tree.range_minimum(l, r)\n            results.append(result)\n        elif t == 3:\n            pos, val = query[1], query[2]\n            arr[pos] = val\n            seg_tree.update(pos, val)\n    return results",
    "timestamp": "2025-08-13 04:23:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CircularShiftAndMinQuery {\n    static int[] arr;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read number of elements\n        int n = sc.nextInt();\n        arr = new int[n];\n        \n        // Read the array elements\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        \n        // Read number of queries\n        int q = sc.nextInt();\n        for (int i = 0; i < q; i++) {\n            int type = sc.nextInt();\n            if (type == 1) { // Circular Shift\n                int l = sc.nextInt();\n                int r = sc.nextInt();\n                circularShift(l, r);\n            } else if (type == 2) { // Find Minimum\n                int l = sc.nextInt();\n                int r = sc.nextInt();\n                System.out.println(findMin(l, r));\n            } else if (type == 3) { // Update Value\n                int pos = sc.nextInt();\n                int val = sc.nextInt();\n                updateValue(pos, val);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static void circularShift(int l, int r) {\n        if (l < r) {\n            int temp = arr[r];\n            System.arraycopy(arr, l, arr, l + 1, r - l);\n            arr[l] = temp;\n        }\n    }\n    \n    static int findMin(int l, int r) {\n        int min = Integer.MAX_VALUE;\n        for (int i = l; i <= r; i++) {\n            if (arr[i] < min) {\n                min = arr[i];\n            }\n        }\n        return min;\n    }\n\n    static void updateValue(int pos, int val) {\n        arr[pos] = val;\n    }\n}",
    "timestamp": "2025-08-13 04:23:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nvoid circularShift(int arr[], int l, int r) {\n    if (l < r) {\n        int temp = arr[r];\n        for (int i = r; i > l; --i) {\n            arr[i] = arr[i - 1];\n        }\n        arr[l] = temp;\n    }\n}\n\nint findMin(int arr[], int l, int r) {\n    int minVal = INT_MAX;\n    for (int i = l; i <= r; ++i) {\n        if (arr[i] < minVal) {\n            minVal = arr[i];\n        }\n    }\n    return minVal;\n}\n\nvoid updateValue(int arr[], int pos, int val) {\n    arr[pos] = val;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n    int arr[n];\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; ++i) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) { // Circular shift query\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            circularShift(arr, l, r);\n        } else if (type == 2) { // Find min query\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%d\\n\", findMin(arr, l, r));\n        } else if (type == 3) { // Update query\n            int pos, val;\n            scanf(\"%d %d\", &pos, &val);\n            updateValue(arr, pos, val);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:23:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.arr = arr\n        self.build(0, 0, self.n - 1)\n\n    def build(self, node, start, end):\n        if start == end:\n            self.tree[node] = self.arr[start]\n            return\n        mid = (start + end) // 2\n        self.build(2 * node + 1, start, mid)\n        self.build(2 * node + 2, mid + 1, end)\n        self.tree[node] = min(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n    def update(self, node, start, end, pos, val):\n        if start == end:\n            self.arr[pos] = val\n            self.tree[node] = val\n            return\n        mid = (start + end) // 2\n        if pos <= mid:\n            self.update(2 * node + 1, start, mid, pos, val)\n        else:\n            self.update(2 * node + 2, mid + 1, end, pos, val)\n        self.tree[node] = min(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n    def query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return float('inf')\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left = self.query(2 * node + 1, start, mid, l, r)\n        right = self.query(2 * node + 2, mid + 1, end, l, r)\n        return min(left, right)\n\n    def circular_shift(self, l, r):\n        if l >= r:\n            return\n        temp = self.arr[r]\n        for i in range(r, l, -1):\n            self.arr[i] = self.arr[i-1]\n        self.arr[l] = temp\n        self.build(0, 0, self.n - 1)\n\ndef solve_queries(n, arr, queries):\n    st = SegmentTree(arr)\n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            st.circular_shift(query[1], query[2])\n        elif query[0] == 2:\n            results.append(st.query(0, 0, n-1, query[1], query[2]))\n        elif query[0] == 3:\n            st.update(0, 0, n-1, query[1], query[2])\n    \n    return results\n\n# Example usage\nn = 5\narr = [1, 2, 3, 4, 5]\nqueries = [\n    [1, 1, 3],  # Circular shift from index 1 to 3\n    [2, 0, 2],  # Find minimum between index 0 and 2\n    [3, 2, 10]  # Update index 2 to value 10\n]\n\nprint(solve_queries(n, arr, queries))",
    "timestamp": "2025-08-13 04:23:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.size = 1 << (math.ceil(math.log2(self.n)))\n        self.min_tree = [float('inf')] * (2 * self.size)\n        \n        for i in range(self.n):\n            self.min_tree[self.size + i] = data[i]\n        for i in range(self.size - 1, 0, -1):\n            self.min_tree[i] = min(self.min_tree[2 * i], self.min_tree[2 * i + 1])\n    \n    def update(self, pos, val):\n        pos += self.size\n        self.min_tree[pos] = val\n        pos >>= 1\n        while pos >= 1:\n            new_val = min(self.min_tree[2 * pos], self.min_tree[2 * pos + 1])\n            if self.min_tree[pos] == new_val:\n                break\n            self.min_tree[pos] = new_val\n            pos >>= 1\n    \n    def query_min(self, l, r):\n        res = float('inf')\n        l += self.size\n        r += self.size\n        while l <= r:\n            if l % 2 == 1:\n                res = min(res, self.min_tree[l])\n                l += 1\n            if r % 2 == 0:\n                res = min(res, self.min_tree[r])\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return res\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    a = list(map(int, input[ptr:ptr + n]))\n    ptr += n\n    \n    st = SegmentTree(a)\n    \n    q = int(input[ptr])\n    ptr += 1\n    \n    for _ in range(q):\n        parts = input[ptr]\n        if parts == '1':\n            # Circular shift\n            ptr += 1\n            l = int(input[ptr]) - 1\n            ptr += 1\n            r = int(input[ptr]) - 1\n            ptr += 1\n            if l >= r:\n                continue\n            last_val = a[r]\n            for i in range(r, l, -1):\n                a[i] = a[i - 1]\n                st.update(i, a[i])\n            a[l] = last_val\n            st.update(l, last_val)\n        elif parts == '2':\n            # Query min\n            ptr += 1\n            l = int(input[ptr]) - 1\n            ptr += 1\n            r = int(input[ptr]) - 1\n            ptr += 1\n            print(st.query_min(l, r))\n        elif parts == '3':\n            # Update\n            ptr += 1\n            pos = int(input[ptr]) - 1\n            ptr += 1\n            val = int(input[ptr])\n            ptr += 1\n            a[pos] = val\n            st.update(pos, val)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 04:24:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    int n;\n    vector<int> data, lazy;\n    \n    SegmentTree(int size): n(size), data(4*size, INT_MAX), lazy(4*size, 0) {}\n\n    void build(vector<int>& arr, int l, int r, int pos) {\n        if (l == r) {\n            data[pos] = arr[l];\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(arr, l, mid, 2 * pos + 1);\n        build(arr, mid + 1, r, 2 * pos + 2);\n        data[pos] = min(data[2 * pos + 1], data[2 * pos + 2]);\n    }\n\n    void push(int pos) {\n        if (lazy[pos] != 0) {\n            data[pos] += lazy[pos];\n            if (2 * pos + 1 < 4 * n) lazy[2 * pos + 1] += lazy[pos];\n            if (2 * pos + 2 < 4 * n) lazy[2 * pos + 2] += lazy[pos];\n            lazy[pos] = 0;\n        }\n    }\n\n    void updateRange(int l, int r, int ql, int qr, int delta, int pos) {\n        push(pos);\n        if (l > r || l > qr || r < ql) return;\n        if (l >= ql && r <= qr) {\n            lazy[pos] += delta;\n            push(pos);\n            return;\n        }\n        int mid = (l + r) / 2;\n        updateRange(l, mid, ql, qr, delta, 2 * pos + 1);\n        updateRange(mid + 1, r, ql, qr, delta, 2 * pos + 2);\n        data[pos] = min(data[2 * pos + 1], data[2 * pos + 2]);\n    }\n\n    int queryMin(int l, int r, int ql, int qr, int pos) {\n        push(pos);\n        if (l > r || l > qr || r < ql) return INT_MAX;\n        if (l >= ql && r <= qr) return data[pos];\n        int mid = (l + r) / 2;\n        return min(queryMin(l, mid, ql, qr, 2 * pos + 1), queryMin(mid + 1, r, ql, qr, 2 * pos + 2));\n    }\n\n    void updatePoint(int l, int r, int idx, int val, int pos) {\n        push(pos);\n        if (l == r) {\n            data[pos] = val;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (idx <= mid) updatePoint(l, mid, idx, val, 2 * pos + 1);\n        else updatePoint(mid + 1, r, idx, val, 2 * pos + 2);\n        data[pos] = min(data[2 * pos + 1], data[2 * pos + 2]);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) cin >> arr[i];\n    \n    SegmentTree segTree(n);\n    segTree.build(arr, 0, n - 1, 0);\n    \n    cin >> q;\n    while (q--) {\n        int type, l, r, pos, val;\n        cin >> type;\n        if (type == 1) {\n            cin >> l >> r;\n            --l; --r;\n            int last = arr[r];\n            for (int i = r; i > l; --i) arr[i] = arr[i - 1];\n            arr[l] = last;\n            segTree.build(arr, 0, n - 1, 0);\n        } else if (type == 2) {\n            cin >> l >> r;\n            --l; --r;\n            cout << segTree.queryMin(0, n - 1, l, r, 0) << \"\\n\";\n        } else if (type == 3) {\n            cin >> pos >> val;\n            --pos;\n            arr[pos] = val;\n            segTree.updatePoint(0, n - 1, pos, val, 0);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:19:24"
  }
]