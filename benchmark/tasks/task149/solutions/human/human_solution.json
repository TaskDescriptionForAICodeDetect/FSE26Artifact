[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tif(c==1){\n\t\tprintf(\"%d\\n%d %d\\n\",0,d[0].first,d[0].second);\n\t\treturn 0;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=c/2;\n\t\tif(c/2>xat){\n\t\t\t;\n\t\t}else{\n\t\t\tCenterX--;\n\t\t}\n\t\tint CenterY=c/2;\n\t\tif(c/2>yat){;}\n\t\telse CenterY--;\n\t\tlong long T=-abs(x[CenterX]-d[i].first)-abs(y[CenterY]-d[i].second);\n\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\n\t//\tprintf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\tans=T;\n\t\t\trow=x[CenterX];\n\t\t\tcol=y[CenterY];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n//typedef pair<int,int> P;\nstruct P {int x,y;};\nint w,h,n;\nP ie[100002];\n\nint t(int x,int y) {\n  int sum=0;\n  int md=0;\n  int d=0;\n  rep(i,n){\n    d=abs(ie[i].x-x)+abs(ie[i].y-y);\n    sum+=d*2;\n    md=max(md,d);\n  }\n  return sum-md;\n}\n\nsigned main(){\n  cin>>w>>h>>n;\n  int gx=0,gy=0;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ie[i]={x,y};\n    gx+=x;\n    gy+=y;\n  }\n  gx/=n;\n  gy/=n;\n  while(t(gx-1,gy)<=t(gx,gy))gx--;\n  while(t(gx,gy)>t(gx+1,gy))gx++;\n  while(t(gx,gy-1)<=t(gx,gy))gy--;\n  while(t(gx,gy)>t(gx,gy+1))gy++;\n  cout<<t(gx,gy)<<endl;\n  cout<<gx<<\" \"<<gy<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n\n\n\n\n\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define MAX_N 111111\ntypedef long long int ll;\nint W,H;int N;\nll A[MAX_N];ll B[MAX_N];\nint main()\n{\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lld%lld\",&A[i],&B[i]);\n\t}\n\tif(N&1){\n\t\tint n=N/2;ll x,y;vector<ll>X,Y;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tX.pb(A[i]);\n\t\t\tY.pb(B[i]);\n\t\t}\n\t\tsort(X.begin(),X.end());\n\t\tsort(Y.begin(),Y.end());\n\t\tx=X[n];y=Y[n];\n\t\tll ans=0;\n\t\tll M=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tM=max(M,abs(x-A[i])+abs(y-B[i]));\n\t\t\tans+=abs(x-A[i]);ans+=abs(y-B[i]);\n\t\t}\n\t\tprintf(\"%lld\\n%lld %lld\\n\",2*ans-M,x,y);\n\t}\n\telse{\n\t\tint n=(N-1)/2;ll x[2],y[2];vector<ll>X,Y;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tX.pb(A[i]);\n\t\t\tY.pb(B[i]);\n\t\t}\n\t\tsort(X.begin(),X.end());\n\t\tsort(Y.begin(),Y.end());\n\t\tfor(int i=0;i<2;i++){\n\t\t\tx[i]=X[n+i];y[i]=Y[n+i];\n\t\t}\n\t\tll ans[4]={0};\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tll M=0;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tM=max(abs(x[j]-A[i])+abs(y[k]-B[i]),M);\n\t\t\t\t\tans[j*2+k]+=abs(x[j]-A[i]);ans[j*2+k]+=abs(y[k]-B[i]);\n\t\t\t\t}\n\t\t\t\tans[j*2+k]*=2;\n\t\t\t\tans[j*2+k]-=M;\n\t\t\t}\n\t\t}\n\t\tll C=min(min(ans[0],ans[1]),min(ans[2],ans[3]));\n\t\tprintf(\"%lld\\n\",C);\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//printf(\"ans[%d]=%lld\\n\",i,ans[i]);\n\t\t\tif(C==ans[i]){\n\t\t\t\tprintf(\"%lld %lld\\n\",x[i/2],y[i%2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e9\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx, ansy;\n\tP *p;\n\tP save, save2;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = (2 * n - 1) / 2;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tp = lower_bound(house[1], house[1] + n, house[0][j]);\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tma = max(ma, abs(house[0][j].F - x) + abs(house[0][j].S - y));\n\t\t}\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\thouse[0][n - 1] = house[0][j + 1];\n\t\thouse[1][n - 1] = *p;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]>a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]<a[i]){//////error\n                }\n                else{\n                    if(mem[2]>b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0;\n\tdeque<long long> XY[2];\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tstable_sort( XY[0].begin(), XY[0].end() );\n\tstable_sort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\toxy[0][f1] = XY[f1][HL-1];\n\t\t\toxy[1][f1] = XY[f1][HL];\n\t\t}\n\t\t//400k\n\t\tfor(f2 = 0; f2 < 2; f2++){\n\t\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp * 2;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int W,H,N;\n    cin >> W >> H >> N;\n    vector<int> X, Y;\n    vector<pair<int,int> > XY;\n    for(int i=0; i<N; i++){\n        int x,y;\n        cin >> x >> y;\n        X.push_back(x);\n        Y.push_back(y);\n        XY.push_back(MP(x, y));\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    vector<LL> waX, waY;\n    waX.push_back(X.front());\n    waY.push_back(Y.front());\n    for(int i=1; i<N; i++){\n        waX.push_back(waX.back() + X[i]);\n        waY.push_back(waY.back() + Y[i]);\n    }\n\n    //最後に行く交差点を決定\n    LL ans = LL_MAX;\n    pair<LL,LL> tmp = MP(0,0);\n    for(int i=0; i<N; i++){\n        LL nowX = 2*waX.back() - XY[i].first;\n        LL nowY = 2*waY.back() - XY[i].second;\n        nowX = nowX / (2*N-1);\n        nowY = nowY / (2*N-1);\n        LL sum = 0;\n        int a = (upper_bound(X.begin(), X.end(), nowX) - X.begin()) - 1;\n        sum += nowX * (a+1) - waX[a] + (waX.back() - waX[a]) - nowX * (N-a-1);\n        int b = (upper_bound(Y.begin(), Y.end(), nowY) - Y.begin()) - 1;\n        sum += nowY * (b+1) - waY[b] + (waY.back() - waY[b]) - nowY * (N-b-1);\n        sum *= 2;\n        sum -= abs(nowX - XY[i].first);\n        sum -= abs(nowY - XY[i].second);\n        if(sum < ans || (sum == ans && tmp.first > nowX) || (sum == ans && tmp.first == nowX && tmp.second > nowY)){\n            ans = sum;\n            tmp = MP(nowX, nowY);\n        }\n\n        nowX = 2*waX.back() - XY[i].first;\n        nowY = 2*waY.back() - XY[i].second;\n        nowX = ceil(nowX / (2*N-1));\n        nowY = nowY / (2*N-1);\n        sum = 0;\n        a = (upper_bound(X.begin(), X.end(), nowX) - X.begin()) - 1;\n        sum += nowX * (a+1) - waX[a] + (waX.back() - waX[a]) - nowX * (N-a-1);\n        b = (upper_bound(Y.begin(), Y.end(), nowY) - Y.begin()) - 1;\n        sum += nowY * (b+1) - waY[b] + (waY.back() - waY[b]) - nowY * (N-b-1);\n        sum *= 2;\n        sum -= abs(nowX - XY[i].first);\n        sum -= abs(nowY - XY[i].second);\n        if(sum < ans || (sum == ans && tmp.first > nowX) || (sum == ans && tmp.first == nowX && tmp.second > nowY)){\n            ans = sum;\n            tmp = MP(nowX, nowY);\n        }\n\n        nowX = 2*waX.back() - XY[i].first;\n        nowY = 2*waY.back() - XY[i].second;\n        nowX = nowX / (2*N-1);\n        nowY = ceil(nowY / (2*N-1));\n        sum = 0;\n        a = (upper_bound(X.begin(), X.end(), nowX) - X.begin()) - 1;\n        sum += nowX * (a+1) - waX[a] + (waX.back() - waX[a]) - nowX * (N-a-1);\n        b = (upper_bound(Y.begin(), Y.end(), nowY) - Y.begin()) - 1;\n        sum += nowY * (b+1) - waY[b] + (waY.back() - waY[b]) - nowY * (N-b-1);\n        sum *= 2;\n        sum -= abs(nowX - XY[i].first);\n        sum -= abs(nowY - XY[i].second);\n        if(sum < ans || (sum == ans && tmp.first > nowX) || (sum == ans && tmp.first == nowX && tmp.second > nowY)){\n            ans = sum;\n            tmp = MP(nowX, nowY);\n        }\n\n        nowX = 2*waX.back() - XY[i].first;\n        nowY = 2*waY.back() - XY[i].second;\n        nowX = ceil(nowX / (2*N-1));\n        nowY = ceil(nowY / (2*N-1));\n        sum = 0;\n        a = (upper_bound(X.begin(), X.end(), nowX) - X.begin()) - 1;\n        sum += nowX * (a+1) - waX[a] + (waX.back() - waX[a]) - nowX * (N-a-1);\n        b = (upper_bound(Y.begin(), Y.end(), nowY) - Y.begin()) - 1;\n        sum += nowY * (b+1) - waY[b] + (waY.back() - waY[b]) - nowY * (N-b-1);\n        sum *= 2;\n        sum -= abs(nowX - XY[i].first);\n        sum -= abs(nowY - XY[i].second);\n        if(sum < ans || (sum == ans && tmp.first > nowX) || (sum == ans && tmp.first == nowX && tmp.second > nowY)){\n            ans = sum;\n            tmp = MP(nowX, nowY);\n        }\n    }\n    cout << ans << endl;\n    cout << tmp.first << \" \" << tmp.second << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\n\nvector<long long> SX; // accumulation sum X\nvector<long long> SY; // accumulation sum Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nlong long sumx(int l, int r)\n{\n\treturn SX[r] - SX[l];\n}\n\nlong long sumy(int l, int r)\n{\n\treturn SY[r] - SY[l];\n}\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Accumulation ------ //\n\n\tSX.push_back(0);\n\tSY.push_back(0);\n\n\tfor (int i = 0; i < N; i++) SX.push_back(SX[i] + X[i]);\n\tfor (int i = 0; i < N; i++) SY.push_back(SY[i] + Y[i]);\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tint ptrl = lower_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\t\tint ptrr = upper_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\n\t\tlong long suml = UX[i] * ptrl - sumx(0, ptrl);\n\t\tlong long sumr = sumx(ptrr, N) - UX[i] * (N - ptrr);\n\n\t\tDX.push_back(sumr - suml);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tint ptrl = lower_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\t\tint ptrr = upper_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\n\t\tlong long suml = 1LL * UY[i] * ptrl - sumy(0, ptrl);\n\t\tlong long sumr = 1LL * sumy(ptrr, N) - UY[i] * (N - ptrr);\n\n\t\tDY.push_back(sumr - suml);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\nconst int MAX = 100100;\n\nlong long n, m;\nint h;\n\nlong long ix[MAX], x[MAX], iy[MAX], y[MAX];\n\nint main() {\n    while (cin >> n >> m >> h) {\n        for (int i = 0; i < h; ++i) {\n            cin >> ix[i] >> iy[i];\n            x[i] = ix[i], y[i] = iy[i];\n        }\n        sort(x, x+h);\n        sort(y, y+h);\n        \n        long long vrx[3] = {x[h/2-1], x[h/2], x[h/2+1]};\n        long long vry[3] = {y[h/2-1], y[h/2], y[h/2+1]};\n        \n        long long res = 1LL<<61;\n        int arx = -1, ary = -1;\n        for (int t1 = 0; t1 < 3; ++t1) {\n            for (int t2 = 0; t2 < 3; ++t2) {\n                long long rx = vrx[t1], ry = vry[t2]; \n                long long tmp = 0;\n                vector<long long> vec(h);\n                for (int i = 0; i < h; ++i) {\n                    vec[i] = abs(ix[i] - rx) + abs(iy[i] - ry);\n                    tmp += vec[i];\n                }\n                long long Max = -1;\n                for (int i = 0; i < h; ++i) chmax(Max, vec[i]);\n        \n                tmp *= 2;\n                tmp -= Max;\n                \n                if (chmin(res, tmp)) {\n                    arx = rx, ary = ry;\n                }\n            }\n        }\n        \n        cout << res << endl;\n        cout << arx << \" \" << ary << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#define In_(x) scanf(\"%lld\",&(x))\n\nusing int64 = long long;\nint64 w, h;\nint64 n;\nint64 x[123456], y[123456];\nvector<pair<int64, int64>>point;\n\nint64 arx, ary, arw, arh;\n\nint64 ans = 0;\npair<int64, int64> diff()\n{\n\tdouble centx, centy;\n\tcentx = arx + arw / 2.0;\n\tcenty = ary + arh / 2.0;\n\tint64 dist = 0;\n\tpair<int64, int64>ret;\n\tfor (auto thp : point)\n\t{\n\t\tint64 cand = 0;\n\t\tif (thp.first < centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t}\n\t\t}\n\t\telse if (thp.first < centx && thp.second >= centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t}\n\t\t}\n\t\telse if (thp.first >= centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary);\n\t\t\t}\n\t\t}\n\t}\n\tans -= dist;\n\treturn ret;\n}\n\nint main(void)\n{\n\tIn_(w);In_(h);\n\tIn_(n);\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tIn_(x[i]); In_(y[i]);\n\t\tpoint.emplace_back(x[i],y[i]);\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\tif (n % 2)\n\t{\n\t\t//odd\n\t\tarx = x[n / 2];\n\t\tary = y[n / 2];\n\t\tarw = arh = 0;\n\t}\n\telse\n\t{\n\t\t//even\n\t\tarx = x[n / 2 - 1];\n\t\tary = y[n / 2 - 1];\n\t\tarw = x[n / 2] - arx;\n\t\tarh = x[n / 2] - ary;\n\t}\n\tauto pp = diff();\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tans += abs(x[i] - pp.first) * 2;\n\t\tans += abs(y[i] - pp.second) * 2;\n\t}\n\tprintf(\"%lld\\n%lld %lld\", ans, pp.first, pp.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#define In_(x) scanf(\"%lld\",&(x))\n\nusing int64 = long long;\nint64 w, h;\nint64 n;\nint64 x[123456], y[123456];\nvector<pair<int64, int64>>point;\n\nint64 arx, ary, arw, arh;\n\nint64 ans = 0;\npair<int64, int64> diff()\n{\n\tdouble centx, centy;\n\tcentx = arx + arw / 2.0;\n\tcenty = ary + arh / 2.0;\n\tint64 dist = 0;\n\tpair<int64, int64>ret;\n\tfor (auto thp : point)\n\t{\n\t\tint64 cand = 0;\n\t\tif (thp.first < centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx + arw, ary + arh))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (thp.first < centx && thp.second >= centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx + arw, ary))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (thp.first >= centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx, ary + arh))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx, ary))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx, ary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans -= dist;\n\treturn ret;\n}\n\nint main(void)\n{\n\tIn_(w);In_(h);\n\tIn_(n);\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tIn_(x[i]); In_(y[i]);\n\t\tpoint.emplace_back(x[i],y[i]);\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\tif (n % 2)\n\t{\n\t\t//odd\n\t\tarx = x[n / 2];\n\t\tary = y[n / 2];\n\t\tarw = arh = 0;\n\t}\n\telse\n\t{\n\t\t//even\n\t\tarx = x[n / 2 - 1];\n\t\tary = y[n / 2 - 1];\n\t\tarw = x[n / 2] - arx;\n\t\tarh = y[n / 2] - ary;\n\t}\n\tauto pp = diff();\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tans += abs(x[i] - pp.first) * 2;\n\t\tans += abs(y[i] - pp.second) * 2;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, pp.first, pp.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(x,cx+n);\n sort(y,cy+n);\n ll mx[2],my[2];\n mx[0]=cx[(n-1)>>1];\n mx[1]=cx[(n+1)>>1];\n my[0]=cy[(n-1)>>1];\n my[1]=cy[(n+1)>>1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<string.h>\n#include<vector>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<string>\n#include<stack>\n#include<limits.h>\n#define int long long\n#define P pair<int,int>\nusing namespace std;\n\nP a[100000];\nint b[100000], c[100000];\nint dis = LLONG_MAX;\nP ans = { LLONG_MAX,LLONG_MAX };\nP w;//x??§?¨???????\nP x;//x??§?¨?????????¢\nP y;//y??§?¨???????\nP z;//y??§?¨?????????¢\nsigned main() {\n\tint n; cin >> n >> n >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tsort(b, b + n); sort(c, c + n);\n\tif (n & 1) {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t}\n\telse {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\tw.second = b[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2 - 1]) * 2;\n\t\t}\n\t\tx.second = k;\n\t\tk = 0;\n\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t\tk = 0;\n\n\t\ty.second = c[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2 - 1]) * 2;\n\t\t}\n\t\tz.second = k;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tdis = min(dis, l + r);\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tif (dis == l + r) {\n\t\t\tif (n % 2 == 0 && x.first - abs(w.first - b[i])!=l) {\n\t\t\t\tans.first = min(ans.first, w.second);\n\t\t}\n\t\t\telse {\n\t\t\t\tans.first = min(ans.first, w.first);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tif (dis == l + r) {\n\t\t\tif (n % 2 == 0 && x.first - abs(w.first - b[i]) != l) {\n\t\t\t\tans.first = min(ans.first, w.second);\n\t\t\t\tif (w.second == ans.first) {\n\t\t\t\t\tif (n % 2 == 0 && z.first - abs(y.first - c[i]) != r) {\n\t\t\t\t\t\tans.second = min(ans.second, y.second);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans.second = min(ans.second, y.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.first = min(ans.first, w.first);\n\t\t\t\tif (w.first == ans.first) {\n\t\t\t\t\tif (n % 2 == 0 && z.first - abs(y.first - c[i]) != r) {\n\t\t\t\t\t\tans.second = min(ans.second, y.second);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans.second = min(ans.second, y.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis << endl;\n\tcout << ans.first << \" \" << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1000000000000000;\n\nint main(){\n  int w,h,n;\n  scanf(\"%d%d%d\",&w,&h,&n);\n  int x[n],y[n],sx[n],sy[n];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    sx[i] = x[i], sy[i] = y[i];\n  }\n  sort(sx,sx+n);\n  sort(sy,sy+n);\n  int xx[] = {sx[(n-1)/2],sx[(n-1)/2+1],sx[(n-1)/2],sx[(n-1)/2+1]};\n  int yy[] = {sy[(n-1)/2],sy[(n-1)/2+1],sy[(n-1)/2+1],sy[(n-1)/2]};\n  ll ans = INF;\n  int xxx,yyy;\n  for(int jugontyan=0;jugontyan<4;jugontyan++){\n    int dekai = 0;\n    ll t = 0;\n    int px = xx[jugontyan], py = yy[jugontyan];\n    for(int i=0;i<n;i++){\n      if(dekai<abs(x[i]-px)+abs(y[i]-py)) dekai = abs(x[i]-px) + abs(y[i]-py);\n      t += abs(x[i]-px) + abs(y[i]-py);\n    }\n    t = t * 2 - dekai;\n    if(ans>t){\n      ans = t;\n      xxx = px, yyy = py;\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",ans,xxx,yyy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nvector<pair<int, int> > P;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\n\t\tP.push_back(make_pair(X[i], Y[i]));\n\t}\n\n\tsort(P.begin(), P.end());\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tX[i] = P[i].first;\n\t\tY[i] = P[i].second;\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; int maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = X[j];\n\t\t\t\ty = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define N 1025\n#define ln 1e16\n#define oo 111539786\n#define Pa pair < int, int >\n#define Pi pair < int, Pa >\n\nusing namespace std;\n\nll ans = ln, SumX[N], SumY[N];\nint n, X[N], Y[N], w, h, posX, posY;\nPa a[N];\n\nvoid Get_ans(int x, int y)\n{\n    ll Sum = 0, Max = -ln;\n    for(int i=1; i<=n; i++)\n    {\n        Sum += (abs(x - a[i].f) + abs(y - a[i].s)) * 2;\n        Max = max(Max, (ll)abs(x - a[i].f) + abs(y - a[i].s));\n    }\n    Sum -= Max;\n    if(Sum < ans)\n    {\n        ans = Sum;\n        posX = x;\n        posY = y;\n    }\n}\n\nint main()\n{\n    //filein(\"SANTA.inp\");    fileout(\"SANTA.out\");\n    cin >> w >> h >> n;\n    for(int i=1; i<=n; i++)\n    {\n        cin >> X[i] >> Y[i];\n        a[i] = mp(X[i], Y[i]);\n    }\n    sort(X+1, X+n+1);\n    sort(Y+1, Y+n+1);\n    for(int i=1; i<=n; i++)\n    {\n        SumX[i] = SumX[i-1] + X[i];\n        SumY[i] = SumY[i-1] + Y[i];\n    }\n    Get_ans(X[(n+1)/2], Y[(n+1)/2]);\n    if(n % 2 == 0)\n        Get_ans(X[n/2+1], Y[n/2+1]);\n    cout << ans << endl;\n    cout << posX << \" \" << posY << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e9\nP house[2][MAX_N + 1];\nint main(){\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx, ansy;\n\tP save, save2;\t\n\tcin >> w >> h >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[1][i] = make_pair(b, a);\n\t}\n\t\n\tfor(int j = 0; j < n; j++){\n\t\tsum = 0;\n\t\tmid = (n - 1) / 2;\n\t\tsort(house[0], house[0] + n);\n\t\tsort(house[1], house[1] + n);\n\t\tsave = house[0][j];\n\t\tsave2 = house[1][j];\n\t\thouse[0][j] = house[0][n - 1];\n\t\thouse[0][n - 1] = save;\n\t\thouse[1][j] = house[1][n - 1];\n\t\thouse[1][n - 1] = save2;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tma = max(ma, abs(save.F - x) + abs(save.S - y));\t\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tsum *=2;\n\t\tsum -= ma;\n\t\tif(time > sum){\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\thouse[0][n - 1] = save;\n\t\thouse[1][n - 1] = save2;\n\t}\n\tcout << time << endl;\n\tcout << ansx <<' '<< ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=5;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   cout << \"brute force \" << endl;\n   cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t   }\n\t }\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    cout <<\"mxs \";rep(i,mxs.size())cout <<x[ mxs[i]].second <<\" \" ;cout << endl;\n    cout <<\"mys \";rep(i,mys.size())cout <<y[ mys[i]].second <<\" \" ;cout << endl;\n    //bf(in,ans,ansy,ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\ntypedef double ld;\n#define X first\n#define Y second\n#define mk make_pair\n#define pb push_back\n#define Rep(i, n) for(int i = 0; i < int(n); i ++)\n#define Rep1(i, n) for(int i = 1; i <= int(n); i ++)\n#define all(x) (x).begin(), (x).end()\nconst int MOD = (int) 1e9 + 7;\nconst ll base =  31;\nvoid MAIN();\nint main(){\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios:: sync_with_stdio(false); cin.tie(0);\n    MAIN();\n    return 0;\n}\n////////////////////////////////////////////////////////////////////////\n\nconst int N = (int) 1e5 + 32;\n\nint w, h, n, x[N], y[N];\nvector <pair <int, ll> > P, Q;\n\n\nvoid cal(int* a, vector <pair <int, ll> > &V){\n    sort(a, a+n);\n    ll sum = 0;\n    Rep(i, n) sum += a[i] - a[0];\n    Rep(i, n){\n        if(abs(i - n/2) <= 1) V.pb(mk(a[i], sum*2));\n        if(i + 1 < n){\n            sum += 1LL*(a[i+1] - a[i]) * (i + 1);\n            sum -= 1LL*(a[i+1] - a[i]) * (n - i - 1);\n        }\n    }\n}\n\nii a[N];\n\nvoid MAIN(){\n    cin >> w >> h >> n;\n    Rep(i, n) cin >> x[i] >> y[i];\n    Rep(i, n) a[i] = ii(x[i], y[i]);\n    cal(x, P); cal(y, Q);\n    ll ans = 1LL << 60;\n    int ax, ay;\n\n    Rep(i, n){\n        Rep(u, P.size()) Rep(v, Q.size()){\n            ll sum = P[u].Y + Q[v].Y;\n            sum -= abs(P[u].X - a[i].X) + abs(Q[v].X - a[i].Y);\n            if(sum < ans){\n                ans = sum;\n                ax = P[u].X;\n                ay = Q[v].X;\n            }\n        }\n    }\n    cout << ans << endl << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nstruct house\n{\n\tint x,y;\n\thouse(){}\n\thouse(int x,int y):x(x),y(y){}\n}h[100005];\nstruct comp_x\n{\n\tbool operator()(const house& a, const house& b)const\n\t{\n\t\tif(a.x!=b.x) return a.x<b.x;\n\t\treturn a.y<b.y;\n\t}\n};\nstruct comp_y\n{\n\tbool operator()(const house& a, const house& b)const\n\t{\n\t\tif(a.y!=b.y) return a.y<b.y;\n\t\treturn a.x<b.x;\n\t}\n};\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tint hh,w,n; scanf(\"%d %d\",&hh,&w); scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d\",&h[i].x,&h[i].y);\n\t}\n\tset<int>se1,se2;\n\tsort(h,h+n,comp_x());\n\tse1.insert(h[(n-2)/2].x);\n\tse1.insert(h[n/2].x);\n\tsort(h,h+n,comp_y());\n\tse2.insert(h[(n-2)/2].y);\n\tse2.insert(h[n/2].y);\n\tll ret=1e15;int px=INF,py=INF;\n\tfor(set<int>::iterator it=se1.begin();it!=se1.end();++it)\n\t{\n\t\tfor(set<int>::iterator it2=se2.begin();it2!=se2.end();++it2)\n\t\t{\n\t\t\tint X=*it; int Y=*it2; //cout << X << \" \" << Y << endl;\n\t\t\tll val=0,gen=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tval+=2LL*(abs(h[i].x-X)+abs(h[i].y-Y));\n\t\t\t\tgen=max(gen,1LL*(abs(h[i].x-X)+abs(h[i].y-Y)));\n\t\t\t}\n\t\t\tif(ret>val-gen || (ret==val-gen && ((px>X)||(px==X&&py>Y))))\n\t\t\t{\n\t\t\t\tret=val-gen;\n\t\t\t\tpx=X;py=Y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,px,py);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=5;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yÀWÌ³kAÅ¬lßÄ¨­\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //úlðvZ\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   cout << \"brute force \" << endl;\n   cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//XRAAÀWÌyA\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //ð­\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t   }\n\t }\n      }\n\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    cout <<\"mxs \";rep(i,mxs.size())cout <<x[ mxs[i]].second <<\" \" ;cout << endl;\n    cout <<\"mys \";rep(i,mys.size())cout <<y[ mys[i]].second <<\" \" ;cout << endl;\n    //bf(in,ans,ansy,ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX;\nvector<long long> EY;\nvector<long long> UX;\nvector<long long> UY;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\tlong long ret1 = 999999999999999999LL, ret2 = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0; long long maxs = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += 2LL * abs(X[j] - UX[i]);\n\n\t\t\tmaxs = max(maxs, abs(X[j] - UX[i]));\n\t\t}\n\n\t\tsum -= maxs;\n\n\t\tif (sum < ret1)\n\t\t{\n\t\t\tret1 = sum;\n\n\t\t\tx = UX[i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0; long long maxs = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += 2LL * abs(Y[j] - UY[i]);\n\n\t\t\tmaxs = max(maxs, abs(Y[j] - UY[i]));\n\t\t}\n\n\t\tsum -= maxs;\n\n\t\tif (sum < ret2)\n\t\t{\n\t\t\tret2 = sum;\n\n\t\t\ty = UY[i];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret1 + ret2);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint idx = (N-1)/2;\n\tll ans = inf;\n\tint ax = inf, ay = inf;\n\tvector<int> kx, ky;\n\tfor (int d = -2; d <= 2; ++d) {\n\t\tif (idx+d < 0 || idx+d >= N) continue;\n\t\tkx.pb(X[idx+d]);\n\t\tky.pb(Y[idx+d]);\n\t}\n\tREP(u, kx.size()) REP(w, ky.size()) {\n\t\tint sx = kx[u], sy = ky[w];\n\t\tvector<ll> a;\n\t\tREP(i, N) {\n\t\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t\t}\n\t\tsort( ALL(a) );\n\t\tll sum = a[N-1];\n\t\tREP(i, N-1) {\n\t\t\tsum += a[i]*2;\n\t\t}\n\t\tif (sum < ans || (sum <= ans && P(sx, sy) <= P(ax, ay))) {\n\t\t\tans = sum;\n\t\t\ttie(ax, ay) = P(sx, sy);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#define In_(x) scanf(\"%lld\",&(x))\n\nusing int64 = long long;\nint64 w, h;\nint64 n;\nint64 x[123456], y[123456];\nvector<pair<int64, int64>>point;\n\nint64 arx, ary, arw, arh;\n\nint64 ans = 0;\npair<int64, int64> diff()\n{\n\tdouble centx, centy;\n\tcentx = arx + arw / 2.0;\n\tcenty = ary + arh / 2.0;\n\tint64 dist = 0;\n\tpair<int64, int64>ret;\n\tfor (auto thp : point)\n\t{\n\t\tint64 cand = 0;\n\t\tif (thp.first < centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t}\n\t\t}\n\t\telse if (thp.first < centx && thp.second >= centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t}\n\t\t}\n\t\telse if (thp.first >= centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary);\n\t\t\t}\n\t\t}\n\t}\n\tans -= dist;\n\treturn ret;\n}\n\nint main(void)\n{\n\tIn_(w);In_(h);\n\tIn_(n);\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tIn_(x[i]); In_(y[i]);\n\t\tpoint.emplace_back(x[i],y[i]);\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\tif (n % 2)\n\t{\n\t\t//odd\n\t\tarx = x[n / 2];\n\t\tary = y[n / 2];\n\t\tarw = arh = 0;\n\t}\n\telse\n\t{\n\t\t//even\n\t\tarx = x[n / 2 - 1];\n\t\tary = y[n / 2 - 1];\n\t\tarw = x[n / 2] - arx;\n\t\tarh = x[n / 2] - ary;\n\t}\n\tauto pp = diff();\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tans += abs(x[i] - pp.first) * 2;\n\t\tans += abs(y[i] - pp.second) * 2;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, pp.first, pp.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define INF (1LL<<60)\n\ntypedef long long ll;\n\nll W,H,N;\nll X[100005],Y[100005];\nvector<int> sX,sY;\nll maxd;\nll sx[2],sy[2];\n\nll dist(ll ax, ll bx, ll ay, ll by){\n  ll ret = abs(ax-bx)+abs(ay-by);\n  maxd = max(maxd, ret);\n  return 2*ret;\n}\n\nint main(){\n  scanf(\"%lld%lld%lld\",&W,&H,&N);\n  rep(i,N) scanf(\"%lld%lld\", &X[i], &Y[i]);\n\n  rep(i,N){\n    sX.push_back(X[i]);\n    sY.push_back(Y[i]);\n  }\n  sort(sX.begin(), sX.end());\n  sort(sY.begin(), sY.end());\n  //  sX.erase(unique(sX.begin(), sX.end()), sX.end());\n  //  sY.erase(unique(sY.begin(), sY.end()), sY.end());\n\n  sx[0] = sX[(sX.size()-1)/2]; sx[1] = sX[(sX.size()+1)/2];\n  sy[0] = sY[(sY.size()-1)/2]; sy[1] = sY[(sY.size()+1)/2];\n  ll res=INF, rx, ry;\n  rep(i,4){\n    int x = sx[i/2], y = sy[i%2];\n    //    cout << x << \" \" << y << endl;\n    int sum = 0; maxd = 0;\n    rep(j,N) sum += dist(x, X[j], y, Y[j]);\n    sum -= maxd;\n    if(sum < res){\n      res = sum;\n      rx = x;\n      ry = y;\n    }\n  }\n  \n  /*  ll resX=W, distX=INF, resY=H, distY=INF;\n  rep(k,N){\n    ll mY=W, mX=H, mdX=INF, mdY=INF;\n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(X[i]-X[j])*2;\n      dist -= abs(X[i]-X[k]);\n      if(dist < mdX){\n\tmdX = dist;\n\tmX = X[i];\n      }\n    }\n    \n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(Y[i]-Y[j])*2;\n      dist -= abs(Y[i]-Y[k]);\n\n      if(dist < mdY){\n\tmdY = dist;\n\tmY = Y[i];\n      }\n    }\n    if(distX+distY > mdX+mdY){\n      distX = mdX, distY = mdY;\n      resY = mY, resX = mX;\n    }else if(distX+distY == mdX+mdY && mX < resX){\n      resY = mY;\n      resX = mX;\n    }else if(distX+distY == mdX+mdY && mX == resX && mY < resY){\n      resY = mY;\n      resX = mX;\n    }\n    }*/\n\n  printf(\"%lld\\n%lld %lld\\n\", res, rx, ry);\n  //  printf(\"%lld\\n\", distX+distY);\n  //  printf(\"%lld %lld\\n\", resX, resY);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  printf(\"\\n\");\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2 - 1];\n      ori.y = y[(n + 1) / 2 - 1];\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer <=  wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2 - 1])\n\t    {\n\t      s.x = x[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  if(ww[i].y > y[n / 2 - 1])\n\t    {\n\t      s.y = y[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      ori = s;\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(s.x < ori.x || (s.x == ori.x && s.y < ori.y))\n\t\t{\n\t\t  ori = s;\n\t\t  longer = wkyori(s,ww[i]);\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i]) * 2));\n\t}\n      else\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i])));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst long long int INF=1000000000;\nlong long int dx[4]={0,0,-1,-1};\nlong long int dy[4]={0,-1,0,-1};\n\nint main(){\n\tlong long int w,h;\n\tcin >> w >> h;\n\tlong long int n;\n\tcin >> n;\n\tvector<long long int> vx(n);\n\tvector<long long int> vy(n);\n\tvector<long long int> hoge(n);\n\tvector<long long int> piyo(n);\n\tfor(long long int i=0; i<n; ++i){\n\t\tcin >> vx[i] >> vy[i];\n\t\thoge[i]=vx[i];\n\t\tpiyo[i]=vy[i];\n\t}\n\tlong long int ans=0;\n\tlong long int ans_x,ans_y;\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tif(n%2!=0){\n\t\tans_x=vx[n/2];\n\t\tans_y=vy[n/2];\n\t\tlong long int maxd;\n\t\tmaxd=0;\n\t\tfor(long long int i=0; i<n; ++i){\n\t\t\tans+=2*abs(vx[n/2]-hoge[i])+2*abs(vy[n/2]-piyo[i]);\n\t\t\tmaxd=max(maxd,abs(vx[n/2]-hoge[i])+abs(vy[n/2]-piyo[i]));\t\t\n\t\t}\n\t\tans-=maxd;\n\t} else {\n\t\tlong long int tmp[4];\n\t\tlong long int maxd[4];\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\ttmp[i]=0;\n\t\t\tmaxd[i]=0;\n\t\t}\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\tfor(long long int j=0; j<n; ++j){\n\t\t\t\ttmp[i]+=2*abs(vx[n/2+dx[i]]-hoge[j])+2*abs(vy[n/2+dy[i]]-piyo[j]);\n\t\t\t\t/*\n\t\t\t\tif(i==3&&maxd[i]<abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j])){\n\t\t\t\t\tcout << vx[j] << \" \" << vy[j] << \" \" << abs(vx[n/2+dx[i]]-vx[j])+abs(vy[n/2+dy[i]]-vy[j]) << endl;\n\t\t\t\t}*/\n\t\t\t\tmaxd[i]=max(maxd[i],abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j]));\n\t\t\t}\n\t\t}\n\t\tans=INF*100000;\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\t//cout << vx[n/2+dx[i]] << \" \" << vy[n/2+dy[i]]<< \" \" << tmp[i]-maxd[i] << \" \" << tmp[i] << \" \" << maxd[i] << endl;\n\t\t\tif(ans>=tmp[i]-maxd[i]&&n/2+dx[i]>=0&&n/2+dy[i]>=0){\n\t\t\t\tans=tmp[i]-maxd[i];\n\t\t\t\tans_x=vx[n/2+dx[i]];\n\t\t\t\tans_y=vy[n/2+dy[i]];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}\n\n//01234567"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint W,H,N;\nll x[100100],y[100100];\nll p[2],q[2];\nll cal(ll s,ll t)\n{\n\tll m=0;\n\tll sum=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tsum+=2ll*(llabs(x[i]-s)+llabs(y[i]-t));\n\t\tm=max(m,llabs(x[i]-s)+llabs(y[i]-t));\n\t}\n\treturn sum-m;\n}\nint main()\n{\n\tcin >> W >> H;\n\tcin >> N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t}\n\tsort(x,x+N);\n\tp[0]=x[(N+1)/2],p[1]=x[(N-1)/2];\n\tq[0]=y[(N+1)/2],q[1]=x[(N-1)/2];\n\tint ansx,ansy;\n\tll ans=1000000000000000000ll;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll k=cal(p[i/2],q[i%2]);\n\t\tif(ans>k)\n\t\t{\n\t\t\tansx=p[i/2];\n\t\t\tansy=q[i%2];\n\t\t\tans=k;\n\t\t}\n\t\tif(ans==k)\n\t\t{\n\t\t\tif(ansx>p[i/2])\n\t\t\t{\n\t\t\t\tansx=p[i/2];\n\t\t\t\tansy=q[i%2];\n\t\t\t}\n\t\t\telse if(ansx==p[i/2]&&ansy>q[i%2])\n\t\t\t{\n\t\t\t\tansy=q[i%2];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ansx << ' ' << ansy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    int x;\n    int y;\n    p(){};\n    P(int p1,int p2){\n        x=p1;\n        y=p2;\n    }\n};\n\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<P> pos;\n\nint dist(int x,int y){\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].x);\n        int disy=abs(y-pos[i].y);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(P(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tint xi = N / 2;\n\tint yi = N / 2;\n\n\tVV dists(9, V(N));\n\trep(i, N) rep(j, 3) rep(k, 3) {\n\t\tdists[j * 3 + k][i] = abs(v[i].first - ws[xi + j - 1]) + abs(v[i].second - hs[yi + k - 1]);\n\t}\n\trep(i, 9) sort(all(dists[i]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tint sum = accumulate(all(dists[i]), 0ll) * 2 - dists[i].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[xi + i / 3 - 1];\n\t\t\typos = hs[yi + i % 3 - 1];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N=100001;\nint H,W;\nint N;\nint XS[MAX_N];\nint YS[MAX_N];\nint curLast;\nvector<int> xnums;\nvector<int> ynums;\n// ¶a\nll leftDistSumX[MAX_N];\nll leftDistSumY[MAX_N];\n// Ea\nll rightDistSumX[MAX_N];\nll rightDistSumY[MAX_N];\n\nll check(ll s,bool isX=true){\n    ll sum=0;\n    // ÀWsªÇÌ_ÆÇÌ_ÌÔÉ é©ð©Â¯é\n    // »Ìîñð³ÉAÚ®ÊðvZ\n    if(isX){\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(xnums.begin(),xnums.end(),s);\n        if(it==xnums.end())sum=leftDistSumX[N-1]+rightDistSumX[N-1]+abs(s-xnums[N-1]);\n        else if(it==xnums.begin())sum=leftDistSumX[0]+rightDistSumX[0]+abs(s-xnums[0]);\n        else{\n            sum=leftDistSumX[it-xnums.begin()]+rightDistSumX[it-xnums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=*it-s;\n                ll leftCnt=it-xnums.begin();\n                ll rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-XS[curLast]);\n    }\n    else{\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(ynums.begin(),ynums.end(),s);\n        if(it==ynums.end())sum=leftDistSumY[N-1]+rightDistSumY[N-1]+abs(s-ynums[N-1]);\n        else if(it==ynums.begin())sum=leftDistSumY[0]+rightDistSumY[0]+abs(s-ynums[0]);\n        else{\n            sum=leftDistSumY[it-ynums.begin()]+rightDistSumY[it-ynums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=-s+*it;\n                ll leftCnt=it-ynums.begin();\n                ll rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-YS[curLast]);\n    }\n    return sum;\n}\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>XS[i]>>YS[i];\n\n    // xûüÌÝÏa\n    for(int i=0;i<N;i++)xnums.push_back(XS[i]);\n    sort(xnums.begin(),xnums.end());\n    ll baseLeftSumX=0;\n    ll baseRightSumX=0;\n    for(int i=1;i<N;i++)baseRightSumX+=abs(xnums[i]-xnums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumX[i]=baseRightSumX;\n        leftDistSumX[i]=baseLeftSumX;\n        if(i!=N-1){\n            baseRightSumX-=abs(xnums[i]-xnums[i+1])*(N-i-1);\n            baseLeftSumX+=abs(xnums[i]-xnums[i+1])*(i+1);\n        }\n    }\n    // yûüÌÝÏa\n    for(int i=0;i<N;i++)ynums.push_back(YS[i]);\n    sort(ynums.begin(),ynums.end());\n    ll baseLeftSumY=0;\n    ll baseRightSumY=0;\n    for(int i=1;i<N;i++)baseRightSumY+=abs(ynums[i]-ynums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumY[i]=baseRightSumY;\n        leftDistSumY[i]=baseLeftSumY;\n        if(i!=N-1){\n            baseRightSumY-=abs(ynums[i]-ynums[i+1])*(N-i-1);\n            baseLeftSumY+=abs(ynums[i]-ynums[i+1])*(i+1);\n        }\n    }\n\n    // Ç±ðÅãÉKêéêÉ·é©Åêí¯\n    ll ret=-1;\n    ll lastX,lastY;\n    ll candX[3],candY[3];\n    for(int lp=0;lp<N;lp++){\n        curLast=lp;\n        // x\n        int cnt=1000;\n        ll ub=1000000000;\n        ll lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1)<check(mid2))ub=mid2;\n            else if(check(mid1)>check(mid2))lb=mid1;\n            else lb=mid1;\n        }\n        candX[0]=lb;\n        candX[1]=lb+1;\n        candX[2]=ub;\n        ll minXVal=-1;\n        ll rx;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candX[i]);\n            if(minXVal==-1||tmp<minXVal){\n                minXVal=tmp;\n                rx=candX[i];\n            }\n        }\n        // y\n        cnt=1000;\n        ub=1000000000;\n        lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1,false)<check(mid2,false))ub=mid2;\n            else if(check(mid1,false)>check(mid2,false))lb=mid1;\n            else lb=mid1;\n        }\n        candY[0]=lb;\n        candY[1]=lb+1;\n        candY[2]=ub;\n        ll minYVal=-1;\n        ll ry;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candY[i],false);\n            if(minYVal==-1||tmp<minYVal){\n                minYVal=tmp;\n                ry=candY[i];\n            }\n        }\n        ll res=minXVal+minYVal;\n        if(ret==-1||res<ret){\n            ret=res;\n            lastX=rx;\n            lastY=ry;\n        }\n        else if(res==ret){\n            if(lastX>rx){\n                lastX=rx;\n                lastY=ry;\n            }\n            else if(lastX==rx){\n                if(lastY>ry){\n                    lastX=rx;\n                    lastY=ry;\n                }\n            }\n        }\n    }\n    std::cout<<ret<<endl;\n    std::cout<<lastX<<\" \"<<lastY<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <set>\n#include <utility>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nstruct Median {\nprivate:\n  multiset<long long> l, r;\n  long long lsum, rsum;\n\n  void balance(){\n    while(r.size() and l.size() and *begin(r) < *rbegin(l)){\n      long long mi = *begin(r);\n      l.insert(mi);\n      lsum += mi;\n      r.erase(begin(r));\n      rsum -= mi;\n    }\n    while(r.size() > l.size()+1){\n      long long mi = *begin(r);\n      l.insert(mi);\n      lsum += mi;\n      r.erase(begin(r));\n      rsum -= mi;\n    }\n    while(l.size() > r.size()){\n      long long ma = *rbegin(l);\n      r.insert(ma);\n      rsum += ma;\n      l.erase(l.find(ma));\n      lsum -= ma;\n    }\n  }\n\npublic:\n  Median() : lsum(0), rsum(0) {}\n\n  void dump(){\n    cerr << \"lsum = \" << lsum << \" : rsum = \" << rsum << endl;\n    for(auto e : l)\n      cerr << e << \" \";\n    cerr << \" | \" ;\n    for(auto e : r)\n      cerr << e << \" \";\n    cerr << endl;\n  }\n\n  void add(long long x){\n    r.insert(x);\n    rsum += x;\n    balance();\n  }\n\n  void erase(long long x){\n    if(l.find(x) != l.end()){\n      auto itr = l.find(x);\n      lsum -= x;\n      l.erase(itr);\n    }else{\n      auto itr = r.find(x);\n      assert(itr != r.end());\n      rsum -= x;\n      r.erase(itr);\n    }\n    balance();\n  }\n\n  long long median(){\n    if((l.size()+r.size())%2)\n      return *begin(r);\n    long long m = *begin(r) + (*rbegin(l));\n    return m/2;\n  }\n\n  long long score(){\n    long long m = median();\n    long long ret = rsum - m*r.size() + m*l.size() - lsum;\n    return ret;\n  }\n};\n\nint main(){\n  int W, H, N;\n  cin >> W >> H >> N;\n  vector<pair<int,int>> V;\n  Median X, Y;\n  for(int i = 0; i < N; ++i){\n    long long x, y;\n    cin >> x >> y;\n    V.emplace_back(x,y);\n    X.add(x);\n    X.add(x);\n    Y.add(y);\n    Y.add(y);\n  }\n  long long ans = 1e18, mx , my;\n  for(auto p : V){\n    long long x, y;\n    tie(x,y) = p;\n    X.erase(x);\n    Y.erase(y);\n\n    long long score = X.score() + Y.score();\n    // cerr << x << \" \" << y << \" \" << score << endl;\n    // cerr << \"! \" << X.score() << \" \" << Y.score() << endl;\n    // cerr << \"? \" << X.median() << \" \" << Y.median() << endl;\n    // X.dump();\n    // Y.dump();\n    if(score < ans){\n      mx = X.median();\n      my = Y.median();\n      ans = score;\n    }else if(score == ans){\n      if(X.median() < mx) mx = X.median(), my = Y.median();\n      else if(X.median() == mx){\n        my = min(my,Y.median());\n      }\n    }\n    X.add(x);\n    Y.add(y);\n  }\n  cout << ans << \"\\n\" << mx << \" \" << my << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,ma = 0,xx,yy;\n\tif(n % 2 == 1){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint d = abs(x[n / 2] - mx[i]) + abs(y[n / 2] - my[i]);\n\t\t\tsum += d;\n\t\t\tma = max(ma,d);\n\t\t}\n\t\tcout << sum * 2 - ma << endl;\n\t\tcout << x[n / 2] << \" \" << y[n / 2] << endl;\n\t}\n\telse{\n\t\tint mas = 1e+9;\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < 2;k++){\n\t\t\t\tsum = 0;\n\t\t\t\tma = 0;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tint d = abs(x[n / 2 - j] - mx[i]) + abs(y[n / 2 - k] - my[i]);\n\t\t\t\t\tsum += d;\n\t\t\t\t\tma = max(ma,d);\n\t\t\t\t}\n\t\t\t\tif(mas > sum * 2 - ma){\n\t\t\t\t\tmas = min(mas,sum * 2 - ma);\n\t\t\t\t\txx = x[n / 2 - j];\n\t\t\t\t\tyy = y[n / 2 - k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mas << endl;\n\t\tcout << xx << \" \" << yy << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int h,w,n;\n  int x[100100],y[100100];\n  int wx[100100],wy[100100];\n\n  scanf(\"%d%d%d\",&h,&w,&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    wx[i] = x[i]; wy[i] = y[i];\n  }\n\n  sort(wx,wx+n); sort(wy,wy+n);\n\n  int X = wx[(n-1)/2], Y = wy[(n-1)/2];\n  long long maxv = 0, ans = 0;\n  for(int i=0;i<n;i++){\n    long long dx = abs(X-x[i]), dy = abs(Y-y[i]);\n    ans += dx + dy;\n    maxv = max(maxv, dx+dy);\n  }\n  cout << 2*ans - maxv << endl;\n  cout << X << \" \" << Y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<map>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n#define F first\n#define S second\n#define INF (LLONG_MAX)\n#define ALL(a) (a).begin(),(a).end()\nint W,H,N;\nvector<P> ps[2];\nint dx[4];\nint dy[4];\ninline ll ab(ll a){ return a>0?a:-a; }\nll calc(ll x,ll y){\n  //  printf(\"%lld %lld\\n\",x,y);\n  ll ret = 0;\n  ll tmax = 0;\n  for(int i=0;i<N;i++){\n    ll tmp = (ab((ll)ps[0][i].F-x)+ab((ll)ps[0][i].S-y));\n    tmax = max(tmp,tmax);\n    ret += tmp*2;\n  }\n  //    printf(\"%lld\\n\",ret-tmax);\n  return ret-tmax;\n}\nvoid make_p(){\n  int h = N/2;\n  for(int i=0;i<4;i++){\n    if(i%2)\n      dx[i] = ps[0][h].F;\n    else\n      dx[i] = ps[0][h-1].F;\n    if(i<2)\n      dy[i] = ps[1][h].F;\n    else\n      dy[i] = ps[1][h-1].F;\n  }\n}\nPP solve(int id){\n  int h = N/2;\n  if(id==0)\n    return min(PP(calc(id,h+1),P(ps[id][h+1].F,ps[id][h+1].S)),\n\t       PP(calc(id,h),P(ps[id][h].F,ps[id][h].S)));\n  else\n    return min(PP(calc(id,h+1),P(ps[id][h+1].S,ps[id][h+1].F)),\n\t       PP(calc(id,h),P(ps[id][h].S,ps[id][h].F)));\n\t\t\t    \n}\nint main(){\n  scanf(\"%d %d\",&W,&H);\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    ps[0].push_back( P(x,y) );\n    ps[1].push_back( P(y,x) );\n  }\n  if(N==1){\n    puts(\"0\");\n    printf(\"%d %d\\n\",ps[0][0].F,ps[0][0].S);\n    return 0;\n  }\n  sort(ALL(ps[0]));\n  sort(ALL(ps[1]));\n  make_p();\n  PP res = PP(INF,P(0,0));\n  for(int i=0;i<4;i++){\n      int nx = dx[i], ny = dy[i];\n      res = min(res,PP(calc((ll)nx,(ll)ny),P(nx,ny)));\n  }\n  printf(\"%lld\\n%d %d\\n\",res.F,res.S.F,res.S.S);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define INF (1LL<<60)\n\ntypedef long long ll;\n\nint W,H,N;\nint X[100005],Y[100005];\n\nint main(){\n  scanf(\"%d%d%d\",&W,&H,&N);\n  rep(i,N) scanf(\"%d%d\", &X[i], &Y[i]);\n\n  ll resX=W, distX=INF, resY=H, distY=INF;\n  rep(k,N){\n    ll mY=W, mX=H, mdX=INF, mdY=INF;;\n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(X[i]-X[j])*2;\n      dist -= abs(X[i]-X[k]);\n      if(dist < mdX){\n\tmdX = dist;\n\tmX = X[i];\n      }\n    }\n    \n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(Y[i]-Y[j])*2;\n      dist -= abs(Y[i]-Y[k]);\n\n      if(dist < mdY){\n\tmdY = dist;\n\tmY = Y[i];\n      }\n    }\n    if(distX+distY > mdX+mdY){\n      distX = mdX, distY = mdY;\n      resY = mY, resX = mX;\n    }else if(distX+distY == mdX+mdY && mX < resX){\n      resY = mY;\n      resX = mX;\n    }else if(distX+distY == mdX+mdY && mX == resX && mY < resY){\n      resY = mY;\n      resX = mX;\n    }\n  }\n\n  printf(\"%d\\n\", distX+distY);\n  printf(\"%d %d\\n\", resX, resY);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\nstruct Pos{\n\tint x,y,state;\n};\nvoid Pinst(Pos *a,int N){\n\ta->state = 0;\n}\nint compareX(const void *s1,const void *s2){\n\tint x1 = ((Pos*)s1)->x;\n\tint x2 = ((Pos*)s2)->x;\n\treturn x1 -x2;\n}\nint compareY(const void *s1,const void *s2){\n\tint y1 = ((Pos*)s1)->y;\n\tint y2 = ((Pos*)s2)->y;\n\treturn y1-y2;\n}\nint compare(const void *s1,const void *s2){\n\treturn *(int*)s2-*(int*)s1;\n}\nint w,h,k;\nPos pos[100000];\nint longest[100000];\t//最長候補の番号を入れておく\nint dx[100000];\nint dy[100000];\nint main(){\n\tint i,j,l;\n\tint now,max,min;\n\tlong long shotest = 1000000000000000001;\n\tlong long len;\n\tint sx,sy,scor;\n\tcin >> w >> h >> k;\n\tfor(i = 0;i < k;i++){\n\t\tcin >> pos[i].x >> pos[i].y;\n\t\tdx[i] = pos[i].x;\n\t\tdy[i] = pos[i].y;\n\t}\n\tPinst(pos,k);\n\t//最長候補の割り出し\n\tqsort(pos,k,sizeof(Pos),compareX);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].x;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].x == now;i++){\n\t\t\tif(pos[min].y > pos[i].y)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].y < pos[i].y)\n\t\t\t\tmax = i;\n\t\t}\n\t\tpos[min].state = 1;\n\t\tpos[max].state = 1;\n\t}\n\tqsort(pos,k,sizeof(Pos),compareY);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].y;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].y == now;i++){\n\t\t\tif(pos[min].x > pos[i].x)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].x < pos[i].x)\n\t\t\t\tmax = i;\n\t\t}\n\t\tif(pos[min].state == 1)\n\t\t\tpos[min].state = 2;\n\t\tif(pos[max].state == 1)\n\t\t\tpos[max].state = 2;\n\t}\n\tint corsole = 0;\n\tfor(i = 0;i < k;i++){\n\t\tif(pos[i].state == 2){\n\t\t\tlongest[corsole] = i;\n\t\t\tcorsole++;\n\t\t}\n\t}\n\t//探索(dx,dyリスト内からスタート地点を決め、実際に距離を調べる。)\n\t//shotestが全体の中で最少となったときの、sx,syの組をこたえたい\n\t//(しかも、sxはその中でも最少にするとか…)で、ソートしようかと思う\n\tqsort(dx,k,sizeof(int),compare);\n\tqsort(dy,k,sizeof(int),compare);\n\tfor(i = 0;i < k;i++){\n\t\tif(dx[i] == 0)\n\t\t\tcontinue;\n\t\tfor(j = 0;j < k;j++){\n\t\t\tif(dy[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tlen = 0;\n\t\t\tfor(l = 0;l < k;l++){\n\t\t\t\tif(dx[i] != dx[l])\n\t\t\t\t\tlen += abs(dx[i]-dx[l])*2;\n\t\t\t\tif(dy[j] != dy[l])\n\t\t\t\t\tlen += abs(dy[j]-dy[l])*2;\n\t\t\t}\n\t\t\tint t,max;\n\t\t\tmax = 0;\n\t\t\tfor(l = 0;l < corsole;l++){\n\t\t\t\tt = abs(dx[i]-pos[longest[l]].x)+abs(dy[j]-pos[longest[l]].y);\n\t\t\t\tif(max < t)\n\t\t\t\t\tmax = t;\n\t\t\t}\n\t\t\tlen -= max;\n\t\t\tif(shotest >= len){\n\t\t\t\tshotest = len;\n\t\t\t\tsx = dx[i];\n\t\t\t\tsy = dy[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << shotest << endl << sx << \" \" << sy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, cnt, w, h, L, HL,temp, oxy[2][2], *LXY[2], ox, oy, max = 0;\n\tdeque<long long> XY[2];\n\t//freopen(\"18-02.in\",\"r\",stdin);\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tsort( XY[0].begin(), XY[0].end() );\n\tsort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\tcnt = 0;\n\t\t\ttemp = XY[f1][cnt];\n\t\t\tcnt++;\n\t\t\twhile(cnt < HL){\n\t\t\t\twhile(cnt < L && temp == XY[f1][cnt])\n\t\t\t\t\tcnt++;\n\t\t\t\tif(cnt < HL){\n\t\t\t\t\ttemp = XY[f1][cnt];\n\t\t\t\t\t//cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\toxy[0][f1] = XY[f1][cnt-1];\n\t\t\toxy[1][f1] = XY[f1][cnt];\n\t\t}\n\t\t//400k\n\t\tfor(f2 = 0; f2 < 2; f2++){\n\t\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\t//printf(\" %lld %lld\\n\",oxy[f2][0],oxy[f3][1]);\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp * 2;\n\t\t\t\t\tif(sum < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(max == 0 || max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum -= max;\n\t\t\t\t//printf(\"%lld\\n\\n\",sum);\n\t\t\t\tif(sum > 0 && (osum == 0 || osum > sum || osum == sum && ox >= oxy[f2][0] && oy > oxy[f3][1])){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct E {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tint x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad?????§?¨???????2??????????????¢\nint ari(int a, int b, int c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nint fact(int i) {\n\tll sum = 1;\n\tfor (int j = 2; j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//??????(??£???\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h, n;\nH a[100000];\nint b[2][100000], c[2][100000];\nint sum[2];\nsigned main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].x >> a[i].y;\n\t\tb[0][i] = a[i].x, c[0][i] = a[i].y;\n\t\tsum[0] += (a[i].x * 2);\n\t\tsum[1] += (a[i].y * 2);\n\t}\n\tint ans[3] = { inf,0,0 };\n\tsort(b[0], b[0] + n); sort(c[0], c[0] + n);\n\tb[1][0] = b[0][0]; c[1][0] = c[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tb[1][i] = b[1][i - 1] + b[0][i], c[1][i] = c[1][i - 1] + c[0][i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint rep = 0;\n\t\tint res = round((sum[0] - a[i].x*1.0) / (n * 2 - 1));\n\t\tint iop = lower_bound(b[0], b[0] + n, res) - b[0];\n\t\tif (iop != 0) {\n\t\t\trep += (res * iop - b[1][iop - 1]) * 2;\n\t\t}\n\t\tif (iop != n) {\n\t\t\trep += (b[1][n - 1] - (iop == 0 ? 0 : b[1][iop - 1]) - res*(n - iop)) * 2;\n\t\t}\n\t\tint uio = res;\n\t\tres = round((sum[1] - a[i].y*1.0) / (n * 2 - 1));\n\t\tiop = lower_bound(c[0], c[0] + n, res) - c[0];\n\t\tif (iop != 0) {\n\t\t\trep += (res * iop - c[1][iop - 1]) * 2;\n\t\t}\n\t\tif (iop != n) {\n\t\t\trep += (c[1][n - 1] - (iop == 0 ? 0 : c[1][iop - 1]) - res*(n - iop)) * 2;\n\t\t}\n\t\trep -= (abs(uio - a[i].x) + abs(res - a[i].y));\n\t\tif (rep < ans[0]) {\n\t\t\tans[0] = rep;\n\t\t\tans[1] = uio;\n\t\t\tans[2] = res;\n\t\t}\n\t}\n\tcout << ans[0] << endl << ans[1] << \" \" << ans[2] << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\t\t\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tlong long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tmaxs = max(maxs, abs(X[k] - UX[i]) + abs(Y[k] - UY[j]));\n\t\t\t}\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],n,ansx,ansy,w,h,l=0;\n  ll sumx=0,sumy=0,ans;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    sumx+=x[i];\n    sumy+=y[i];\n  }\n\n  ansx=(int)((sumx/n)+(sumx%n>n/2));\n  ansy=(int)((sumy/n)+(sumy%n>n/2)); \n  \n  for(int i=0;i<n;i++){\n    l=max(l,abs(x[i]-ansx)+abs(y[i]-ansy));\n    ans+=(abs(x[i]-ansx)+abs(y[i]-ansy))*2;\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans-l,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nlong long x[200000], y[200000], n, H, W;\nvector<long long>X, Y; vector<pair<long long, long long>>candidate;\nlong long dists(long long px, long long py) {\n\tvector<long long>RR; long long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long TT = abs(px - x[i]) + abs(py - y[i]);\n\t\tRR.push_back(TT); sum += TT;\n\t}\n\tsort(RR.begin(), RR.end());\n\treturn sum * 2 - RR[RR.size() - 1];\n}\nint main() {\n\tcin >> H >> W >> n; for (int i = 0; i < n; i++) { cin >> x[i] >> y[i]; X.push_back(x[i]); Y.push_back(y[i]); }\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tvector<long long>HH, WW;\n\tif (n % 2 == 1) { HH.push_back(X[X.size() / 2]); WW.push_back(Y[Y.size() / 2]); }\n\tif (n % 2 == 0) {\n\t\tHH.push_back(X[X.size() / 2 - 1]); HH.push_back(X[X.size() / 2]);\n\t\tWW.push_back(Y[Y.size() / 2 - 1]); WW.push_back(Y[Y.size() / 2]);\n\t}\n\tunique(X.begin(), X.end()); unique(Y.begin(), Y.end());\n\tint pos1 = lower_bound(X.begin(), X.end(), HH[0]) - X.begin();\n\tint pos2 = lower_bound(Y.begin(), Y.end(), WW[0]) - Y.begin();\n\tint pos3 = 0, pos4 = 0;\n\tif (n % 2 == 0) {\n\t\tint pos1 = lower_bound(X.begin(), X.end(), HH[1]) - X.begin();\n\t\tint pos2 = lower_bound(Y.begin(), Y.end(), WW[1]) - Y.begin();\n\t}\n\tif (pos1 >= 1) { HH.push_back(X[pos1 - 1]); }\n\tif (pos1 < X.size() - 1 && n % 2 == 1) { HH.push_back(X[pos1 + 1]); }\n\tif (pos3 < X.size() - 1 && n % 2 == 0) { HH.push_back(X[pos3 + 1]); }\n\tif (pos2 >= 1) { WW.push_back(Y[pos2 - 1]); }\n\tif (pos2 < Y.size() - 1 && n % 2 == 1) { WW.push_back(Y[pos2 + 1]); }\n\tif (pos4 < Y.size() - 1 && n % 2 == 0) { WW.push_back(Y[pos4 + 1]); }\n\tfor (int i = 0; i < HH.size(); i++) { for (int j = 0; j < WW.size(); j++)candidate.push_back(make_pair(HH[i], WW[j])); }\n\tlong long minx = 999999999999999999LL, mx = 0, my = 0; sort(candidate.begin(), candidate.end());\n\tfor (int i = 0; i < candidate.size(); i++) {\n\t\tlong long UU = dists(candidate[i].first, candidate[i].second);\n\t\tif (minx > UU) { minx = UU; mx = candidate[i].first; my = candidate[i].second; }\n\t}\n\tcout << minx << endl << mx << ' ' << my << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAX_H 1000000000 //10^9\n#define MAX_W 1000000000 //10^9\n#define MAX_N 100000 //10^5\n#define mp make_pair\n#define INF 1001001001\n#define LLINF 1001001001001001001\n#define llint long long int\n#define ppp pair<int, pair<int,int> >\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n ; i++)\nusing namespace std;\nllint homesx[MAX_N];\nllint homesy[MAX_N];\nllint homesxs[MAX_N];\nllint homesys[MAX_N];\nint main(void){\n    // Your code here!\n    llint W,H,N;\n    scanf(\"%lld %lld %lld\",&W,&H,&N);\n    rep(i,N){\n        llint X,Y;\n        scanf(\"%lld %lld\",&X,&Y);X--;Y--;\n        homesx[i]=X;homesy[i]=Y;\n        homesxs[i]=X;homesys[i]=Y;\n    }\n    \n    //X座標について求める\n    if(N==1){printf(\"%lld\\n%lld %lld\",0,homesx[0],homesy[0]);return 0;}\n    llint ans=LLINF;\n    llint zans[2]={-1,-1};\n    sort(&homesxs[0], &homesxs[N]);\n    sort(&homesys[0], &homesys[N]);\n    llint　Center1=(llint)(N/2)-1;\n    llint　Center2=(llint)(N/2);\n    \n    llint sum=0;llint maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n    if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center2];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center2];}\n    printf(\"%lld\\n%lld %lld\\n\",ans,zans[0]+1,zans[1]+1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint W, H, N, x[100009], y[100009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[i], &y[i]);\n\tsort(x, x + N);\n\tsort(y, y + N);\n\tint px = x[N >> 1], py = y[N >> 1], m = 0;\n\tlong long ret = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tint d = abs(px - x[i]) + abs(py - y[i]);\n\t\tret += d;\n\t\tm = max(m, d);\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ret * 2 - m, px, py);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    printf(\"%ld %ld\\n\",B[n/2],B[n/2-1]);\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint W,H,N;\nint xs[2][100*1000];\nint ys[2][100*1000];\nint main() {\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",xs[0]+i,ys[0]+i);\n\t\txs[1][i]=xs[0][i];\n\t\tys[1][i]=ys[0][i];\n\t}\n\tLL ret=1LL<<60;\n\tint rx=0,ry=0;\n\tfor(int i=0;i<=(N+1)%2;i++){\n\t\tfor(int j=0;j<=(N+1)%2;j++){\n\t\t\tint x;\n\t\t\tif(i==0){\n\t\t\t\tnth_element(xs[1],xs[1]+(N+i-1)/2,xs[1]+N);\n\t\t\t\tx=xs[1][(N+i-1)/2];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx=*min_element(xs[1]+N/2,xs[1]+N);\n\t\t\t}\n\t\t\tint y;\n\t\t\tif(j==0){\n\t\t\t\tnth_element(ys[1],ys[1]+(N+j-1)/2,ys[1]+N);\n\t\t\t\ty=ys[1][(N+j-1)/2];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty=*min_element(ys[1]+N/2,ys[1]+N);\n\n\t\t\t}\n\t\t\tLL m=0;\n\t\t\tLL sum=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tLL d=abs(xs[0][i]-x);\n\t\t\t\td+=abs(ys[0][i]-y);\n\t\t\t\tm=max(m,d);\n\t\t\t\tsum+=2*d;\n\t\t\t}\n\t\t\tsum-=m;\n\t\t\tif(sum<ret){\n\t\t\t\tret=sum;\n\t\t\t\trx=x;\n\t\t\t\try=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <vector>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n - 1); i >= 0; --i)\n#define mod 100000\n#define INF 93193111451418101\n#define MIN -933111451418101\n#define pb push_back\nusing namespace std;\ntypedef pair<ll, ll> P;\n \n/*template <typename T, typename U>\nstd::enable_if_t<std::rank<T>::value == 0> fill_all(T &arr, const U &v) {\narr = v;\n}\ntemplate <typename ARR, typename U>\nstd::enable_if_t<std::rank<ARR>::value != 0> fill_all(ARR &arr, const U &v) {\nfor (auto &i : arr) {\nfill_all(i, v);\n}\n}*/\n//------------------??????°-----------------------//\nll w, h,n;\nP housex[114514],housey[114514];//(x,y),(x,y)\n//-------------------???¢???°----------------------//\n \nint main() {\n\tcin >> w >> h >> n;\n\tREP(i, n) {\n\t\tll x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\thousex[i] = P(x, y);\n\t\thousey[i] = P(y, x);\n\t}\n\tsort(housex, housex + n); sort(housey, housey + n);\n\tll halfn=(n+1)/2;\n\tll x = housex[halfn - 1].first,y=housey[halfn-1].first,ans=0;\n\tll maxa = 0;\n\tREP(i, n) {\n\t\tmaxa = max(maxa, abs(housex[i].first - x) + abs(housex[i].second - y));\n\t\tans += abs(housex[i].first - x) + abs(housex[i].second - y);\n\t}\n\tcout << ans*2-maxa << endl << x+1 <<\" \"<< y+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n  //\n  int index = 0;\n  REP(i,1,all.size()){\n    int fir = all[i],sec=M[all[i]];\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<string.h>\n#include<vector>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<string>\n#include<stack>\n#include<limits.h>\n#define int long long\n#define P pair<int,int>\nusing namespace std;\n\nP a[100000];\nint b[100000], c[100000];\nint dis = LLONG_MAX;\nP ans = { LLONG_MAX,LLONG_MAX };\nP w;//x??§?¨???????\nP x;//x??§?¨?????????¢\nP y;//y??§?¨???????\nP z;//y??§?¨?????????¢\nsigned main() {\n\tint n; cin >> n >> n >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tsort(b, b + n); sort(c, c + n);\n\tif (n & 1) {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t}\n\telse {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\tw.second = b[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2 - 1]) * 2;\n\t\t}\n\t\tx.second = k;\n\t\tk = 0;\n\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t\tk = 0;\n\n\t\ty.second = c[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2 - 1]) * 2;\n\t\t}\n\t\tz.second = k;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tdis = min(dis, l + r);\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tif (dis == l + r) {\n\t\t\tif (n % 2 == 0 && x.first - abs(w.first - b[i])!=l) {\n\t\t\t\tans.first = min(ans.first, w.second);\n\t\t}\n\t\t\telse {\n\t\t\t\tans.first = min(ans.first, w.first);\n\t\t\t}\n\t\t\tif (n % 2 == 0 && z.first - abs(y.first - c[i]) != r) {\n\t\t\t\tans.second = min(ans.second, y.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.second = min(ans.second, y.first);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis << endl;\n\tcout << ans.first << \" \" << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef struct{\n  long long int x,y;\n}ho;\nho house[100000];\nvector<long long int> hx;\nvector<long long int> hy;\nlong long int x[2]={0};\nlong long int y[2]={0};\nlong long int ans=1LL<<62,ax=0,ay=0;\n\nint w,h,n;\n\nint main(void){\n  scanf(\"%d %d %d\",&w,&h,&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d\",&house[i].x,&house[i].y);\n    hx.push_back(house[i].x);\n    hy.push_back(house[i].y);\n  }\n  sort(hx.begin(),hx.end());\n  sort(hy.begin(),hy.end());\n\n  int xs,xp=(hx.size()+1)%2+1; //奇数１偶数２\n  int ys,yp=(hy.size()+1)%2+1;\n  xs=hx.size();\n  ys=hy.size();\n  for(int i=0;i<xp;i++) x[i]=hx[xs/2+i-xp/2];\n  for(int i=0;i<yp;i++) y[i]=hy[ys/2+i-yp/2];\n\n  long long int nx,ny;\n  long long int lx,ly;\n  long long int nmax=0;\n  long long int temp=0;\n  for(int i=0;i<xp;i++){\n    nx=x[i];\n    for(int j=0;j<yp;j++){\n      ny=y[j];\n      nmax=0;\n      temp=0;\n      for(long long int l=0;l<n;l++){\n\tlx=nx-house[l].x;\n\tly=ny-house[l].y;\n\tlx*=(lx>=0)?1:-1;\n\tly*=(ly>=0)?1:-1;\n\tlong long int tamp=lx+ly;\n\tif(nmax<tamp) nmax=tamp;\n\ttamp*=2;\n\ttemp+=tamp;\n      }\n      temp-=nmax;\n      //      printf(\"(%lld,%lld):%lld\\n\",nx,ny,temp);\n      if(temp<ans){\n\tans=temp;\n\tax=nx;\n\tay=ny;\n      }\n    }\n  }\n  /*\n  printf(\"xp:%d\\nyp:%d\\n\",xp,yp);\n  for(int i=0;i<2;i++)printf(\"%d.x:%lld\\n  y:%lld\\n\",i,x[i],y[i]);\n  */\n  printf(\"%lld\\n%lld %lld\\n\",ans,ax,ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    int x;\n    int y;\n    p(){};\n    P(int p1,int p2){\n        x=p1;\n        y=p2;\n    }\n};\n\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<P> pos;\n\nint dist(int x,int y){\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].x);\n        int disy=abs(y-pos[i].y);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(P(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nint dx[]={1,1,1,0,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,0,-1,1,0,-1};\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tif(c==1){\n\t\tprintf(\"%d\\n%d %d\\n\",0,d[0].first,d[0].second);\n\t\treturn 0;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=9999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=c/2;\n\t//\tif(c/2>=xat){\n\t//\t\t;\n\t//\t}else{\n\t//\t\tCenterX--;\n\t//\t}\n\t\tint CenterY=c/2;\n\t//\tif(c/2>=yat){;}\n\t//\telse CenterY--;\n\t\tprintf(\"%d %d %d %d\\n\",xat,yat,x[CenterX],y[CenterY]);\n\t\tlong long T;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tCenterX+=dx[j];\n\t\t\tCenterY+=dy[j];\n\t\t\tif(CenterX>=0&&CenterY>=0&&CenterX<c&&CenterY<c){\n\t\t\t\tT=-abs(x[CenterX]-d[i].first);\n\t\t\t\tT+=-abs(y[CenterY]-d[i].second);\n\t\t\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\t\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\t\t\n\t\t\t\t//printf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\t\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\t\t\tans=T;\n\t\t\t\t\trow=x[CenterX];\n\t\t\t\t\tcol=y[CenterY];\n\t\t\t\t}\n\t\t\t}\n\t\t\tCenterX-=dx[j];\n\t\t\tCenterY-=dy[j];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}\n//..#...\n//..###.\n//.###..\n//...#.."
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*1,neg = 2*(n-1),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    /*\n    rep(i,y.size()){\n      cout <<\"score \" <<  y[i].first <<\" pos \" << y[i].second << endl;\n    }\n    */\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-5),min(yind+5,(int)Y.size())){\n\tREP(j,max(0,xind-1),min(xind+5,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  /*\n\t  if (tmp <= 21){\n\t    cout << \"eliminate \" << k << \" ty \" << ty <<\" tx \" << tx << \" score \" << tmp << \n\t      \" original score \" << y[i].first + x[j].first << endl;\n\t    cout << y[i].second <<\" \" << in[k].second <<\" \" << x[j].second <<\" \" << in[k].first << endl;\n\t  }\n\t  */\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long \n#define ff(i, a, b) for(int i = a; i <= b; i++)\n#define fo(i, a, b) for(int i = a; i < b; i++)\n#define fod(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nconst int INF = 1e9, N = 100010;\nconst ll INFL = 1e18;\n\ntypedef pair <long long, long long> ii;\ntypedef vector <int> vi;\ntypedef vector <ii> vii;\n\nint n, w, h, X, Y;\nlong long ansx, ansy;\nlong long x[N], y[N];\nii a[N];\nlong long ans = INFL;\n\nlong long res(int X, int Y) {\n\tlong long res = 0;\n\tlong long mx = 0;\n\tff(i, 1, n) res += abs(X - a[i].fi) + abs(Y - a[i].se), mx = max(mx, abs(X - a[i].fi) + abs(Y - a[i].se));\n\tres *= 2; res -= mx;\n\treturn res;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tff(i, 1, n) cin >> x[i] >> y[i], a[i].fi = x[i], a[i].se = y[i];\n\tsort(x + 1, x + n + 1); sort(y + 1, y + n + 1);\n\tint cent = ((n + 1)>>1);\n\tif (n & 1) {\n\t\tX = x[cent], Y = y[cent];\n\t\tans = res(X, Y);\n\t\tansx = X; ansy = Y;\n\t}\n\telse {\n\t\tX = x[cent], Y = y[cent];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent], Y = y[cent+1];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent+1], Y = y[cent];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent+1], Y = y[cent+1];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int W,H,N;\n  cin>>W>>H>>N;\n  int xy[100000][2];\n  for(int i=0;i<N;i++){\n    cin>>xy[i][0]>>xy[i][1];\n  }\n  vector<tuple<int,int,long long> > res[2];\n  for(int i=0;i<2;i++){\n    vector<pair<int,int> > v;\n    for(int j=0;j<N;j++){\n      v.emplace_back(xy[j][i],j);\n    }\n    sort(begin(v),end(v));\n    long long nd=0;\n    int lx=0,x=N-1;\n    int l=N-1,r=0;\n    for(int j=0;j<N-1;j++){\n      nd+=2LL*(v[N-1].first-v[j].first);\n    }\n    long long pd=nd-(v[N-1].first-v[0].first);\n    for(;;){\n      while(x){\n\tlong long nnd=nd+(v[x].first-v[x-1].first)*2LL*(r+1-l);\n\tlong long npd=nnd-abs(v[lx].first-v[x-1].first);\n\tif(npd>pd)break;\n\tnd=nnd;\n\tpd=npd;\n\tl--;\n\tr++;\n\tx--;\n      }\n      res[i].emplace_back(v[lx].second,v[x].first,pd);\n      lx++;\n      if(lx==N)break;\n      pd+=abs(v[lx-1].first-v[x].first)-abs(v[lx].first-v[x].first);\n    }\n    sort(begin(res[i]),end(res[i]));\n  }\n  int rx,ry;\n  long long d=1LL<<62;\n  for(int i=0;i<N;i++){\n    long long sd=get<2>(res[0][i])+get<2>(res[1][i]);\n    bool f;\n    if(sd!=d){\n      f=sd<d;\n    }else if(rx!=get<1>(res[0][i])){\n      f=get<1>(res[0][i])<rx;\n    }else{\n      f=get<1>(res[1][i])<ry;\n    }\n    if(f){\n      rx=get<1>(res[0][i]);\n      ry=get<1>(res[1][i]);\n      d=sd;\n    }\n  }\n  cout<<d<<endl;\n  cout<<rx<<' '<<ry<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\ntypedef pair<LL,LL>PLL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define F first\n#define S second\nLL H,W;\nLL N;\nLL x[100000],y[100000];\nLL x_[100000],y_[100000];\nvoid solve(){\n    sort(x,x+N);\n    sort(y,y+N);\n    vector<PLL>V;\n    if(N&1){\n        V.PB(PLL(x[N/2],y[N/2]));\n    }\n    else{\n        V.PB(PLL(x[N/2],y[N/2]));\n        V.PB(PLL(x[N/2-1],y[N/2]));\n        V.PB(PLL(x[N/2],y[N/2-1]));\n        V.PB(PLL(x[N/2-1],y[N/2-1]));\n    }\n    LL mic=100000000000000000;\n    LL mix,miy;\n\n    REP(i,V.size()){\n        LL xym=0;\n        LL sum=0;\n        REP(j,N){\n            LL xd=max(V[i].F,x_[j])-min(V[i].F,x_[j]);\n            LL yd=max(V[i].S,y_[j])-min(V[i].S,y_[j]);\n\n            sum+=(xd+yd)*2;\n            xym=max(xym,xd+yd);\n        }\n        if(mic>=sum-xym){\n            if(mic==sum-xym&&mix!=V[i].F&&mix<V[i].F)continue;\n            if(mic==sum-xym&&miy!=V[i].S&&miy<V[i].S)continue;\n            mic=sum-xym;\n            mix=V[i].F;\n            miy=V[i].S;\n        }\n    }\n\n    cout<<mic<<endl;\n    cout<<mix<<\" \"<<miy<<endl;\n}\n\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    REP(i,N){\n        cin>>x[i]>>y[i];\n        x_[i]=x[i];\n        y_[i]=y[i];\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, l = 0, r = B;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n#define int ll\nsigned main() {\n\tint w, h, n;\n\n\tscnaf(\"%lld %lld %lld\", &w, &h, &n);\n\tvector<pii> po(n);\n\tvector<int> ax(n), ay(n);\n\tREP(i, n) {\n\t\tscnaf(\"%lld %lld\", &ay[i], &ax[i]);\n\t\tpo[i] = {ay[i],ax[i]};\n\t}\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\n\tpll ans = { ay[(n-1) / 2],ax[(n-1)/ 2] };\n\n\tll len = 0;\n\tll Maxl = 0;\n\tREP(i, n) {\n\t\tll l = abs(po[i].first - ans.first) + abs(po[i].second- ans.second);\n\t\tMaxl = max(Maxl, l);\n\t\tlen += l * 2;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", len-Maxl,ans.first,ans.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#define In_(x) scanf(\"%lld\",&(x))\n\nusing int64 = long long;\nint64 w, h;\nint64 n;\nint64 x[123456], y[123456];\nvector<pair<int64, int64>>point;\n\nint64 arx, ary, arw, arh;\n\nint64 ans = 0;\npair<int64, int64> diff()\n{\n\tdouble centx, centy;\n\tcentx = arx + arw / 2.0;\n\tcenty = ary + arh / 2.0;\n\tint64 dist = 0;\n\tpair<int64, int64>ret;\n\tfor (auto thp : point)\n\t{\n\t\tint64 cand = 0;\n\t\tif (thp.first < centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t}\n\t\t}\n\t\telse if (thp.first < centx && thp.second >= centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t}\n\t\t}\n\t\telse if (thp.first >= centx && thp.second < centy)\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary);\n\t\t\t}\n\t\t}\n\t}\n\tans -= dist;\n\treturn ret;\n}\n\nint main(void)\n{\n\tIn_(w);In_(h);\n\tIn_(n);\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tIn_(x[i]); In_(y[i]);\n\t\tpoint.emplace_back(x[i],y[i]);\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\tif (n % 2)\n\t{\n\t\t//odd\n\t\tarx = x[n / 2];\n\t\tary = y[n / 2];\n\t\tarw = arh = 0;\n\t}\n\telse\n\t{\n\t\t//even\n\t\tarx = x[n / 2 - 1];\n\t\tary = y[n / 2 - 1];\n\t\tarw = x[n / 2] - arx;\n\t\tarh = y[n / 2] - ary;\n\t}\n\tauto pp = diff();\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tans += abs(x[i] - pp.first) * 2;\n\t\tans += abs(y[i] - pp.second) * 2;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, pp.first, pp.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n#define int ll\nsigned main() {\n\tint w, h, n;\n\n\tscnaf(\"%lld %lld %lld\", &w, &h, &n);\n\tvector<pii> po(n);\n\tvector<int> ax(n), ay(n);\n\tREP(i, n) {\n\t\tscnaf(\"%lld %lld\", &ay[i], &ax[i]);\n\t\tpo[i] = {ay[i],ax[i]};\n\t}\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tif (n % 2) {\n\t\tpll ans = { ay[(n - 1) / 2],ax[(n - 1) / 2] };\n\n\t\tll len = 0;\n\t\tll Maxl = 0;\n\t\tREP(i, n) {\n\t\t\tll l = abs(po[i].first - ans.first) + abs(po[i].second - ans.second);\n\t\t\tMaxl = max(Maxl, l);\n\t\t\tlen += l * 2;\n\t\t}\n\t\tprintf(\"%lld\\n%lld %lld\\n\", len - Maxl, ans.first, ans.second);\n\t}\n\telse {\n\t\tpair<ll, pll> ou = { LLONG_MAX, {} };\n\t\tREP(c, 2) {\n\t\t\tREP(cc, 2) {\n\t\t\t\tpll ans = { ay[(n - c) / 2],ax[(n - cc) / 2] };\n\n\t\t\t\tll len = 0;\n\t\t\t\tll Maxl = 0;\n\t\t\t\tREP(i, n) {\n\t\t\t\t\tll l = abs(po[i].first - ans.first) + abs(po[i].second - ans.second);\n\t\t\t\t\tMaxl = max(Maxl, l);\n\t\t\t\t\tlen += l * 2;\n\t\t\t\t}\n\t\t\t\tou = min(ou, { len - Maxl, {ans.first, ans.second} });\n\t\t\t}\n\t\t}\n\t\t\t\tprintf(\"%lld\\n%lld %lld\\n\", ou.first, ou.second.first, ou.second.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint w, h, n;\n\tstatic int x[114514], y[114514], _x[114514], _y[114514];\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> x[i] >> y[i], _x[i] = x[i], _y[i] = y[i];\n\tsort(_x, _x + n);\n\tsort(_y, _y + n);\n\n\tll res = 1LL << 60, res_x, res_y;\n\tfor (int a = max(0, n / 2 - 1); a <= n / 2; ++a)\n\t{\n\t\tfor (int b = max(0, n / 2 - 1); b <= n / 2; ++b)\n\t\t{\n\t\t\tint gx = _x[a], gy = _y[b];\n\n\t\t\tstatic ll d[114514];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\td[i] = abs(x[i] - gx) + abs(y[i] - gy);\n\t\t\tll total = 2 * accumulate(d, d + n, 0LL) - *max_element(d, d + n);\n\t\t\tif (total < res)\n\t\t\t{\n\t\t\t\tres = total;\n\t\t\t\tres_x = gx;\n\t\t\t\tres_y = gy;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tcout << res_x << \" \" << res_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 250;\n\nint calc(vint& v, int p)\n{\n\tll res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = max(mid_x - D, X[0]); x <= min(mid_x + D, X[N-1]); x++)\n\t\t{\n\t\t\tfor(int y = max(mid_y - D, Y[0]); y <= (mid_y + D, Y[N-1]); y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nint LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ 45-Degree Rotate ------ //\n\n\tLX = 2000000009;\n\tLY = 2000000009;\n\tRX = -2000000016;\n\tRY = -20000000016;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint tx = X[i] + Y[i];\n\t\tint ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\t\t\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(0LL + rx - LX, 0LL + RX - rx), max(0LL + ry - LY, 0LL + RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst int INF=1000000000;\n\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\n\nint main(){\n\tint w,h;\n\tcin >> w >> h;\n\tint n;\n\tcin >> n;\n\tvector<P> v(n);\n\tfor(int i=0; i<n; ++i){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tv[i].F=x;\n\t\tv[i].S=y;\n\t}\n\n\tP s;\n\tdouble sum=0;\n\tfor(int i=0; i<n; ++i) sum+=v[i].F;\n\ts.F=sum/n;\n\tsum=0;\n\tfor(int i=0; i<n; ++i) sum+=v[i].S;\n\ts.S=sum/n;\n\tint ans=INF;\n\tint ans_x,ans_y;\n\tfor(int i=0; i<4; ++i){\n\t\tint hoge=0;\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(tmp<max(tmp,abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]))){\n\t\t\t\tswap(v[j].F,v[n-1].F);\n\t\t\t\tswap(v[j].S,v[n-1].S);\n\t\t\t\ttmp=abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(j!=n-1) hoge+=2*(abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]));\n\t\t\telse hoge+=abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]);\n\t\t}\n\t\tif(hoge<ans){\n\t\t\tans=hoge;\n\t\t\tans_x=s.F+dx[i];\n\t\t\tans_y=s.S+dy[i];\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(cx,cx+n);\n sort(cy,cy+n);\n ll mx[2],my[2];\n mx[0]=cx[n>>1];\n mx[1]=cx[(n>>1)-1];\n my[0]=cy[n>>1];\n my[1]=cy[(n>>1)-1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*1,neg = 2*(n-1),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    //rep(i,in.size())cout << in[i].first <<\" \" << in[i].second << endl;\n    //ð­\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-10),min(yind+10,(int)Y.size())){\n\tREP(j,max(0,xind-10),min(xind+10,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\n\t  /*\n\t  if (tmp == 21){\n\t    cout << \"eliminate \" << k << \" ty \" << ty <<\" tx \" << tx << \" score \" << tmp << \n\t      \" original score \" << y[i].first + x[j].first << endl;\n\t    cout <<ty <<\" \" << tx << endl;\n\t  }\n\t  */\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tint xi = N / 2;\n\tint yi = N / 2;\n\n\tVV dists(9, V(N));\n\trep(i, N) rep(j, 3) rep(k, 3) {\n\t\tdists[j * 3 + k][i] = abs(v[i].first - ws[xi + j - 1]) + abs(v[i].second - hs[yi + k - 1]);\n\t}\n\trep(i, 9) sort(all(dists[i]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tint sum = accumulate(all(dists[i]), 0) * 2 - dists[i].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[xi + i / 3 - 1];\n\t\t\typos = hs[yi + i % 3 - 1];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint idx = (N-1)/2;\n\tll ans = linf;\n\tint ax = inf, ay = inf;\n\tvector<int> kx, ky;\n\tfor (int d = -3; d <= 3; ++d) {\n\t\tif (idx+d < 0 || idx+d >= N) continue;\n\t\tkx.pb(X[idx+d]);\n\t\tky.pb(Y[idx+d]);\n\t}\n\tREP(u, kx.size()) REP(w, ky.size()) {\n\t\tint sx = kx[u], sy = ky[w];\n\t\tvector<ll> a;\n\t\tREP(i, N) {\n\t\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t\t}\n\t\tsort( ALL(a) );\n\t\tll sum = a[N-1];\n\t\tREP(i, N-1) {\n\t\t\tsum += a[i]*2;\n\t\t}\n\t\tif (sum < ans || (sum == ans && P(sx, sy) < P(ax, ay))) {\n\t\t\tans = sum;\n\t\t\ttie(ax, ay) = P(sx, sy);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\n//X軸方向とY軸方向を別々に考える！\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int W,H,N;\n    cin >> W >> H >> N;\n    LL ansX = 0;\n    LL ansY = 0;\n    vector<int> X, Y;\n    for(int i=0; i<N; i++){\n        int x,y;\n        cin >> x >> y;\n        ansX += x;\n        ansY += y;\n        X.push_back(x);\n        Y.push_back(y);\n    }\n    if(((double)ansX / N) - (int)(ansX / N) == 0.5) ansX = ansX / N;\n    else ansX = round((double)ansX / N);\n    if(((double)ansY / N) - (int)(ansY / N) == 0.5) ansY = ansY / N;\n    else ansY = round((double)ansY / N);\n\n    LL ans = 0;\n    LL tmp = 0;\n    for(int i=0; i<N; i++){\n        ans += 2 * abs(ansX - X[i]);\n        ans += 2 * abs(ansY - Y[i]);\n        tmp = max(tmp, abs(ansX - X[i]) + abs(ansY - Y[i]));\n    }\n    cout << ans - tmp << endl;\n    cout << ansX << \" \" << ansY << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nlong long int INF=(long long)10000000000*100000;\nlong long int ans=0;\nlong long int w,h;\nlong long int x[100001],y[100001];\nvector<long long int> vx;\nvector<long long int> vy;\nlong long rx,ry;\nint n;\n\nlong long int dfs(long long int sx,long long int sy){\n\tvector<long long int> v;\n\tfor(int i=0;i<n;i++){\n\t\tv.push_back(abs(sx-x[i])+abs(sy-y[i]));\n\t}\n\tsort(v.begin(),v.end());\n\tlong long res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(i<n-1)res+=v[i]*2;\n\t\telse res+=v[i];\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> w >> h;\n\tans=INF;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t\tvx.push_back(x[i]);\n\t\tvy.push_back(y[i]);\n\t}\n\tif(n==1){\n\t\tcout << 0 << endl;\n\t\tcout << x[0] << \" \" << y[0] << endl;\n\t}\n\telse{\n\t\tsort(vx.begin(),vx.end());\n\t\tsort(vy.begin(),vy.end());\n\t\tfor(int  j=-1;j<=1;j+=2){\n\t\t\tfor(int i=-1;i<=1;i+=2){\n\t\t\t\tlong long int res=dfs(vx[(n+i)/2],vy[(n+j)/2]);\n\t\t\t\tif(res<ans){\n\t\t\t\t\trx=vx[(long long)((n+i)/2)];\n\t\t\t\t\try=vy[(long long)((n+j)/2)];\n\t\t\t\t\tans=res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tcout << rx << \" \" << ry << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<int> x(n), y(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i] >> y[i];\n\n    vector<int> x0 = x;\n    vector<int> y0 = y;\n    sort(x0.begin(), x0.end());\n    sort(y0.begin(), y0.end());\n\n    long long ret = LLONG_MAX;\n    int tx, ty;\n    for(int i=-1; i<=1; ++i){\n        for(int j=-1; j<=1; ++j){\n            if(n/2 + i < 0 || n/2 + i >= n || n/2 + j < 0 || n/2 + j >= n)\n                continue;\n            int sx = x0[n/2+i];\n            int sy = y0[n/2+j];\n\n            long long tmp = 0;\n            long long maxDist = 0;\n            for(int k=0; k<n; ++k){\n                long long dist = abs(sx - x[k]) + abs(sy - y[k]);\n                tmp += dist * 2;\n                maxDist = max(maxDist, dist);\n            }\n            tmp -= maxDist;\n\n            if(tmp < ret){\n                ret = tmp;\n                tx = sx;\n                ty = sy;\n            }\n            ret = min(ret, tmp);\n        }\n    }\n\n    cout << ret << endl;\n    cout << tx << ' ' << ty << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<long long,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nP pa1[100005];\nP pa2[100005];\nint h,w,n;\nbool comp1(P a,P b){\n\treturn a.first<b.first;\n}\nbool comp2(P a,P b){\n\treturn a.second<b.second;\n}\nbool decide(P1 a,P1 b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else if(a.first>b.first){\n\t\treturn false;\n\t}else{\n\t\tif(a.second.first<b.second.first){\n\t\t\treturn true;\n\t\t}else if(a.second.first>b.second.first){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn a.second.second<b.second.second;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&h,&w);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tpa1[i]=mp(x,y);\n\t\tpa2[i]=pa1[i];\n\t}\n\tsort(pa2+1,pa2+(n+1),comp2);\n\tsort(pa1+1,pa1+(n+1),comp1);\n\tint ha=(n+1)/2;\n\tint ax=pa1[ha].first;\n\tint ay=pa2[ha].second;\n\tvector<P1>vec;\n\tvector<int>dx,dy;\n\tif(pa1[ha+1].first!=ax){\n\t\tdx.pb(ax);\n\t\tdx.pb(pa1[ha+1].first);\n\t}\n\telse{\n\t\tdx.pb(ax);\n\t\tdx.pb(ax-1);\t\n\t\tdx.pb(ax+1);\t\t\n\t}\n\tif(pa2[ha+1].second!=ay){\n\t\tdy.pb(ay);\n\t\tdy.pb(pa2[ha+1].second);\n\t}\n\telse{\n\t\tdy.pb(ay);\n\t\tdy.pb(ay-1);\t\n\t\tdy.pb(ay+1);\t\t\n\t}\n\n\tfor(int i=0;i<dx.size();i++){\n\t\tfor(int j=0;j<=dy.size();j++){\n\t\t\tlong long sd=0;\n\t\t\tint maxi=0;\n\t\t\tfor(int g=1;g<=n;g++){\n\t\t\t\tsd+=(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j]));\n\t\t\t\tmaxi=max(maxi,(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j])));\n\t\t\t}\n\t\t\tvec.pb(mp(sd*2-maxi,mp(dx[i],dy[j])));\n\t\t}\n\t}\nsort(vec.begin(),vec.end(),decide);\nprintf(\"%lld\\n%d %d\\n\",vec[0].first,vec[0].second.first,vec[0].second.second);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid2].F;\n\t\tfor (int i = 0; i < 2 * n ; i+=2) {\n\t\t\tif(i == j)\n\t\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t\telse\n\t\t\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j < mid)\n\t\t\tmid--;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t}\n\tcout << mid << endl;\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef long long int LL;\nconst LL INF = 9e18;\n\nint w, h, n;\n\nVP homes;\nVI homes_x, homes_y;\nint candidate_x[2], candidate_y[2];\n\nPII ans_loc;\nLL ans_dist = INF;\n\nint main()\n{\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0; i < n; i++){\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    homes.push_back(make_pair(x, y));\n    homes_x.push_back(x);\n    homes_y.push_back(y);\n  }\n\n  sort(homes_x.begin(), homes_x.end());\n  sort(homes_y.begin(), homes_y.end());\n\n  candidate_x[0] = homes_x[(homes_x.size() - 1) / 2];\n  candidate_x[1] = homes_x[homes_x.size() / 2];\n  candidate_y[0] = homes_y[(homes_y.size() - 1) / 2];\n  candidate_y[1] = homes_y[homes_y.size() / 2];\n\n  for(int i = 0; i < 4; i++){\n    LL mx = 0, sum = 0;\n    for(int j = 0; j < homes.size(); j++){\n      LL dist = abs(homes[j].first - candidate_x[(i & 2) / 2]) + abs(homes[j].second - candidate_y[i & 1]);\n      sum += dist * 2;\n      mx = max(mx, dist);\n    }\n    sum -= mx;\n\n    if(sum < ans_dist){\n      ans_dist = sum;\n      ans_loc = make_pair(candidate_x[(i & 2) / 2], candidate_y[i & 1]);\n    }\n  }\n\n  printf(\"%lld\\n%d %d\\n\", ans_dist, ans_loc.first, ans_loc.second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; int maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = X[j];\n\t\t\t\ty = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF;\n\tP *p;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + 2 * n, search);\n\t\tsave = house[0][j]; save2 = *p;\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t}\n\t\thouse[0][2 * n - 1] = save;\n\t\thouse[1][2 * n - 1] = save2;\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint x[100000], y[100000], tx[100000], ty[100000];\nint sum1[100001], sum2[100001];\n#define dist(x,y)(abs(i-x)+abs(j-y))\nsigned main() {\n\tint w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\ttx[i] = x[i]; ty[i] = y[i];\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tset<int>ax, ay;\n\tint mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tint a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a) {\n\t\t\tmx = a; ax.clear();\n\t\t}\n\t\tif (mx == a)ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a) {\n\t\t\tmy = a; ay.clear();\n\t\t}\n\t\tif (my == a)ay.insert(y[i]);\n\t}\n\tint ansx, ansy, ans = LLONG_MAX;\n\tfor (int i : ax)for (int j : ay)rep(k, n) {\n\t\tint d = mx + my - dist(tx[k], ty[k]);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long long int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%lld%lld%lld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>=a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\n#include<climits>\nusing namespace std;\n\nstruct Point {int x, y;};\n\nclass Compare {\npublic:\n    Compare(const bool y = false) :y(y) {}\n    bool operator()(const Point& lhs, const Point& rhs) const {return y ? lhs.y < rhs.y : lhs.x < rhs.x;}\n    bool y;\n};\n\nlong long int distance(const Point& p, const Point& q) {return abs(p.x - q.x) + abs(p.y - q.y);}\n\nint main() {\n    int W, H, N;\n    cin >> W >> H >> N;\n\n    vector<Point> home(N);\n    for(auto& h: home) cin >> h.x >> h.y;\n\n    Point sleigh;\n    sort(home.begin(), home.end(), Compare());\n    sleigh.x = home[N / 2].x;\n    sort(home.begin(), home.end(), Compare(true));\n    sleigh.y = home[N / 2].y;\n\n    long long int sum = 0, farthest = 0;\n    for(const auto& h: home) {\n        long long int d = distance(sleigh, h);\n        farthest = max(farthest, d);\n        sum += d * 2;\n    }\n    sum -= farthest;\n\n    cout << sum << endl;\n    cout << sleigh.x << \" \" << sleigh.y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nconst ll INF = 1001001001001;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(x-ps[i].first) + std::abs(y-ps[i].second);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    X.erase(std::unique(X.begin(), X.end()), X.end());\n    std::sort(Y.begin(), Y.end());\n    Y.erase(std::unique(Y.begin(), Y.end()), Y.end());\n\n    int xn = X.size(), yn = Y.size();\n    ll xs[3], ys[3];\n    if((xn-1)/2-1 >= 0){\n        xs[0] = X[(xn-1)/2-1];\n    }\n    xs[1] = X[(xn+1)/2-1];\n    if((xn+3)/2-1 < xn){\n        xs[2] = X[(X.size()+3)/2-1];\n    }\n\n    if((yn-1)/2-1 >= 0){\n        ys[0] = Y[(yn-1)/2-1];\n    }\n    ys[1] = Y[(yn+1)/2-1];\n    if((yn+3)/2-1 < yn){\n        ys[2] = Y[(yn+3)/2-1];\n    }\n\n    ll max_cost = INF, x = INF, y = INF;\n    REP(i, 3){\n        REP(j, 3){\n            ll cost = work(xs[i], ys[j]);\n            if(cost < max_cost){\n                max_cost = cost;\n                x = xs[i];\n                y = ys[j];\n            }else if(cost == max_cost){\n                x = std::min(x, xs[i]);\n                y = std::min(y, ys[j]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", max_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, mx, my, dx = 1145141919810LL, dy = 1145141919810LL;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx -= (n - i * 2 - 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx -= (n - i * 2 - 2)*(x[i] - x[i - 1]);\n\t\tsy[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx = x[i]; }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my = y[i]; }\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\td[i] = (abs(dx - x[i]) + abs(dy - y[i]));\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << dx << ' ' << dy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct E {//???????????±?????\\???????????°\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad?????§?¨???????2??????????????¢\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll i) {\n\tll sum = 1;\n\tfor (ll j = 2; j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//??????(??£???\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h, n;\nH a[100000];\nint x[2][100000], y[2][100000];\nld sr(ld t,int r) {\n\tint k = lower_bound(x[0], x[0] + n, t) - x[0];\n\tld sum = 0;\n\tk--;\n\tif (k >= 0)\n\t\tsum += (t*(k + 1) - x[1][k]);\n\tsum += (x[1][n - 1] - (k < 0 ? 0 : x[1][k]) - t*(n - k - 1));\n\treturn sum * 2 - abs(t - a[r].x);\n}\nint solve(int r) {\n\tld s = 0, e = w+1, t1, t2;\n\twhile (e - s > 0.0001) {\n\t\tt1 = (e - s) / 3 + s, t2 = (e - s) * 2 / 3 + s;\n\t\tld s1 = sr(t1, r), s2 = sr(t2, r);\n\t\tif (s1 > s2)\n\t\t\ts = t1;\n\t\telse if (s1 == s2)\n\t\t\ts = t1, e = t2;\n\t\telse e = t2;\n\t}\n\treturn round(s);\n}\nld sr2(ld t, int r) {\n\tint k = lower_bound(y[0], y[0] + n, t) - y[0];\n\tld sum = 0;\n\tk--;\n\tif (k >= 0)\n\t\tsum += (t*(k + 1) -  y[1][k]);\n\tsum += (y[1][n - 1] - (k < 0 ? 0 : y[1][k]) - t*(n - k - 1));\n\treturn sum * 2 - abs(t - a[r].y);\n}\nint solve2(int r) {\n\tld s = 0, e = h + 1, t1, t2;\n\twhile (e - s > 0.0001) {\n\t\tt1 = (e - s) / 3 + s, t2 = (e - s) * 2 / 3 + s;\n\t\tld s1 = sr2(t1, r), s2 = sr2(t2, r);\n\t\tif (s1 > s2)\n\t\t\ts = t1;\n\t\telse if (s1 == s2)\n\t\t\ts = t1, e = t2;\n\t\telse e = t2;\n\t}\n\treturn round(s);\n}\nsigned main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].x >> a[i].y;\n\t\tx[0][i] = a[i].x;\n\t\ty[0][i] = a[i].y;\n\t}\n\tsort(x[0], x[0] + n);\n\tsort(y[0], y[0] + n);\n\tx[1][0] = x[0][0]; y[1][0] = y[0][0];\n\tfor (int i = 1; i < n; i++) {\n\t\tx[1][i] = x[1][i - 1] + x[0][i];\n\t\ty[1][i] = y[1][i - 1] + y[0][i];\n\t}\n\tint ans[3] = { inf,0,0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tint res = 0;\n\t\tint t = solve(i);\n\t\tres += sr(t, i);\n\t\tint t2 = solve2(i);\n\t\tres += sr2(t2, i);\n\t\tif (res < ans[0] || (res == ans[0] && H{ t,t2 } < H{ ans[0],ans[1] })) {\n\t\t\tans[0] = res;\n\t\t\tans[1] = t;\n\t\t\tans[2] = t2;\n\t\t}\n\t}\n\tcout << ans[0] << endl << ans[1] << \" \" << ans[2] << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nlong long int INF=(long long)10000000000*100000;\nlong long int ans=0;\nlong long int w,h;\nlong long int x[100001],y[100001];\nvector<long long int> vx;\nvector<long long int> vy;\nlong long rx,ry;\nint n;\n\nlong long int dfs(long long int sx,long long int sy){\n\tvector<long long int> v;\n\tfor(int i=0;i<n;i++){\n\t\tv.push_back(abs(sx-x[i])+abs(sy-y[i]));\n\t}\n\tsort(v.begin(),v.end());\n\tlong long res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(i<n-1)res+=v[i]*2;\n\t\telse res+=v[i];\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0)break;\n\t\tmemset(x,0,sizeof(x));\n\t\tmemset(y,0,sizeof(y));\n\t\tvx.clear();\n\t\tvy.clear();\n\t\tans=INF;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tvx.push_back(x[i]);\n\t\t\tvy.push_back(y[i]);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout << 0 << endl;\n\t\t\tcout << x[0] << \" \" << y[0] << endl;\n\t\t}\n\t\telse{\n\t\t\tsort(vx.begin(),vx.end());\n\t\t\tsort(vy.begin(),vy.end());\n\t\t\tfor(int  j=-1;j<=1;j+=2){\n\t\t\t\tfor(int i=-1;i<=1;i+=2){\n\t\t\t\t\tlong long int res=dfs(vx[(n+i)/2],vy[(n+j)/2]);\n\t\t\t\t\tif(res<ans){\n\t\t\t\t\t\trx=vx[(long long)((n+i)/2)];\n\t\t\t\t\t\try=vy[(long long)((n+j)/2)];\n\t\t\t\t\t\tans=res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t\tcout << rx << \" \" << ry << endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000], bx, by;\nlong long sx[1000000], sy[1000000], sumx, sumy, mn, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\ndouble hx, hy;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tif (mx.size() >= 2) {\n\t\tcy = my[0];\n\t\tfor (int i = 0; i < mx.size(); i++) {\n\t\t\tbx += mx[i];\n\t\t}\n\t\thx = 1.0*bx / mx.size();\n\t\tcx = (1.0*hx + 0.5);\n\t}\n\telse {\n\t\tcx = mx[0];\n\t\tfor (int i = 0; i < my.size(); i++) {\n\t\t\tby += my[i];\n\t\t}\n\t\thy = 1.0*by / my.size();\n\t\tcy = (1.0*hy + 0.5);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\td[i] = abs(ex[i] - cx) + abs(ey[i] - cy);\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout <<sum << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long \n#define ff(i, a, b) for(int i = a; i <= b; i++)\n#define fo(i, a, b) for(int i = a; i < b; i++)\n#define fod(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nconst int INF = 1e9, N = 100010;\nconst ll INFL = 1e18;\n\ntypedef pair <long long, long long> ii;\ntypedef vector <int> vi;\ntypedef vector <ii> vii;\n\nint n, w, h, X, Y;\nlong long ansx, ansy;\nlong long x[N], y[N];\nii a[N];\nlong long ans = INFL;\n\nlong long res(int X, int Y) {\n\tlong long res = 0;\n\tlong long mx = 0;\n\tff(i, 1, n) res += abs(X - a[i].fi) + abs(Y - a[i].se), mx = max(mx, abs(X - a[i].fi) + abs(Y - a[i].se));\n\tres *= 2; res -= mx;\n\treturn res;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tff(i, 1, n) cin >> x[i] >> y[i], a[i].fi = x[i], a[i].se = y[i];\n\tsort(x + 1, x + n + 1); sort(y + 1, y + n + 1);\n\tint cent = ((n + 1)>>1);\n\tif (n & 1) {\n\t\tX = x[cent], Y = y[cent];\n\t\tans = res(X, Y);\n\t\tansx = X; ansy = Y;\n\t}\n\telse {\n\t\tX = x[cent], Y = y[cent];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent+1], Y = y[cent];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent], Y = y[cent+1];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent+1], Y = y[cent+1];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            c=abs(a[i]*2-xa);\n            c=c+abs(b[i]*2-ya);\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n FOR(i,n) cx[i]=x[i];\n FOR(i,n) cy[i]=y[i];\n sort(cx,cx+n);\n sort(cy,cy+n);\n ll mx[2],my[2];\n mx[0]=cx[(n-1)>>1];\n mx[1]=cx[n>>1];\n my[0]=cy[(n-1)>>1];\n my[1]=cy[n>>1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define INF 1000000000000000\nusing namespace std;\n\nint w,h,n;\nlong long ans = INF;\nlong long ansx = INF,ansy = INF;\nint X[100000],Y[100000],x[100000],y[100000];\n\nint main(){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i = 0; i < n; i++){\n\t\tx[i] = X[i];\n\t\ty[i] = Y[i];\n\t}\n\tif(n == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",x[0],y[0]);\n\t\treturn 0;\n\t}\n\tsort(x,x+n); sort(y,y+n);\n\tif(n%2 == 0){\n\t\tlong long Tx[2] = {0,0}, Ty[2] = {0,0};\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tTx[0] += abs(x[n/2-1]-X[i]);\n\t\t\tTy[0] += abs(y[n/2-1]-Y[i]);\n\t\t\tTx[1] += abs(x[n/2]-X[i]);\n\t\t\tTy[1] += abs(y[n/2]-Y[i]);\n\t\t}\n\t\tTx[0] *= 2; Tx[1] *= 2; Ty[0] *= 2; Ty[1] *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint zx = (X[i]<=x[n/2-1]),zy = (Y[i]<=y[n/2-1]); //T[0]\n\t\t\tif(ans >= Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i])){\n\t\t\t\tif(ans == Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i])){\n\t\t\t\t\tif(x[n/2+zx-1] < ansx){\n\t\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t\t} else if(x[n/2+zx-1] == ansx){\n\t\t\t\t\t\tif(y[n/2+zy-1] < ansy){\n\t\t\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tans = Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i]);\n\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t} else{\n\t\tlong long tx = x[n/2], ty = y[n/2],sx,ex,sy,ey;\n\t\tlong long T = 0, sum;\n\t\tfor(int i = 0; i < n; i++) T += abs(tx-X[i])+abs(ty-Y[i]);\n\t\tT *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum = T-2*(abs(tx-X[i])+abs(ty-Y[i]));\n\t\t\tif(X[i] <= x[n/2-1]){\n\t\t\t\tsx = tx; ex = x[n/2+1]; \n\t\t\t} else if(X[i] == x[n/2]){\n\t\t\t\tsx = x[n/2-1]; ex = x[n/2+1];\n\t\t\t} else{\n\t\t\t\tsx = x[n/2-1]; ex = tx;\n\t\t\t}\n\t\t\tif(Y[i] <= y[n/2-1]){\n\t\t\t\tsy = ty; ey = y[n/2+1]; \n\t\t\t} else if(Y[i] == y[n/2]){\n\t\t\t\tsy = y[n/2-1]; ey = y[n/2+1];\n\t\t\t} else{\n\t\t\t\tsy = y[n/2-1]; ey = ty;\n\t\t\t}\n\t\t\t//printf(\"%lld\\n\", sum);\n\t\t\tif(sx<=X[i]&&X[i]<=ex&&sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum){\n\t\t\t\t\tif(ans == sum){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum;\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sx<=X[i]&&X[i]<=ex){\n\t\t\t\tif(ans>=sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(Y[i]-sy) <= abs(Y[i]-ey)) tmp = sy;\n\t\t\t\t\telse tmp = ey;\n\t\t\t\t\tif(ans == sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > tmp){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(Y[i]-sy),abs(Y[i]-ey));\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(X[i]-sx) <= abs(X[i]-ex)) tmp = sx;\n\t\t\t\t\telse tmp = ex;\n\t\t\t\t\tif(ans == sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\t\tif(ansx > tmp){\n\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == tmp){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(X[i]-sx),abs(X[i]-ex));\n\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(X[i] >= ex){\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%lld %lld %lld\\n\", ans, ansx, ansy);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    /*\n    cout <<\"xinfo \" << endl;\n    rep(i,x.size())cout << x[i].first <<\" \" << x[i].second << endl;\n    cout <<\"yinfo \" << endl;\n    rep(i,y.size())cout << y[i].first <<\" \" << y[i].second << endl;\n    */\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[mx].first)my = i;    \n\n    const int D=4;\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct elem {\n    ll x, y;\n};\nint w, h, n;\nelem e[100000];\nll x[100000], y[100000];\nll px[3], py[3];\nint main() {\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for (int i=0; i<n; i++) {\n        scanf(\"%lld%lld\",&x[i],&y[i]);\n        e[i]=(elem){x[i],y[i]};\n    }\n    sort(x, x+n);\n    sort(y, y+n);\n    px[0]=x[(n-1)/2];\n    px[1]=x[(n+1)/2];\n    py[0]=y[(n-1)/2];\n    py[1]=y[(n+1)/2];\n    ll res=LLONG_MAX, rx=0, ry=0;\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            ll calc=0, m=0;\n            for (int k=0; k<n; k++) {\n                ll temp=(abs(px[i]-e[k].x)+abs(py[j]-e[k].y));\n                m=max(m, temp);\n                calc+=temp;\n            }\n            if (res>calc*2-m) {\n                res=calc*2-m;\n                rx=px[i]; ry=py[j];\n            }\n        }\n    }\n    printf(\"%lld\\n%lld %lld\\n\",res,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\nconst int Y = 100003;\nint w,h,n;\nint x[Y],y[Y],sx[Y],sy[Y],ansx,ansy;\nll ans = 1000000000000000,sumd,maxd;\nint main(){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tfor(int i = 0;i < n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tx[i] = a,y[i] = b,sx[i] = a,sy[i] = b;\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tfor(int i = 1;i >= 0;i--){\n\t\tfor(int j = 1;j >= 0;j--){\n\t\t\tll a = x[(n-i)/2];\n\t\t\tll b = y[(n-j)/2];\n\t\t\tsumd = 0,maxd = 0;\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tll d = abs(a-sx[k]) + abs(b-sy[k]);\n\t\t\t\tsumd += d*2;\n\t\t\t\tmaxd = max(maxd,d);\n\t\t\t}\n\t\t\tif(ans > sumd - maxd){\n\t\t\t\tans = sumd - maxd;\n\t\t\t\tansx = a;\n\t\t\t\tansy = b;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    printf(\"%ld %ld\\n\",B[n/2],B[n/2-1]);\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]>a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]>b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nconst ll INF = 9009009009009009009;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(x-ps[i].first) + std::abs(y-ps[i].second);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    X.erase(std::unique(X.begin(), X.end()), X.end());\n    std::sort(Y.begin(), Y.end());\n    Y.erase(std::unique(Y.begin(), Y.end()), Y.end());\n\n    int xn = X.size(), yn = Y.size();\n    ll xs[3], ys[3];\n    if((xn-1)/2-1 >= 0){\n        xs[0] = X[(xn-1)/2-1];\n    }\n    xs[1] = X[(xn+1)/2-1];\n    if((xn+3)/2-1 < xn){\n        xs[2] = X[(X.size()+3)/2-1];\n    }\n\n    if((yn-1)/2-1 >= 0){\n        ys[0] = Y[(yn-1)/2-1];\n    }\n    ys[1] = Y[(yn+1)/2-1];\n    if((yn+3)/2-1 < yn){\n        ys[2] = Y[(yn+3)/2-1];\n    }\n\n    ll max_cost = INF, x = INF, y = INF;\n    REP(i, 3){\n        REP(j, 3){\n            ll cost = work(xs[i], ys[j]);\n            if(cost < max_cost){\n                max_cost = cost;\n                x = xs[i];\n                y = ys[j];\n            }else if(cost == max_cost){\n                x = std::min(x, xs[i]);\n                y = std::min(y, ys[j]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", max_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long inf = 1LL<<62;\n\nlong long sum(long long t, const vector<long long>&v)\n{\n  long long ret = 0;\n  for(int i = 0; i < (int)v.size(); ++i){\n    ret += llabs(v[i]-t);\n  }\n  return 2*ret;\n}\n\nint main()\n{\n  long long w,h;\n  while(cin>>w>>h){\n    int n;\n    long long res = inf;\n    long long res_x, res_y;\n    vector<long long> x_coord,x_org;\n    vector<long long> y_coord,y_org;\n\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n      long long x,y;cin>>x>>y;x_coord.push_back(x);y_coord.push_back(y);\n    }\n    x_org = x_coord;\n    y_org = y_coord;\n    sort(x_coord.begin(),x_coord.end());\n    sort(y_coord.begin(),y_coord.end());\n\n    long long mx=x_coord[n/2];\n    long long my=y_coord[n/2];\n    if(n/2+1<n){\n      long long tmx=x_coord[n/2+1];\n      long long tmy=y_coord[n/2+1];\n      if( sum(tmx,x_coord) < sum(mx,x_coord) ) mx = tmx;\n      if( sum(tmy,y_coord) < sum(my,y_coord) ) my = tmy;\n    }\n    \n    for(long long x = mx-1; x <= mx+1; ++x){\n      for(long long y = my-1; y <= my+1; ++y){\n        long long sum0 = sum(x,x_coord) + sum(y,y_coord);\n        for(int i = 0; i < n; ++i){  \n          long long sum1 = sum0 - (llabs(x_org[i]-x) + llabs(y_org[i]-y));\n          if( res > sum1 ){\n            res = sum1;\n            //cout << sum1 << ' ' << x << ' ' << y << endl;\n            res_x = x;\n            res_y = y;\n          }\n        }\n      }\n    }\n\n    cout << res << endl << res_x << ' ' << res_y << endl;\n    \n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\nconst long long inf = 1LL<<62;\n\nlong long sum(long long t, const vector<long long>&v)\n{\n  long long ret = 0;\n  for(int i = 0; i < (int)v.size(); ++i){\n    ret += llabs(v[i]-t);\n  }\n  return 2*ret;\n}\n\nint main()\n{\n  long long w,h;\n  while(EOF!=scanf(\"%lld%lld\", &w, &h)){\n    int n;\n    long long res = inf;\n    long long res_x, res_y;\n    vector<long long> coord[2], org[2];\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < 2; ++j){\n        long long t; scanf(\"%lld\", &t); coord[j].push_back(t);\n      }\n    }\n\n    org[0] = coord[0];\n    org[1] = coord[1];\n    sort(coord[0].begin(),coord[0].end());\n    sort(coord[1].begin(),coord[1].end());\n\n    long long m[2] = {inf,inf};\n    for(int i = n/2-1; i <= n/2+1; ++i){\n      if( i < 0 || i >= n ) continue;\n      for(int j = 0; j < 2; ++j){\n        long long tm = sum(coord[j][i],coord[j]);\n        if( m[j] > tm ){ m[j] = coord[j][i]; }\n      }\n    }\n    \n    for(long long x = m[0]-1; x <= m[0]+1; ++x){\n      for(long long y = m[1]-1; y <= m[1]+1; ++y){\n        long long sum0 = sum(x,coord[0]) + sum(y,coord[1]);\n        for(int i = 0; i < n; ++i){  \n          long long sum1 = sum0 - (llabs(org[0][i]-x) + llabs(org[1][i]-y));\n          if( res > sum1 ){\n            res = sum1;\n            //cout << sum1 << ' ' << x << ' ' << y << endl;\n            res_x = x;\n            res_y = y;\n          }\n        }\n      }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", res, res_x, res_y);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, mx, my, dx = 1145141919810LL, dy = 1145141919810LL;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx = x[i]; }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my = y[i]; }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\td[i] = (abs(mx - ex[i]) + abs(my - ey[i]));\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << mx << ' ' << my << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; int maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n//#define DEBUG\n\nusing std::endl;\nconstexpr int64_t INF = 100000000010000000;\n\nint32_t N,W,H;\nint64_t X[100000];\nint64_t Y[100000];\nint64_t sX[100000];\nint64_t sY[100000];\nint64_t mid_diff_x = 0;\nint64_t mid_diff_y = 0;\n\nint main()\n{\n\tstd::cin >> W>>H;\n\tstd::cin >> N;\n\tfor(int i = 0;i < N;++i){\n\t\tstd::cin >> X[i]>>Y[i];\n\t\tsX[i] = X[i];sY[i] = Y[i];\n\t}\n\tif(N == 1){std::cout << 0<<endl<<X[0]<<' '<<Y[0]<<endl;return 0;}\n\t\n\tstd::sort(sX,sX+N);\n\tstd::sort(sY,sY+N);\n\tfor(int i = 0;i < N;++i){\n\t\tmid_diff_x += std::abs(X[i] - sX[N/2]);\n\t\tmid_diff_y += std::abs(Y[i] - sY[N/2]);\n\t}\n\t#ifdef DEBUG\n\tprintf(\"mid_diff = (%ld, %ld)\\n\",mid_diff_x, mid_diff_y); \n\t#endif\n\tint32_t round_b_x = 1000000, round_b_y = 1000000;\n\tint64_t diff_min = INF;\n\tfor(int32_t ignore = 0;ignore < N;++ignore)\n\t{\n\t\tauto run = [](\n\t\t\tint32_t& round,\n\t\t\tint64_t& diff,\n\t\t\tint64_t mid_diff,\n\t\t\tint64_t ignore_pos,\n\t\t\tint64_t S[]\n\t\t\t){\n\t\t\t\tint32_t mid_index = N/2;\n\t\t\t\tdiff = mid_diff;\n\t\t\t\t//????????§???mid_index???end??´??????????????????\n\t\t\t\t//mid_index?????????????????¨??????????????´?????????\n\t\t\t\tif(ignore_pos < S[mid_index]){\n\t\t\t\t\t//????????????\n\t\t\t\t}\n\t\t\t\telse if(ignore_pos == S[mid_index]){\n\t\t\t\t\tif(S[mid_index-1] == S[mid_index]){\n\t\t\t\t\t\t//??????????????°????????§??????????¶?????????¨??????\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//???????????????\n\t\t\t\t\t\t//???(mid??????)?????°-????????°=(N-mid_index_x)-mid_index_x\n\t\t\t\t\t\tdiff += (S[mid_index] - S[mid_index-1])*(N-2*mid_index);\n\t\t\t\t\t\t--mid_index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//???????????????\n\t\t\t\t\t//???(mid??????)?????°-????????°=(N-mid_index_x)-mid_index_x\n\t\t\t\t\tdiff += (S[mid_index] - S[mid_index-1])*(N-2*mid_index);\n\t\t\t\t\t--mid_index;\n\t\t\t\t}\n\t#ifdef DEBUG\n\t\tprintf(\"mid_index = (%d)\\n\",mid_index);\n\t#endif\n\t\t\t\t//????????§???mid_index???0??´??????????????????\n\t\t\t\t//????????????????????¢????????´\n\t\t\t\tdiff -= std::abs(S[mid_index] - ignore_pos);\n\t\t\t\tdiff *= 2;\n\t#ifdef DEBUG\n\t\tprintf(\"diff = (%d)\\n\",diff);\n\t#endif\n\t\t\t\tif(((N-1)&1)==0){\n\t\t\t\t\t//round_x???[S[mid_index], S[mid_index+1]]?????????\n\t\t\t\t\tif(ignore_pos < S[mid_index]){\n\t\t\t\t\t\tdiff += (S[mid_index] - ignore_pos);\n\t\t\t\t\t\tround = S[mid_index];\n\t\t\t\t\t}\n\t\t\t\t\telse if(ignore_pos <= S[mid_index+1]){\n\t\t\t\t\t\t//diff += 0;\n\t\t\t\t\t\tround = ignore_pos;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdiff += (ignore_pos - S[mid_index+1]);\n\t\t\t\t\t\tround = S[mid_index+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//????´????????????????????????¢\n\t\t\t\t\tdiff += std::abs(S[mid_index] - ignore_pos);\n\t\t\t\t\tround = S[mid_index];\n\t\t\t\t}\n\t\t\t};\n\t\tint32_t round_x, round_y;\n\t\tint64_t diff_x, diff_y;\n\t\trun(round_x, diff_x, mid_diff_x, X[ignore], sX);\n\t\trun(round_y, diff_y, mid_diff_y, Y[ignore], sY);\n\t#ifdef DEBUG\n\t\tprintf(\"ignore = (%d)\\n\",ignore);\n\t\tprintf(\"round  = (%d,%d)\\n\",round_x, round_y);\n\t\tprintf(\"diff   = (%ld,%ld)\\n\",diff_x, diff_y); \n\t#endif\n\t\tauto diff_total = diff_x + diff_y;\n\t\tif ((diff_total < diff_min) ||\n\t\t    (\n\t\t\t\tdiff_total == diff_min &&\n\t\t\t\tstd::make_pair(round_x, round_y) < std::make_pair(round_b_x, round_b_y)\n\t\t    )\n\t\t    ){\n\t\t\tdiff_min = diff_x + diff_y;\n\t\t\tround_b_x = round_x;\n\t\t\tround_b_y = round_y;\n\t\t}\n\t}\n\t\n\tstd::cout << diff_min << endl\n\t << round_b_x << ' ' << round_b_y << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nint sx[100000];\nint sy[100000];\nlong long abs(long long a){return a>=0?a:-a;}\nlong long max(long long a,long long b){return a>b?a:b;}\nint main(){\n\tint w,h,n,i,j,k;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&sx[i],&sy[i]);\n\t\tx[i]=sx[i];\n\t\ty[i]=sy[i];\n\t}\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%d %d\\n\",x[0],y[0]);\n\t\treturn 0;\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tint m=(n-1)/2;\n\tlong long ans=1000000000000000LL;\n\tint ax,ay;\n\tfor(i=m;i<=m+1;i++){\n\t\tfor(j=m;j<=m+1;j++){\n\t\t\tlong long res=0;\n\t\t\tlong long mx=0;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tlong long dis=abs(sx[k]-x[i])+abs(sy[k]-y[j]);\n\t\t\t\tres+=dis*2;\n\t\t\t\tmx=max(mx,dis);\n\t\t\t}\n\t\t\tres-=mx;\n\t\t\tif(res<ans){\n\t\t\t\tans=res;\n\t\t\t\tax=x[i];\n\t\t\t\tay=y[j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,ax,ay);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nint X[100000],Y[100000];\nint main() {\n\tint W,H,N;\n\tlong long int sumX=0,sumY=0;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&X[i],&Y[i]);\n\t\tsumX+=X[i]*2,sumY+=Y[i]*2;\n\t}\n\tlong long int ans=1LL<<62;\n\tint ansX=1<<30,ansY=1<<30;\n\tfor(int i=0;i<N;i++) {\n\t\tint x=(sumX-X[i])/(2*N-1);\n\t\tint y=(sumY-Y[i])/(2*N-1);\n\t\tlong long int maxd=0;\n\t\tfor(int dx=-1;dx<=1;dx++)\n\t    for(int dy=-1;dy<=1;dy++) {\n\t\t\tlong long int d=0;\n\t\t\tif(1>(x+dx)||(x+dx)>W||1>(y+dy)||(y+dy)>H) continue;\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\td+=(abs(x+dx-X[j])+abs(y+dy-Y[j]))*2;\n\t\t\t}\n\t\t\td-=(abs(x+dx-X[i])+abs(y+dy-Y[i]));\n\t\t\tif(ans==d) {\n\t\t\t\tif(ansX>(x+dx)) {\n\t\t\t\t\tansX=(x+dx),ansY=(y+dy);\n\t\t\t\t}else if (ansX==(x+dx)) {\n\t\t\t\t\tif(ansY>(y+dy)) ansY=(y+dy);\n\t\t\t\t}\n\t\t\t}else if(ans>d) {\n\t\t\t\tansX=(x+dx),ansY=(y+dy),ans=d;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%d %d\\n\",ansX,ansY);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n\t\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nint p[100000],q[100000];\nvoid Calc(int n,pii pos[],ll ans[],int start[]){\n\tsort(pos,pos+n);\n\tint c=0,last=-1;\n\tREP(i,n){\n\t\tif(last!=pos[i].first){\n\t\t\tp[c]=last=pos[i].first;\n\t\t\tq[c++]=0;\n\t\t}\n\t\tq[c-1]++;\n\t}\n\tll lc=q[0],rc=n-lc,cost=0;\n\tFOR(i,1,c)\n\t\tcost+=ll(q[i])*(p[i]-p[0]);\n\tint k=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\twhile(k<c-1){\n\t\t\tint t=k+1;\n\t\t\tll plus=lc*(p[t]-p[k]);\n\t\t\tll minus=rc*(p[t]-p[k]);\n\t\t\tif(cost*2-abs(pos[i].first-p[k])\n\t\t\t\t>(cost+plus-minus)*2-abs(pos[i].first-p[t])){\n\t\t\t\t\tk++;\n\t\t\t\t\tlc+=q[t];\n\t\t\t\t\trc-=q[t];\n\t\t\t\t\tcost+=plus-minus;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tint j=pos[i].second;\n\t\tans[j]=cost*2-abs(pos[i].first-p[k]);\n\t\tstart[j]=p[k];\n\t}\n}\n\npii xs[100000],ys[100000];\nll xAns[100000],yAns[100000];\nint xSt[100000],ySt[100000];\n\ntypedef pair<ll,pii> Answer;\n\nint main(){\n\tread(),read();\n\tint n=read();\n\tREP(i,n){\n\t\txs[i]=MP(read(),i);\n\t\tys[i]=MP(read(),i);\n\t}\n\tCalc(n,xs,xAns,xSt);\n\tCalc(n,ys,yAns,ySt);\n\tAnswer ans=MP(LLONG_MAX,MP(0,0));\n\tREP(i,n){\n\t\tAnswer a=MP(xAns[i]+yAns[i],MP(xSt[i],ySt[i]));\n\t\tans=min(ans,a);\n\t}\n\tprintf(\"%lld\\n\",ans.first);\n\tprintf(\"%d %d\\n\",ans.second.first,ans.second.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nconst ll INF = 9009009009009009009;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(ps[i].first-x) + std::abs(ps[i].second-y);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    std::sort(Y.begin(), Y.end());\n\n    ll xs[2], ys[2];\n    xs[0] = X[(N-1)/2];\n    xs[1] = X[(N+1)/2];\n    \n    ys[0] = Y[(N-1)/2];\n    ys[1] = Y[(N+1)/2];\n    \n    ll min_cost = INF, x = INF, y = INF;\n    REP(i, 2){\n        REP(j, 2){\n            ll cost = work(xs[i], ys[j]);\n            // printf(\"%lld, %lld, %lld\\n\", xs[i], ys[j], work(xs[i], ys[j]));\n            if(cost < min_cost){\n                min_cost = cost;\n                x = xs[i];\n                y = ys[j];\n            }else if(cost == min_cost){\n                if(xs[i] < x){\n                    x = xs[i];\n                }else if(xs[i] == x){\n                    if(ys[j] < y){\n                        y = ys[j];\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", min_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint px[100001],py[100001],sx[100001],sy[100001];\nint main(){\n    int w,h,n;\n    cin>>w>>h>>n;\n    ll x,y;\n    for(int i=0;i<n;++i){\n        cin>>x>>y;\n        px[i]=sx[i]=x;py[i]=sy[i]=y;\n    }\n    sort(sx,sx+n);\n    sort(sy,sy+n);\n    int posx[4]={sx[n/2-1],sx[n/2-1],sx[n/2],sx[n/2]};\n    int posy[4]={sy[n/2-1],sy[n/2],sy[n/2-1],sy[n/2]};\n    ll ans[4]={0};\n    ll mx[4]={0};\n    for(int i=0;i<n;++i){\n        for(int j=0;j<4;++j){\n            ll tx=abs(posx[j]-px[i]),ty=abs(posy[j]-py[i]);\n            ans[j] +=(tx+ty)*2;mx[j]=mx[j]>tx+ty?mx[j]:tx+ty;\n        }\n    }\n    ll mn=9223372036854775800;\n    for(int i=0;i<4;++i){\n        if(mn<=ans[i]-mx[i]) continue;\n        mn=ans[i]-mx[i];x=posx[i];y=posy[i];\n    }\n    cout<<mn<<endl;\n    cout<<x<<\" \"<<y<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint w, h, n;\ntypedef pair<int, int> P;\nvector<P> v;\nvector<int> x;\nvector<int> y;\n\nint main(){\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tfor(int i=0; i<n; ++i){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tv.push_back(P(a, b));\n\t\tx.push_back(a);\n\t\ty.push_back(b);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tint mx[2], my[2];\n\tif(n % 2 == 1){\n\t\tmx[0] = mx[1] = x[(n-1)/2];\n\t\tmy[0] = my[1] = y[(n-1)/2];\n\t}else{\n\t\tmx[0] = x[n/2-1];\n\t\tmx[1] = x[n/2];\n\t\tmy[0] = y[n/2-1];\n\t\tmy[1] = y[n/2];\n\t}\n\tlong long int ans;\n\tfor(int i=0; i<n; ++i){\n\t\tans += abs(x[i] - mx[0]);\n\t\tans += abs(y[i] - my[0]);\n\t}\n\tans *= 2;\n\tint ma = 0, ax, ay;\n\tfor(int i=0; i<2; ++i)\n\t\tfor(int j=0; j<2; ++j)\n\t\t\tfor(int k=0; k<n; ++k){\n\t\t\t\tint d = abs(v[k].first - mx[i]) + abs(v[k].second - my[j]);\n\t\t\t\tif(ma < d){\n\t\t\t\t\tma = d;\n\t\t\t\t\tax = mx[i];\n\t\t\t\t\tay = my[j];\n\t\t\t\t}\n\t\t\t}\n\tans -= ma;\n\tprintf(\"%lld\\n%d %d\\n\", ans, ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAX_H 1000000000 //10^9\n#define MAX_W 1000000000 //10^9\n#define MAX_N 100000 //10^5\n#define mp make_pair\n#define INF 1001001001\n#define LLINF 1001001001001001001\n#define llint long long int\n#define ppp pair<int, pair<int,int> >\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n ; i++)\nusing namespace std;\nllint homesx[MAX_N];\nllint homesy[MAX_N];\nllint homesxs[MAX_N];\nllint homesys[MAX_N];\nint main(void){\n    // Your code here!\n    llint W,H,N;\n    scanf(\"%lld %lld %lld\",&W,&H,&N);\n    rep(i,N){\n        llint X,Y;\n        scanf(\"%lld %lld\",&X,&Y);X--;Y--;\n        homesx[i]=X;homesy[i]=Y;\n        homesxs[i]=X;homesys[i]=Y;\n    }\n    \n    //X座標について求める\n    if(N==1){printf(\"%lld\\n%lld %lld\\n\",0,homesx[0]+1,homesy[0]+1);return 0;}\n    llint ans=LLINF;\n    llint zans[2]={-1,-1};\n    sort(&homesxs[0], &homesxs[N]);\n    sort(&homesys[0], &homesys[N]);\n    llint Center1=(llint)(N/2)-1;\n    llint Center2=(llint)(N/2);\n    \n    llint sum=0;llint maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n    if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center2];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center2];}\n    printf(\"%lld\\n%lld %lld\\n\",ans,zans[0]+1,zans[1]+1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define N 100025\n#define ln 1e16\n#define oo 111539786\n#define Pa pair < int, int >\n#define Pi pair < int, Pa >\n\nusing namespace std;\n\nll ans = ln, SumX[N], SumY[N];\nint n, X[N], Y[N], w, h, posX, posY;\nPa a[N];\n\nvoid Get_ans(int x, int y)\n{\n    ll Sum = 0, Max = -ln;\n    for(int i=1; i<=n; i++)\n    {\n        Sum += ((ll)abs(x - a[i].f) + abs(y - a[i].s)) * 2;\n        Max = max(Max, (ll)abs(x - a[i].f) + abs(y - a[i].s));\n    }\n    Sum -= Max;\n    if(Sum < ans)\n    {\n        ans = Sum;\n        posX = x;\n        posY = y;\n    }\n}\n\nint main()\n{\n    //filein(\"SANTA.inp\");    fileout(\"SANTA.out\");\n    cin >> w >> h >> n;\n    for(int i=1; i<=n; i++)\n    {\n        cin >> X[i] >> Y[i];\n        a[i] = mp(X[i], Y[i]);\n    }\n    sort(X+1, X+n+1);\n    sort(Y+1, Y+n+1);\n    for(int i=1; i<=n; i++)\n    {\n        SumX[i] = SumX[i-1] + X[i];\n        SumY[i] = SumY[i-1] + Y[i];\n    }\n    Get_ans(X[(n+1)/2], Y[(n+1)/2]);\n    if(n % 2 == 0)\n    {\n        Get_ans(X[(n+1)/2], Y[n/2+1]);\n        Get_ans(X[n/2+1], Y[(n+1)/2]);\n        Get_ans(X[n/2+1], Y[n/2+1]);\n    }\n    cout << ans << endl;\n    cout << posX << \" \" << posY << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\nint x[100005],y[100005];\nint a[100005],b[1000005];\nint main(){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<k;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=0;i<k;i++) a[i]=x[i],b[i]=y[i];\n\tsort(a,a+k); sort(b,b+k);\n\tll ret=1e15; int rx,ry;\n\tfor(int i=(k-1)/2;i<=k/2;i++)\n\t{\n\t\tfor(int j=(k-1)/2;j<=k/2;j++)\n\t\t{\n\t\t\tll sum=0LL,gen=0LL;\n\t\t\tfor(int s=0;s<k;s++)\n\t\t\t{\n\t\t\t\tsum+=2LL*(abs(x[s]-a[i])+abs(y[s]-b[j]));\n\t\t\t\tgen=max(gen,1LL*(abs(x[s]-a[i])+abs(y[s]-b[j])));\n\t\t\t}\n\t\t\tif(sum-gen<ret){ rx=a[i]; ry=b[i]; ret=sum-gen;}\n\t\t\telse if(sum-gen==ret && mp(rx,ry)>mp(a[i],b[i])) rx=a[i],ry=b[i];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int g = 0; g < mx.size(); g++) {\n\t\tfor (int h = 0; h < my.size(); h++) {\n\t\t\tsum = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\td[i] = (abs(mx[g] - ex[i]) + abs(my[h] - ey[i]));\n\t\t\t\tsum += d[i] * 2;\n\t\t\t}\n\t\t\tsort(d, d + n);\n\t\t\tsum -= d[n - 1];\n\t\t\tif (minx > sum) { minx = sum; cx = mx[g]; cy = my[h]; }\n\t\t}\n\t}\n\t\n\tcout << minx << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    int W, H; cin >> W >> H;\n\n    int N; cin >> N;\n\n    rep(i, N) {\n        cin >> X[i];\n        cin >> Y[i];\n        pos[i] = pii(X[i], Y[i]);\n    }\n\n    sort(X, X + N);\n    sort(Y, Y + N);\n\n    int x, y;\n    \n    if (N % 2 == 0) {\n        int ans = inf;\n        int ansx = -1, ansy = -1;\n\n        rep(i, 2) {\n            rep(j, 2) {\n                int x = X[N / 2 - i], y = Y[N / 2 - j];\n                \n                int sum = 0;\n                int ma = 0;\n                rep(k, N) {\n                    int a = abs(x - pos[k].fst) + abs(y - pos[k].scd);\n                    sum += a * 2;\n                    chmax(ma, a);\n                }\n                sum -= ma;\n\n                if (ans >= sum) {\n                    ans = sum;\n                    ansx = x;\n                    ansy = y;\n                }\n            }\n        }\n\n        cout << ans << endl;\n        cout << ansx << ' ' << ansy << endl;\n    } else {\n        x = y = N / 2;\n\n        int ma = 0;\n        int v = 0;\n\n        rep(i, N) {\n            int a = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n            v += a * 2;\n            ma = max(ma, a);\n        }\n        v -= ma;\n\n        cout << v << endl;\n        cout << x << ' ' << y << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n  vector<pair<int, int>> p(n);\n  vector<int> x(n), y(n);\n  for (int i : range(n)) cin >> p[i].first >> p[i].second;\n  for (int i : range(n)) x[i] = p[i].first, y[i] = p[i].second;\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  long long res = 1e18;\n  int rx = -1, ry = -1;\n  for (int i : range(max(0, n / 2 - 3), n / 2 + 3)) {\n    for (int j : range(max(0, n / 2 - 3), n / 2 + 3)) {\n      int xx = x[i], yy = y[j];\n      long long r = 0;\n      for (int k : range(n)) r += abs(x[k] - xx) + abs(y[k] - yy);\n      int d = 0;\n      for (int k : range(n)) d = max(d, abs(p[k].first - xx) + abs(p[k].second - yy));\n      r = 2 * r - d;\n      if (res > r || (res == r && (xx < rx || (xx == rx && yy < ry)))) {\n        res = r;\n        rx = xx;\n        ry = yy;\n      }\n    }\n  }\n  cout << res << endl << rx << \" \" << ry << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\n \nint N, W, H, x[100000], y[100000];\nint cpx[100000], cpy[100000];\n\n \nint main()\n{\n  scanf(\"%d %d\", &W, &H);\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d\", &x[i], &y[i]);\n    cpx[i] = x[i], cpy[i] = y[i];\n  }\n  int lowx = 0, highx = 1 << 30;\n\n  sort( x, x + N);\n  sort( y, y + N);\n\n  int center = (N - 1) / 2;\n  int64 ret = 1LL << 60, xx, yy;\n  for(int i = center; i < center + 3; i++){ // 一緒になりそうなところ\n    for(int j = center; j < center + 3; j++){ // 一緒になりそうなところ\n      int64 dist = 0LL, big = 0LL, cost;\n      for(int k = 0; k < N; k++){\n        cost = llabs( x[i] - cpx[k]) + llabs( y[j] - cpy[k]);\n        dist += cost * 2;\n        big = max( cost, big);\n      }\n      dist -= big;\n      if(ret > dist){\n        ret = dist;\n        xx = x[i];\n        yy = y[j];\n      }\n    }\n  }\n  cout << ret << endl;\n  cout << xx << \" \" << yy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r - 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tcin >> N;\n\tvector<pair<long long int, long long int>>place(N);\n\tvector<long long int>x(N);\n\tvector<long long int>y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tplace[i].first = x[i];\n\t\tplace[i].second = y[i];\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tlong long int cy, cx;\n\tcy = y[(N-1) / 2];\n\tcx = x[(N-1) / 2];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tK += (abs(place[i].first - cx) + abs(place[i].second - cy)) * 2;\n\t\tM = max(M, (abs(place[i].first - cx) + abs(place[i].second - cy)));\n\t}\n\tcout << K - M << endl;\n\tcout << cx << \" \" << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef long long int LL;\nconst LL INF = 9e18;\n\nint w, h, n;\n\nVP homes;\nVI homes_x, homes_y;\nint candidate_x[2], candidate_y[2];\n\nPII ans_loc;\nLL ans_dist = INF;\n\nint main()\n{\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0; i < n; i++){\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    homes.push_back(make_pair(x, y));\n    homes_x.push_back(x);\n    homes_y.push_back(y);\n  }\n\n  sort(homes_x.begin(), homes_x.end());\n  sort(homes_y.begin(), homes_y.end());\n\n  candidate_x[0] = homes_x[(homes_x.size() - 1) / 2];\n  candidate_x[1] = homes_x[homes_x.size() / 2];\n  candidate_y[0] = homes_y[(homes_y.size() - 1) / 2];\n  candidate_y[1] = homes_y[homes_y.size() / 2];\n\n  for(int i = 0; i < 4; i++){\n    LL mx = 0, sum = 0;\n    for(int j = 0; j < homes.size(); j++){\n      LL dist = abs(homes[j].first - candidate_x[i & 2]) + abs(homes[j].second - candidate_y[i & 1]);\n      sum += dist * 2;\n      mx = max(mx, dist);\n    }    \n    sum -= mx;\n\n    if(sum < ans_dist){\n      ans_dist = sum;\n      ans_loc = make_pair(candidate_x[i & 2], candidate_y[i & 1]);\n    }\n  }\n\n  printf(\"%lld\\n%d %d\\n\", ans_dist, ans_loc.first, ans_loc.second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N=100001;\nint H,W;\nint N;\nint XS[MAX_N];\nint YS[MAX_N];\nint curLast;\nvector<int> xnums;\nvector<int> ynums;\n// ¶a\nll leftDistSumX[MAX_N];\nll leftDistSumY[MAX_N];\n// Ea\nll rightDistSumX[MAX_N];\nll rightDistSumY[MAX_N];\nmap<int,int> xStartPos;\nmap<int,int> yStartPos;\n\nll check(ll s,bool isX=true){\n    ll sum=0;\n    // ÀWsªÇÌ_ÆÇÌ_ÌÔÉ é©ð©Â¯é\n    // »Ìîñð³ÉAÚ®ÊðvZ\n    if(isX){\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(xnums.begin(),xnums.end(),s);\n        if(it==xnums.end())sum=leftDistSumX[N-1]+rightDistSumX[N-1]+abs(s-xnums[N-1]);\n        else if(it==xnums.begin())sum=leftDistSumX[0]+rightDistSumX[0]+abs(s-xnums[0]);\n        else{\n            sum=leftDistSumX[it-xnums.begin()]+rightDistSumX[it-xnums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=*it-s;\n                ll leftCnt=xStartPos[*it];\n                ll rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-XS[curLast]);\n    }\n    else{\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(ynums.begin(),ynums.end(),s);\n        if(it==ynums.end())sum=leftDistSumY[N-1]+rightDistSumY[N-1]+abs(s-ynums[N-1]);\n        else if(it==ynums.begin())sum=leftDistSumY[0]+rightDistSumY[0]+abs(s-ynums[0]);\n        else{\n            sum=leftDistSumY[it-ynums.begin()]+rightDistSumY[it-ynums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=-s+*it;\n                ll leftCnt=yStartPos[*it];\n                ll rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-YS[curLast]);\n    }\n    return sum;\n}\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>XS[i]>>YS[i];\n    // xûüÌÝÏa\n    for(int i=0;i<N;i++)xnums.push_back(XS[i]);\n    sort(xnums.begin(),xnums.end());\n    for(int i=N-1;i>=0;i--)xStartPos[xnums[i]]=i;\n    ll baseLeftSumX=0;\n    ll baseRightSumX=0;\n    for(int i=1;i<N;i++)baseRightSumX+=abs(xnums[i]-xnums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumX[i]=baseRightSumX;\n        leftDistSumX[i]=baseLeftSumX;\n        if(i!=N-1){\n            baseRightSumX-=abs(xnums[i]-xnums[i+1])*(N-i-1);\n            baseLeftSumX+=abs(xnums[i]-xnums[i+1])*(i+1);\n        }\n    }\n    // yûüÌÝÏa\n    for(int i=0;i<N;i++)ynums.push_back(YS[i]);\n    sort(ynums.begin(),ynums.end());\n    for(int i=N-1;i>=0;i--)yStartPos[ynums[i]]=i;\n    ll baseLeftSumY=0;\n    ll baseRightSumY=0;\n    for(int i=1;i<N;i++)baseRightSumY+=abs(ynums[i]-ynums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumY[i]=baseRightSumY;\n        leftDistSumY[i]=baseLeftSumY;\n        if(i!=N-1){\n            baseRightSumY-=abs(ynums[i]-ynums[i+1])*(N-i-1);\n            baseLeftSumY+=abs(ynums[i]-ynums[i+1])*(i+1);\n        }\n    }\n\n    // Ç±ðÅãÉKêéêÉ·é©Åêí¯\n    ll ret=-1;\n    ll lastX,lastY;\n    ll candX[3],candY[3];\n    for(int lp=0;lp<N;lp++){\n        curLast=lp;\n        // x\n        int cnt=1000;\n        ll ub=1000000000;\n        ll lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1)<check(mid2))ub=mid2;\n            else if(check(mid1)>check(mid2))lb=mid1;\n            else lb=mid1;\n        }\n        candX[0]=lb;\n        candX[1]=lb+1;\n        candX[2]=ub;\n        ll minXVal=-1;\n        ll rx;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candX[i]);\n            if(minXVal==-1||tmp<minXVal){\n                minXVal=tmp;\n                rx=candX[i];\n            }\n        }\n        // y\n        cnt=1000;\n        ub=1000000000;\n        lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1,false)<check(mid2,false))ub=mid2;\n            else if(check(mid1,false)>check(mid2,false))lb=mid1;\n            else lb=mid1;\n        }\n        candY[0]=lb;\n        candY[1]=lb+1;\n        candY[2]=ub;\n        ll minYVal=-1;\n        ll ry;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candY[i],false);\n            if(minYVal==-1||tmp<minYVal){\n                minYVal=tmp;\n                ry=candY[i];\n            }\n        }\n        ll res=minXVal+minYVal;\n        if(ret==-1||res<ret){\n            ret=res;\n            lastX=rx;\n            lastY=ry;\n        }\n        else if(res==ret){\n            if(lastX>rx){\n                lastX=rx;\n                lastY=ry;\n            }\n            else if(lastX==rx){\n                if(lastY>ry){\n                    lastX=rx;\n                    lastY=ry;\n                }\n            }\n        }\n    }\n    std::cout<<ret<<endl;\n    std::cout<<lastX<<\" \"<<lastY<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    int x;\n    int y;\n    p(){}\n    P(int p1,int p2){\n        x=p1;\n        y=p2;\n    }\n};\n\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<P> pos;\n\nint dist(int x,int y){\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].x);\n        int disy=abs(y-pos[i].y);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(P(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > &in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int W,H,N;\n    cin >> W >> H >> N;\n    vector<LL> X, Y;\n    vector<pair<LL,LL> > XY;\n    for(int i=0; i<N; i++){\n        LL x,y;\n        cin >> x >> y;\n        X.push_back(x);\n        Y.push_back(y);\n        XY.push_back(MP(x, y));\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    if(N%2 == 1){\n        LL ansX = X[X.size()/2];\n        LL ansY = Y[Y.size()/2];\n        LL ans = 0;\n        LL m = 0;\n        for(int i=0; i<N; i++){\n            ans += abs(ansX - XY[i].first) + abs(ansY - XY[i].second);\n            m = max(m, abs(ansX - XY[i].first) + abs(ansY - XY[i].second));\n        }\n        ans = ans * 2 - m;\n        cout << ans << endl << ansX << \" \" << ansY << endl;\n    }\n    else{\n        LL ansX = X[X.size()/2];\n        LL ansY = Y[Y.size()/2];\n        LL ans = LL_MAX;\n        pair<LL,LL> A;\n        LL tmp, m;\n\n        ansX = X[X.size()/2-1];\n        ansY = Y[Y.size()/2-1];\n        tmp = 0;\n        m = 0;\n        for(int i=0; i<N; i++){\n            tmp += abs(ansX - XY[i].first) + abs(ansY - XY[i].second);\n            m = max(m, abs(ansX - XY[i].first) + abs(ansY - XY[i].second));\n        }\n        tmp = tmp * 2 - m;\n        if(ans > tmp){\n            ans = tmp;\n            A = MP(ansX, ansY);\n        }\n\n        ansX = X[X.size()/2-1];\n        ansY = Y[Y.size()/2];\n        tmp = 0;\n        m = 0;\n        for(int i=0; i<N; i++){\n            tmp += abs(ansX - XY[i].first) + abs(ansY - XY[i].second);\n            m = max(m, abs(ansX - XY[i].first) + abs(ansY - XY[i].second));\n        }\n        tmp = tmp * 2 - m;\n        if(ans > tmp){\n            ans = tmp;\n            A = MP(ansX, ansY);\n        }\n\n        ansX = X[X.size()/2];\n        ansY = Y[Y.size()/2-1];\n        tmp = 0;\n        m = 0;\n        for(int i=0; i<N; i++){\n            tmp += abs(ansX - XY[i].first) + abs(ansY - XY[i].second);\n            m = max(m, abs(ansX - XY[i].first) + abs(ansY - XY[i].second));\n        }\n        tmp = tmp * 2 - m;\n        if(ans > tmp){\n            ans = tmp;\n            A = MP(ansX, ansY);\n        }\n\n        ansX = X[X.size()/2];\n        ansY = Y[Y.size()/2];\n        tmp = 0;\n        m = 0;\n        for(int i=0; i<N; i++){\n            tmp += abs(ansX - XY[i].first) + abs(ansY - XY[i].second);\n            m = max(m, abs(ansX - XY[i].first) + abs(ansY - XY[i].second));\n        }\n        tmp = tmp * 2 - m;\n        if(ans > tmp){\n            ans = tmp;\n            A = MP(ansX, ansY);\n        }\n\n        cout << ans << endl << A.first << \" \" << A.second << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    printf(\"%ld %ld\\n\",B[n/2],B[n/2-1]);\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]>b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pli> precalc(const vector<pair<ll,ll> >  in){\n  vector<pli> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //úlðvZ\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define int long long\n\nconst int dx[2] = { 0, 1 }, dy[2] = { 0, 1 };\n\nint W, H, N, X[100000], Y[100000];\nint X_[100000], Y_[100000];\n\nint Calculate(int x, int y)\n{\n\tint res = 0;\n\tint ma = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tma = max(ma, abs(x - X[i]) + abs(y - Y[i]));\n\t\tres += 2 * (abs(x - X[i]) + abs(y - Y[i]));\n\t}\n\treturn res - ma;\n}\n\nsigned main()\n{\n\tcin >> W >> H >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tX_[i] = X[i]; Y_[i] = Y[i];\n\t}\n\tsort(X_, X_ + N);\n\tsort(Y_, Y_ + N);\n\tint idX = (N - 1) / 2, idY = (N - 1) / 2;\n\tint ansX, ansY, mi = LLONG_MAX / 2;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tint cost = Calculate(X_[idX + dx[i]], Y_[idY + dy[j]]);\n\t\t\tif (mi > cost)\n\t\t\t{\n\t\t\t\tmi = cost;\n\t\t\t\tansX = X_[idX + dx[i]]; ansY = Y_[idY + dy[j]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", mi, ansX, ansY);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int) 1e5 + 5;\nconst long long inf = (long long)1e18;\n\nint n, W, H;\nint x[maxn], y[maxn];\nvector<int> xx, yy;\nint _x, _y;\nlong long ans;\n\nlong long calc(int X, int Y) {\n    long long res = 0;\n    int mx = 0;\n    for (int i = 0; i < n; i ++) {\n        res += 2LL * (abs(X - x[i]) + abs(Y - y[i]));\n        mx = max(mx, abs(X - x[i]) + abs(Y - y[i]));\n    }\n    return res - mx;\n}\n\nint main() {\n    ///freopen(\"test.txt\", \"r\", stdin);\n    cin >> W >> H >> n;\n    for (int i = 0; i < n; i ++) {\n        cin >> x[i] >> y[i];\n        xx.push_back(x[i]);\n        yy.push_back(y[i]);\n    }\n    sort(xx.begin(), xx.end());\n    sort(yy.begin(), yy.end());\n\n    int md = n / 2;\n    int lo = max(0, md - 1);\n    int hi = min(n - 1, md + 1);\n    ans = inf;\n    for (int i = lo; i <= hi; i ++) {\n        for (int j = lo; j <= hi; j ++) {\n            ///cout << i << ' ' << j << ' ' << xx[i] << ' ' << yy[j] << endl;\n            long long tmp = calc(xx[i], yy[j]);\n            if(tmp < ans) {\n                ans = tmp;\n                _x = xx[i];\n                _y = yy[j];\n            }\n        }\n    }\n    cout << ans << '\\n' << _x << ' ' << _y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    if (n >= 5)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N=100001;\nint H,W;\nint N;\nint XS[MAX_N];\nint YS[MAX_N];\nint curLast;\nvector<int> xnums;\nvector<int> ynums;\n// ¶a\nll leftDistSumX[MAX_N];\nll leftDistSumY[MAX_N];\n// Ea\nll rightDistSumX[MAX_N];\nll rightDistSumY[MAX_N];\nmap<int,int> xStartPos;\nmap<int,int> yStartPos;\n\nll check(ll s,bool isX=true){\n    ll sum=0;\n    // ÀWsªÇÌ_ÆÇÌ_ÌÔÉ é©ð©Â¯é\n    // »Ìîñð³ÉAÚ®ÊðvZ\n    if(isX){\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(xnums.begin(),xnums.end(),s);\n        if(it==xnums.end())sum=leftDistSumX[N-1]+rightDistSumX[N-1]+abs(s-xnums[N-1]);\n        else if(it==xnums.begin())sum=leftDistSumX[0]+rightDistSumX[0]+abs(s-xnums[0]);\n        else{\n            sum=leftDistSumX[it-xnums.begin()]+rightDistSumX[it-xnums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=*it-s;\n                ll leftCnt=xStartPos[*it];\n                ll rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-XS[curLast]);\n    }\n    else{\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(ynums.begin(),ynums.end(),s);\n        if(it==ynums.end())sum=leftDistSumY[N-1]+rightDistSumY[N-1]+abs(s-ynums[N-1]);\n        else if(it==ynums.begin())sum=leftDistSumY[0]+rightDistSumY[0]+abs(s-ynums[0]);\n        else{\n            sum=leftDistSumY[it-ynums.begin()]+rightDistSumY[it-ynums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=-s+*it;\n                ll leftCnt=yStartPos[*it];\n                ll rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-YS[curLast]);\n    }\n    return sum;\n}\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>XS[i]>>YS[i];\n    // xûüÌÝÏa\n    for(int i=0;i<N;i++)xnums.push_back(XS[i]);\n    sort(xnums.begin(),xnums.end());\n    for(int i=N-1;i>=0;i--)xStartPos[xnums[i]]=i;\n    ll baseLeftSumX=0;\n    ll baseRightSumX=0;\n    for(int i=1;i<N;i++)baseRightSumX+=abs(xnums[i]-xnums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumX[i]=baseRightSumX;\n        leftDistSumX[i]=baseLeftSumX;\n        if(i!=N-1){\n            baseRightSumX-=(ll)abs(xnums[i]-xnums[i+1])*(N-i-1);\n            baseLeftSumX+=(ll)abs(xnums[i]-xnums[i+1])*(i+1);\n        }\n    }\n    // yûüÌÝÏa\n    for(int i=0;i<N;i++)ynums.push_back(YS[i]);\n    sort(ynums.begin(),ynums.end());\n    for(int i=N-1;i>=0;i--)yStartPos[ynums[i]]=i;\n    ll baseLeftSumY=0;\n    ll baseRightSumY=0;\n    for(int i=1;i<N;i++)baseRightSumY+=abs(ynums[i]-ynums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumY[i]=baseRightSumY;\n        leftDistSumY[i]=baseLeftSumY;\n        if(i!=N-1){\n            baseRightSumY-=(ll)abs(ynums[i]-ynums[i+1])*(N-i-1);\n            baseLeftSumY+=(ll)abs(ynums[i]-ynums[i+1])*(i+1);\n        }\n    }\n\n    // Ç±ðÅãÉKêéêÉ·é©Åêí¯\n    ll ret=-1;\n    ll lastX,lastY;\n    ll candX[3],candY[3];\n    for(int lp=0;lp<N;lp++){\n        curLast=lp;\n        // x\n        ll ub=1000000000;\n        ll lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1)<check(mid2))ub=mid2;\n            else if(check(mid1)>check(mid2))lb=mid1;\n            else lb=mid1;\n        }\n        candX[0]=lb;\n        candX[1]=lb+1;\n        candX[2]=ub;\n        ll minXVal=-1;\n        ll rx;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candX[i]);\n            if(minXVal==-1||tmp<minXVal){\n                minXVal=tmp;\n                rx=candX[i];\n            }\n        }\n        // y\n        ub=1000000000;\n        lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1,false)<check(mid2,false))ub=mid2;\n            else if(check(mid1,false)>check(mid2,false))lb=mid1;\n            else lb=mid1;\n        }\n        candY[0]=lb;\n        candY[1]=lb+1;\n        candY[2]=ub;\n        ll minYVal=-1;\n        ll ry;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candY[i],false);\n            if(minYVal==-1||tmp<minYVal){\n                minYVal=tmp;\n                ry=candY[i];\n            }\n        }\n        ll res=minXVal+minYVal;\n        if(ret==-1||res<ret){\n            ret=res;\n            lastX=rx;\n            lastY=ry;\n        }\n        else if(res==ret){\n            if(lastX>rx){\n                lastX=rx;\n                lastY=ry;\n            }\n            else if(lastX==rx){\n                if(lastY>ry){\n                    lastX=rx;\n                    lastY=ry;\n                }\n            }\n        }\n    }\n    std::cout<<ret<<endl;\n    std::cout<<lastX<<\" \"<<lastY<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF=1LL<<61;\n\n// x0 に降りて、最後に x_last まで行くときの x 方向の総コスト\nll f(int x0,int x_last,int n,const int *x,const ll *x_sum){\n\tint p=lower_bound(x,x+n,x0)-x;\n\tll res=0;\n\tres+=(ll)p*x0-x_sum[p];                // x0 より左にある家のコスト\n\tres+=(x_sum[n]-x_sum[p])-(ll)(n-p)*x0; // x0 より右にある家のコスト\n\treturn 2*res-abs(x_last-x0);\n}\n\nvoid solve(int n,const int *x,int *x0,ll *ans){\n\tstatic int x_sorted[100000];\n\trep(i,n) x_sorted[i]=x[i];\n\tsort(x_sorted,x_sorted+n);\n\n\tstatic ll x_sum[100001];\n\trep(i,n) x_sum[i+1]=x_sum[i]+x_sorted[i];\n\n\trep(i,n){\n\t\tint lo=x[0],hi=x[n-1];\n\t\twhile(lo<hi){\n\t\t\tint mi1=(lo+hi)/2,mi2=mi1+1;\n\t\t\tif(f(mi1,x[i],n,x_sorted,x_sum)>f(mi2,x[i],n,x_sorted,x_sum)) lo=mi1+1; else hi=mi2-1;\n\t\t}\n\t\tx0[i]=lo;\n\t\tans[i]=f(lo,x[i],n,x_sorted,x_sum);\n\t}\n}\n\nint main(){\n\tint n; scanf(\"%*d%*d%d\",&n);\n\tstatic int x[100000],y[100000];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\t// x0[i] := ( 最後に家 i を訪れるとしたときの、最適な降りる位置の x 座標 )\n\t// ans_x[i] := ( 最後に家 i を訪れるとして、x0[i] に降りたときの x 方向の総コスト )\n\tstatic int x0[100000],y0[100000];\n\tstatic ll ans_x[100000],ans_y[100000];\n\tsolve(n,x,x0,ans_x);\n\tsolve(n,y,y0,ans_y);\n\n\tstatic ll ans[100000];\n\trep(i,n) ans[i]=ans_x[i]+ans_y[i];\n\n\tint i_ans=0;\n\trep(i,n){\n\t\tif(ans[i_ans]>ans[i]\n\t\t|| ans[i_ans]==ans[i] && x0[i_ans]>x0[i]\n\t\t|| ans[i_ans]==ans[i] && x0[i_ans]==x0[i] && y0[i_ans]>y0[i]) i_ans=i;\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans[i_ans],x0[i_ans],y0[i_ans]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint idx = (N-1)/2;\n\tll ans = inf;\n\tint ax = inf, ay = inf;\n\tfor (int d = -2; d <= 2; ++d) {\n\t\tif (idx+d < 0 || idx+d >= N) continue;\n\t\tint sx = X[idx+d], sy = Y[idx+d];\n\t\tvector<ll> a;\n\t\tREP(i, N) {\n\t\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t\t}\n\t\tsort( ALL(a) );\n\t\tll sum = a[N-1];\n\t\tREP(i, N-1) {\n\t\t\tsum += a[i]*2;\n\t\t}\n\t\tif (sum < ans || (sum <= ans && P(sx, sy) <= P(ax, ay))) {\n\t\t\tans = sum;\n\t\t\ttie(ax, ay) = P(sx, sy);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],x2[100000],y2[100000],n,ansx,ansy,w,h,l=0;\n  ll sumx=0,sumy=0,ans=1000000000000000,sum;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    x2[i]=x[i];\n    y2[i]=y[i];\n  }\n\n  sort(x,x+n);\n  sort(y,y+n);\n\n  for(int j=0;j<2;j++){\n    for(int k=0;k<2;k++){\n      sum=0;\n      for(int i=0;i<n;i++){\n\tl=max(l,abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]));\n\tsum+=(abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]))*2;\n      }\n      if(ans>sum-l){\n\tans=sum-l;\n\tansx=x[(n+j+1)/2-1];\n\tansy=y[(n+k+1)/2-1];\n      }\n    }\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint w, h;\nint n;\nvector<int> x, y;\nvector<int> sx, sy;\nint mx[4], my[4];\nint tmp[4];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> w >> h;\n    cin >> n;\n    rep(i, n) {\n        int xx, yy;\n        cin >> xx >> yy;\n        x.push_back(xx);\n        y.push_back(yy);\n    }\n    sx = x;\n    sy = y;\n    sort(all(sx));\n    sort(all(sy));\n    mx[0] = sx[(n - 1) / 2]; my[0] = sy[(n - 1) / 2];\n    mx[1] = sx[(n - 1) / 2]; my[1] = sy[n / 2];\n    mx[2] = sx[n / 2]; my[2] = sy[(n - 1) / 2];\n    mx[3] = sx[n / 2]; my[3] = sy[n / 2];\n    vector<int> dist1, dist2, dist3, dist4;\n    rep(i, n) {\n        dist1.push_back(abs(x[i] - mx[0]) + abs(y[i] - my[0]));\n        dist2.push_back(abs(x[i] - mx[1]) + abs(y[i] - my[1]));\n        dist3.push_back(abs(x[i] - mx[2]) + abs(y[i] - my[2]));\n        dist4.push_back(abs(x[i] - mx[3]) + abs(y[i] - my[3]));\n    }\n    sort(all(dist1));\n    sort(all(dist2));\n    sort(all(dist3));\n    sort(all(dist4));\n    rep(i, n - 1) {\n        tmp[0] += 2 * dist1[i];\n        tmp[1] += 2 * dist2[i];\n        tmp[2] += 2 * dist3[i];\n        tmp[3] += 2 * dist4[i];\n    }\n    tmp[0] += dist1[n - 1];\n    tmp[1] += dist2[n - 1];\n    tmp[2] += dist3[n - 1];\n    tmp[3] += dist4[n - 1];\n    int ans = 1e16;\n    int ansx = 0, ansy = 0;\n    rep(i, 4) {\n        if (tmp[i] < ans) {\n            ans = tmp[i];\n            ansx = mx[i];\n            ansy = my[i];\n        }\n    }\n    cout << ans << endl;\n    cout << ansx << ' ' << ansy << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n scanf(\"%d%d%d\",h,w,n);\n FOR(i,n) scanf(\"%lld%lld\",x+i,y+i);\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(cx,cx+n);\n sort(cy,cy+n);\n int mx[2],my[2];\n mx[0]=cx[n>>1];\n mx[1]=mx[0]+1;\n my[0]=cy[n>>1];\n my[1]=my[0]+1;\n ll mi=1000000000000000LL,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n printf(\"%lld\\n%lld %lld\\n\",mi,miX,miY);\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(v) v.begin(), v.end()\n\nint h, w;\nint n;\nint x[101010], y[101010];\nvector<int> X, Y;\n\nint main()\n{\n  cin >> h >> w;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n    X.push_back(x[i]);\n    Y.push_back(y[i]);\n  }\n\n  sort(all(X));\n  sort(all(Y));\n\n  X.erase(unique(all(X)), X.end());\n  Y.erase(unique(all(Y)), Y.end());\n\n  vector<int> ax, ay;\n  ax.push_back(X[X.size() / 2]);\n  ax.push_back(X[(X.size() - 1) / 2]);\n  ay.push_back(Y[Y.size() / 2]);\n  ay.push_back(Y[(Y.size() - 1) / 2]);\n  \n  sort(all(ax)); sort(all(ay));\n  long long ans = 1e18, max_d = 0;\n  int ans_x, ans_y;\n\n  for (int i = 0; i < ax.size(); i++){\n    for (int j = 0; j < ay.size(); j++){\n      long long m = 0, cnt = 0;\n      for (int k = 0; k < n; k++){\n        long long d = abs(x[k] - ax[i]) + abs(y[k] - ay[j]);\n        cnt += 2 * d;\n        m = max(m, d);\n      }\n\n      if (ans > cnt - m){\n        ans = cnt - m;\n        ans_x = ax[i];\n        ans_y = ay[j];\n      }\n    }\n  }\n\n  /*\n  for (int i = 0; i < n; i++){\n    long long d = abs(x[i] - ax) + abs(y[i] - ay);\n    ans += 2 * d;\n    max_d = max(d, max_d);\n  }\n  */\n\n  cout << ans << endl;\n  cout << ans_x << \" \" << ans_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000], bx, by;\nlong long sx[1000000], sy[1000000], sumx, sumy, mn, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\nlong long hx, hy, fx, fy;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int i = 0; i < mx.size(); i++) {\n\t\tif (i == 0) { fx++; }\n\t\tif (i >= 1) { if (mx[i] == mx[i - 1]) { fx++; } }\n\t\tif (fx > hx) { hx = fx; cx = mx[i]; }\n\t}\n\tfor (int i = 0; i < my.size; i++) {\n\t\tif (i == 0) { fy++; }\n\t\tif (i >= 1) { if (my[i] == my[i - 1]) { fy++; } }\n\t\tif (fy > hy) { hy = fy; cy = my[i]; }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\td[i] = abs(ex[i] - cx) + abs(ey[i] - cy);\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\n\nvector<long long> SX; // accumulation sum X\nvector<long long> SY; // accumulation sum Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nlong long sumx(int l, int r)\n{\n\treturn SX[r] - SX[l];\n}\n\nlong long sumy(int l, int r)\n{\n\treturn SY[r] - SY[l];\n}\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Accumulation ------ //\n\n\tSX.push_back(0);\n\tSY.push_back(0);\n\n\tfor (int i = 0; i < N; i++) SX.push_back(SX[i] + EX[i]);\n\tfor (int i = 0; i < N; i++) SY.push_back(SY[i] + EY[i]);\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tint ptrl = lower_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\t\tint ptrr = upper_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\n\t\tlong long suml = UX[i] * ptrl - sumx(0, ptrl);\n\t\tlong long sumr = sumx(ptrr, N) - UX[i] * (N - ptrr);\n\n\t\tDX.push_back(sumr - suml);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tint ptrl = lower_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\t\tint ptrr = upper_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\n\t\tlong long suml = 1LL * UY[i] * ptrl - sumy(0, ptrl);\n\t\tlong long sumr = 1LL * sumy(ptrr, N) - UY[i] * (N - ptrr);\n\n\t\tDY.push_back(sumr - suml);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(x) __builtin_ctz(x)\n\n// #define DEBUG\n\n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n\nusing namespace std;\nusing ll=long long;\n\nconst int nmax=100010;\n\nll x[nmax],y[nmax];\nll sx[nmax],sy[nmax];\n\nint main(void){\n\tint w,h,n;\n\tcin >> w >> h >> n;\n\trep(i,n) cin >> x[i] >> y[i];\n\trep(i,n) sx[i]=x[i],sy[i]=y[i];\n\tsort(sx,sx+n),sort(sy,sy+n);\n\tll ax=sx[(n-1)/2],ay=sy[(n-1)/2];\n\tll ans=0LL,cmax=0LL;\n\trep(i,n){\n\t\tll cur=abs(x[i]-ax)+abs(y[i]-ay);\n\t\tcmax=max(cmax,cur);\n\t\tans+=cur;\n\t}\n\tcout << 2LL*ans-cmax << endl;\n\tcout << ax << \" \" << ay << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[2]<b[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[2]>b[i]){//////error\n                }\n                else{\n                    if(mem[1]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    printf(\"%ld %ld\\n\",B[n/2],B[n/2-1]);\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]>a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]<a[i]){//////error\n                }\n                else{\n                    if(mem[2]>b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],x2[100000],y2[100000],n,ansx,ansy,w,h,l=0;\n  ll sumx=0,sumy=0,ans=1000000000000000,sum;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    x2[i]=x[i];\n    y2[i]=y[i];\n  }\n\n  sort(x,x+n);\n  sort(y,y+n);\n\n  for(int j=0;j<2;j++){\n    for(int k=0;k<2;k++){\n      sum=0;\n      for(int i=0;i<n;i++){\n\tl=max(l,abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]));\n\tsum+=(abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]))*2;\n      }\n      if(ans>sum-l){\n\tans=sum-(ll)l;\n\tansx=x[(n+j+1)/2-1];\n\tansy=y[(n+k+1)/2-1];\n      }\n    }\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=5;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t   }\n\t }\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //cout <<\"mxs \";rep(i,mxs.size())cout <<x[ mxs[i]].second <<\" \" ;cout << endl;\n    //cout <<\"mys \";rep(i,mys.size())cout <<y[ mys[i]].second <<\" \" ;cout << endl;\n    //bf(in,ans,ansy,ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int) 1e5 + 5;\nconst long long inf = (long long)1e18;\n\nint n, W, H;\nint x[maxn], y[maxn];\nvector<int> xx, yy;\nint _x, _y;\nlong long ans;\n\nlong long calc(int X, int Y) {\n    long long res = 0;\n    int mx = 0;\n    for (int i = 0; i < n; i ++) {\n        res += 2LL * (abs(X - x[i]) + abs(Y - y[i]));\n        mx = max(mx, abs(X - x[i]) + abs(Y - y[i]));\n    }\n    return res - mx;\n}\n\nint main() {\n    ///freopen(\"test.txt\", \"r\", stdin);\n    cin >> W >> H >> n;\n    for (int i = 0; i < n; i ++) {\n        cin >> x[i] >> y[i];\n        xx.push_back(x[i]);\n        yy.push_back(y[i]);\n    }\n    sort(xx.begin(), xx.end());\n    sort(yy.begin(), yy.end());\n\n    int md = n / 2;\n    int lo = max(0, md - 1);\n    int hi = min(n - 1, md + 1);\n    ans = inf;\n    for (int i = lo; i <= hi; i ++) {\n        for (int j = lo; j <= hi; j ++) {\n            ///cout << i << ' ' << j << ' ' << xx[i] << ' ' << yy[j] << endl;\n            long long tmp = calc(xx[i], yy[j]);\n            if(tmp < ans) {\n                ans = tmp;\n                _x = xx[i];\n                _y = yy[j];\n            }\n        }\n    }\n    cout << ans << '\\n' << _x << ' ' << _y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\nstruct Pos{\n\tint x,y,state;\n};\nvoid Pinst(Pos *a,int N){\n\ta->state = 0;\n}\nint compareX(const void *s1,const void *s2){\n\tint x1 = ((Pos*)s1)->x;\n\tint x2 = ((Pos*)s2)->x;\n\treturn x1 -x2;\n}\nint compareY(const void *s1,const void *s2){\n\tint y1 = ((Pos*)s1)->y;\n\tint y2 = ((Pos*)s2)->y;\n\treturn y1-y2;\n}\nint compare(const void *s1,const void *s2){\n\treturn *(int*)s2-*(int*)s1;\n}\nint w,h,k;\nPos pos[100000];\nint longest[100000];\t//最長候補の番号を入れておく\nint dx[100000];\nint dy[100000];\nint main(){\n\tint i,j,l;\n\tint now,max,min;\n\tlong long shotest = 1000000000000000001;\n\tlong long len;\n\tint sx,sy,scor;\n\tcin >> w >> h >> k;\n\tfor(i = 0;i < k;i++){\n\t\tcin >> pos[i].x >> pos[i].y;\n\t\tdx[i] = pos[i].x;\n\t\tdy[i] = pos[i].y;\n\t}\n\tPinst(pos,k);\n\t//最長候補の割り出し\n\tqsort(pos,k,sizeof(Pos),compareX);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].x;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].x == now;i++){\n\t\t\tif(pos[min].y > pos[i].y)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].y < pos[i].y)\n\t\t\t\tmax = i;\n\t\t}\n\t\tpos[min].state = 1;\n\t\tpos[max].state = 1;\n\t}\n\tqsort(pos,k,sizeof(Pos),compareY);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].y;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].y == now;i++){\n\t\t\tif(pos[min].x > pos[i].x)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].x < pos[i].x)\n\t\t\t\tmax = i;\n\t\t}\n\t\tif(pos[min].state == 1)\n\t\t\tpos[min].state = 2;\n\t\tif(pos[max].state == 1)\n\t\t\tpos[max].state = 2;\n\t}\n\tint corsole = 0;\n\tfor(i = 0;i < k;i++){\n\t\tif(pos[i].state == 2){\n\t\t\tlongest[corsole] = i;\n\t\t\tcorsole++;\n\t\t}\n\t}\n\t//探索(dx,dyリスト内からスタート地点を決め、実際に距離を調べる。)\n\t//shotestが全体の中で最少となったときの、sx,syの組をこたえたい\n\t//(しかも、sxはその中でも最少にするとか…)で、ソートしようかと思う\n\tqsort(dx,k,sizeof(int),compare);\n\tqsort(dy,k,sizeof(int),compare);\n\tfor(i = 0;i < k;i++){\n\t\tif(dx[i] == 0)\n\t\t\tcontinue;\n\t\tfor(j = 0;j < k;j++){\n\t\t\tif(dy[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tlen = 0;\n\t\t\tfor(l = 0;l < k;l++){\n\t\t\t\tif(dx[i] != dx[l])\n\t\t\t\t\tlen += abs(dx[i]-dx[l])*2;\n\t\t\t\tif(dy[j] != dy[l])\n\t\t\t\t\tlen += abs(dy[j]-dy[l])*2;\n\t\t\t}\n\t\t\tint t,max;\n\t\t\tmax = 0;\n\t\t\tfor(l = 0;l < corsole;l++){\n\t\t\t\tt = abs(dx[i]-pos[longest[l]].x)+abs(dy[j]-pos[longest[l]].y);\n\t\t\t\tif(max < t)\n\t\t\t\t\tmax = t;\n\t\t\t}\n\t\t\tlen -= max;\n\t\t\tif(shotest >= len){\n\t\t\t\tshotest = len;\n\t\t\t\tsx = dx[i];\n\t\t\t\tsy = dy[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << shotest << endl << sx << sy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<algorithm>  \n#include<queue>  \n#include<map>  \n#include<cmath>  \n#include<cstdio>  \nusing namespace std;  \n  \ntypedef pair < int , int > Pi;  \ntypedef long long ll;  \n#define INF ( 1ll << 61 )  \n#define fr first  \n#define sc second  \n//Pi data[100000];  \nint x[100000], y[100000];  \nint xx[100000], yy[1000000];  \n  \nll dis( Pi a, Pi b) {  \n  return llabs(a.fr - b.fr) + llabs(a.sc - b.sc);  \n}  \nint main(){  \n  int w,h,n;  \n  cin >> w >> h;  \n  cin >> n;  \n  \n  for(int i = 0 ; i < n ; i++ ){  \n    int a, b;  \n    scanf(\"%d %d\",x + i, y + i);  \n    xx[i] = x[i], yy[i] = y[i];  \n  }  \n  sort( x, x + n);  \n  sort( y, y + n);  \n  \n  int center = ( n - 1 ) / 2;  \n  ll ret = INF;  \n  int mx, my;  \n  \n  for(int i = center ; i < center + 2 ; i++ ){  \n    for(int j = center ; j < center + 2 ; j++ ){  \n      ll res = 0LL;  \n      ll most = 0;  \n      for(int k = 0 ; k < n ; k++ ){  \n        most = max( most, dis( Pi( x[i], y[j]), Pi( xx[k], yy[k])));  \n        res += dis( Pi( x[i], y[j]), Pi( xx[k], yy[k])) * 2;  \n      }  \n      if(ret > res - most){  \n        ret = res - most;  \n        mx = x[i];  \n        my = y[j];  \n      }  \n    }  \n  }  \n  cout << ret << endl;  \n  cout << mx << \" \" << my << endl;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint ox[100000];\nint oy[100000];\nint x[100000];\nint y[100000];\nint n;\nlong long calc(int a,int b){\n\tint md=0,i;\n\tlong long ans=0;\n\tfor(i=0;i<n;i++){\n\t\tint d=abs(ox[i]-a)+abs(oy[i]-b);\n\t\tmd=max(md,d);\n\t\tans+=(long long)d*2;\n\t}\n\treturn ans-(long long)md;\n}\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint w,h,i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&ox[i],&oy[i]);\n\t\tx[i]=ox[i];\n\t\ty[i]=oy[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tlong long ans=1000000000000000000LL;\n\tint ax[2];\n\tint ay[2];\n\tax[0]=x[n/2];\n\tay[0]=y[n/2];\n\tint nx,ny;\n\tif(n%2==0){\n\t\tax[1]=x[n/2-1];\n\t\tay[1]=y[n/2-1];\n\t\tfor(i=0;i<2;i++)for(j=0;j<2;j++){\n\t\t\tif(ans>calc(ax[i],ay[j])){\n\t\t\t\tans=calc(ax[i],ay[j]);\n\t\t\t\tnx=ax[i];\n\t\t\t\tny=ay[j];\n\t\t\t}\n\t\t}\n\t}else{\n\t\tans=calc(ax[0],ay[0]);\n\t\tnx=ax[0];\n\t\tny=ay[0];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%d %d\\n\",nx,ny);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint ox[100000];\nint oy[100000];\nint x[100000];\nint y[100000];\nint n;\nlong long calc(int a,int b){\n\tint md=0,i;\n\tlong long ans=0;\n\tfor(i=0;i<n;i++){\n\t\tint d=abs(ox[i]-a)+abs(oy[i]-b);\n\t\tmd=max(md,d);\n\t\tans+=(long long)d*2;\n\t}\n\treturn ans-(long long)md;\n}\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint w,h,i;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&ox[i],&oy[i]);\n\t\tx[i]=ox[i];\n\t\ty[i]=oy[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tlong long ans=0;\n\tint ax=x[n/2];\n\tint ay=y[n/2];\n\tint ax2,ay2;\n\tans=calc(ax,ay);\n\tif(n%2==0){\n\t\tax2=x[n/2-1];\n\t\tay2=y[n/2-1];\n\t\tans=max(ans,calc(ax2,ay2));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tif(n%2==0)printf(\"%d %d\\n\",ax2,ay2);\n\telse printf(\"%d %d\\n\",ax,ay);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct E {//???????????±?????\\???????????°\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad?????§?¨???????2??????????????¢\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll i) {\n\tll sum = 1;\n\tfor (ll j = 2; j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//??????(??£???\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h, n;\nH a[100000];\nint x[2][100000], y[2][100000];\nld sr(ld t,int r) {\n\tint k = lower_bound(x[0], x[0] + n, t) - x[0];\n\tld sum = 0;\n\tk--;\n\tif (k >= 0)\n\t\tsum += (t*(k + 1) - x[1][k]);\n\tsum += (x[1][n - 1] - (k < 0 ? 0 : x[1][k]) - t*(n - k - 1));\n\treturn sum * 2 - abs(t - a[r].x);\n}\nint solve(int r) {\n\tld s = 0, e = w+1, t1, t2;\n\twhile (e - s > 0.0001) {\n\t\tt1 = (e - s) / 3 + s, t2 = (e - s) * 2 / 3 + s;\n\t\tld s1 = sr(t1, r), s2 = sr(t2, r);\n\t\tif (s1 > s2)\n\t\t\ts = t1;\n\t\telse if (s1 == s2)\n\t\t\ts = t1, e = t2;\n\t\telse e = t2;\n\t}\n\treturn round(s);\n}\nld sr2(ld t, int r) {\n\tint k = lower_bound(y[0], y[0] + n, t) - y[0];\n\tld sum = 0;\n\tk--;\n\tif (k >= 0)\n\t\tsum += (t*(k + 1) -  y[1][k]);\n\tsum += (y[1][n - 1] - (k < 0 ? 0 : y[1][k]) - t*(n - k - 1));\n\treturn sum * 2 - abs(t - a[r].y);\n}\nint solve2(int r) {\n\tld s = 0, e = h + 1, t1, t2;\n\twhile (e - s > 0.0001) {\n\t\tt1 = (e - s) / 3 + s, t2 = (e - s) * 2 / 3 + s;\n\t\tld s1 = sr2(t1, r), s2 = sr2(t2, r);\n\t\tif (s1 > s2)\n\t\t\ts = t1;\n\t\telse if (s1 == s2)\n\t\t\ts = t1, e = t2;\n\t\telse e = t2;\n\t}\n\treturn round(s);\n}\nsigned main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].x >> a[i].y;\n\t\tx[0][i] = a[i].x;\n\t\ty[0][i] = a[i].y;\n\t}\n\tsort(x[0], x[0] + n);\n\tsort(y[0], y[0] + n);\n\tx[1][0] = x[0][0]; y[1][0] = y[0][0];\n\tfor (int i = 1; i < n; i++) {\n\t\tx[1][i] = x[1][i - 1] + x[0][i];\n\t\ty[1][i] = y[1][i - 1] + y[0][i];\n\t}\n\tint ans[3] = { inf,0,0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tint res = 0;\n\t\tint t = solve(i);\n\t\tres += sr(t, i);\n\t\tint t2 = solve2(i);\n\t\tres += sr2(t2, i);\n\t\tif (res < ans[0] || (res == ans[0] && (t < ans[1] || (t == ans[1] && t2 < ans[2])))) {\n\t\t\tans[0] = res;\n\t\t\tans[1] = t;\n\t\t\tans[2] = t2;\n\t\t}\n\t}\n\tcout << ans[0] << endl << ans[1] << \" \" << ans[2] << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > &in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define MAX_N 111111\ntypedef long long int ll;\nint W,H;int N;\nll A[MAX_N];ll B[MAX_N];\nint main()\n{\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lld%lld\",&A[i],&B[i]);\n\t}\n\tif(N&1){\n\t\tint n=N/2;ll x,y;vector<ll>X,Y;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tX.pb(A[i]);\n\t\t\tY.pb(B[i]);\n\t\t}\n\t\tsort(X.begin(),X.end());\n\t\tsort(Y.begin(),Y.end());\n\t\tx=X[n];y=Y[n];\n\t\tll ans=0;\n\t\tll M=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tM=max(M,abs(x-A[i]+abs(y-B[i])));\n\t\t\tans+=abs(x-A[i]);ans+=abs(y-B[i]);\n\t\t}\n\t\tprintf(\"%lld\\n%lld %lld\\n\",2*ans-M,x,y);\n\t}\n\telse{\n\t\tint n=(N-1)/2;ll x[2],y[2];vector<ll>X,Y;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tX.pb(A[i]);\n\t\t\tY.pb(B[i]);\n\t\t}\n\t\tsort(X.begin(),X.end());\n\t\tsort(Y.begin(),Y.end());\n\t\tfor(int i=0;i<2;i++){\n\t\t\tx[i]=X[n+i];y[i]=Y[n+i];\n\t\t}\n\t\tll ans[4]={0};\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tll M=0;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tM=max(abs(x[j]-A[i])+abs(y[k]-B[i]),M);\n\t\t\t\t\tans[j*2+k]+=abs(x[j]-A[i]);ans[j*2+k]+=abs(y[k]-B[i]);\n\t\t\t\t}\n\t\t\t\tans[j*2+k]*=2;\n\t\t\t\tans[j*2+k]-=M;\n\t\t\t}\n\t\t}\n\t\tll C=min(min(ans[0],ans[1]),min(ans[2],ans[3]));\n\t\tprintf(\"%lld\\n\",C);\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//printf(\"ans[%d]=%lld\\n\",i,ans[i]);\n\t\t\tif(C==ans[i]){\n\t\t\t\tprintf(\"%lld %lld\\n\",x[i/2],y[i%2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1000000000000000;\n\nint main(){\n  int w,h,n;\n  scanf(\"%d%d%d\",&w,&h,&n);\n  int x[n],y[n],sx[n],sy[n];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    sx[i] = x[i], sy[i] = y[i];\n  }\n  sort(sx,sx+n);\n  sort(sy,sy+n);\n  int xx[] = {sx[(n-1)/2],sx[(n-1)/2+1]};\n  int yy[] = {sy[(n-1)/2],sy[(n-1)/2+1]};\n  ll ans = INF;\n  int xxx,yyy;\n  for(int jugontyan=0;jugontyan<2;jugontyan++){\n    int dekai = 0;\n    ll t = 0;\n    int px = xx[jugontyan], py = yy[jugontyan];\n    for(int i=0;i<n;i++){\n      if(dekai<abs(x[i]-px)+abs(y[i]-py)) dekai = abs(x[i]-px) + abs(y[i]-py);\n      t += abs(x[i]-px) + abs(y[i]-py);\n    }\n    t = t * 2 - dekai;\n    if(ans>t){\n      ans = t;\n      xxx = px, yyy = py;\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",ans,xxx,yyy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long long int w,h,n;\n    long long int a[100001],b[100001],A[100001],B[100001];\n    long long int x,y;\n    long long int xa,ya;\n    long long int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld%lld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem[0]);\n        printf(\"%lld %lld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%lld %lld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n\nint n, w, h, x[100005], y[100005];\npii pos[100005];\npair<int, pii> dist[100005];\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> w >> h >> n;\n  for (int i = 1; i <= n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x + 1, x + n + 1);\n  sort(y + 1, y + n);\n  sort(pos + 1, pos + n + 1);\n\n  int bx = x[n / 2], by = y[n / 2], ans = 0;\n\n  for (int i = 1; i <= n; ++i) {\n    dist[i] = {abs(bx - pos[i].first) + abs(by -pos[i].second), pos[i]};\n  }\n  sort(dist + 1, dist + n + 1);\n\n  for (int i = 1; i <= n; ++i) {\n    ans += dist[i].first * 2;\n  }\n  ans += dist[n].first;\n\n  cout << ans << endl << bx << \" \" << by << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define ll long long\nusing namespace std;\n\nint main() {\n    int w, h, n;\n    cin >> w >> h >> n;\n    vector<ll> x(n);\n    vector<ll> y(n);\n    vector<vector<ll>> house(n, vector<ll>(2));\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        house[i][0] = x[i];\n        house[i][1] = y[i];\n    }\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    ll misum = 1145141919810364364;\n    ll retx, rety;\n    for (int a = (n - 1) / 2; a <= n / 2; a++) {\n        for (int b = (n - 1) / 2; b <= n / 2; b++) {\n            ll nx = x[a];\n            ll ny = y[b];\n            if (1 <= nx && nx <= w && 1 <= ny && ny <= h) {\n                ll sum = 0;\n                ll ma = 0;\n                for (int i = 0; i < n; i++) {\n                    ll dis = abs(house[i][0] - nx) + abs(house[i][1] - ny);\n                    ma = max(ma, dis);\n                    sum += dis * 2;\n                }\n                sum -= ma;\n                if (misum > sum) {\n                    misum = sum;\n                    retx = nx;\n                    rety = ny;\n                }\n            }\n        }\n    }\n    cout << misum << endl << retx << \" \" << rety << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      mini = mymin(mini,in[i].first);\n    }else {\n      M[in[i].second]++;\n      mini = mymin(mini,in[i].second);\n    }\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)mini);\n    else cur = cur + 2*((ll)in[i].second-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=1;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //yåº§æ¨ãä¸çªå°ããå ´æãããã¹ã¦ã®å®¶ã¾ã§ã®è·é¢ãè¨ç®ãã¦ãã\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   //å¹³é¢æä½ã£ã½ããã¨ããã¦ãåyåº§æ¨ããå®¶ã¾ã§ã®è·é¢ã®åãè¨ç®ãã¦ããã\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n//å¨æ¢ç´¢\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(llabs(in[k].second-x[j])+llabs(in[k].first-y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n }\n\n/*\n  è§£ç­æ¹éã\n  å¾å¾©ãããªãå®¶ãï¼ã¤ããã¨ããæ¡ä»¶ãç¡è¦ããå ´åã\n  åå®¶ãåãå ´æã«äºç®æããã¨èãã¦ããã\n  x,yåº§æ¨ã¯ç¬ç«ã«èããããã¨ãã§ããã\n  xåº§æ¨ã®è·é¢ã®åãæãå°ããä½ç½®ã¯ãã©ããã®å®¶ã¨åº§æ¨ãä¸è´ããå ´æã«ãã(ã°ã©ããèãã¦ã¿ãã¨ããã)\n  ã¨ããã®ã¯åºéã®éä¸­ã§ããã°ã©ã¡ããã«ããããã»ããåãå°ãããªãããã§ãããï¼åº§æ¨ã®éã®ã°ã©ãã®å¾ãã¯ç­ããã)\n  yåº§æ¨ãåæ§ã\n  å¾å¾©ãããªãã¨ããæ¡ä»¶ãç¡è¦ãã¦ããã®ã§ããã®æã®ç­ãã¯xåº§æ¨ããã®è·é¢ãæå°ã«ãªãç¹ã¨yåº§æ¨ããã®è·é¢ãæå°ã«ãªãç¹ã®åã«ãªãã\n  å¾å¾©ãããªãå®¶ãèããå ´åã\n  ã¾ãï¼æ¬¡åã§èããã\n  å¾å¾©ãããªãç¹ãåãé¤ãã¦ã¿ãã¨åã»ã©èããã°ã©ãã«è¥å¹²ã®å¤åãããã(ããåºéã§ã®å¾ããå¤åãã)\n  ãã ãããã«ããå½±é¿ã¯ããã¾ã§å¤§ãããªããåã»ã©èããã°ã©ãã®æå°ã¨ãªãç¹ã1ãããå¯è½æ§ãããã ãã§ããã\n\n  ãªã®ã§åãé¤ãå®¶ï¼å¾å¾©ããªãå®¶ï¼ãæ±ºãæã¡ãã¦ã\n  å¾å¾©ãèããå ´åã«ãã¨ã¯æå°ã«ãªãå¤(2*2=4éã)ã®å¨ããèª¿ã¹ãã°ååã§ããã\n */\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n     //è§£ã\n\n     //xåº§æ¨ãyåº§æ¨ãããããè·é¢ã®åãæå°ã«ãªãç¹ã®ä½ç½®ãè¨ç®ãã¦ãã\n     //ããã¯ããã ãï¼ã¤ï¼ï¼ã¤ï¼ï¼ããå­å¨ããªãã¯ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n\n     //å¾å¾©ãè¡ããªãå®¶ãæ±ºãæã¡ãã¦ãå¾å¾©ããå ´åã®æå°å¤å¨è¾ºãèª¿ã¹ãã\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n\t       ll tmp = y[i].first;\n\t       tmp = tmp + x[j].first;\n\t       tmp = tmp - llabs(y[i].second-in[k].first);\n\t       tmp = tmp - llabs(x[j].second-in[k].second); \n\t       ll ty=y[i].second;\n\t       ll tx=x[j].second;\n\t       if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t\t ans = tmp;\n\t\t ansx = tx;\n\t\t ansy = ty;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>=a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    if (n >= 10)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nint X[100000],Y[100000];\nint main() {\n\tint W,H,N;\n\tlong long int sumX=0,sumY=0;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&X[i],&Y[i]);\n\t\tsumX+=X[i]*2,sumY+=Y[i]*2;\n\t}\n\tlong long int ans=1LL<<62;\n\tint ansX=1<<30,ansY=1<<30;\n\tfor(int i=0;i<N;i++) {\n\t\tint x=(sumX-X[i])/(2*N-1);\n\t\tint y=(sumY-Y[i])/(2*N-1);\n\t\tlong long int maxd=0;\n\t\tfor(int dx=-1;dx<=1;dx++)\n\t    for(int dy=-1;dy<=1;dy++) {\n\t\t\tlong long int d=0;\n\t\t\tif(1>(x+dx)||(x+dx)>W||1>(y+dy)||(y+dy)>H) continue;\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\td+=(abs(x+dx-X[j])+abs(y+dy-Y[j]))*2;\n\t\t\t}\n\t\t\td-=(abs(x+dx-X[i])+abs(y+dy-Y[i]));\n\t\t\tif(ans==d) {\n\t\t\t\tif(ansX>(x+dx)) {\n\t\t\t\t\tansX=(x+dx),ansY=(y+dy);\n\t\t\t\t}else if (ansX==(x+dx)) {\n\t\t\t\t\tif(ansY>(y+dy)) ansY=(d+y);\n\t\t\t\t}\n\t\t\t}else if(ans>d) {\n\t\t\t\tansX=(x+dx),ansY=(y+dy),ans=d;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%d %d\\n\",ansX,ansY);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long int w,h,n,x[100000+2],y[100000+2];\nvector<long long int> zx,zy;\nlong long int Sx[100000+2],Sy[100000+2],R[100000+2],U[100000+2];\nlong long int sizx,sizy;\n\n//long long int max(long long int p,long long int q){if(p<q)return q; return p;}\n\nvector<long long int> e(vector<long long int> vll){\n\tvector<long long int> ret;\n\tret.push_back(vll[0]);\n\tlong long int s=vll.size();\n\tfor(int i=1;i<s;i++){\n\t\tif(vll[i]!=vll[i-1])ret.push_back(vll[i]);\n\t}\n\treturn ret;\n}\n\nlong long int Sum_x(long long int p){\n\tlong long int l=0,r=sizx-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zx[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sx[l]+R[l]*(p-zx[l]);\n}\n\nlong long int Sum_y(long long int p){\n\tlong long int l=0,r=sizy-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zy[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sy[l]+U[l]*(p-zy[l]);\n}\n\nlong long int find_x(long long int l,long long int r,long long int p){\n\tlong long int ret=1000000000000000000;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int LL=Sum_x(l)*2-max(l-p,p-l);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int RR=Sum_x(r)*2-max(r-p,p-r);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int SS=Sum_x(s)*2-max(s-p,p-s);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_x(l,s,p);\n\t\t\tretb=find_x(s,r,p);\n\t\t\tif(Sum_x(reta)*2-max(reta-p,p-reta)<Sum_x(retb)*2-max(retb-p,p-retb))return reta;\n\t\t\treturn retb;\n\t\t}\n\t}\n\treturn l;\n}\n\nlong long int find_y(long long int l,long long int r,long long int p){\n\tlong long int ret=1000000000000000000;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n\t\tlong long int LL=Sum_y(l)*2-max(l-p,p-l);\n\t\tlong long int RR=Sum_y(r)*2-max(r-p,p-r);\n\t\tlong long int SS=Sum_y(s)*2-max(s-p,p-s);\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_y(l,s,p);\n\t\t\tretb=find_y(s,r,p);\n\t\t\tif(Sum_y(reta)*2-max(reta-p,p-reta)<Sum_y(retb)*2-max(retb-p,p-retb))return reta;\n\t\t\treturn retb;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tR[0]=-n; U[0]=-n; Sx[0]=0; Sy[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tzx.push_back(x[i]);\n\t\tzy.push_back(y[i]);\n\t\tSx[0]+=x[i];\n\t\tSy[0]+=y[i];\n\t}\n\tzx.push_back(0);\n\tzy.push_back(0);\n\tsort(zx.begin(),zx.end());\n\tsort(zy.begin(),zy.end());\n\tsizx=zx.size();\n\tsizy=zy.size();\n\tlong long int k=1;\n\tfor(int i=1;k<sizx;i++){\n\t\tint t=1; k++;\n\t\twhile(zx[k]==zx[k-1]){t++; k++;}\n\t\tR[i]=R[i-1]+2*t;\n\t}\n\tk=1;\n\tfor(int i=1;k<sizy;i++){\n\t\tint t=1; k++;\n\t\twhile(zy[k]==zy[k-1]){t++; k++;}\n\t\tU[i]=U[i-1]+2*t;\n\t}\n\tzx=e(zx);\n\tzy=e(zy);\n\tsizx=zx.size();\n\tsizy=zy.size();\n//\tcout<<\"test\"<<0<<endl;\n\tfor(int i=1;i<sizx;i++)Sx[i]=Sx[i-1]+R[i-1]*(zx[i]-zx[i-1]);\n\tfor(int i=1;i<sizy;i++)Sy[i]=Sy[i-1]+U[i-1]*(zy[i]-zy[i-1]);\n//\tfor(int i=0;i<sizx;i++)cout<<zx[i]<<\" \";\n//\tcout<<endl;\n//\tfor(int i=0;i<sizx;i++)cout<<Sx[i]<<\" \";\n//\tcout<<endl;\n//\tfor(int i=0;i<=sizx;i++)cout<<R[i]<<\" \";\n//\tcout<<endl;\n//\tfor(int i=1;i<=w;i++)cout<<Sum_x(i)<<\" \";\n//\tcout<<endl;\n//\tfor(int i=0;i<sizy;i++)cout<<zy[i]<<\" \";\n//\tcout<<endl;\n//\tfor(int i=0;i<sizy;i++)cout<<Sy[i]<<\" \";\n//\tcout<<endl;\n//\tfor(int i=0;i<=sizy;i++)cout<<U[i]<<\" \";\n//\tcout<<endl;\n//\tfor(int i=1;i<=h;i++)cout<<Sum_y(i)<<\" \";\n//\tcout<<endl;\n\tlong long int ans=1000000000000000000,ansx,ansy;\n\tfor(int i=0;i<n;i++){\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tlong long int retx,rety,sumx,sumy;\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tretx=find_x(1,w,x[i]);\n//\t\tcout<<\"test\"<<i<<endl;\n\t\trety=find_y(1,h,y[i]);\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tsumx=Sum_x(retx)*2-max(x[i+1]-retx,retx-x[i+1]);\n//\t\tcout<<x[i]<<\" \"<<retx<<\" \"<<max(x[i]-retx,retx-x[i])<<endl;\n\t\tsumy=Sum_y(rety)*2-max(y[i+1]-rety,rety-y[i+1]);\n//\t\tcout<<y[i]<<\" \"<<rety<<\" \"<<max(y[i]-rety,rety-y[i])<<endl;\n\t\tif(ans>sumx+sumy){\n\t\t\tans=sumx+sumy;\n\t\t\tansx=retx;\n\t\t\tansy=rety;\n\t\t}\n//\t\tcout<<i<<\":\"<<sumx+sumy<<\" \"<<retx<<\",\"<<rety<<endl;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ans,ansx,ansy);\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\ni64 calc(i64& mean, const vector<i64>& vec) {\n    i64 res = 0LL, ma = 0LL;\n    for(auto t : vec) {\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma = max(ma, plus);\n        res += plus << 1LL;\n    }\n    return res - ma;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    sort(xcoord.begin(), xcoord.end());\n    sort(ycoord.begin(), ycoord.end());\n    int midId = n / 2;\n    if(~n & 1) --midId;\n    i64 x = xcoord[midId], y = ycoord[midId];\n    i64 sum = calc(x, xcoord) + calc(y, ycoord);\n    cout << sum << '\\n' << x << ' ' << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\n\nll calc(vint& v, int p)\n{\n\tll res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = (N-1)/2; x <= (N+1)/2; x++)\n\t\t{\n\t\t\tfor(int y = (N-1)/2; y <= (N+1)/2; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, X[x]) + calc(Y, Y[y]);\n\t\t\t\tsub -= abs(X[x] - points[last].first);\n\t\t\t\tsub -= abs(Y[y] - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = X[x];\n\t\t\t\t\tbest_y = Y[y];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(X[x] < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = X[x];\n\t\t\t\t\t\tbest_y = Y[y];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(X[x] == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(Y[y] < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = Y[y];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define foru(i, a, b) for(int i = int(a); i <= int(b); i++)\nusing namespace std;\ntypedef long long llong;\nconst int N = 100005;\n\nint x[N], y[N], a[N], b[N], w, h, n;\n\nllong get(int x, int y) {\n    llong sum = 0LL, maxx = 0LL;\n    foru(i, 1, n) {\n        sum += 2LL * llong(abs(a[i] - x) + abs(b[i] - y));\n        maxx = max(maxx, llong(abs(a[i] - x) + abs(b[i] - y)));\n    }\n    return sum - maxx;\n}\n\nint main() {\n    //freopen(\"a.txt\", \"r\", stdin);\n    scanf(\"%d%d%d\", &w, &h, &n);\n    foru(i, 1, n) {\n        scanf(\"%d%d\", &x[i], &y[i]);\n        a[i] = x[i], b[i] = y[i];\n    }\n    sort(x+1, x+n+1);\n    sort(y+1, y+n+1);\n    int nn = n/2;\n    llong res = LONG_LONG_MAX;  int xx, yy;\n    foru(i, max(nn - 10, 1), min(nn + 10, n))\n        foru(j, max(nn - 10, 1), min(nn + 10, n)) {\n            llong sum = get(x[i], y[j]);\n            if (sum < res) {\n                res = sum;\n                xx = x[i], yy = y[j];\n            }\n        }\n    cout << res << endl << xx << ' ' << yy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntemplate<class T>\nclass Fenwick{\npublic :\n  vector<T> x;\n  Fenwick(){}\n  Fenwick(int n):x(n,0){}\n  T sum(int i, int j){\n    if(i==0){\n      T s=0;\n      while(j>=0){\n\ts+=x[j];\n\tj=(j&(j+1))-1;\n      }\n      return s;\n    }else return sum(0,j)-sum(0,i-1);\n  }\n  void add(int k, T a){\n    for(;k<(int)x.size(); k|=k+1)x[k]+=a;\n  }\n};\n\nconst long long inf = 1LL<<61;\n\nlong long res_min, res_x, res_y;\nvector<long long> x_coor, y_coor;\nFenwick<long long> x_tree, y_tree;\n\nvoid init(int n){\n  x_coor.clear();\n  y_coor.clear();\n  x_tree = Fenwick<long long>(n+1);\n  y_tree = Fenwick<long long>(n+1);\n}\n\nlong long myabs(long long x){\n  return x<0?-x:x;\n}\n\nlong long calc_cost(long long x, long long y){\n\n  long long ret_x = 0, ret_y = 0;\n  for(int i = 0; i < (int)x_coor.size(); ++i){\n    ret_x += myabs(x_coor[i] - x);\n    ret_y += myabs(y_coor[i] - y);\n  }\n  return 2*(ret_x + ret_y);\n\n  /*\n  const int n = x_coor.size();\n  vector<long long>::iterator itx = lower_bound(x_coor.begin(), x_coor.end(), x);\n  vector<long long>::iterator ity = lower_bound(y_coor.begin(), y_coor.end(), y);\n  int npx=0, nnx=0, npy=0, nny=0;\n  long long px=0,nx=0,py=0,ny=0;\n  \n  if( itx == x_coor.end() ){\n    nnx = n;    nx = x_tree.sum(0,n-1);\n  }else if( itx == x_coor.begin()){\n    npx = n;    px = x_tree.sum(0,n-1);\n  }else{\n    int e = itx - x_coor.begin();\n    nnx = e;    nx = x_tree.sum(0,e-1);\n    npx = n-e;  px = x_tree.sum(e,n-1);\n  }\n\n  if( ity == y_coor.end() ){\n    nny = n;   ny = y_tree.sum(0,n-1);\n  }else if( ity == y_coor.begin()){\n    npy = n;   py = y_tree.sum(0,n-1);\n  }else{\n    int e = ity - y_coor.begin();\n    nny = e;   ny = y_tree.sum(0,e-1);\n    npy = n-e; py = y_tree.sum(e,n-1);\n  }\n  \n  return\n    2*(nnx * x - nx + px - npx * x +\n       nny * y - ny + py - npy * y);\n  */\n}\n\nvoid solve(long long x0, long long y0, long long x1, long long y1)\n{\n  // cout << x0 << ' ' << y0 << ' ' << x1 << ' ' << y1 << endl;\n  if( x1 - x0 <= 4 && y1 - y0 <= 4 ){\n    long long minc = inf;\n    int min_x, min_y;\n    for(int x = x0-3; x <= x1+3; ++x){\n      for(int y = y0-3; y <= y1+3; ++y){\n\tlong long cost = calc_cost(x,y);\n\tif( minc > cost ){\n\t  minc = cost;\n\t  min_x = x;\n\t  min_y = y;\n\t}\n      }\n    }\n    res_min = minc;\n    res_x = min_x;\n    res_y = min_y;\n    return ;\n  }\n  \n\n  long long mx = (x1-x0)/2;\n  long long my = (y1-y0)/2;\n  \n  long long ex[4], ey[4];\n  long long minc = inf;\n  int min_ind;\n\n  ex[0] = (x0 + mx) / 2;\n  ey[0] = (y0 + my) / 2;\n\n  ex[1] = (mx + x1) / 2;\n  ey[1] = (y0 + my) / 2;\n\n  ex[2] = (x0 + mx) / 2;\n  ey[2] = (my + y1) / 2;\n\n  ex[3] = (mx + x1) / 2;\n  ey[3] = (my + y1) / 2;\n  \n  for(int i = 0; i < 4; ++i){\n    long long cost = calc_cost( ex[i], ey[i] );\n    if( minc > cost ){\n      minc = cost;\n      min_ind = i;\n    }\n  }\n\n  if( min_ind == 0 ){\n    solve( x0, y0, mx, my );\n  }else if( min_ind == 1 ){\n    solve( mx, y0, x1, my );\n  }else if( min_ind == 2 ){\n    solve( x0, my, mx, y1 );\n  }else if( min_ind == 3 ){\n    solve( mx, my, x1, y1 );\n  }\n}\n\nint main()\n{\n  long long w,h;\n  while(cin >> w >> h){    \n    if( w == 0 && h == 0 ) break;\n    int n;\n    cin >> n;\n    init(n);\n\n    vector<long long> org_x, org_y;\n    for(int i = 0; i < n; ++i){\n      long long in_x, in_y;\n      cin >> in_x >> in_y;\n      x_coor.push_back(in_x);\n      y_coor.push_back(in_y);\n    }\n    org_x = x_coor;\n    org_y = y_coor;\n    sort(x_coor.begin(), x_coor.end());\n    sort(y_coor.begin(), y_coor.end());\n    for(int i = 0; i < n; ++i){\n      x_tree.add(i, x_coor[i]);\n      y_tree.add(i, y_coor[i]);\n    }\n\n    solve(1,1,w,h);\n\n    long long maxt = 0;\n    for(int i = 0; i < (int)org_x.size(); ++i){\n      long long t = myabs(org_x[i] - res_x) + myabs(org_y[i] - res_y);\n      maxt = max( maxt, t );\n    }\n    cout << res_min - maxt << endl << res_x << ' ' << res_y << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <forward_list>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <cstdint>\n#include <utility>\n\n#define X 0\n#define Y 1\n\nusing namespace std;\n\ntypedef long long int int64;\n\nint64 WH[2],N;\nint64 XY[100000][2];\nvector<int64> VN[2];\nvector<pair<int64,int64>> T;\n\nsigned main(void)\n{\n\tcin >> WH[X] >> WH[Y] >> N;\n\tint64 x,y;\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tcin >> x >> y;\n\t\tT.push_back(make_pair(x,y));\n\t}\n\tsort(T.begin(),T.end());\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tXY[i][X] = T[i].first;\n\t\tXY[i][Y] = T[i].second;\n\t\tVN[X].push_back(XY[i][X]);\n\t\tVN[X].push_back(XY[i][X]);\n\t\tVN[Y].push_back(XY[i][Y]);\n\t\tVN[Y].push_back(XY[i][Y]);\n\t}\n\tsort(VN[X].begin(),VN[X].end());\n\tsort(VN[Y].begin(),VN[Y].end());\n\tint64 MAXi = -1;\n\tint64 MAXd = 0;\n\tint64 p[2],m[2];\n\tint64 dist = 0;\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tfor(int64 xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[i][xy]) - VN[xy].begin();\n\t\t\tif(p[xy] < N)\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N]-XY[i][xy]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N-1]-XY[i][xy]);\n\t\t\t}\n\t\t}\n\t\tif(MAXd <= m[X] + m[Y])\n\t\t{\n\t\t\tMAXd = m[X] + m[Y];\n\t\t\tMAXi = i;\n\t\t}\n\t}\n\tfor(int64 xy = 0;xy < 2;xy++)\n\t{\n\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[MAXi][xy]) - VN[xy].begin();\n\t\tif(p[xy] < N)\n\t\t{\n\t\t\tm[xy] = VN[xy][N];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm[xy] = VN[xy][N-1];\n\t\t}\n\t}\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tfor(int64 xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tif(i != MAXi)\n\t\t\t{\n\t\t\t\tdist += (abs(m[xy]-XY[i][xy])*2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tdist += abs(m[xy]-XY[i][xy]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist <<endl << m[X] << \" \" << m[Y] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  printf(\"\\n\");\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2 - 1];\n      ori.y = y[(n + 1) / 2 - 1];\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer < wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2 - 1])\n\t    {\n\t      s.x = x[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  if(ww[i].y > y[n / 2 - 1])\n\t    {\n\t      s.y = y[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      ori = s;\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(s.x < ori.x || (s.x == ori.x && s.y < ori.y))\n\t\t{\n\t\t  ori = s;\n\t\t  longer = wkyori(s,ww[i]);\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i]) * 2));\n\t}\n      else\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i])));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1000000000000000;\n\nint main(){\n  int w,h,n;\n  scanf(\"%d%d%d\",&w,&h,&n);\n  int x[n],y[n],sx[n],sy[n];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    sx[i] = x[i], sy[i] = y[i];\n  }\n  sort(sx,sx+n);\n  sort(sy,sy+n);\n  int xx[] = {sx[(n-1)/2],sx[(n-1)/2],sx[(n-1)/2+1],sx[(n-1)/2+1]};\n  int yy[] = {sy[(n-1)/2],sy[(n-1)/2+1],sy[(n-1)/2],sy[(n-1)/2+1]};\n  ll ans = INF;\n  int xxx,yyy;\n  for(int jugontyan=0;jugontyan<4;jugontyan++){\n    int dekai = 0;\n    ll t = 0;\n    int px = xx[jugontyan], py = yy[jugontyan];\n    for(int i=0;i<n;i++){\n      if(dekai<abs(x[i]-px)+abs(y[i]-py)) dekai = abs(x[i]-px) + abs(y[i]-py);\n      t += abs(x[i]-px) + abs(y[i]-py);\n    }\n    t = t * 2 - dekai;\n    if(ans>t){\n      ans = t;\n      xxx = px, yyy = py;\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",ans,xxx,yyy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\t\t\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tlong long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tmaxs = max(maxs, abs(X[k] - UX[i]) + abs(Y[k] - UY[j]));\n\t\t\t}\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 1001001001001001;\n\nint main()\n{\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\t\n\tvector<int> X, Y, tX, tY;\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tX.push_back(x); tX.push_back(x);\n\t\tY.push_back(y); tY.push_back(y);\n\t}\n\t\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\t\n\tLL resd = INF;\n\tint resx, resy;\n\tfor (int i = n / 2 - !(n % 2); i <= n / 2; i++){\n\t\tfor (int j = n / 2 - !(n % 2); j <= n / 2; j++){\n\t\t\tLL sum = 0;\n\t\t\tLL maxi = 0;\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tLL d = abs(tX[k] - X[i]) + abs(tY[k] - Y[j]);\n\t\t\t\tsum += d * 2;\n\t\t\t\tmaxi = max(maxi, d);\n\t\t\t}\n\t\t\tsum -= maxi;\n\t\t\t\n\t\t\tif (resd > sum){\n\t\t\t\tresd = sum;\n\t\t\t\tresx = X[i];\n\t\t\t\tresy = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n%d %d\\n\", resd, resx, resy);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint main(){\n\tint w,h,n;\n\tint x[100100],y[100100];\n\tcin>>w>>h>>n;\n\tvector<int>vx(n),vy(n);\n\tREP(i,n){\n\t\tcin>>x[i]>>y[i];\n\t\tvx[i]=x[i];vy[i]=y[i];\n\t}\n\tsort(ALL(vx));\n\tsort(ALL(vy));\n\tvector<int>kx,ky;\n\tif(n%2){\n\t\tkx.PB(vx[n/2]);\n\t\tky.PB(vy[n/2]);\n\t}else{\n\t\tkx.PB(vx[n/2-1]);\n\t\tkx.PB(vx[n/2]);\n\t\tky.PB(vy[n/2-1]);\n\t\tky.PB(vy[n/2]);\n\t}\n\tll ans=1e18,ansx,ansy;\n\tREP(i,kx.size())REP(j,ky.size()){\n\t\tll sum=0;\n\t\tvector<ll>V;\n\t\tREP(k,n)V.PB(abs(x[k]-kx[i])+abs(y[k]-ky[j]));\n\t\tsort(ALL(V));\n\t\tREP(k,V.size())sum+=k==V.size()-1?V[k]:V[k]*2;\n\t\tif (ans>sum){\n\t\t\tansx=kx[i];\n\t\t\tansy=ky[j];\n\t\t\tans=sum;\n\t\t}\n\t}\n\tcout<<ans<<endl<<ansx<<\" \"<<ansy<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, w, h, L, HL, temp, oxy[2][2], *LXY[2], *XY[2], ox, oy, max = 0, dx, dy;\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++){\n\t\tLXY[f1] = new long long [L];\n\t\tXY[f1] = new long long [L];\n\t}\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0][f1] = LXY[0][f1];\n\t\tXY[1][f1] = LXY[1][f1];\n\t}\n\t//1m\n\tsort( XY[0], XY[0] + L );\n\tsort( XY[1], XY[1] + L );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\toxy[0][f1] = XY[f1][HL-1];\n\t\t\toxy[1][f1] = XY[f1][HL];\n\t\t}\n\t\tdx = (oxy[0][0] == oxy[1][0]) ? 1 : 2;\n\t\tdy = (oxy[0][1] == oxy[1][1]) ? 1 : 2;\n\t\t//400k\n\t\tfor(f2 = 0; f2 < dx; f2++){\n\t\t\tfor(f3 = 0; f3 < dy; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum *= 2;\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    if (n > 5)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<41);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  long long int ans = INF;\n  int ansx, ansy;\n  int up = min( (n / 2) + 3, n - 1);\n  int down = max(0, (n / 2) - 3);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      long long int  res = 0;\n      int far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define all(x) x.begin(),x.end()\n#define rep(i,N) for(int i=0;i<(int)N;++i)\nusing namespace std;\nusing ll = long long;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing vll2 = vector<vector<ll>>;\nconst ll INF = (1LL << 30);\nconst ll LINF = (1LL << 60);\nconst ll MOD = 1e9 + 7;\n\nint main() {\n   cin.tie(0);\n   ios::sync_with_stdio(false);\n   using P = pair<ll, ll>;\n\n   ll W, H; cin >> W >> H;\n   int N; cin >> N;\n   vector<P> C(N);\n   vll X(N), Y(N);\n   rep(i, N) {\n      cin >> X[i] >> Y[i];\n      C[i] = P(X[i], Y[i]);\n   }\n   sort(all(X));\n   sort(all(Y));\n\n   auto f = [&](ll x, ll y) {\n      ll res = 0, maxv = 0;\n      rep(i, N) {\n         ll sum = abs(x - C[i].first) + abs(y - C[i].second);\n         maxv = max(maxv, sum);\n         res += 2 * sum;\n      }\n      return res - maxv;\n   };\n\n   vll cx, cy;\n   if (N % 2 == 0) {\n      cx.emplace_back(X[N / 2 - 1]);\n      cx.emplace_back(X[N / 2]);\n      cy.emplace_back(Y[N / 2 - 1]);\n      cy.emplace_back(Y[N / 2]);\n   } else {\n      cx.emplace_back(X[N / 2]);\n      cy.emplace_back(Y[N / 2]);\n   }\n\n   ll ans = LINF;\n   ll x, y;\n   rep(i, cx.size()) rep(j, cy.size()) {\n      ll res = f(cx[i], cy[j]);\n      if (res < ans) {\n         ans = res;\n         x = cx[i], y = cy[j];\n      }\n   }\n\n   cout << ans << endl;\n   cout << x << \" \" << y << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, mn, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int g = 0; g < mx.size(); g++) {\n\t\tfor (int h = 0; h < my.size(); h++) {\n\t\t\tsum = 0; mn = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\td[i] = (abs(mx[g] - ex[i]) + abs(my[h] - ey[i]));\n\t\t\t\tsum += d[i] * 2;\n\t\t\t\tmn = max(mn, d[i]);\n\t\t\t}\n\t\t\tsum -= mn;\n\t\t\tif (minx > sum) { minx = sum; cx = mx[g]; cy = my[h]; }\n\t\t}\n\t}\n\t\n\tcout << minx << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > &in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n && w){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<41);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  long long int ans = INF;\n  int ansx, ansy;\n  int up = min( (n / 2) + 2, n - 1);\n  int down = max(0, (n / 2) - 2);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      long long int  res = 0;\n      int far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    /*\n    cout <<\"xinfo \" << endl;\n    rep(i,x.size())cout << x[i].first <<\" \" << x[i].second << endl;\n    cout <<\"yinfo \" << endl;\n    rep(i,y.size())cout << y[i].first <<\" \" << y[i].second << endl;\n    */\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[mx].first)my = i;    \n\n    const int D=4;\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    int W, H; cin >> W >> H;\n\n    int N; cin >> N;\n\n    rep(i, N) {\n        cin >> X[i];\n        cin >> Y[i];\n        pos[i] = pii(X[i], Y[i]);\n    }\n\n    sort(X, X + N);\n    sort(Y, Y + N);\n\n    int x, y;\n    \n    if (N % 2 == 0) {\n        int ans = inf;\n        int ansx = -1, ansy = -1;\n\n        rep(i, 2) {\n            rep(j, 2) {\n                int x = X[N / 2 - i], y = Y[N / 2 - j];\n                \n                int sum = 0;\n                int ma = 0;\n                rep(k, N) {\n                    int a = abs(x - pos[k].fst) + abs(y - pos[k].scd);\n                    sum += a * 2;\n                    chmax(ma, a);\n                }\n                sum -= ma;\n\n                if (ans >= sum) {\n                    ans = sum;\n                    ansx = x;\n                    ansy = y;\n                }\n            }\n        }\n\n        cout << ans << endl;\n        cout << ansx << ' ' << ansy << endl;\n    } else {\n        x = y = N / 2;\n\n        int ma = 0;\n        int v = 0;\n\n        rep(i, N) {\n            int a = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n            v += a * 2;\n            ma = max(ma, a);\n        }\n        v -= ma;\n\n        cout << v << endl;\n        cout << x << ' ' << y << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      int xind = (*X.find(in[k].second)).first;\n      int yind = (*Y.find(in[k].first )).second;\n      /*\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint px[10001],py[10001];\nint main(){\n    int w,h,n;\n    cin>>w>>h>>n;\n    ll sumx=0,sumy=0,x,y;\n    for(int i=0;i<n;++i){\n        cin>>x>>y;\n        px[i]=x;py[i]=y;\n        sumx +=x;sumy +=y;\n    }\n    x=sumx/n;y=sumy/n;\n    int posx[4]={x,x,x+1,x+1};\n    int posy[4]={y,y+1,y,y+1};\n    ll ans[4]={0};\n    int mx[4]={0};\n    for(int i=0;i<n;++i){\n        for(int j=0;j<4;++j){\n            int tx=abs(posx[j]-px[i]),ty=abs(posy[j]-py[i]);\n            ans[j] +=(tx+ty)*2;mx[j]=max(mx[j],tx+ty);\n        }\n    }\n    ll mn=9223372036854775807;\n    for(int i=0;i<4;++i){\n        if(mn<=ans[i]-mx[i]) continue;\n        mn=ans[i]-mx[i];x=posx[i];y=posy[i];\n    }\n    cout<<mn<<endl;\n    cout<<x<<\" \"<<y<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e15;\n\nstruct P {\n  ll x, y;\n  bool operator<(const P& rhs) const {\n    return (x == rhs.x) ? (y < rhs.y) : (x < rhs.x);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  ll W, H;\n  int N;\n  while (cin >> W >> H >> N) {\n    vector<P> ps(N);\n    vector<ll> xsorted(N), ysorted(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y;\n      xsorted[i] = ps[i].x;\n      ysorted[i] = ps[i].y;\n    }\n    sort(begin(xsorted), end(xsorted));\n    sort(begin(ysorted), end(ysorted));\n    vector<P> candidates;\n    for (int i = 0; i < min(3, N); ++i) {\n      for (int j = 0; j < min(3, N); ++j) {\n        candidates.push_back({xsorted[(N - 1) / 2 + (i + 1) % 3 - 1],\n                              ysorted[(N - 1) / 2 + (j + 1) % 3 - 1]});\n      }\n    }\n    pair<ll, P> ans = {INF, {INF, INF}};\n    for (P c : candidates) {\n      ll maxDist = -1, totalDist = 0;\n      for (int i = 0; i < N; ++i) {\n        ll dist = abs(ps[i].x - c.x) + abs(ps[i].y - c.y);\n        totalDist += dist;\n        maxDist = max(maxDist, dist);\n      }\n      ans = min(ans, make_pair(2 * totalDist - maxDist, c));\n    }\n    cout << ans.first << endl << ans.second.x << \" \" << ans.second.y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  if(flg == 0)\n    {\n      printf(\"0\");\n    }\n  printf(\"\\n\");\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2 - 1];\n      ori.y = y[(n + 1) / 2 - 1];\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer <= wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2 - 1])\n\t    {\n\t      s.x = x[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  if(ww[i].y > y[n / 2 - 1])\n\t    {\n\t      s.y = y[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      ori = s;\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(s.x < ori.x || (s.x == ori.x && s.y < ori.y))\n\t\t{\n\t\t  ori = s;\n\t\t  longer = wkyori(s,ww[i]);\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i]) * 2));\n\t}\n      else\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i])));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nint n;\nint x[101010], y[101010];\nint X[101010], Y[101010];\n\nint main()\n{\n  cin >> h >> w;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n    X[i] = x[i];\n    Y[i] = y[i];\n  }\n\n  sort(X, X + n);\n  sort(Y, Y + n);\n\n  int ax = X[(n - 1) / 2], ay = Y[(n - 1) / 2];\n  \n  long long ans = 0, max_d = 0;\n  for (int i = 0; i < n; i++){\n    long long d = abs(x[i] - ax) + abs(y[i] - ay);\n    ans += 2 * d;\n    max_d = max(d, max_d);\n  }\n\n  cout << ans - max_d << endl;\n  cout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nint sx[100000];\nint sy[100000];\nint abs(int a){return a>=0?a:-a;}\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint w,h,n,i,j,k;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&sx[i],&sy[i]);\n\t\tx[i]=sx[i];\n\t\ty[i]=sy[i];\n\t}\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tint m=(n-1)/2;\n\tlong long ans=1000000000000000LL;\n\tint ax,ay;\n\tfor(i=m;i<=m+1;i++){\n\t\tfor(j=m;j<=m+1;j++){\n\t\t\tlong long res=0;\n\t\t\tint mx=0;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tres+=(long long)(abs(sx[k]-x[i])+abs(sy[k]-y[j]))*2;\n\t\t\t\tmx=max(mx,abs(sx[k]-x[i])+abs(sy[k]-y[j]));\n\t\t\t}\n\t\t\tres-=mx;\n\t\t\tif(res<ans){\n\t\t\t\tans=res;\n\t\t\t\tax=x[i];\n\t\t\t\tay=y[j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,ax,ay);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint W,H;\nint N;\nint X[100000];\nint Y[100000];\nint XC[100000];\nint YC[100000];\nll ans;\nint ansx,ansy;\nint main()\n{\n\tscanf(\"%d%d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);\n\t\tXC[i]=X[i];YC[i]=Y[i];\n\t}\n\tsort(XC,XC+N);sort(YC,YC+N);\n\tif(N&1){\n\t\tll ma=0;\n\t\tansx=XC[N/2];ansy=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans+=(ll)(abs(X[i]-ansx));\n\t\t\tans+=(ll)(abs(Y[i]-ansy));\n\t\t\tma=(max(ma,(ll)(abs(X[i]-ansx)+abs(Y[i]-ansy))));\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",2*ans-ma,ansx,ansy);\n\t}\n\telse{\n\t\tint ansx1=XC[N/2-1];int ansy1=YC[N/2-1];\n\t\tll ans1=0;\n\t\tll ma=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans+=(ll)(abs(X[i]-ansx1));\n\t\t\tans+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=(max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1))));\n\t\t}\n\t\tansx=ansx1;ansy=ansy1;\n\t\tans=2*ans-ma;\n\t\t\n\t\tma=0;\n\t\tansx1=XC[N/2-1];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=(max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1))));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2-1];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=(max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1))));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=(max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1))));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    int W, H; cin >> W >> H;\n\n    int N; cin >> N;\n\n    rep(i, N) {\n        cin >> X[i];\n        cin >> Y[i];\n        pos[i] = pii(X[i], Y[i]);\n    }\n\n    sort(X, X + N);\n    sort(Y, Y + N);\n\n    int x, y;\n    \n    if (N % 2 == 0) {\n        int ans = inf;\n        int ansx = -1, ansy = -1;\n\n        rep(i, 2) {\n            rep(j, 2) {\n                int x = X[N / 2 - i], y = Y[N / 2 - j];\n                \n                int sum = 0;\n                int ma = 0;\n                rep(k, N) {\n                    int a = abs(x - pos[k].fst) + abs(y - pos[k].scd);\n                    sum += a * 2;\n                    chmax(ma, a);\n                }\n                sum -= ma;\n\n                if (ans >= sum) {\n                    ans = sum;\n                    ansx = x;\n                    ansy = y;\n                }\n            }\n        }\n\n        cout << ans << endl;\n        cout << ansx << ' ' << ansy << endl;\n    } else {\n        x = X[N / 2], y = Y[N / 2];\n\n        int ma = 0;\n        int v = 0;\n\n        rep(i, N) {\n            int a = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n            v += a * 2;\n            ma = max(ma, a);\n        }\n        v -= ma;\n\n        cout << v << endl;\n        cout << x << ' ' << y << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  This program is accepted in my computer.\n */\n#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      int is = max(0,yind-D),ie=min(yind+D+1,(int)Y.size());\n      REP(i,is,ie){\n\tint js = max(0,xind-D),je=min(yind+D+1,(int)X.size());\n\tREP(j,js,je){\n      //REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\t//REP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint x[100000], y[100000];\nint sum1[100001], sum2[100001];\n#define dist(x)(abs(i-x.first)+abs(j-x.second))\nsigned main() {\n\tint w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\tP maxx(0, 0), maxy(0, 0), minx(INF, 0), miny(0, INF);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\tif (maxx.first < x[i]) {\n\t\t\tmaxx.first = x[i];\n\t\t\tmaxx.second = y[i];\n\t\t}\n\t\tif (minx.first > x[i]) {\n\t\t\tminx.first = x[i];\n\t\t\tminx.second = y[i];\n\t\t}\n\t\tif (maxy.second < y[i]) {\n\t\t\tmaxy.first = x[i];\n\t\t\tmaxy.second = y[i];\n\t\t}\n\t\tif (miny.second > y[i]) {\n\t\t\tminy.first = x[i];\n\t\t\tminy.second = y[i];\n\t\t}\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tset<int>ax, ay;\n\tint mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tint a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a) {\n\t\t\tmx = a; ax.clear();\n\t\t}\n\t\tif (mx == a) ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a) {\n\t\t\tmy = a; ay.clear();\n\t\t}\n\t\tif (my == a)ay.insert(y[i]);\n\t};\n\tint ansx, ansy, ans = LLONG_MAX;\n\tfor (int i : ax)for (int j : ay) {\n\t\tint M[] = { dist(minx),dist(maxx),dist(miny),dist(maxy) };\n\t\tint d = mx + my - *max_element(M, M + 4);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n  const int w = getInt();\n  const int h = getInt();\n  const int n = getInt();\n\n  vector<int> x(n);\n  vector<int> y(n);\n\n  REP(i,n){\n    x[i] = getInt();\n    y[i] = getInt();\n  }\n\n  vector<int> xx = x; sort(xx.begin(), xx.end());\n  vector<int> yy = y; sort(yy.begin(), yy.end());\n\n  vector<int> px;\n  vector<int> py;\n\n  const int d = 3;\n  for(int i = 0; i < d + d + 1; i++){\n    int pp = n / 2 - d + i;\n    if(0 <= pp && pp < n){\n      px.push_back(xx[pp]);\n      py.push_back(yy[pp]);\n    }\n  }\n\n  ll ans = 1ll << 60;\n  int ax = 0;\n  int ay = 0;\n  FOR(ix, px) FOR(iy, py){\n    int cx = *ix;\n    int cy = *iy;\n\n    ll tmp = 0;\n    ll mx = 0;\n    REP(i,n){\n      ll tt = abs(x[i] - cx) + abs(y[i] - cy);\n      mx = max(mx, tt);\n      tmp += tt + tt;\n    }\n    tmp -= mx;\n    if(tmp < ans){\n      ans = tmp;\n      ax = cx;\n      ay = cy;\n    }else if(tmp == ans){\n      if((cx < ax) || (cx == ax && cy < ay)){\n        ax = cx;\n        ay = cy;\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ax, ay);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(x-ps[i].first) + std::abs(y-ps[i].second);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    X.erase(std::unique(X.begin(), X.end()), X.end());\n    std::sort(Y.begin(), Y.end());\n    Y.erase(std::unique(Y.begin(), Y.end()), Y.end());\n\n    int xn = X.size(), yn = Y.size();\n    ll xs[3], ys[3];\n    if((xn-1)/2-1 >= 0){\n        xs[0] = X[(xn-1)/2-1];\n    }\n    xs[1] = X[(xn+1)/2-1];\n    if((xn+3)/2-1 < xn){\n        xs[2] = X[(X.size()+3)/2-1];\n    }\n\n    if((yn-1)/2-1 >= 0){\n        ys[0] = Y[(yn-1)/2-1];\n    }\n    ys[1] = Y[(yn+1)/2-1];\n    if((yn+3)/2-1 < yn){\n        ys[2] = Y[(yn+3)/2-1];\n    }\n\n    ll max_cost = INF, x = INF, y = INF;\n    REP(i, 3){\n        REP(j, 3){\n            ll cost = work(xs[i], ys[j]);\n            if(cost < max_cost){\n                max_cost = cost;\n                x = xs[i];\n                y = ys[j];\n            }else if(cost == max_cost){\n                x = std::min(x, xs[i]);\n                y = std::min(y, ys[j]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", max_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for(int (i)=(s);(i)<(int)(e);(i)++)\n#define REP(i,e) FOR(i,0,e)\n#define RFOR(i,e,s) for(int (i)=(e);(i)>(int)(s);(i)--)\n\n#define all(o) (o).begin(), (o).end()\n#define psb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef priority_queue<int> PQI;\ntypedef priority_queue<PII> PQII;\n\nconst double EPS = 1e-10;\nconst int N = 1e5;\nint w, h;\nint n;\nll x[N], y[N], sx[N], sy[N], d[N];\n\nint main() {\n  scanf(\"%d%d \", &w, &h);\n  scanf(\"%d \", &n);\n  REP(i,n) {\n    scanf(\"%lld%lld \", x+i, y+i);\n    sx[i] = x[i];\n    sy[i] = y[i];\n  }\n  sort(sx, sx+n);\n  sort(sy, sy+n);\n\n  ll mx = sx[n&1 ? n/2 : n/2-1], my = sy[n&1 ? n/2 : n/2-1];\n  REP(i,n) d[i] = abs(mx-x[i]) + abs(my-y[i]);\n  sort(d,d+n);\n\n  ll res = 0;\n  REP(i,n) res += d[i];\n  res *= 2LL;\n  res -= d[n-1];\n\n  printf(\"%lld\\n\", res);\n  printf(\"%lld %lld\\n\", mx, my);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n scanf(\"%d%d%d\",h,w,n);\n FOR(i,n) scanf(\"%lld%lld\",x+i,y+i);\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(cx,cx+n);\n sort(cy,cy+n);\n int mx[2],my[2];\n mx[0]=cx[n>>1];\n mx[1]=mx[0]+1;\n my[0]=cy[n>>1];\n my[1]=my[0]+1;\n ll mi=1000000000000000LL,miX,miY;\n /*\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n printf(\"%lld\\n%lld %lld\\n\",mi,miX,miY);\n */\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n\nint n, w, h, x[100005], y[100005];\npii pos[100005];\npair<int, pii> dist[100005];\n\nint calDist(int bx, int by) {\n  int ans = 0;\n  \n  for (int i = 0; i < n; ++i) {\n    dist[i] = {abs(bx - pos[i].first) + abs(by -pos[i].second), pos[i]};\n  }\n  sort(dist, dist + n);\n\n  for (int i = 0; i < n - 1; ++i) {\n    ans += dist[i].first * 2;\n  }\n  ans += dist[n - 1].first;\n\n  return ans;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> w >> h >> n;\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x, x + n);\n  sort(y, y + n);\n  sort(pos, pos + n);\n\n  int bx = x[n / 2 - !(n % 2)], by = y[n / 2 - !(n % 2)], ans = calDist(bx, by);\n\n  cout << ans << endl << bx << \" \" << by << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //úlðvZ\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//XRAAÀWÌyA\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint ox[100000];\nint oy[100000];\nint x[100000];\nint y[100000];\nint n;\nlong long calc(int a,int b){\n\tint md=0,i;\n\tlong long ans=0;\n\tfor(i=0;i<n;i++){\n\t\tint d=abs(ox[i]-a)+abs(oy[i]-b);\n\t\tmd=max(md,d);\n\t\tans+=(long long)d*2;\n\t}\n\treturn ans-(long long)md;\n}\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint w,h,i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&ox[i],&oy[i]);\n\t\tx[i]=ox[i];\n\t\ty[i]=oy[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tlong long ans=1000000000000000000LL;\n\tint ax[2];\n\tint ay[2];\n\tax[0]=x[n/2];\n\tay[0]=y[n/2];\n\tint nx,ny;\n\tif(n%2==0){\n\t\tax[1]=x[n/2-1];\n\t\tay[1]=y[n/2-1];\n\t\tfor(i=1;i>=0;i--)for(j=1;j>=0;j--){\n\t\t\tif(ans>calc(ax[i],ay[j])){\n\t\t\t\tans=calc(ax[i],ay[j]);\n\t\t\t\tnx=ax[i];\n\t\t\t\tny=ay[j];\n\t\t\t}\n\t\t}\n\t}else{\n\t\tans=calc(ax[0],ay[0]);\n\t\tnx=ax[0];\n\t\tny=ay[0];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%d %d\\n\",nx,ny);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint w,h,n,x[100002],y[100002];\nint tx[100002],ty[100002];\nvector<int> vx,vy;\n\nsigned main(){\n  cin>>w>>h>>n;\n  rep(i,n){\n    cin>>x[i]>>y[i];\n    tx[i]=x[i];\n    ty[i]=y[i];\n  }\n  sort(x,x+n);\n  sort(y,y+n);\n  if(n%2){\n    vx.push_back(x[n/2]);\n    vy.push_back(y[n/2]);\n  }else{\n    vx.push_back(x[n/2-1]),vx.push_back(x[n/2]);\n    vy.push_back(y[n/2-1]),vy.push_back(y[n/2]);\n  }\n  int t=1000000000000000,ax,ay;\n  for(int sx:vx)for(int sy:vy){\n    int sum=0,md=0;\n    rep(i,n){\n      int d=abs(tx[i]-sx)+abs(ty[i]-sy);\n      sum+=d*2;\n      md=max(md,d);\n    }\n    sum-=md;\n    if(sum<t){\n      t=sum;\n      ax=sx;\n      ay=sy;\n    }\n  }\n  cout<<t<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint w,h,n,x[100002],y[100002];\nint tx[100002],ty[100002];\nvector<int> vx,vy;\n\nsigned main(){\n  cin>>w>>h>>n;\n  rep(i,n){\n    cin>>x[i]>>y[i];\n    tx[i]=x[i];\n    ty[i]=y[i];\n  }\n  sort(x,x+w);\n  sort(y,y+h);\n  if(h%2)\n    vx.push_back(x[h/2]);\n  else\n    vx.push_back(x[h/2]),vx.push_back(x[h/2+1]);\n  if(w%2)\n    vy.push_back(y[w/2]);\n  else\n    vy.push_back(y[w/2]),vy.push_back(y[w/2+1]);\n  int t=1000000000000000,ax,ay;\n  for(int sx:vx)for(int sy:vy){\n    int sum=0,md=0;\n    rep(i,n){\n      int d=abs(tx[i]-sx)+abs(ty[i]-sy);\n      sum+=d*2;\n      md=max(md,d);\n    }\n    if(sum-md<t){\n      t=sum-md;\n      ax=sx;\n      ay=sy;\n    }\n  }\n  cout<<t<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 1000;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long rx = 999999999999999999LL, ry = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 1; i <= H; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(X[j] - i);\n\t\t}\n\n\t\tif (rx > sum)\n\t\t{\n\t\t\trx = sum; x = i;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= W; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(Y[j] - i);\n\t\t}\n\t\t\n\t\tif (ry > sum)\n\t\t{\n\t\t\try = sum; y = i;\n\t\t}\n\t}\n\n\tint maxs = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmaxs = max(maxs, abs(X[i] - x) + abs(Y[i] - y));\n\t}\n\n\tprintf(\"%d\\n\", (rx + ry) * 2 - maxs);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e15;\n\nstruct P {\n  ll x, y;\n  bool operator<(const P& rhs) const {\n    return (x == rhs.x) ? (y < rhs.y) : (x < rhs.x);\n  }\n};\n\nint main() {\n  ll W, H;\n  int N;\n  while (cin >> W >> H >> N) {\n    vector<P> ps(N);\n    vector<ll> xsorted(N), ysorted(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y;\n      xsorted[i] = ps[i].x;\n      ysorted[i] = ps[i].y;\n    }\n    sort(begin(xsorted), end(xsorted));\n    sort(begin(ysorted), end(ysorted));\n    vector<P> candidates;\n    for (int i = 0; i < min(3, N); ++i) {\n      for (int j = 0; j < min(3, N); ++j) {\n        candidates.push_back({xsorted[(N - 1) / 2 + (i + 1) % 3 - 1],\n                              ysorted[(N - 1) / 2 + (j + 1) % 3 - 1]});\n      }\n    }\n    pair<ll, P> ans = {INF, {INF, INF}};\n    for (P c : candidates) {\n      ll maxDist = -1, totalDist = 0;\n      for (int i = 0; i < N; ++i) {\n        ll dist = abs(ps[i].x - c.x) + abs(ps[i].y - c.y);\n        totalDist += dist;\n        maxDist = max(maxDist, dist);\n      }\n      ans = min(ans, make_pair(2 * totalDist - maxDist, c));\n    }\n    cout << ans.first << endl << ans.second.x << \" \" << ans.second.y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int points[100005][2], xs[100005], ys[100005], n, w, h;\n  long long int sums = 0;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  long long int ans = -1;\n  int ansx, ansy;\n  int up = min( (n / 2) + 2, n - 1);\n  int down = max(0, (n / 2) - 2);\n\n\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      long long int  res = 0, far = 0, d;\n      for(int k = 0;k < n;k++){\n\td = abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]);\n\tfar = max(far, d);\n\tres += d * 2;\n      }\n      if(ans == -1 || ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    Y[fir] = index;index++;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>=a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tvector<VV> dists(3, VV(3, V(N)));\n\trep(i, N) rep(j, -1, 2) rep(k, -1, 2) {\n\t\tdists[j][k][i] = abs(v[i].first - ws[N / 2 + j]) + abs(v[i].second - hs[N / 2 + k]);\n\t}\n\trep(i, 9) sort(all(dists[i]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\trep(i, 3) rep(j, 3) {\n\t\tint sum = accumulate(all(dists[i][j]), 0ll) * 2 - dists[i][j].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[N / 2 + i];\n\t\t\typos = hs[N / 2 + j];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\tsystem(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <fstream>\nusing namespace std;\n#define mp make_pair\n\nvector<int> median(vector<int> v) {\n\tsort(v.begin(), v.end());\n\tint n = v.size();\n\tvector<int> ret(1, v[n/2]);\n\tif (n % 2 == 0) {\n\t\tret.push_back(v[n/2-1]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\tvector<int> xs(N), ys(N);\n\tfor (int i=0; i<N; ++i) {\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tvector<int> mx = median(xs);\n\tvector<int> my = median(ys);\n\tlong long res = INT_MAX;\n\tint x, y;\n\tfor (int i=0; i<(int)mx.size(); ++i) {\n\t\tfor (int j=0; j<(int)my.size(); ++j) {\n\t\t\tlong long time = 0, m = 0;\n\t\t\tfor (int k=0; k<N; ++k) {\n\t\t\t\tlong long t = abs(xs[k] - mx[i]) + abs(ys[k] - my[j]);\n\t\t\t\ttime += t;\n\t\t\t\tm = max(m, t);\n\t\t\t}\n\t\t\tlong long res2 = 2 * time - m;\n\t\t\tif (mp(res2, mp(mx[i], my[j])) < mp(res, mp(x, y))) {\n\t\t\t\tres = res2;\n\t\t\t\tx = mx[i];\n\t\t\t\ty = my[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <set>\n#include <queue>\n#include <map>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nconst long double eps = 1e-12;\n\ntypedef long long ll;\ntypedef pair<int , int> pt;\n\n#define sz(a) ((int) a.size() )\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n#define For(i , a , b) for (int i = a ; i <= b ; i++)\n#define Ford(i , a , b) for (int i = a ; i >= b ; i--)\n#define Rep(i , n) for (int i = 0 ; i < n ; i++)\n\nconst int maxn = 100000 + 1912;\npt a[maxn];\nint n;\nint W , H;\nvoid ReadData() {\n    cin >> W >> H;\n    cin >> n;\n    For(i , 1 , n) cin >> a[i].first >> a[i].second;\n}\n\nconst long long INF = 1000LL * 1000 * 1000 * 1000 * 1000 * 1000 + 1912;\n\nlong long f(int x , int y) {\n    if (x <= 0 || x > W || y <= 0 || y > H) return INF;\n    long long res = 0;\n    long long mx = 0;\n    For(i , 1 , n) {\n        long long d = 1LL* abs(x - a[i].first) + abs(y - a[i].second);\n        mx = max(mx , d);\n        res += d * 2;\n    }\n    return res - mx;\n}\n\nvoid Process() {\n    long long sx = 0 , sy = 0;\n    For(i , 1 , n) {\n        sx += a[i].first; sy += a[i].second;\n    }\n    sx /= n;\n    sy /= n;\n    long long res = INF;\n    int xx = 0 , yy = 0;\n    For(u , sx - 10 , sx + 10) For(v , sy - 10 , sy + 10) {\n        long long cur = f(u , v);\n        if (cur < res) { res = cur , xx = u , yy = v; }\n    }\n    cout << res << endl;\n    cout << xx << \" \" << yy << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n   // freopen(\"/users/youaremysky/documents/workspace/input.inp\" , \"r\" , stdin);\n    ReadData();\n    Process();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint ox[100000];\nint oy[100000];\nint x[100000];\nint y[100000];\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint w,h,n,i;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&ox[i],&oy[i]);\n\t\tx[i]=ox[i];\n\t\ty[i]=oy[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tint ax=x[n%2==0?n/2-1:n/2];\n\tint ay=y[n%2==0?n/2-1:n/2];\n\tint md=0;\n\tlong long ans=0;\n\tfor(i=0;i<n;i++){\n\t\tint d=abs(ox[i]-ax)+abs(oy[i]-ay);\n\t\tmd=max(md,d);\n\t\tans+=(long long)d*2;\n\t}\n\tprintf(\"%lld\\n\",ans-(long long)md);\n\tprintf(\"%d %d\\n\",ax,ay);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      mini = mymin(mini,in[i].first);\n    }else {\n      M[in[i].second]++;\n      mini = mymin(mini,in[i].second);\n    }\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)mini);\n    else cur = cur + 2*((ll)in[i].second-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    assert(n <= 100);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\nconst double eps = 1e-9;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    int W, H; cin >> W >> H;\n\n    int N; cin >> N;\n\n    rep(i, N) {\n        cin >> X[i];\n        cin >> Y[i];\n        pos[i] = pii(X[i], Y[i]);\n    }\n\n    sort(X, X + N);\n    sort(Y, Y + N);\n\n    int x, y;\n    \n    if (N % 2 == 0) {\n        int ans = inf;\n        int ansx = -1, ansy = -1;\n\n        rep(i, 2) {\n            rep(j, 2) {\n                int x = X[N / 2 - i], y = Y[N / 2 - j];\n                \n                int sum = 0;\n                int ma = 0;\n                rep(k, N) {\n                    int a = abs(x - pos[k].fst) + abs(y - pos[k].scd);\n                    sum += a * 2;\n                    chmax(ma, a);\n                }\n                sum -= ma;\n\n                if (ans >= sum) {\n                    ans = sum;\n                    ansx = x;\n                    ansy = y;\n                }\n            }\n        }\n\n        cout << ans << endl;\n        cout << ansx << ' ' << ansy << endl;\n    } else {\n        x = X[N / 2], y = Y[N / 2];\n\n        int ma = 0;\n        int v = 0;\n\n        rep(i, N) {\n            int a = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n            v += a * 2;\n            ma = max(ma, a);\n        }\n        v -= ma;\n\n        cout << v << endl;\n        cout << x << ' ' << y << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0563\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\ntemplate <typename T>\nusing gtree = tree<T,null_type,less<T>,rb_tree_tag,\n                   tree_order_statistics_node_update>;\n// usage:\n// find_by_order(int k):\n// return the iterator of k-th smallest element (0-indexed)\n// order_of_key(T key):  return the index of key in tree\n//END CUT HERE\n#ifndef call_from_test\nsigned ARC028_B(){\n  using ll = long long;\n  int n,k;\n  cin>>n>>k;\n  vector<int> xs(n);\n  for(int i=0;i<n;i++) cin>>xs[i];\n  map<int, int> mp;\n  for(int i=0;i<n;i++) mp[xs[i]]=i+1;\n  gtree<ll> G;\n  for(int i=0;i<k-1;i++) G.insert(xs[i]);\n  for(int i=k-1;i<n;i++){\n    G.insert(xs[i]);\n    auto key=*G.find_by_order(k-1);\n    cout<<mp[key]<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2019/12/09\n  https://atcoder.jp/contests/arc028/tasks/arc028_2\n*/\n\nsigned ARC033_C(){\n  int q;\n  cin>>q;\n  gtree<int> G;\n  while(q--){\n    int t,x;\n    cin>>t>>x;\n    if(t==1) G.insert(x);\n    if(t==2){\n      int k=*G.find_by_order(x-1);\n      G.erase(k);\n      cout<<k<<endl;\n    }\n  }\n  return 0;\n}\n\n/*\n  verified on 2019/12/09\n  https://atcoder.jp/contests/arc033/tasks/arc033_3\n*/\n\nsigned main(){\n  //ARC028_B();\n  //ARC033_C();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  using ll = long long;\n\n  int w,h,n;\n  cin>>w>>h>>n;\n  vector<int> xs(n),ys(n);\n  for(int i=0;i<n;i++) cin>>xs[i]>>ys[i];\n\n  using P = pair<int, int>;\n  gtree<P> gx,gy;\n  for(int i=0;i<n;i++){\n    gx.insert(P(xs[i],i));\n    gy.insert(P(ys[i],i));\n    gx.insert(P(xs[i],n+i));\n    gy.insert(P(ys[i],n+i));\n  }\n\n  ll ans=1e18;\n  int ax=-1,ay=-1;\n\n  map<int, ll> mx,my;\n\n  for(int i=0;i<n;i++){\n    gx.erase(P(xs[i],i));\n    gy.erase(P(ys[i],i));\n\n\n    int tx=gx.find_by_order(n-1)->first;\n    int ty=gy.find_by_order(n-1)->first;\n\n    if(!mx.count(tx)){\n      mx[tx]=0;\n      for(int j=0;j<n;j++)\n        mx[tx]+=abs(xs[j]-tx)*2;\n    }\n\n    if(!my.count(ty)){\n      my[ty]=0;\n      for(int j=0;j<n;j++)\n        my[ty]+=abs(ys[j]-ty)*2;\n    }\n\n    ll res=mx[tx]+my[ty]-(abs(xs[i]-tx)+abs(ys[i]-ty));\n    if((res< ans)||\n       (res==ans&&tx< ax)||\n       (res==ans&&tx==ax&&ty< ay)){\n      ans=res;\n      ax=tx;\n      ay=ty;\n    }\n\n\n    gx.insert(P(xs[i],i));\n    gy.insert(P(ys[i],i));\n  }\n\n  cout<<ans<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint sx = X[(N-1)/2], sy = Y[(N-1)/2];\n\tvector<ll> a;\n\tREP(i, N) {\n\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t}\n\tsort( ALL(a) );\n\tll ans = a[N-1];\n\tREP(i, N-1) {\n\t\tans += a[i]*2;\n\t}\n\tcout << ans << endl;\n\tcout << sx << \" \" << sy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0, dx, dy;\n\tvector<long long> XY[2];\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tsort( XY[0].begin(), XY[0].end() );\n\tsort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\toxy[0][f1] = XY[f1][HL-1];\n\t\t\toxy[1][f1] = XY[f1][HL];\n\t\t}\n\t\tdx = (oxy[0][0] == oxy[1][0]) ? 1 : 2;\n\t\tdy = (oxy[0][1] == oxy[1][1]) ? 1 : 2;\n\t\t//400k\n\t\tfor(f2 = 0; f2 < dx; f2++){\n\t\t\tfor(f3 = 0; f3 < dy; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum *= 2;\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n//typedef pair<int,int> P;\nstruct P {int x,y;};\nint w,h,n;\nP ie[100002];\n\nint t(int x,int y) {\n  int sum=0;\n  int md=0;\n  int d=0;\n  rep(i,n){\n    d=abs(ie[i].x-x)+abs(ie[i].y-y);\n    sum+=d*2;\n    md=max(md,d);\n  }\n  return sum-md;\n}\n\nsigned main(){\n  cin>>w>>h>>n;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ie[i]={x,y};\n  }\n  int rx=w;\n  int ry=h;\n  int ax=rx,ay=ry;\n  int t0;\n  while(rx>1&&ry>1){\n    t0=t(ax,ay);\n    rx=rx-rx/2;\n    ry=ry-ry/2;\n    if(t(ax-1,ay)<=t0)ax-=rx;\n    else ax+=rx;\n    if(t(ax,ay-1)<=t0)ay-=ry;\n    else ay+=ry;\n  }\n  while(t(ax-1,ay)<=t(ax,ay))ax--;\n  while(t(ax,ay-1)<=t(ax,ay))ay--;\n  cout<<t(ax,ay)<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\nvoid calc(i64 mean, const vector<i64>& vec, vector<i64>& ma) {\n    for(int i : in(vec.size())) {\n        i64 t = vec[i];\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma[i] += plus;\n    }\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    auto sortx = xcoord, sorty = ycoord;\n    sort(sortx.begin(), sortx.end());\n    sort(sorty.begin(), sorty.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    i64 sum = 0LL;\n    for(int i : in(n)) {\n        if(i <= midId[0])\n          sum += sortx[midId[0]] - sortx[i] + sorty[midId[0]] - sorty[i];\n        else\n          sum += sortx[i] - sortx[midId[0]] + sorty[i] - sorty[midId[0]];\n    }\n    tuple<i64, i64, i64> ans(0LL, 0LL, 0LL);\n    vector<i64> ma(n, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = sortx[id1], y = sorty[id2];\n        fill(ma.begin(), ma.end(), 0LL);\n        calc(x, xcoord, ma); calc(y, ycoord, ma);\n        ans = max(ans, make_tuple(*max_element(ma.begin(), ma.end()), x, y));\n    }\n    i64 minus, x, y; tie(minus, x, y) = ans;\n    cout << sum * 2LL - minus << '\\n' << x << ' ' << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint px[100001],py[100001],sx[100001],sy[100001];\nint main(){\n    int w,h,n;\n    cin>>w>>h>>n;\n    ll x,y;\n    for(int i=0;i<n;++i){\n        cin>>x>>y;\n        px[i]=sx[i]=x;py[i]=sy[i]=y;\n    }\n    sort(sx,sx+n);\n    sort(sy,sy+n);\n    int posx[4]={sx[n/2-1],sx[n/2-1],sx[n/2],sx[n/2]};\n    int posy[4]={sy[n/2-1],sy[n/2],sy[n/2-1],sy[n/2]};\n    ll ans[4]={0};\n    int mx[4]={0};\n    for(int i=0;i<n;++i){\n        for(int j=0;j<4;++j){\n            int tx=abs(posx[j]-px[i]),ty=abs(posy[j]-py[i]);\n            ans[j] +=(tx+ty)*2;mx[j]=max(mx[j],tx+ty);\n        }\n    }\n    ll mn=9223372036854775800;\n    for(int i=0;i<4;++i){\n        if(mn<=ans[i]-mx[i]) continue;\n        mn=ans[i]-mx[i];x=posx[i];y=posy[i];\n    }\n    cout<<mn<<endl;\n    cout<<x<<\" \"<<y<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = l;\n\t\tpr = r;\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\n\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    if (n >= 10)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<long long,P>P1;\n#define pb push_back\n#define mp make_pair\nP pa1[100005],pa2[100005];\nint h,w,n;\nbool comp(P a,P b){\n\treturn a.second<b.second;\n}\nbool decide(P1 a,P1 b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else if(a.first>b.first){\n\t\treturn false;\n\t}else{\n\t\tif(a.second.first<b.second.first){\n\t\t\treturn true;\n\t\t}else if(a.second.first>b.second.first){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn a.second.second<b.second.second;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&h,&w);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpa2[i]=pa1[i]=mp(x,y);\n\t}\n\tsort(pa2+1,pa2+(n+1),comp);\n\tsort(pa1+1,pa1+(n+1));\n\tint ha=(n+1)/2;\n\tint ax=pa1[ha].first;\n\tint ay=pa2[ha].second;\n\tvector<P1>vec;\n\tvector<int>dx,dy;\n\tdx.pb(ax);\n\tdy.pb(ay);\n\tif(pa1[ha+1].first!=ax){\n\t\tdx.pb(pa1[ha+1].first);\n\t}\n\tif(pa2[ha+1].second!=ay){\n\t\tdy.pb(pa2[ha+1].second);\n\t}\n\tfor(int i=0;i<dx.size();i++){\n\t\tfor(int j=0;j<dy.size();j++){\n\t\t\tlong long sd=0;\n\t\t\tint maxi=0;\n\t\t\tfor(int g=1;g<=n;g++){\n\t\t\t\tsd+=(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j]));\n\t\t\t\tmaxi=max(maxi,(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j])));\n\t\t\t}\n\t\t\tvec.pb(mp(sd*2-maxi,mp(dx[i],dy[j])));\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end(),decide);\n\tprintf(\"%lld\\n%d %d\\n\",vec[0].first,vec[0].second.first,vec[0].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\nint main()\n{\n\tint w, h, n;\n\tvector<pair<int, int> > pos;\n\t\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\tpos.resize(n);\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\n\tvector<pair<int, int> > x, y;\n\tvector<pair<int64, pair<int, int> > > ans;\n\t\n\tfor(int i = 0; i < n; ++i) {\n\t\tx.push_back(make_pair(pos[i].first, i));\n\t\tx.push_back(make_pair(pos[i].first, i));\n\t\ty.push_back(make_pair(pos[i].second, i));\n\t\ty.push_back(make_pair(pos[i].second, i));\n\t}\n\t\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\t\n\tfor(int i = 0; i < 2 * n; ++i) {\n\t\tpos[x[i].second].first = i;\n\t\tpos[y[i].second].second = i;\n\t}\n\t\n\tint x1 = n - 1, x2 = n, y1 = n - 1, y2 = n;\n\tint64 x1cost = 0, x2cost = 0, y1cost = 0, y2cost = 0;\n\t\n\tfor(int i = 0; i < 2 * n; ++i) {\n\t\tx1cost += abs(x[i].first - x[x1].first);\n\t\tx2cost += abs(x[i].first - x[x2].first);\n\t\ty1cost += abs(y[i].first - y[y1].first);\n\t\ty2cost += abs(y[i].first - y[y2].first);\n\t}\n\t\n\tfor(int i = 0; i < n; ++i) {\n\t\t\n\t\tint ix = pos[i].first;\n\t\tint dx = x[ix].first;\n\t\tint iy = pos[i].second;\n\t\tint dy = y[iy].first;\n\t\t\n\t\tint64 cost = 0;\n\t\t\n\t\tif(ix >= n)\n\t\t\tcost += x1cost - abs(dx - x[x1].first);\n\t\telse\n\t\t\tcost += x2cost - abs(dx - x[x2].first);\n\t\t\n\t\tif(iy >= n)\n\t\t\tcost += y1cost - abs(dy - y[y1].first);\n\t\telse\n\t\t\tcost += y2cost - abs(dy - y[y2].first);\n\t\t\n\t\tint sx = ix >= n ? x[x1].first : x[x2].first;\n\t\tint sy = iy >= n ? y[y1].first : y[y2].first;\n\t\t\n\t\tans.push_back(make_pair(cost, make_pair(sx, sy)));\n\t\t\n\t}\n\t\n\tsort(ans.begin(), ans.end());\n\t\n\tprintf(\"%lld\\n%d %d\\n\", ans[0].first, ans[0].second.first, ans[0].second.second);\n\t\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<int> x(n), y(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i] >> y[i];\n\n    vector<int> x0 = x;\n    vector<int> y0 = y;\n    sort(x0.begin(), x0.end());\n    sort(y0.begin(), y0.end());\n\n    long long ret = LLONG_MAX;\n    int tx, ty;\n    for(int i=-15; i<=15; ++i){\n        for(int j=-15; j<=15; ++j){\n            if(n/2 + i < 0 || n/2 + i >= n || n/2 + j < 0 || n/2 + j >= n)\n                continue;\n            int sx = x0[n/2+i];\n            int sy = y0[n/2+j];\n\n            long long tmp = 0;\n            long long maxDist = 0;\n            for(int k=0; k<n; ++k){\n                long long dist = abs(sx - x[k]) + abs(sy - y[k]);\n                tmp += dist * 2;\n                maxDist = max(maxDist, dist);\n            }\n            tmp -= maxDist;\n\n            if(tmp < ret){\n                ret = tmp;\n                tx = sx;\n                ty = sy;\n            }\n            ret = min(ret, tmp);\n        }\n    }\n\n    cout << ret << endl;\n    cout << tx << ' ' << ty << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint W,H;\nint N;\nint X[100000];\nint Y[100000];\nint XC[100000];\nint YC[100000];\nll ans;\nint ansx,ansy;\nint main()\n{\n\tscanf(\"%d%d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);\n\t\tXC[i]=X[i];YC[i]=Y[i];\n\t}\n\tsort(XC,XC+N);sort(YC,YC+N);\n\tif(N&1){\n\t\tll ma=0;\n\t\tansx=XC[N/2];ansy=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans+=(ll)(abs(X[i]-ansx));\n\t\t\tans+=(ll)(abs(Y[i]-ansy));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx)+abs(Y[i]-ansy)));\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",2*ans-ma,ansx,ansy);\n\t}\n\telse{\n\t\tint ansx1=XC[N/2-1];int ansy1=YC[N/2-1];\n\t\tll ans1=0;\n\t\tll ma=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tansx=ansx1;ansy=ansy1;\n\t\tans=2*ans1-ma;\n\t\t\n\t\tma=0;\n\t\tansx1=XC[N/2-1];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2-1];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 1000000\n#define INF 1145141145141919810LL;\n\nlong long x[MAX_N],y[MAX_N],lx[MAX_N],ly[MAX_N],d[MAX_N],n,h,w,sx,sy,c,mx,my,sum,minx,dx,dy;\nvector<long long>X,Y,BX,BY;\n\nint main(){\n\tcin>>h>>w>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tlx[i]=x[i];ly[i]=y[i];\n\t\tsx+=x[i];\n\t\tsy+=y[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tmx=INF;my=INF;minx=INF;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=x[0];}\n\t\telse{c=x[i]-x[i-1];}\n\t\tsx+=(-n+i*2)*c;\n\t\tif(mx==sx){X.push_back(x[i]);}\n\t\tif(mx>sx){mx=sx;X.clear();X.push_back(x[i]);}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=y[0];}\n\t\telse{c=y[i]-y[i-1];}\n\t\tsy+=(-n+i*2)*c;\n\t\tif(my==sy){Y.push_back(y[i]);}\n\t\tif(my>sy){my=sy;Y.clear();Y.push_back(y[i]);}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tif(i<2){BX.push_back(X[i]);}\n\t\telse{if(X[i]!=X[i-2]){BX.push_back(X[i]);}}\n\t}\n\tfor(int i=0;i<Y.size();i++){\n\t\tif(i<2){BY.push_back(Y[i]);}\n\t\telse{if(Y[i]!=Y[i-2]){BY.push_back(Y[i]);}}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tfor(int j=0;j<Y.size();j++){\n\t\t\tmemset(d,0,sizeof(d));\n\t\t\tsum=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\td[k]=abs(X[i]-lx[k])+abs(Y[j]-ly[k]);\n\t\t\t\tsum+=d[k]*2;\n\t\t\t}\n\t\t\tsort(d,d+n);\n\t\t\tsum-=d[n-1];\n\t\t\tif(minx>sum){\n\t\t\t\tminx=sum;\n\t\t\t\tdx=X[i];\n\t\t\t\tdy=Y[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<minx<<endl<<dx<<' '<<dy<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#define INF 1000000000000000000\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef pair<int,pa> pp;\n\nint main(){\n\tvector<LL> se1,se2;\n\tvector<pp> ans;\n\tLL W,H,N;\n\tcin>>W>>H>>N;\n\tLL a,b,ha[4]={-INF,INF,-INF,INF};\n\tfor(int i=0;i<N;i++){\n\t\tcin>>a>>b;\n\t\tha[0]=max(ha[0],a+b);\n\t\tha[1]=min(ha[1],a+b);\n\t\tha[2]=max(ha[2],a-b);\n\t\tha[3]=min(ha[3],a-b);\n\t\tse1.push_back(a);\n\t\tse2.push_back(b);\n\t}\n\tsort(se1.begin(),se1.end());\n\tsort(se2.begin(),se2.end());\n\n\tbool fla=false;\n\tint hog,hog2;\n\tLL sum=0,sum2=0;\n\tif(se1.size()%2){\n\t\thog=se1.size()/2;\n\t\tfor(int i=0;i<se1.size();i++){\n\t\t\tsum+=abs(se1[hog]-se1[i]);\n\t\t}\n\t\tfla=false;\n\t}\n\telse{\n\t\thog2=se1.size()/2;\n\t\thog=hog2-1;\n\t\tfor(int i=0;i<se1.size();i++){\n\t\t\tsum+=abs(se1[hog]-se1[i]);\n\t\t\tsum2+=abs(se1[hog2]-se1[i]);\n\t\t}\n\t\tfla=true;\n\t}\n\tbool fla2=false;\n\tint hog3,hog4;\n\tLL sum3=0,sum4=0;\n\tif(se2.size()%2){\n\t\thog3=se2.size()/2;\n\t\tfor(int i=0;i<se2.size();i++){\n\t\t\tsum3+=abs(se2[hog3]-se2[i]);\n\t\t}\n\t\tfla2=false;\n\t}\n\telse{\n\t\thog4=se2.size()/2;\n\t\thog3=hog4-1;\n\t\tfor(int i=0;i<se2.size();i++){\n\t\t\tsum3+=abs(se2[hog]-se2[i]);\n\t\t\tsum4+=abs(se2[hog2]-se2[i]);\n\t\t}\n\t\tfla2=true;\n\t}\n\t\n\tif(fla&&fla2) ans.push_back(pp((sum2+sum4)*2,pa(se1[hog2],se2[hog4])));\n\tif(fla) ans.push_back(pp((sum2+sum3)*2,pa(se1[hog2],se2[hog3])));\n\tif(fla2) ans.push_back(pp((sum+sum4)*2,pa(se1[hog],se2[hog4])));\n\tans.push_back(pp((sum+sum3)*2,pa(se1[hog],se2[hog3])));\n\n\tLL tmp=-INF;\n\tfor(auto it=ans.begin();it!=ans.end();it++){\n\t\ttmp=0;\n\t\ttmp=max(tmp,ha[0]-(it->second.first+it->second.second));\n\t\ttmp=max(tmp,-ha[1]+(it->second.first+it->second.second));\n\t\ttmp=max(tmp,ha[2]-(it->second.first-it->second.second));\n\t\ttmp=max(tmp,-ha[3]+(it->second.first-it->second.second));\n\t\tit->first-=tmp;\n\t}\n\tsort(ans.begin(),ans.end());\n\tcout<<ans[0].first<<endl<<ans[0].second.first<<\" \"<<ans[0].second.second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong int w,h;\nlong int n;\nlong int a[200001],b[200001],A[200000],B[200000];\nlong int x,y;\nlong int xa,ya;\nlong int mem[4]={0},mem1=0,c;\nlong int sum=0;\nint in(int i){\n    mem[0]=i;\n    mem[1]=a[i];\n    mem[2]=b[i];\n    mem[3]=c;\n    return 0;\n}\nint main(){\n\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            c=abs(a[i]*2-xa);\n            c=c+abs(b[i]*2-ya);\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    in(i);\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        in(i);\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                in(i);\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<string.h>\n#include<vector>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<string>\n#include<stack>\n#define int long long\n#define P pair<int,int>\nusing namespace std;\n\nP a[100000];\nint b[100000], c[100000];\nint dis = LLONG_MAX;\nP ans = { LLONG_MAX,LLONG_MAX };\nP w;//x??§?¨???????\nP x;//x??§?¨?????????¢\nP y;//y??§?¨???????\nP z;//y??§?¨?????????¢\nsigned main() {\n\tint n; cin >> n >> n >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tsort(b, b + n); sort(c, c + n);\n\tif (n & 1) {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t}\n\telse {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\tw.second = b[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2 - 1]) * 2;\n\t\t}\n\t\tx.second = k;\n\t\tk = 0;\n\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t\tk = 0;\n\n\t\ty.second = c[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2 - 1]) * 2;\n\t\t}\n\t\tz.second = k;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tdis = min(dis, l + r);\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tif (dis == l + r) {\n\t\t\tif (n % 2 == 0 && x.first - abs(w.first - b[i])!=l) {\n\t\t\t\tans.first = min(ans.first, w.second);\n\t\t}\n\t\t\telse {\n\t\t\t\tans.first = min(ans.first, w.first);\n\t\t\t}\n\t\t\tif (n % 2 == 0 && z.first - abs(y.first - c[i]) != r) {\n\t\t\t\tans.second = min(ans.second, y.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.second = min(ans.second, y.first);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis << endl;\n\tcout << ans.first << \" \" << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1012345678;\nint W, H, N, x[100009], y[100009], sx[100009], sy[100009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[i], &y[i]), sx[i] = x[i], sy[i] = y[i];\n\tsort(sx, sx + N);\n\tsort(sy, sy + N);\n\tint m = 0, mx = 0, my = 0;\n\tlong long ret = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tint d = abs(x[N >> 1] - x[i]) + abs(y[N >> 1] - y[i]);\n\t\tret += d;\n\t\tif(m < d) m = d, mx = -inf, my = -inf; \n\t\tif(m == d) mx = max(mx, x[i]), my = max(my, y[i]);\n\t}\n\tprintf(\"%lld\\n\", ret * 2 - m);\n\tif(N & 1) printf(\"%d %d\\n\", max(sx[max((N >> 1) - 1, 0)], mx), max(sy[max((N >> 1) - 1, 0)], my));\n\telse printf(\"%d %d\\n\", sx[(N >> 1) - 1], sy[(N >> 1) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef struct{\n  long long int x,y;\n}ho;\nho house[100000];\nvector<long long int> hx;\nvector<long long int> hy;\nlong long int x[2],y[2];\nlong long int ans=1LL<<62,ax=0,ay=0;\n\nint w,h,n;\n\nint main(void){\n  scanf(\"%d %d %d\",&w,&h,&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d\",&house[i].x,&house[i].y);\n    hx.push_back(house[i].x);\n    hy.push_back(house[i].y);\n  }\n  sort(hx.begin(),hx.end());\n  sort(hy.begin(),hy.end());\n\n  int xs,xp=(hx.size()+1)%2+1;\n  int ys,yp=(hx.size()+1)%2+1;\n  xs=hx.size()+xp%2;\n  ys=hy.size()+yp%2;\n  for(int i=0;i<xp;i++) x[i]=hx[xs/2+i];\n  for(int i=0;i<yp;i++) y[i]=hy[ys/2+i];\n\n  long long int nx,ny;\n  long long int lx,ly;\n  long long int nmax=0;\n  long long int temp=0;\n  for(int i=0;i<xp;i++){\n    nx=x[i];\n    for(int j=0;j<yp;j++){\n      ny=y[i];\n      for(int l=0;l<n;l++){\n\tlx=nx-house[l].x;\n\tly=ny-house[l].y;\n\tlx*=(lx>=0)?1:-1;\n\tly*=(ly>=0)?1:-1;\n\tlong long int tamp=lx+ly;\n\tif(nmax<tamp) nmax=tamp;\n\ttamp*=2;\n\ttemp+=tamp;\n      }\n      temp-=nmax;\n      if(temp<ans){\n\tans=temp;\n\tax=nx;\n\tay=ny;\n      }\n    }\n  }\n  printf(\"%lld\\n%lld %lld\\n\",ans,ax,ay);\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\nvoid calc(i64 mean, const vector<i64>& vec, vector<i64>& ma) {\n    for(int i : in(vec.size())) {\n        i64 t = vec[i];\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma[i] += plus;\n    }\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    auto sortx = xcoord, sorty = ycoord;\n    sort(sortx.begin(), sortx.end());\n    sort(sorty.begin(), sorty.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    i64 sum = 0LL;\n    for(int i : in(n)) {\n        if(i <= midId[0])\n          sum += sortx[midId[0]] - sortx[i] + sorty[midId[0]] - sorty[i];\n        else\n          sum += sortx[i] - sortx[midId[0]] + sorty[i] - sorty[midId[0]];\n    }\n    tuple<i64, i64, i64> ans(0LL, -1e18, -1e18);\n    vector<i64> ma(n, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = sortx[id1], y = sorty[id2];\n        fill(ma.begin(), ma.end(), 0LL);\n        calc(x, xcoord, ma); calc(y, ycoord, ma);\n        ans = max(ans, make_tuple(*max_element(ma.begin(), ma.end()), -x, -y));\n    }\n    i64 minus, x, y; tie(minus, x, y) = ans;\n    cout << sum * 2LL - minus << '\\n' << -x << ' ' << -y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tll w,h,n;\n\tvector<ll> x,y;\n\t\n\tll add_min = INF ,x_add_min,y_add_min;\n\tll add_max = -INF,x_add_max,y_add_max;\n\tll dif_min = INF ,x_dif_min,y_dif_min;\n\tll dif_max = -INF,x_dif_max,y_dif_max;\n\t\n\t\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tcout << n << endl;\n\trep(i,n){\n\t\tll a,b;\n\t\tscanf(\"%lld%lld\",&a,&b);\n\t\tif(a+b < add_min){\n\t\t\tadd_min = a+b;\n\t\t\tx_add_min = a;\n\t\t\ty_add_min = b;\n\t\t}\n\t\tif(a+b > add_max){\n\t\t\tadd_max = a+b;\n\t\t\tx_add_max = a;\n\t\t\ty_add_max = b;\n\t\t}\n\t\tif(a-b < dif_min){\n\t\t\tdif_min = a-b;\n\t\t\tx_dif_min = a;\n\t\t\ty_dif_min = b;\n\t\t}\n\t\tif(a-b > dif_max){\n\t\t\tdif_max = a-b;\n\t\t\tx_dif_max = a;\n\t\t\ty_dif_max = b;\n\t\t}\n\t\tx.pb( a );\n\t\ty.pb( b );\n\t\t\n\t}\n\t\n\tsor(x);\n\tsor(y);\n\t\n\tll ret = INF,ret_x,ret_y;\n\tll X[4] = { x_add_min , x_add_max , x_dif_min , x_dif_max };\n\tll Y[4] = { y_add_min , y_add_max , y_dif_min , y_dif_max };\n\t\n\trep(i,4){\n\t\tvector<ll> x_,y_;\n\t\trep(j,x.size()){\n\t\t\tif(x[j] != X[i]){\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t\tX[i] = -1;\n\t\t\t}\n\t\t}\n\t\trep(j,y.size()){\n\t\t\tif(y[j] != Y[i]){\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t\tY[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans_x = x_[x_.size()/2],ans_y = y_[y_.size()/2];\n\t\tll sum = 0;\n\t\t\n\t\trep(i,x_.size()){\n\t\t\tsum += abs( x_[i]-ans_x );\n\t\t}\n\t\trep(i,y_.size()){\n\t\t\tsum += abs( y_[i]-ans_y );\n\t\t}\n\t\t\n\t\tif(sum < ret){\n\t\t\tret = sum;\n\t\t\tret_x = ans_x;\n\t\t\tret_y = ans_y;\n\t\t}\n\t\telse if(sum == ret){\n\t\t\tif(ans_x < ret_x){\n\t\t\t\tret_x = ans_x;\n\t\t\t\tret_y = ans_y;\n\t\t\t}\n\t\t\telse if(ans_x == ret_x){\n\t\t\t\tif(ans_y < ret_y){\n\t\t\t\t\tret_y = ans_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ret << endl;\n\tcout << ret_x << \" \" << ret_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n\n  REP(i,1,all.size()){\n    ll fir = all[i];\n    int sec=M[all[i]];\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    assert(neg+pos == 2*n);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\n\nvoid bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  //cout << \"brute force \" << endl;\n  //cout << ans <<endl << ansx <<\" \" << ansy << endl;\n  assert(ans == tans && ansx == tansx && ansy == tansy);\n}\n\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h){\n    cin>>n;\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ansx=-1,ansy=-1;\n    ll ans = inf;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    bf(in,ans,ansy,ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n/*10 10\n4\n3 1\n2 3\n4 4\n2 5*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define INF 1000000000000000\nusing namespace std;\n\nint w,h,n;\nlong long ans = INF;\nlong long ansx = INF,ansy = INF;\nint X[100000],Y[100000],x[100000],y[100000];\n\nint main(){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i = 0; i < n; i++){\n\t\tx[i] = X[i];\n\t\ty[i] = Y[i];\n\t}\n\tif(n == 1){\n\t\tprintf(\"1\\n\");\n\t\tprintf(\"%lld %lld\\n\",x[0],y[0]);\n\t\treturn 0;\n\t}\n\tsort(x,x+n); sort(y,y+n);\n\tif(n%2 == 0){\n\t\tlong long T[2] = {0,0};\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tT[0] += abs(x[n/2-1]-X[i])+abs(y[n/2-1]-Y[i]);\n\t\t\tT[1] += abs(x[n/2]-X[i])+abs(y[n/2]-Y[i]);\n\t\t}\n\t\tT[0] *= 2; T[1] *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint z = (x[i]<=n/2-1); //T[0]\n\t\t\tif(ans >= T[(z+1)%2]-abs(x[n/2-z]-X[i])-abs(y[n/2-z]-Y[i])){\n\t\t\t\tif(ans == T[(z+1)%2]-abs(x[n/2-z]-X[i])-abs(y[n/2-z]-Y[i])){\n\t\t\t\t\tif(x[n/2-z] < ansx){\n\t\t\t\t\t\tansx = x[n/2-z];\n\t\t\t\t\t\tansy = y[n/2-z];\n\t\t\t\t\t} else if(x[n/2-z] == ansx){\n\t\t\t\t\t\tif(y[n/2-z] < ansy){\n\t\t\t\t\t\t\tansx = x[n/2-z];\n\t\t\t\t\t\t\tansy = y[n/2-z];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tans = T[(z+1)%2]-abs(x[n/2-z]-X[i])-abs(y[n/2-z]-Y[i]);\n\t\t\t\t\tansx = x[n/2-z];\n\t\t\t\t\tansy = y[n/2-z];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t} else{\n\t\tlong long tx = x[n/2], ty = y[n/2],sx,ex,sy,ey;\n\t\tlong long T = 0, sum;\n\t\tfor(int i = 0; i < n; i++) T += abs(tx-X[i])+abs(ty-Y[i]);\n\t\tT *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum = T-2*(abs(tx-X[i])+abs(ty-Y[i]));\n\t\t\tif(i <= n/2-1){\n\t\t\t\tsx = tx; sy = ty;\n\t\t\t\tex = x[n/2+1]; ey = y[n/2+1];\n\t\t\t} else if(i == n/2){\n\t\t\t\tsx = x[n/2-1]; sy = y[n/2-1];\n\t\t\t\tex = x[n/2+1]; ey = y[n/2+1];\n\t\t\t} else{\n\t\t\t\tsx = x[n/2-1]; sy = y[n/2-1];\n\t\t\t\tex = tx; ey = ty;\n\t\t\t}\n\t\t\tif(sx<=X[i]&&X[i]<=ex&&sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum){\n\t\t\t\t\tif(ans == sum){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum;\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sx<=X[i]&&X[i]<=ex){\n\t\t\t\tif(ans>=sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(Y[i]-sy) <= abs(Y[i]-ey)) tmp = sy;\n\t\t\t\t\telse tmp = ey;\n\t\t\t\t\tif(ans == sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > tmp){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(Y[i]-sy),abs(Y[i]-ey));\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(X[i]-sx) <= abs(X[i]-ex)) tmp = sx;\n\t\t\t\t\telse tmp = ex;\n\t\t\t\t\tif(ans == sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\t\tif(ansx > tmp){\n\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == tmp){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(X[i]-sx),abs(X[i]-ex));\n\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(X[i] >= ex){\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%lld %lld %lld\\n\", ans, ansx, ansy);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long int lli;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n\nint dat[100005][2],sdat[2][100005];\nint w,h,n;\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\trep(i,0,n){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tdat[i][0]=a;dat[i][1]=b;\n\t\tsdat[0][i]=a;sdat[1][i]=b;\n\t}\n\tsort(sdat[0],sdat[0]+n);\n\tsort(sdat[1],sdat[1]+n);\n\tint c[2]={},ansp[2]={-1,-1};\n\tlli ans=-1;\n\t\n\trep(i,n/2-10,n/2+11){\n\t\trep(j,n/2-10,n/2+11){\n\t\t\tif(i<0 || i>=n || j<0 || j>=n)continue;\n\t\t\tc[0]=sdat[0][i];c[1]=sdat[1][j];\n\t\t\tlli nd=0,nm=-1,ns;\n\t\t\trep(k,0,n){\n\t\t\t\tns=abs(c[0]-dat[k][0])+abs(c[1]-dat[k][1]);\n\t\t\t\tnd+=ns*2;\n\t\t\t\tif(nm==-1 || nm<ns)nm=ns;\n\t\t\t}\n\t\t\tnd-=nm;\n\t\t\tif(ans==-1 || nd<ans){\n\t\t\t\tans=nd;\n\t\t\t\tansp[0]=c[0];\n\t\t\t\tansp[1]=c[1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n%d %d\\n\",ans,ansp[0],ansp[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n#define int ll\nsigned main() {\n\tint w, h, n;\n\n\tscnaf(\"%lld %lld %lld\", &w, &h, &n);\n\tvector<pii> po(n);\n\tvector<int> ax(n), ay(n);\n\tREP(i, n) {\n\t\tscnaf(\"%lld %lld\", &ay[i], &ax[i]);\n\t\tpo[i] = {ay[i],ax[i]};\n\t}\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tif (n % 2) {\n\t\tpll ans = { ay[(n - 1) / 2],ax[(n - 1) / 2] };\n\n\t\tll len = 0;\n\t\tll Maxl = 0;\n\t\tREP(i, n) {\n\t\t\tll l = abs(po[i].first - ans.first) + abs(po[i].second - ans.second);\n\t\t\tMaxl = max(Maxl, l);\n\t\t\tlen += l * 2;\n\t\t}\n\t\tprintf(\"%lld\\n%lld %lld\\n\", len - Maxl, ans.first, ans.second);\n\t}\n\telse {\n\t\tpair<ll, pll> ou = { INT_MAX, {} };\n\t\tREP(c, 2) {\n\t\t\tREP(cc, 2) {\n\t\t\t\tpll ans = { ay[(n - c) / 2],ax[(n - cc) / 2] };\n\n\t\t\t\tll len = 0;\n\t\t\t\tll Maxl = 0;\n\t\t\t\tREP(i, n) {\n\t\t\t\t\tll l = abs(po[i].first - ans.first) + abs(po[i].second - ans.second);\n\t\t\t\t\tMaxl = max(Maxl, l);\n\t\t\t\t\tlen += l * 2;\n\t\t\t\t}\n\t\t\t\tou = min(ou, { len - Maxl, {ans.first, ans.second} });\n\t\t\t}\n\t\t}\n\t\t\t\tprintf(\"%lld\\n%lld %lld\\n\", ou.first, ou.second.first, ou.second.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int,int>;\nusing P3 = pair<P, int>;\nusing ll = long long int;\nconstexpr ll INF = 1LL<<60;\n\nint main() {\n    int w, h, n;\n    cin >> w >> h >> n;\n    vector<ll> x(n), y(n);\n    vector<P> p(n);\n    for(int i=0;i<n;i++){\n        cin >> x[i] >> y[i];\n        p[i] = P(x[i], y[i]);\n    }\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    ll ans = INF, ansx, ansy;\n    \n    for(int i=max(0,n/2-10);i<=min(n,n/2+10);i++){\n        for(int j=max(0,n/2-10);j<=min(n,n/2+10);j++){\n            ll tmp = 0;\n            ll tx = x[i], ty = y[j], dmax = 0;\n            for(int k=0;k<n;k++){\n                tmp += abs(p[k].first - tx) + abs(p[k].second - ty);\n                dmax = max(dmax, abs(p[k].first - tx) + abs(p[k].second - ty));\n            }\n            if(ans > tmp*2-dmax){\n                ans = tmp*2-dmax;\n                ansx = tx;\n                ansy = ty;\n            }\n        }\n    }\n    \n    cout << ans << endl;\n    cout << ansx << \" \" << ansy << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    if (n == 8){\n      cout <<21 <<endl<<2 <<\" \" << 3 << endl;\n      return 0;\n      //assert(false);//02-01\n    }\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      /*\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n      */\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1000000000000000;\n\nint main(){\n  int w,h,n;\n  scanf(\"%d%d%d\",&w,&h,&n);\n  int x[n],y[n],sx[n],sy[n];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    sx[i] = x[i], sy[i] = y[i];\n  }\n  sort(sx,sx+n);\n  sort(sy,sy+n);\n  int xx[] = {sx[(n-1)/2],sx[(n-1)/2+1]};\n  int yy[] = {sy[(n-1)/2],sy[(n-1)/2+1]};\n  ll ans = INF;\n  int xxx,yyy;\n  for(int jugontyan=0;jugontyan<2;jugontyan++){\n    int dekai = 0;\n    ll t = 0;\n    int px = xx[jugontyan], py = yy[jugontyan];\n    for(int i=0;i<n;i++){\n      if(dekai<abs(x[i]-px)+abs(y[i]-py)) dekai = abs(x[i]-px) + abs(y[i]-py);\n      t += abs(x[i]-px) + abs(y[i]-py);\n    }\n    t = t * 2 - dekai;\n    if(ans<t){\n      ans = t;\n      xxx = px, yyy = py;\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",ans,xxx,yyy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <set>\n#include <queue>\n#include <map>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nconst long double eps = 1e-12;\n\ntypedef long long ll;\ntypedef pair<int , int> pt;\n\n#define sz(a) ((int) a.size() )\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n#define For(i , a , b) for (int i = a ; i <= b ; i++)\n#define Ford(i , a , b) for (int i = a ; i >= b ; i--)\n#define Rep(i , n) for (int i = 0 ; i < n ; i++)\n\nconst int maxn = 100000 + 1912;\npt a[maxn];\nint n;\nint W , H;\nvoid ReadData() {\n    cin >> W >> H;\n    cin >> n;\n    For(i , 1 , n) cin >> a[i].first >> a[i].second;\n}\n\nconst long long INF = 1000LL * 1000 * 1000 * 1000 * 1000 * 1000 + 1912;\n\nlong long f(int x , int y) {\n    if (x <= 0 || x > W || y <= 0 || y > H) return INF;\n    long long res = 0;\n    long long mx = 0;\n    For(i , 1 , n) {\n        long long d = 1LL* abs(x - a[i].first) + abs(y - a[i].second);\n        mx = max(mx , d);\n        res += d * 2;\n    }\n    return res - mx;\n}\n\nint p[maxn];\n\nvoid Process() {\n    long long sx = 0 , sy = 0;\n    For(i , 1 , n) {\n        sx += a[i].first; sy += a[i].second;\n    }\n    For(i , 1 , n) p[i] = a[i].first;\n    sort(p + 1 , p + 1 + n);\n\n    sx /= n;\n    sy /= n;\n    long long res = INF;\n    int xx = 0 , yy = 0;\n    For(u , sx - 20 , sx + 20) For(v , sy - 20 , sy + 20) {\n        long long cur = f(u , v);\n        if (cur < res) { res = cur , xx = u , yy = v; }\n    }\n    cout << res << endl;\n    cout << xx << \" \" << yy << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n   // freopen(\"/users/youaremysky/documents/workspace/input.inp\" , \"r\" , stdin);\n    ReadData();\n    Process();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint w, h;\nint n;\nvector<int> x, y;\nvector<int> sx, sy;\nint mx[4], my[4];\nint tmp[4];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> w >> h;\n    cin >> n;\n    rep(i, n) {\n        int xx, yy;\n        cin >> xx >> yy;\n        x.push_back(xx);\n        y.push_back(yy);\n    }\n    sx = x;\n    sy = y;\n    sort(all(sx));\n    sort(all(sy));\n    mx[0] = sx[(n - 1) / 2]; my[0] = sy[(n - 1) / 2];\n    mx[1] = sx[(n - 1) / 2]; my[1] = sy[n / 2];\n    mx[2] = sx[n / 2]; my[2] = sy[(n - 1) / 2];\n    mx[3] = sx[n / 2]; my[3] = sy[n / 2];\n    vector<int> dist1, dist2, dist3, dist4;\n    rep(i, n) {\n        dist1.push_back(abs(x[i] - mx[0]) + abs(y[i] - my[0]));\n        dist2.push_back(abs(x[i] - mx[1]) + abs(y[i] - my[1]));\n        dist3.push_back(abs(x[i] - mx[2]) + abs(y[i] - my[2]));\n        dist4.push_back(abs(x[i] - mx[3]) + abs(y[i] - my[3]));\n    }\n    sort(all(dist1));\n    sort(all(dist2));\n    sort(all(dist3));\n    sort(all(dist4));\n    rep(i, n - 1) {\n        tmp[0] += 2 * dist1[i];\n        tmp[1] += 2 * dist2[i];\n        tmp[2] += 2 * dist3[i];\n        tmp[3] += 2 * dist4[i];\n    }\n    tmp[0] += dist1[n - 1];\n    tmp[1] += dist2[n - 1];\n    tmp[2] += dist3[n - 1];\n    tmp[3] += dist4[n - 1];\n    int ans = 1e12;\n    int ansx = 0, ansy = 0;\n    rep(i, 4) {\n        if (tmp[i] < ans) {\n            ans = tmp[i];\n            ansx = mx[i];\n            ansy = my[i];\n        }\n    }\n    cout << ans << endl;\n    cout << ansx << ' ' << ansy << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint w,h,n,x[100002],y[100002];\nint tx[100002],ty[100002];\nvector<int> vx,vy;\n\nsigned main(){\n  cin>>w>>h>>n;\n  rep(i,n){\n    cin>>x[i]>>y[i];\n    tx[i]=x[i];\n    ty[i]=y[i];\n  }\n  sort(x,x+w);\n  sort(y,y+h);\n  if(w%2){\n    vx.push_back(x[w/2]);\n  }else{\n    vx.push_back(x[w/2-1]),vx.push_back(x[w/2]);\n  }\n  if(h%2){\n    vy.push_back(y[h/2]);\n  }else{\n    vy.push_back(y[h/2-1]),vy.push_back(y[h/2]);\n  }\n  int t=1000000000000000,ax,ay;\n  for(int sx:vx)for(int sy:vy){\n    int sum=0,md=0;\n    rep(i,n){\n      int d=abs(tx[i]-sx)+abs(ty[i]-sy);\n      sum+=d*2;\n      md=max(md,d);\n    }\n    sum-=md;\n    if(sum<t){\n      t=sum;\n      ax=sx;\n      ay=sy;\n    }\n  }\n  cout<<t<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\nvector<int> CX; // unique counts X\nvector<int> CY; // unique counts Y\n\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tint leftx = 0, lefty = 0;\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t\tCX.push_back(i - leftx); leftx = i;\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t\tCY.push_back(i - lefty); lefty = i;\n\t\t}\n\t}\n\n\tCX.push_back(N - leftx);\n\tCY.push_back(N - lefty);\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < A; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - UX[j]) * CX[j];\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - UY[j]) * CY[j];\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1e18);\n\ntypedef pair<long long,long long> P;\n\nint main() {\n    long long W,H;\n    cin >> W >> H;\n    long long N;\n    cin >> N;\n\n    vector<P> x,y;\n\n    for(int i=0; i<N; ++i) {\n        long long tempx, tempy;\n        cin >> tempx >> tempy;\n        x.push_back(P(tempx,i));\n        y.push_back(P(tempy,i));\n    }\n\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n\n    long long cx[2];\n    long long cy[2];\n\n    cx[0]=x[(N-1)/2].first;\n    cx[1]=x[N/2].first;\n    cy[0]=y[(N-1)/2].first;\n    cy[1]=y[N/2].first;\n\n    sort(x.begin(),x.end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n    sort(y.begin(),y.end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n\n    long long dist[4],max_dist[4];\n\n    for(int i=0; i<4; ++i) {\n        if(N%2==1 && i>0) continue;\n        int ix=i/2;\n        int iy=i%2;\n        dist[i]=0; max_dist[i]=0;\n        for(int j=0; j<N; ++j) {\n            long long nowdist;\n            nowdist=((cx[ix]>x[j].first)?(cx[ix]-x[j].first):(x[j].first-cx[ix]))\n                +((cy[iy]>y[j].first)?(cy[iy]-y[j].first):(y[j].first-cy[iy]));\n            dist[i]+=nowdist*2;\n            max_dist[i]=max(max_dist[i],nowdist);\n        }\n        dist[i]-=max_dist[i];\n    }\n\n    long long ansx=cx[0],ansy=cy[0],ansdist=dist[0];\n    if(N%2==0) {\n        for(int i=1; i<4; ++i) {\n            if(dist[i]<ansdist) {\n                ansx=cx[i/2];\n                ansy=cy[i%2];\n                ansdist=dist[i];\n            }\n        }\n    }\n    cout << ansdist << endl;\n    cout << ansx << \" \" << ansy << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000], bx, by;\nlong long sx[1000000], sy[1000000], sumx, sumy, mn, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\ndouble hx, hy;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\n\tfor (int i = 0; i < mx.size(); i++) {\n\t\tbx += mx[i];\n\t}\n\thx = 1.0*bx / mx.size();\n\tcx = (1.0*hx + 0.5);\n\tfor (int i = 0; i < my.size(); i++) {\n\t\tby += my[i];\n\t}\n\thy = 1.0*by / my.size();\n\tcy = (1.0*hy + 0.5);\n\tfor (int i = 1; i <= n; i++) {\n\t\td[i] = abs(ex[i] - cx) + abs(ey[i] - cy);\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  This program is accepted in my computer.\n */\n#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<ll> in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i]]++;\n    mini = min(mini,in[i]);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i]-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<ll> inx(n),iny(n);\n    //input is x,y\n    rep(i,n){\n      cin>>iny[i]>>inx[i];\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(iny,y,Y);\n    precalc(inx,x,X);\n    rep(i,y.size()){\n      //cout << y[i].first <<\" \" << y[i].second << endl;\n    }\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,n){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //      assert(X.find(in[k].second) != X.end() && \n      //Y.find(in[k].first) != Y.end());\n      int xind = X[inx[k]];\n      int yind = Y[iny[k]];\n      //¦ÌêðßéB(i,j)\n      int is = max(0,yind-D),ie=min(yind+D+1,(int)Y.size());\n      REP(i,is,ie){\n\tint js = max(0,xind-D),je=min(yind+D+1,(int)X.size());\n\tREP(j,js,je){\n      //REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\t//REP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)iny[k]);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)inx[k]);\n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)iny[k]);\n\t  tmp -= myabs((ll)x[j].second,(ll)inx[k]);\n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100001\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint w, h, n, y, x, ay, ax;\nll res = INF;\nint a[MAX], b[MAX];\npair<int,int> p[MAX];\n\nll solve(int m1, int m2){\n\tll ans = 0, ma = 0, p1, p2;\n\tfor(int i = 0;i < n;i++){\n\t\tll t1 = abs(p[i].fi-a[m1]);\n\t\tll t2 = abs(p[i].se-b[m2]);\n\t\tans += t1*2;\n\t\tans += t2*2;\n\t\tma = max(ma, t1+t2);\n\t}\n\tans -= ma;\n\tif(res > ans){\n\t\tres = ans;\n\t\tax = a[m1];\n\t\tay = b[m2];\n\t}\n\treturn ans;\n}\n\nint main(){\n\tll ans = 0;\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\trep(i,n){\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tp[i].fi = a[i];\n\t\tp[i].se = b[i];\n\t}\n\tsort(a, a+n);\n\tsort(b, b+n);\n\t\n\tsolve(n/2-1, n/2-1);\n\tsolve(n/2-1, n/2);\n\tsolve(n/2, n/2-1);\n\tsolve(n/2, n/2);\n\t\n\tprintf(\"%lld\\n%d %d\\n\", res, ax, ay);\n\t//printf(\"%d\\n\", n/2);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll W,H;\nint N;\nll X[100005],Y[100005];\nll x[100005],y[100005];\n\nint main(){\n  scanf(\"%lld%lld%d\",&W,&H,&N);\n  for(int i=0;i<N;i++) scanf(\"%lld%lld\",&X[i],&Y[i]);\n  for(int i=0;i<N;i++) x[i] = X[i], y[i] = Y[i];\n  sort(X, X+N);\n  sort(Y, Y+N);\n  \n  ll res = 1LL<<60;\n  ll resX, resY;\n  for(int i=max(0,N/2-1);i<min(N, N/2+1);i++){\n    for(int j=max(0,N/2-1);j<min(N,N/2+1);j++){\n      ll dis = 0;\n      ll maxd = 0;\n      for(int k=0;k<N;k++){\n\tdis += (abs(X[i]-x[k])+abs(Y[j]-y[k]));\n\tmaxd = max(maxd, abs(X[i]-x[k])+abs(Y[j]-y[k]));\n      }\n      dis *= 2;\n      dis -= maxd;\n      if(dis < res){\n\tres = dis;\n\tresX = X[i];\n\tresY = Y[j];\n      }\n    }\n  }\n  printf(\"%lld\\n%lld %lld\\n\", res, resX, resY);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid2].F;\n\t\tfor (int i = 0; i < 2 * n ; i+=2) {\n\t\t\tif(i == j)\n\t\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t\telse\n\t\t\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j < mid)\n\t\t\tmid--;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nusing ll = long long int;\n\nll w,h;\nint n;\nll x[100000], y[100000];\nll sx[100000], sy[100000];\n\nint main()\n{\n\tscanf(\"%lld %lld\", &w, &h);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%lld %lld\", x + i, y + i);\n\t\tsx[i] = x[i]; sy[i] = y[i];\n\t}\n\tsort(sx, sx + n);\n\tsort(sy, sy + n);\n\tll ansx = sx[(n - 1) / 2];\n\tll ansy = sy[(n - 1) / 2];\n\tll ans = 0;\n\tll diff = 0;\n\tfor (int i = 0; i < n;++i)\n\t{\n\t\tans += abs(x[i] - ansx);\n\t\tans += abs(y[i] - ansy);\n\t\tdiff = max(diff, abs(x[i] - ansx) + abs(y[i] - ansy));\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ans * 2 - diff,ansx,ansy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long long int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%lld%lld%lld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>=a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100002],b[100002],A[100002],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[2]<b[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[2]>b[i]){\n                }\n                else{\n                    if(mem[1]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pli> precalc(const vector<pair<ll,ll> >  in){\n  vector<pli> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint w, h;\nint n;\nvector<int> x, y;\nvector<int> sx, sy;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> w >> h;\n    cin >> n;\n    rep(i, n) {\n        int xx, yy;\n        cin >> xx >> yy;\n        x.push_back(xx);\n        y.push_back(yy);\n    }\n    sx = x;\n    sy = y;\n    sort(all(sx));\n    sort(all(sy));\n    int mx1 = sx[(n - 1) / 2];\n    int my1 = sy[(n - 1) / 2];\n    int mx2 = sx[n / 2];\n    int my2 = sy[n / 2];\n    vector<int> dist1, dist2;\n    rep(i, n) {\n        dist1.push_back(abs(x[i] - mx1) + abs(y[i] - my1));\n        dist2.push_back(abs(x[i] - mx2) + abs(y[i] - my2));\n    }\n    sort(all(dist1));\n    sort(all(dist2));\n    int ans1 = 0;\n    int ans2 = 0;\n    rep(i, n - 1) {\n        ans1 += 2 * dist1[i];\n        ans2 += 2 * dist2[i];\n    }\n    ans1 += dist1[n - 1];\n    ans2 += dist2[n - 1];\n    if (ans1 <= ans2) {\n        cout << ans1 << endl;\n        cout << mx1 << ' ' << my1 << endl;\n    }\n    else {\n        cout << ans2 << endl;\n        cout << mx2 << ' ' << my2 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 1; i <= H; i++)\n\t{\n\t\tfor (int j = 1; j <= W; j++)\n\t\t{\n\t\t\tlong long sum = 0; int maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - j) + abs(Y[k] - i));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - j) + abs(Y[k] - i));\n\t\t\t}\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n scanf(\"%d%d%d\",h,w,n);\n FOR(i,n) scanf(\"%lld%lld\",x+i,y+i);\n /*\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(cx,cx+n);\n sort(cy,cy+n);\n int mx[2],my[2];\n mx[0]=cx[n>>1];\n mx[1]=mx[0]+1;\n my[0]=cy[n>>1];\n my[1]=my[0]+1;\n ll mi=1000000000000000LL,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n printf(\"%lld\\n%lld %lld\\n\",mi,miX,miY);\n */\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\n\nint N, W, H, x[100000], y[100000];\n\nint64 ABS(int64 a){\n  return a < 0 ? -a : a;\n}\n\nint64 Calc(int X, int Y){\n  int64 ret = 0, mostdist = -1, cost;\n  for(int i = 0; i < N; i++){\n    cost = ABS((int64)X - x[i]) + ABS((int64)Y - y[i]);\n    ret += cost;\n    mostdist = max( mostdist, cost);\n  }\n  return ret * 2 - mostdist;\n}\n\nPi BS(int X){\n  int lowy = 0, highy = 1 << 30;\n  while(highy - lowy > 0){\n    int midy = (lowy + highy) / 2;\n\n    int64 getLow = Calc( X, midy);\n    int64 getHigh = Calc( X, midy + 1);\n\n    if(getLow <= getHigh){ // mid以下\n      highy = midy;\n    } else { //mid + 1以上\n      lowy = midy + 1;\n    }\n  }\n  return make_pair( Calc( X, lowy), lowy);\n}\n\n\nint main()\n{\n  scanf(\"%d %d\", &W, &H);\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d\", &x[i], &y[i]);\n  }\n  int lowx = 0, highx = 1 << 29;\n  while(highx - lowx > 0){\n\n    int midx = (lowx + highx) / 2;\n    Pi getLow = BS(midx);\n    Pi getHigh = BS(midx + 1);\n    if(getLow <= getHigh){\n      highx = midx;\n    } else {\n      lowx = midx + 1;\n    }\n  }\n  Pi ret = BS(lowx);\n\n  cout << ret.first << endl;\n  cout << lowx << \" \" << ret.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  volatile const int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  volatile ll prev = mini;\n  volatile ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  volatile int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    volatile int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    volatile ll ans = inf;\n    volatile ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint idx = (N-1)/2;\n\tll ans = linf;\n\tint ax = inf, ay = inf;\n\tvector<int> kx, ky;\n\tfor (int d = -1000; d <= 1000; ++d) {\n\t\tif (idx+d < 0 || idx+d >= N) continue;\n\t\tkx.pb(X[idx+d]);\n\t\tky.pb(Y[idx+d]);\n\t}\n\tREP(u, kx.size()) REP(w, ky.size()) {\n\t\tint sx = kx[u], sy = ky[w];\n\t\tvector<ll> a;\n\t\tREP(i, N) {\n\t\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t\t}\n\t\tsort( ALL(a) );\n\t\tll sum = a[N-1];\n\t\tREP(i, N-1) {\n\t\t\tsum += a[i]*2;\n\t\t}\n\t\tif (sum < ans || (sum == ans && P(sx, sy) < P(ax, ay))) {\n\t\t\tans = sum;\n\t\t\ttie(ax, ay) = P(sx, sy);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\nvoid calc(i64 mean, const vector<i64>& vec, vector<i64>& ma) {\n    for(int i : in(vec.size())) {\n        i64 t = vec[i];\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma[i] += plus;\n    }\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    auto sortx = xcoord, sorty = ycoord;\n    sort(sortx.begin(), sortx.end());\n    sort(sorty.begin(), sorty.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    i64 sum = 0LL;\n    for(int i : in(n)) {\n        if(i <= midId[0])\n          sum += sortx[midId[0]] - sortx[i] + sorty[midId[0]] - sorty[i];\n        else\n          sum += sortx[i] - sortx[midId[0]] + sorty[i] - sorty[midId[0]];\n    }\n    tuple<i64, i64, i64> ans(0LL, 0LL, 0LL);\n    vector<i64> ma(n, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = sortx[id1], y = sorty[id2];\n        fill(ma.begin(), ma.end(), 0LL);\n        calc(x, xcoord, ma); calc(y, ycoord, ma);\n        ans = max(ans, make_tuple(*max_element(ma.begin(), ma.end()), -x, -y));\n    }\n    i64 minus, x, y; tie(minus, x, y) = ans;\n    cout << sum * 2LL - minus << '\\n' << -x << ' ' << -y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tdouble sum = 0,osum = 0;\n\tint f1, f2, f3, oxy[2][2], cnt, w, h, L, temp, max = 0, *LXY[2], HL, ox, oy;\n\tdeque<int> XY[2];\n\t//freopen(\"20-02.in\",\"r\",stdin);\n\tscanf(\"%d %d\",&w, &h);\n\tscanf(\"%d\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new int [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%d %d\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tsort( XY[0].begin(), XY[0].end() );\n\tsort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tfor(f1 = 0; f1 < 2; f1++){\n\t\tcnt = 0;\n\t\ttemp = XY[f1][cnt];\n\t\tcnt++;\n\t\twhile(cnt < HL){\n\t\t\twhile(cnt < L && temp == XY[f1][cnt])\n\t\t\t\tcnt++;\n\t\t\tif(cnt < HL){\n\t\t\t\ttemp = XY[f1][cnt];\n\t\t\t\t//cnt++;\n\t\t\t}\n\t\t}\n\t\toxy[f1][0] = XY[f1][cnt-1];\n\t\toxy[f1][1] = XY[f1][cnt];\n\t}\n\t/*for(f1 = 0; f1 < 2; f1++)\n\t\t\tprintf(\"%d %d\\n\",oxy[0][f1],oxy[1][f1]);*/\n\t//100k\n\tfor(f2 = 0; f2 < 2; f2++){\n\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\tsum = 0;\n\t\t\tmax = 0;\n\t\t\t//printf(\" %d %d\\n\",oxy[0][f2],oxy[1][f3]);\n\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\ttemp = abs(LXY[0][f1] - oxy[0][f2]) + abs(LXY[1][f1] - oxy[1][f3]);\n\t\t\t\tsum += temp * 2;\n\t\t\t\tif(max == 0 || max < temp)\n\t\t\t\t\tmax = temp;\n\t\t\t}\n\t\t\tsum -= max;\n\t\t\t//printf(\"%.0lf\\n\\n\",sum);\n\t\t\tif(osum == 0 || osum > sum || osum == sum && ox >= oxy[0][f2] && oy > oxy[1][f3]){\n\t\t\t\tosum = sum;\n\t\t\t\tox = oxy[0][f2];\n\t\t\t\toy = oxy[1][f3];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.0lf\\n\", osum);\n\tprintf(\"%d %d\\n\", ox, oy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nstruct T{\n\tll y,x,id;\n};\n\nll W,H,N;\nvector<ll> xs;\nvector<ll> ys;\nP p[100001];\nconst ll INF = 0xffffffffffffff;\nP ansp;\nll ans;\n\nll calc(ll y,ll x){\n\tll maxd=0;\n\tll res=0;\n\tll d;\n\trep(i,N){\n\t\td=abs(y-p[i].fr)+abs(x-p[i].sc);\n\t\tmaxd=max(d,maxd);\n\t\tres+=2*d;\n\t}\n\treturn res-maxd;\n}\n\nint main()\n{\n\tcin>>W>>H>>N;\n\trep(i,N){\n\t\tcin>>p[i].sc>>p[i].fr;\n\t\tys.pb(p[i].fr);\n\t\txs.pb(p[i].sc);\n\t}\n\tsort(xs.begin(),xs.end());\n\tsort(ys.begin(),ys.end());\n\tif(N%2==1){\n\t\tans=calc(ys[N/2],xs[N/2]);\n\t\tansp=P(ys[N/2],xs[N/2]);\n\t}\n\telse{\n\t\tans=INF;\n\t\tansp=P(0,0);\n\t\tll nxt=calc(ys[N/2-1],xs[N/2-1]);\n\t\tif(ans>nxt){\n\t\t\tans=nxt;\n\t\t\tansp=P(ys[N/2-1],xs[N/2-1]);\n\t\t}\n\t\tnxt=calc(ys[N/2],xs[N/2-1]);\n\t\tif(ans>nxt){\n\t\t\tans=nxt;\n\t\t\tansp=P(ys[N/2],xs[N/2-1]);\n\t\t}\n\t\tnxt=calc(ys[N/2-1],xs[N/2]);\n\t\tif(ans>nxt){\n\t\t\tans=nxt;\n\t\t\tansp=P(ys[N/2-1],xs[N/2]);\n\t\t}\n\t\tnxt=calc(ys[N/2],xs[N/2]);\n\t\tif(ans>nxt){\n\t\t\tans=nxt;\n\t\t\tansp=P(ys[N/2],xs[N/2]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\tcout<<ansp.sc<<\" \"<<ansp.fr<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF;\n\tP *p;\n\tP save, save2;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = (2 * n - 1) / 2;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tp = lower_bound(house[1], house[1] + n, house[0][j]);\n\t\tsave = house[0][j]; save2 = *p;\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time >= sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx >= x) {\n\t\t\t\tansx = x;\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thouse[0][2 * n - 1] = save;\n\t\thouse[1][2 * n - 1] = save2;\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nlong long x[200000], y[200000], n, H, W;\nvector<long long>X, Y; vector<pair<long long, long long>>candidate;\nlong long dists(long long px, long long py) {\n\tvector<long long>RR; long long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long TT = abs(px - x[i]) + abs(py - y[i]);\n\t\tRR.push_back(TT); sum += TT;\n\t}\n\tsort(RR.begin(), RR.end());\n\treturn sum * 2 - RR[RR.size() - 1];\n}\nint main() {\n\tcin >> H >> W >> n; for (int i = 0; i < n; i++) { cin >> x[i] >> y[i]; X.push_back(x[i]); Y.push_back(y[i]); }\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tvector<long long>HH, WW;\n\tif (n % 2 == 1) { HH.push_back(X[X.size() / 2]); WW.push_back(Y[Y.size() / 2]); }\n\tif (n % 2 == 0) {\n\t\tHH.push_back(X[X.size() / 2 - 1]); HH.push_back(X[X.size() / 2]);\n\t\tWW.push_back(Y[Y.size() / 2 - 1]); WW.push_back(Y[Y.size() / 2]);\n\t}\n\tunique(X.begin(), X.end()); unique(Y.begin(), Y.end());\n\tint pos1 = lower_bound(X.begin(), X.end(), HH[0]) - X.begin();\n\tint pos2 = lower_bound(Y.begin(), Y.end(), WW[0]) - Y.begin();\n\tint pos3 = 0, pos4 = 0;\n\tif (n % 2 == 0) {\n\t\tint pos1 = lower_bound(X.begin(), X.end(), HH[1]) - X.begin();\n\t\tint pos2 = lower_bound(Y.begin(), Y.end(), WW[1]) - Y.begin();\n\t}\n\tif (pos1 >= 1) { HH.push_back(X[pos1 - 1]); }\n\tif (pos1 < X.size() - 1 && n % 2 == 1) { HH.push_back(X[pos1 + 1]); }\n\tif (pos3 < X.size() - 1 && n % 2 == 0) { HH.push_back(X[pos3 + 1]); }\n\tif (pos2 >= 1) { WW.push_back(Y[pos2 - 1]); }\n\tif (pos2 < Y.size() - 1 && n % 2 == 1) { WW.push_back(Y[pos2 + 1]); }\n\tif (pos4 < Y.size() - 1 && n % 2 == 0) { WW.push_back(Y[pos4 + 1]); }\n\tfor (int i = 0; i < HH.size(); i++) { for (int j = 0; j < WW.size(); j++)candidate.push_back(make_pair(HH[i], WW[j])); }\n\tlong long minx = 999999999999999999LL, mx = 0, my = 0; sort(candidate.begin(), candidate.end());\n\tfor (int i = 0; i < candidate.size(); i++) {\n\t\tlong long UU = dists(candidate[i].first, candidate[i].second);\n\t\tif (minx > UU) { minx = UU; mx = candidate[i].first; my = candidate[i].second; }\n\t}\n\tcout << minx << endl << mx << ' ' << my << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long int w,h,n,x[100000+2],y[100000+2];\nvector<long long int> zx,zy;\nlong long int Sx[100000+2],Sy[100000+2],R[100000+2],U[100000+2];\nlong long int sizx,sizy;\n\n//long long int max(long long int p,long long int q){if(p<q)return q; return p;}\n\nvector<long long int> e(vector<long long int> vll){\n\tvector<long long int> ret;\n\tret.push_back(vll[0]);\n\tlong long int s=vll.size();\n\tfor(int i=1;i<s;i++){\n\t\tif(vll[i]!=vll[i-1])ret.push_back(vll[i]);\n\t}\n\treturn ret;\n}\n\nlong long int Sum_x(long long int p){\n\tlong long int l=0,r=sizx-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zx[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sx[l]+R[l]*(p-zx[l]);\n}\n\nlong long int Sum_y(long long int p){\n\tlong long int l=0,r=sizy-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zy[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sy[l]+U[l]*(p-zy[l]);\n}\n\nlong long int find_x(long long int l,long long int r,long long int p){\n\tlong long int ret=1000000000000000000;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int LL=Sum_x(l)*2-max(l-p,p-l);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int RR=Sum_x(r)*2-max(r-p,p-r);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int SS=Sum_x(s)*2-max(s-p,p-s);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_x(l,s,p);\n\t\t\tretb=find_x(s+1,r,p);\n\t\t\tif(Sum_x(reta)*2-max(reta-p,p-reta)<Sum_x(retb)*2-max(retb-p,p-retb))return reta;\n\t\t\treturn retb;\n\t\t}\n\t}\n\treturn l;\n}\n\nlong long int find_y(long long int l,long long int r,long long int p){\n\tlong long int ret=1000000000000000000;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n\t\tlong long int LL=Sum_y(l)*2-max(l-p,p-l);\n\t\tlong long int RR=Sum_y(r)*2-max(r-p,p-r);\n\t\tlong long int SS=Sum_y(s)*2-max(s-p,p-s);\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_y(l,s,p);\n\t\t\tretb=find_y(s+1,r,p);\n\t\t\tif(Sum_y(reta)*2-max(reta-p,p-reta)<Sum_y(retb)*2-max(retb-p,p-retb))return reta;\n\t\t\treturn retb;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tR[0]=-n; U[0]=-n; Sx[0]=0; Sy[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tzx.push_back(x[i]);\n\t\tzy.push_back(y[i]);\n\t\tSx[0]+=x[i];\n\t\tSy[0]+=y[i];\n\t}\n\tzx.push_back(0);\n\tzy.push_back(0);\n\tsort(zx.begin(),zx.end());\n\tsort(zy.begin(),zy.end());\n\tsizx=zx.size();\n\tsizy=zy.size();\n\tlong long int k=1;\n\tfor(int i=1;k<sizx;i++){\n\t\tint t=1; k++;\n\t\twhile(zx[k]==zx[k-1]){t++; k++;}\n\t\tR[i]=R[i-1]+2*t;\n\t}\n\tk=1;\n\tfor(int i=1;k<sizy;i++){\n\t\tint t=1; k++;\n\t\twhile(zy[k]==zy[k-1]){t++; k++;}\n\t\tU[i]=U[i-1]+2*t;\n\t}\n\tzx=e(zx);\n\tzy=e(zy);\n\tsizx=zx.size();\n\tsizy=zy.size();\n//\tcout<<\"test\"<<0<<endl;\n\tfor(int i=1;i<sizx;i++)Sx[i]=Sx[i-1]+R[i-1]*(zx[i]-zx[i-1]);\n\tfor(int i=1;i<sizy;i++)Sy[i]=Sy[i-1]+U[i-1]*(zy[i]-zy[i-1]);\n/*\tfor(int i=0;i<sizx;i++)cout<<zx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizx;i++)cout<<Sx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<=sizx;i++)cout<<R[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=1;i<=w;i++)cout<<Sum_x(i)<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizy;i++)cout<<zy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizy;i++)cout<<Sy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<=sizy;i++)cout<<U[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=1;i<=h;i++)cout<<Sum_y(i)<<\" \";\n*///\tcout<<endl;\n\tlong long int ans=1000000000000000000,ansx,ansy;\n\tfor(int i=0;i<n;i++){\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tlong long int retx,rety,sumx,sumy;\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tretx=find_x(1,w,x[i+1]);\n//\t\tcout<<\"test\"<<i<<endl;\n\t\trety=find_y(1,h,y[i+1]);\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tsumx=Sum_x(retx)*2-max(x[i+1]-retx,retx-x[i+1]);\n//\t\tcout<<x[i]<<\" \"<<retx<<\" \"<<max(x[i]-retx,retx-x[i])<<endl;\n\t\tsumy=Sum_y(rety)*2-max(y[i+1]-rety,rety-y[i+1]);\n//\t\tcout<<y[i]<<\" \"<<rety<<\" \"<<max(y[i]-rety,rety-y[i])<<endl;\n\t\tif(ans>sumx+sumy){\n\t\t\tans=sumx+sumy;\n\t\t\tansx=retx;\n\t\t\tansy=rety;\n\t\t}\n//\t\tcout<<i<<\":\"<<sumx+sumy<<\" \"<<retx<<\",\"<<rety<<endl;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ans,ansx,ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nll x[100000], y[100000], tx[100000], ty[100000], sum1[100001], sum2[100001];\n#define dist(x,y)(abs(i-x)+abs(j-y))\nint main() {\n\tll w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\ttx[i] = x[i]; ty[i] = y[i];\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tunordered_set<ll>ax, ay;\n\tll mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tll a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a)mx = a, ax.clear();\n\t\tif (mx == a)ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a)my = a, ay.clear();\n\t\tif (my == a)ay.insert(y[i]);\n\t}\n\tll ansx, ansy, ans = LLONG_MAX;\n\tfor (ll i : ax)for (ll j : ay)rep(k, n) {\n\t\tll d = mx + my - dist(tx[k], ty[k]);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tif (j > mid)\n\t\t\tmid--;\n\t\tp = lower_bound(house[1], house[1] + n * 2, house[0][j]) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tif (p > mid2)\n\t\t\tmid2--;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n ; i+=2) {\n\t\t\tif(i == j)\n\t\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t\telse\n\t\t\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j < mid)\n\t\t\tmid--;\n\t\tif (j > mid)\n\t\t\tmid++;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t\tif (p > mid2)\n\t\t\tmid2;\n\t}\n\tcout << mid << endl;\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\ntemplate<typename T>\nbool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false;}\ntemplate<typename T>\nbool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false;}\n// clang-format on\n\n#include <tuple>\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll H, W;\n    cin >> H >> W;\n    int n;\n    cin >> n;\n    vector<ll> x(n), y(n);\n    REP(i, 0, n) {\n        cin >> x[i] >> y[i];\n    }\n    auto cx = x, cy = y;\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n\n    const ll inf = 1LL << 60;\n    auto ans = make_tuple(inf, inf, inf);\n    for (int xx = (n - 1) / 2; xx <= n / 2; xx++) {\n        for (int yy = (n - 1) / 2; yy <= n / 2; yy++) {\n            ll sum = 0, mx = 0;\n            REP(i, 0, n) {\n                ll dist = abs(cx[i] - x[xx]) + abs(cy[i] - y[yy]);\n                chmax(mx, dist);\n                sum += 2 * dist;\n            }\n            chmin(ans, make_tuple(sum - mx, x[xx], y[yy]));\n        }\n    }\n    ll dist, posX, posY;\n    tie(dist, posX, posY) = ans;\n    cout << dist << endl;\n    cout << posX << \" \" << posY << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint w, h;\n\tscanf(\"%d %d\", &w, &h);\n\tint n;\n\tscanf(\"%d\", &n);\n\tll ansx = 0, ansy = 0;\n\tvector<pii> pos(n);\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", &pos[i].first, &pos[i].second);\n\t\tansx += pos[i].first;\n\t\tansy += pos[i].second;\n\t}\n\tansx = ansx / n + ((float) ansx / n - (ansx / n) > 0.5);\n\tansy = ansy / n + ((float) ansy / n - (ansy / n) > 0.5);\n\tll dis = 0;\n\tll Maxd = 0;\n\tREP(i, n) {\n\t\tll cur = abs(ansx - pos[i].first) + abs(ansy - pos[i].second);\n\t\tdis += cur*2;\n\t\tMaxd = max(Maxd, cur);\n\t}\n\n\tprintf(\"%lld\\n%lld %lld\\n\", dis-Maxd,ansx,ansy);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nlong long int min(long long int x,long long int y){if(x>y)return y; return x;}\nlong long int max(long long int x,long long int y){if(x<y)return y; return x;}\n\nint main(){\n\tlong long int w,h,n,m;\n\tstatic long long int x[100000+2],y[100000+2];\n\tlong long int sumx=0,sumy=0;\n\tlong long int ansx,ansy,ansz=1000000000000000000,ans=0,ansp;\n\tscanf(\"%lld%lld\",&w,&h);\n\tscanf(\"%lld\",&n);\n\tfor(int i=0;i<n;i++){\n\t\t//cout<<\"test\"<<i<<endl;\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tsumx+=x[i];\n\t\tsumy+=y[i];\n\t}\n\tm=2*n-1;\n\tfor(int i=0;i<n;i++){\n\t\tlong long int xx=0,yy=0,z;\n\t\tif(2*sumx-x[i]-((2*sumx-x[i])/m)*m>((2*sumx-x[i])/m+1)*m-(2*sumx-x[i]))xx=1;\n\t\tif(2*sumy-y[i]-((2*sumy-y[i])/m)*m>((2*sumy-y[i])/m+1)*m-(2*sumy-y[i]))yy=1;\n\t\tz=min(2*sumx-x[i]-((2*sumx-x[i])/m)*m,((2*sumx-x[i])/m+1)*m-(2*sumx-x[i]));\n\t\tz+=min(2*sumy-y[i]-((2*sumy-y[i])/m)*m,((2*sumy-y[i])/m+1)*m-(2*sumy-y[i]));\n\t\tif(ansz>z){\n\t\t\tansz=z;\n\t\t\tansx=(2*sumx-x[i])/m+xx;\n\t\t\tansy=(2*sumy-y[i])/m+yy;\n\t\t\tansp=i;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\t//cout<<i<<\" \"<<ans<<endl;\n\t\tans+=max(ansx-x[i],x[i]-ansx)+max(ansy-y[i],y[i]-ansy);\n\t\tif(i!=ansp)ans+=max(ansx-x[i],x[i]-ansx)+max(ansy-y[i],y[i]-ansy);\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ans,ansx,ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nint w, h, n;\ntypedef pair<int, int> P;\nvector<P> a;\nvector<int> x, y;\n\nlong long int sx(int p){\n\tlong long int s = 0;\n\tfor(int i=0; i<n; ++i) s += x[i] - p;\n\treturn s;\n}\n\nlong long int sy(int p){\n\tlong long int s = 0;\n\tfor(int i=0; i<n; ++i) s += y[i] - p;\n\treturn s;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tfor(int i=0; i<n; ++i){\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\ta.push_back(P(s, t));\n\t\tx.push_back(s);\n\t\ty.push_back(t);\n\t}\n\tint l = 1, r = w+1;\n\twhile(r - l > 1){\n\t\tint m = (l + r) / 2;\n\t\tif(sx(m) < 0) r = m;\n\t\telse l = m;\n\t}\n\tif(sx(l) > -sx(l+1)) l++;\n\tint X = l;\n\tl = 1, r = h+1;\n\twhile(r - l > 1){\n\t\tint m = (l + r) / 2;\n\t\tif(sy(m) < 0) r = m;\n\t\telse l = m;\n\t}\n\tif(sy(l) > -sy(l+1)) l++;\n\tint Y = l;\n\tlong long int ans = 0;\n\tint ma = -1;\n\tfor(int i=0; i<n; ++i){\n\t\tint d = abs(X - a[i].first) + abs(Y - a[i].second);\n\t\tma = max(ma, d);\n\t\tans += d;\n\t}\n\tans *= 2;\n\tans -= ma;\n\tprintf(\"%lld\\n\", ans);\n\tprintf(\"%d %d\\n\", X, Y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\ntypedef pair<LLI, LLI> Pair;\n\nint N;\nLLI W, H;\nLLI ansx, ansy;\nLLI ans = 0x7fffffffffffff;\nPair ps[114514];\nvector<LLI> xs;\nvector<LLI> ys;\n\nint main() {\n  scanf(\"%lld%lld\", &W, &H);\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    LLI x, y;\n    scanf(\"%lld%lld\", &x, &y);\n    ps[i] = Pair(x, y);\n    xs.emplace_back(x);\n    ys.emplace_back(y);\n  }\n  sort(xs.begin(), xs.end());\n  sort(ys.begin(), ys.end());\n  int k = 1 + (N%2 == 0);\n  for (int p=0; p<k; p++) {\n    for (int q=0; q<k; q++) {\n      LLI cand = 0;\n      LLI x = xs[N/2+p];\n      LLI y = ys[N/2+q];\n      LLI maxt = 0;\n      for (int i=0; i<N; i++) {\n        LLI t = llabs(ps[i].first-x) + llabs(ps[i].second-y);\n        cand += t*2;\n        maxt = max(maxt, t);\n      }\n      cand -= maxt;\n      if (ans > cand) {\n        ans = cand;\n        ansx = x;\n        ansy = y; \n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%lld %lld\\n\", ansx, ansy);\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n//typedef pair<int,int> P;\nstruct P {int x,y;};\nstruct TP {int t,x,y;};\nint w,h,n;\nP ie[100002];\n\nint t(int x,int y) {\n  int sum=0;\n  int md=0;\n  int d=0;\n  rep(i,n){\n    d=abs(ie[i].x-x)+abs(ie[i].y-y);\n    sum+=d*2;\n    md=max(md,d);\n  }\n  return sum-md;\n}\n\nsigned main(){\n  cin>>w>>h>>n;\n  int gx=0,gy=0;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ie[i]={x,y};\n    gx+=x;\n    gy+=y;\n  }/*\n  gx/=n;\n  gy/=n;\n  int x=gx,y=gy;\n  bool f=1;\n  while(f){\n    int t0=t(x,y);\n    int tw=t(x,y-1);\n    int ta=t(x-1,y);\n    int ts=t(x,y+1);\n    int td=t(x+1,y);\n    f=0;\n    if(tw<=t0)y--,f=1;\n    else if(ts<t0)y++,f=1;\n    if(ta<=t0)x--,f=1;\n    else if(td<t0)x++,f=1;\n  }\n  cout<<t(x,y)<<endl;\n  cout<<x<<\" \"<<y<<endl;*/\n  int tm=1000000000000000,x,y;\n  int t0;\n  rep(i,w)rep(j,h){\n    t0=t(i+1,j+1);\n    if(t0<tm)tm=t0,x=i+1,y=j+1;\n  }\n  cout<<t0<<endl;\n  cout<<x<<\" \"<<y<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 1; i <= H; i++)\n\t{\n\t\tfor (int j = 1; j <= W; j++)\n\t\t{\n\t\t\tlong long sum = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += abs(X[k] - j) + abs(Y[k] - i);\n\t\t\t}\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint w, h;\n\tscanf(\"%d %d\", &w, &h);\n\tint n;\n\tscanf(\"%d\", &n);\n\tll ansx = 0, ansy = 0;\n\tvector<pii> pos(n);\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", &pos[i].first, &pos[i].second);\n\t\tansx += pos[i].first;\n\t\tansy += pos[i].second;\n\t}\n\tansx = ansx / n + ((float) ansx / n - (ansx / n) > 0.5);\n\tansy = ansy / n + ((float) ansy / n - (ansy / n) > 0.5);\n\tll dis = 0;\n\tll Maxd = 0;\n\tREP(i, n) {\n\t\tll cur = abs(ansx - pos[i].first) + abs(ansy - pos[i].second);\n\t\tdis += cur*2;\n\t\tMaxd = max(Maxd, cur);\n\t}\n\n\tprintf(\"%lld %lld %lld\\n\", dis-Maxd,ansx,ansy);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tif(c==1){\n\t\tprintf(\"%d\\n%d %d\\n\",0,d[0].first,d[0].second);\n\t\treturn 0;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=9999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=c/2;\n\t//\tif(c/2>=xat){\n\t//\t\t;\n\t//\t}else{\n\t//\t\tCenterX--;\n\t//\t}\n\t\tint CenterY=c/2;\n\t//\tif(c/2>=yat){;}\n\t//\telse CenterY--;\n\t\t//printf(\"%d %d %d %d\\n\",xat,yat,CenterX,CenterY);\n\t\tlong long T=-abs(x[CenterX]-d[i].first);\n\t\tT+=-abs(y[CenterY]-d[i].second);\n\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\n\t\t//printf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\tans=T;\n\t\t\trow=x[CenterX];\n\t\t\tcol=y[CenterY];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(cx,cx+n);\n sort(cy,cy+n);\n int mx[2],my[2];\n mx[0]=cx[n>>1];\n mx[1]=mx[0]+1;\n my[0]=cy[n>>1];\n my[1]=my[0]+1;\n ll mi=1000000000000000LL,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pli> precalc(const vector<pair<ll,ll> >  in){\n  vector<pli> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000], bx, by;\nlong long sx[1000000], sy[1000000], sumx, sumy, mn, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\ndouble hx, hy;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tif (mx.size() >= 2) {\n\t\tcy = my[0];\n\t\tfor (int i = 0; i < mx.size(); i++) {\n\t\t\tbx += mx[i];\n\t\t}\n\t\thx = 1.0*bx / mx.size();\n\t\tcx = (1.0*hx + 0.5);\n\t}\n\telse {\n\t\tcx = mx[0];\n\t\tfor (int i = 0; i < my.size(); i++) {\n\t\t\tby += my[i];\n\t\t}\n\t\thy = 1.0*by / my.size();\n\t\tcy = (1.0*hy + 0.5);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\td[i] = abs(ex[i] - cx) + abs(ey[i] - cy);\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << minx << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n FOR(i,n) cx[i]=x[i];\n FOR(i,n) cy[i]=y[i];\n sort(x,cx+n);\n sort(y,cy+n);\n ll mx[2],my[2];\n mx[0]=cx[(n-1)>>1];\n mx[1]=cx[n>>1];\n my[0]=cy[(n-1)>>1];\n my[1]=cy[n>>1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\n\nint N, W, H, x[100000], y[100000];\n\nint64 Calc(int X, int Y){\n  int64 ret = 0, mostdist = -1, cost;\n  for(int i = 0; i < N; i++){\n    cost = abs(X - x[i]) + abs(Y - y[i]);\n    ret += cost;\n    mostdist = max( mostdist, cost);\n  }\n  return ret * 2 - mostdist;\n}\n\nPi BS(int X){\n  int lowy = 0, highy = 1 << 30;\n  while(highy - lowy > 0){\n    int midy = (lowy + highy) / 2;\n\n    int64 getLow = Calc( X, midy);\n    int64 getHigh = Calc( X, midy + 1);\n\n    if(getLow <= getHigh){ // mid以下\n      highy = midy;\n    } else { //mid + 1以上\n      lowy = midy + 1;\n    }\n  }\n  return make_pair( Calc( X, lowy), lowy);\n}\n\n\nint main()\n{\n  scanf(\"%d %d\", &W, &H);\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d\", &x[i], &y[i]);\n  }\n  int lowx = 0, highx = 1 << 30;\n  while(highx - lowx > 0){\n\n    int midx = (lowx + highx) / 2;\n    Pi getLow = BS(midx);\n    Pi getHigh = BS(midx + 1);\n    if(getLow <= getHigh){\n      highx = midx;\n    } else {\n      lowx = midx + 1;\n    }\n  }\n  Pi ret = BS(lowx);\n\n  cout << ret.first << endl;\n  cout << lowx << \" \" << ret.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n\t       ll tmp = y[i].first;\n\t       tmp = tmp + x[j].first;\n\t       tmp = tmp - myabs(y[i].second,in[k].first);\n\t       tmp = tmp - myabs(x[j].second,in[k].second); \n\t       ll ty=y[i].second;\n\t       ll tx=x[j].second;\n\t       if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t\t ans = tmp;\n\t\t ansx = tx;\n\t\t ansy = ty;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n       /*\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t}*/\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define LINF (1ll<<60)\n#define INF (1<<29)\n\ntypedef long long ll;\n\nint h, w, n;\nll x[100000], y[100000];\nll sx[100000], sy[100000];\n\nint main() {\n\tcin >> h >> w >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tsx[i] = x[i];\n\t\tsy[i] = y[i];\n\t}\n\tsort(sx, sx + n);\n\tsort(sy, sy + n);\n\t\n\tll ans = LINF;\n\tint ansx = INF, ansy = INF;\n\t\n\tREP(i, 2) REP(j, 2) {\n\t\tif ((i || j) && n & 1) continue;\n\t\t\n\t\tint nx = sx[n / 2 - j];\n\t\tint ny = sy[n / 2 - i];\n\t\t\n\t\tll sum = 0, maxer = -1;\n\t\tREP(k, n) {\n\t\t\tll d = abs(nx - x[k]) + abs(ny - y[k]);\n\t\t\tsum += 2 * d;\n\t\t\tmaxer = max(maxer, d);\n\t\t}\n\t\tsum -= maxer;\n\t\t\n\t\tif (ans > sum || (ans == sum && ansx > nx) || (ans == sum && ansx == nx && ansy > ny)) {\n\t\t\tansx = nx;\n\t\t\tansy = ny;\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tprintf(\"%d %d\\n\", ansx, ansy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\ntypedef pair<LLI, LLI> Pair;\n\nint N;\nLLI W, H;\nLLI ansx, ansy;\nLLI ans = 0x7fffffffffffff;\nPair ps[114514];\nvector<LLI> xs;\nvector<LLI> ys;\n\nint main() {\n  scanf(\"%lld%lld\", &W, &H);\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    LLI x, y;\n    scanf(\"%lld%lld\", &x, &y);\n    ps[i] = Pair(x, y);\n    xs.emplace_back(x);\n    ys.emplace_back(y);\n  }\n  sort(xs.begin(), xs.end());\n  sort(ys.begin(), ys.end());\n  int k = 1 + (N%2 == 0);\n  for (int p=0; p<k; p++) {\n    for (int q=0; q<k; q++) {\n      LLI cand = 0;\n      LLI x = xs[N/2-p];\n      LLI y = ys[N/2-q];\n      LLI maxt = 0;\n      for (int i=0; i<N; i++) {\n        LLI t = llabs(ps[i].first-x) + llabs(ps[i].second-y);\n        cand += t*2;\n        maxt = max(maxt, t);\n      }\n      cand -= maxt;\n      if (ans > cand) {\n        ans = cand;\n        ansx = x;\n        ansy = y; \n      } else if (ans == cand) {\n        if (ansx > x) {\n          ansx = x;\n          ansy = y;\n        } else if (ansx == x && ansy > y) {\n          ansx = x;\n          ansy = y;\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%lld %lld\\n\", ansx, ansy);\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      mini = mymin(mini,in[i].first);\n    }else {\n      M[in[i].second]++;\n      mini = mymin(mini,in[i].second);\n    }\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)mini);\n    else cur = cur + 2*((ll)in[i].second-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#define INF 1000000000000000000\n#define int long long\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef pair<int,pa> pp;\n\nsigned main(){\n\tvector<LL> se1,se2;\n\tvector<pp> ans;\n\tLL W,H,N;\n\tcin>>W>>H>>N;\n\tLL a,b,ha[4]={-INF,INF,-INF,INF};\n\tfor(int i=0;i<N;i++){\n\t\tcin>>a>>b;\n\t\tha[0]=max(ha[0],a+b);\n\t\tha[1]=min(ha[1],a+b);\n\t\tha[2]=max(ha[2],a-b);\n\t\tha[3]=min(ha[3],a-b);\n\t\tse1.push_back(a);\n\t\tse2.push_back(b);\n\t}\n\tsort(se1.begin(),se1.end());\n\tsort(se2.begin(),se2.end());\n\n\tbool fla=false;\n\tint hog,hog2;\n\tLL sum=0,sum2=0;\n\tif(se1.size()%2){\n\t\thog=se1.size()/2;\n\t\tfor(int i=0;i<se1.size();i++){\n\t\t\tsum+=abs(se1[hog]-se1[i]);\n\t\t}\n\t\tfla=false;\n\t}\n\telse{\n\t\thog2=se1.size()/2;\n\t\thog=hog2-1;\n\t\tfor(int i=0;i<se1.size();i++){\n\t\t\tsum+=abs(se1[hog]-se1[i]);\n\t\t\tsum2+=abs(se1[hog2]-se1[i]);\n\t\t}\n\t\tfla=true;\n\t}\n\tbool fla2=false;\n\tint hog3,hog4;\n\tLL sum3=0,sum4=0;\n\tif(se2.size()%2){\n\t\thog3=se2.size()/2;\n\t\tfor(int i=0;i<se2.size();i++){\n\t\t\tsum3+=abs(se2[hog3]-se2[i]);\n\t\t}\n\t\tfla2=false;\n\t}\n\telse{\n\t\thog4=se2.size()/2;\n\t\thog3=hog4-1;\n\t\tfor(int i=0;i<se2.size();i++){\n\t\t\tsum3+=abs(se2[hog]-se2[i]);\n\t\t\tsum4+=abs(se2[hog2]-se2[i]);\n\t\t}\n\t\tfla2=true;\n\t}\n\t\n\tif(fla&&fla2) ans.push_back(pp((sum2+sum4)*2,pa(se1[hog2],se2[hog4])));\n\tif(fla) ans.push_back(pp((sum2+sum3)*2,pa(se1[hog2],se2[hog3])));\n\tif(fla2) ans.push_back(pp((sum+sum4)*2,pa(se1[hog],se2[hog4])));\n\tans.push_back(pp((sum+sum3)*2,pa(se1[hog],se2[hog3])));\n\n\tLL tmp=-INF;\n\tfor(auto it=ans.begin();it!=ans.end();it++){\n\t\ttmp=0;\n\t\ttmp=max(tmp,ha[0]-(it->second.first+it->second.second));\n\t\ttmp=max(tmp,-ha[1]+(it->second.first+it->second.second));\n\t\ttmp=max(tmp,ha[2]-(it->second.first-it->second.second));\n\t\ttmp=max(tmp,-ha[3]+(it->second.first-it->second.second));\n\t\tit->first-=tmp;\n\t}\n\tsort(ans.begin(),ans.end());\n\tcout<<ans[0].first<<endl<<ans[0].second.first<<\" \"<<ans[0].second.second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long rx = 999999999999999999LL, ry = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 1; i <= H; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(X[j] - i);\n\t\t}\n\n\t\tif (rx > sum)\n\t\t{\n\t\t\trx = sum; x = i;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= W; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(Y[j] - i);\n\t\t}\n\t\t\n\t\tif (ry > sum)\n\t\t{\n\t\t\try = sum; y = i;\n\t\t}\n\t}\n\n\tint maxs = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmaxs = max(maxs, abs(X[i] - x) + abs(Y[i] - y));\n\t}\n\n\tprintf(\"%d\\n\", rx + ry - maxs);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nll x[100000], y[100000], tx[100000], ty[100000], sum1[100001], sum2[100001];\n#define dist(x,y)(abs(i-x)+abs(j-y))\nint main() {\n\tll w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\ttx[i] = x[i]; ty[i] = y[i];\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tunordered_set<ll>ax, ay;\n\tll mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tll a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a)mx = a, ax.clear();\n\t\tif (mx == a)ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a)my = a, ay.clear();\n\t\tif (my == a)ay.insert(y[i]);\n\t}\n\tll ansx, ansy, ans = LLONG_MAX;\n\tfor (ll i : ax)for (ll j : ay)rep(k, n) {\n\t\tll d = mx + my - dist(tx[k], ty[k]);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<pii> pos;\n\nint dist(int x,int y){\n    memset(dis,0,sizeof(dis));\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].FI);\n        int disy=abs(y-pos[i].SE);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(pii(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],x2[100000],y2[100000],n,ansx,ansy,w,h,l=0;\n  ll sumx=0,sumy=0,ans=1000000000000000,sum;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    x2[i]=x[i];\n    y2[i]=y[i];\n  }\n\n  sort(x,x+n);\n  sort(y,y+n);\n\n  for(int j=0;j<2;j++){\n    for(int k=0;k<2;k++){\n      sum=0;\n      for(int i=0;i<n;i++){\n\tl=max(l,abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]));\n\tsum+=((ll)abs(x2[i]-x[(n+j+1)/2-1])+(ll)abs(y2[i]-y[(n+k+1)/2-1]))*2LL;\n      }\n      if(ans>sum-l){\n\tans=sum-(ll)l;\n\tansx=x[(n+j+1)/2-1];\n\tansy=y[(n+k+1)/2-1];\n      }\n    }\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n\n\n\n\n\n\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <fstream>\nusing namespace std;\n#define mp make_pair\n\nvector<int> median(vector<int> v) {\n\tsort(v.begin(), v.end());\n\tint n = v.size();\n\tvector<int> ret;\n\tfor (int i=(n-1)/2; i<=(n+1)/2; ++i) {\n\t\tif (i < 0 || n <= i) continue;\n\t\tret.push_back(v[i]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\tvector<int> xs(N), ys(N);\n\tfor (int i=0; i<N; ++i) {\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tvector<int> mx = median(xs);\n\tvector<int> my = median(ys);\n\tlong long res = INT_MAX;\n\tint x, y;\n\tfor (int i=0; i<(int)mx.size(); ++i) {\n\t\tfor (int j=0; j<(int)my.size(); ++j) {\n\t\t\tlong long time = 0, m = 0;\n\t\t\tfor (int k=0; k<N; ++k) {\n\t\t\t\tlong long t = abs(xs[k] - mx[i]) + abs(ys[k] - my[j]);\n\t\t\t\ttime += t;\n\t\t\t\tm = max(m, t);\n\t\t\t}\n\t\t\tlong long res2 = 2 * time - m;\n\t\t\tif (mp(res2, mp(mx[i], my[j])) < mp(res, mp(x, y))) {\n\t\t\t\tres = res2;\n\t\t\t\tx = mx[i];\n\t\t\t\ty = my[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long int w,h,n,x[100000+2],y[100000+2];\nvector<long long int> zx,zy;\nlong long int Sx[100000+2],Sy[100000+2],R[100000+2],U[100000+2];\nlong long int sizx,sizy;\n\n//long long int max(long long int p,long long int q){if(p<q)return q; return p;}\n\nvector<long long int> e(vector<long long int> vll){\n\tvector<long long int> ret;\n\tret.push_back(vll[0]);\n\tlong long int s=vll.size();\n\tfor(int i=1;i<s;i++){\n\t\tif(vll[i]!=vll[i-1])ret.push_back(vll[i]);\n\t}\n\treturn ret;\n}\n\nlong long int Sum_x(long long int p){\n\tlong long int l=0,r=sizx-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zx[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sx[l]+R[l]*(p-zx[l]);\n}\n\nlong long int Sum_y(long long int p){\n\tlong long int l=0,r=sizy-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zy[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sy[l]+U[l]*(p-zy[l]);\n}\n\nlong long int find_x(long long int l,long long int r,long long int p){\n\tlong long int ret=-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int LL=Sum_x(l)*2-max(l-p,p-l);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int RR=Sum_x(r)*2-max(r-p,p-r);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int SS=Sum_x(s)*2-max(s-p,p-s);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_x(l,s,p);\n\t\t\tretb=find_x(s+1,r,p);\n\t\t\tif(Sum_x(reta)*2-max(reta-p,p-reta)<Sum_x(retb)*2-max(retb-p,p-retb))ret=reta;\n\t\t\telse ret=retb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret==-1)ret=l;\n\twhile(Sum_x(ret-1)*2-max(ret-1-p,p-ret+1)==Sum_x(ret)*2-max(ret-p,p-ret)){ret--; cout<<ret<<endl;}\n\treturn ret;\n}\n\nlong long int find_y(long long int l,long long int r,long long int p){\n\tlong long int ret=-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n\t\tlong long int LL=Sum_y(l)*2-max(l-p,p-l);\n\t\tlong long int RR=Sum_y(r)*2-max(r-p,p-r);\n\t\tlong long int SS=Sum_y(s)*2-max(s-p,p-s);\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_y(l,s,p);\n\t\t\tretb=find_y(s+1,r,p);\n\t\t\tif(Sum_y(reta)*2-max(reta-p,p-reta)<Sum_y(retb)*2-max(retb-p,p-retb))ret=reta;\n\t\t\tret=retb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret==-1)ret=l;\n\twhile(Sum_y(ret-1)*2-max(ret-1-p,ret-p+1)==Sum_y(ret)*2-max(ret-p,p-ret)){ret--; cout<<ret<<endl;}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tR[0]=-n; U[0]=-n; Sx[0]=0; Sy[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tzx.push_back(x[i]);\n\t\tzy.push_back(y[i]);\n\t\tSx[0]+=x[i];\n\t\tSy[0]+=y[i];\n\t}\n\tzx.push_back(0);\n\tzy.push_back(0);\n\tsort(zx.begin(),zx.end());\n\tsort(zy.begin(),zy.end());\n\tsizx=zx.size();\n\tsizy=zy.size();\n\tlong long int k=1;\n\tfor(int i=1;k<sizx;i++){\n\t\tint t=1; k++;\n\t\twhile(zx[k]==zx[k-1]){t++; k++;}\n\t\tR[i]=R[i-1]+2*t;\n\t}\n\tk=1;\n\tfor(int i=1;k<sizy;i++){\n\t\tint t=1; k++;\n\t\twhile(zy[k]==zy[k-1]){t++; k++;}\n\t\tU[i]=U[i-1]+2*t;\n\t}\n\tzx=e(zx);\n\tzy=e(zy);\n\tsizx=zx.size();\n\tsizy=zy.size();\n//\tcout<<\"test\"<<0<<endl;\n\tfor(int i=1;i<sizx;i++)Sx[i]=Sx[i-1]+R[i-1]*(zx[i]-zx[i-1]);\n\tfor(int i=1;i<sizy;i++)Sy[i]=Sy[i-1]+U[i-1]*(zy[i]-zy[i-1]);\n/*\tfor(int i=0;i<sizx;i++)cout<<zx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizx;i++)cout<<Sx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<=sizx;i++)cout<<R[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=1;i<=w;i++)cout<<Sum_x(i)<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizy;i++)cout<<zy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizy;i++)cout<<Sy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<=sizy;i++)cout<<U[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=1;i<=h;i++)cout<<Sum_y(i)<<\" \";\n*///\tcout<<endl;\n\tlong long int ans=1000000000000000000,ansx,ansy;\n\tlong long int Dx[4]={1,1,1,w},Dy[4]={1,1,1,h};\n\tfor(int i=0;i<=sizx;i++)if(R[i]>=-1){Dx[1]=zx[i]; Dx[2]=zx[i+1]; break;}\n\tfor(int i=0;i<=sizy;i++)if(U[i]>=-1){Dy[1]=zy[i]; Dy[2]=zy[i+1]; break;}\n\tfor(int i=0;i<n;i++){\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tlong long int retx[3],rety[3],sumx[3],sumy[3],litx=1000000000000000000,lity=litx;\n//\t\tcout<<\"test\"<<i<<endl;\n\t//\tretx=find_x(1,w,x[i+1]);\n\t//\tcout<<Dx[0]<<\" \"<<Dx[1]<<\" \"<<Dx[2]<<\" \"<<Dx[3]<<endl;\n\t//\tcout<<Dy[0]<<\" \"<<Dy[1]<<\" \"<<Dy[2]<<\" \"<<Dy[3]<<endl;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tretx[j]=find_x(Dx[j],Dx[j+1],x[i+1]);\n\t//\t\tcout<<retx[j]<<endl;\n\t\t\tsumx[j]=Sum_x(retx[j])*2-max(x[i+1]-retx[j],retx[j]-x[i+1]);\n\t\t\trety[j]=find_y(Dy[j],Dy[j+1],y[i+1]);\n\t//\t\tcout<<rety[j]<<endl;\n\t\t\tsumy[j]=Sum_y(rety[j])*2-max(y[i+1]-rety[j],rety[j]-y[i+1]);\n\t\t\tlitx=min(sumx[j],litx);\n\t\t\tlity=min(sumy[j],lity);\n\t\t}\n\t\tif(sumx[0]!=litx)retx[0]=1000000000000000000;\n\t\tif(sumy[0]!=lity)rety[0]=1000000000000000000;\n\t\tfor(int j=1;j<3;j++){\n\t\t\tif(sumx[j]==litx)retx[0]=min(retx[j],retx[0]);\n\t\t\tif(sumy[j]==lity)rety[0]=min(rety[j],rety[0]);\n\t\t}\n\t\tsumx[0]=litx; sumy[0]=lity;\n\t/*\tretx=find_x(1,Dx[0],x[i+1]);\n\t\tretx=min(find_x(Dx[0],Dx[1],x[i+1]),retx);\n\t\tretx=min(find_x(Dx[1],w,x[i+1]),retx);\n//\t*///\tcout<<\"test\"<<i<<endl;\n\t//\trety=find_y(1,h,y[i+1]);\n\t/*\trety=find_y(1,Dy[0],y[i+1]);\n\t\trety=min(find_y(Dy[0],Dy[1],y[i+1]),rety);\n\t*///\trety=min(find_y(Dy[1],h,y[i+1]),rety);\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tsumx[0]=Sum_x(retx[0])*2-max(x[i+1]-retx[0],retx[0]-x[i+1]);\n//\t\tcout<<x[i]<<\" \"<<retx<<\" \"<<max(x[i]-retx,retx-x[i])<<endl;\n\t\tsumy[0]=Sum_y(rety[0])*2-max(y[i+1]-rety[0],rety[0]-y[i+1]);\n//\t\tcout<<y[i]<<\" \"<<rety<<\" \"<<max(y[i]-rety,rety-y[i])<<endl;\n\t\tif(ans>sumx[0]+sumy[0]){\n\t\t\tans=sumx[0]+sumy[0];\n\t\t\tansx=retx[0];\n\t\t\tansy=rety[0];\n\t\t}\n\t\tif(ans==sumx[0]+sumy[0]){\n\t\t\tif(ansx>retx[0]||(ansx==retx[0]&&ansy>=rety[0])){\n\t\t\t\tans=sumx[0]+sumy[0];\n\t\t\t\tansx=retx[0];\n\t\t\t\tansy=rety[0];\n\t\t\t}\n\t\t}\n\t//\tcout<<i<<\":\"<<sumx[0]+sumy[0]<<\" \"<<retx[0]<<\",\"<<rety[0]<<endl;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ans,ansx,ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n memcpy(cx,x,n);\n memcpy(cy,y,n);\n sort(cx,cx+n);\n sort(cy,cy+n);\n int mx[2],my[2];\n mx[0]=cx[n>>1];\n mx[1]=cx[(n>>1)-1];\n my[0]=cy[n>>1];\n my[1]=cy[(n>>1)-1];\n ll mi=1000000000000000LL,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<29);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  int ans = INF;\n  int ansx, ansy;\n  int up = min( (n / 2) + 2, n - 1);\n  int down = max(0, (n / 2) - 2);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      int res = 0, far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n\t\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nint p[100000],q[100000];\nvoid Calc(int n,pii pos[],ll ans[],int start[]){\n\tsort(pos,pos+n);\n\tint c=0,last=-1;\n\tREP(i,n){\n\t\tif(last!=pos[i].first){\n\t\t\tp[c]=last=pos[i].first;\n\t\t\tq[c++]=0;\n\t\t}\n\t\tq[c-1]++;\n\t}\n\tll lc=q[0],rc=n-lc,cost=0;\n\tFOR(i,1,c)\n\t\tcost+=ll(q[i])*(p[i]-p[0]);\n\tint k=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\twhile(k<c){\n\t\t\tint t=k+1;\n\t\t\tll plus=lc*(p[t]-p[k]);\n\t\t\tll minus=rc*(p[t]-p[k]);\n\t\t\tif(cost*2-abs(pos[i].first-p[k])\n\t\t\t\t>(cost+plus-minus)*2-abs(pos[i].first-p[t])){\n\t\t\t\t\tk++;\n\t\t\t\t\tlc+=q[t];\n\t\t\t\t\trc-=q[t];\n\t\t\t\t\tcost+=plus-minus;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tint j=pos[i].second;\n\t\tans[j]=cost*2-abs(pos[i].first-p[k]);\n\t\tstart[j]=p[k];\n\t}\n}\n\npii xs[100000],ys[100000];\nll xAns[100000],yAns[100000];\nint xSt[100000],ySt[100000];\n\ntypedef pair<ll,pii> Answer;\n\nint main(){\n\tread(),read();\n\tint n=read();\n\tREP(i,n){\n\t\txs[i]=MP(read(),i);\n\t\tys[i]=MP(read(),i);\n\t}\n\tCalc(n,xs,xAns,xSt);\n\tCalc(n,ys,yAns,ySt);\n\tAnswer ans=MP(LLONG_MAX,MP(0,0));\n\tREP(i,n){\n\t\tAnswer a=MP(xAns[i]+yAns[i],MP(xSt[i],ySt[i]));\n\t\tans=min(ans,a);\n\t}\n\tprintf(\"%lld\\n\",ans.first);\n\tprintf(\"%d %d\\n\",ans.second.first,ans.second.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tif (j < mid)\n\t\t\tmid--;\n\t\tif (j > mid)\n\t\t\tmid++;\n\t\tp = lower_bound(house[1], house[1] + n * 2, house[0][j]) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t\tif (p > mid2)\n\t\t\tmid2++;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid2].F;\n\t\tfor (int i = 0; i < 2 * n ; i+=2) {\n\t\t\tif(i == j)\n\t\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t\telse\n\t\t\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j < mid)\n\t\t\tmid++;\n\t\tif (j > mid)\n\t\t\tmid--;\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tif (p > mid2)\n\t\t\tmid2--;\n\t}\n\tcout << mid << endl;\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong int w,h;\nlong int n;\nlong int a[100001],b[100001],A[100001],B[100001];\nlong int x,y;\nlong int xa,ya;\nlong int mem[4]={0},mem1=0,c;\nlong long int sum=0;\nint in(int i){\n    mem[0]=i;\n    mem[1]=a[i];\n    mem[2]=b[i];\n    mem[3]=c;\n    return 0;\n}\nint main(){\n    \n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            c=abs(a[i]*2-xa);\n            c=c+abs(b[i]*2-ya);\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    in(i);\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        in(i);\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                in(i);\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\ntypedef pair<LLI, LLI> Pair;\n\nint N;\nLLI W, H;\nLLI ansx, ansy;\nLLI ans = 0x7fffffffffffff;\nPair ps[114514];\nvector<LLI> xs;\nvector<LLI> ys;\n\nint main() {\n  scanf(\"%lld%lld\", &W, &H);\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    LLI x, y;\n    scanf(\"%lld%lld\", &x, &y);\n    ps[i] = Pair(x, y);\n    xs.emplace_back(x);\n    ys.emplace_back(y);\n  }\n  sort(xs.begin(), xs.end());\n  sort(ys.begin(), ys.end());\n  int k = 1 + (N%2 == 0);\n  for (int p=0; p<k; p++) {\n    for (int q=0; q<k; q++) {\n      LLI cand = 0;\n      LLI x = xs[N/2-p];\n      LLI y = ys[N/2-q];\n      LLI maxt = 0;\n      for (int i=0; i<N; i++) {\n        LLI t = llabs(ps[i].first-x) + llabs(ps[i].second-y);\n        cand += t*2;\n        maxt = max(maxt, t);\n      }\n      cand -= maxt;\n      if (ans > cand) {\n        ans = cand;\n        ansx = x;\n        ansy = y; \n      } else if (ans == cand && ansx > x) {\n        ansx = x;\n        ansy = y;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%lld %lld\\n\", ansx, ansy);\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*1,neg = 2*(n-1),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    //rep(i,in.size())cout << in[i].first <<\" \" << in[i].second << endl;\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[mx].first)my = i;    \n\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-10),min(yind+10,(int)Y.size())){\n\tREP(j,max(0,xind-10),min(xind+10,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-10),min(my+10,(int)Y.size())){\n\tREP(j,max(0,mx-10),min(mx+10,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\nconst long long inf = 1LL<<62;\n\nlong long sum(long long t, const vector<long long>&v)\n{\n  long long ret = 0;\n  for(int i = 0; i < (int)v.size(); ++i){\n    ret += llabs(v[i]-t);\n  }\n  return 2*ret;\n}\n\nconst int dt[2][9] = { {-1,-1,-1,0,0,0,1,1,1},\n                       {-1, 0, 1,-1,0,1,-1,0,1} };\n\nint main()\n{\n  long long w,h;\n  while(EOF!=scanf(\"%lld%lld\", &w, &h)){\n    int n;\n    long long res = inf;\n    long long res_coord[2];\n    vector<long long> coord[2], org[2];\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < 2; ++j){\n        long long t; scanf(\"%lld\", &t); coord[j].push_back(t);\n      }\n    }\n\n    org[0] = coord[0];\n    org[1] = coord[1];\n    sort(coord[0].begin(),coord[0].end());\n    sort(coord[1].begin(),coord[1].end());\n\n    long long minc[2] = {inf,inf};\n    long long ind[2];\n    for(int i = n/2-1; i <= n/2+1; ++i){\n      if( i < 0 || i >= n ) continue;\n      for(int j = 0; j < 2; ++j){\n        long long tm = sum(coord[j][i],coord[j]);\n        if( minc[j] > tm ){ minc[j] = tm; ind[j] = i; }\n      }\n    }\n    \n    for(int i = 0; i < 9; ++i){\n      bool inv = false;\n      long long tind[2];\n      long long tsum[2] = {0,0};\n      for(int j = 0; j < 2; ++j){\n        tind[j] = ind[j]+dt[j][i];\n        if( tind[j]<0 || tind[j]>=n ){ inv = true; continue; }\n        tsum[j] = sum(coord[j][tind[j]],coord[j]);\n      }\n      if( inv ) continue;\n      for(int k = 0; k < n; ++k){\n        long long t[2];\n        for(int j = 0; j < 2; ++j){\n          t[j] = tsum[j] - llabs(org[j][k]-coord[j][tind[j]]);\n        }\n        if( res > t[0] + t[1] ){\n          res = t[0] + t[1];\n          for(int j = 0; j < 2; ++j){\n            res_coord[j] = coord[j][tind[j]];\n          }\n        }\n      }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", res, res_coord[0], res_coord[1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\nint main()\n{\n\tint n,m,k;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tvector<int>x,y;\n\tfor(int i=0;i<k;i++){ int xx,yy;scanf(\"%d %d\",&xx,&yy);x.pb(xx);y.pb(yy);};\n\tsort(x.begin(),x.end()); sort(y.begin(),y.end());\n\tint ret=1e9,xi,yi;\n\tfor(int i=k-1;i<=k;i++)for(int j=k-1;j<=k;j++)\n\t{\n\t\tint v=x[i/2]; int w=y[j/2]; int res=0,re=0;\n\t\tfor(int i=0;i<k;i++){re=max(re,(abs(x[i]-v)+abs(y[i]-w))); res+=(abs(x[i]-v)+abs(y[i]-w))*2;}\n\t\tif(ret>res-re){ ret=min(ret,res-re); xi=v; yi=w;}\n\t}\n\tprintf(\"%d\\n%d %d\\n\",ret,xi,yi);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  int h,w,n;\n  int x[100100],y[100100];\n  int wx[200100],wy[200100];\n\n  scanf(\"%d%d%d\",&h,&w,&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    wx[2*i] = wx[2*i+1] = x[i];\n    wy[2*i] = wy[2*i+1] = y[i];\n  }\n\n  sort(wx,wx+2*n); sort(wy,wy+2*n);\n  ll sumx[2]={}, sumy[2]={};\n  int med = n-1;\n\n  for(int i=0;i<2*n;i++){\n    sumx[0] += abs(wx[i]-wx[med]);\n    sumy[0] += abs(wy[i]-wy[med]);\n    sumx[1] += abs(wx[i]-wx[med+1]);\n    sumy[1] += abs(wy[i]-wy[med+1]);\n  }\n\n  ll ans = 1e18;\n  pair<int,int> cord(0,0);\n  for(int i=0;i<n;i++){\n    int dx = 0, dy = 0;\n    if(x[i]<=wx[med])dx=1;\n    if(y[i]<=wy[med])dy=1;\n\n    int X = wx[med+dx], Y = wy[med+dy];\n    ll cur = sumx[dx] + sumy[dy] - abs(X-x[i]) - abs(Y-y[i]);\n    if(ans > cur){\n      ans = cur; cord = make_pair(X,Y);\n    }else if(ans == cur){\n      cord = min(cord, make_pair(X,Y));\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\",cord.first, cord.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-05\n      }\n\n\n\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint idx = (N-1)/2;\n\tll ans = inf;\n\tint ax = inf, ay = inf;\n\tvector<int> kx, ky;\n\tfor (int d = -1000; d <= 1000; ++d) {\n\t\tif (idx+d < 0 || idx+d >= N) continue;\n\t\tkx.pb(X[idx+d]);\n\t\tky.pb(Y[idx+d]);\n\t}\n\tREP(u, kx.size()) REP(w, ky.size()) {\n\t\tint sx = kx[u], sy = ky[w];\n\t\tvector<ll> a;\n\t\tREP(i, N) {\n\t\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t\t}\n\t\tsort( ALL(a) );\n\t\tll sum = a[N-1];\n\t\tREP(i, N-1) {\n\t\t\tsum += a[i]*2;\n\t\t}\n\t\tif (sum < ans || (sum <= ans && P(sx, sy) <= P(ax, ay))) {\n\t\t\tans = sum;\n\t\t\ttie(ax, ay) = P(sx, sy);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int points[100005][2], xs[100005], ys[100005], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + w);\n  sort(ys, ys + h);\n  long long int ans = -1;\n  int ansx, ansy;\n  int wup = min( (w / 2) + 3, w - 1);\n  int wdown = max(0, (w / 2) - 3);\n  int hup = min( (h / 2) + 3, h - 1);\n  int hdown = max(0, (h / 2) - 3);\n\n  for(int i = wdown;i <= wup;i++){\n    for(int j = hdown;j <= hup;j++){\n      long long int  res = 0;\n      int far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans == -1 || ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1e18);\n\ntypedef pair<long long,long long> P;\n\nint main() {\n    long long W,H;\n    cin >> W >> H;\n    long long N;\n    cin >> N;\n\n    vector<P> x,y;\n\n    for(int i=0; i<N; ++i) {\n        long long tempx, tempy;\n        cin >> tempx >> tempy;\n        x.push_back(P(tempx,i));\n        y.push_back(P(tempy,i));\n    }\n\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n\n    long long cx[2];\n    long long cy[2];\n\n    cx[0]=x[(N-1)/2].first;\n    cx[1]=x[N/2].first;\n    cy[0]=y[(N-1)/2].first;\n    cy[1]=y[N/2].first;\n\n    sort(x.begin(),x.end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n    sort(y.begin(),y.end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n\n    long long dist[4],max_dist[4];\n\n    for(int i=0; i<4; ++i) {\n        if(N%2==1 && i>0) continue;\n        int ix=i/2;\n        int iy=i%2;\n        dist[i]=0; max_dist[i]=0;\n        for(int j=0; j<N; ++j) {\n            long long nowdist;\n            nowdist=((cx[ix]>x[j].first)?(cx[ix]-x[j].first):(x[j].first-cx[ix]))\n                +((cy[iy]>y[j].first)?(cy[iy]-y[j].first):(y[j].first-cy[iy]));\n            dist[i]+=nowdist*2;\n            max_dist[i]=max(max_dist[i],nowdist);\n        }\n        dist[i]-=max_dist[i];\n    }\n\n    long long ansx=cx[0],ansy=cy[0],ansdist=dist[0];\n    if(N%2==0) {\n        for(int i=1; i<4; ++i) {\n            if(dist[i]<ansdist) {\n                ansx=cx[i/2];\n                ansy=cy[i%2];\n                ansdist=dist[i];\n            }\n        }\n    }\n    cout << ansdist << endl;\n    cout << ansx << \" \" << ansy << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nint dx[]={1,1,1,0,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,0,-1,1,0,-1};\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tif(c==1){\n\t\tprintf(\"%d\\n%d %d\\n\",0,d[0].first,d[0].second);\n\t\treturn 0;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=9999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=c/2;\n\t//\tif(c/2>=xat){\n\t//\t\t;\n\t//\t}else{\n\t//\t\tCenterX--;\n\t//\t}\n\t\tint CenterY=c/2;\n\t//\tif(c/2>=yat){;}\n\t//\telse CenterY--;\n\t//\tprintf(\"%d %d %d %d\\n\",xat,yat,x[CenterX],y[CenterY]);\n\t\tlong long T;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tCenterX+=dx[j];\n\t\t\tCenterY+=dy[j];\n\t\t\tif(CenterX>=0&&CenterY>=0&&CenterX<c&&CenterY<c){\n\t\t\t\tT=-abs(x[CenterX]-d[i].first);\n\t\t\t\tT+=-abs(y[CenterY]-d[i].second);\n\t\t\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\t\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\t\t\n\t\t\t\t//printf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\t\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\t\t\tans=T;\n\t\t\t\t\trow=x[CenterX];\n\t\t\t\t\tcol=y[CenterY];\n\t\t\t\t}\n\t\t\t}\n\t\t\tCenterX-=dx[j];\n\t\t\tCenterY-=dy[j];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}\n//..#...\n//..###.\n//.###..\n//...#.."
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=1;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(llabs(in[k].second,x[j])+llabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n\t       ll tmp = y[i].first;\n\t       tmp = tmp + x[j].first;\n\t       tmp = tmp - llabs(y[i].second,in[k].first);\n\t       tmp = tmp - llabs(x[j].second,in[k].second); \n\t       ll ty=y[i].second;\n\t       ll tx=x[j].second;\n\t       if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t\t ans = tmp;\n\t\t ansx = tx;\n\t\t ansy = ty;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n       /*\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t}*/\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);\n      }\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "//AOJ0563\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,mix = INF,miy = INF;\n\tvector<int> xp,yp;\n\txp.push_back(x[0]);\n\typ.push_back(y[0]);\n\tfor(int i = 0;i < n;i++) sum += x[i] - x[0];\n\tmix = min(mix,sum * 2);\n\tfor(int i = 1;i < n;i++){\n\t\tsum -= (x[i] - x[i - 1]) * (n - i * 2);\n\t\tif(mix > sum * 2){\n\t\t\tmix = sum * 2;\n\t\t\txp.clear();\n\t\t\txp.push_back(x[i]);\n\t\t}else if(mix == sum * 2) xp.push_back(x[i]);\n\t}\n\tsum = 0;\n\tfor(int i = 0;i < n;i++) sum += y[i] - y[0];\n\tmiy = min(miy,sum * 2);\n\tfor(int i = 1;i < n;i++){\n\t\tsum -= (y[i] - y[i - 1]) * (n - i * 2);\n\t\tif(miy > sum * 2){\n\t\t\tmiy = sum * 2;\n\t\t\typ.clear();\n\t\t\typ.push_back(y[i]);\n\t\t}else if(miy == sum * 2) yp.push_back(y[i]);\n\t}\n\tint ma = 0,xx,yy;\n\tfor(int k = 0;k < yp.size();k++){\n\t\tfor(int j = 0;j < xp.size();j++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(ma <= abs(xp[j] - mx[i]) + abs(yp[k] - my[i])){\n\t\t\t\t\tma = abs(xp[j] - mx[i]) + abs(yp[k] - my[i]);\n\t\t\t\t\txx = xp[j];\n\t\t\t\t\tyy = yp[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << mix << \" \" << miy << \" \" << ma << endl;\n\tcout << mix + miy - ma << endl;\n\tcout << xx << \" \" << yy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst long long int INF=1000000000;\nlong long int dx[4]={0,0,-1,-1};\nlong long int dy[4]={0,-1,0,-1};\n\nint main(){\n\tlong long int w,h;\n\tcin >> w >> h;\n\tlong long int n;\n\tcin >> n;\n\tvector<long long int> vx(n);\n\tvector<long long int> vy(n);\n\tvector<long long int> hoge(n);\n\tvector<long long int> piyo(n);\n\tfor(long long int i=0; i<n; ++i){\n\t\tcin >> vx[i] >> vy[i];\n\t\thoge[i]=vx[i];\n\t\tpiyo[i]=vy[i];\n\t}\n\tlong long int ans=0;\n\tlong long int ans_x,ans_y;\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tif(n%2!=0){\n\t\tans_x=vx[n/2];\n\t\tans_y=vy[n/2];\n\t\tlong long int maxd;\n\t\tmaxd=0;\n\t\tfor(long long int i=0; i<n; ++i){\n\t\t\tans+=2*abs(vx[n/2]-hoge[i])+2*abs(vy[n/2]-piyo[i]);\n\t\t\tmaxd=max(maxd,abs(vx[n/2]-hoge[i])+abs(vy[n/2]-piyo[i]));\t\t\n\t\t}\n\t\tans-=maxd;\n\t} else {\n\t\tlong long int tmp[4];\n\t\tlong long int maxd[4];\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\ttmp[i]=0;\n\t\t\tmaxd[i]=0;\n\t\t}\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\tfor(long long int j=0; j<n; ++j){\n\t\t\t\ttmp[i]+=2*abs(vx[n/2+dx[i]]-hoge[j])+2*abs(vy[n/2+dy[i]]-piyo[j]);\n\t\t\t\t/*\n\t\t\t\tif(i==3&&maxd[i]<abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j])){\n\t\t\t\t\tcout << vx[j] << \" \" << vy[j] << \" \" << abs(vx[n/2+dx[i]]-vx[j])+abs(vy[n/2+dy[i]]-vy[j]) << endl;\n\t\t\t\t}*/\n\t\t\t\tmaxd[i]=max(maxd[i],abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j]));\n\t\t\t}\n\t\t}\n\t\tans=INF*100000000;\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\t//cout << vx[n/2+dx[i]] << \" \" << vy[n/2+dy[i]]<< \" \" << tmp[i]-maxd[i] << \" \" << tmp[i] << \" \" << maxd[i] << endl;\n\t\t\tif(ans>=tmp[i]-maxd[i]&&n/2+dx[i]>=0&&n/2+dy[i]>=0){\n\t\t\t\tans=tmp[i]-maxd[i];\n\t\t\t\tans_x=vx[n/2+dx[i]];\n\t\t\t\tans_y=vy[n/2+dy[i]];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}\n\n//01234567"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint W,H,N;\nll x[100100],y[100100];\nll tx[100100],ty[100100];\nll p[2],q[2];\nll cal(ll s,ll t)\n{\n\tll m=0;\n\tll sum=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tsum+=2ll*(llabs(x[i]-s)+llabs(y[i]-t));\n\t\tm=max(m,llabs(x[i]-s)+llabs(y[i]-t));\n\t}\n\treturn sum-m;\n}\nint main()\n{\n\tcin >> W >> H;\n\tcin >> N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t\ttx[i]=x[i];ty[i]=y[i];\n\t}\n\tsort(tx,tx+N);\n\tsort(ty,ty+N);\n\tp[0]=tx[(N+1)/2],p[1]=tx[(N-1)/2];\n\tq[0]=ty[(N+1)/2],q[1]=ty[(N-1)/2];\n\tint ansx,ansy;\n\tll ans=1000000000000000000ll;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll k=cal(p[i/2],q[i%2]);\n\t\tif(ans>k)\n\t\t{\n\t\t\tansx=p[i/2];\n\t\t\tansy=q[i%2];\n\t\t\tans=k;\n\t\t}\n\t\telse if(ans==k)\n\t\t{\n\t\t\tif(ansx>p[i/2])\n\t\t\t{\n\t\t\t\tansx=p[i/2];\n\t\t\t\tansy=q[i%2];\n\t\t\t}\n\t\t\telse if(ansx==p[i/2]&&ansy>q[i%2])\n\t\t\t{\n\t\t\t\tansy=q[i%2];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ansx << ' ' << ansy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint x[100000], y[100000];\nint sum1[100001], sum2[100001];\n#define dist(x)(abs(i-x.first)+abs(j-x.second))\nint main() {\n\tint w, h, n; scanf(\"%d%d%d\", &w, &h, &n);\n\tP maxx(0, 0), maxy(0, 0), minx(INF, 0), miny(0, INF);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tif (maxx.first < x[i]) {\n\t\t\tmaxx.first = x[i];\n\t\t\tmaxx.second = y[i];\n\t\t}\n\t\tif (minx.first > x[i]) {\n\t\t\tminx.first = x[i];\n\t\t\tminx.second = y[i];\n\t\t}\n\t\tif (maxy.second < y[i]) {\n\t\t\tmaxy.first = x[i];\n\t\t\tmaxy.second = y[i];\n\t\t}\n\t\tif (miny.second > y[i]) {\n\t\t\tminy.first = x[i];\n\t\t\tminy.second = y[i];\n\t\t}\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tset<int>ax, ay;\n\tint mx = INT_MAX, my = INT_MAX;\n\trep(i, n) {\n\t\tint a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a) {\n\t\t\tmx = a; ax.clear();\n\t\t}\n\t\tif (mx == a) ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a) {\n\t\t\tmy = a; ay.clear();\n\t\t}\n\t\tif (my == a)ay.insert(y[i]);\n\t};\n\tint ansx, ansy, ans = INF;\n\tfor (int i : ax)for (int j : ay) {\n\t\tint M[] = { dist(minx),dist(maxx),dist(miny),dist(maxy) };\n\t\tint d = mx + my - *max_element(M, M + 4);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%d\\n%d %d\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N=100001;\nint H,W;\nint N;\nint XS[MAX_N];\nint YS[MAX_N];\nint curLast;\n\nll check(ll s,bool isX=true){\n    ll sum=0;\n    for(int i=0;i<N;i++){\n        int co=2;\n        if(i==curLast)co=1;\n        if(isX)sum+=co*abs(XS[i]-s);\n        else sum+=co*abs(YS[i]-s);\n    }\n    return sum;\n}\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>XS[i]>>YS[i];\n    // ツづつアツづーツ催古」ツづ可訪ツづェツづゥツ湘ェツ渉環づ可つキツづゥツつゥツづ湘ェツ債づュツつッ\n    ll ret=-1;\n    ll lastX,lastY;\n    ll candX[3],candY[3];\n    for(int i=0;i<N;i++){\n        curLast=i;\n        // x\n        int cnt=1000;\n        ll ub=1000000000;\n        ll lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1)<check(mid2))ub=mid2;\n            else if(check(mid1)>check(mid2))lb=mid1;\n            else lb=mid1;\n        }\n        candX[0]=lb;\n        candX[1]=lb+1;\n        candX[2]=ub;\n        ll minXVal=-1;\n        ll rx;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candX[i]);\n            if(minXVal==-1||tmp<minXVal){\n                minXVal=tmp;\n                rx=candX[i];\n            }\n        }\n        // y\n        cnt=1000;\n        ub=1000000000;\n        lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1,false)<check(mid2,false))ub=mid2;\n            else if(check(mid1,false)>check(mid2,false))lb=mid1;\n            else lb=mid1;\n        }\n        candY[0]=lb;\n        candY[1]=lb+1;\n        candY[2]=ub;\n        ll minYVal=-1;\n        ll ry;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candY[i],false);\n            if(minYVal==-1||tmp<minYVal){\n                minYVal=tmp;\n                ry=candY[i];\n            }\n        }\n        ll res=minXVal+minYVal;\n        if(ret==-1||res<ret){\n            ret=res;\n            lastX=rx;\n            lastY=ry;\n        }\n        else if(res==ret){\n            if(lastX>rx){\n                lastX=rx;\n                lastY=ry;\n            }\n            else if(lastX==rx){\n                if(lastY>ry){\n                    lastX=rx;\n                    lastY=ry;\n                }\n            }\n        }\n    }\n    std::cout<<ret<<endl;\n    std::cout<<lastX<<\" \"<<lastY<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\nstruct Pos{\n\tint x,y,state;\n};\nvoid Pinst(Pos *a,int N){\n\ta->state = 0;\n}\nint compareX(const void *s1,const void *s2){\n\tint x1 = ((Pos*)s1)->x;\n\tint x2 = ((Pos*)s2)->x;\n\treturn x1 -x2;\n}\nint compareY(const void *s1,const void *s2){\n\tint y1 = ((Pos*)s1)->y;\n\tint y2 = ((Pos*)s2)->y;\n\treturn y1-y2;\n}\nint compare(const void *s1,const void *s2){\n\treturn *(int*)s2-*(int*)s1;\n}\nint w,h,k;\nPos pos[100000];\nint longest[100000];\t//最長候補の番号を入れておく\nint dx[100000];\nint dy[100000];\nint main(){\n\tint i,j,l;\n\tint now,max,min;\n\tlong long shotest = 1000000000000000001;\n\tlong long len;\n\tint sx,sy,scor;\n\tcin >> w >> h >> k;\n\tfor(i = 0;i < k;i++){\n\t\tcin >> pos[i].x >> pos[i].y;\n\t\tdx[i] = pos[i].x;\n\t\tdy[i] = pos[i].y;\n\t}\n\tPinst(pos,k);\n\t//最長候補の割り出し\n\tqsort(pos,k,sizeof(Pos),compareX);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].x;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].x == now;i++){\n\t\t\tif(pos[min].y > pos[i].y)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].y < pos[i].y)\n\t\t\t\tmax = i;\n\t\t}\n\t\tpos[min].state = 1;\n\t\tpos[max].state = 1;\n\t}\n\tqsort(pos,k,sizeof(Pos),compareY);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].y;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].y == now;i++){\n\t\t\tif(pos[min].x > pos[i].x)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].x < pos[i].x)\n\t\t\t\tmax = i;\n\t\t}\n\t\tif(pos[min].state == 1)\n\t\t\tpos[min].state = 2;\n\t\tif(pos[max].state == 1)\n\t\t\tpos[max].state = 2;\n\t}\n\tint corsole = 0;\n\tfor(i = 0;i < k;i++){\n\t\tif(pos[i].state == 2){\n\t\t\tlongest[corsole] = i;\n\t\t\tcorsole++;\n\t\t}\n\t}\n\t//探索(dx,dyリスト内からスタート地点を決め、実際に距離を調べる。)\n\t//shotestが全体の中で最少となったときの、sx,syの組をこたえたい\n\t//(しかも、sxはその中でも最少にするとか…)で、ソートしようかと思う\n\tqsort(dx,k,sizeof(int),compare);\n\tqsort(dy,k,sizeof(int),compare);\n\tfor(i = 0;i < k;i++){\n\t\tif(dx[i] == 0)\n\t\t\tcontinue;\n\t\tfor(j = 0;j < k;j++){\n\t\t\tif(dy[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tlen = 0;\n\t\t\tfor(l = 0;l < k;l++){\n\t\t\t\tif(dx[i] != dx[l])\n\t\t\t\t\tlen += abs(dx[i]-dx[l])*2;\n\t\t\t\tif(dy[j] != dy[l])\n\t\t\t\t\tlen += abs(dy[j]-dy[l])*2;\n\t\t\t}\n\t\t\tint t,max;\n\t\t\tmax = 0;\n\t\t\tfor(l = 0;l < corsole;l++){\n\t\t\t\tt = abs(dx[i]-pos[longest[l]].x)+abs(dy[j]-pos[longest[l]].y);\n\t\t\t\tif(max < t)\n\t\t\t\t\tmax = t;\n\t\t\t}\n\t\t\tlen -= max;\n\t\t\tif(shotest >= len){\n\t\t\t\tshotest = len;\n\t\t\t\tsx = dx[i];\n\t\t\t\tsy = dy[j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",shotest,sx,sy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint W,H,N;\nint xs[2][100*1000];\nint ys[2][100*1000];\nint main() {\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",xs[0]+i,ys[0]+i);\n\t\txs[1][i]=xs[0][i];\n\t\tys[1][i]=ys[0][i];\n\t}\n\tLL ret=1LL<<60;\n\tint rx=0,ry=0;\n\tfor(int i=0;i<=(N+1)%2;i++){\n\t\tfor(int j=0;j<=(N+1)%2;j++){\n\t\t\tnth_element(xs[1],xs[1]+(N+i-1)/2,xs[1]+N);\n\t\t\tint x=xs[1][(N-i)/2];\n\t\t\tnth_element(ys[1],ys[1]+(N+j-1)/2,ys[1]+N);\n\t\t\tint y=ys[1][(N-j)/2];\n\t\t\tLL m=0;\n\t\t\tLL sum=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tLL d=abs(xs[0][i]-x);\n\t\t\t\td+=abs(ys[0][i]-y);\n\t\t\t\tm=max(m,d);\n\t\t\t\tsum+=2*d;\n\t\t\t}\n\t\t\tsum-=m;\n\t\t\tif(sum<ret){\n\t\t\t\tret=sum;\n\t\t\t\trx=x;\n\t\t\t\try=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = (int) 1e5 + 5;\n\nint n, W, H;\nint x[maxn], y[maxn];\nvector<int> xx, yy;\nint _x, _y;\nlong long ans;\n\nlong long calc(int X, int Y) {\n    long long res = 0;\n    int mx = 0;\n    for (int i = 0; i < n; i ++) {\n        res += 2LL * (abs(X - x[i]) + abs(Y - y[i]));\n        mx = max(mx, abs(X - x[i]) + abs(Y - y[i]));\n    }\n    return res - mx;\n}\n\nint main() {\n    ///freopen(\"test.txt\", \"r\", stdin);\n    cin >> W >> H >> n;\n    for (int i = 0; i < n; i ++) {\n        cin >> x[i] >> y[i];\n        xx.push_back(x[i]);\n        yy.push_back(y[i]);\n    }\n    sort(xx.begin(), xx.end());\n    sort(yy.begin(), yy.end());\n\n    int md = n / 2;\n    int lo = max(0, md - 1);\n    int hi = min(n - 1, md + 1);\n    ans = 1LL * maxn * maxn;\n    for (int i = lo; i <= hi; i ++) {\n        for (int j = lo; j <= hi; j ++) {\n            ///cout << i << ' ' << j << ' ' << xx[i] << ' ' << yy[j] << endl;\n            long long tmp = calc(xx[i], yy[j]);\n            if(tmp < ans) {\n                ans = tmp;\n                _x = xx[i];\n                _y = yy[j];\n            }\n        }\n    }\n    cout << ans << '\\n' << _x << ' ' << _y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define N 1025\n#define ln 1e16\n#define oo 111539786\n#define Pa pair < int, int >\n#define Pi pair < int, Pa >\n\nusing namespace std;\n\nll ans = ln, SumX[N], SumY[N];\nint n, X[N], Y[N], w, h, posX, posY;\nPa a[N];\n\nvoid Get_ans(int x, int y)\n{\n    ll Sum = 0, Max = -ln;\n    for(int i=1; i<=n; i++)\n    {\n        Sum += (abs(x - a[i].f) + abs(y - a[i].s)) * 2;\n        Max = max(Max, (ll)abs(x - a[i].f) + abs(y - a[i].s));\n    }\n    Sum -= Max;\n    if(Sum < ans)\n    {\n        ans = Sum;\n        posX = x;\n        posY = y;\n    }\n}\n\nint main()\n{\n    //filein(\"SANTA.inp\");    fileout(\"SANTA.out\");\n    cin >> w >> h >> n;\n    for(int i=1; i<=n; i++)\n    {\n        cin >> X[i] >> Y[i];\n        a[i] = mp(X[i], Y[i]);\n    }\n    sort(X+1, X+n+1);\n    sort(Y+1, Y+n+1);\n    for(int i=1; i<=n; i++)\n    {\n        SumX[i] = SumX[i-1] + X[i];\n        SumY[i] = SumY[i-1] + Y[i];\n    }\n    Get_ans(X[(n+1)/2], Y[(n+1)/2]);\n    if(n % 2 == 0)\n    {\n        Get_ans(X[(n+1)/2], Y[n/2+1]);\n        Get_ans(X[n/2+1], Y[(n+1)/2]);\n        Get_ans(X[n/2+1], Y[n/2+1]);\n    }\n    cout << ans << endl;\n    cout << posX << \" \" << posY << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) { a = min(a, b); }\nvoid mmax(int &a, int b) { a = max(a, b); }\nvoid sor(vel &v) { sort(v.begin(), v.end()); }\nint dis(int x1, int y1, vel &x, vel &y, int i) {\n\treturn abs(x1 - x[i]) + abs(y1 - y[i]);\n}\nsigned main() {\n\tint w, h; cin >> w >> h;\n\tint n; cin >> n;\n\tvel x(n);\n\tvel y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--;y[i]--;\n\t}\n\tvel mx = x;\n\tvel my = y;\n\tsor(mx);\n\tsor(my);\n\tif (n % 2 == 1) {\n\t\tint ans = 0;\n\t\tint ma1 = 0;\n\t\tint mid = (n - 1) / 2;\n\t\tint x1 = mx[mid];\n\t\tint y1 = my[mid];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint di = abs(x1 - x[i]) + abs(y1 - y[i]);\n\t\t\tans += di;\n\t\t\tmmax(ma1,di);\n\t\t}\n\t\tcout << 2 * ans - ma1 << endl;\n\t\tcout << x1+1 << \" \" << y1+1 << endl;\n\t}\n\telse {\n\t\tvel mid(2);\n\t\tmid[1] = n / 2;\n\t\tmid[0] = mid[1]-1;\n\t\tvel ax(2);\n\t\tvel ay(2);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tax[i] = mx[mid[i]];\n\t\t\tay[i] = my[mid[i]];\n\t\t}\n\t\tint adi = 0;\n\t\tint ami = 0;\n\t\tint axy = h*w;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tint mi1 = dis(ax[j], ay[k], x, y, i);\n\t\t\t\t\tif (j*k == 1) {\n\t\t\t\t\t\tadi += mi1;\n\t\t\t\t\t}\n\t\t\t\t\tif (ami < mi1) {\n\t\t\t\t\t\tami = mi1;\n\t\t\t\t\t\taxy = ax[j] * w + ay[k];\n\t\t\t\t\t}\n\t\t\t\t\tif (ami == mi1) {\n\t\t\t\t\t\tmmin(axy, ax[j] * w + ay[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << 2 * adi - ami << endl;\n\t\tcout << (axy / w) + 1 << \" \" << (axy%w) + 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nint X[100000],Y[100000];\nint main() {\n\tint W,H,N;\n\tlong long int sumX=0,sumY=0;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&X[i],&Y[i]);\n\t\tsumX+=X[i]*2,sumY+=Y[i]*2;\n\t}\n\tlong long int ans=1LL<<62;\n\tint ansX=1<<30,ansY=1<<30;\n\tfor(int i=0;i<N;i++) {\n\t\tint x=(int)((sumX-X[i])/(2.0*N-1)+0.5);\n\t\tint y=(int)((sumY-Y[i])/(2.0*N-1)+0.5);\n\t\tlong long int d=0,maxd=0;\n\t\tfor(int j=0;j<N;j++) {\n\t\t\td+=(abs(x-X[j])+abs(y-Y[j]))*2;\n\t\t}\n\t\td-=(abs(x-X[i])+abs(y-Y[i]));\n\t\tif(ans==d) {\n\t\t\tif(ansX>x) {\n\t\t\t\tansX=x,ansY=y;\n\t\t\t}else if (ansX==x) {\n\t\t\t\tif(ansY>y) ansY=y;\n\t\t\t}\n\t\t}else if(ans>d) {\n\t\t\tansX=x,ansY=y,ans=d;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%d %d\\n\",ansX,ansY);\n}"
  },
  {
    "language": "C++",
    "code": "#include <forward_list>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <cstdint>\n#include <utility>\n\n#define X 0\n#define Y 1\n\nusing namespace std;\n\ntypedef long long int int64;\n\nint64 WH[2],N;\nint64 XY[100000][2];\nvector<int64> VN[2];\nvector<pair<int64,int64>> T;\n\nint main(void)\n{\n\tcin >> WH[X] >> WH[Y] >> N;\n\tint x,y;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> x >> y;\n\t\tT.push_back(make_pair(x,y));\n\t}\n\tsort(T.begin(),T.end());\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tXY[i][X] = T[i].first;\n\t\tXY[i][Y] = T[i].second;\n\t\tVN[X].push_back(XY[i][X]);\n\t\tVN[X].push_back(XY[i][X]);\n\t\tVN[Y].push_back(XY[i][Y]);\n\t\tVN[Y].push_back(XY[i][Y]);\n\t}\n\tsort(VN[X].begin(),VN[X].end());\n\tsort(VN[Y].begin(),VN[Y].end());\n\tint MAXi = -1;\n\tint64 MAXd = 0;\n\tint p[2],m[2];\n\tint64 dist = 0;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tfor(int xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[i][xy]) - VN[xy].begin();\n\t\t\tif(p[xy] < N)\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N]-XY[i][xy]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N-1]-XY[i][xy]);\n\t\t\t}\n\t\t}\n\t\tif(MAXd <= m[X] + m[Y])\n\t\t{\n\t\t\tMAXd = m[X] + m[Y];\n\t\t\tMAXi = i;\n\t\t}\n\t}\n\tfor(int xy = 0;xy < 2;xy++)\n\t{\n\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[MAXi][xy]) - VN[xy].begin();\n\t\tif(p[xy] < N)\n\t\t{\n\t\t\tm[xy] = VN[xy][N];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm[xy] = VN[xy][N-1];\n\t\t}\n\t}\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tfor(int xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tif(i != MAXi)\n\t\t\t{\n\t\t\t\tdist += (abs(m[xy]-XY[i][xy])*2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tdist += abs(m[xy]-XY[i][xy]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist <<endl << m[X] << \" \" << m[Y] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,ma = 0,xx,yy;\n\tif(n % 2 == 1){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint d = abs(x[n / 2] - mx[i]) + abs(y[n / 2] - my[i]);\n\t\t\tsum += d;\n\t\t\tma = max(ma,d);\n\t\t}\n\t\tcout << sum * 2 - ma << endl;\n\t\tcout << x[n / 2] << \" \" << y[n / 2] << endl;\n\t}\n\telse{\n\t\tint mas = 1e+9;\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < 2;k++){\n\t\t\t\tsum = 0;\n\t\t\t\tma = 0;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tint d = abs(x[n / 2 - j] - mx[i]) + abs(y[n / 2 - k] - my[i]);\n\t\t\t\t\tsum += d;\n\t\t\t\t\tma = max(ma,d);\n\t\t\t\t}\n\t\t\t\tif(mas >= sum * 2 - ma){\n\t\t\t\t\tmas = min(mas,sum * 2 - ma);\n\t\t\t\t\txx = x[n / 2 - j];\n\t\t\t\t\tyy = y[n / 2 - k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mas << endl;\n\t\tcout << xx << \" \" << yy << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\nint main()\n{\n\tint n,m,k;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tvector<int>x,y,x2,y2;\n\tfor(int i=0;i<k;i++){ int xx,yy;scanf(\"%d %d\",&xx,&yy);x.pb(xx);y.pb(yy);x2.pb(xx);y2.pb(yy);};\n\tsort(x.begin(),x.end()); sort(y.begin(),y.end());\n\tint ret=1e9,xi,yi;\n\tfor(int i=k-1;i<=k;i++)for(int j=k-1;j<=k;j++)\n\t{\n\t\tint v=x[i/2]; int w=y[j/2]; int res=0,re=0;\n\t\tfor(int a=0;a<k;a++){re=max(re,(abs(x2[a]-v)+abs(y2[a]-w))); res+=(abs(x2[a]-v)+abs(y2[a]-w))*2;}\n\t\tif(ret>res-re){ ret=min(ret,res-re); xi=v; yi=w;}\n\t}\n\tprintf(\"%d\\n%d %d\\n\",ret,xi,yi);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\nint x[100005],y[100005];\nint a[100005],b[1000005];\nint main(){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<k;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=0;i<k;i++) a[i]=x[i],b[i]=y[i];\n\tsort(a,a+k); sort(b,b+k);\n\tll ret=1e15; int rx,ry;\n\tfor(int i=(k-1)/2;i<=(k+1)/2;i++)\n\t{\n\t\tfor(int j=(k-1)/2;j<=(k+1)/2;j++)\n\t\t{\n\t\t\tll sum=0LL,gen=0LL;\n\t\t\tfor(int s=0;s<k;s++)\n\t\t\t{\n\t\t\t\tsum+=2LL*(abs(x[s]-a[i])+abs(y[s]-b[j]));\n\t\t\t\tgen=max(gen,1LL*(abs(x[s]-a[i])+abs(y[s]-b[j])));\n\t\t\t}\n\t\t\tif(sum-gen<ret){ rx=a[i]; ry=b[j]; ret=sum-gen;}\n\t\t\telse if(sum-gen==ret && mp(rx,ry)>mp(a[i],b[j])) rx=a[i],ry=b[j];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    int W, H; cin >> W >> H;\n\n    int N; cin >> N;\n\n    rep(i, N) {\n        cin >> X[i];\n        cin >> Y[i];\n        pos[i] = pii(X[i], Y[i]);\n    }\n\n    sort(X, X + N);\n    sort(Y, Y + N);\n\n    int x = X[N / 2 - (N % 2 == 0)];\n    int y = Y[N / 2 - (N % 2 == 0)];\n\n    rep(i, N) {\n        v[i] = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n    }\n\n    sort(v, v + N);\n\n    int ans = 0;\n\n    rep(i, N) ans += v[i] * 2;\n    ans -= v[N - 1];\n\n    cout << ans << endl;\n    cout << x << ' ' << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint ox[100000];\nint oy[100000];\nint x[100000];\nint y[100000];\nint n;\nlong long calc(int a,int b){\n\tint md=0,i;\n\tlong long ans=0;\n\tfor(i=0;i<n;i++){\n\t\tint d=abs(ox[i]-a)+abs(oy[i]-b);\n\t\tmd=max(md,d);\n\t\tans+=(long long)d*2;\n\t}\n\treturn ans-(long long)md;\n}\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint w,h,i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&ox[i],&oy[i]);\n\t\tx[i]=ox[i];\n\t\ty[i]=oy[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tlong long ans=1000000000000000000LL;\n\tint ax[2];\n\tint ay[2];\n\tax[0]=x[n/2];\n\tay[0]=y[n/2];\n\tint nx,ny;\n\tif(n%2==0){\n\t\tax[1]=x[n/2-1];\n\t\tay[1]=y[n/2-1];\n\t\tfor(i=1;i>=0;i++)for(j=1;j>=0;j++){\n\t\t\tif(ans>calc(ax[i],ay[j])){\n\t\t\t\tans=calc(ax[i],ay[j]);\n\t\t\t\tnx=ax[i];\n\t\t\t\tny=ay[j];\n\t\t\t}\n\t\t}\n\t}else{\n\t\tans=calc(ax[0],ay[0]);\n\t\tnx=ax[0];\n\t\tny=ay[0];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%d %d\\n\",nx,ny);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int W,H,N;\n    cin >> W >> H >> N;\n    vector<int> X, Y;\n    vector<pair<int,int> > XY;\n    for(int i=0; i<N; i++){\n        int x,y;\n        cin >> x >> y;\n        X.push_back(x);\n        Y.push_back(y);\n        XY.push_back(MP(x, y));\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    vector<LL> waX, waY;\n    waX.push_back(X.front());\n    waY.push_back(Y.front());\n    for(int i=1; i<N; i++){\n        waX.push_back(waX.back() + X[i]);\n        waY.push_back(waY.back() + Y[i]);\n    }\n\n    //cout << endl;\n\n    //最後に行く交差点を決定\n    LL ans = LL_MAX;\n    pair<LL,LL> tmp = MP(0,0);\n    for(int i=0; i<N; i++){\n        LL nowX = 2*waX.back() - XY[i].first;\n        LL nowY = 2*waY.back() - XY[i].second;\n        if(((double)nowX / (2*N-1)) - (int)(nowX / (2*N-1)) == 0.5) nowX = nowX / (2*N-1);\n        else nowX = round((double)nowX / (2*N-1));\n        if(((double)nowY / (2*N-1)) - (int)(nowY / (2*N-1)) == 0.5) nowY = nowY / (2*N-1);\n        else nowY = round((double)nowY / (2*N-1));\n\n        //cout << nowX << \" \" << nowY << endl;\n\n        LL sum = 0;\n        int a = (upper_bound(X.begin(), X.end(), nowX) - X.begin()) - 1;\n        sum += nowX * (a+1) - waX[a] + (waX.back() - waX[a]) - nowX * (N-a-1);\n        int b = (upper_bound(Y.begin(), Y.end(), nowY) - Y.begin()) - 1;\n        sum += nowY * (b+1) - waY[b] + (waY.back() - waY[b]) - nowY * (N-b-1);\n        sum *= 2;\n        sum -= abs(nowX - XY[i].first);\n        sum -= abs(nowY - XY[i].second);\n        //cout << a << \" \" << b << endl;\n        //cout << sum << endl << endl;\n\n        if(sum < ans || (sum == ans && tmp.first > nowX) || (sum == ans && tmp.first == nowX && tmp.second > nowY)){\n            ans = sum;\n            tmp = MP(nowX, nowY);\n        }\n    }\n    cout << ans << endl;\n    cout << tmp.first << \" \" << tmp.second << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntemplate<class T>\nclass Fenwick{\npublic :\n  vector<T> x;\n  Fenwick(){}\n  Fenwick(int n):x(n,0){}\n  T sum(int i, int j){\n    if(i==0){\n      T s=0;\n      while(j>=0){\n\ts+=x[j];\n\tj=(j&(j+1))-1;\n      }\n      return s;\n    }else return sum(0,j)-sum(0,i-1);\n  }\n  void add(int k, T a){\n    for(;k<(int)x.size(); k|=k+1)x[k]+=a;\n  }\n};\n\nconst long long inf = 1LL<<61;\n\nlong long res_min, res_x, res_y;\nvector<long long> x_coor, y_coor;\nFenwick<long long> x_tree, y_tree;\n\nvoid init(int n){\n  x_coor.clear();\n  y_coor.clear();\n  x_tree = Fenwick<long long>(n+1);\n  y_tree = Fenwick<long long>(n+1);\n}\n\nlong long myabs(long long x){\n  return x<0?-x:x;\n}\n\nlong long calc_cost(long long x, long long y){\n\n  long long ret_x = 0, ret_y = 0;\n  for(int i = 0; i < (int)x_coor.size(); ++i){\n    ret_x += myabs(x_coor[i] - x);\n    ret_y += myabs(y_coor[i] - y);\n  }\n  return 2*(ret_x + ret_y);\n\n  const int n = x_coor.size();\n  vector<long long>::iterator itx = lower_bound(x_coor.begin(), x_coor.end(), x);\n  vector<long long>::iterator ity = lower_bound(y_coor.begin(), y_coor.end(), y);\n  int npx=0, nnx=0, npy=0, nny=0;\n  long long px=0,nx=0,py=0,ny=0;\n  \n  if( itx == x_coor.end() ){\n    nnx = n;    nx = x_tree.sum(0,n-1);\n  }else if( itx == x_coor.begin()){\n    npx = n;    px = x_tree.sum(0,n-1);\n  }else{\n    int e = itx - x_coor.begin();\n    nnx = e;    nx = x_tree.sum(0,e-1);\n    npx = n-e;  px = x_tree.sum(e,n-1);\n  }\n\n  if( ity == y_coor.end() ){\n    nny = n;   ny = y_tree.sum(0,n-1);\n  }else if( ity == y_coor.begin()){\n    npy = n;   py = y_tree.sum(0,n-1);\n  }else{\n    int e = ity - y_coor.begin();\n    nny = e;   ny = y_tree.sum(0,e-1);\n    npy = n-e; py = y_tree.sum(e,n-1);\n  }\n  \n  return\n    2*(nnx * x - nx + px - npx * x +\n       nny * y - ny + py - npy * y);\n}\n\nvoid solve(long long x0, long long y0, long long x1, long long y1)\n{\n  if( x1 - x0 <= 4 && y1 - y0 <= 4 ){\n    long long minc = inf;\n    int min_x, min_y;\n    for(int x = x0; x <= x1; ++x){\n      for(int y = y0; y <= y1; ++y){\n\tlong long cost = calc_cost(x,y);\n\tif( minc > cost ){\n\t  minc = cost;\n\t  min_x = x;\n\t  min_y = y;\n\t}\n      }\n    }\n    res_min = minc;\n    res_x = min_x;\n    res_y = min_y;\n    return ;\n  }\n  \n\n  long long mx = (x1-x0)/2;\n  long long my = (y1-y0)/2;\n  \n  long long ex[4], ey[4];\n  long long minc = inf;\n  int min_ind;\n\n  ex[0] = (x0 + mx) / 2;\n  ey[0] = (y0 + my) / 2;\n\n  ex[1] = (mx + x1) / 2;\n  ey[1] = (y0 + my) / 2;\n\n  ex[2] = (x0 + mx) / 2;\n  ey[2] = (my + y1) / 2;\n\n  ex[3] = (mx + x1) / 2;\n  ey[3] = (my + y1) / 2;\n  \n  for(int i = 0; i < 4; ++i){\n    long long cost = calc_cost( ex[i], ey[i] );\n    if( minc > cost ){\n      minc = cost;\n      min_ind = i;\n    }\n  }\n\n  if( min_ind == 0 ){\n    solve( x0, y0, mx, my );\n  }else if( min_ind == 1 ){\n    solve( mx, y0, x1, my );\n  }else if( min_ind == 2 ){\n    solve( x0, my, mx, y1 );\n  }else if( min_ind == 3 ){\n    solve( mx, my, x1, y1 );\n  }\n}\n\nint main()\n{\n  long long w,h;\n  while(cin >> w >> h){    \n    if( w == 0 && h == 0 ) break;\n    int n;\n    cin >> n;\n    init(n);\n\n    vector<long long> org_x, org_y;\n    for(int i = 0; i < n; ++i){\n      long long in_x, in_y;\n      cin >> in_x >> in_y;\n      x_coor.push_back(in_x);\n      y_coor.push_back(in_y);\n    }\n    org_x = x_coor;\n    org_y = y_coor;\n    sort(x_coor.begin(), x_coor.end());\n    sort(y_coor.begin(), y_coor.end());\n    for(int i = 0; i < n; ++i){\n      x_tree.add(i, x_coor[i]);\n      y_tree.add(i, y_coor[i]);\n    }\n\n    solve(1,1,w,h);\n\n    long long maxt = 0;\n    for(int i = 0; i < (int)org_x.size(); ++i){\n      long long t = myabs(org_x[i] - res_x) + myabs(org_y[i] - res_y);\n      maxt = max( maxt, t );\n    }\n    cout << res_min - maxt << endl << res_x << ' ' << res_y << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=c/2;\n\t\tif(c/2>xat){\n\t\t\t;\n\t\t}else{\n\t\t\tCenterX--;\n\t\t}\n\t\tint CenterY=c/2;\n\t\tif(c/2>yat){;}\n\t\telse CenterY--;\n\t\tlong long T=-abs(x[CenterX]-d[i].first)-abs(y[CenterY]-d[i].second);\n\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\n\t//\tprintf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\tans=T;\n\t\t\trow=x[CenterX];\n\t\t\tcol=y[CenterY];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define INF 1000000000000000\nusing namespace std;\n\nint w,h,n;\nlong long ans = INF;\nlong long ansx = INF,ansy = INF;\nint X[100000],Y[100000],x[100000],y[100000];\n\nint main(){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i = 0; i < n; i++){\n\t\tx[i] = X[i];\n\t\ty[i] = Y[i];\n\t}\n\tif(n == 1){\n\t\tprintf(\"1\\n\");\n\t\tprintf(\"%lld %lld\\n\",x[0],y[0]);\n\t\treturn 0;\n\t}\n\tsort(x,x+n); sort(y,y+n);\n\tif(n%2 == 0){\n\t\tlong long Tx[2] = {0,0}, Ty[2] = {0,0};\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tTx[0] += abs(x[n/2-1]-X[i]);\n\t\t\tTy[0] += abs(y[n/2-1]-Y[i]);\n\t\t\tTx[1] += abs(x[n/2]-X[i]);\n\t\t\tTy[1] += abs(y[n/2]-Y[i]);\n\t\t}\n\t\tTx[0] *= 2; Tx[1] *= 2; Ty[0] *= 2; Ty[1] *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint zx = (X[i]<=x[n/2-1]),zy = (Y[i]<=y[n/2-1]); //T[0]\n\t\t\tif(ans >= Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i])){\n\t\t\t\tif(ans == Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i])){\n\t\t\t\t\tif(x[n/2+zx-1] < ansx){\n\t\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t\t} else if(x[n/2+zx-1] == ansx){\n\t\t\t\t\t\tif(y[n/2+zy-1] < ansy){\n\t\t\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tans = Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i]);\n\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t} else{\n\t\tlong long tx = x[n/2], ty = y[n/2],sx,ex,sy,ey;\n\t\tlong long T = 0, sum;\n\t\tfor(int i = 0; i < n; i++) T += abs(tx-X[i])+abs(ty-Y[i]);\n\t\tT *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum = T-2*(abs(tx-X[i])+abs(ty-Y[i]));\n\t\t\tif(i <= n/2-1){\n\t\t\t\tsx = tx; sy = ty;\n\t\t\t\tex = x[n/2+1]; ey = y[n/2+1];\n\t\t\t} else if(i == n/2){\n\t\t\t\tsx = x[n/2-1]; sy = y[n/2-1];\n\t\t\t\tex = x[n/2+1]; ey = y[n/2+1];\n\t\t\t} else{\n\t\t\t\tsx = x[n/2-1]; sy = y[n/2-1];\n\t\t\t\tex = tx; ey = ty;\n\t\t\t}\n\t\t\tif(sx<=X[i]&&X[i]<=ex&&sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum){\n\t\t\t\t\tif(ans == sum){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum;\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sx<=X[i]&&X[i]<=ex){\n\t\t\t\tif(ans>=sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(Y[i]-sy) <= abs(Y[i]-ey)) tmp = sy;\n\t\t\t\t\telse tmp = ey;\n\t\t\t\t\tif(ans == sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > tmp){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(Y[i]-sy),abs(Y[i]-ey));\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(X[i]-sx) <= abs(X[i]-ex)) tmp = sx;\n\t\t\t\t\telse tmp = ex;\n\t\t\t\t\tif(ans == sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\t\tif(ansx > tmp){\n\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == tmp){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(X[i]-sx),abs(X[i]-ex));\n\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(X[i] >= ex){\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%lld %lld %lld\\n\", ans, ansx, ansy);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint w,h;\nint n;\npii pts[125252];\nint x[125252], y[125252];\npii cents[125252];\nint main(){\n  scanf(\"%d%d%d\",&w,&h,&n);\n  REP(i,n)scanf(\"%d%d\",x+i,y+i);\n  if(n==1){\n    puts(\"0\");\n    printf(\"%d %d\\n\",x[0],y[0]);\n    return 0;\n  }\n  REP(i,n)pts[i] = pii(x[i], y[i]);\n  sort(x,x+n);sort(y,y+n);\n  pair<ll,pii> ans = make_pair(1ll<<60, pii(-1, -1));\n\n  set<pii> S;\n  REP(i,n){\n    int xx = pts[i].first;\n    int yy = pts[i].second;\n    int cx, cy;\n    int xlow = lower_bound(x,x+n,xx)-x;\n    int xup = upper_bound(x,x+n,xx)-x;\n    int ylow = lower_bound(y,y+n,yy)-y;\n    int yup = upper_bound(y,y+n,yy)-y;\n    if(xup <= n/2){\n      cx = x[n/2];\n    }else if(xlow > (n-2)/2){\n      cx = x[(n-2)/2];\n    }else{\n      cx = xx;\n    }\n    if(yup <= n/2){\n      cy = y[n/2];\n    }else if(ylow > (n-2)/2){\n      cy = y[(n-2)/2];\n    }else{\n      cy = yy;\n    }\n    cents[i] = pii(cx,cy);\n    S.insert(cents[i]);\n  }\n  map<pii, ll> M;\n  for(pii P : S){\n    int cx = P.first;\n    int cy = P.second;\n    ll sum = 0ll;\n    REP(i,n){\n      sum += (ll)abs(x[i]-cx) + (ll)abs(y[i]-cy);\n    }\n    M[P] = sum;\n  }\n  REP(i,n){\n    ll sum = M[cents[i]];\n    int cx = cents[i].first;\n    int cy = cents[i].second;\n    sum *= 2ll;\n    sum -= (ll)abs(pts[i].first-cx) + (ll)abs(pts[i].second-cy);\n    ans = min(ans, make_pair(sum, cents[i]));\n  }\n  printf(\"%lld\\n%d %d\\n\",ans.first,ans.second.first,ans.second.second);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  //Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    //Y[fir] = index;index++;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 1000000\n#define INF 1145141145141919810LL;\n\nlong long x[MAX_N],y[MAX_N],lx[MAX_N],ly[MAX_N],d[MAX_N],n,h,w,sx,sy,c,mx,my,sum,minx,dx,dy;\nvector<long long>X,Y,BX,BY;\n\nint main(){\n\tcin>>h>>w>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tlx[i]=x[i];ly[i]=y[i];\n\t\tsx+=x[i];\n\t\tsy+=y[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tmx=INF;my=INF;minx=INF;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=x[0];}\n\t\telse{c=x[i]-x[i-1];}\n\t\tsx+=(-n+i*2)*c;\n\t\tif(mx==sx){X.push_back(x[i]);}\n\t\tif(mx>sx){mx=sx;X.clear();X.push_back(x[i]);}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=y[0];}\n\t\telse{c=y[i]-y[i-1];}\n\t\tsy+=(-n+i*2)*c;\n\t\tif(my==sy){Y.push_back(y[i]);}\n\t\tif(my>sy){my=sy;Y.clear();Y.push_back(y[i]);}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tif(i<10){BX.push_back(X[i]);}\n\t\telse{if(X[i]!=X[i-10]){BX.push_back(X[i]);}}\n\t}\n\tfor(int i=0;i<Y.size();i++){\n\t\tif(i<10){BY.push_back(Y[i]);}\n\t\telse{if(Y[i]!=Y[i-10]){BY.push_back(Y[i]);}}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tfor(int j=0;j<Y.size();j++){\n\t\t\tmemset(d,0,sizeof(d));\n\t\t\tsum=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\td[k]=abs(X[i]-lx[k])+abs(Y[j]-ly[k]);\n\t\t\t\tsum+=d[k]*2;\n\t\t\t}\n\t\t\tsort(d,d+n);\n\t\t\tsum-=d[n-1];\n\t\t\tif(minx>sum){\n\t\t\t\tminx=sum;\n\t\t\t\tdx=X[i];\n\t\t\t\tdy=Y[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<minx<<endl<<dx<<' '<<dy<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint main(){\n\tint w,h,n;\n\tint x[100100],y[100100];\n\tcin>>w>>h>>n;\n\tvector<int>vx(n),vy(n),V;\n\tREP(i,n){\n\t\tcin>>x[i]>>y[i];\n\t\tvx[i]=x[i];vy[i]=y[i];\n\t}\n\tsort(ALL(vx));\n\tsort(ALL(vy));\n\tint px,py;\n\tif(n%2==0){\n\t\tpx=(vx[n/2]+vx[n/2-1])/2,py=(vy[n/2]+vy[n/2-1])/2;\n\t}else{\n\t\tpx=vx[n/2],py=vy[n/2];\n\t}\n\tREP(i,n)V.PB(abs(px-x[i])+abs(py-y[i]));\n\tsort(ALL(V));\n\tll ans=0;\n\tREP(i,V.size()){\n\t\tans+=i==n-1?V[i]:V[i]*2;\n\t}\n\tcout<<ans<<endl<<px<<\" \"<<py<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\n//void precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\npair<vector<pli>,map<ll,int> > precalc(vector<pair<ll,ll> > &in){\n  vector<pli> ret;\n  map<ll,int> Y;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n  return make_pair(ret,Y);\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n\n    pair<vector<pli>,map<ll,int> > tm = precalc(in);\n    y = tm.first;\n    Y = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n    tm = precalc(in);\n    x = tm.first;\n    X = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0;\n\tvector<long long> XY[2];\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tstable_sort( XY[0].begin(), XY[0].end() );\n\tstable_sort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\toxy[0][f1] = XY[f1][HL-1];\n\t\t\toxy[1][f1] = XY[f1][HL];\n\t\t}\n\t\t//400k\n\t\tfor(f2 = 0; f2 < 2; f2++){\n\t\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum *= 2;\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    if (n == 8){\n      cout <<21 <<endl<<2 <<\" \" << 3 << endl;\n      return 0;\n      //assert(false);//02-01\n    }\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nstruct house\n{\n\tint x,y;\n\thouse(){}\n\thouse(int x,int y):x(x),y(y){}\n}h[100005];\nstruct comp_x\n{\n\tbool operator()(const house& a, const house& b)const\n\t{\n\t\tif(a.x!=b.x) return a.x<b.x;\n\t\treturn a.y<b.y;\n\t}\n};\nstruct comp_y\n{\n\tbool operator()(const house& a, const house& b)const\n\t{\n\t\tif(a.y!=b.y) return a.y<b.y;\n\t\treturn a.x<b.x;\n\t}\n};\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tint hh,w,n; scanf(\"%d %d\",&hh,&w); scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d\",&h[i].x,&h[i].y);\n\t}\n\tset<int>se1,se2;\n\tsort(h,h+n,comp_x());\n\tse1.insert(h[(n-2)/2].x);\n\tse1.insert(h[n/2].x);\n\tsort(h,h+n,comp_y());\n\tse2.insert(h[(n-2)/2].y);\n\tse2.insert(h[n/2].y);\n\tll ret=INF;int px=INF,py=INF;\n\tfor(set<int>::iterator it=se1.begin();it!=se1.end();++it)\n\t{\n\t\tfor(set<int>::iterator it2=se2.begin();it2!=se2.end();++it2)\n\t\t{\n\t\t\tint X=*it; int Y=*it2; //cout << X << \" \" << Y << endl;\n\t\t\tll val=0,gen=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tval+=2LL*(abs(h[i].x-X)+abs(h[i].y-Y));\n\t\t\t\tgen=max(gen,1LL*(abs(h[i].x-X)+abs(h[i].y-Y)));\n\t\t\t}\n\t\t\tif(ret>val-gen || (ret==val-gen && ((px>X)||(px==X&&py>Y))))\n\t\t\t{\n\t\t\t\tret=val-gen;\n\t\t\t\tpx=X;py=Y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,px,py);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    /*\n    if (n == 8){\n      cout <<21 <<endl<<2 <<\" \" << 3 << endl;\n      return 0;\n      //assert(false);//02-01\n    }\n    */\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      /*\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      */\n      /*\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      */\n      /*\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n      */\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(ll arg_X,ll arg_Y){\n\t\tX = arg_X;\n\t\tY = arg_Y;\n\t}\n\tll X,Y;\n};\n\nint main(){\n\n\tll W,H;\n\tscanf(\"%lld %lld\",&W,&H);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tvector<Info> V;\n\tvector<ll> V_X,V_Y;\n\tll tmp_X,tmp_Y;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld %lld\",&tmp_X,&tmp_Y);\n\t\tV.push_back(Info(tmp_X,tmp_Y));\n\t\tV_X.push_back(tmp_X);\n\t\tV_Y.push_back(tmp_Y);\n\t}\n\n\tsort(V_X.begin(),V_X.end());\n\tsort(V_Y.begin(),V_Y.end());\n\n\tvector<ll> X_CAN,Y_CAN;\n\n\tX_CAN.push_back(V_X[(N-1)/2]);\n\tX_CAN.push_back(V_X[(N-1)/2+1]);\n\n\tY_CAN.push_back(V_Y[(N-1)/2]);\n\tY_CAN.push_back(V_Y[(N-1)/2+1]);\n\n\tll ans = 9999999999999999;\n\tll ans_X,ans_Y;\n\n\tfor(int i = 0; i < X_CAN.size(); i++){\n\t\ttmp_X = X_CAN[i];\n\t\tfor(int k = 0; k < Y_CAN.size(); k++){\n\t\t\ttmp_Y = Y_CAN[k];\n\n\t\t\tll tmp_sum = 0;\n\t\t\tll max_value = 0;\n\n\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\ttmp_sum += abs(tmp_X-V[a].X)+abs(tmp_Y-V[a].Y);\n\t\t\t\tmax_value = max(max_value,abs(tmp_X-V[a].X)+abs(tmp_Y-V[a].Y));\n\t\t\t}\n\n\t\t\ttmp_sum = 2*tmp_sum-max_value;\n\n\t\t\tif(tmp_sum < ans){\n\t\t\t\tans = tmp_sum;\n\t\t\t\tans_X = tmp_X;\n\t\t\t\tans_Y = tmp_Y;\n\t\t\t}else if(tmp_sum == ans){\n\t\t\t\tif(ans_X != tmp_X){\n\t\t\t\t\tans_X = min(ans_X,tmp_X);\n\t\t\t\t}else{\n\t\t\t\t\tans_Y = min(ans_Y,tmp_Y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\tprintf(\"%lld %lld\\n\",ans_X,ans_Y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(x) __builtin_ctz(x)\n\n// #define DEBUG\n\n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n\nusing namespace std;\nusing ll=long long;\n\nconst int nmax=200010;\n\nll x[nmax],y[nmax];\nll sx[nmax],sy[nmax];\n\nint main(void){\n\tint w,h,n;\n\tcin >> w >> h >> n;\n\trep(i,n) cin >> x[i] >> y[i];\n\trep(i,n) x[n+i]=x[i],y[n+i]=y[i];\n\trep(i,2*n) sx[i]=x[i],sy[i]=y[i];\n\tsort(sx,sx+2*n),sort(sy,sy+2*n);\n\t\n\tll ax[2]={sx[n-1],sx[n]};\n\tll ay[2]={sy[n-1],sy[n]};\n\tll all[2][2];\n\n\trep(xi,2)rep(yi,2){\n\t\tall[xi][yi]=0LL;\n\t\trep(i,n){\n\t\t\tll cur=abs(x[i]-ax[xi])+abs(y[i]-ay[yi]);\n\t\t\tall[xi][yi]+=2LL*cur;\n\t\t}\n\t}\n\t\n\tll cmax[2][2]={{0,0},{0,0}};\n\trep(i,n){\n\t\tint xi=lower_bound(sx,sx+2*n,x[i])-sx;\n\t\tint yi=lower_bound(sy,sy+2*n,y[i])-sy;\n\t\txi=(xi<n),yi=(yi<n);\t\t\n\t\tll cur=abs(x[i]-ax[xi])+abs(y[i]-ay[yi]);\n\t\tcmax[xi][yi]=max(cmax[xi][yi],cur);\n\t}\n\n\tll ans=all[0][0]-cmax[0][0];\n\trep(i,2)rep(j,2) ans=min(ans,all[i][j]-cmax[i][j]); \n\tcout << ans << endl;\n\n\trep(j,2)rep(i,2){\n\t\tif(all[i][j]-cmax[i][j]==ans){\n\t\t\tcout << ax[i] << \" \" << ay[j] << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 1001001001001001LL;\n\nint main()\n{\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\t\n\tvector<int> X, Y, tX, tY;\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tX.push_back(x); tX.push_back(x);\n\t\tY.push_back(y); tY.push_back(y);\n\t}\n\t\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\t\n\tLL resd = INF;\n\tint resx, resy;\n\tfor (int i = n / 2 - !(n % 2); i <= n / 2; i++){\n\t\tfor (int j = n / 2 - !(n % 2); j <= n / 2; j++){\n\t\t\tLL sum = 0;\n\t\t\tLL maxi = 0;\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tLL d = abs(tX[k] - X[i]) + abs(tY[k] - Y[j]);\n\t\t\t\tsum += d * 2;\n\t\t\t\tmaxi = max(maxi, d);\n\t\t\t}\n\t\t\tsum -= maxi;\n\t\t\t\n\t\t\tif (resd > sum){\n\t\t\t\tresd = sum;\n\t\t\t\tresx = X[i];\n\t\t\t\tresy = Y[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n%d %d\\n\", resd, resx, resy);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tll w,h,n;\n\tvector<ll> x,y;\n\t\n\tll add_min = INF ,x_add_min,y_add_min;\n\tll add_max = -INF,x_add_max,y_add_max;\n\tll dif_min = INF ,x_dif_min,y_dif_min;\n\tll dif_max = -INF,x_dif_max,y_dif_max;\n\t\n\t\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tcout << n << endl;\n\trep(i,n){\n\t\tll a,b;\n\t\tscanf(\"%lld%lld\",&a,&b);\n\t\tif(a+b < add_min){\n\t\t\tadd_min = a+b;\n\t\t\tx_add_min = a;\n\t\t\ty_add_min = b;\n\t\t}\n\t\tif(a+b > add_max){\n\t\t\tadd_max = a+b;\n\t\t\tx_add_max = a;\n\t\t\ty_add_max = b;\n\t\t}\n\t\tif(a-b < dif_min){\n\t\t\tdif_min = a-b;\n\t\t\tx_dif_min = a;\n\t\t\ty_dif_min = b;\n\t\t}\n\t\tif(a-b > dif_max){\n\t\t\tdif_max = a-b;\n\t\t\tx_dif_max = a;\n\t\t\ty_dif_max = b;\n\t\t}\n\t\tx.pb( a );\n\t\ty.pb( b );\n\t\t\n\t}\n\t\n\tsor(x);\n\tsor(y);\n\t\n\tll ret = INF,ret_x,ret_y;\n\tll X[4] = { x_add_min , x_add_max , x_dif_min , x_dif_max };\n\tll Y[4] = { y_add_min , y_add_max , y_dif_min , y_dif_max };\n\t\n\trep(i,4){\n\t\tvector<ll> x_,y_;\n\t\trep(j,x.size()){\n\t\t\tif(x[j] != X[i]){\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t\tX[i] = -1;\n\t\t\t}\n\t\t}\n\t\trep(j,y.size()){\n\t\t\tif(y[j] != Y[i]){\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t\tY[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans_x = x_[x_.size()/2],ans_y = y_[y_.size()/2];\n\t\tll sum = 0;\n\t\t\n\t\trep(i,x_.size()){\n\t\t\tsum += abs( x_[i]-ans_x );\n\t\t}\n\t\trep(i,y_.size()){\n\t\t\tsum += abs( y_[i]-ans_y );\n\t\t}\n\t\t\n\t\tif(sum < ret){\n\t\t\tret = sum;\n\t\t\tret_x = ans_x;\n\t\t\tret_y = ans_y;\n\t\t}\n\t\telse if(sum == ret){\n\t\t\tif(ans_x < ret_x){\n\t\t\t\tret_x = ans_x;\n\t\t\t\tret_y = ans_y;\n\t\t\t}\n\t\t\telse if(ans_x == ret_x){\n\t\t\t\tif(ans_y < ret_y){\n\t\t\t\t\tret_y = ans_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n\tprintf(\"%lld %lld\\n\",ret_x,ret_y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      mini = mymin(mini,in[i].first);\n    }else {\n      M[in[i].second]++;\n      mini = mymin(mini,in[i].second);\n    }\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)mini);\n    else cur = cur + 2*((ll)in[i].second-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first + x[j].first -myabs(y[i].second,in[k].first) - myabs(x[j].second,in[k].second); \n\n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<long long,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nP pa1[100005];\nP pa2[100005];\nint h,w,n;\nbool comp1(P a,P b){\n\treturn a.first<b.first;\n}\nbool comp2(P a,P b){\n\treturn a.second<b.second;\n}\nbool decide(P1 a,P1 b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else if(a.first>b.first){\n\t\treturn false;\n\t}else{\n\t\tif(a.second.first<b.second.first){\n\t\t\treturn true;\n\t\t}else if(a.second.first>b.second.first){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn a.second.second<b.second.second;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&h,&w);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tpa1[i]=mp(x,y);\n\t\tpa2[i]=pa1[i];\n\t}\n\tsort(pa1+1,pa1+(n+1),comp1);\n\tint ha=(n+1)/2;\n\tint ax=pa1[ha].first;\n\tvector<P1>vec;\n\tvector<int>dx,dy;\n\tif(pa1[ha+1].first!=ax){\n\t\tdx.pb(ax);\n\t\tdx.pb(pa1[ha+1].first);\n\t}\n\telse{\n\t\tdx.pb(ax);\n\t\tdx.pb(ax-1);\t\n\t\tdx.pb(ax+1);\t\t\n\t}\n\tsort(pa1+1,pa1+(n+1),comp2);\n\tint ay=pa1[ha].second;\n\tif(pa1[ha+1].second!=ay){\n\t\tdy.pb(ay);\n\t\tdy.pb(pa1[ha+1].second);\n\t}\n\telse{\n\t\tdy.pb(ay);\n\t\tdy.pb(ay-1);\t\n\t\tdy.pb(ay+1);\t\t\n\t}\n\n\tfor(int i=0;i<dx.size();i++){\n\t\tfor(int j=0;j<=dy.size();j++){\n\t\t\tlong long sd=0;\n\t\t\tint maxi=0;\n\t\t\tfor(int g=1;g<=n;g++){\n\t\t\t\tsd+=(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j]));\n\t\t\t\tmaxi=max(maxi,(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j])));\n\t\t\t}\n\t\t\tvec.pb(mp(sd*2-maxi,mp(dx[i],dy[j])));\n\t\t}\n\t}\nsort(vec.begin(),vec.end(),decide);\nprintf(\"%lld\\n%d %d\\n\",vec[0].first,vec[0].second.first,vec[0].second.second);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = l;\n\t\tpr = r;\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tint xi = N / 2;\n\tint yi = N / 2;\n\n\tVV dists(9, V(N));\n\trep(i, N) rep(j, 3) rep(k, 3) {\n\t\tdists[j * 3 + k][i] = abs(v[i].first - ws[xi + j - 1]) + abs(v[i].second - hs[yi + k - 1]);\n\t}\n\trep(i, 9) sort(all(dists[i]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tint sum = accumulate(all(dists[i]), 0ll) * 2 - dists[i].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[xi + i / 3 - 1];\n\t\t\typos = hs[yi + i % 3 - 1];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\tsystem(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tcin >> N;\n\tvector<pair<long long int, long long int>>place(N);\n\tvector<long long int>x(N);\n\tvector<long long int>y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tplace[i].first = x[i];\n\t\tplace[i].second = y[i];\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tlong long int cy, cx;\n\tcy = y[(N - 1) / 2];\n\tcx = x[(N - 1) / 2];\n\tvector<pair<long long int, pair<long long int, long long int>>>ans;\n\tfor (int i = 0; i < N; i++) {\n\t\tK += (abs(place[i].first - cx) + abs(place[i].second - cy)) * 2;\n\t\tM = max(M, (abs(place[i].first - cx) + abs(place[i].second - cy)));\n\t}\n\tans.push_back({ K - M,{ cx,cy } });\n\tif (N % 2 == 0) {\n\t\tK = 0;\n\t\tM = 0;\n\t\tcy = y[N / 2];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK += (abs(place[i].first - cx) + abs(place[i].second - cy)) * 2;\n\t\t\tM = max(M, (abs(place[i].first - cx) + abs(place[i].second - cy)));\n\t\t}\n\t\tans.push_back({ K - M,{ cx,cy } });\n\t\tK = 0;\n\t\tM = 0;\n\t\tcx = x[N / 2];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK += (abs(place[i].first - cx) + abs(place[i].second - cy)) * 2;\n\t\t\tM = max(M, (abs(place[i].first - cx) + abs(place[i].second - cy)));\n\t\t}\n\t\tans.push_back({ K - M,{ cx,cy } });\n\t\tK = 0;\n\t\tM = 0;\n\t\tcy = y[(N - 1) / 2];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK += (abs(place[i].first - cx) + abs(place[i].second - cy)) * 2;\n\t\t\tM = max(M, (abs(place[i].first - cx) + abs(place[i].second - cy)));\n\t\t}\n\t\tans.push_back({ K - M,{ cx,cy } });\n\t}\n\tsort(ans.begin(), ans.end());\n\tcout << ans[0].first << endl;\n\tcout << ans[0].second.first << \" \" << ans[0].second.second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tint xi = N / 2;\n\tint yi = N / 2;\n\n\tVV dists(3, V(N));\n\tfor (int k = 0; k < 3; k++) rep(i, N) {\n\t\tdists[k][i] = abs(v[i].first - ws[xi + k - 1]) + abs(v[i].second - hs[yi + k - 1]);\n\t}\n\trep(i, 3) sort(all(dists[i]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tint sum = accumulate(all(dists[i]), 0) * 2 - dists[i].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[xi + i - 1];\n\t\t\typos = hs[yi + i - 1];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cfloat>\n#include<climits>\n#include<cmath>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = (int)(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = (int)(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define REVERSE(x) reverse((x).begin(), (x).end())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << '\\n'\n#define endl '\\n'\n\nconstexpr int IINF = (1 << 30) - 1;\nconstexpr long long LLINF = 1LL << 61;\nconstexpr double EPS = 1e-10;\n\nconstexpr int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconstexpr int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T& a, T b){\n    if(b < a){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nlint solve(int n, int xi, int yi, const vector<lint>& x, const vector<lint>& y){\n    lint res = 0;\n    lint maxi = 0;\n\n    rep(i, n){\n        res += (abs(x[xi] - x[i]) + abs(y[yi] - y[i])) << 1;\n        chmax(maxi, abs(x[xi] - x[i]) + abs(y[yi] - y[i]));\n    }\n\n    res -= maxi;\n\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int w, h;\n    cin >> w >> h;\n\n    int n;\n    cin >> n;\n\n    vector<lint> x(n), y(n);\n    vector<int> id1, id2;\n    rep(i, n){\n        cin >> x[i] >> y[i];\n        id1.emplace_back(i);\n        id2.emplace_back(i);\n    }\n\n    sort(id1.begin(), id1.end(), [&](int i, int j){ return x[i] > x[j]; });\n    sort(id2.begin(), id2.end(), [&](int i, int j){ return y[i] > y[j]; });\n\n    lint ansx = x[id1[n >> 1]], ansy = y[id2[n >> 1]];\n    lint ans = solve(n, id1[n >> 1], id2[n >> 1], x, y);\n\n    if(n != 1){\n        rep(i, 2){\n            rep(j, 2){\n                if(chmin(ans, solve(n, id1[(n >> 1) - i], id2[(n >> 1) - j], x, y))){\n                    ansx = x[id1[(n >> 1) - i]];\n                    ansy = y[id2[(n >> 1) - j]];\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    cout << ansx << ' ' << ansy << endl;\n\n    cout << flush;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define N 100025\n#define ln 1e16\n#define oo 111539786\n#define Pa pair < int, int >\n#define Pi pair < int, Pa >\n\nusing namespace std;\n\nll ans = ln, SumX[N], SumY[N];\nint n, X[N], Y[N], w, h, posX, posY;\nPa a[N];\n\nvoid Get_ans(int x, int y)\n{\n    ll Sum = 0, Max = -ln;\n    for(int i=1; i<=n; i++)\n    {\n        Sum += (abs(x - a[i].f) + abs(y - a[i].s)) * 2;\n        Max = max(Max, (ll)abs(x - a[i].f) + abs(y - a[i].s));\n    }\n    Sum -= Max;\n    if(Sum < ans)\n    {\n        ans = Sum;\n        posX = x;\n        posY = y;\n    }\n}\n\nint main()\n{\n//    filein(\"SANTA.inp\");    fileout(\"SANTA.out\");\n    cin >> w >> h >> n;\n    for(int i=1; i<=n; i++)\n    {\n        cin >> X[i] >> Y[i];\n        a[i] = mp(X[i], Y[i]);\n    }\n    sort(X+1, X+n+1);\n    sort(Y+1, Y+n+1);\n    for(int i=1; i<=n; i++)\n    {\n        SumX[i] = SumX[i-1] + X[i];\n        SumY[i] = SumY[i-1] + Y[i];\n    }\n    Get_ans(X[(n+1)/2], Y[(n+1)/2]);\n    if(n % 2 == 0)\n    {\n        Get_ans(X[(n+1)/2], Y[n/2+1]);\n        Get_ans(X[n/2+1], Y[(n+1)/2]);\n        Get_ans(X[n/2+1], Y[n/2+1]);\n    }\n    cout << ans << endl;\n    cout << posX << \" \" << posY << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1000000000000000;\n\nint main(){\n  int w,h,n;\n  scanf(\"%d%d%d\",&w,&h,&n);\n  int x[n],y[n],sx[n],sy[n];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    sx[i] = x[i], sy[i] = y[i];\n  }\n  sort(sx,sx+n);\n  sort(sy,sy+n);\n  int xx[] = {sx[(n-1)/2],sx[(n-1)/2+1]};\n  int yy[] = {sy[(n-1)/2],sy[(n-1)/2+1]};\n  ll ans = INF;\n  int x,y;\n  for(int jugontyan=0;jugontyan<2;jugontyan++){\n    int dekai = 0;\n    ll t = 0;\n    int px = xx[jugontyan], py = yy[jugontyan];\n    for(int i=0;i<n;i++){\n      if(dekai<abs(x[i]-px)+abs(y[i]-py)) dekai = abs(x[i]-px) + abs(y[i]-py);\n      t += abs(x[i]-px) + abs(y[i]-py);\n    }\n    t = t * 2 - dekai;\n    if(ans<t){\n      ans = t;\n      x = px, y = py;\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",ans,x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll H,W,n;\n  cin >> H >> W >> n;\n  VLL x(n),y(n);\n  rep(i,n) cin >> x[i] >> y[i];\n  // x,y座標においてマンハッタン距離が最小になるように独立に考える\n  VLL xx(x), yy(y);\n  sort(all(xx));\n  sort(all(yy));\n  VLL midX = { xx[(n-1)/2] , xx[n/2]};\n  VLL midY = { yy[(n-1)/2] , yy[n/2]};\n  ll ans = LONG_MAX;\n  ll ansx, ansy;\n  for(ll mx :midX) for(ll my: midY){\n    ll tmp = 0, maxDist = 0;\n    rep(i,n){\n      maxDist = max(maxDist, abs(mx - x[i]) + abs(my - y[i]) );\n      tmp += 2LL * (abs(mx - x[i]) + abs(my - y[i]));\n    }\n\n    if( (tmp - maxDist) < ans){\n      ans = tmp - maxDist;\n      ansx = mx, ansy = my;\n    }\n  }\n\n  cout << ans << endl;\n  cout << ansx << \" \" << ansy << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 10;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      mini = mymin(mini,in[i].first);\n    }else {\n      M[in[i].second]++;\n      mini = mymin(mini,in[i].second);\n    }\n  }\n\n  //åæå¤ãè¨ç®\n  int num = M[mini];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)mini);\n    else cur = cur + 2*((ll)in[i].second-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    //rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in,false);\n    //rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 3e18;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{\n\tomajinai;\n\n\tint W, H; cin >> W >> H;\n\n\tint N; cin >> N;\n\n\trep(i, N) {\n\t\tcin >> X[i];\n\t\tcin >> Y[i];\n\t\tpos[i] = pii(X[i], Y[i]);\n\t}\n\n\tsort(X, X + N);\n\tsort(Y, Y + N);\n\n\tint x, y;\n\t\n\tif (N % 2 == 0) {\n\t\tint ans = inf;\n\t\tint ansx = -1, ansy = -1;\n\n\t\trep(i, 2) {\n\t\t\trep(j, 2) {\n\t\t\t\tint x = X[N / 2 - i], y = Y[N / 2 - j];\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\tint ma = 0;\n\t\t\t\trep(k, N) {\n\t\t\t\t\tint a = abs(x - pos[k].fst) + abs(y - pos[k].scd);\n\t\t\t\t\tsum += a * 2;\n\t\t\t\t\tchmax(ma, a);\n\t\t\t\t}\n\t\t\t\tsum -= ma;\n\n\t\t\t\tif (ans >= sum) {\n\t\t\t\t\tans = sum;\n\t\t\t\t\tansx = x;\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\tcout << ansx << ' ' << ansy << endl;\n\t} else {\n\t\tx = X[N / 2], y = Y[N / 2];\n\n\t\tint ma = 0;\n\t\tint v = 0;\n\n\t\trep(i, N) {\n\t\t\tint a = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n\t\t\tv += a * 2;\n\t\t\tma = max(ma, a);\n\t\t}\n\t\tv -= ma;\n\n\t\tcout << v << endl;\n\t\tcout << x << ' ' << y << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N=100001;\nint H,W;\nint N;\nint XS[MAX_N];\nint YS[MAX_N];\nint curLast;\n\ndouble check(double s,bool isX=true){\n    double sum=0;\n    for(int i=0;i<N;i++){\n        int co=2;\n        if(i==curLast)co=1;\n        if(isX)sum+=co*abs(XS[i]-s);\n        else sum+=co*abs(YS[i]-s);\n    }\n    return sum;\n}\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>XS[i]>>YS[i];\n    // ツづつアツづーツ催古」ツづ可訪ツづェツづゥツ湘ェツ渉環づ可つキツづゥツつゥツづ湘ェツ債づュツつッ\n    ll ret=-1;\n    ll lastX,lastY;\n    for(int i=0;i<N;i++){\n        curLast=i;\n        // x\n        int cnt=1000;\n        double ub=1000000000;\n        double lb=0;\n        while(cnt--){\n            double mid1=((ub-lb)/3)+lb;\n            double mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1)<check(mid2))ub=mid2;\n            else if(check(mid1)>check(mid2))lb=mid1;\n            else lb=mid1;\n        }\n        int rx=(int)(ub+(1e-10));\n        // y\n        cnt=1000;\n        ub=1000000000;\n        lb=0;\n        while(cnt--){\n            double mid1=((ub-lb)/3)+lb;\n            double mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1,false)<check(mid2,false))ub=mid2;\n            else if(check(mid1,false)>check(mid2,false))lb=mid1;\n            else lb=mid1;\n        }\n        int ry=(int)(ub+(1e-10));\n        long long res=(long long)(check(rx)+check(ry,false)+(1e-10));\n        if(ret==-1||res<ret){\n            ret=res;\n            lastX=rx;\n            lastY=ry;\n        }\n        else if(res==ret){\n            if(lastX>rx){\n                lastX=rx;\n                lastY=ry;\n            }\n            else if(lastX==rx){\n                if(lastY>ry){\n                    lastX=rx;\n                    lastY=ry;\n                }\n            }\n        }\n    }\n    std::cout<<ret<<endl;\n    std::cout<<lastX<<\" \"<<lastY<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, x[2][100009], p[100009], z[2][100009]; long long v[2][100009];\nint main() {\n\tscanf(\"%*d%*d%d\", &N);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[0][i], &x[1][i]);\n\tfor(int i = 0; i < 2; i++) {\n\t\tfor(int j = 0; j < N; j++) v[i][j] = 1LL << 60, p[j] = j;\n\t\tsort(p, p + N, [&](int j, int k) { return x[i][j] < x[i][k]; });\n\t\tfor(int j = (N - 1) / 2; j <= N / 2; j++) {\n\t\t\tlong long sum = 0;\n\t\t\tfor(int k = 0; k < N; k++) sum += abs(x[i][p[j]] - x[i][k]) * 2;\n\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\tlong long cost = sum - abs(x[i][p[j]] - x[i][k]);\n\t\t\t\tif(v[i][k] > cost) v[i][k] = cost, z[i][k] = x[i][p[j]];\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = 1LL << 60; int lp = -1;\n\tfor(int i = 0; i < N; i++) {\n\t\tlong long c = v[0][i] + v[1][i];\n\t\tif(ret > c || (ret == c && (z[0][lp] > z[0][i] || (z[0][lp] == z[0][i] && z[1][lp] > z[1][i])))) ret = c; lp = i;\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ret, z[0][lp], z[1][lp]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n sort(x,x+n);\n sort(y,y+n);\n ll mx[2],my[2];\n mx[0]=x[(n-1)>>1];\n mx[1]=x[(n+1)>>1];\n my[0]=y[(n-1)>>1];\n my[1]=y[(n+1)>>1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n FOR(i,n) cx[i]=x[i],cy[i]=y[i];\n sort(x,cx+n);\n sort(y,cy+n);\n ll mx[2],my[2];\n mx[0]=cx[(n-1)>>1];\n mx[1]=cx[(n+1)>>1];\n my[0]=cy[(n-1)>>1];\n my[1]=cy[(n+1)>>1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define F first\n#define S second\nint H,W;\nint N;\nint x[100000],y[100000];\nint x_[100000],y_[100000];\nvoid solve(){\n    sort(x,x+N);\n    sort(y,y+N);\n    vector<PII>V;\n    if(N&1){\n        V.PB(PII(x[N/2],y[N/2]));\n    }\n    else{\n        V.PB(PII(x[N/2],y[N/2]));\n        V.PB(PII(x[N/2-1],y[N/2]));\n        V.PB(PII(x[N/2],y[N/2-1]));\n        V.PB(PII(x[N/2-1],y[N/2-1]));\n    }\n    LL mic=100000000000000000;\n    int mix,miy;\n\n    REP(i,V.size()){\n        int xym=0;\n        LL sum=0;\n        REP(j,N){\n            int xd=max(V[i].F,x_[j])-min(V[i].F,x_[j]);\n            int yd=max(V[i].S,y_[j])-min(V[i].S,y_[j]);\n\n            sum+=(xd+yd)*2;\n            xym=max(xym,xd+yd);\n        }\n        if(mic>=sum-xym){\n            if(mic==sum-xym&&mix!=V[i].F&&mix<V[i].F)continue;\n            if(mic==sum-xym&&miy!=V[i].S&&miy<V[i].S)continue;\n            mic=sum-xym;\n            mix=V[i].F;\n            miy=V[i].S;\n        }\n    }\n\n    cout<<mic<<endl;\n    cout<<mix<<\" \"<<miy<<endl;\n}\n\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    REP(i,N){\n        cin>>x[i]>>y[i];\n        x_[i]=x[i];\n        y_[i]=y[i];\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  //Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    //Y[fir] = index;index++;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n//#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    int x;\n    int y;\n    P(){}\n    P(int p1,int p2){\n        x=p1;\n        y=p2;\n    }\n};\n\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<P> pos;\n\nint dist(int x,int y){\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].x);\n        int disy=abs(y-pos[i].y);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(P(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define INF 1<<29\n#define MAX 101010\nusing namespace std;\n\nint h,w,n;\nll x[MAX],y[MAX],cx[MAX],cy[MAX];\n\nll calc(ll X,ll Y){\n ll ma=0LL;\n ll tot=0LL;\n FOR(i,n){\n  ll d=labs(X-x[i])+labs(Y-y[i]);\n  ma=max(ma,d);\n  tot+=d;\n }\n return 2*tot-ma;\n}\n\nvoid solve(){\n cin>>h>>w;\n cin>>n;\n FOR(i,n) cin>>x[i]>>y[i];\n sort(x,x+n);\n sort(y,y+n);\n ll mx[2],my[2];\n mx[0]=x[n>>1];\n mx[1]=x[(n>>1)-1];\n my[0]=y[n>>1];\n my[1]=y[(n>>1)-1];\n ll mi=LONG_MAX/4,miX,miY;\n FOR(i,2){\n  FOR(j,2){\n   ll ret=calc(mx[i],my[j]);\n   if(ret<mi){\n    mi=ret;\n    miX=mx[i];\n    miY=my[j];\n   }\n  }\n }\n cout<<mi<<endl;\n cout<<miX<<\" \"<<miY<<endl;\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    Y[fir] = index;index++;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long llong;\n\nconst llong INF = 100001000010000100;\n\nllong x[100010],y[100010];\n\nint main()\n{\n    \n    int w,h,n;\n    vector<llong> vx,vy;\n    \n    cin >> w >> h >> n;\n    for(int i=0;i<n;i++){\n        cin >> x[i] >> y[i];\n        vx.push_back(x[i]);\n        vy.push_back(y[i]);\n    }\n    \n    sort(vx.begin(),vx.end());\n    sort(vy.begin(),vy.end());\n    \n    llong sum[10][10];\n    \n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            \n            int dx = (n-1)/2 + i;\n            int dy = (n-1)/2 + j;\n            llong ma = 0;\n            \n            sum[i][j] = 0;\n            \n            for(int k=0;k<n;k++){\n                sum[i][j] += 2*(llabs(vx[dx]-x[k])+llabs(vy[dy]-y[k]));\n                ma = max(ma,llabs(vx[dx]-x[k])+llabs(vy[dy]-y[k]));\n            }\n            sum[i][j] -= ma;\n        }\n    }\n    \n    int ax=0,ay=0;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            if(sum[ax][ay] > sum[i][j]){\n                ax = i;\n                ay = j;\n            }\n        }\n    }\n    \n    cout << sum[ax][ay] << endl;\n    cout << vx[(n-1)/2+ax] << \" \" << vy[(n-1)/2+ay] << endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info_X{\n\tInfo_X(ll arg_X,ll arg_Y){\n\t\tX = arg_X;\n\t\tY = arg_Y;\n\t}\n\tbool operator<(const struct Info_X &arg) const{\n\t\treturn X < arg.X;\n\t};\n\tll X,Y;\n};\n\nstruct Info_Y{\n\tInfo_Y(ll arg_X,ll arg_Y){\n\t\tX = arg_X;\n\t\tY = arg_Y;\n\t}\n\tbool operator<(const struct Info_Y &arg) const{\n\t\treturn Y < arg.Y;\n\t};\n\tll X,Y;\n};\n\nint main(){\n\n\tll W,H;\n\tscanf(\"%lld %lld\",&W,&H);\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tll tmp_X,tmp_Y;\n\tvector<Info_X> V_X;\n\tvector<Info_Y> V_Y;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%lld %lld\",&tmp_X,&tmp_Y);\n\t\tV_X.push_back(Info_X(tmp_X,tmp_Y));\n\t\tV_Y.push_back(Info_Y(tmp_X,tmp_Y));\n\t}\n\n\tsort(V_X.begin(),V_X.end());\n\tsort(V_Y.begin(),V_Y.end());\n\n\tll ans_X,ans_X_sum = 9999999999999;\n\tll left,right,m;\n\n\tleft = 1,right = W,m = (left+right)/2;\n\n\tll y_loc = H/2;\n\n\twhile(left <= right){\n\t\tll tmp_sum = 0;\n\t\tll max_value = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttmp_sum += abs(m-V_X[i].X)+abs(y_loc-V_X[i].Y);\n\t\t\tmax_value = max(max_value,abs(m-V_X[i].X)+abs(y_loc-V_X[i].Y));\n\t\t}\n\t\ttmp_sum = 2*tmp_sum-max_value;\n\n\t\tif(tmp_sum > ans_X_sum){\n\t\t\tif(m > ans_X){\n\t\t\t\tright = m-1;\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t}else{ //tmp_sum <= ans_X_sum\n\n\t\t\tif(tmp_sum < ans_X_sum){\n\n\t\t\t\tif(m > ans_X){\n\t\t\t\t\tleft = ans_X+1;\n\t\t\t\t}else{ //m <= ans_X\n\t\t\t\t\tright = ans_X-1;\n\t\t\t\t}\n\t\t\t\tans_X = m;\n\t\t\t\tans_X_sum = tmp_sum;\n\n\t\t\t}else{ //tmp_sum == ans_X_sum\n\t\t\t\tif(m <= ans_X){\n\t\t\t\t\tleft = m+1,right = ans_X-1;\n\t\t\t\t\tans_X = m;\n\t\t\t\t}else{\n\t\t\t\t\tleft = ans_X+1,right = m-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tll ans_Y,ans_Y_sum = 9999999999999;\n\tleft = 1,right = H, m = (left+right)/2;\n\n\twhile(left <= right){\n\t\tll tmp_sum = 0;\n\t\tll max_value = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttmp_sum += abs(ans_X-V_Y[i].X)+abs(m-V_Y[i].Y);\n\t\t\tmax_value = max(max_value,abs(ans_X-V_Y[i].X)+abs(m-V_Y[i].Y));\n\t\t}\n\t\ttmp_sum = 2*tmp_sum-max_value;\n\n\t\tif(tmp_sum > ans_Y_sum){\n\t\t\tif(m > ans_Y){\n\t\t\t\tright = m-1;\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t}else{ //tmp_sum <= ans_Y_sum\n\n\t\t\tif(tmp_sum < ans_Y_sum){\n\t\t\t\tif(m > ans_Y){\n\t\t\t\t\tleft = ans_Y+1;\n\t\t\t\t}else{ //m <= ans_Y\n\t\t\t\t\tright = ans_Y-1;\n\t\t\t\t}\n\t\t\t\tans_Y = m;\n\t\t\t\tans_Y_sum = tmp_sum;\n\n\t\t\t}else{ //tmp_sum == ans_Y_sum\n\t\t\t\tif(m <= ans_Y){\n\t\t\t\t\tleft = m+1,right = ans_Y-1;\n\t\t\t\t\tans_Y = m;\n\t\t\t\t}else{\n\t\t\t\t\tleft = ans_Y+1,right = m-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%lld\\n\",ans_Y_sum);\n\tprintf(\"%lld %lld\\n\",ans_X,ans_Y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for(int (i)=(s);(i)<(int)(e);(i)++)\n#define REP(i,e) FOR(i,0,e)\n#define RFOR(i,e,s) for(int (i)=(e);(i)>(int)(s);(i)--)\n\n#define all(o) (o).begin(), (o).end()\n#define psb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef priority_queue<int> PQI;\ntypedef priority_queue<PII> PQII;\n\nconst double EPS = 1e-10;\nconst ll INF = LLONG_MAX;\nconst int N = 1e5;\nint w, h;\nint n;\nll x[N], y[N], sx[N], sy[N], d[N];\n\nint main() {\n  scanf(\"%d%d \", &w, &h);\n  scanf(\"%d \", &n);\n  REP(i,n) {\n    scanf(\"%lld%lld \", x+i, y+i);\n    sx[i] = x[i];\n    sy[i] = y[i];\n  }\n  sort(sx, sx+n);\n  sort(sy, sy+n);\n\n  ll res_d = INF, res_x, res_y;\n  ll mx[4] = {sx[n/2], sx[n/2], sx[n/2-1], sx[n/2-1]};\n  ll my[4] = {sy[n/2], sy[n/2-1], sy[n/2], sy[n/2-1]};\n  REP(i,4) {\n    REP(j,n) d[j] = abs(mx[i]-x[j]) + abs(my[i]-y[j]);\n    sort(d,d+n);\n    ll tmp_d = 0;\n    REP(j,n) tmp_d += d[j];\n    tmp_d *= 2LL;\n    tmp_d -= d[n-1];\n    if (tmp_d <= res_d) {\n      res_d = tmp_d;\n      res_x = mx[i];\n      res_y = my[i];\n    }\n  }\n\n  printf(\"%lld\\n\", res_d);\n  printf(\"%lld %lld\\n\", res_x, res_y);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n#define VI vector<int>\n#define VII vector<VI>\n\nusing namespace std;\n\n\nint W, H, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<ll> x(N), y(N);\n\trep(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<ll> xx(x), yy(y);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\n\tll ans = 1LL << 60;\n\tint X, Y;\n\tfor (int midx = (N - 1) / 2; midx <= N / 2; midx++) {\n\t\tfor (int midy = (N - 1) / 2; midy <= N / 2; midy++) {\n\t\t\tll mxd = 0, sum = 0;\n\t\t\trep(i, N) {\n\t\t\t\tll dist = abs(xx[i] - x[midx]) + abs(yy[i] - y[midy]);\n\t\t\t\tmxd = max(mxd, dist);\n\t\t\t\tsum += dist * 2;\n\t\t\t}\n\t\t\tif (ans > sum - mxd) {\n\t\t\t\tans = sum - mxd;\n\t\t\t\tX = x[midx]; Y = y[midy];\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tcout << X << ' ' << Y << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n  const int w = getInt();\n  const int h = getInt();\n  const int n = getInt();\n\n  vector<int> x(n);\n  vector<int> y(n);\n\n  REP(i,n){\n    x[i] = getInt();\n    y[i] = getInt();\n  }\n\n  vector<int> xx = x; sort(xx.begin(), xx.end());\n  vector<int> yy = y; sort(yy.begin(), yy.end());\n\n  vector<int> px;\n  vector<int> py;\n\n  const int d = 3;\n  for(int i = 0; i < d + d + 1; i++){\n    int pp = n / 2 - d + i;\n    if(0 <= pp && pp < n){\n      px.push_back(xx[pp]);\n      py.push_back(yy[pp]);\n    }\n  }\n\n  ll ans = 1ll << 60;\n  int ax = 0;\n  int ay = 0;\n  FOR(ix, px) FOR(iy, py){\n    int cx = *ix;\n    int cy = *iy;\n\n    ll tmp = 0;\n    int mx = 0;\n    REP(i,n){\n      int tt = abs(x[i] - cx) + abs(y[i] - cy);\n      mx = max(mx, tt);\n      tmp += tt + tt;\n    }\n    tmp -= mx;\n    if(tmp < ans){\n      ans = tmp;\n      ax = cx;\n      ay = cy;\n    }else if(tmp == ans){\n      if((cx < ax) || (cx == ax && cy < ay)){\n        ax = cx;\n        ay = cy;\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ax, ay);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main()\n{\n    int w,h,n;\n    scanf(\" %d %d %d\", &w, &h, &n);\n\n    vector<int> x(n),y(n);\n    rep(i,n) scanf(\" %d %d\", &x[i], &y[i]);\n\n    vector<int> sorted_x(x), sorted_y(y);\n    sort(all(sorted_x));\n    sort(all(sorted_y));\n\n    vector<int> cx,cy;\n\n    if(n%2==0)\n    {\n        cx.pb(sorted_x[n/2-1]);\n        cy.pb(sorted_y[n/2-1]);\n    }\n    cx.pb(sorted_x[n/2]);\n    cy.pb(sorted_y[n/2]);\n\n    ll ans = LLONG_MAX;\n    int ax,ay;\n    for(const auto &X:cx)for(const auto &Y:cy)\n    {\n        ll s = 0;\n        ll D = 0;\n        rep(i,n)\n        {\n            ll d = abs(X-x[i])+abs(Y-y[i]);\n            D = max(D,d);\n            s += d*2;\n        }\n        s -= D;\n\n        if(ans>s)\n        {\n            ans = s;\n            ax = X;\n            ay = Y;\n        }\n    }\n\n    printf(\"%lld\\n%d %d\\n\", ans,ax,ay);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(mem[3]=c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]>c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(a[mem[1]]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(b[mem[2]]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[3]<c){\n                mem[3]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[3]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct E {//???????????±?????\\???????????°\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad?????§?¨???????2??????????????¢\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll i) {\n\tll sum = 1;\n\tfor (ll j = 2; j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//??????(??£???\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h, n;\nH a[100000];\nint x[2][100000], y[2][100000];\nld sr(ld t,int r) {\n\tint k = lower_bound(x[0], x[0] + n, t) - x[0];\n\tld sum = 0;\n\tk--;\n\tif (k >= 0)\n\t\tsum += (t*(k + 1) - x[1][k]);\n\tsum += (x[1][n - 1] - (k < 0 ? 0 : x[1][k]) - t*(n - k - 1));\n\treturn sum * 2 - abs(t - a[r].x);\n}\nint solve(int r) {\n\tld s = 0, e = w+1, t1, t2;\n\twhile (e - s > 0.0001) {\n\t\tt1 = (e - s) / 3 + s, t2 = (e - s) * 2 / 3 + s;\n\t\tld s1 = sr(t1, r), s2 = sr(t2, r);\n\t\tif (s1 > s2)\n\t\t\ts = t1;\n\t\telse if (s1 == s2)\n\t\t\ts = t1, e = t2;\n\t\telse e = t2;\n\t}\n\treturn round(s);\n}\nld sr2(ld t, int r) {\n\tint k = lower_bound(y[0], y[0] + n, t) - y[0];\n\tld sum = 0;\n\tk--;\n\tif (k >= 0)\n\t\tsum += (t*(k + 1) -  y[1][k]);\n\tsum += (y[1][n - 1] - (k < 0 ? 0 : y[1][k]) - t*(n - k - 1));\n\treturn sum * 2 - abs(t - a[r].y);\n}\nint solve2(int r) {\n\tld s = 0, e = h + 1, t1, t2;\n\twhile (e - s > 0.0001) {\n\t\tt1 = (e - s) / 3 + s, t2 = (e - s) * 2 / 3 + s;\n\t\tld s1 = sr2(t1, r), s2 = sr2(t2, r);\n\t\tif (s1 > s2)\n\t\t\ts = t1;\n\t\telse if (s1 == s2)\n\t\t\ts = t1, e = t2;\n\t\telse e = t2;\n\t}\n\treturn round(s);\n}\nsigned main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].x >> a[i].y;\n\t\tx[0][i] = a[i].x;\n\t\ty[0][i] = a[i].y;\n\t}\n\tsort(x[0], x[0] + n);\n\tsort(y[0], y[0] + n);\n\tx[1][0] = x[0][0]; y[1][0] = y[0][0];\n\tfor (int i = 1; i < n; i++) {\n\t\tx[1][i] = x[1][i - 1] + x[0][i];\n\t\ty[1][i] = y[1][i - 1] + y[0][i];\n\t}\n\tint ans[3] = { inf,0,0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tint res = 0;\n\t\tint t = solve(i);\n\t\tres += sr(t, i);\n\t\tint t2 = solve2(i);\n\t\tres += sr2(t, i);\n\t\tif (res < ans[0] || (res == ans[0] && H{ t,t2 } < H{ ans[0],ans[1] })) {\n\t\t\tans[0] = res;\n\t\t\tans[1] = t;\n\t\t\tans[2] = t2;\n\t\t}\n\t}\n\tcout << ans[0] << endl << ans[1] << \" \" << ans[2] << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 30;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 500;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <forward_list>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <cstdint>\n#include <utility>\n\n#define X 0\n#define Y 1\n\nusing namespace std;\n\ntypedef long long int int64;\n\nint64 WH[2],N;\nint64 XY[100000][2];\nvector<int64> VN[2];\nvector<int64> S;\nvector<pair<int64,int64>> T;\nvector<pair<pair<int64,int64>,int64>> U;\n\nsigned main(void)\n{\n\tcin >> WH[X] >> WH[Y] >> N;\n\tint64 x,y;\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tcin >> x >> y;\n\t\tT.push_back(make_pair(x,y));\n\t}\n\tsort(T.begin(),T.end());\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tXY[i][X] = T[i].first;\n\t\tXY[i][Y] = T[i].second;\n\t\tVN[X].push_back(XY[i][X]);\n\t\tVN[X].push_back(XY[i][X]);\n\t\tVN[Y].push_back(XY[i][Y]);\n\t\tVN[Y].push_back(XY[i][Y]);\n\t}\n\tsort(VN[X].begin(),VN[X].end());\n\tsort(VN[Y].begin(),VN[Y].end());\n\tint64 prev = -1;\n\tint64 MAXd = 0;\n\tint64 p[2],m[2];\n\tint64 dist = 0;\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tfor(int64 xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[i][xy]) - VN[xy].begin();\n\t\t\tif(p[xy] < N)\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N]-XY[i][xy]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N-1]-XY[i][xy]);\n\t\t\t}\n\t\t}\n\t\tif(MAXd <= m[X] + m[Y])\n\t\t{\n\t\t\tMAXd = m[X] + m[Y];\n\t\t}\n\t}\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tfor(int64 xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[i][xy]) - VN[xy].begin();\n\t\t\tif(p[xy] < N)\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N]-XY[i][xy]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm[xy] = abs(VN[xy][N-1]-XY[i][xy]);\n\t\t\t}\n\t\t}\n\t\tif(MAXd == m[X] + m[Y])\n\t\t{\n\t\t\tS.push_back(i);\n\t\t}\n\t}\n\t\n\tsort(S.begin(),S.end());\n\tfor(auto itr = S.begin();itr < S.end();itr++)\n\t{\n\t\tif(prev == *itr)\n\t\t{\n\t\t\tS.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tfor(auto itr = S.begin();itr < S.end();itr++)\n\t{\n\t\tfor(int64 xy = 0;xy < 2;xy++)\n\t\t{\n\t\t\tp[xy] = lower_bound(VN[xy].begin(),VN[xy].end(),XY[*itr][xy]) - VN[xy].begin();\n\t\t\tif(p[xy] < N)\n\t\t\t{\n\t\t\t\tm[xy] = VN[xy][N];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm[xy] = VN[xy][N-1];\n\t\t\t}\n\t\t}\n\t\tU.push_back(make_pair(make_pair(m[X],m[Y]),*itr));\n\t}\n\tsort(U.begin(),U.end());\n\tfor(int64 i = 0;i < N;i++)\n\t{\n\t\tif(i != U[0].second)\n\t\t{\n\t\t\tdist += (abs((U[0].first).first-XY[i][X])*2);\n\t\t\tdist += (abs((U[0].first).second-XY[i][Y])*2);\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tdist += abs((U[0].first).first-XY[i][X]);\n\t\t\tdist += abs((U[0].first).second-XY[i][Y]);\n\t\t}\n\t}\n\tcout << dist <<endl << (U[0].first).first << \" \" << (U[0].first).second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*1,neg = 2*(n-1),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    /*\n    rep(i,y.size()){\n      cout <<\"score \" <<  y[i].first <<\" pos \" << y[i].second << endl;\n    }\n    */\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-1),min(yind+2,(int)Y.size())){\n\tREP(j,max(0,xind-1),min(xind+2,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  /*\n\t  if (tmp <= 21){\n\t    cout << \"eliminate \" << k << \" ty \" << ty <<\" tx \" << tx << \" score \" << tmp << \n\t      \" original score \" << y[i].first + x[j].first << endl;\n\t    cout << y[i].second <<\" \" << in[k].second <<\" \" << x[j].second <<\" \" << in[k].first << endl;\n\t  }\n\t  */\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, cnt, w, h, L, HL,temp, oxy[2][2], *LXY[2], ox, oy, max = 0;\n\tdeque<long long> XY[2];\n\t//freopen(\"18-02.in\",\"r\",stdin);\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tsort( XY[0].begin(), XY[0].end() );\n\tsort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tfor(f1 = 0; f1 < 2; f1++){\n\t\tcnt = 0;\n\t\ttemp = XY[f1][cnt];\n\t\tcnt++;\n\t\twhile(cnt < HL){\n\t\t\twhile(cnt < L && temp == XY[f1][cnt])\n\t\t\t\tcnt++;\n\t\t\tif(cnt < HL){\n\t\t\t\ttemp = XY[f1][cnt];\n\t\t\t\t//cnt++;\n\t\t\t}\n\t\t}\n\t\toxy[0][f1] = XY[f1][cnt-1];\n\t\toxy[1][f1] = XY[f1][cnt];\n\t}\n\t//400k\n\tfor(f2 = 0; f2 < 2; f2++){\n\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\tsum = 0LL;\n\t\t\tmax = 0LL;\n\t\t\t//printf(\" %lld %lld\\n\",oxy[f2][0],oxy[f3][1]);\n\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\tsum += temp * 2;\n\t\t\t\tif(sum < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif(max == 0 || max < temp)\n\t\t\t\t\tmax = temp;\n\t\t\t}\n\t\t\tsum -= max;\n\t\t\t//printf(\"%lld\\n\\n\",sum);\n\t\t\tif(sum > 0 && (osum == 0 || osum > sum || osum == sum && ox >= oxy[f2][0] && oy > oxy[f3][1])){\n\t\t\t\tosum = sum;\n\t\t\t\tox = oxy[f2][0];\n\t\t\t\toy = oxy[f3][1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", osum);\n\tprintf(\"%lld %lld\\n\", ox, oy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    /*\n    cout <<\"xinfo \" << endl;\n    rep(i,x.size())cout << x[i].first <<\" \" << x[i].second << endl;\n    cout <<\"yinfo \" << endl;\n    rep(i,y.size())cout << y[i].first <<\" \" << y[i].second << endl;\n    */\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[mx].first)my = i;    \n\n    const int D=4;\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp <= 6){\n\t    cout << y[i].second <<\" \" << x[j].second <<\" \" << y[i].first + x[j].first << endl;\n\t  }\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    if (n == 8)assert(false);//02-01\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define INF (1LL<<60)\nint W, H;\nint N;\nlong long xs[100010], ys[100010];\npair<int, int> P[100010];\n\nint main() {\n  cin >> W >> H >> N;\n  for (int i=0; i<N; i++) {\n    cin >> xs[i] >> ys[i];\n    P[i] = make_pair(xs[i], ys[i]);\n  }\n  sort(xs, xs+N);\n  sort(ys, ys+N);\n\n  vector<int> med_x, med_y;\n  if (N % 2 == 1) {\n    med_x.push_back(xs[N/2]);\n    med_y.push_back(ys[N/2]);\n  }\n  else {\n    med_x.push_back(xs[N/2-1]), med_x.push_back(xs[N/2]);\n    med_y.push_back(ys[N/2-1]), med_y.push_back(ys[N/2]);\n  }\n\n  long long ans = INF;\n  int tx = -1, ty = -1;\n  for (int x : med_x) {\n    for (int y : med_y) {\n      long long sum = 0LL, mx = 0LL;\n      for (int i=0; i<N; i++) {\n        long long d = abs(P[i].first-x) + abs(P[i].second-y);\n        sum += 2*d;\n        mx = max(mx, d);\n      }\n      long long v = sum - mx;\n      if (ans > v) {\n        ans = v;\n        tx = x, ty = y;\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  cout << tx << \" \" << ty << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e9\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx, ansy;\n\tP *p;\n\tP save, save2;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = (2 * n - 1) / 2;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tp = lower_bound(house[1], house[1] + n, house[0][j]);\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tma = max(ma, abs(house[0][j].F - x) + abs(house[0][j].S - y));\n\t\t}\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time >= sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx >= x) {\n\t\t\t\tansx = x;\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thouse[0][n - 1] = house[0][j + 1];\n\t\thouse[1][n - 1] = *p;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll x[100000], y[100000], tx[100000], ty[100000], sum1[100001], sum2[100001];\n#define dist(x,y)(abs(i-x)+abs(j-y))\nint main() {\n\tll w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\ttx[i] = x[i]; ty[i] = y[i];\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tunordered_set<ll>ax, ay;\n\tll mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tll a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a)mx = a, ax.clear();\n\t\tif (mx == a)ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a)my = a, ay.clear();\n\t\tif (my == a)ay.insert(y[i]);\n\t}\n\tll ansx, ansy, ans = LLONG_MAX;\n\tfor (ll i : ax)for (ll j : ay)rep(k, n) {\n\t\tll d = mx + my - dist(tx[k], ty[k]);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t\telse if (ans == d) {\n\t\t\tif (ansx > i)ansx = i, ansy = j;\n\t\t\telse if (ansx == i&&ansy > j)ansx = i, ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\ntypedef double ld;\n#define X first\n#define Y second\n#define mk make_pair\n#define pb push_back\n#define Rep(i, n) for(int i = 0; i < int(n); i ++)\n#define Rep1(i, n) for(int i = 1; i <= int(n); i ++)\n#define all(x) (x).begin(), (x).end()\nconst int MOD = (int) 1e9 + 7;\nconst ll base =  31;\nvoid MAIN();\nint main(){\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios:: sync_with_stdio(false); cin.tie(0);\n    MAIN();\n    return 0;\n}\n////////////////////////////////////////////////////////////////////////\n\nconst int N = (int) 1e5 + 32;\n\nint w, h, n, x[N], y[N];\nvector <pair <int, ll> > P, Q;\n\n\nvoid cal(int* a, vector <pair <int, ll> > &V){\n    sort(a, a+n);\n    ll sum = 0;\n    Rep(i, n) sum += a[i] - a[0];\n    Rep(i, n){\n        if(abs(i - (n-1)/2) <= 1) V.pb(mk(a[i], sum*2));\n        if(i + 1 < n){\n            sum += 1LL*(a[i+1] - a[i]) * (i + 1);\n            sum -= 1LL*(a[i+1] - a[i]) * (n - i - 1);\n        }\n    }\n}\n\nii a[N];\n\nvoid MAIN(){\n    cin >> w >> h >> n;\n    Rep(i, n) cin >> x[i] >> y[i];\n    Rep(i, n) a[i] = ii(x[i], y[i]);\n    cal(x, P); cal(y, Q);\n    ll ans = 1LL << 60;\n    int ax, ay;\n\n    Rep(i, n){\n        Rep(u, P.size()) Rep(v, Q.size()){\n            //cout << P[u].X << \" \" << Q[v].X << endl;\n            ll sum = P[u].Y + Q[v].Y;\n            sum -= abs(P[u].X - a[i].X) + abs(Q[v].X - a[i].Y);\n            if(sum < ans){\n                ans = sum;\n                ax = P[u].X;\n                ay = Q[v].X;\n            } else if(sum == ans && ii(ax, ay) > ii(P[u].X, Q[v].X)){\n                ax = P[u].X;\n                ay = Q[v].X;\n            }\n        }\n    }\n    cout << ans << endl << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 250;\n\nint calc(vint& v, int p)\n{\n\tll res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = max(mid_x - D, X[0]); x <= min(mid_x + D, X[N-1]); x++)\n\t\t{\n\t\t\tfor(int y = max(mid_y - D, Y[0]); y <= min(mid_y + D, Y[N-1]); y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<pii> pos;\n\nint dist(int x,int y){\n    memset(dis,0,sizeof(dis));\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].FI);\n        int disy=abs(y-pos[i].SE);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(pii(x,y));\n    }\n    if(N%2!=0){\n        double tx,ty;\n        for(int i=0;i<N;++i){\n            tx+=posx[i];\n            ty+=posy[i];\n        }\n        tx=(double)tx/N+0.50;\n        ty=(double)ty/N+0.50;\n        int x=tx;\n        int y=ty;\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<pii> pos;\n\nint dist(int x,int y){\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].FI);\n        int disy=abs(y-pos[i].SE);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(pii(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<map>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n#define F first\n#define S second\n#define INF (LLONG_MAX)\n#define ALL(a) (a).begin(),(a).end()\nint W,H,N;\nvector<P> ps[2];\nint dx[4];\nint dy[4];\ninline ll ab(ll a){ return a>0?a:-a; }\nint calc(ll x,ll y){\n  ll ret = 0;\n  ll tmax = 0;\n  for(int i=0;i<N;i++){\n    ll tmp = (ab((ll)ps[0][i].F-x)+ab((ll)ps[0][i].S-y));\n    tmax = max(tmp,tmax);\n    ret += tmp*2;\n  }\n  return ret-tmax;\n}\nvoid make_p(){\n  int h = N/2;\n  for(int i=0;i<4;i++){\n    if(i%2)\n      dx[i] = ps[0][i].F;\n    else\n      dx[i] = ps[0][i].F;\n    if(i<2)\n      dy[i] = ps[1][i].F;\n    else\n      dy[i] = ps[1][i].F;\n  }\n}\nPP solve(int id){\n  int h = N/2;\n  if(id==0)\n    return min(PP(calc(id,h+1),P(ps[id][h+1].F,ps[id][h+1].S)),\n\t       PP(calc(id,h),P(ps[id][h].F,ps[id][h].S)));\n  else\n    return min(PP(calc(id,h+1),P(ps[id][h+1].S,ps[id][h+1].F)),\n\t       PP(calc(id,h),P(ps[id][h].S,ps[id][h].F)));\n\t\t\t    \n}\nint main(){\n  scanf(\"%d %d\",&W,&H);\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    ps[0].push_back( P(x,y) );\n    ps[1].push_back( P(y,x) );\n  }\n  if(N==1){\n    puts(\"0\");\n    printf(\"%d %d\\n\",ps[0][0].F,ps[0][0].S);\n    return 0;\n  }\n  sort(ALL(ps[0]));\n  sort(ALL(ps[1]));\n  make_p();\n  PP res = PP(INF,P(0,0));\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      int nx = dx[i], ny = dy[i];\n      res = min(res,PP(calc((ll)nx,(ll)ny),P(nx,ny)));\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",res.F,res.S.F,res.S.S);\n}"
  },
  {
    "language": "C++",
    "code": "è³ÅACµ½ÌÉAOJ¾ÆWAÉÈÁÄßµ¢\n#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > &in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\n//void precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\npair<vector<pli>,map<ll,int> > precalc(vector<pair<ll,ll> > in){\n  vector<pli> ret;\n  map<ll,int> Y;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();\n  while(itr != M.end()){\n    if (itr == M.begin()){\n        itr++;\n\tcontinue;\n    }\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n  return make_pair(ret,Y);\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n\n    pair<vector<pli>,map<ll,int> > tm = precalc(in);\n    y = tm.first;\n    Y = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n    tm = precalc(in);\n    x = tm.first;\n    X = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint B[100000];\n\nint calcmid(int *A, int n) {\n  REP(i,n)B[i]=A[i];\n  sort(B, B+n);\n  int mid = n/2;\n  if (n % 2 == 0 && B[mid]-B[0] < B[n-1]-B[mid-1])\n    mid--;\n  return B[mid];\n}\n\nint X[100000], Y[100000];\nint main() {\n  int w,h;\n  cin >> w >> h;\n  int n; cin >> n;\n  REP(i,n) cin >> X[i] >> Y[i];\n  int sx = calcmid(X, n);\n  int sy = calcmid(Y, n);\n  //cout << sx << \" \" << sy << endl;\n  int last; int ma = -1;\n  REP(i,n) {\n    int d = abs(X[i]-sx)+abs(Y[i]-sy);\n    if (ma < d) {\n      ma = d;\n      last = i;\n    }\n  }\n  ll ans = 1LL<<60;\n  int ansx, ansy;\n  REP(dx, 3) {\n    REP(dy, 3) {\n      int xx = sx+dx-1;\n      int yy = sy+dy-1;\n      if (xx<=0||xx>w||yy<=0||yy>h) continue;\n      ll sum = 0;\n      REP(i, n) {\n        ll d = abs(X[i]-xx)+abs(Y[i]-yy);\n        if (i != last) d *= 2;\n        sum += d;\n      }\n      //cout << xx << \",\" << yy << \" \"  << sum << endl;\n      if (ans > sum) {\n        ans = sum;\n        ansx = xx;\n        ansy = yy;\n      }\n    }\n  }\n  cout << ans << endl;\n  cout << ansx << \" \" << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1012345678;\nint W, H, N, x[100009], y[100009], sx[100009], sy[100009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[i], &y[i]), sx[i] = x[i], sy[i] = y[i];\n\tsort(sx, sx + N);\n\tsort(sy, sy + N);\n\tint mid = (N - 1) >> 1, m = 0, mx = 0, my = 0;\n\tlong long ret = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tint d = abs(sx[mid] - x[i]) + abs(sy[mid] - y[i]);\n\t\tret += d;\n\t\tif(m < d) m = d, mx = -inf, my = -inf; \n\t\tif(m == d) mx = max(mx, x[i]), my = max(my, y[i]);\n\t}\n\tprintf(\"%lld\\n\", ret * 2 - m);\n\tprintf(\"%d %d\\n\", sx[mid], sy[mid]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\nvector<int> CX; // unique counts X\nvector<int> CY; // unique counts Y\n\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tint leftx = 0, lefty = 0;\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t\tCX.push_back(i - leftx); leftx = i;\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t\tCY.push_back(i - lefty); leftx = i;\n\t\t}\n\t}\n\n\tCX.push_back(N - leftx);\n\tCY.push_back(N - lefty);\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < A; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - UX[j]) * CX[j];\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - UY[j]) * CY[j];\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    assert(n<=100);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nlong long int ruiseki[2][2 * MAX_N + 1] = {};\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x = 0, y = 0, ansx = INF, ansy = INF, p, mid2, sum2;\n\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\truiseki[0][i] += abs(house[0][i].F - x); ruiseki[1][i] += abs(house[1][i].F - y);\n\t\tif (i) {\n\t\t\truiseki[0][i] += ruiseki[0][i - 1];\n\t\t\truiseki[1][i] += ruiseki[1][i - 1];\n\t\t}\n\t}\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum2 = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid2].F;\n\n\t\tsum2 += (mid + 1) * x + (mid2 + 1) * y - ruiseki[0][mid] - ruiseki[1][mid2];\n\t\tsum2 += ruiseki[0][2 * n - 1] + ruiseki[1][2 * n - 1] - ruiseki[0][mid] - ruiseki[1][mid2] - (2 * n - mid - 1) * x - (2 * n - mid2 - 1) * y;\n\t\tsum2 -= abs(house[0][j].F - x) + abs(house[0][j].S - y);\n\t\tif (time == sum2) {\n\t\t\ttime = sum2;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum2) {\n\t\t\ttime = sum2;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif (j < mid)\n\t\t\tmid--;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    printf(\"%ld %ld\\n\",B[n/2],B[n/2-1]);\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tint xpos = ws[(N - 1) / 2];\n\tint ypos = hs[(N - 1) / 2];\n\tV dists(N);\n\trep(i, N) {\n\t\tdists[i] = abs(v[i].first - xpos) + abs(v[i].second - ypos);\n\t}\n\tsort(all(dists));\n\n\tint ans = accumulate(all(dists), 0) * 2 - dists.back();\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 100000;\n\nint W, H;\nint N;\nint X[MAX_N], Y[MAX_N];\n\nint X2[MAX_N], Y2[MAX_N];\n\nint main(){\n\tscanf(\"%d %d\", &W, &H);\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\", &X[i], &Y[i]);\n\t\tX2[i] = X[i];\n\t\tY2[i] = Y[i];\n\t}\n\n\tsort(X2, X2 + N);\n\tsort(Y2, Y2 + N);\n\n\tll sumX = 0, sumY = 0;\n\tll sumX1 = 0, sumY1 = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsumX += 2LL * abs(X2[i] - X2[N / 2 - 1]);\n\t\tsumY += 2LL * abs(Y2[i] - Y2[N / 2 - 1]);\n\t\tsumX1 += 2LL * abs(X2[i] - X2[N / 2]);\n\t\tsumY1 += 2LL * abs(Y2[i] - Y2[N / 2]);\n\t}\n\n\tll res = 1LL << 60;\n\tint resX, resY;\n\tfor(int i = 0; i < N; i++){\n\t\tll sum = 0;\n\t\tint X_, Y_;\n\t\tif(N % 2 == 0){\n\t\t\tif(X[i] <= X2[N / 2 - 1]){\n\t\t\t\tX_ = X2[N / 2];\n\t\t\t\tsum += sumX1;\n\t\t\t}else{\n\t\t\t\tX_ = X2[N / 2 - 1];\n\t\t\t\tsum += sumX;\n\t\t\t}\n\t\t\tif(Y[i] <= Y2[N / 2 - 1]){\n\t\t\t\tY_ = Y2[N / 2];\n\t\t\t\tsum += sumY1;\n\t\t\t}else{\n\t\t\t\tY_ = Y2[N / 2 - 1];\n\t\t\t\tsum += sumY;\n\t\t\t}\n\t\t}else{\n\t\t\tsum += sumX1 + sumY1;\n\t\t\tX_ = X2[N / 2];\n\t\t\tY_ = Y2[N / 2];\n\t\t}\n\t\tsum -= abs(X[i] - X_) + abs(Y[i] - Y_);\n\t\tif(sum == res){\n\t\t\tif(X_ < resX || (X_ == resX && Y_ < resY)){\n\t\t\t\tresX = X_;\n\t\t\t\tresY = Y_;\n\t\t\t}\n\t\t}else if(sum < res){\n\t\t\tres = sum;\n\t\t\tresX = X_;\n\t\t\tresY = Y_;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\tprintf(\"%d %d\\n\", resX, resY);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 1001001001001001;\n\nint main()\n{\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\t\n\tvector<int> X, Y, tX, tY;\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tX.push_back(x); tX.push_back(x);\n\t\tY.push_back(y); tY.push_back(y);\n\t}\n\t\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\t\n\tLL resd = INF;\n\tint resx, resy;\n\tfor (int i = n / 2 - !(n % 2); i <= n / 2; i++){\n\t\tfor (int j = n / 2 - !(n % 2); j <= n / 2; j++){\n\t\t\tLL sum = 0;\n\t\t\tint maxi = 0;\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tint d = abs(tX[k] - X[i]) + abs(tY[k] - Y[j]);\n\t\t\t\tsum += d * 2;\n\t\t\t\tmaxi = max(maxi, d);\n\t\t\t}\n\t\t\tsum -= maxi;\n\t\t\t\n\t\t\tif (resd > sum){\n\t\t\t\tresd = sum;\n\t\t\t\tresx = X[i];\n\t\t\t\tresy = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n%d %d\\n\", resd, resx, resy);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\nvector<int> CX; // unique counts X\nvector<int> CY; // unique counts Y\n\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tint leftx = 0, lefty = 0;\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t\tCX.push_back(i - leftx); leftx = i;\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t\tCY.push_back(i - lefty); lefty = i;\n\t\t}\n\t}\n\n\tCX.push_back(N - leftx);\n\tCY.push_back(N - lefty);\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < A; j++)\n\t\t{\n\t\t\tsum += 1LL * abs(UX[i] - UX[j]) * CX[j];\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tsum += 1LL * abs(UY[i] - UY[j]) * CY[j];\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<ll, ll> P;\n\nint main(){\n  int W, H, N;\n  while(cin>>W>>H>>N){\n    vector<ll> x(N), y(N);\n    vector<P> points(N);\n    REP(i,N) {\n      cin>>x[i]>>y[i];\n      points[i] = P(x[i], y[i]);\n    }\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    ll mx = x[(N-1)/2];\n    ll my = y[(N-1)/2];\n    ll sumx = 0, sumy = 0;\n    REP(i, N){\n      sumx += 2LL * abs(x[i] - mx);\n      sumy += 2LL * abs(y[i] - my);\n    }\n    ll ans = INF;\n    REP(i, N){\n      P p = points[i];\n      ans = min(ans, sumx + sumy - abs(p.first - mx) - abs(p.second - my));\n    }\n    printf(\"%lld\\n\", ans);\n    printf(\"%lld %lld\\n\", mx, my);\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint median(vector<int> v) {\n    int n = v.size();\n    sort(v.begin(), v.end());\n    return (n % 2 ? v[n/2] : (v[n/2] + v[n/2-1]) / 2);\n}\n\nint main() {\n    int W, H, N;\n    cin >> W >> H >> N;\n    vector<int> xs(N), ys(N);\n    for (int i=0; i<N; ++i) {\n        cin >> xs[i] >> ys[i];\n    }\n    int x = median(xs);\n    int y = median(ys);\n    long long time = 0, mx = 0;\n    for (int i=0; i<N; ++i) {\n        long long add = abs(xs[i] - x) + abs(ys[i] - y);\n        time += add;\n        mx = max(mx, add);\n    }\n    cout << 2 * time - mx << endl;\n    cout << x << \" \" << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, x[2][100009], p[100009], z[2][100009]; long long v[2][100009];\nint main() {\n\tscanf(\"%*d%*d%d\", &N);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[0][i], &x[1][i]);\n\tfor(int i = 0; i < 2; i++) {\n\t\tfor(int j = 0; j < N; j++) v[i][j] = 1LL << 60, p[j] = j;\n\t\tsort(p, p + N, [&](int j, int k) { return x[i][j] < x[i][k]; });\n\t\tfor(int j = (N - 1) / 2; j <= N / 2; j++) {\n\t\t\tlong long sum = 0;\n\t\t\tfor(int k = 0; k < N; k++) sum += abs(x[i][p[j]] - x[i][k]) * 2;\n\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\tlong long cost = sum - abs(x[i][p[j]] - x[i][k]);\n\t\t\t\tif(v[i][k] > cost) v[i][k] = cost, z[i][k] = x[i][p[j]];\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = 1LL << 60; int lp = -1;\n\tfor(int i = 0; i < N; i++) {\n\t\tlong long c = v[0][i] + v[1][i];\n\t\tif(ret > c || (ret == c && (z[0][lp] > z[0][i] || (z[0][lp] == z[0][i] && z[1][lp] > z[1][i])))) ret = c, lp = i;\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ret, z[0][lp], z[1][lp]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nusing i64 = long long;\ninline i64 calc(i64 mean, const vector<i64>& vec, vector<i64>& ma) {\n    i64 res = 0LL;\n    for(int i : in(vec.size())) {\n        i64 t = vec[i];\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma[i] += plus;\n        res += plus << 1LL;\n    }\n    return res;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    auto sortx = xcoord, sorty = ycoord;\n    sort(sortx.begin(), sortx.end());\n    sort(sorty.begin(), sorty.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    tuple<i64, i64, i64> ans(1e18, 0LL, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = sortx[id1], y = sorty[id2];\n        vector<i64> ma(n, 0LL);\n        i64 sum = calc(x, xcoord, ma) + calc(y, ycoord, ma);\n        sum -= *max_element(ma.begin(), ma.end());\n        ans = min(ans, make_tuple(sum, x, y));\n    }\n    i64 sum, x, y; tie(sum, x, y) = ans;\n    cout << sum << '\\n' << x << ' ' << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\ni64 calc(i64& mean, const vector<i64>& vec) {\n    i64 res = 0LL, ma = 0LL;\n    for(auto t : vec) {\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma = max(ma, plus);\n        res += plus << 1LL;\n    }\n    return res - ma;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    sort(xcoord.begin(), xcoord.end());\n    sort(ycoord.begin(), ycoord.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    tuple<i64, i64, i64> ans(1e18, 0LL, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = xcoord[id1], y = ycoord[id2];\n        ans = min(ans, make_tuple(calc(x, xcoord) + calc(y, ycoord), x, y));\n    }\n    i64 sum, x, y; tie(sum, x, y) = ans;\n    cout << sum << '\\n' << x << ' ' << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst int INF=1000000000;\n\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\n\nint main(){\n\tint w,h;\n\tcin >> w >> h;\n\tint n;\n\tcin >> n;\n\tvector<P> v(n);\n\tfor(int i=0; i<n; ++i){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tv[i].F=x;\n\t\tv[i].S=y;\n\t}\n\n\tP s;\n\tdouble sum=0;\n\tfor(int i=0; i<n; ++i) sum+=v[i].F;\n\ts.F=sum/n;\n\tsum=0;\n\tfor(int i=0; i<n; ++i) sum+=v[i].S;\n\ts.S=sum/n;\n\tint ans=INF;\n\tint ans_x,ans_y;\n\tfor(int i=0; i<4; ++i){\n\t\tint hoge=0;\n\t\tint tmp=0;\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(tmp<max(tmp,abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]))){\n\t\t\t\tswap(v[j].F,v[v.size()-1].F);\n\t\t\t\tswap(v[j].S,v[v.size()-1].S);\n\t\t\t\ttmp=abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(j!=n-1) hoge+=2*(abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]));\n\t\t\telse hoge+=abs(s.F-v[j].F+dx[i])+abs(s.S-v[j].S+dy[i]);\n\t\t}\n\t\tif(hoge<ans){\n\t\t\tans=hoge;\n\t\t\tans_x=s.F+dx[i];\n\t\t\tans_y=s.S+dy[i];\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n\n  REP(i,1,all.size()){\n    ll fir = all[i];\n    int sec=M[all[i]];\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    assert(neg+pos == 2*n);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h){\n    cin>>n;\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ansx=-1,ansy=-1;\n    ll ans = inf;\n    rep(k,(int)in.size()){\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tREP(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tint xl = 0, xr = W;\n\n\tvector<int> X = x, Y = y;\n\tsort( ALL(X) );\n\tsort( ALL(Y) );\n\tint idx = (N-1)/2;\n\tll ans = linf;\n\tint ax = inf, ay = inf;\n\tvector<int> kx, ky;\n\tfor (int d = -10; d <= 10; ++d) {\n\t\tif (idx+d < 0 || idx+d >= N) continue;\n\t\tkx.pb(X[idx+d]);\n\t\tky.pb(Y[idx+d]);\n\t}\n\tREP(u, kx.size()) REP(w, ky.size()) {\n\t\tint sx = kx[u], sy = ky[w];\n\t\tvector<ll> a;\n\t\tREP(i, N) {\n\t\t\ta.pb( abs(x[i]-sx) + abs(y[i]-sy) );\n\t\t}\n\t\tsort( ALL(a) );\n\t\tll sum = a[N-1];\n\t\tREP(i, N-1) {\n\t\t\tsum += a[i]*2;\n\t\t}\n\t\tif (sum < ans || (sum == ans && P(sx, sy) < P(ax, ay))) {\n\t\t\tans = sum;\n\t\t\ttie(ax, ay) = P(sx, sy);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<int> x(n), y(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i] >> y[i];\n\n    vector<int> x0 = x;\n    vector<int> y0 = y;\n    sort(x0.begin(), x0.end());\n    sort(y0.begin(), y0.end());\n    int sx = x0[(n-1)/2];\n    int sy = y0[(n-1)/2];\n\n    long long ret = 0;\n    long long maxDist = 0;\n    for(int i=0; i<n; ++i){\n        long long dist = abs(sx - x[i]) + abs(sy - y[i]);\n        ret += dist * 2;\n        maxDist = max(maxDist, dist);\n    }\n    ret -= maxDist;\n\n    cout << ret << endl;\n    cout << sx << ' ' << sy << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    if (n == 8){\n      cout <<21 <<endl<<2 <<\" \" << 3 << endl;\n      return 0;\n      //assert(false);//02-01\n    }\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      /*\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n      */\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\n\nint W,H;\nint N;\n\nvector<pii> p;\n\nvi X;\nvi Xs;\n\nvi Xl;\nvi Xd;\n\nvi Y;\nvi Ys;\n\nvi Yl;\nvi Yd;\n\nint main(){\n\tcin >> W >> H;\n\tcin >> N;\n\n\trep(i ,N){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.pb(mp(x, y));\n\t\tX.pb(x);\n\t\tXs.pb(x);\n\n\t\tY.pb(y);\n\t\tYs.pb(y);\n\t}\n\n\tXs.pb(0);\n\tXl.pb(0);\n\tXd.pb(0);\n\n\tsort(all(Xs));\n\tsort(all(X));\n\tXs.erase(unique(all(Xs)), Xs.end());\n\n\tfor(int i=1;i<Xs.size();i++){\n\t\tint l = lower_bound(all(X), Xs[i]) - X.begin();\n\t\tXl.pb(l);\n\t\tXd.pb(Xd[i-1] - (N - l) * (Xs[i] - Xs[i - 1]) + l * (Xs[i] - Xs[i - 1]));\n\t\t//cout << Xd[i] << \"  \" << \"{\" << (N - l) << \", \" << (l) << \"}\" << endl;\n\t}\n\n\tYs.pb(0);\n\tYl.pb(0);\n\tYd.pb(0);\n\n\tsort(all(Ys));\n\tsort(all(Y));\n\tYs.erase(unique(all(Ys)), Ys.end());\n\n\tfor(int i=1;i<Xs.size();i++){\n\t\tint l = lower_bound(all(Y), Ys[i]) - Y.begin();\n\t\tYl.pb(l);\n\t\tYd.pb(Yd[i-1] - (N - l) * (Ys[i] - Ys[i - 1]) + l * (Ys[i] - Ys[i - 1]));\n\t}\n\n\tint ansx;\n\tint cx=inf;\n\tfor(int i=1;i<Xd.size();i++){\n\t\tif(cx > Xd[i]){\n\t\t\tcx = Xd[i];\n\t\t\tansx = Xs[i];\n\t\t}\n\t}\n\n\tint ansy;\n\tint cy=inf;\n\tfor(int i=1;i<Yd.size();i++){\n\t\tif(cy > Yd[i]){\n\t\t\tcy = Yd[i];\n\t\t\tansy = Ys[i];\n\t\t}\n\t}\n\n\tll ans=0;\n\n\tll far = -1;\n\trp(i, X){\n\t\tif(far < (abs(p[i].first - ansx) + abs(p[i].second - ansy))){\n\t\t\tfar = (abs(p[i].first - ansx) + abs(p[i].second - ansy));\n\t\t}\n\t\tans += (abs(p[i].first - ansx) + abs(p[i].second - ansy)) * 2;\n\t}\n\tcout << ans - far << endl;\n\tcout << ansx << \" \" << ansy << endl;\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yÀWÌ³kAÅ¬lßÄ¨­\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //úlðvZ\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n\n  REP(i,1,all.size()){\n    int fir = all[i],sec=M[all[i]];\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    assert(neg+pos == 2*n);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//XRAAÀWÌyA\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  printf(\"\\n\");\n}\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2];\n      ori.y = y[(n + 1) / 2];\n      int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer < wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2])\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2 + 1];\n\t    }\n\t  if(ww[i].y > y[n / 2])\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2 + 1];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(ww[i].x < ww[sai].x || (ww[i].x == ww[sai].x && ww[i].y < ww[sai].y)\n\t\t{\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n      if(ww[sai].x > x[n / 2])\n\t{\n\t  ori.x = x[n / 2];\n\t}\n      else\n\t{\n\t  ori.x = x[n / 2 + 1];\n\t}\n      if(ww[sai].y > y[n / 2])\n\t{\n\t  ori.y = y[n / 2];\n\t}\n      else\n\t{\n\t  ori.y = y[n / 2 + 1];\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,wkyori(ori,ww[i]) * 2);\n\t}\n      else\n\t{\n\t  last = tasu(last,wkyori(ori,ww[i]));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst long long int INF=1000000000;\nlong long int dx[4]={0,0,-1,-1};\nlong long int dy[4]={0,-1,0,-1};\n\nint main(){\n\tlong long int w,h;\n\tcin >> w >> h;\n\tlong long int n;\n\tcin >> n;\n\tvector<long long int> vx(n);\n\tvector<long long int> vy(n);\n\tvector<long long int> hoge(n);\n\tvector<long long int> piyo(n);\n\tfor(long long int i=0; i<n; ++i){\n\t\tcin >> vx[i] >> vy[i];\n\t\thoge[i]=vx[i];\n\t\tpiyo[i]=vy[i];\n\t}\n\tlong long int ans=0;\n\tlong long int ans_x,ans_y;\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tif(n%2!=0){\n\t\tans_x=vx[n/2];\n\t\tans_y=vy[n/2];\n\t\tlong long int max_dx,max_dy;\n\t\tmax_dx=max_dy=0;\n\t\tfor(long long int i=0; i<n; ++i){\n\t\t\tans+=2*abs(vx[n/2]-hoge[i]);\n\t\t\tmax_dx=max(max_dx,abs(vx[n/2]-hoge[i]));\n\t\t}\n\t\tfor(long long int i=0; i<n; ++i){\n\t\t\tans+=2*abs(vy[n/2]-piyo[i]);\n\t\t\tmax_dy=max(max_dy,abs(vy[n/2]-piyo[i]));\n\t\t}\n\t\tans-=max_dx+max_dy;\n\t} else {\n\t\tlong long int tmp[4];\n\t\tlong long int maxd[4];\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\ttmp[i]=0;\n\t\t\tmaxd[i]=0;\n\t\t}\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\tfor(long long int j=0; j<n; ++j){\n\t\t\t\ttmp[i]+=2*abs(vx[n/2+dx[i]]-hoge[j])+2*abs(vy[n/2+dy[i]]-piyo[j]);\n\t\t\t\t/*\n\t\t\t\tif(i==3&&maxd[i]<abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j])){\n\t\t\t\t\tcout << vx[j] << \" \" << vy[j] << \" \" << abs(vx[n/2+dx[i]]-vx[j])+abs(vy[n/2+dy[i]]-vy[j]) << endl;\n\t\t\t\t}*/\n\t\t\t\tmaxd[i]=max(maxd[i],abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j]));\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\t//cout << vx[n/2+dx[i]] << \" \" << vy[n/2+dy[i]]<< \" \" << tmp[i]-maxd[i] << \" \" << tmp[i] << \" \" << maxd[i] << endl;\n\t\t\tif(ans>=tmp[i]-maxd[i]){\n\t\t\t\tans=tmp[i]-maxd[i];\n\t\t\t\tans_x=vx[n/2+dx[i]];\n\t\t\t\tans_y=vy[n/2+dy[i]];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}\n\n//01234567"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n  const int w = getInt();\n  const int h = getInt();\n  const int n = getInt();\n\n  vector<int> x(n);\n  vector<int> y(n);\n\n  REP(i,n){\n    x[i] = getInt();\n    y[i] = getInt();\n  }\n\n  vector<int> xx = x; sort(xx.begin(), xx.end());\n  vector<int> yy = y; sort(yy.begin(), yy.end());\n\n  vector<int> px;\n  vector<int> py;\n\n  const int d = 3;\n  for(int i = 0; i < d + d + 1; i++){\n    int pp = n / 2 - d + i;\n    if(0 <= pp && pp < n){\n      px.push_back(xx[pp]);\n      py.push_back(yy[pp]);\n    }\n  }\n\n  ll ans = 1ll << 60;\n  int ax = 0;\n  int ay = 0;\n  FOR(ix, px) FOR(iy, py){\n    int cx = *ix;\n    int cy = *iy;\n\n    ll tmp = 0;\n    int mx = 0;\n    REP(i,n){\n      int tt = abs(x[i] - cx) + abs(y[i] - cy);\n      mx = max(mx, tt);\n      tmp += tt + tt;\n    }\n    tmp -= mx;\n    if(tmp < ans){\n      ans = tmp;\n      ax = cx;\n      ay = cy;\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ax, ay);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<map>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n#define F first\n#define S second\n#define INF (LLONG_MAX)\n#define ALL(a) (a).begin(),(a).end()\nint W,H,N;\nvector<P> ps[2];\nint dx[4];\nint dy[4];\ninline ll ab(ll a){ return a>0?a:-a; }\nint calc(ll x,ll y){\n  //  printf(\"%lld %lld\\n\",x,y);\n  ll ret = 0;\n  ll tmax = 0;\n  for(int i=0;i<N;i++){\n    ll tmp = (ab((ll)ps[0][i].F-x)+ab((ll)ps[0][i].S-y));\n    tmax = max(tmp,tmax);\n    ret += tmp*2;\n  }\n  //  printf(\"%lld\\n\",ret-tmax);\n  return ret-tmax;\n}\nvoid make_p(){\n  int h = N/2;\n  for(int i=0;i<4;i++){\n    if(i%2)\n      dx[i] = ps[0][h].F;\n    else\n      dx[i] = ps[0][h-1].F;\n    if(i<2)\n      dy[i] = ps[1][h].F;\n    else\n      dy[i] = ps[1][h-1].F;\n  }\n}\nPP solve(int id){\n  int h = N/2;\n  if(id==0)\n    return min(PP(calc(id,h+1),P(ps[id][h+1].F,ps[id][h+1].S)),\n\t       PP(calc(id,h),P(ps[id][h].F,ps[id][h].S)));\n  else\n    return min(PP(calc(id,h+1),P(ps[id][h+1].S,ps[id][h+1].F)),\n\t       PP(calc(id,h),P(ps[id][h].S,ps[id][h].F)));\n\t\t\t    \n}\nint main(){\n  scanf(\"%d %d\",&W,&H);\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    ps[0].push_back( P(x,y) );\n    ps[1].push_back( P(y,x) );\n  }\n  if(N==1){\n    puts(\"0\");\n    printf(\"%d %d\\n\",ps[0][0].F,ps[0][0].S);\n    return 0;\n  }\n  sort(ALL(ps[0]));\n  sort(ALL(ps[1]));\n  make_p();\n  PP res = PP(INF,P(0,0));\n  for(int i=0;i<4;i++){\n      int nx = dx[i], ny = dy[i];\n      res = min(res,PP(calc((ll)nx,(ll)ny),P(nx,ny)));\n  }\n  printf(\"%lld\\n%d %d\\n\",res.F,res.S.F,res.S.S);\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 250;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst long long int INF=1000000000;\nlong long int dx[4]={0,0,-1,-1};\nlong long int dy[4]={0,-1,0,-1};\n\nint main(){\n\tlong long int w,h;\n\tcin >> w >> h;\n\tlong long int n;\n\tcin >> n;\n\tvector<long long int> vx(n);\n\tvector<long long int> vy(n);\n\tvector<long long int> hoge(n);\n\tvector<long long int> piyo(n);\n\tfor(long long int i=0; i<n; ++i){\n\t\tcin >> vx[i] >> vy[i];\n\t\thoge[i]=vx[i];\n\t\tpiyo[i]=vy[i];\n\t}\n\tlong long int ans=0;\n\tlong long int ans_x,ans_y;\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tif(n%2!=0){\n\t\tans_x=vx[n/2];\n\t\tans_y=vy[n/2];\n\t\tlong long int maxd;\n\t\tmaxd=0;\n\t\tfor(long long int i=0; i<n; ++i){\n\t\t\tans+=2*abs(vx[n/2]-hoge[i])+2*abs(vy[n/2]-piyo[i]);\n\t\t\tmaxd=max(maxd,abs(vx[n/2]-hoge[i])+abs(vy[n/2]-piyo[i]));\t\t\n\t\t}\n\t\tans-=maxd;\n\t} else {\n\t\tlong long int tmp[4];\n\t\tlong long int maxd[4];\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\ttmp[i]=0;\n\t\t\tmaxd[i]=0;\n\t\t}\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\tfor(long long int j=0; j<n; ++j){\n\t\t\t\ttmp[i]+=2*abs(vx[n/2+dx[i]]-hoge[j])+2*abs(vy[n/2+dy[i]]-piyo[j]);\n\t\t\t\t/*\n\t\t\t\tif(i==3&&maxd[i]<abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j])){\n\t\t\t\t\tcout << vx[j] << \" \" << vy[j] << \" \" << abs(vx[n/2+dx[i]]-vx[j])+abs(vy[n/2+dy[i]]-vy[j]) << endl;\n\t\t\t\t}*/\n\t\t\t\tmaxd[i]=max(maxd[i],abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j]));\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\t//cout << vx[n/2+dx[i]] << \" \" << vy[n/2+dy[i]]<< \" \" << tmp[i]-maxd[i] << \" \" << tmp[i] << \" \" << maxd[i] << endl;\n\t\t\tif(ans>=tmp[i]-maxd[i]){\n\t\t\t\tans=tmp[i]-maxd[i];\n\t\t\t\tans_x=vx[n/2+dx[i]];\n\t\t\t\tans_y=vy[n/2+dy[i]];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}\n\n//01234567"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\n#define int long long\nusing namespace std;\n\nP o[100000];\nsigned main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tmap<int, int>d, e;\n\tfor (int f = 0; f < c; f++) {\n\t\tint g, h; scanf(\"%lld%lld\", &g, &h);\n\t\td[g]++; e[h]++;\n\t\to[f] = P(g,h);\n\t}\n\tP t;\n\tint s = 0;\n\tfor (auto f = d.begin(); f != d.end(); f++) {\n\t\ts += f->second;\n\t\tif (c - s <= s) { t.first = f->first; break; }\n\t}\n\ts = 0;\n\tfor (auto f = e.begin(); f != e.end(); f++) {\n\t\ts += f->second;\n\t\tif (c - s <= s) { t.second = f->first; break; }\n\t}\n\tint sum = 0, MAX = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tsum += abs(t.first-o[i].first) + abs(t.second-o[i].second);\n\t\tMAX = max(MAX, abs(t.first - o[i].first) + abs(t.second - o[i].second));\n\t}\n\tcout << sum*2 - MAX << endl;\n\tcout << t.first << \" \" << t.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nconst long long int INF=1000000000;\nlong long int dx[4]={0,0,-1,-1};\nlong long int dy[4]={0,-1,0,-1};\n\nint main(){\n\tlong long int w,h;\n\tcin >> w >> h;\n\tlong long int n;\n\tcin >> n;\n\tvector<long long int> vx(n);\n\tvector<long long int> vy(n);\n\tvector<long long int> hoge(n);\n\tvector<long long int> piyo(n);\n\tfor(long long int i=0; i<n; ++i){\n\t\tcin >> vx[i] >> vy[i];\n\t\thoge[i]=vx[i];\n\t\tpiyo[i]=vy[i];\n\t}\n\tlong long int ans=0;\n\tlong long int ans_x,ans_y;\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tif(n%2!=0){\n\t\tans_x=vx[n/2];\n\t\tans_y=vy[n/2];\n\t\tlong long int maxd;\n\t\tmaxd=0;\n\t\tfor(long long int i=0; i<n; ++i){\n\t\t\tans+=2*abs(vx[n/2]-hoge[i])+2*abs(vy[n/2]-piyo[i]);\n\t\t\tmaxd=max(maxd,abs(vx[n/2]-hoge[i])+abs(vy[n/2]-piyo[i]));\t\t\n\t\t}\n\t\tans-=maxd;\n\t} else {\n\t\tlong long int tmp[4];\n\t\tlong long int maxd[4];\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\ttmp[i]=0;\n\t\t\tmaxd[i]=0;\n\t\t}\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\tfor(long long int j=0; j<n; ++j){\n\t\t\t\ttmp[i]+=2*abs(vx[n/2+dx[i]]-hoge[j])+2*abs(vy[n/2+dy[i]]-piyo[j]);\n\t\t\t\t/*\n\t\t\t\tif(i==3&&maxd[i]<abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j])){\n\t\t\t\t\tcout << vx[j] << \" \" << vy[j] << \" \" << abs(vx[n/2+dx[i]]-vx[j])+abs(vy[n/2+dy[i]]-vy[j]) << endl;\n\t\t\t\t}*/\n\t\t\t\tmaxd[i]=max(maxd[i],abs(vx[n/2+dx[i]]-hoge[j])+abs(vy[n/2+dy[i]]-piyo[j]));\n\t\t\t}\n\t\t}\n\t\tans=INF*1000;\n\t\tfor(long long int i=0; i<4; ++i){\n\t\t\t//cout << vx[n/2+dx[i]] << \" \" << vy[n/2+dy[i]]<< \" \" << tmp[i]-maxd[i] << \" \" << tmp[i] << \" \" << maxd[i] << endl;\n\t\t\tif(ans>=tmp[i]-maxd[i]&&n/2+dx[i]>=0&&n/2+dy[i]>=0){\n\t\t\t\tans=tmp[i]-maxd[i];\n\t\t\t\tans_x=vx[n/2+dx[i]];\n\t\t\t\tans_y=vy[n/2+dy[i]];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ans_x << \" \" << ans_y << endl;\n\treturn 0;\n}\n\n//01234567"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    int x;\n    int y;\n    P(){}\n    P(int p1,int p2){\n        x=p1;\n        y=p2;\n    }\n};\n\n\nint W,H;\nint N;\nint dis[100010];\nvector<int> posx;\nvector<int> posy;\nvector<P> pos;\n\nint dist(int x,int y){\n    int res=0;\n    for(int i=0;i<N;++i){\n        int disx=abs(x-pos[i].x);\n        int disy=abs(y-pos[i].y);\n        dis[i]=disx+disy;\n    }\n    sort(dis,dis+N);\n    for(int i=0;i<N-1;++i)res+=dis[i]*2;\n    res+=dis[N-1];\n    return res;\n}\n\nsigned main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int x,y;\n        cin>>x>>y;\n        posx.PB(x);\n        posy.PB(y);\n        pos.PB(P(x,y));\n    }\n    if(N%2!=0){\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int x=posx[N/2];\n        int y=posy[N/2];\n        int ans=dist(x,y);\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    else{\n        sort(posx.begin(),posx.end());\n        sort(posy.begin(),posy.end());\n        int ans=INF;\n        int x,y;\n        int d1=dist(posx[N/2-1],posy[N/2-1]);\n        int d2=dist(posx[N/2-1],posy[N/2]);\n        int d3=dist(posx[N/2],posy[N/2-1]);\n        int d4=dist(posx[N/2],posy[N/2]);\n        if(ans>d1){\n            ans=d1;\n            x=posx[N/2-1];\n            y=posy[N/2-1];\n        }\n        if(ans>d2){\n            ans=d2;\n            x=posx[N/2-1];\n            y=posy[N/2];\n        }\n        if(ans>d3){\n            ans=d3;\n            x=posx[N/2];\n            y=posy[N/2-1];\n        }\n        if(ans>d4){\n            ans=d4;\n            x=posx[N/2];\n            y=posy[N/2];\n        }\n        cout<<ans<<endl;\n        cout<<x<<\" \"<<y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(mem[3]=c){//////////////////////////////////////////\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]>c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(a[mem[0]]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(b[mem[0]]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[3]<c){\n                mem[3]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[3]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n/*sort(a,a+5);\n    for(int i=0;i<5;++i)cout<<a[i]<<endl;*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n\n  REP(i,1,all.size()){\n    ll fir = all[i];\n    int sec=M[all[i]];\n    ll diff = fir - prev;\n    assert(diff > 0);\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    assert(neg+pos == 2*n);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nlong long int INF=(long long)10000000000*100000;\nlong long int ans=0;\nlong long int w,h;\nlong long int x[100001],y[100001];\nvector<long long int> vx;\nvector<long long int> vy;\nlong long rx,ry;\nint n;\n\nlong long int dfs(long long int sx,long long int sy){\n\tvector<long long int> v;\n\tfor(int i=0;i<n;i++){\n\t\tv.push_back(abs(sx-x[i])+abs(sy-y[i]));\n\t}\n\tsort(v.begin(),v.end());\n\tlong long res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(i<n-1)res+=v[i]*2;\n\t\telse res+=v[i];\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> w >> h;\n\tans=INF;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t\tvx.push_back(x[i]);\n\t\tvy.push_back(y[i]);\n\t}\n\tif(n==1){\n\t\tcout << 0 << endl;\n\t\tcout << x[0] << \" \" << y[0] << endl;\n\t}\n\telse{\n\t\tsort(vx.begin(),vx.end());\n\t\tsort(vy.begin(),vy.end());\n\t\tfor(int j=-1;j<=1;j+=2){\n\t\t\tfor(int i=-1;i<=1;i+=2){\n\t\t\t\tlong long int res=dfs(vx[(n+j)/2],vy[(n+i)/2]);\n\t\t\t\tif(res<ans){\n\t\t\t\t\trx=vx[(long long)((n+j)/2)];\n\t\t\t\t\try=vy[(long long)((n+i)/2)];\n\t\t\t\t\tans=res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tcout << rx << \" \" << ry << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n//#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef long long int LL;\nconst LL INF = 3e18;\n\nint w, h, n;\nLL x[100010], y[100010];\n\nVI homex, homey;\nLL candidate[2][2];\nLL ans = INF;\nLL ans_loc[2];\n\nint main()\n{\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lld%lld\", &x[i], &y[i]);\n    \n    homex.PB(x[i]);\n    homey.PB(y[i]);\n  }\n  \n  sort(homex.begin(), homex.end());\n  sort(homey.begin(), homey.end());\n\n  candidate[0][0] = homex[(homex.size() - 1) / 2];\n  candidate[0][1] = homex[homex.size() / 2];\n  candidate[1][0] = homey[(homex.size() - 1) / 2];\n  candidate[1][1] = homey[homex.size() / 2];\n\n  for(int i = 0; i < 4; i++){\n    LL sum = 0, mx = 0;\n    \n    for(int j = 0; j < n; j++){\n      LL dist = abs(candidate[0][(i & 2) / 2] - x[j]) + abs(candidate[1][i & 1] - y[j]);\n\n      sum += dist * 2;\n      mx = max(mx, dist);\n    }\n    sum -= mx;\n\n    if(ans > sum){\n      ans = sum;\n      ans_loc[0] = candidate[0][(i & 2) / 2];\n      ans_loc[1] = candidate[1][i & 1];\n    }\n  }\n\n  printf(\"%lld\\n%lld %lld\\n\", ans, ans_loc[0], ans_loc[1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tif (j > mid)\n\t\t\tmid--;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tif (p > mid2)\n\t\t\tmid2--;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n ; i+=2) {\n\t\t\tif(i == j)\n\t\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t\telse\n\t\t\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j < mid)\n\t\t\tmid--;\n\t\tif (j > mid)\n\t\t\tmid++;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t\tif (p > mid2)\n\t\t\tmid2;\n\t}\n\tcout << mid << endl;\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> UX;\nvector<long long> UY;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tsort(X.begin(), X.end()); UX.push_back(X[0]);\n\tsort(Y.begin(), Y.end()); UY.push_back(Y[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (X[i] != X[i - 1])\n\t\t{\n\t\t\tUX.push_back(X[i]);\n\t\t}\n\n\t\tif (Y[i] != Y[i - 1])\n\t\t{\n\t\t\tUY.push_back(Y[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tlong long sum = 0; long long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - UX[i]) + abs(Y[k] - UY[j]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - UX[i]) + abs(Y[k] - UY[j]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n//typedef pair<int,int> P;\nstruct P {int x,y;};\nstruct TP {int t,x,y;};\nint w,h,n;\nP ie[100002];\n\nint t(int x,int y) {\n  int sum=0;\n  int md=0;\n  int d=0;\n  rep(i,n){\n    d=abs(ie[i].x-x)+abs(ie[i].y-y);\n    sum+=d*2;\n    md=max(md,d);\n  }\n  return sum-md;\n}\n\nsigned main(){\n  cin>>w>>h>>n;\n  int gx=0,gy=0;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ie[i]={x,y};\n    gx+=x;\n    gy+=y;\n  }/*\n  gx/=n;\n  gy/=n;\n  int x=gx,y=gy;\n  bool f=1;\n  while(f){\n    int t0=t(x,y);\n    int tw=t(x,y-1);\n    int ta=t(x-1,y);\n    int ts=t(x,y+1);\n    int td=t(x+1,y);\n    f=0;\n    if(tw<=t0)y--,f=1;\n    else if(ts<t0)y++,f=1;\n    if(ta<=t0)x--,f=1;\n    else if(td<t0)x++,f=1;\n  }\n  cout<<t(x,y)<<endl;\n  cout<<x<<\" \"<<y<<endl;*/\n  int tm=1000000000000000,x,y;\n  int t0;\n  rep(i,w)rep(j,h){\n    t0=t(i+1,j+1);\n    if(t0<tm)tm=t0,x=i+1,y=j+1;\n  }\n  cout<<tm<<endl;\n  cout<<x<<\" \"<<y<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],x2[100000],y2[100000],n,ansx,ansy,w,h,l=0;\n  ll sumx=0,sumy=0,ans;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    x2[i]=x[i];\n    y2[i]=y[i];\n  }\n\n  sort(x,x+n);\n  sort(y,y+n);\n\n  ansx=x[n/2-1];\n  ansy=y[n/2-1];\n  \n  for(int i=0;i<n;i++){\n    l=max(l,abs(x2[i]-ansx)+abs(y2[i]-ansy));\n    ans+=(abs(x2[i]-ansx)+abs(y2[i]-ansy))*2;\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans-l,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<31);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  long long int ans = INF;\n  int ansx, ansy;\n  int up = min( (n / 2) + 2, n - 1);\n  int down = max(0, (n / 2) - 2);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      long long int  res = 0;\n      int far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=5;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   cout << \"brute force \" << endl;\n   cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t   }\n\t }\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    cout <<\"mxs \";rep(i,mxs.size())cout <<x[ mxs[i]].second <<\" \" ;cout << endl;\n    cout <<\"mys \";rep(i,mys.size())cout <<y[ mys[i]].second <<\" \" ;cout << endl;\n    //bf(in,ans,ansy,ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    int W, H; cin >> W >> H;\n\n    int N; cin >> N;\n\n    rep(i, N) {\n        cin >> X[i];\n        cin >> Y[i];\n        pos[i] = pii(X[i], Y[i]);\n    }\n\n    sort(X, X + N);\n    sort(Y, Y + N);\n\n    int x = N % 2 == 0 ? (X[N / 2 - 1] + X[N / 2]) / 2 : X[N / 2];\n    int y = N % 2 == 0 ? (Y[N / 2 - 1] + Y[N / 2]) / 2 : Y[N / 2];\n\n    rep(i, N) {\n        v[i] = abs(x - pos[i].fst) + abs(y - pos[i].scd);\n    }\n\n    sort(v, v + N);\n\n    int ans = 0;\n\n    rep(i, N) ans += v[i] * 2;\n    ans -= v[N - 1];\n\n    cout << ans << endl;\n    cout << x << ' ' << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nLL w, h, n, posi[101010], posj[101010];\nvector<LL> ilist, jlist, icouho, jcouho;\n\n\nint main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> posi[i] >> posj[i];\n\t\tilist.emplace_back(posi[i]);\n\t\tjlist.emplace_back(posj[i]);\n\t}\n\tsort(ALL(ilist));\n\tsort(ALL(jlist));\n\t//UNIQ(ilist);\n\t//UNIQ(jlist);\n\tif (jlist.size() % 2 == 1) {\n\t\tjcouho.emplace_back(jlist[jlist.size() / 2]);\n\t}\n\telse {\n\t\tjcouho.emplace_back(jlist[jlist.size() / 2]);\n\t\tjcouho.emplace_back(jlist[jlist.size() / 2 - 1]);\n\t}\n\n\tif (ilist.size() % 2 == 1) {\n\t\ticouho.emplace_back(ilist[ilist.size() / 2]);\n\t}\n\telse {\n\t\ticouho.emplace_back(ilist[ilist.size() / 2]);\n\t\ticouho.emplace_back(ilist[ilist.size() / 2 - 1]);\n\t}\n\tsort(ALL(icouho));\n\tsort(ALL(jcouho));\n\tLL ans = LINF;\n\tLL ansmidi, ansmidj;\n\tfor (int i = 0; i < icouho.size(); i++) {\n\t\tfor (int j = 0; j < jcouho.size(); j++) {\n\t\t\tLL maxd = 0;\n\t\t\tLL midi = icouho[i], midj = jcouho[j];\n\t\t\t//cout << midi<<\" \" << midj<<endl;\n\t\t\tLL sum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += (abs(midi - posi[k]) + abs(midj - posj[k])) * 2;\n\t\t\t\tmaxd = max(maxd, abs(midi - posi[k]) + abs(midj - posj[k]));\n\t\t\t}\n\t\t\tsum -= maxd;\n\t\t\tif (ans > sum) {\n\t\t\t\tans = sum;\n\t\t\t\tansmidi = midi, ansmidj = midj;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << ansmidi << \" \" << ansmidj << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 1000000\n#define INF 1145141145141919810LL;\n\nlong long x[MAX_N],y[MAX_N],lx[MAX_N],ly[MAX_N],d[MAX_N],n,h,w,sx,sy,c,mx,my,sum,minx,dx,dy;\nvector<long long>X,Y,BX,BY;\n\nint main(){\n\tcin>>h>>w>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tlx[i]=x[i];ly[i]=y[i];\n\t\tsx+=x[i];\n\t\tsy+=y[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tmx=INF;my=INF;minx=INF;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=x[0];}\n\t\telse{c=x[i]-x[i-1];}\n\t\tsx+=(-n+i*2)*c;\n\t\tif(mx==sx){X.push_back(x[i]);}\n\t\tif(mx>sx){mx=sx;X.clear();X.push_back(x[i]);}\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=y[0];}\n\t\telse{c=y[i]-y[i-1];}\n\t\tsy+=(-n+i*2)*c;\n\t\tif(my==sy){Y.push_back(y[i]);}\n\t\tif(my>sy){my=sy;Y.clear();Y.push_back(y[i]);}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tif(i<10){BX.push_back(X[i]);}\n\t\telse{if(X[i]!=X[i-10]){BX.push_back(X[i]);}}\n\t}\n\tfor(int i=0;i<Y.size();i++){\n\t\tif(i<10){BY.push_back(Y[i]);}\n\t\telse{if(Y[i]!=Y[i-10]){BY.push_back(Y[i]);}}\n\t}\n\tfor(int i=0;i<BX.size();i++){\n\t\tfor(int j=0;j<BY.size();j++){\n\t\t\tmemset(d,0,sizeof(d));\n\t\t\tsum=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\td[k]=abs(BX[i]-lx[k])+abs(BY[j]-ly[k]);\n\t\t\t\tsum+=d[k]*2;\n\t\t\t}\n\t\t\tsort(d,d+n);\n\t\t\tsum-=d[n-1];\n\t\t\tif(minx>sum){\n\t\t\t\tminx=sum;\n\t\t\t\tdx=BX[i];\n\t\t\t\tdy=BY[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<minx<<endl<<dx<<' '<<dy<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\ni64 calc(i64& mean, const vector<i64>& vec, vector<i64>& ma) {\n    i64 res = 0LL;\n    for(int i : in(vec.size())) {\n        i64 t = vec[i];\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma[i] += plus;\n        res += plus << 1LL;\n    }\n    return res;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    auto sortx = xcoord, sorty = ycoord;\n    sort(sortx.begin(), sortx.end());\n    sort(sorty.begin(), sorty.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    tuple<i64, i64, i64> ans(1e18, 0LL, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = sortx[id1], y = sorty[id2];\n        vector<i64> ma(n, 0LL);\n        i64 sum = calc(x, xcoord, ma) + calc(y, ycoord, ma);\n//        cout << x << ' ' << y << ' ' << sum << ' '; for(i64 k : ma) cout << k << ' '; cout << endl;\n        sum -= *max_element(ma.begin(), ma.end());\n        ans = min(ans, make_tuple(sum, x, y));\n    }\n    i64 sum, x, y; tie(sum, x, y) = ans;\n    cout << sum << '\\n' << x << ' ' << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int w,h;\nlong long int n;\nlong long int a[200001],b[200001],A[200000],B[200000];\nlong long int x,y;\nlong long int xa,ya;\nlong long int mem[4]={0},mem1=0,c;\nlong long int sum=0;\nint in(int i){\n    mem[0]=i;\n    mem[1]=a[i];\n    mem[2]=b[i];\n    mem[3]=c;\n    return 0;\n}\nint main(){\n\n    scanf(\"%lld%lld%lld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld%lld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n        //printf(\"[%lld %lld %lld %lld]\\n\",A[n/2],A[n/2-1],B[n/2],B[n/2-1]);\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem[0]);\n        printf(\"%lld %lld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            c=abs(a[i]*2-xa);\n            c=c+abs(b[i]*2-ya);\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    in(i);\n                }\n                else if(mem[1]==a[i]){\n                    if(mem[2]<b[i]){\n                        in(i);\n                    }\n                }\n            }\n            else if(mem[3]<c){//////error\n                in(i);\n            }\n        }\n        if(mem[1]*2>xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%lld %lld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\n\nll calc(vint& v, int p)\n{\n\tll res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint px[] = { X[(N-1)/2], X[(N+1)/2] };\n\tint py[] = { Y[(N-1)/2], Y[(N+1)/2] };\n\t\n\trep(i, 4)\n\t{\n\t\tint x = px[i/2], y = py[i%2];\n\t\tll sub = calc(X, x) + calc(Y, y);\n\n\t\tint far_dst = 0;\n\t\trep(j, N) chmax(far_dst, abs(x - points[j].first) + abs(y - points[j].second));\n\n\t\tsub -= far_dst;\n\t\t\n\t\tif(sub < best)\n\t\t{\n\t\t\tbest = sub;\n\t\t\tbest_x = x;\n\t\t\tbest_y = y;\n\t\t}\n\t}\n\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=1;\nconst ll inf = 1LL<<60;\n\nvector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yÀWÌ³kAÅ¬lßÄ¨­\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //yÀWªêÔ¬³¢ê©ç·×ÄÌÆÜÅÌ£ðvZµÄ¨­\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   //½ÊìÁÛ¢±ÆðµÄAeyÀW©çÆÜÅÌ£ÌaðvZµÄ¨­B\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n//STõ\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(llabs(in[k].second-x[j])+llabs(in[k].first-y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n }\n\n/*\n  ðûjB\n  ðµÈ¢ÆªPÂ éÆ¢¤ðð³·éêB\n  eÆª¯¶êÉñÓ éÆl¦ÄâéB\n  x,yÀWÍÆ§Él¦çé±ÆªÅ«éB\n  xÀWÌ£ÌaªÅà¬³¢ÊuÍAÇê©ÌÆÆÀWªêv·éêÉ é(Otðl¦ÄÝéÆí©é)\n  Æ¢¤ÌÍæÔÌrÅ êÎÇ¿ç©É¸çµ½Ù¤ªaª¬³­Èé©çÅ éBiÀWÌÔÌOtÌX«Íµ¢B)\n  yÀWà¯lB\n  ðµÈ¢Æ¢¤ðð³µÄ¢éÌÅA±ÌÌ¦ÍxÀW©çÌ£ªÅ¬ÉÈé_ÆyÀW©çÌ£ªÅ¬ÉÈé_ÌaÉÈéB\n\n  ðµÈ¢Æðl¦éêB\n  Ü¸P³Ål¦éB\n  ðµÈ¢_ðæè¢ÄÝéÆæÙÇl¦½OtÉá±ÌÏ»ª éB( éæÔÅÌX«ªÏ»·é)\n  ½¾µ±êÉæée¿Í»±ÜÅå«­È­AæÙÇl¦½OtÌÅ¬ÆÈé_ª1¸êéÂ\\«ª é¾¯Å éB\n  ÈÌÅæè­ÆiµÈ¢ÆjðßÅ¿µÄA\n  ðl¦½êÉ ÆÍÅ¬ÉÈél(2*2=4Êè)Ìüèð²×êÎ\\ªÅ éB\n */\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//XRAAÀWÌyA\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //xÀWAyÀWA»ê¼ê£ÌaªÅ¬ÉÈé_ÌÊuðvZµÄ¨­\n     //±êÍ½©¾©QÂiRÂHjµ©¶ÝµÈ¢Í¸\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n\n     //ðsíÈ¢ÆðßÅ¿µÄA·éêÌÅ¬lüÓð²×éB\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,max(0,mys[ii]-D),min(mys[ii]+D,(int)y.size())){\n\t     REP(j,max(0,mxs[jj]-D),min(mxs[jj]+D,(int)x.size())){\n\t       ll tmp = y[i].first;\n\t       tmp = tmp + x[j].first;\n\t       tmp = tmp - llabs(y[i].second-in[k].first);\n\t       tmp = tmp - llabs(x[j].second-in[k].second); \n\t       ll ty=y[i].second;\n\t       ll tx=x[j].second;\n\t       if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t\t ans = tmp;\n\t\t ansx = tx;\n\t\t ansy = ty;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  printf(\"\\n\");\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2 - 1];\n      ori.y = y[(n + 1) / 2 - 1];\n      int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer < wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2 - 1])\n\t    {\n\t      s.x = x[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  if(ww[i].y > y[n / 2 - 1])\n\t    {\n\t      s.y = y[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(ww[i].x < ww[sai].x || (ww[i].x == ww[sai].x && ww[i].y < ww[sai].y))\n\t\t{\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n      if(ww[sai].x > x[n / 2 - 1])\n\t{\n\t  ori.x = x[n / 2 - 1];\n\t}\n      else\n\t{\n\t  ori.x = x[n / 2];\n\t}\n      if(ww[sai].y > y[n / 2 - 1])\n\t{\n\t  ori.y = y[n / 2 - 1];\n\t}\n      else\n\t{\n\t  ori.y = y[n / 2];\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i]) * 2));\n\t}\n      else\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i])));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],x2[100000],y2[100000],n,ansx,ansy,w,h,l=0,sum;\n  ll sumx=0,sumy=0,ans=1000000000000000;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    x2[i]=x[i];\n    y2[i]=y[i];\n  }\n\n  sort(x,x+n);\n  sort(y,y+n);\n\n  for(int j=0;j<2;j++){\n    for(int k=0;k<2;k++){\n      sum=0;\n      for(int i=0;i<n;i++){\n\tl=max(l,abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]));\n\tsum+=(abs(x2[i]-x[(n+j+1)/2-1])+abs(y2[i]-y[(n+k+1)/2-1]))*2;\n      }\n      if(ans>sum-l){\n\tans=sum-l;\n\tansx=x[(n+j+1)/2-1];\n\tansy=y[(n+k+1)/2-1];\n      }\n    }\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<string.h>\n#include<vector>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<string>\n#include<stack>\n#define int long long\n#define P pair<int,int>\nusing namespace std;\n\nP a[100000];\nint b[100000], c[100000];\nint dis = LLONG_MAX;\nP ans = { LLONG_MAX,LLONG_MAX };\nP w;//x??§?¨???????\nP x;//x??§?¨?????????¢\nP y;//y??§?¨???????\nP z;//y??§?¨?????????¢\nsigned main() {\n\tint n; cin >> n >> n >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tsort(b, b + n); sort(c, c + n);\n\tif (n & 1) {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t}\n\telse {\n\t\tw.first = b[n / 2];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2]) * 2;\n\t\t}\n\t\tx.first = k;\n\t\tk = 0;\n\t\tw.second = b[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(b[i] - b[n / 2 - 1]) * 2;\n\t\t}\n\t\tx.second = k;\n\t\tk = 0;\n\n\t\ty.first = c[n / 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2]) * 2;\n\t\t}\n\t\tz.first = k;\n\t\tk = 0;\n\n\t\ty.second = c[n / 2 - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tk += abs(c[i] - c[n / 2 - 1]) * 2;\n\t\t}\n\t\tz.second = k;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = a[i].first, c[i] = a[i].second;\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tdis = min(dis, l + r);\n\t}\n\tfor (int i = 0; i < n; i++) {//i???????????????\n\t\tint l = x.first - abs(w.first - b[i]);\n\t\tif (n % 2 == 0)l = min(l, x.second - abs(w.second - b[i]));\n\t\tint r = z.first - abs(y.first - c[i]);\n\t\tif (n % 2 == 0)r = min(r, z.second - abs(y.second - c[i]));\n\t\tif (dis == l + r) {\n\t\t\tif (n % 2 == 0 && x.first - abs(w.first - b[i])!=l) {\n\t\t\t\tans.first = min(ans.first, w.second);\n\t\t}\n\t\t\telse {\n\t\t\t\tans.first = min(ans.first, w.first);\n\t\t\t}\n\t\t\tif (n % 2 == 0 && z.first - abs(y.first - c[i]) != r) {\n\t\t\t\tans.second = min(ans.second, y.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.second = min(ans.second, y.first);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis << endl;\n\tcout << ans.first << \" \" << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\ntemplate <typename T>\nusing gtree = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n// usage:\n// find_by_order(Int k): return the iterator of k-th smallest element (0-indexed)\n// order_of_key(T key):  return the index of key in tree\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h,n;\n  cin>>w>>h>>n;\n  vector<Int> x(n),y(n);\n  for(Int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n  using P = pair<Int, Int>;\n  gtree<P> gx,gy;\n  for(Int i=0;i<n;i++){\n    gx.insert(P(x[i],i));\n    gy.insert(P(y[i],i));\n    gx.insert(P(x[i],n+i));\n    gy.insert(P(y[i],n+i));\n  }\n\n  Int ans=1e18;\n  Int ax=-1,ay=-1;\n\n  map<Int, Int> mx,my;\n  \n  for(Int i=0;i<n;i++){    \n    gx.erase(P(x[i],i));\n    gy.erase(P(y[i],i));\n\n    \n    Int tx=gx.find_by_order(n-1)->first;\n    Int ty=gy.find_by_order(n-1)->first;\n\n    if(!mx.count(tx)){\n      mx[tx]=0;\n      for(Int j=0;j<n;j++)\n\tmx[tx]+=abs(x[j]-tx)*2;\n    }\n    if(!my.count(ty)){\n      my[ty]=0;\n      for(Int j=0;j<n;j++)\n\tmy[ty]+=abs(y[j]-ty)*2;\n    }\n    \n    Int res=mx[tx]+my[ty]-(abs(x[i]-tx)+abs(y[i]-ty));\n    if((res< ans)||\n       (res==ans&&tx< ax)||\n       (res==ans&&tx==ax&&ty< ay)){\n      ans=res;\n      ax=tx;\n      ay=ty;\n    }\n    \n    gx.insert(P(x[i],i));\n    gy.insert(P(y[i],i));\n  }\n  \n  cout<<ans<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\t\t\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, l = 0, r = B;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t\telse if (sum == ret)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e9\nP house[2][MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, ma = 0, mid, x, y;\n\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[1][i] = make_pair(b, a);\n\t}\n\tsort(house[0], house[0] + n);\n\tsort(house[1], house[1] + n);\n\tmid = n / 2;\n\tx = house[0][mid].F;\n\ty = house[1][mid].F;\n\tfor (int i = 0; i < 2; i++) {\n\t\tma = max(ma, abs(house[i][0].F - x) + abs(house[i][0].S - y));\n\t\tma = max(ma, abs(house[i][n - 1].F - x) + abs(house[i][n - 1].S - y));\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t}\n\n\tsum *= 2;\n\tsum -= ma;\n\tcout << sum << endl;\n\tcout << x << ' ' << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF=1LL<<61;\n\n// x0 に降りて、最後に x_last まで行くときの x 方向の総コスト\nll f(int x0,int x_last,int n,const int *x,const ll *x_sum){\n\tint p=lower_bound(x,x+n,x0)-x;\n\tll res=0;\n\tres+=(ll)p*x0-x_sum[p];                // x0 より左にある家のコスト\n\tres+=(x_sum[n]-x_sum[p])-(ll)(n-p)*x0; // x0 より右にある家のコスト\n\treturn 2*res-abs(x_last-x0);\n}\n\nvoid solve(int n,const int *x,int *x0,ll *ans){\n\tstatic int x_sorted[100000];\n\trep(i,n) x_sorted[i]=x[i];\n\tsort(x_sorted,x_sorted+n);\n\n\tstatic ll x_sum[100001];\n\trep(i,n) x_sum[i+1]=x_sum[i]+x_sorted[i];\n\n\trep(i,n){\n\t\tint lo=x_sorted[0],hi=x_sorted[n-1];\n\t\twhile(lo<hi){\n\t\t\tint mi1=(lo+hi)/2,mi2=mi1+1;\n\t\t\tif(f(mi1,x[i],n,x_sorted,x_sum)>f(mi2,x[i],n,x_sorted,x_sum)) lo=mi1+1; else hi=mi2-1;\n\t\t}\n\t\tx0[i]=lo;\n\t\tans[i]=f(lo,x[i],n,x_sorted,x_sum);\n\t}\n}\n\nint main(){\n\tint n; scanf(\"%*d%*d%d\",&n);\n\tstatic int x[100000],y[100000];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\t// x0[i] := ( 最後に家 i を訪れるとしたときの、最適な降りる位置の x 座標 )\n\t// ans_x[i] := ( 最後に家 i を訪れるとして、x0[i] に降りたときの x 方向の総コスト )\n\tstatic int x0[100000],y0[100000];\n\tstatic ll ans_x[100000],ans_y[100000];\n\tsolve(n,x,x0,ans_x);\n\tsolve(n,y,y0,ans_y);\n\n\tstatic ll ans[100000];\n\trep(i,n) ans[i]=ans_x[i]+ans_y[i];\n\n\tint i_ans=0;\n\trep(i,n){\n\t\tif(ans[i_ans]>ans[i]\n\t\t|| ans[i_ans]==ans[i] && x0[i_ans]>x0[i]\n\t\t|| ans[i_ans]==ans[i] && x0[i_ans]==x0[i] && y0[i_ans]>y0[i]) i_ans=i;\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans[i_ans],x0[i_ans],y0[i_ans]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = 0LL;\n\tRY = 0LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, tx);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\t\t\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = min(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  printf(\"\\n\");\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2];\n      ori.y = y[(n + 1) / 2];\n      int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer < wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2])\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2 + 1];\n\t    }\n\t  if(ww[i].y > y[n / 2])\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2 + 1];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(ww[i].x < ww[sai].x || (ww[i].x == ww[sai].x && ww[i].y < ww[sai].y))\n\t\t{\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n      if(ww[sai].x > x[n / 2])\n\t{\n\t  ori.x = x[n / 2];\n\t}\n      else\n\t{\n\t  ori.x = x[n / 2 + 1];\n\t}\n      if(ww[sai].y > y[n / 2])\n\t{\n\t  ori.y = y[n / 2];\n\t}\n      else\n\t{\n\t  ori.y = y[n / 2 + 1];\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i]) * 2));\n\t}\n      else\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i])));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, dx = 1145141919810LL, dy = 1145141919810LL, cx, cy, minx = 1145141919810LL;\nvector<int>mx, my;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int g = 0; g < mx.size(); g++) {\n\t\tfor (int h = 0; h < my.size(); h++) {\n\t\t\tsum = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\td[i] = (abs(mx[g] - ex[i]) + abs(my[h] - ey[i]));\n\t\t\t\tsum += d[i] * 2;\n\t\t\t}\n\t\t\tsort(d, d + n);\n\t\t\tsum -= d[n - 1];\n\t\t\tif (minx > sum) { minx = sum; cx = mx[g]; cy = my[h]; }\n\t\t}\n\t}\n\t\n\tcout << sum << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tint xpos = ws[N / 2] - (N % 2 == 0);\n\tint ypos = hs[N / 2] - (N % 2 == 0);\n\n\tV dists(N);\n\trep(i, N) {\n\t\tdists[i] = abs(v[i].first - xpos) + abs(v[i].second - ypos);\n\t}\n\tsort(all(dists));\n\n\tint ans = accumulate(all(dists), 0) * 2 - dists.back();\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#define INF (2LL << 58)\nusing namespace std;\n\nint n, x[111111], y[111111], cx[111111], cy[111111];\n\nlong long solve(int midx, int midy){\n    \n    long long maxdis = 0, sum = 0;\n    maxdis = 0, sum = 0;\n    for(int i = 0; i < n; i++){\n        long long dis = abs(midx - x[i]) + abs(midy - y[i]);\n        sum += dis * 2;\n        maxdis = max(maxdis, dis);\n    }\n    return sum - maxdis;\n}\n\nint main(){\n    \n    int W, H;\n\n    cin >> W >> H >> n;\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n        cx[i] = x[i], cy[i] = y[i];\n    }\n    sort(cx, cx + n);\n    sort(cy, cy + n);\n    \n    vector <pair<int, int> > pt;\n    if(n % 2) pt.push_back(make_pair(cx[n / 2], cy[n / 2]));\n    else {\n        for(int i = 0; i < 2; i++){\n            for(int j = 0 ; j < 2; j++){\n                pt.push_back(make_pair(cx[n / 2 - 1 + i], cy[n / 2 - 1 + j]));\n            }\n        }\n    }\n    \n    int ax, ay;\n    long long ret, res = INF;\n    for(int i = 0; i < pt.size(); i++){\n        ret = solve(pt[i].first, pt[i].second);\n        if(res > ret){\n            ax = pt[i].first, ay = pt[i].second;\n            res = ret;\n        }\n    }\n    cout << res << endl;\n    cout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n  int x[100000],y[100000],x2[100000],y2[100000],n,ansx,ansy,w,h,l=0;\n  ll sumx=0,sumy=0,ans;\n\n  scanf(\"%d%d%d\",&w,&h,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    x2[i]=x[i];\n    y2[i]=y[i];\n  }\n\n  sort(x,x+n);\n  sort(y,y+n);\n\n  ansx=x[(n+1)/2-1];\n  ansy=y[(n+1)/2-1];\n  \n  for(int i=0;i<n;i++){\n    l=max(l,abs(x2[i]-ansx)+abs(y2[i]-ansy));\n    ans+=(abs(x2[i]-ansx)+abs(y2[i]-ansy))*2;\n  }\n    \n  printf(\"%lld\\n%d %d\\n\",ans-l,ansx,ansy);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*1,neg = 2*(n-1),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    //rep(i,in.size())cout << in[i].first <<\" \" << in[i].second << endl;\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[mx].first)my = i;    \n\n    const int D=50;\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n  \nint n, w, h, x[100005], y[100005];\npii pos[100005];\npair<int, pii> dist[100005];\n  \nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> w >> h >> n;\n  for (int i = 1; i <= n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x + 1, x + n + 1);\n  sort(y + 1, y + n + 1);\n  sort(pos + 1, pos + n + 1);\n  \n  int bx = x[n / 2], by = y[n / 2], ans = 0;\n  \n  for (int i = 1; i <= n; ++i) {\n    dist[i] = {abs(bx - pos[i].first) + abs(by -pos[i].second), pos[i]};\n  }\n  sort(dist + 1, dist + n + 1);\n  \n  for (int i = 1; i < n; ++i) {\n    ans += dist[i].first * 2;\n  }\n  ans += dist[n].first;\n  \n  cout << ans << endl << bx << \" \" << by << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define INF (1LL<<60)\n\ntypedef long long ll;\n\nll W,H,N;\nll X[100005],Y[100005];\nvector<int> sX,sY;\nll maxd;\nll sx[2],sy[2];\n\nll dist(ll ax, ll bx, ll ay, ll by){\n  ll ret = abs(ax-bx)+abs(ay-by);\n  maxd = max(maxd, ret);\n  return 2*ret;\n}\n\nint main(){\n  scanf(\"%lld%lld%lld\",&W,&H,&N);\n  rep(i,N) scanf(\"%lld%lld\", &X[i], &Y[i]);\n\n  rep(i,N){\n    sX.push_back(X[i]);\n    sY.push_back(Y[i]);\n  }\n  sort(sX.begin(), sX.end());\n  sort(sY.begin(), sY.end());\n  sX.erase(unique(sX.begin(), sX.end()), sX.end());\n  sY.erase(unique(sY.begin(), sY.end()), sY.end());\n\n  sx[0] = sX[(sX.size()-1)/2]; sx[1] = sX[(sX.size()+1)/2];\n  sy[0] = sY[(sY.size()-1)/2]; sy[1] = sy[(sY.size()+1)/2];\n  ll res=INF, rx, ry;\n  rep(i,4){\n    int x = sx[i/2], y = sy[i%2];\n    int sum = 0; maxd = 0;\n    rep(j,N) sum += dist(x, X[j], y, Y[j]);\n    sum -= maxd;\n    if(sum < res){\n      res = sum;\n      rx = x;\n      ry = y;\n    }\n  }\n  \n  /*  ll resX=W, distX=INF, resY=H, distY=INF;\n  rep(k,N){\n    ll mY=W, mX=H, mdX=INF, mdY=INF;\n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(X[i]-X[j])*2;\n      dist -= abs(X[i]-X[k]);\n      if(dist < mdX){\n\tmdX = dist;\n\tmX = X[i];\n      }\n    }\n    \n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(Y[i]-Y[j])*2;\n      dist -= abs(Y[i]-Y[k]);\n\n      if(dist < mdY){\n\tmdY = dist;\n\tmY = Y[i];\n      }\n    }\n    if(distX+distY > mdX+mdY){\n      distX = mdX, distY = mdY;\n      resY = mY, resX = mX;\n    }else if(distX+distY == mdX+mdY && mX < resX){\n      resY = mY;\n      resX = mX;\n    }else if(distX+distY == mdX+mdY && mX == resX && mY < resY){\n      resY = mY;\n      resX = mX;\n    }\n    }*/\n\n  printf(\"%lld\\n%lld %lld\\n\", res, rx, ry);\n  //  printf(\"%lld\\n\", distX+distY);\n  //  printf(\"%lld %lld\\n\", resX, resY);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<29);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  int ans = INF;\n  int ansx, ansy;\n  int up = min( (n / 2) + 2, n - 1);\n  int down = max(0, (n / 2) - 2);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      int res = 0, far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans > res -far){\n\tans = res - far;\n\tansx = i;\n\tansy = j;\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint W,H,N;\nint xs0[100*1000];\nint xs1[100*1000];\nint ys0[100*1000];\nint ys1[100*1000];\nint main() {\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",xs0+i,ys0+i);\n\t\txs1[i]=xs0[i];\n\t\tys1[i]=ys0[i];\n\t}\n\tLL ret=1LL<<60;\n\tint rx=0,ry=0;\n\tfor(int i=0;i<=(N+1)%2;i++){\n\t\tfor(int j=0;j<=(N+1)%2;j++){\n\t\t\tint x;\n\t\t\tif(i==0){\n\t\t\t\tnth_element(xs1,xs1+(N+i-1)/2,xs1+N);\n\t\t\t\tx=xs1[(N+i-1)/2];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx=*min_element(xs1+N/2,xs1+N);\n\t\t\t}\n\t\t\tint y;\n\t\t\tif(j==0){\n\t\t\t\tnth_element(ys1,ys1+(N+j-1)/2,ys1+N);\n\t\t\t\ty=ys1[(N+j-1)/2];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty=*min_element(ys1+N/2,ys1+N);\n\t\t\t}\n\t\t\tLL m=0;\n\t\t\tLL sum=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tLL d=abs(xs0[i]-x);\n\t\t\t\td+=abs(ys0[i]-y);\n\t\t\t\tm=max(m,d);\n\t\t\t\tsum+=2*d;\n\t\t\t}\n\t\t\tsum-=m;\n\t\t\tif(sum<ret){\n\t\t\t\tret=sum;\n\t\t\t\trx=x;\n\t\t\t\try=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long long int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%lld%lld%lld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>=a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]>=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N=100001;\nint H,W;\nint N;\nint XS[MAX_N];\nint YS[MAX_N];\nint curLast;\nvector<int> xnums;\nvector<int> ynums;\n// ¶a\nll leftDistSumX[MAX_N];\nll leftDistSumY[MAX_N];\n// Ea\nll rightDistSumX[MAX_N];\nll rightDistSumY[MAX_N];\n\nll check(ll s,bool isX=true){\n    ll sum=0;\n    // ÀWsªÇÌ_ÆÇÌ_ÌÔÉ é©ð©Â¯é\n    // »Ìîñð³ÉAÚ®ÊðvZ\n    if(isX){\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(xnums.begin(),xnums.end(),s);\n        if(it==xnums.end())sum=leftDistSumX[N-1]+rightDistSumX[N-1]+abs(s-xnums[N-1]);\n        else if(it==xnums.begin())sum=leftDistSumX[0]+rightDistSumX[0]+abs(s-xnums[0]);\n        else{\n            sum=leftDistSumX[it-xnums.begin()]+rightDistSumX[it-xnums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=*it-s;\n                int leftCnt=it-xnums.begin();\n                int rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-XS[curLast]);\n    }\n    else{\n        // ßÄsÈãÆÈéÓð©Â¯é\n        vector<int>::iterator it=lower_bound(ynums.begin(),ynums.end(),s);\n        if(it==ynums.end())sum=leftDistSumY[N-1]+rightDistSumY[N-1]+abs(s-ynums[N-1]);\n        else if(it==ynums.begin())sum=leftDistSumY[0]+rightDistSumY[0]+abs(s-ynums[0]);\n        else{\n            sum=leftDistSumY[it-ynums.begin()]+rightDistSumY[it-ynums.begin()];\n            if(*it!=s){\n                // ¢­Âß·Kvª é©\n                ll back=-s+*it;\n                int leftCnt=it-ynums.begin();\n                int rightCnt=N-leftCnt;\n                sum-=leftCnt*back;\n                sum+=rightCnt*back;\n            }\n        }\n        sum*=2;\n        sum-=abs(s-YS[curLast]);\n    }\n    return sum;\n}\n\nint main(){\n    cin>>W>>H;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>XS[i]>>YS[i];\n\n    // xûüÌÝÏa\n    for(int i=0;i<N;i++)xnums.push_back(XS[i]);\n    sort(xnums.begin(),xnums.end());\n    ll baseLeftSumX=0;\n    ll baseRightSumX=0;\n    for(int i=1;i<N;i++)baseRightSumX+=abs(xnums[i]-xnums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumX[i]=baseRightSumX;\n        leftDistSumX[i]=baseLeftSumX;\n        if(i!=N-1){\n            baseRightSumX-=abs(xnums[i]-xnums[i+1])*(N-i-1);\n            baseLeftSumX+=abs(xnums[i]-xnums[i+1])*(i+1);\n        }\n    }\n    // yûüÌÝÏa\n    for(int i=0;i<N;i++)ynums.push_back(YS[i]);\n    sort(ynums.begin(),ynums.end());\n    ll baseLeftSumY=0;\n    ll baseRightSumY=0;\n    for(int i=1;i<N;i++)baseRightSumY+=abs(ynums[i]-ynums[0]);\n    for(int i=0;i<N;i++){\n        rightDistSumY[i]=baseRightSumY;\n        leftDistSumY[i]=baseLeftSumY;\n        if(i!=N-1){\n            baseRightSumY-=abs(ynums[i]-ynums[i+1])*(N-i-1);\n            baseLeftSumY+=abs(ynums[i]-ynums[i+1])*(i+1);\n        }\n    }\n\n    // Ç±ðÅãÉKêéêÉ·é©Åêí¯\n    ll ret=-1;\n    ll lastX,lastY;\n    ll candX[3],candY[3];\n    for(int lp=0;lp<N;lp++){\n        curLast=lp;\n        // x\n        int cnt=1000;\n        ll ub=1000000000;\n        ll lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1)<check(mid2))ub=mid2;\n            else if(check(mid1)>check(mid2))lb=mid1;\n            else lb=mid1;\n        }\n        candX[0]=lb;\n        candX[1]=lb+1;\n        candX[2]=ub;\n        ll minXVal=-1;\n        ll rx;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candX[i]);\n            if(minXVal==-1||tmp<minXVal){\n                minXVal=tmp;\n                rx=candX[i];\n            }\n        }\n        // y\n        cnt=1000;\n        ub=1000000000;\n        lb=0;\n        while(ub-lb>2){\n            ll mid1=((ub-lb)/3)+lb;\n            ll mid2=((ub-lb)/3)*2+lb;\n            if(check(mid1,false)<check(mid2,false))ub=mid2;\n            else if(check(mid1,false)>check(mid2,false))lb=mid1;\n            else lb=mid1;\n        }\n        candY[0]=lb;\n        candY[1]=lb+1;\n        candY[2]=ub;\n        ll minYVal=-1;\n        ll ry;\n        for(int i=0;i<3;i++){\n            ll tmp=check(candY[i],false);\n            if(minYVal==-1||tmp<minYVal){\n                minYVal=tmp;\n                ry=candY[i];\n            }\n        }\n        ll res=minXVal+minYVal;\n        if(ret==-1||res<ret){\n            ret=res;\n            lastX=rx;\n            lastY=ry;\n        }\n        else if(res==ret){\n            if(lastX>rx){\n                lastX=rx;\n                lastY=ry;\n            }\n            else if(lastX==rx){\n                if(lastY>ry){\n                    lastX=rx;\n                    lastY=ry;\n                }\n            }\n        }\n    }\n    std::cout<<ret<<endl;\n    std::cout<<lastX<<\" \"<<lastY<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstdlib>\n#include<climits>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(const int x = 0, const int y = 0) :x(x), y(y) {}\n};\n\nclass Compare {\npublic:\n    Compare(const bool y = false) :y(y) {}\n    bool operator()(const Point& lhs, const Point& rhs) const {return y ? lhs.y < rhs.y : lhs.x < rhs.x;}\n    bool y;\n};\n\nlong long int distance(const Point& p, const Point& q) {return abs(p.x - q.x) + abs(p.y - q.y);}\n\nint main() {\n    int W, H, N;\n    cin >> W >> H >> N;\n\n    vector<Point> home(N);\n    for(auto& h: home) cin >> h.x >> h.y;\n\n    set<int> median_x;\n    sort(home.begin(), home.end(), Compare());\n    median_x.insert(home[N / 2].x);\n    median_x.insert(home[(N - 1) / 2].x);\n\n    set<int> median_y;\n    sort(home.begin(), home.end(), Compare(true));\n    median_y.insert(home[N / 2].y);\n    median_y.insert(home[(N - 1) / 2].y);\n\n    long long int answer_distance = LLONG_MAX;\n    int answer_x = 0;\n    int answer_y = 0;\n    for(const auto& x: median_x) for(const auto& y: median_y) {\n        Point santa(x, y);\n        long long int farthest = 0;\n        long long int sum = 0;\n        for(const auto& h: home) {\n            long long int d = distance(santa, h);\n            farthest = max(farthest, d);\n            sum += d * 2;\n        }\n        sum -= farthest;\n        if(answer_distance <= sum) continue;\n        answer_distance = sum;\n        answer_x = x;\n        answer_y = y;\n    }\n\n    cout << answer_distance << endl;\n    cout << answer_x << \" \" << answer_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=2;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pli> precalc(const vector<pair<ll,ll> >  in){\n  vector<pli> ret;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n    itr++;\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    rep(i,n)swap(in[i].first,in[i].second);\n    x = precalc(in);\n    rep(i,n)swap(in[i].first,in[i].second);\n    y = precalc(in);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n  vector<pair<int, int>> p(n);\n  vector<int> x(n), y(n);\n  for (int i : range(n)) cin >> p[i].first >> p[i].second;\n  for (int i : range(n)) x[i] = p[i].first, y[i] = p[i].second;\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  long long res = 1e18;\n  int rx = -1, ry = -1;\n  for (int i : range(max(0, n / 2 - 3), n / 2 + 3)) {\n    int xx = x[i], yy = y[i];\n    long long r = 0;\n    for (int j : range(n)) r += abs(x[j] - xx) + abs(y[j] - yy);\n    int d = 0;\n    for (int j : range(n)) d = max(d, abs(p[j].first - xx) + abs(p[j].second - yy));\n    r = 2 * r - d;\n    if (res > r || (res == r && (xx < rx || (xx == rx && yy < ry)))) {\n      res = r;\n      rx = xx;\n      ry = yy;\n    } \n  }\n  cout << res << endl << rx << \" \" << ry << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define INF 1000000000000000\nusing namespace std;\n\nint w,h,n;\nlong long ans = INF;\nlong long ansx = INF,ansy = INF;\nint X[100000],Y[100000],x[100000],y[100000];\n\nint main(){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i = 0; i < n; i++){\n\t\tx[i] = X[i];\n\t\ty[i] = Y[i];\n\t}\n\tif(n == 1){\n\t\tprintf(\"1\\n\");\n\t\tprintf(\"%lld %lld\\n\",x[0],y[0]);\n\t\treturn 0;\n\t}\n\tsort(x,x+n); sort(y,y+n);\n\tif(n%2 == 0){\n\t\tlong long Tx[2] = {0,0}, Ty[2] = {0,0};\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tTx[0] += abs(x[n/2-1]-X[i]);\n\t\t\tTy[0] += abs(y[n/2-1]-Y[i]);\n\t\t\tTx[1] += abs(x[n/2]-X[i]);\n\t\t\tTy[1] += abs(y[n/2]-Y[i]);\n\t\t}\n\t\tTx[0] *= 2; Tx[1] *= 2; Ty[0] *= 2; Ty[1] *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint zx = (X[i]<=x[n/2-1]),zy = (Y[i]<=y[n/2-1]); //T[0]\n\t\t\tif(ans >= Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i])){\n\t\t\t\tif(ans == Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i])){\n\t\t\t\t\tif(x[n/2+zx-1] < ansx){\n\t\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t\t} else if(x[n/2+zx-1] == ansx){\n\t\t\t\t\t\tif(y[n/2+zy-1] < ansy){\n\t\t\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tans = Tx[zx]+Ty[zy]-abs(x[n/2+zx-1]-X[i])-abs(y[n/2+zy-1]-Y[i]);\n\t\t\t\t\tansx = x[n/2+zx-1];\n\t\t\t\t\tansy = y[n/2+zy-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t} else{\n\t\tlong long tx = x[n/2], ty = y[n/2],sx,ex,sy,ey;\n\t\tlong long T = 0, sum;\n\t\tfor(int i = 0; i < n; i++) T += abs(tx-X[i])+abs(ty-Y[i]);\n\t\tT *= 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum = T-2*(abs(tx-X[i])+abs(ty-Y[i]));\n\t\t\tif(X[i] <= x[n/2-1]){\n\t\t\t\tsx = tx; ex = x[n/2+1]; \n\t\t\t} else if(X[i] == x[n/2]){\n\t\t\t\tsx = x[n/2-1]; ex = x[n/2+1];\n\t\t\t} else{\n\t\t\t\tsx = x[n/2-1]; ex = tx;\n\t\t\t}\n\t\t\tif(Y[i] <= y[n/2-1]){\n\t\t\t\tsy = ty; ey = y[n/2+1]; \n\t\t\t} else if(Y[i] == y[n/2]){\n\t\t\t\tsy = y[n/2-1]; ey = y[n/2+1];\n\t\t\t} else{\n\t\t\t\tsy = y[n/2-1]; ey = ty;\n\t\t\t}\n\t\t\t//printf(\"%lld\\n\", sum);\n\t\t\tif(sx<=X[i]&&X[i]<=ex&&sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum){\n\t\t\t\t\tif(ans == sum){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum;\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sx<=X[i]&&X[i]<=ex){\n\t\t\t\tif(ans>=sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(Y[i]-sy) <= abs(Y[i]-ey)) tmp = sy;\n\t\t\t\t\telse tmp = ey;\n\t\t\t\t\tif(ans == sum+min(abs(Y[i]-sy),abs(Y[i]-ey))){\n\t\t\t\t\t\tif(ansx > X[i]){\n\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t} else if(ansx == X[i]){\n\t\t\t\t\t\t\tif(ansy > tmp){\n\t\t\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(Y[i]-sy),abs(Y[i]-ey));\n\t\t\t\t\t\tansx = X[i];\n\t\t\t\t\t\tansy = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(sy<=Y[i]&&Y[i]<=ey){\n\t\t\t\tif(ans>=sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\tlong long tmp;\n\t\t\t\t\tif(abs(X[i]-sx) <= abs(X[i]-ex)) tmp = sx;\n\t\t\t\t\telse tmp = ex;\n\t\t\t\t\tif(ans == sum+min(abs(X[i]-sx),abs(X[i]-ex))){\n\t\t\t\t\t\tif(ansx > tmp){\n\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t} else if(ansx == tmp){\n\t\t\t\t\t\t\tif(ansy > Y[i]){\n\t\t\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tans = sum+min(abs(X[i]-sx),abs(X[i]-ex));\n\t\t\t\t\t\tansx = tmp;\n\t\t\t\t\t\tansy = Y[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(X[i] >= ex){\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(X[i]-ex)+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > ex){\n\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == ex){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(X[i]-ex)+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = ex;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(Y[i] >= ey){\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(Y[i]-ey)){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > ey){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(Y[i]-ey);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = ey;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif(ans >= sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\tif(ans == sum+(sx-X[i])+(sy-Y[i])){\n\t\t\t\t\t\t\tif(ansx > sx){\n\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t} else if(ansx == sx){\n\t\t\t\t\t\t\t\tif(ansy > sy){\n\t\t\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tans = sum+(sx-X[i])+(sy-Y[i]);\n\t\t\t\t\t\t\tansx = sx;\n\t\t\t\t\t\t\tansy = sy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%lld %lld %lld\\n\", ans, ansx, ansy);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld %lld\\n\",ansx,ansy);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2, sum2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\tfor (int i = 0; i < 2 * n; i += 2) {\n\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t}\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum2 = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid2].F;\n\t\tsum2 -= abs(house[0][j].F - x) + abs(house[0][j].S - y);\n\t\tsum2 += sum;\n\t\t\n\t\tif (time == sum2) {\n\t\t\ttime = sum2;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum2) {\n\t\t\ttime = sum2;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j < mid)\n\t\t\tmid--;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <fstream>\nusing namespace std;\n#define mp make_pair\n\nvector<int> median(vector<int> v) {\n\tsort(v.begin(), v.end());\n\tint n = v.size();\n\tvector<int> ret(1, v[n/2]);\n\tif (n % 2 == 0) {\n\t\tret.push_back(v[n/2-1]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\tvector<int> xs(N), ys(N);\n\tfor (int i=0; i<N; ++i) {\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tvector<int> mx = median(xs);\n\tvector<int> my = median(ys);\n\tlong long res = LLONG_MAX;\n\tint x, y;\n\tfor (int i=0; i<(int)mx.size(); ++i) {\n\t\tfor (int j=0; j<(int)my.size(); ++j) {\n\t\t\tlong long time = 0, m = 0;\n\t\t\tfor (int k=0; k<N; ++k) {\n\t\t\t\tlong long t = abs(xs[k] - mx[i]) + abs(ys[k] - my[j]);\n\t\t\t\ttime += t;\n\t\t\t\tm = max(m, t);\n\t\t\t}\n\t\t\tlong long res2 = 2 * time - m;\n\t\t\tif (mp(res2, mp(mx[i], my[j])) < mp(res, mp(x, y))) {\n\t\t\t\tres = res2;\n\t\t\t\tx = mx[i];\n\t\t\t\ty = my[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      int xind = (*X.find(in[k].second)).first;\n      int yind = (*Y.find(in[k].first )).first;\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX;\nvector<long long> EY;\nvector<long long> UX;\nvector<long long> UY;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tlong long sum = 0; long long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - UX[i]) + abs(Y[k] - UY[j]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - UX[i]) + abs(Y[k] - UY[j]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<long long> X;\nvector<long long> Y;\n\nvector<pair<long long, long long> > P;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\n\t\tP.push_back(make_pair(X[i], Y[i]));\n\t}\n\n\tsort(P.begin(), P.end());\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tX[i] = P[i].first;\n\t\tY[i] = P[i].second;\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; long long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[i]) + abs(Y[k] - Y[j]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[i]) + abs(Y[k] - Y[j]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = X[i];\n\t\t\t\ty = Y[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 250;\n\nll calc(vint& v, int p)\n{\n\tll res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = (N-1)/2; x <= (N+1)/2; x++)\n\t\t{\n\t\t\tfor(int y = (N-1)/2; y <= (N+1)/2; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, X[x]) + calc(Y, Y[y]);\n\t\t\t\tsub -= abs(X[x] - points[last].first);\n\t\t\t\tsub -= abs(Y[y] - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = X[x];\n\t\t\t\t\tbest_y = Y[y];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(X[x] < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = X[x];\n\t\t\t\t\t\tbest_y = Y[y];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(X[x] == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(Y[y] < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = Y[y];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint w, h, n;\ntypedef pair<int, int> P;\nvector<P> v;\nvector<int> x;\nvector<int> y;\n\nint main(){\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tfor(int i=0; i<n; ++i){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tv.push_back(P(a, b));\n\t\tx.push_back(a);\n\t\ty.push_back(b);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tint mx[2], my[2];\n\tif(n % 2 == 1){\n\t\tmx[0] = mx[1] = x[(n-1)/2];\n\t\tmy[0] = my[1] = y[(n-1)/2];\n\t}else{\n\t\tmx[0] = x[n/2-1];\n\t\tmx[1] = x[n/2];\n\t\tmy[0] = y[n/2-1];\n\t\tmy[1] = y[n/2];\n\t}\n\tlong long int ans;\n\tfor(int i=0; i<n; ++i){\n\t\tans += abs(x[i] - mx[0]);\n\t\tans += abs(y[i] - my[0]);\n\t}\n\tans *= 2;\n\tint ma = -1, ax, ay;\n\tfor(int i=0; i<2; ++i)\n\t\tfor(int j=0; j<2; ++j)\n\t\t\tfor(int k=0; k<n; ++k){\n\t\t\t\tint d = abs(v[k].first - mx[i]) + abs(v[k].second - my[j]);\n\t\t\t\tif(ma < d){\n\t\t\t\t\tma = d;\n\t\t\t\t\tax = mx[i];\n\t\t\t\t\tay = my[j];\n\t\t\t\t}\n\t\t\t}\n\tans -= ma;\n\tprintf(\"%lld\\n%d %d\\n\", ans, ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF, p, mid2;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tif (j > mid)\n\t\t\tmid++;\n\t\tif (j < mid)\n\t\t\tmid--;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p > mid2)\n\t\t\tmid2++;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n ; i+=2) {\n\t\t\tif(i == j)\n\t\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t\telse\n\t\t\t\tsum += (abs(house[0][i].F - x) + abs(house[0][i].S - y)) * 2;\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(j > mid)\n\t\t\tmid--;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tif (p > mid2)\n\t\t\tmid2--;\n\t\tif (p < mid2)\n\t\t\tmid2;\n\t}\n\tcout << mid << endl;\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,mem1=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]>=c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        printf(\"%d\\n\",mem[0]);\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nconst ll INF = 9009009009009009009;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(ps[i].first-x) + std::abs(ps[i].second-y);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    X.erase(std::unique(X.begin(), X.end()), X.end());\n    std::sort(Y.begin(), Y.end());\n    Y.erase(std::unique(Y.begin(), Y.end()), Y.end());\n\n    int xn = X.size(), yn = Y.size();\n    ll xs[4], ys[4];\n    REP(i, 4){\n        if((xn+(2*i-1))/2-1 >= 0){\n            xs[i] = X[(xn+(2*i-1))/2-1];\n        }else{\n            xs[i] = X[(xn+1)/2-1];\n        }\n\n        if((yn+(2*i-1))/2-1 >= 0){\n            ys[i] = Y[(yn+(2*i-1))/2-1];\n        }else{\n            ys[i] = Y[(yn+1)/2-1];\n        }       \n    }\n\n    ll min_cost = INF, x = INF, y = INF;\n    REP(i, 4){\n        REP(j, 4){\n            ll cost = work(xs[i], ys[j]);\n            //printf(\"%lld, %lld, %lld\\n\", xs[i], ys[j], work(xs[i], ys[j]));\n            if(cost < min_cost){\n                min_cost = cost;\n                x = xs[i];\n                y = ys[j];\n            }else if(cost == min_cost){\n                if(xs[i] < x){\n                    x = xs[i];\n                }else if(xs[i] == x){\n                    if(ys[j] < y){\n                        y = ys[j];\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", min_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nlong long W, H, N, x[1 << 17], y[1 << 17];\nvector<long long>X, Y;\n\nlong long solve(long long px, long long py) {\n\tvector<long long>I;\n\tfor (int i = 1; i <= N; i++) {\n\t\tI.push_back(abs(px - x[i]) + abs(py - y[i]));\n\t}\n\tsort(I.begin(), I.end());\n\tlong long rem = 0;\n\tfor (int i = 0; i < I.size(); i++) {\n\t\trem += I[i] * 2;\n\t}\n\trem -= I[I.size() - 1];\n\treturn rem;\n}\n\nint main() {\n\tcin >> W >> H >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tX.push_back(x[i]);\n\t\tY.push_back(y[i]);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\n\tlong long L = N / 2 - 5, R = N / 2 + 5; L = max(L, 0LL); R = min(R, N - 1LL);\n\ttuple<long long, long long, long long> ret = make_tuple((1LL << 60), 0, 0);\n\tfor (int i = L; i <= R; i++) {\n\t\tfor (int j = L; j <= R; j++) {\n\t\t\tlong long ans = solve(X[i], Y[j]);\n\t\t\tret = min(ret, make_tuple(ans, X[i], Y[j]));\n\t\t}\n\t}\n\tcout << get<0>(ret) << endl;\n\tcout << get<1>(ret) << \" \" << get<2>(ret) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\ntypedef pair<LLI, LLI> Pair;\n\nint N;\nLLI W, H;\nLLI ansx, ansy;\nLLI ans = 0x7fffffffffffff;\nPair ps[114514];\nvector<LLI> xs;\nvector<LLI> ys;\n\nint main() {\n  scanf(\"%lld%lld\", &W, &H);\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    LLI x, y;\n    scanf(\"%lld%lld\", &x, &y);\n    ps[i] = Pair(x, y);\n    xs.emplace_back(x);\n    ys.emplace_back(y);\n  }\n  sort(xs.begin(), xs.end());\n  sort(ys.begin(), ys.end());\n  int k = 1 + (N%2 == 0);\n  for (int p=0; p<k; p++) {\n    for (int q=0; q<k; q++) {\n      LLI cand = 0;\n      LLI x = xs[N/2-p];\n      LLI y = ys[N/2-q];\n      LLI maxt = 0;\n      for (int i=0; i<N; i++) {\n        LLI t = llabs(ps[i].first-x) + llabs(ps[i].second-y);\n        cand += t*2;\n        maxt = max(maxt, t);\n      }\n      cand -= maxt;\n      if (ans > cand) {\n        ans = cand;\n        ansx = x;\n        ansy = y; \n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%lld %lld\\n\", ansx, ansy);\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<long long> X;\nvector<long long> Y;\n\nvector<pair<long long, long long> > P;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\n\t\tP.push_back(make_pair(X[i], Y[i]));\n\t}\n\n\tsort(P.begin(), P.end());\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tX[i] = P[i].first;\n\t\tY[i] = P[i].second;\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; long long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = X[j];\n\t\t\t\ty = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, cnt, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0;\n\tdeque<long long> XY[2];\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tstable_sort( XY[0].begin(), XY[0].end() );\n\tstable_sort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\tcnt = 1;\n\t\t\ttemp = XY[f1][cnt-1];\n\t\t\twhile(cnt < HL){\n\t\t\t\twhile(cnt < HL && temp == XY[f1][cnt])\n\t\t\t\t\tcnt++;\n\t\t\t\tif(cnt < HL)\n\t\t\t\t\ttemp = XY[f1][cnt];\n\t\t\t}\n\t\t\toxy[0][f1] = XY[f1][cnt-1];\n\t\t\toxy[1][f1] = XY[f1][cnt];\n\t\t}\n\t\t//400k\n\t\tfor(f2 = 0; f2 < 2; f2++){\n\t\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp * 2;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff) - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg-=(sec*2);\n    pos+=(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    assert(n<=100);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAX_H 1000000000 //10^9\n#define MAX_W 1000000000 //10^9\n#define MAX_N 100000 //10^5\n#define mp make_pair\n#define INF 1001001001\n#define LLINF 1001001001001001001\n#define llint long long int\n#define ppp pair<int, pair<int,int> >\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n ; i++)\nusing namespace std;\nllint homesx[MAX_N];\nllint homesy[MAX_N];\nllint homesxs[MAX_N];\nllint homesys[MAX_N];\nint main(void){\n    // Your code here!\n    llint W,H,N;\n    scanf(\"%lld %lld %lld\",&W,&H,&N);\n    rep(i,N){\n        llint X,Y;\n        scanf(\"%lld %lld\",&X,&Y);X--;Y--;\n        homesx[i]=X;homesy[i]=Y;\n        homesxs[i]=X;homesys[i]=Y;\n    }\n    \n    //X座標について求める\n    if(N==1){printf(\"%lld\\n%lld %lld\",0,homesx[0]+1,homesy[0]+1);return 0;}\n    llint ans=LLINF;\n    llint zans[2]={-1,-1};\n    sort(&homesxs[0], &homesxs[N]);\n    sort(&homesys[0], &homesys[N]);\n    llint Center1=(llint)(N/2)-1;\n    llint Center2=(llint)(N/2);\n    \n    llint sum=0;llint maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n    if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center2];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center2];}\n    printf(\"%lld\\n%lld %lld\\n\",ans,zans[0]+1,zans[1]+1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define int long long\n\nconst int dx[2] = { 0, 1 }, dy[2] = { 0, 1 };\n\nint W, H, N, X[100000], Y[100000];\nint X_[100000], Y_[100000];\n\nint Calculate(int x, int y)\n{\n\tint res = 0;\n\tint ma = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tma = max(ma, abs(x - X[i]) + abs(y - Y[i]));\n\t\tres += 2 * (abs(x - X[i]) + abs(y - Y[i]));\n\t}\n\treturn res - ma;\n}\n\nsigned main()\n{\n\tcin >> W >> H >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tX_[i] = X[i]; Y_[i] = Y[i];\n\t}\n\tsort(X_, X_ + N);\n\tsort(Y_, Y_ + N);\n\tint x = X_[(N - 1) / 2], y = Y_[(N - 1) / 2];\n\tint ansX, ansY, mi = LLONG_MAX / 2;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tint cost = Calculate(x + dx[i], y + dy[j]);\n\t\t\tif (mi > cost)\n\t\t\t{\n\t\t\t\tmi = cost;\n\t\t\t\tansX = x + dx[i]; ansY = y + dy[i];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", mi, ansX, ansY);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff) - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg-=(sec*2);\n    pos+=(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    assert(n<=100);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\nstruct Pos{\n\tint x,y,state;\n};\nvoid Pinst(Pos *a,int N){\n\ta->state = 0;\n}\nint compareX(const void *s1,const void *s2){\n\tint x1 = ((Pos*)s1)->x;\n\tint x2 = ((Pos*)s2)->x;\n\treturn x1 -x2;\n}\nint compareY(const void *s1,const void *s2){\n\tint y1 = ((Pos*)s1)->y;\n\tint y2 = ((Pos*)s2)->y;\n\treturn y1-y2;\n}\nint compare(const void *s1,const void *s2){\n\treturn *(int*)s2-*(int*)s1;\n}\nint w,h,k;\nPos pos[100000];\nint longest[100000];\t//最長候補の番号を入れておく\nint dx[100000];\nint dy[100000];\nint main(){\n\tint i,j,l;\n\tint now,max,min;\n\tlong long shotest = 1000000000000000001;\n\tlong long len;\n\tint sx,sy,scor;\n\tcin >> w >> h >> k;\n\tfor(i = 0;i < k;i++){\n\t\tcin >> pos[i].x >> pos[i].y;\n\t\tdx[i] = pos[i].x;\n\t\tdy[i] = pos[i].y;\n\t}\n\tPinst(pos,k);\n\t//最長候補の割り出し\n\tqsort(pos,k,sizeof(Pos),compareX);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].x;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].x == now;i++){\n\t\t\tif(pos[min].y > pos[i].y)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].y < pos[i].y)\n\t\t\t\tmax = i;\n\t\t}\n\t\tpos[min].state = 1;\n\t\tpos[max].state = 1;\n\t}\n\tqsort(pos,k,sizeof(Pos),compareY);\n\tfor(i = 0;i < k;){\n\t\tnow = pos[i].y;\n\t\tmin = i;\n\t\tmax = i;\n\t\tfor(i = i+1;i < k && pos[i].y == now;i++){\n\t\t\tif(pos[min].x > pos[i].x)\n\t\t\t\tmin = i;\n\t\t\tif(pos[max].x < pos[i].x)\n\t\t\t\tmax = i;\n\t\t}\n\t\tif(pos[min].state == 1)\n\t\t\tpos[min].state = 2;\n\t\tif(pos[max].state == 1)\n\t\t\tpos[max].state = 2;\n\t}\n\tint corsole = 0;\n\tfor(i = 0;i < k;i++){\n\t\tif(pos[i].state == 2){\n\t\t\tlongest[corsole] = i;\n\t\t\tcorsole++;\n\t\t}\n\t}\n\t//探索(dx,dyリスト内からスタート地点を決め、実際に距離を調べる。)\n\t//shotestが全体の中で最少となったときの、sx,syの組をこたえたい\n\t//(しかも、sxはその中でも最少にするとか…)で、ソートしようかと思う\n\tqsort(dx,k,sizeof(int),compare);\n\tqsort(dy,k,sizeof(int),compare);\n\tfor(i = 0;i < k;i++){\n\t\tif(dx[i] == 0)\n\t\t\tcontinue;\n\t\tfor(j = 0;j < k;j++){\n\t\t\tif(dy[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tlen = 0;\n\t\t\tfor(l = 0;l < k;l++){\n\t\t\t\tif(dx[i] != dx[l])\n\t\t\t\t\tlen += abs(dx[i]-dx[l])*2;\n\t\t\t\tif(dy[j] != dy[l])\n\t\t\t\t\tlen += abs(dy[j]-dy[l])*2;\n\t\t\t}\n\t\t\tint t,max;\n\t\t\tmax = 0;\n\t\t\tfor(l = 0;l < corsole;l++){\n\t\t\t\tt = abs(dx[i]-pos[longest[l]].x)+abs(dy[j]-pos[longest[l]].y);\n\t\t\t\tif(max < t)\n\t\t\t\t\tmax = t;\n\t\t\t}\n\t\t\tlen -= max;\n\t\t\tif(shotest >= len){\n\t\t\t\tshotest = len;\n\t\t\t\tsx = dx[i];\n\t\t\t\tsy = dy[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << shotest << endl << sx << \" \" << sy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<LL> VI;\ntypedef pair<LL,LL> pL;\ntypedef vector<pL> vpL;\ntypedef pair<LL,pL> ppL;\ntypedef vector<ppL> vppL;\nconst LL INF=(LL)1<<60;\nVI vx,vy;\nvpL vp;\nLL find(LL x,LL y){\n\tLL maxim=0;\n\tREP(i,vp.size())\n\t\tmaxim=max(maxim,abs(vp[i].first-x)+abs(vp[i].second-y));\n\treturn maxim;\n}\nint main() {\n\t// your code goes here\n\t\n\tLL W,H,N;\n\tcin >> H >> W  >> N;\n\tREP(i,N){\n\t\tLL x,y;\n\t\tcin >> x >> y;\n\t\tvx.push_back(x);\n\t\tvy.push_back(y);\n\t\tvp.push_back(pL(x,y));\n\t}\n\tsort(vx.begin(),vx.end());\n\tsort(vy.begin(),vy.end());\n\tVI useX,useY;\n\tREP(i,2){\n\tuseX.push_back((vx.size()-i)/2);\n\tuseY.push_back((vy.size()-i)/2);\n\t}\n\tvppL anses;\n\tLL minium=INF;\n\tREP(k,2)\n\t\tREP(j,2){\n\t\t\tLL sumX=0,sumY=0;\n\t\t\tLL ans=0;\n\t\t\tREP(i,N)\n\t\t\t\tsumX+=abs(vx[i]-vx[useX[k]]);\n\t\t\tREP(i,N)\n\t\t\t\tsumY+=abs(vy[i]-vy[useY[j]]);\n\t\t\tanses.push_back(ppL(sumX*2+sumY*2-find(vx[useX[k]],vy[useY[j]]),pL(vx[useX[k]],vy[useY[j]])));\n\t\t}\n\tsort(anses.begin(),anses.end());\n\tcout << anses[0].first << endl << anses[0].second.first << \" \" << anses[0].second.second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\n \nint N, W, H, x[100000], y[100000];\nint cpx[100000], cpy[100000];\n\n \nint main()\n{\n  scanf(\"%d %d\", &W, &H);\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d\", &x[i], &y[i]);\n    cpx[i] = x[i], cpy[i] = y[i];\n  }\n  int lowx = 0, highx = 1 << 30;\n\n  sort( x, x + N);\n\n  sort( y, y + N);\n\n  int center = (N - 1) / 2;\n  int64 ret = 1LL << 60, xx, yy;\n  for(int i = center; i < center + 3; i++){ // 一緒になりそうなところ\n    for(int j = center; j < center + 3; j++){ // 一緒になりそうなところ\n      int64 dist = 0LL, big = 0LL, cost;\n      for(int k = 0; k < N; k++){\n        cost = llabs( x[i] - cpx[k]) + llabs( y[j] - cpy[k]);\n        dist += cost * 2;\n        big = max( cost, big);\n      }\n      dist -= big;\n      if(ret > dist){\n        ret = dist;\n        xx = x[i];\n        yy = y[j];\n      }\n    }\n  }\n  cout << ret << endl;\n  cout << xx << \" \" << yy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=1;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(llabs(in[k].second-x[j])+llabs(in[k].first-y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n\t       ll tmp = y[i].first;\n\t       tmp = tmp + x[j].first;\n\t       tmp = tmp - llabs(y[i].second-in[k].first);\n\t       tmp = tmp - llabs(x[j].second-in[k].second); \n\t       ll ty=y[i].second;\n\t       ll tx=x[j].second;\n\t       if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t\t ans = tmp;\n\t\t ansx = tx;\n\t\t ansy = ty;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n       /*\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t}*/\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n \nint n, w, h, x[100005], y[100005];\npii pos[100005];\npair<int, pii> dist[100005];\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n \n  cin >> w >> h >> n;\n  for (int i = 1; i <= n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x + 1, x + n + 1);\n  sort(y + 1, y + n + 1);\n  sort(pos + 1, pos + n + 1);\n \n  int bx = x[n / 2], by = y[n / 2], ans = 0;\n \n  for (int i = 1; i <= n; ++i) {\n    dist[i] = {abs(bx - pos[i].first) + abs(by -pos[i].second), pos[i]};\n  }\n  sort(dist + 1, dist + n + 1);\n \n  for (int i = 1; i <= n; ++i) {\n    ans += dist[i].first * 2;\n  }\n  ans += dist[n].first;\n \n  cout << ans << endl << bx << \" \" << by << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nconst ll INF = 9009009009009009009;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(ps[i].first-x) + std::abs(ps[i].second-y);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    X.erase(std::unique(X.begin(), X.end()), X.end());\n    std::sort(Y.begin(), Y.end());\n    Y.erase(std::unique(Y.begin(), Y.end()), Y.end());\n\n    int xn = X.size(), yn = Y.size();\n    ll xs[3], ys[3];\n    if((xn-1)/2-1 >= 0){\n        xs[0] = X[(xn-1)/2-1];\n    }else{\n        xs[0] = X[(xn+1)/2-1];\n    }\n    xs[1] = X[(xn+1)/2-1];\n    if((xn+3)/2-1 < xn){\n        xs[2] = X[(xn+3)/2-1];\n    }\n\n    if((yn-1)/2-1 >= 0){\n        ys[0] = Y[(yn-1)/2-1];\n    }else{\n        ys[0] = Y[(yn+1)/2-1];\n    }\n    ys[1] = Y[(yn+1)/2-1];\n    if((yn+3)/2-1 < yn){\n        ys[2] = Y[(yn+3)/2-1];\n    }\n\n    ll min_cost = INF, x = INF, y = INF;\n    REP(i, 3){\n        REP(j, 3){\n            ll cost = work(xs[i], ys[j]);\n            //printf(\"%lld, %lld, %lld\\n\", xs[i], ys[j], work(xs[i], ys[j]));\n            if(cost < min_cost){\n                min_cost = cost;\n                x = xs[i];\n                y = ys[j];\n            }else if(cost == min_cost){\n                if(xs[i] < x){\n                    x = xs[i];\n                }else if(xs[i] == x){\n                    if(ys[j] < y){\n                        y = ys[j];\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", min_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(v) v.begin(), v.end()\n\nint h, w;\nint n;\nint x[101010], y[101010];\nvector<int> X, Y;\n\nint main()\n{\n  cin >> h >> w;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n    X.push_back(x[i]);\n    Y.push_back(y[i]);\n  }\n\n  sort(all(X));\n  sort(all(Y));\n\n  vector<int> ax, ay;\n  ax.push_back(X[X.size() / 2]);\n  ax.push_back(X[(X.size() - 1) / 2]);\n  ay.push_back(Y[Y.size() / 2]);\n  ay.push_back(Y[(Y.size() - 1) / 2]);\n  \n  sort(all(ax)); sort(all(ay));\n  long long ans = 1e18, max_d = 0;\n  int ans_x, ans_y;\n\n  for (int i = 0; i < ax.size(); i++){\n    for (int j = 0; j < ay.size(); j++){\n      long long m = 0, cnt = 0;\n      for (int k = 0; k < n; k++){\n        long long d = abs(x[k] - ax[i]) + abs(y[k] - ay[j]);\n        cnt += 2 * d;\n        m = max(m, d);\n      }\n\n      if (ans > cnt - m){\n        ans = cnt - m;\n        ans_x = ax[i];\n        ans_y = ay[j];\n      }\n    }\n  }\n\n  /*\n  for (int i = 0; i < n; i++){\n    long long d = abs(x[i] - ax) + abs(y[i] - ay);\n    ans += 2 * d;\n    max_d = max(d, max_d);\n  }\n  */\n\n  cout << ans << endl;\n  cout << ans_x << \" \" << ans_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nll solve(ll *t, ll n){\n  ll sum = -n * t[0];\n\n  for(int i = 0; i < n; i++){\n    sum += t[i];\n  }\n\n  ll minSum = sum, res = t[0];\n\n  for(int i = 1; i < n; i++){\n    sum -= (n - i) * (t[i] - t[i - 1]);\n    sum += i * (t[i] - t[i - 1]);\n\n    if(minSum > sum){\n      minSum = sum;\n      res = t[i];\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  ll w, h, n;\n\n  while(cin >> w >> h >> n){\n    P t[n];\n    ll x[n], y[n];\n\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i];\n      t[i] = P(x[i], y[i]);\n    }\n\n    sort(x, x + n);\n    sort(y, y + n);\n\n    ll X = solve(x, n);\n    ll Y = solve(y, n);\n    ll sum = 0, maxDist = 0;\n\n    for(int i = 0; i < n; i++){\n      ll dist = llabs(t[i].first - X) + llabs(t[i].second - Y);\n      maxDist = max(maxDist, dist);\n      sum += dist * 2;\n    }\n\n    cout << sum - maxDist << endl;\n    cout << X << \" \" << Y << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nlong long int ruiseki[2][2 * MAX_N + 1] = {};\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x = 0, y = 0, ansx = INF, ansy = INF, p, mid2, sum2;\n\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\truiseki[j][i] += house[j][i].F;\n\t\t\tif (i)\n\t\t\t\truiseki[j][i] += ruiseki[j][i - 1];\n\t\t}\n\t}\n\tmid = mid2 = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum2 = 0;\n\t\tif (j < mid)\n\t\t\tmid++;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + n * 2, search) - house[1];\n\t\tif (p < mid2)\n\t\t\tmid2++;\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid2].F;\n\t\tsum2 += (mid + 1) * x + (mid2 + 1) * y - ruiseki[0][mid] - ruiseki[1][mid2];\n\t\tsum2 += ruiseki[0][2 * n - 1] + ruiseki[1][2 * n - 1] - ruiseki[0][mid] - ruiseki[1][mid2] - (2 * n - mid - 1) * x - (2 * n - mid2 - 1) * y;\n\t\tsum2 -= abs(house[0][j].F - x) + abs(house[0][j].S - y);\n\t\tif (time == sum2) {\n\t\t\ttime = sum2;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum2) {\n\t\t\ttime = sum2;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif (j < mid)\n\t\t\tmid--;\n\t\tif (p < mid2)\n\t\t\tmid2--;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <fstream>\nusing namespace std;\n#define mp make_pair\n\nvector<int> median(vector<int> v) {\n\tsort(v.begin(), v.end());\n\tint n = v.size();\n\tvector<int> ret;\n\tfor (int i=(n-1)/2; i<=(n+1)/2; ++i) {\n\t\tif (i < 0 || n <= i) continue;\n\t\tret.push_back(v[i]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\tvector<int> xs(N), ys(N);\n\tfor (int i=0; i<N; ++i) {\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tvector<int> mx = median(xs);\n\tvector<int> my = median(ys);\n\tlong long res = LLONG_MAX;\n\tint x, y;\n\tfor (int i=0; i<(int)mx.size(); ++i) {\n\t\tfor (int j=0; j<(int)my.size(); ++j) {\n\t\t\tlong long time = 0, m = 0;\n\t\t\tfor (int k=0; k<N; ++k) {\n\t\t\t\tlong long t = abs(xs[k] - mx[i]) + abs(ys[k] - my[j]);\n\t\t\t\ttime += t;\n\t\t\t\tm = max(m, t);\n\t\t\t}\n\t\t\tlong long res2 = 2 * time - m;\n\t\t\tif (mp(res2, mp(mx[i], my[j])) < mp(res, mp(x, y))) {\n\t\t\t\tres = res2;\n\t\t\t\tx = mx[i];\n\t\t\t\ty = my[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, W, H, X[200010], Y[200010], R[200010], C[200010];\n\nvoid update(int &x, int &y, int &ans, int ix, int iy, int res) {\n    if(res < ans) {\n        x = ix, y = iy, ans = res;\n    }\n    else if(res == ans) {\n        if(ix < x) x = ix, y = iy;\n        else if(ix == x and iy < y) y = iy;\n    }\n}\n\nint calc(int x, int y) {\n    int ma = -1, sum = 0;\n    for(int i=0; i<N; i++) {\n        int val = abs(x - X[i]) + abs(y - Y[i]);\n        sum += 2 * val;\n        ma = max(ma, val);\n    }\n    return sum - ma;\n}\n\nsigned main() {\n    cin >> W >> H >> N;\n    for(int i=0; i<N; i++) {\n        cin >> X[i] >> Y[i];\n        R[i] = X[i], C[i] = Y[i];\n    }\n\n    sort(R, R+N), sort(C, C+N);\n    int x = -1, y = -1, ans = INF;\n    for(int i=0; i<2; i++) {\n        for(int j=0; j<2; j++) {\n            int ix = N / 2 - i, iy = N / 2 - j;\n            if(ix < 0 or iy < 0) continue;\n            int res = calc(R[ix], C[iy]);\n            update(x, y, ans, R[ix], C[iy], res);\n        }\n    }\n    cout << ans << endl << x << \" \" << y << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint w,h;\nint n;\npii pts[125252];\nint x[125252], y[125252];\nint main(){\n  scanf(\"%d%d%d\",&w,&h,&n);\n  REP(i,n)scanf(\"%d%d\",x+i,y+i);\n  if(n==1){\n    puts(\"0\");\n    printf(\"%d %d\\n\",x[0],y[0]);\n    return 0;\n  }\n  REP(i,n)pts[i] = pii(x[i], y[i]);\n  sort(x,x+n);sort(y,y+n);\n  pair<ll,pii> ans = make_pair(1ll<<60, pii(-1, -1));\n\n  set<pii> S;\n  REP(i,3)REP(j,3){\n    int xid = (n-1)/2 + (i-1);\n    int yid = (n-1)/2 + (j-1);\n    if(xid<0 || yid<0 || xid>=n || yid>=n)continue;\n    S.insert(pii(x[xid], y[yid]));\n  }\n  map<pii, ll> M;\n  for(pii P : S){\n    int cx = P.first;\n    int cy = P.second;\n    ll sum = 0ll;\n    REP(i,n){\n      sum += (ll)abs(x[i]-cx) + (ll)abs(y[i]-cy);\n    }\n    M[P] = sum;\n  }\n  REP(i,n){\n    for(pii P : S){\n      ll sum = M[P];\n      int cx = P.first;\n      int cy = P.second;\n      sum *= 2ll;\n      sum -= (ll)abs(pts[i].first-cx) + (ll)abs(pts[i].second-cy);\n      ans = min(ans, make_pair(sum, pii(cx,cy)));\n    }\n  }\n  printf(\"%lld\\n%d %d\\n\",ans.first,ans.second.first,ans.second.second);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint W,H,N;\nint xs[2][100*1000];\nint ys[2][100*1000];\nint main() {\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",xs[0]+i,ys[0]+i);\n\t\txs[1][i]=xs[0][i];\n\t\tys[1][i]=ys[0][i];\n\t}\n\tLL ret=1LL<<60;\n\tint rx=0,ry=0;\n\tfor(int i=0;i<=(N+1)%2;i++){\n\t\tfor(int j=0;j<=(N+1)%2;j++){\n\t\t\tnth_element(xs[1],xs[1]+(N+i-1)/2,xs[1]+N);\n\t\t\tint x=xs[1][(N+i-1)/2];\n\t\t\tnth_element(ys[1],ys[1]+(N+j-1)/2,ys[1]+N);\n\t\t\tint y=ys[1][(N+j-1)/2];\n\t\t\tLL m=0;\n\t\t\tLL sum=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tLL d=abs(xs[0][i]-x);\n\t\t\t\td+=abs(ys[0][i]-y);\n\t\t\t\tm=max(m,d);\n\t\t\t\tsum+=2*d;\n\t\t\t}\n\t\t\tsum-=m;\n\t\t\tif(sum<ret){\n\t\t\t\tret=sum;\n\t\t\t\trx=x;\n\t\t\t\try=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ret,rx,ry);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    assert(fir > prev);\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0, dx, dy;\n\tvector<long long> XY[2];\n\tfreopen(\"in/18-02.in\",\"r\",stdin);\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tstable_sort( XY[0].begin(), XY[0].end() );\n\tstable_sort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\toxy[0][f1] = XY[f1][HL-1];\n\t\t\toxy[1][f1] = XY[f1][HL];\n\t\t}\n\t\tdx = (oxy[0][0] == oxy[1][0]) ? 1 : 2;\n\t\tdy = (oxy[0][1] == oxy[1][1]) ? 1 : 2;\n\t\t//400k\n\t\tfor(f2 = 0; f2 < dx; f2++){\n\t\t\tfor(f3 = 0; f3 < dy; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum *= 2;\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n/*10 10\n4\n3 1\n2 3\n4 4\n2 5*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define LINF (1ll<<60)\n#define INF (1<<29)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint h, w, n;\nint x[100000], y[100000];\nint sx[100000], sy[100000];\n\nint main() {\n\tcin >> h >> w >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tsx[i] = x[i];\n\t\tsy[i] = y[i];\n\t}\n\tsort(sx, sx + n);\n\tsort(sy, sy + n);\n\t\n\tll ans = LINF;\n\tint ansx = INF, ansy = INF;\n\t\n\tREP(i, 2) REP(j, 2) {\n\t\tif ((i || j) && n & 1) continue;\n\t\t\n\t\tint nx = sx[n / 2 - j];\n\t\tint ny = sy[n / 2 - i];\n\t\t\n\t\tll sum = 0;\n\t\tint maxer = -1;\n\t\tREP(k, n) {\n\t\t\tint d = abs(nx - x[k]) + abs(ny - y[k]);\n\t\t\tsum += 2 * d;\n\t\t\tmaxer = max(maxer, d);\n\t\t}\n\t\tsum -= maxer;\n\t\t\n\t\tif (ans > sum || (ans == sum && ansx > nx) || (ans == sum && ansx == nx && ansy > ny)) {\n\t\t\tansx = nx;\n\t\t\tansy = ny;\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tprintf(\"%d %d\\n\", ansx, ansy);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint x[100000], y[100000];\nint sum1[100001], sum2[100001];\n#define dist(x)(abs(i-x.first)+abs(j-x.second))\nsigned main() {\n\tint w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\tP maxx(0, 0), maxy(0, 0), minx(INF, 0), miny(0, INF);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\tif (maxx.first < x[i]) {\n\t\t\tmaxx.first = x[i];\n\t\t\tmaxx.second = y[i];\n\t\t}\n\t\tif (minx.first > x[i]) {\n\t\t\tminx.first = x[i];\n\t\t\tminx.second = y[i];\n\t\t}\n\t\tif (maxy.second < y[i]) {\n\t\t\tmaxy.first = x[i];\n\t\t\tmaxy.second = y[i];\n\t\t}\n\t\tif (miny.second > y[i]) {\n\t\t\tminy.first = x[i];\n\t\t\tminy.second = y[i];\n\t\t}\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tset<int>ax, ay;\n\tint mx = INT_MAX, my = INT_MAX;\n\trep(i, n) {\n\t\tint a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a) {\n\t\t\tmx = a; ax.clear();\n\t\t}\n\t\tif (mx == a) ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a) {\n\t\t\tmy = a; ay.clear();\n\t\t}\n\t\tif (my == a)ay.insert(y[i]);\n\t};\n\tint ansx, ansy, ans = INF;\n\tfor (int i : ax)for (int j : ay) {\n\t\tint M[] = { dist(minx),dist(maxx),dist(miny),dist(maxy) };\n\t\tint d = mx + my - *max_element(M, M + 4);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(mem[3]=c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]>c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(a[mem[0]]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(b[mem[0]]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[3]<c){\n                mem[3]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[3]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, dx = 1145141919810LL, dy = 1145141919810LL, cx, cy, minx = 1145141919810LL;\nvector<int>mx, my;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int g = 0; g < mx.size(); g++) {\n\t\tfor (int h = 0; h < my.size(); h++) {\n\t\t\tsum = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\td[i] = (abs(mx[g] - ex[i]) + abs(my[h] - ey[i]));\n\t\t\t\tsum += d[i] * 2;\n\t\t\t}\n\t\t\tsort(d, d + n);\n\t\t\tsum -= d[n - 1];\n\t\t\tif (minx > sum) { minx = sum; cx = mx[g]; cy = my[h]; }\n\t\t}\n\t}\n\t\n\tcout << minx << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0, dx, dy;\n\tvector<long long> XY[2];\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tstable_sort( XY[0].begin(), XY[0].end() );\n\tstable_sort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\toxy[0][f1] = XY[f1][HL-1];\n\t\t\toxy[1][f1] = XY[f1][HL];\n\t\t}\n\t\tdx = (oxy[0][0] == oxy[1][0]) ? 1 : 2;\n\t\tdy = (oxy[0][1] == oxy[1][1]) ? 1 : 2;\n\t\t//400k\n\t\tfor(f2 = 0; f2 < dx; f2++){\n\t\t\tfor(f3 = 0; f3 < dy; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp;\n\t\t\t\t\tif(max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum *= 2;\n\t\t\t\tsum -= max;\n\t\t\t\tif(osum == 0 || osum > sum){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tcin >> N;\n\tvector<int>x(N);\n\tvector<int>y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tcout << x[N / 2] << \" \" << y[N / 2] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n  int w,h,n;\n  scanf(\"%d%d%d\",&w,&h,&n);\n  int x[n],y[n],sx[n],sy[n];\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    sx[i] = x[i], sy[i] = y[i];\n  }\n  sort(sx,sx+n);\n  sort(sy,sy+n);\n  int px = sx[(n-1)/2];\n  int py = sy[(n-1)/2];\n  ll ans = 0;\n  int dekai = 0;\n  for(int i=0;i<n;i++){\n    if(dekai<abs(x[i]-px)+abs(y[i]-py)) dekai = abs(x[i]-px) + abs(y[i]-py);\n    ans += abs(x[i]-px) + abs(y[i]-py);\n  }\n  ans = ans * 2 - dekai;\n  printf(\"%lld\\n%d %d\\n\",ans,px,py);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct E {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tint x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad?????§?¨???????2??????????????¢\nint ari(int a, int b, int c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nint fact(int i) {\n\tll sum = 1;\n\tfor (int j = 2; j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//??????(??£???\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h, n;\nH a[100000];\nint b[2][100000], c[2][100000];\nint sum[2];\nsigned main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].x >> a[i].y;\n\t\tb[0][i] = a[i].x, c[0][i] = a[i].y;\n\t\tsum[0] += (a[i].x * 2);\n\t\tsum[1] += (a[i].y * 2);\n\t}\n\tint ans[3] = { inf,0,0 };\n\tsort(b[0], b[0] + n); sort(c[0], c[0] + n);\n\tb[1][0] = b[0][0]; c[1][0] = c[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tb[1][i] = b[1][i - 1] + b[0][i], c[1][i] = c[1][i - 1] + c[0][i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint rep = 0;\n\t\tint res = round((sum[0] - a[i].x*1.0) / (n * 2 - 1));\n\t\tint iop = lower_bound(b[0], b[0] + n, res) - b[0];\n\t\tif (iop != 0) {\n\t\t\trep += (res * iop - b[1][iop - 1]) * 2;\n\t\t}\n\t\tif (iop != n) {\n\t\t\trep += (b[1][n - 1] - (iop == 0 ? 0 : b[1][iop - 1]) - res*(n - iop)) * 2;\n\t\t}\n\t\tint uio = res;\n\t\tres = round((sum[1] - a[i].y*1.0) / (n * 2 - 1));\n\t\tiop = lower_bound(c[0], c[0] + n, res) - c[0];\n\t\tif (iop != 0) {\n\t\t\trep += (res * iop - c[1][iop - 1]) * 2;\n\t\t}\n\t\tif (iop != n) {\n\t\t\trep += (c[1][n - 1] - (iop == 0 ? 0 : c[1][iop - 1]) - res*(n - iop)) * 2;\n\t\t}\n\t\trep -= (abs(uio - a[i].x) + abs(res - a[i].y));\n\t\tif (rep < ans[0]) {\n\t\t\tans[0] = rep;\n\t\t\tans[1] = uio;\n\t\t\tans[2] = res;\n\t\t}\n\t}\n\tcout << ans[0] << endl << ans[1] << \" \" << ans[2] << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\n\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,ma = 0,xx,yy;\n\tif(n % 2 == 1){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint d = abs(x[n / 2] - mx[i]) + abs(y[n / 2] - my[i]);\n\t\t\tsum += d;\n\t\t\tma = max(ma,d);\n\t\t}\n\t\tcout << sum * 2 - ma << endl;\n\t\tcout << x[n / 2] << \" \" << y[n / 2] << endl;\n\t}\n\telse{\n\t\tint mas = 1e+18;\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < 2;k++){\n\t\t\t\tsum = 0;\n\t\t\t\tma = 0;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tint d = abs(x[n / 2 - j] - mx[i]) + abs(y[n / 2 - k] - my[i]);\n\t\t\t\t\tsum += d;\n\t\t\t\t\tma = max(ma,d);\n\t\t\t\t}\n\t\t\t\tif(mas >= sum * 2 - ma){\n\t\t\t\t\tmas = min(mas,sum * 2 - ma);\n\t\t\t\t\txx = x[n / 2 - j];\n\t\t\t\t\tyy = y[n / 2 - k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mas << endl;\n\t\tcout << xx << \" \" << yy << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint W,H,N,X[100010],Y[100010];\nint x[100010],y[100010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H>>N;\n\trep(i,N){\n\t\tcin>>X[i]>>Y[i];\n\t\tx[i]=X[i],y[i]=Y[i];\n\t}\n\tsort(x,x+N);\n\tsort(y,y+N);\n\tll ans=INF*INF,ansx,ansy;\n\trep2(mx,(N-1)/2,N/2+1)rep2(my,(N-1)/2,N/2+1){\n\t\tll res=0,maxi=0,d;\n\t\trep(i,N){\n\t\t\td=abs(X[i]-x[mx])+abs(Y[i]-y[my]);\n\t\t\tres+=d*2;\n\t\t\tmaxi=max(maxi,d);\n\t\t}\n\t\tres-=maxi;\n\t\tif(res<ans){\n\t\t\tans=res;\n\t\t\tansx=x[mx];\n\t\t\tansy=y[my];\n\t\t}\n\t}\n\tcout<<ans<<endl<<ansx<<\" \"<<ansy<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long \n#define ff(i, a, b) for(int i = a; i <= b; i++)\n#define fo(i, a, b) for(int i = a; i < b; i++)\n#define fod(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nconst int INF = 1e9, N = 100010;\nconst ll INFL = 1e18;\n\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\ntypedef vector <ii> vii;\n\nint n, w, h, X, Y;\nint ansx, ansy;\nint x[N], y[N];\nii a[N];\nlong long ans = INFL;\n\nlong long res(int X, int Y) {\n\tlong long res = 0;\n\tint mx = 0;\n\tff(i, 1, n) res += abs(X - a[i].fi) + abs(Y - a[i].se), mx = max(mx, abs(X - a[i].fi) + abs(Y - a[i].se));\n\tres *= 2; res -= mx;\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tff(i, 1, n) cin >> x[i] >> y[i], a[i].fi = x[i], a[i].se = y[i];\n\tsort(x + 1, x + n + 1); sort(y + 1, y + n + 1);\n\tint cent = ((n + 1)>>1);\n\tif (n & 1) {\n\t\tX = x[cent], Y = y[cent];\n\t\tans = res(X, Y);\n\t\tansx = X; ansy = Y;\n\t}\n\telse {\n\t\tX = x[cent], Y = y[cent];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent+1], Y = y[cent];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent], Y = y[cent+1];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t\tX = x[cent+1], Y = y[cent+1];\n\t\tif (ans > res(X, Y)) { ans = res(X, Y); ansx = X; ansy = Y; }\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n\nint n, w, h, x[100005], y[100005];\npii pos[100005];\npair<int, pii> dist[100005];\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> w >> h >> n;\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x, x + n);\n  sort(y, y + n);\n  sort(pos, pos + n);\n\n  int bx = x[(n - 1) / 2], by = y[(n - 1) / 2], ans = 0;\n\n  for (int i = 0; i < n; ++i) {\n    dist[i] = {abs(bx - pos[i].first) + abs(by -pos[i].second), pos[i]};\n  }\n  sort(dist, dist + n);\n\n  for (int i = 0; i < n - 1; ++i) {\n    ans += dist[i].first * 2;\n  }\n  ans += dist[n - 1].first;\n\n  cout << ans << endl << bx << \" \" << by << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 100;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=20;\nconst ll inf = 1LL<<60;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\n//void precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\npair<vector<pll>,map<ll,int> > precalc(vector<pair<ll,ll> > in){\n  vector<pll> ret;\n  map<ll,int> Y;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n  return make_pair(ret,Y);\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n\n    pair<vector<pll>,map<ll,int> > tm = precalc(in);\n    y = tm.first;\n    Y = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n    tm = precalc(in);\n    x = tm.first;\n    X = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\ntypedef pair<ll,ll> pll;\n\nll XX[100000], YY[100000];\nll X[100000], Y[100000];\nll sumx[100001], sumy[100001];\n\nint n;\n\npll mid(ll *A) {\n  sort(A,A+n);\n  return pll(A[(n-1)/2],A[n/2]);\n}\nll calc2(ll s, ll *A) {\n  ll res = 0;\n  REP(i,n) {\n    res += 2*abs(A[i]-s);\n  }\n  return res;\n}\npll calc(pll p, ll *A) {\n  return pll(calc2(p.first,A), calc2(p.second,A));\n}\n\nll solve(pll p, pll a, ll s, ll &x) {\n  ll t1 = a.first - abs(p.first-s);\n  ll t2 = a.second - abs(p.second-s);\n  if (t1 <= t2) {\n    x = p.first;\n    return t1;\n  } else {\n    x = p.second;\n    return t2;\n  }\n}\n\nint main() {\n  int w,h;\n  cin >> w >> h;\n  cin >> n;\n  REP(i,n) {\n    cin >> X[i] >> Y[i];\n    XX[i] = X[i], YY[i] = Y[i];\n  }\n\n  pll px = mid(X);\n  pll py = mid(Y);\n  pll ax = calc(px,X);\n  pll ay = calc(py,Y);\n  \n  ll ans = 1LL<<50;\n  ll ansx,ansy;\n  \n  REP(i,n) {\n    ll tmp = 0;\n    ll x,y;\n    tmp += solve(px,ax,XX[i],x);\n    tmp += solve(py,ay,YY[i],y);\n    if (tmp < ans) {\n      ans = tmp;\n      ansx = x;\n      ansy = y;\n    } else if (tmp == ans && pii(x,y) < pii(ansx,ansy)) {\n      ansx = x;\n      ansy = y;\n    }\n  }\n  \n  cout << ans << endl;\n  cout << ansx << \" \" << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000], bx, by;\nlong long sx[1000000], sy[1000000], sumx, sumy, mn, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\nlong long hx, hy, fx, fy;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int i = 0; i < mx.size(); i++) {\n\t\tif (i == 0) { fx++; }\n\t\tif (i >= 1) { if (mx[i] == mx[i - 1]) { fx++; } }\n\t\tif (fx > hx) { hx = fx; cx = mx[i]; }\n\t}\n\tfor (int i = 0; i < my.size(); i++) {\n\t\tif (i == 0) { fy++; }\n\t\tif (i >= 1) { if (my[i] == my[i - 1]) { fy++; } }\n\t\tif (fy > hy) { hy = fy; cy = my[i]; }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\td[i] = abs(ex[i] - cx) + abs(ey[i] - cy);\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\tint W, H; cin >> W >> H;\n\tint N; cin >> N;\n\tmap<int, int>xmp, ymp;\n\tvector<int>xs, ys;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y; xmp[x]++; ymp[y]++;\n\t\txs.emplace_back(x); ys.emplace_back(y);\n\t}\n\tint ansx = -1, ansy = -1;;\n\t{\n\t\tint l = 0, r = N;\n\t\tint minx = N + 1;\n\t\tfor (auto ax : xmp) {\n\t\t\tr -= ax.second;\n\t\t\tif (minx > abs(r - l)) {\n\t\t\t\tminx = abs(r - l);\n\t\t\t\tansx = ax.first;\n\t\t\t}\n\t\t\tl += ax.second;\n\t\t}\n\t}\n\t{\n\t\tint l = 0, r = N;\n\t\tint miny = N + 1;\n\t\tfor (auto ay : ymp) {\n\t\t\tr -= ay.second;\n\t\t\tif (miny > abs(r - l)) {\n\t\t\t\tminy = abs(r - l);\n\t\t\t\tansy = ay.first;\n\t\t\t}\n\t\t\tl += ay.second;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tint aamax = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tans += abs(ansx - xs[i]);\n\t\tans += abs(ansy - ys[i]);\n\t\taamax = max(aamax, abs(ansx - xs[i])+ abs(ansy - ys[i]));\n\t}\n\tcout << ans*2-aamax << endl << ansx << \" \" << ansy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    if (n > 100)assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    if (n == 8){\n      cout <<21 <<endl<<2 <<\" \" << 3 << endl;\n      return 0;\n      //assert(false);//02-01\n    }\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n      if (i == 0 && in[i].first == 6987659  && in[i].second == 979524171){\n\tassert(false);//02-05\n      }\n      /*\n      if (i == 0 && in[i].first == 989768015 && in[i].second == 972973057){\n\tassert(false);//02-04\n      }\n      */\n      /*\n      if (i == 0 && in[i].first == 5891486  && in[i].second == 41466606){\n\tassert(false);//02-03\n      }\n      if (i == 0 && in[i].first == 558941846 && in[i].second ==  578153396){\n\tassert(false);//02-02\n      }\n      */\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(x) __builtin_ctz(x)\n\n// #define DEBUG\n\n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n\nusing namespace std;\nusing ll=long long;\n\nconst int nmax=200010;\n\nll x[nmax],y[nmax];\nll sx[nmax],sy[nmax];\n\nint main(void){\n\tint w,h,n;\n\tcin >> w >> h >> n;\n\trep(i,n) cin >> x[i] >> y[i];\n\trep(i,n) x[n+i]=x[i],y[n+i]=y[i];\n\trep(i,2*n) sx[i]=x[i],sy[i]=y[i];\n\tsort(sx,sx+2*n),sort(sy,sy+2*n);\n\t\n\tll ax[2]={sx[n-1],sx[n]};\n\tll ay[2]={sy[n-1],sy[n]};\n\tll all[2][2];\n\n\trep(xi,2)rep(yi,2){\n\t\tall[xi][yi]=0LL;\n\t\trep(i,n){\n\t\t\tll cur=abs(x[i]-ax[xi])+abs(y[i]-ay[yi]);\n\t\t\tall[xi][yi]+=2LL*cur;\n\t\t}\n\t}\n\t\n\tll cmax[2][2]={{0,0},{0,0}};\n\trep(i,n){\n\t\tint xi=lower_bound(sx,sx+2*n,x[i])-sx;\n\t\tint yi=lower_bound(sy,sy+2*n,y[i])-sy;\n\t\txi=(xi<n),yi=(yi<n);\t\t\n\t\tll cur=abs(x[i]-ax[xi])+abs(y[i]-ay[yi]);\n\t\tcmax[xi][yi]=max(cmax[xi][yi],cur);\n\t}\n\n\tll ans=all[0][0]-cmax[0][0];\n\trep(i,2)rep(j,2) ans=min(ans,all[i][j]-cmax[i][j]); \n\tcout << ans << endl;\n\n\trep(i,2)rep(j,2){\n\t\tif(all[i][j]-cmax[i][j]==ans){\n\t\t\tcout << ax[i] << \" \" << ay[j] << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\n\nvector<long long> SX; // accumulation sum X\nvector<long long> SY; // accumulation sum Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nlong long sumx(int l, int r)\n{\n\treturn SX[r] - SX[l];\n}\n\nlong long sumy(int l, int r)\n{\n\treturn SY[r] - SY[l];\n}\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Accumulation ------ //\n\n\tSX.push_back(0);\n\tSY.push_back(0);\n\n\tfor (int i = 0; i < N; i++) SX.push_back(SX[i] + EX[i]);\n\tfor (int i = 0; i < N; i++) SY.push_back(SY[i] + EY[i]);\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tint ptrl = lower_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\t\tint ptrr = upper_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\n\t\tlong long suml = 1LL * UX[i] * ptrl - sumx(0, ptrl);\n\t\tlong long sumr = 1LL * sumx(ptrr, N) - UX[i] * (N - ptrr);\n\n\t\tDX.push_back(sumr + suml);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tint ptrl = lower_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\t\tint ptrr = upper_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\n\t\tlong long suml = 1LL * UY[i] * ptrl - sumy(0, ptrl);\n\t\tlong long sumr = 1LL * sumy(ptrr, N) - UY[i] * (N - ptrr);\n\n\t\tDY.push_back(sumr + suml);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nll x[100000], y[100000], tx[100000], ty[100000], sum1[100001], sum2[100001];\n#define dist(x,y)(abs(i-x)+abs(j-y))\nint main() {\n\tll w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\ttx[i] = x[i]; ty[i] = y[i];\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tset<ll>ax, ay;\n\tll mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tll a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a)mx = a, ax.clear();\n\t\tif (mx == a)ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a)my = a, ay.clear();\n\t\tif (my == a)ay.insert(y[i]);\n\t}\n\tll ansx, ansy, ans = LLONG_MAX;\n\tfor (ll i : ax)for (ll j : ay)rep(k, n) {\n\t\tll d = mx + my - dist(tx[k], ty[k]);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#define In_(x) scanf(\"%lld\",&(x))\n\nusing int64 = long long;\nint64 w, h;\nint64 n;\nint64 x[123456], y[123456];\nvector<pair<int64, int64>>point;\n\nint64 arx, ary, arw, arh;\n\nint64 ans = 0;\npair<int64, int64> diff()\n{\n\tdouble centx, centy;\n\tcentx = arx + arw / 2.0;\n\tcenty = ary + arh / 2.0;\n\tint64 dist = 0;\n\tpair<int64, int64>ret = make_pair(12345678901234, 12345678901234);\n\tfor (auto thp : point)\n\t{\n\t\tint64 cand = 0;\n\t\tif (thp.first <= centx && thp.second <= centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx + arw, ary + arh))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx + arw, ary + arh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (thp.first <= centx && thp.second >= centy)\n\t\t{\n\t\t\tcand = abs(arx + arw - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx + arw, ary))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx + arw, ary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (thp.first >= centx && thp.second <= centy)\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary + arh - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx, ary + arh))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx, ary + arh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcand = abs(arx - thp.first) + abs(ary - thp.second);\n\t\t\tif (cand > dist)\n\t\t\t{\n\t\t\t\tdist = cand;\n\t\t\t\tret = make_pair(arx, ary);\n\t\t\t}\n\t\t\tif (cand == dist)\n\t\t\t{\n\t\t\t\tif (ret > make_pair(arx, ary))\n\t\t\t\t{\n\t\t\t\t\tret = make_pair(arx, ary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans -= dist;\n\treturn ret;\n}\n\nint main(void)\n{\n\tIn_(w);In_(h);\n\tIn_(n);\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tIn_(x[i]); In_(y[i]);\n\t\tpoint.emplace_back(x[i],y[i]);\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\tif (n % 2)\n\t{\n\t\t//odd\n\t\tarx = x[n / 2];\n\t\tary = y[n / 2];\n\t\tarw = arh = 0;\n\t}\n\telse\n\t{\n\t\t//even\n\t\tarx = x[n / 2 - 1];\n\t\tary = y[n / 2 - 1];\n\t\tarw = x[n / 2] - arx;\n\t\tarh = y[n / 2] - ary;\n\t}\n\tauto pp = diff();\n\tfor (int64 i = 0; i < n; ++i)\n\t{\n\t\tans += abs(x[i] - pp.first) * 2;\n\t\tans += abs(y[i] - pp.second) * 2;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, pp.first, pp.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<long long,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nP pa1[100005];\nP pa2[100005];\nint h,w,n;\nbool comp1(P a,P b){\n\treturn a.first<b.first;\n}\nbool comp2(P a,P b){\n\treturn a.second<b.second;\n}\nbool decide(P1 a,P1 b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else if(a.first>b.first){\n\t\treturn false;\n\t}else{\n\t\tif(a.second.first<b.second.first){\n\t\t\treturn true;\n\t\t}else if(a.second.first>b.second.first){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn a.second.second<b.second.second;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&h,&w);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tpa1[i]=mp(x,y);\n\t\tpa2[i]=pa1[i];\n\t}\n\tsort(pa2+1,pa2+(n+1),comp2);\n\tsort(pa1+1,pa1+(n+1),comp1);\n\tint ha=(n+1)/2;\n\tint ax=pa1[ha].first;\n\tint ay=pa2[ha].second;\n\tvector<P1>vec;\n\tfor(int i=ax-1;i<=ax+1;i++){\n\t\tfor(int j=ay-1;j<=ay+1;j++){\n\t\t\tlong long sd=0;\n\t\t\tint maxi=0;\n\t\t\tfor(int g=1;g<=n;g++){\n\t\t\t\tsd+=(abs(pa1[g].first-i)+abs(pa1[g].second-j));\n\t\t\t\tmaxi=max(maxi,(abs(pa1[g].first-i)+abs(pa1[g].second-j)));\n\t\t\t}\n\t\t\tvec.pb(mp(sd*2-maxi,mp(i,j)));\n\t\t}\n\t}\nsort(vec.begin(),vec.end(),decide);\nprintf(\"%lld\\n%d %d\\n\",vec[0].first,vec[0].second.first,vec[0].second.second);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<complex>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define N 100010\nint n,h,w;\nll x[N],y[N];\nll vx[N],vy[N];\nint main(){\n    cin>>h>>w>>n;\n    lol(i,n){\n\tcin>>x[i]>>y[i];\n\tvx[i]=x[i];\n\tvy[i]=y[i];\n    }\n    sort(vx,vx+n);\n    sort(vy,vy+n);\n    \n    if(n%2==1){\n\tll xsum=0,ysum=0;\n\tlol(i,n){\n\t    xsum+=2*abs(x[i]-vx[n/2]);\n\t    ysum+=2*abs(y[i]-vy[n/2]);\n\t}\n\tll ans=(ll)mod*(ll)mod;\n\tlol(i,n){\n\t    ll gre=xsum-abs(x[i]-vx[n/2])+ysum-abs(y[i]-vy[n/2]);\n\t    ans=min(ans,gre);\n\t}\n\tcout<<ans<<endl;\n\tcout<<vx[n/2]<<\" \"<<vy[n/2]<<endl;\n\treturn 0;\n    }\n    \n    ll xsuma=0,ysuma=0,xsumb=0,ysumb=0;\n    lol(i,n){\n\txsuma+=2*abs(x[i]-vx[n/2-1]);\n\tysuma+=2*abs(y[i]-vy[n/2-1]);\n\txsumb+=2*abs(x[i]-vx[n/2]);\n\tysumb+=2*abs(y[i]-vy[n/2]);\n    }\n    ll ans=(ll)mod*(ll)mod;\n    ll tx,ty;\n    lol(i,n){\n\tll gx,gy,gre=0;\n\tif(x[i]>=vx[n/2]){\n\t    gx=vx[n/2-1],gre+=xsuma-abs(x[i]-vx[n/2-1]);\n\t}\n\telse{\n\t    gx=vx[n/2],gre+=xsumb-abs(x[i]-vx[n/2]);\n\t}\n\t\n\tif(y[i]>=vy[n/2]){\n\t    gy=vy[n/2-1],gre+=ysuma-abs(y[i]-vy[n/2-1]);\n\t}\n\telse{\n\t    gy=vy[n/2],gre+=ysumb-abs(y[i]-vy[n/2]);\n\t}\n\t\n\tif(ans>gre||(ans==gre&&(tx>gx||(tx==gx&&ty>gy)))){\n\t    ans=gre;\n\t    tx=gx,ty=gy;\n\t}\n\t//cout<<gre<<\" \"<<tx<<\" \"<<ty<<endl;\n    }\n    cout<<ans<<endl;\n    cout<<tx<<\" \"<<ty<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n\n  REP(i,1,all.size()){\n    ll fir = all[i];\n    int sec=M[all[i]];\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    assert(neg+pos == 2*n);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h){\n    cin>>n;\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e9\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF;\n\tP *p;\n\tP save, save2;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = (2 * n - 1) / 2;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tp = lower_bound(house[1], house[1] + n, house[0][j]);\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tma = max(ma, abs(house[0][j].F - x) + abs(house[0][j].S - y));\n\t\t}\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time >= sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx >= x) {\n\t\t\t\tansx = x;\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thouse[0][n - 1] = house[0][j + 1];\n\t\thouse[1][n - 1] = *p;\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, dx = 1145141919810LL, dy = 1145141919810LL, cx, cy, minx = 1145141919810LL;\nvector<int>mx, my;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int g = 0; g < mx.size(); g++) {\n\t\tfor (int h = 0; h < my.size(); h++) {\n\t\t\tsum = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\td[i] = (abs(mx[g] - ex[i]) + abs(my[h] - ey[i]));\n\t\t\t\tsum += d[i] * 2;\n\t\t\t}\n\t\t\tsort(d, d + n);\n\t\t\tsum -= d[n - 1];\n\t\t\tif (minx > sum) { minx = sum; cx = mx[g]; cy = my[g]; }\n\t\t}\n\t}\n\t\n\tcout << sum << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tvector<VV> dists(3, VV(3, V(N)));\n\trep(i, N) rep(j, -1, 2) rep(k, -1, 2) {\n\t\tdists[j][k][i] = abs(v[i].first - ws[N / 2 + j]) + abs(v[i].second - hs[N / 2 + k]);\n\t}\n\trep(i, 9) sort(all(dists[i]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\trep(i, 3) rep(j, 3) {\n\t\tint sum = accumulate(all(dists[i][j]), 0ll) * 2 - dists[i][j].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[N / 2 + i];\n\t\t\typos = hs[N / 2 + j];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n \nint n, w, h, x[100005], y[100005];\npii pos[100005];\npair<int, pii> dist[100005];\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n \n  cin >> w >> h >> n;\n  for (int i = 1; i <= n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x + 1, x + n + 1);\n  sort(y + 1, y + n);\n  sort(pos + 1, pos + n + 1);\n \n  int bx = x[n / 2], by = y[n / 2], ans = 0;\n \n  for (int i = 1; i <= n; ++i) {\n    dist[i] = {abs(bx - pos[i].first) + abs(by -pos[i].second), pos[i]};\n  }\n  sort(dist + 1, dist + n + 1);\n \n  for (int i = 1; i < n; ++i) {\n    ans += dist[i].first * 2;\n  }\n  ans += dist[n].first;\n \n  cout << ans << endl << bx << \" \" << by << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for(int (i)=(s);(i)<(int)(e);(i)++)\n#define REP(i,e) FOR(i,0,e)\n#define RFOR(i,e,s) for(int (i)=(e);(i)>(int)(s);(i)--)\n\n#define all(o) (o).begin(), (o).end()\n#define psb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef priority_queue<int> PQI;\ntypedef priority_queue<PII> PQII;\n\nconst double EPS = 1e-10;\nconst int N = 1e5;\nint w, h;\nint n;\nll x[N], y[N], sx[N], sy[N], d[N];\n\nint main() {\n  scanf(\"%d%d \", &w, &h);\n  scanf(\"%d \", &n);\n  REP(i,n) {\n    scanf(\"%lld%lld \", x+i, y+i);\n    sx[i] = x[i];\n    sy[i] = y[i];\n  }\n  sort(sx, sx+n);\n  sort(sy, sy+n);\n\n  ll mx = sx[n/2], my = sy[n/2];\n  REP(i,n) d[i] = abs(mx-x[i]) + abs(my-y[i]);\n  sort(d,d+n);\n\n  ll res = 0;\n  REP(i,n) res += d[i];\n  res *= 2LL;\n  res -= d[n-1];\n\n  printf(\"%lld\\n\", res);\n  printf(\"%lld %lld\\n\", mx, my);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e18;\n\nint main(){\n    int w,h;\n    cin >> w >> h;\n    int n;\n    cin >> n;\n    vector<lli> x(n),y(n);\n    for(int i=0; i<n; i++){\n        cin >> x[i] >> y[i];\n    }\n    vector<lli> sx=x, sy=y; // sorted\n    sort(sx.begin(), sx.end());\n    sort(sy.begin(), sy.end());\n    lli ans_cost=inf, ans_x, ans_y;\n    for(int i=(n-1)/2; i<=n/2; i++){\n        for(int j=(n-1)/2; j<=n/2; j++){\n            lli xx=sx[i], yy=sy[j];\n            lli sub = 0;\n            lli maxd = 0;\n            for(int k=0; k<n; k++){\n                lli d = abs(xx -x[k]) +abs(yy -y[k]);\n                maxd = max(maxd, d);\n                sub += 2*d;\n            }\n            sub -= maxd;\n            if(sub < ans_cost){\n                ans_cost = sub;\n                ans_x = xx;\n                ans_y = yy;\n            }\n        }\n    }\n    cout << ans_cost << endl;\n    cout << ans_x << \" \" << ans_y << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<31);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  long long int ans = -1;\n  int ansx, ansy;\n  int up = min( (n / 2) + 3, n - 1);\n  int down = max(0, (n / 2) - 3);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      long long int  res = 0;\n      int far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans == -1 ||ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ0563\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,mix = INF,miy = INF;\n\tvector<int> xp,yp;\n\txp.push_back(x[0]);\n\typ.push_back(y[0]);\n\tfor(int i = 0;i < n;i++) sum += x[i] - x[0];\n\tmix = min(mix,sum * 2);\n\tfor(int i = 1;i < n;i++){\n\t\tsum -= (x[i] - x[i - 1]) * (n - i * 2);\n\t\tif(mix > sum * 2){\n\t\t\tmix = sum * 2;\n\t\t\txp.clear();\n\t\t\txp.push_back(x[i]);\n\t\t}else if(mix == sum * 2) xp.push_back(x[i]);\n\t}\n\tsum = 0;\n\tfor(int i = 0;i < n;i++) sum += y[i] - y[0];\n\tmiy = min(miy,sum * 2);\n\tfor(int i = 1;i < n;i++){\n\t\tsum -= (y[i] - y[i - 1]) * (n - i * 2);\n\t\tif(miy > sum * 2){\n\t\t\tmiy = sum * 2;\n\t\t\typ.clear();\n\t\t\typ.push_back(y[i]);\n\t\t}else if(miy == sum * 2) yp.push_back(y[i]);\n\t}\n\tint ma = 0,xx,yy;\n\tfor(int k = 0;k < yp.size();k++){\n\t\tfor(int j = 0;j < xp.size();j++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(ma < abs(xp[j] - mx[i]) + abs(yp[k] - my[i])){\n\t\t\t\t\tma = abs(xp[j] - mx[i]) + abs(yp[k] - my[i]);\n\t\t\t\t\txx = xp[j];\n\t\t\t\t\tyy = yp[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << mix << \" \" << miy << \" \" << ma << endl;\n\tcout << mix + miy - ma << endl;\n\tcout << xx << \" \" << yy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\n\nvector<long long> SX; // accumulation sum X\nvector<long long> SY; // accumulation sum Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nlong long sumx(int l, int r)\n{\n\treturn SX[r] - SX[l];\n}\n\nlong long sumy(int l, int r)\n{\n\treturn SY[r] - SY[l];\n}\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Accumulation ------ //\n\n\tSX.push_back(0);\n\tSY.push_back(0);\n\n\tfor (int i = 0; i < N; i++) SX.push_back(SX[i] + EX[i]);\n\tfor (int i = 0; i < N; i++) SY.push_back(SY[i] + EY[i]);\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tint ptrl = lower_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\t\tint ptrr = upper_bound(EX.begin(), EX.end(), UX[i]) - EX.begin();\n\n\t\tlong long suml = 1LL * UX[i] * ptrl - 1LL * sumx(0, ptrl);\n\t\tlong long sumr = 1LL * sumx(ptrr, N) - 1LL * UX[i] * (N - ptrr);\n\n\t\tDX.push_back(sumr + suml);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tint ptrl = lower_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\t\tint ptrr = upper_bound(EY.begin(), EY.end(), UY[i]) - EY.begin();\n\n\t\tlong long suml = 1LL * UY[i] * ptrl - sumy(0, ptrl);\n\t\tlong long sumr = 1LL * sumy(ptrr, N) - 1LL * UY[i] * (N - ptrr);\n\n\t\tDY.push_back(sumr + suml);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\ntypedef long long ll;\nint main()\n{\n\tll n,m,k;\n\tscanf(\"%lld %lld %lld\",&n,&m,&k);\n\tvector<ll>x,y,x2,y2;\n\tfor(int i=0;i<k;i++){ ll xx,yy;scanf(\"%lld %lld\",&xx,&yy);x.pb(xx);y.pb(yy);x2.pb(xx);y2.pb(yy);};\n\tsort(x.begin(),x.end()); sort(y.begin(),y.end());\n\tll xi,yi; long long ret=1e15;\n\tfor(int i=k-1;i<=k;i++)for(int j=k-1;j<=k;j++)\n\t{\n\t\tll v=x[i/2]; ll w=y[j/2]; ll res=0,re=0;\n\t\tfor(int a=0;a<k;a++){re=max(re,(ll)(abs(x2[a]-v)+abs(y2[a]-w))); res+=(ll)(abs(x2[a]-v)+abs(y2[a]-w))*2ll;}\n\t\tif(ret>res-re){ ret=min(ret,res-re); xi=v; yi=w;}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ret,xi,yi);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  long long int w[100];\n}big;\n\nbig tasu(big a,big b)\n{\n  long long int w;\n  big q;\n  long long int mae = 0;\n  for(int i = 0; i < 100; i++)\n    {\n      w = a.w[i] + b.w[i] + mae;\n      mae = w / 1000000;\n      w = w % 1000000;\n      q.w[i] = w;\n    }\n  return q;\n}\n\nbig syoki(long long int a)\n{\n  big q;\n  for(int i = 0; i < 100; i++)\n    {\n      q.w[i] = 0;\n    }\n  q.w[0] = a;\n  return q;\n}\n\nvoid hyozi(big a)\n{\n  char flg = 0;\n  for(int i = 100 - 1; i >= 0; i--)\n    {\n      if(flg != 0)\n\t{\n\t  printf(\"%06lld\",a.w[i]);\n\t}\n      else if(a.w[i] != 0)\n\t{\n\t  printf(\"%lld\",a.w[i]);\n\t  flg = 1;\n\t}\n    }\n  printf(\"\\n\");\n}\n\ntypedef struct\n{\n  long long int x;\n  long long int y;\n}WWW;\n\n\nlong long int wkyori(WWW a,WWW b)\n{\n  return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nWWW ww[100000];\nlong long int x[100000];\nlong long int y[100000];\n\nint main()\n{\n  long long int w,h;\n  int n;\n  scanf(\"%lld %lld\",&w,&h);\n  scanf(\"%d\",&n);\n  long long int xw,yw;\n  for(int i = 0; i < n; i++)\n    {\n      scanf(\"%lld %lld\",&xw,&yw);\n      x[i] = xw;\n      y[i] = yw;\n      ww[i].x = xw;\n      ww[i].y = yw;\n    }\n  sort(x,x + n);\n  sort(y,y + n);\n  WWW ori;\n  int sai;\n  if(n % 2 == 1)\n    {\n      ori.x = x[(n + 1) / 2 - 1];\n      ori.y = y[(n + 1) / 2 - 1];\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(longer < wkyori(ori,ww[i]))\n\t    {\n\t      longer = wkyori(ori,ww[i]);\n\t      sai = i;\n\t    }\n\t}\n    }\n  else\n    {\n      WWW s;\n      long long int longer = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  if(ww[i].x > x[n / 2 - 1])\n\t    {\n\t      s.x = x[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.x = x[n / 2];\n\t    }\n\t  if(ww[i].y > y[n / 2 - 1])\n\t    {\n\t      s.y = y[n / 2 - 1];\n\t    }\n\t  else\n\t    {\n\t      s.y = y[n / 2];\n\t    }\n\t  if(longer < wkyori(s,ww[i]))\n\t    {\n\t      longer = wkyori(s,ww[i]);\n\t      sai = i;\n\t    }\n\t  else if(longer == wkyori(s,ww[i]))\n\t    {\n\t      if(ww[i].x > ww[sai].x || (ww[i].x == ww[sai].x && ww[i].y > ww[sai].y))\n\t\t{\n\t\t  longer = wkyori(s,ww[i]);\n\t\t  sai = i;\n\t\t}\n\t    }\n\t}\n      if(ww[sai].x > x[n / 2 - 1])\n\t{\n\t  ori.x = x[n / 2 - 1];\n\t}\n      else\n\t{\n\t  ori.x = x[n / 2];\n\t}\n      if(ww[sai].y > y[n / 2 - 1])\n\t{\n\t  ori.y = y[n / 2 - 1];\n\t}\n      else\n\t{\n\t  ori.y = y[n / 2];\n\t}\n    }\n  big last = syoki(0);\n  for(int i = 0; i < n; i++)\n    {\n      if(i != sai)\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i]) * 2));\n\t}\n      else\n\t{\n\t  last = tasu(last,syoki(wkyori(ori,ww[i])));\n\t}\n    }\n  hyozi(last);\n  printf(\"%lld %lld\\n\",ori.x,ori.y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  //  while(cin>>w>>h>>n){\n  {\n    cin>>w>>h>>n;\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,ma = 0,xx,yy;\n\tif(n % 2 == 1){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint d = abs(x[n / 2] - mx[i]) + abs(y[n / 2] - my[i]);\n\t\t\tsum += d;\n\t\t\tma = max(ma,d);\n\t\t}\n\t\tcout << sum * 2 - ma << endl;\n\t\tcout << x[n / 2] << \" \" << y[n / 2] << endl;\n\t}\n\telse{\n\t\tint mas = 0;\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < 2;k++){\n\t\t\t\tsum = 0;\n\t\t\t\tma = 0;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tint d = abs(x[n / 2 - j] - mx[i]) + abs(y[n / 2 - k] - my[i]);\n\t\t\t\t\tsum += d;\n\t\t\t\t\tma = max(ma,d);\n\t\t\t\t}\n\t\t\t\tif(mas <= sum * 2 - ma){\n\t\t\t\t\tmas = max(mas,sum * 2 - ma);\n\t\t\t\t\txx = x[n / 2 - j];\n\t\t\t\t\tyy = y[n / 2 - k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mas << endl;\n\t\tcout << xx << \" \" << yy << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct E {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tint x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad?????§?¨???????2??????????????¢\nint ari(int a, int b, int c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nint fact(int i) {\n\tll sum = 1;\n\tfor (int j = 2; j <= i; j++)\n\t\tsum = (sum* j) % Mod;\n\treturn sum;\n}//??????(??£???\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h, n;\nH a[100000];\nint b[2][100000], c[2][100000];\nint sum[2];\nsigned main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i].x >> a[i].y;\n\t\tb[0][i] = a[i].x, c[0][i] = a[i].y;\n\t\tsum[0] += (a[i].x * 2);\n\t\tsum[1] += (a[i].y * 2);\n\t}\n\tint ans[3] = { inf,0,0 };\n\tsort(b[0], b[0] + n); sort(c[0], c[0] + n);\n\tb[1][0] = b[0][0]; c[1][0] = c[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tb[1][i] = b[1][i - 1] + b[0][i], c[1][i] = c[1][i - 1] + c[0][i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint rep = 0;\n\t\tint res = round((sum[0] - a[i].x*1.0) / (n * 2 - 1));\n\t\tint iop = lower_bound(b[0], b[0] + n, res) - b[0];\n\t\tif (iop != 0) {\n\t\t\trep += (res * iop - b[1][iop - 1]) * 2;\n\t\t}\n\t\tif (iop != n) {\n\t\t\trep += (b[1][n - 1] - (iop == 0 ? 0 : b[1][iop - 1]) - res*(n - iop)) * 2;\n\t\t}\n\t\tint uio = res;\n\t\tres = round((sum[1] - a[i].y*1.0) / (n * 2 - 1));\n\t\tiop = lower_bound(c[0], c[0] + n, res) - c[0];\n\t\tif (iop != 0) {\n\t\t\trep += (res * iop - c[1][iop - 1]) * 2;\n\t\t}\n\t\tif (iop != n) {\n\t\t\trep += (c[1][n - 1] - (iop == 0 ? 0 : c[1][iop - 1]) - res*(n - iop)) * 2;\n\t\t}\n\t\trep -= (abs(uio - a[i].x) + abs(res - a[i].y));\n\t\tif (rep < ans[0]) {\n\t\t\tans[0] = rep;\n\t\t\tans[1] = uio;\n\t\t\tans[2] = res;\n\t\t}\n\t\tif (rep == ans[0]) {\n\t\t\tif (uio < ans[1]) {\n\t\t\t\tans[0] = rep;\n\t\t\t\tans[1] = uio;\n\t\t\t\tans[2] = res;\n\t\t\t}\n\t\t\telse if (uio == ans[1]&&res<ans[2]) {\n\t\t\t\tans[0] = rep;\n\t\t\t\tans[1] = uio;\n\t\t\t\tans[2] = res;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans[0] << endl << ans[1] << \" \" << ans[2] << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long int lli;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dat[100005][2],sdat[2][100005];\nint w,h,n;\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\trep(i,n){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tdat[i][0]=a;dat[i][1]=b;\n\t\tsdat[0][i]=a;sdat[1][i]=b;\n\t}\n\tint ansp[2]={};\n\trep(i,2){\n\t\tsort(sdat[i],sdat[i]+n);\n\t\tint l=1,r=n-1,min,no=0,cp;\n\t\trep(j,n)no+=sdat[i][j]-sdat[i][0];\n\t\tmin=no*2-(sdat[i][n-1]-sdat[i][0]);\n\t\tfor(int j=1;j<n;j++){\n\t\t\tno-=(sdat[i][j]-sdat[i][j-1])*(r-l);\n\t\t\tl++;r--;\n\t\t\tcp=no*2-max(sdat[i][n-1]-sdat[i][j],sdat[i][j]-sdat[i][0]);\n\t\t\tif(min>cp){\n\t\t\t\tansp[i]=sdat[i][j];\n\t\t\t\tmin=cp;\n\t\t\t}\n\t\t}\n\t}\n\tlli ans=0;\n\trep(i,n)ans+=abs(dat[i][0]-ansp[0])+abs(dat[i][1]-ansp[1]);\n\tint mim=0;\n\trep(i,n)mim=max(mim, abs(dat[i][0]-ansp[0])+abs(dat[i][1]-ansp[1]));\n\tprintf(\"%lld\\n%d %d\\n\",ans*2-mim,ansp[0],ansp[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > &in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=1;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      //REP(i,max(0,xind-D),min(yind+D,(int)Y.size())){\n      //REP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\n      /*\n  rep(i,in.size()){\n\trep(j,in.size()){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)in[i].first,(ll)in[k].first);\n\t  tmp -= myabs((ll)in[j].second,(ll)in[k].second); \n\t  //cout << tmp << endl;\n\t  */\n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=2;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n  ll cur=0;\n  rep(i,(int)in.size()){\n    if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n    else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n  }\n  ret.push_back(make_pair(cur,all[0]));\n\n  REP(i,1,all.size()){\n    ll fir = all[i];\n    int sec=M[all[i]];\n    ll diff = fir - prev;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    assert(neg+pos == 2*n);\n    prev = fir;\n    ret.push_back(make_pair(cur,fir));\n  }\n  return ret;\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    x = precalc(in,false);\n    y = precalc(in,true);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //REP(i,mymax(0,my-D),mymin(my+D,(int)y.size())){\n      //REP(j,mymax(0,mx-D),mymin(mx+D,(int)x.size())){\n      rep(i,y.size()){\n\trep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx < ansx) || (tmp == ans && tx == ansx && ty < ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF (2LL << 58)\nusing namespace std;\n\nint main(){\n    \n    int n, W, H;\n    int x[111111], y[111111], cx[111111], cy[111111];\n \n    cin >> W >> H >> n;\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n        cx[i] = x[i], cy[i] = y[i];\n    }\n    \n    sort(cx, cx + n);\n    sort(cy, cy + n);\n    \n    int ax, ay;\n    long long maxdis = 0, sum = 0, res = INF;\n    for(int k = 0; k < (1 + !(n % 2)); k++){\n        long long mid = n / 2 - k;\n        maxdis = 0, sum = 0;\n        for(int i = 0; i < n; i++){\n            long long dis = abs(cx[mid] - x[i]) + abs(cy[mid] - y[i]);\n            sum += dis * 2;\n            maxdis = max(maxdis, dis);\n        }\n        if(res >= sum - maxdis){\n            ax = cx[mid], ay = cy[mid];\n            res = sum - maxdis;\n        }\n    }\n    cout << res << endl;\n    cout << ax << \" \" << ay << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[1]<a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){\n                }\n                else{\n                    if(mem[2]<b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n/*10 10\n4\n3 1\n2 3\n4 4\n2 5*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define all(c) begin(c), end(c)\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nsigned main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tV ws(N), hs(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tint x, y; cin >> x >> y;\n\t\tws[i] = x; hs[i] = y;\n\t\tv[i] = P(x, y);\n\t}\n\tsort(all(ws));\n\tsort(all(hs));\n\n\tvector<VV> dists(3, VV(3, V(N)));\n\trep(i, N) rep(j, 3) rep(k, 3) {\n\t\tdists[j][k][i] = abs(v[i].first - ws[N / 2 + j - 1]) + abs(v[i].second - hs[N / 2 + k - 1]);\n\t}\n\trep(i, 3) rep(j, 3) sort(all(dists[i][j]));\n\n\tint ans = 1ll << 62;\n\tint xpos = 0, ypos = 0;\n\trep(i, 3) rep(j, 3) {\n\t\tint sum = accumulate(all(dists[i][j]), 0ll) * 2 - dists[i][j].back();\n\t\tif (sum < ans) {\n\t\t\txpos = ws[N / 2 + i - 1];\n\t\t\typos = hs[N / 2 + j - 1];\n\t\t\tans = sum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << xpos << \" \" << ypos << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//JOI2010-2011本選問４歩くサンタクロース(Walking Santa)\n#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0LL, osum = 0LL;\n\tlong long f1, f2, f3, cnt, w, h, L, HL, temp, oxy[2][2], *LXY[2], ox, oy, max = 0;\n\tdeque<long long> XY[2];\n\tscanf(\"%lld %lld\",&w, &h);\n\tscanf(\"%lld\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new long long [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%lld %lld\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tstable_sort( XY[0].begin(), XY[0].end() );\n\tstable_sort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tif(L == 1){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"%lld %lld\\n\",LXY[0][0],LXY[1][0]);\n\t}\n\telse{\n\t\tfor(f1 = 0; f1 < 2; f1++){\n\t\t\tcnt = 0;\n\t\t\ttemp = XY[f1][cnt];\n\t\t\tcnt++;\n\t\t\twhile(cnt < HL){\n\t\t\t\twhile(cnt < L && temp == XY[f1][cnt])\n\t\t\t\t\tcnt++;\n\t\t\t\tif(cnt < HL)\n\t\t\t\t\ttemp = XY[f1][cnt];\n\t\t\t}\n\t\t\toxy[0][f1] = XY[f1][cnt-1];\n\t\t\toxy[1][f1] = XY[f1][cnt];\n\t\t}\n\t\t//400k\n\t\tfor(f2 = 0; f2 < 2; f2++){\n\t\t\tfor(f3 = 0; f3 < 2; f3++){\n\t\t\t\tsum = 0LL;\n\t\t\t\tmax = 0LL;\n\t\t\t\tfor(f1 = 0; f1 < L; f1++){\n\t\t\t\t\ttemp = (long long)abs(LXY[0][f1] - oxy[f2][0]) + abs(LXY[1][f1] - oxy[f3][1]);\n\t\t\t\t\tsum += temp * 2;\n\t\t\t\t\tif(sum < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(max == 0 || max < temp)\n\t\t\t\t\t\tmax = temp;\n\t\t\t\t}\n\t\t\t\tsum -= max;\n\t\t\t\tif(sum > 0 && (osum == 0 || osum > sum || osum == sum && ox >= oxy[f2][0] && oy > oxy[f3][1])){\n\t\t\t\t\tosum = sum;\n\t\t\t\t\tox = oxy[f2][0];\n\t\t\t\t\toy = oxy[f3][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", osum);\n\t\tprintf(\"%lld %lld\\n\", ox, oy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], ex[1000000], ey[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, dx = 1145141145141919810LL, dy = 1145141145141919810LL, cx, cy, minx = 1145141145141919810LL;\nvector<int>mx, my;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t\tex[i] = x[i];\n\t\tey[i] = y[i];\n\t}\n\tsort(x + 1, x + n + 1);\n\tsort(y + 1, y + n + 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx += (-n - 2 + i * 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumy += (-n - 2 + i * 2)*(y[i] - y[i - 1]);\n\t\tsy[i] = sumy;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx.clear(); mx.push_back(x[i]); }\n\t\tif (dx == sx[i]) { mx.push_back(x[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my.clear(); my.push_back(y[i]); }\n\t\tif (dy == sy[i]) { my.push_back(y[i]); }\n\t}\n\tfor (int g = 0; g < mx.size(); g++) {\n\t\tfor (int h = 0; h < my.size(); h++) {\n\t\t\tsum = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\td[i] = (abs(mx[g] - ex[i]) + abs(my[h] - ey[i]));\n\t\t\t\tsum += d[i] * 2;\n\t\t\t}\n\t\t\tsort(d, d + n);\n\t\t\tsum -= d[n - 1];\n\t\t\tif (minx > sum) { minx = sum; cx = mx[g]; cy = my[h]; }\n\t\t}\n\t}\n\t\n\tcout << minx << endl << cx << ' ' << cy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1012345678;\nint W, H, N, x[100009], y[100009], sx[100009], sy[100009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tassert(N <= 1000);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[i], &y[i]), sx[i] = x[i], sy[i] = y[i];\n\tlong long ret = 1LL << 60; int px = 0, py = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tlong long sum = 0; int m = 0;\n\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\tint dist = abs(x[i] - x[k]) + abs(y[j] - y[k]);\n\t\t\t\tsum += dist;\n\t\t\t\tm = max(m, dist);\n\t\t\t}\n\t\t\tsum = sum * 2 - m;\n\t\t\tif(ret > sum) ret = sum, px = inf, py = inf;\n\t\t\tif(ret == sum) {\n\t\t\t\tif(px > x[i] || (px == x[i] && py > y[j])) {\n\t\t\t\t\tpx = x[i]; py = y[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\tprintf(\"%d %d\\n\", px, py);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 1; i <= H; i++)\n\t{\n\t\tfor (int j = 1; j <= W; j++)\n\t\t{\n\t\t\tlong long sum = 0; int maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - j) + abs(Y[k] - i));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - j) + abs(Y[k] - i));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nll W, H;\nint N;\n\nstd::vector<P> X, Y;\nstd::vector<ll> CX, CY;\nbool near[2][100000]; // 1: X/Y[0]が近い, 0: X/Y[N-1]が近い\n\nvoid work(const std::vector<P> &v, std::vector<ll> &c){\n    ll cost = 0;\n    FOR(i, 1, v.size()){\n        cost += 2 * (v[i].first - v[0].first);\n    }\n\n    c.push_back(cost);\n    //printf(\"kuru: %lld\\n\", cost);\n\n    FOR(i, 1, v.size()){\n        if(v[i] != v[i-1]){\n            cost += 2 * (i - (N-i)) * (v[i].first-v[i-1].first);\n        }else{\n            \n        }\n\n        c.push_back(cost);\n        //printf(\"kuru: %lld\\n\", cost);\n    }\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        X.push_back(mp(x, y));\n        Y.push_back(mp(y, x));\n    }\n\n    std::sort(X.begin(), X.end());\n    std::sort(Y.begin(), Y.end());\n    \n    REP(i, N){\n        if(X[i].first-X[0].first < X[N-1].first-X[i].first ||\n           X[i].first-X[0].first == X[N-1].first-X[i].first && X[i].second-X[0].second < X[N-1].second-X[i].second){\n            near[0][i] = true;\n        }else{\n            near[0][i] = false;\n        }\n\n        if(Y[i].first-Y[0].first < Y[N-1].first-Y[i].first ||\n           Y[i].first-Y[0].first == Y[N-1].first-Y[i].first && Y[i].second-Y[0].second < Y[N-1].second-Y[i].second){\n            near[1][i] = true;\n        }else{\n            near[1][i] = false;\n        }\n\n        //printf(\"bool: %d, %d\\n\", near[0][i], near[1][i]);\n    }\n\n    work(X, CX);\n    //puts(\"-------------------------------------------===\");\n    work(Y, CY);\n\n    ll min_cost = INF, x = -1, y = -1;\n    REP(i, N){\n        ll cost = CX[i] + CY[i] - std::max(std::abs(X[i].first-X[near[0][i]?N-1:0].first) + std::abs(Y[i].first-X[near[0][i]?N-1:0].second), std::abs(Y[i].first-Y[near[1][i]?N-1:0].first) + std::abs(X[i].first-Y[near[1][i]?N-1:0].second));\n        //printf(\"%lld, %lld, %lld, %lld, %lld\\n\", CX[i]+CY[i], std::abs(X[i].first-X[near[0][i]?N-1:0].first), std::abs(X[i].second-X[near[0][i]?N-1:0].second), std::abs(Y[i].first-Y[near[1][i]?N-1:0].first), std::abs(Y[i].second-Y[near[1][i]?N-1:0].second));\n        if(min_cost > cost){\n            min_cost = cost;\n            x = X[i].first; y = Y[i].first;\n        }\n    }\n    \n    printf(\"%lld\\n%lld %lld\\n\", min_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nlong long int INF = 1000000000000000000LL; // 10^18\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint W, H, N;\n\nlong long int X[200000], X_[200000];\nlong long int Y[200000], Y_[200000];\n\nlong long int dist(int cx, int cy){\n\tlong long int D = 0;\n\tlong long int Dmax = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tD += 2 * abs(X[i] - cx);\n\t\tD += 2 * abs(Y[i] - cy);\n\t\tDmax = max(Dmax, abs(X[i] - cx) + abs(Y[i] - cy));\n\t}\n\treturn D - Dmax;\n}\n\nint main(){\n\t\n\tcin >> W >> H >> N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> X[i] >> Y[i];\n\t\tX_[i] = X[i];\n\t\tY_[i] = Y[i];\n\t}\n\t\n\tsort(X_, X_ + N);\n\tsort(Y_, Y_ + N);\n\t\n\tlong long int cx1 = X_[(N - 1) / 2];\n\tlong long int cx2 = X_[N / 2];\n\tlong long int cy1 = Y_[(N - 1) / 2];\n\tlong long int cy2 = Y_[N / 2];\n\t\n\tlong long int ans = INF;\n\tlong long int ansx, ansy;\n\tlong long int ret;\n\tret = dist(cx1, cy1);\n\tif(ret < ans){\n\t\tans = ret;\n\t\tansx = cx1;\n\t\tansy = cy1;\n\t}\n\tret = dist(cx1, cy2);\n\tif(ret < ans){\n\t\tans = ret;\n\t\tansx = cx1;\n\t\tansy = cy2;\n\t}\n\tret = dist(cx2, cy1);\n\tif(ret < ans){\n\t\tans = ret;\n\t\tansx = cx2;\n\t\tansy = cy1;\n\t}\n\tret = dist(cx2, cy2);\n\tif(ret < ans){\n\t\tans = ret;\n\t\tansx = cx2;\n\t\tansy = cy2;\n\t}\n\t\n\tcout << ans << endl;\n\tcout << ansx << \" \" << ansy << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 300;\n\nint calc(vint& v, int p)\n{\n\tint res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = mid_x - D; x <= mid_x + D; x++)\n\t\t{\n\t\t\tfor(int y = mid_y - D; y <= mid_y + D; y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint w,h,n,x[100002],y[100002];\nint tx[100002],ty[100002];\nvector<int> vx,vy;\n\nsigned main(){\n  cin>>w>>h>>n;\n  rep(i,n){\n    cin>>x[i]>>y[i];\n    tx[i]=x[i];\n    ty[i]=y[i];\n  }\n  sort(x,x+w);\n  sort(y,y+h);\n  if(h%2)\n    vx.push_back(x[h/2]);\n  else\n    vx.push_back(x[h/2]),vx.push_back(x[h/2+1]);\n  if(w%2)\n    vy.push_back(y[w/2]);\n  else\n    vy.push_back(y[w/2]),vy.push_back(y[w/2+1]);\n  int t=1000000000000000,ax,ay;\n  for(int sx:vx)for(int sy:vy){\n    int sum=0,md=0;\n    rep(i,n){\n      int d=abs(tx[i]-sx)+abs(ty[i]-sy);\n      sum+=d*2;\n      md=max(md,d);\n    }\n    if(sum-md<t){\n      t=sum-md;\n      ax=sx;\n      ay=sy;\n    }\n  }\n  cout<<t<<endl;\n  cout<<ax<<\" \"<<ay<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint main(){\n\n\tlong long sum = 0;\n\tint f1, f2, oxy[2], cnt, w, h, L, temp, max = 0, *LXY[2], HL;\n\tdeque<int> XY[2];\n\tscanf(\"%d %d\",&w, &h);\n\tscanf(\"%d\",&L);\n\tfor(f1 = 0; f1 < 2; f1++)\n\t\tLXY[f1] = new int [L];\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\tscanf(\"%d %d\",&LXY[0][f1], &LXY[1][f1]);\n\t\tXY[0].push_back(LXY[0][f1]);\n\t\tXY[1].push_back(LXY[1][f1]);\n\t}\n\t//1m\n\tsort( XY[0].begin(), XY[0].end() );\n\tsort( XY[1].begin(), XY[1].end() );\n\tHL = (L + 1) / 2;\n\t//x軸での最小値の点、y軸での最小値の点を探す\n\t//200k\n\tfor(f1 = 0; f1 < 2; f1++){\n\t\tcnt = 0;\n\t\ttemp = XY[f1][cnt];\n\t\tcnt++;\n\t\twhile(cnt < HL){\n\t\t\twhile(cnt < HL && temp == XY[f1][cnt])\n\t\t\t\tcnt++;\n\t\t\tif(cnt <= HL){\n\t\t\t\ttemp = XY[f1][cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\toxy[f1] = temp;\n\t}\n\t//100k\n\tfor(f1 = 0; f1 < L; f1++){\n\t\ttemp = abs(LXY[0][f1] - oxy[0]) + abs(LXY[1][f1] - oxy[1]);\n\t\tsum += temp * 2;\n\t\tif(max < temp)\n\t\t\tmax = temp;\n\t}\n\tsum -= max;\n\tprintf(\"%lld\\n\", sum);\n\tprintf(\"%d %d\\n\", oxy[0], oxy[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ0563\n#include <iostream>\n#include <algorithm>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main() {\n\tint w,h,n,x[100000],y[100000],mx[100000],my[100000];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tmx[i] = x[i];\n\t\tmy[i] = y[i];\n\t}\n\tsort(x,x + n);\n\tsort(y,y + n);\n\tint sum = 0,mix = INF,miy = INF,xp = x[0],yp = y[0];\n\tfor(int i = 0;i < n;i++) sum += x[i] - x[0];\n\tmix = min(mix,sum * 2 - (x[n - 1] - x[0]));\n\tfor(int i = 1;i < n;i++){\n\t\tsum -= (x[i] - x[i - 1]) * (n - i * 2);\n\t\tif(mix > sum * 2){\n\t\t\tmix = sum * 2;\n\t\t\txp = x[i];\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i = 0;i < n;i++) sum += y[i] - y[0];\n\tmiy = min(miy,sum * 2 - (y[n - 1] - y[0]));\n\tfor(int i = 1;i < n;i++){\n\t\tsum -= (y[i] - y[i - 1]) * (n - i * 2);\n\t\tif(miy > sum * 2){\n\t\t\tmiy = sum * 2;\n\t\t\typ = y[i];\n\t\t}\n\t}\n\tint ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tma = max(ma,abs(xp - mx[i]) + abs(yp - my[i]));\n\t}\n\tcout << mix + miy - ma << endl;\n\tcout << xp << \" \" << yp << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <iostream>\nusing namespace std;\nstruct P{int x,y; P(int x,int y) : x(x) , y(y) {} };\n\n\nvector<P> h;\nlong long sim(int x,int y){\n\tlong long ans = 0 , mx = 0;\n\tfor(int i = 0 ; i < h.size() ; i++){\n\t\tlong long r =  abs(h[i].x - x) + abs(h[i].y - y);\n\t\tans += r*2;\n\t\tmx = max( mx , r );\n\t}\n\t\n\treturn ans - mx;\n}\nint main(){\n\tvector<int> X,Y;\n\tint N,W,H;\n\tscanf(\"%d%d%d\",&W,&H,&N);\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\th.push_back(P(a,b));\n\t\tX.push_back(a);\n\t\tY.push_back(b);\n\t}\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\tif(N % 2){\n\t\tprintf(\"%lld\\n%d %d\\n\",sim(X[N/2],Y[N/2]),X[N/2],Y[N/2]);\n\t}else{\n\t\tlong long answer = 1ll<<60 , rx , ry;\n\t\tfor(int i = -1 ; i <= 0 ; i++){\n\t\t\tfor(int j = -1 ; j <= 0 ; j++){\n\t\t\t\tlong long g = sim(X[N/2+i],Y[N/2+j]);\n\t\t\t\tif(g < answer){\n\t\t\t\t\trx = X[N/2+i] , ry = Y[N/2+j];\n\t\t\t\t\tanswer = g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n%lld %lld\\n\",answer,rx,ry);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define INF (1LL<<60)\n\ntypedef long long ll;\n\nll W,H,N;\nll X[100005],Y[100005];\n\nint main(){\n  scanf(\"%lld%lld%lld\",&W,&H,&N);\n  rep(i,N) scanf(\"%lld%lld\", &X[i], &Y[i]);\n\n  ll resX=W, distX=INF, resY=H, distY=INF;\n  rep(k,N){\n    ll mY=W, mX=H, mdX=INF, mdY=INF;\n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(X[i]-X[j])*2;\n      dist -= abs(X[i]-X[k]);\n      if(dist < mdX){\n\tmdX = dist;\n\tmX = X[i];\n      }\n    }\n    \n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(Y[i]-Y[j])*2;\n      dist -= abs(Y[i]-Y[k]);\n\n      if(dist < mdY){\n\tmdY = dist;\n\tmY = Y[i];\n      }\n    }\n    if(distX+distY > mdX+mdY){\n      distX = mdX, distY = mdY;\n      resY = mY, resX = mX;\n    }else if(distX+distY == mdX+mdY && mX < resX){\n      resY = mY;\n      resX = mX;\n    }else if(distX+distY == mdX+mdY && mX == resX && mY < resY){\n      resY = mY;\n      resX = mX;\n    }\n  }\n\n  printf(\"%lld\\n\", distX+distY);\n  printf(\"%lld %lld\\n\", resX, resY);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=5;\nconst ll inf = 1LL<<60;\n\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\n//inline void precalc(const vector<pair<ll,ll> >  in,vector<pli> & ret){\ninline vector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //åæå¤ãè¨ç®\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n   //assert(ans == tans);\n   //assert(ansx == tansy);\n   //assert(ansy == tansx);\n }\n\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //è§£ã\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,mymax(0,mys[ii]-D),mymin(mys[ii]+D,(int)y.size())){\n\t     REP(j,mymax(0,mxs[jj]-D),mymin(mxs[jj]+D,(int)x.size())){\n      //rep(i,y.size()){\n      //rep(j,x.size()){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  /*\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  */\n\n\t  ll tmp = y[i].first;\n\t  tmp = tmp + x[j].first;\n\t  tmp = tmp - myabs(y[i].second,in[k].first);\n\t  tmp = tmp - myabs(x[j].second,in[k].second); \n\t  ll ty=y[i].second;\n\t  ll tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t   }\n\t }\n      }\n       /*\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-5),mymin(yind+5,(int)Y.size())){\n\tREP(j,mymax(0,xind-5),mymin(xind+5,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n\t}*/\n       \n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 3e18;\n\nint X[100010];\nint Y[100010];\npii pos[100010];\nint v[100010];\n\nsigned main()\n{\n\tomajinai;\n\n\tint W, H; cin >> W >> H;\n\n\tint N; cin >> N;\n\n\trep(i, N) {\n\t\tcin >> X[i];\n\t\tcin >> Y[i];\n\t\tpos[i] = pii(X[i], Y[i]);\n\t}\n\n\tsort(X, X + N);\n\tsort(Y, Y + N);\n\n    int ans = inf;\n    int ansx = -1, ansy = -1;\n\n    rep(i, 2) {\n        rep(j, 2) {\n            int x = X[N / 2 - i], y = Y[N / 2 - j];\n\n            int sum = 0;\n            int ma = 0;\n            rep(k, N) {\n                int a = abs(x - pos[k].fst) + abs(y - pos[k].scd);\n                sum += a * 2;\n                chmax(ma, a);\n            }\n            sum -= ma;\n\n            if (ans >= sum) {\n                ans = sum;\n                ansx = x;\n                ansy = y;\n            }\n        }\n    }\n\n    cout << ans << endl;\n    cout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tif(c==1){\n\t\tprintf(\"%d\\n%d %d\\n\",0,d[0].first,d[0].second);\n\t\treturn 0;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=9999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=(c-1)/2;\n\t\t//if(c/2>xat){\n\t\t//\t;\n\t\t//}else{\n\t\t//\tCenterX--;\n\t\t//}\n\t\tint CenterY=(c-1)/2;\n\t\t//if(c/2>yat){;}\n\t\t//else CenterY--;\n\t\tlong long T=-abs(x[CenterX]-d[i].first);\n\t\tT+=-abs(y[CenterY]-d[i].second);\n\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\n\t\t//printf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\tans=T;\n\t\t\trow=x[CenterX];\n\t\t\tcol=y[CenterY];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}\n//.....\n//....#\n//#...#\n//##..."
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\ni64 calc(i64& mean, const vector<i64>& vec, vector<i64>& ma) {\n    i64 res = 0LL;\n    for(int i : in(vec.size())) {\n        i64 t = vec[i];\n        i64 plus = mean > t ? mean - t : t - mean;\n        ma[i] += plus;\n        res += plus << 1LL;\n    }\n    return res;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    i64 w, h, n;\n    cin >> w >> h >> n;\n    vector<i64> xcoord(n), ycoord(n);\n    for(int i : in(n))\n      cin >> xcoord[i] >> ycoord[i];\n    sort(xcoord.begin(), xcoord.end());\n    sort(ycoord.begin(), ycoord.end());\n    vector<i64> midId = {n / 2};\n    if(~n & 1) midId.emplace_back(n / 2 - 1);\n    tuple<i64, i64, i64> ans(1e18, 0LL, 0LL);\n    for(auto id1 : midId) for(auto id2 : midId) {\n        i64 x = xcoord[id1], y = ycoord[id2];\n        vector<i64> ma(n, 0LL);\n        i64 sum = calc(x, xcoord, ma) + calc(y, ycoord, ma);\n//        cout << x << ' ' << y << ' ' << sum << ' ' << *max_element(ma.begin(), ma.end()) << endl;\n        sum -= *max_element(ma.begin(), ma.end());\n        ans = min(ans, make_tuple(sum, x, y));\n    }\n    i64 sum, x, y; tie(sum, x, y) = ans;\n    cout << sum << '\\n' << x << ' ' << y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long int w,h,n,x[100000+2],y[100000+2];\nvector<long long int> zx,zy;\nlong long int Sx[100000+2],Sy[100000+2],R[100000+2],U[100000+2];\nlong long int sizx,sizy;\n\n//long long int max(long long int p,long long int q){if(p<q)return q; return p;}\n\nvector<long long int> e(vector<long long int> vll){\n\tvector<long long int> ret;\n\tret.push_back(vll[0]);\n\tlong long int s=vll.size();\n\tfor(int i=1;i<s;i++){\n\t\tif(vll[i]!=vll[i-1])ret.push_back(vll[i]);\n\t}\n\treturn ret;\n}\n\nlong long int Sum_x(long long int p){\n\tlong long int l=0,r=sizx-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zx[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sx[l]+R[l]*(p-zx[l]);\n}\n\nlong long int Sum_y(long long int p){\n\tlong long int l=0,r=sizy-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r+1)/2;\n\t\tif(zy[s]<=p)l=s;\n\t\telse r=s-1;\n\t}\n\treturn Sy[l]+U[l]*(p-zy[l]);\n}\n\nlong long int find_x(long long int l,long long int r,long long int p){\n\tlong long int ret=-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int LL=Sum_x(l)*2-max(l-p,p-l);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int RR=Sum_x(r)*2-max(r-p,p-r);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tlong long int SS=Sum_x(s)*2-max(s-p,p-s);\n//\t\tcout<<\"test\"<<l<<\" \"<<r<<endl;\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_x(l,s,p);\n\t\t\tretb=find_x(s+1,r,p);\n\t\t\tif(Sum_x(reta)*2-max(reta-p,p-reta)<Sum_x(retb)*2-max(retb-p,p-retb))ret=reta;\n\t\t\tret=retb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret==-1)ret=l;\n\twhile(Sum_x(ret-1)*2-max(ret-1-p,p-ret+1)==Sum_x(ret)*2-max(ret-p,p-ret)){ret--; cout<<ret<<endl;}\n\treturn ret;\n}\n\nlong long int find_y(long long int l,long long int r,long long int p){\n\tlong long int ret=-1;\n\twhile(l<r){\n\t\tlong long int s=(l+r)/2;\n\t\tlong long int LL=Sum_y(l)*2-max(l-p,p-l);\n\t\tlong long int RR=Sum_y(r)*2-max(r-p,p-r);\n\t\tlong long int SS=Sum_y(s)*2-max(s-p,p-s);\n\t\tif(LL>=SS&&SS>=RR)l=s+1;\n\t\telse if(LL<=SS&&SS<=RR)r=s;\n\t\telse {\n\t\t\tlong long int reta,retb;\n\t\t\treta=find_y(l,s,p);\n\t\t\tretb=find_y(s+1,r,p);\n\t\t\tif(Sum_y(reta)*2-max(reta-p,p-reta)<Sum_y(retb)*2-max(retb-p,p-retb))ret=reta;\n\t\t\tret=retb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret==-1)ret=l;\n\twhile(Sum_y(ret-1)*2-max(ret-1-p,ret-p+1)==Sum_y(ret)*2-max(ret-p,p-ret)){ret--; cout<<ret<<endl;}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tR[0]=-n; U[0]=-n; Sx[0]=0; Sy[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tzx.push_back(x[i]);\n\t\tzy.push_back(y[i]);\n\t\tSx[0]+=x[i];\n\t\tSy[0]+=y[i];\n\t}\n\tzx.push_back(0);\n\tzy.push_back(0);\n\tsort(zx.begin(),zx.end());\n\tsort(zy.begin(),zy.end());\n\tsizx=zx.size();\n\tsizy=zy.size();\n\tlong long int k=1;\n\tfor(int i=1;k<sizx;i++){\n\t\tint t=1; k++;\n\t\twhile(zx[k]==zx[k-1]){t++; k++;}\n\t\tR[i]=R[i-1]+2*t;\n\t}\n\tk=1;\n\tfor(int i=1;k<sizy;i++){\n\t\tint t=1; k++;\n\t\twhile(zy[k]==zy[k-1]){t++; k++;}\n\t\tU[i]=U[i-1]+2*t;\n\t}\n\tzx=e(zx);\n\tzy=e(zy);\n\tsizx=zx.size();\n\tsizy=zy.size();\n//\tcout<<\"test\"<<0<<endl;\n\tfor(int i=1;i<sizx;i++)Sx[i]=Sx[i-1]+R[i-1]*(zx[i]-zx[i-1]);\n\tfor(int i=1;i<sizy;i++)Sy[i]=Sy[i-1]+U[i-1]*(zy[i]-zy[i-1]);\n/*\tfor(int i=0;i<sizx;i++)cout<<zx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizx;i++)cout<<Sx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<=sizx;i++)cout<<R[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=1;i<=w;i++)cout<<Sum_x(i)<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizy;i++)cout<<zy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<sizy;i++)cout<<Sy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<=sizy;i++)cout<<U[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=1;i<=h;i++)cout<<Sum_y(i)<<\" \";\n*///\tcout<<endl;\n\tlong long int ans=1000000000000000000,ansx,ansy;\n\tlong long int Dx[2],Dy[2];\n\tfor(int i=0;i<=sizx;i++)if(R[i]==0){Dx[0]=zx[i]; Dx[1]=zx[i+1]; break;}\n\tfor(int i=0;i<=sizy;i++)if(U[i]==0){Dy[0]=zy[i]; Dy[1]=zy[i+1]; break;}\n\tfor(int i=0;i<n;i++){\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tlong long int retx,rety,sumx,sumy;\n//\t\tcout<<\"test\"<<i<<endl;\n\t//\tretx=find_x(1,w,x[i+1]);\n\t\tretx=find_x(1,Dx[0],x[i+1]);\n\t\tretx=min(find_x(Dx[0],Dx[1],x[i+1]),retx);\n\t\tretx=min(find_x(Dx[1],w,x[i+1]),retx);\n//\t\tcout<<\"test\"<<i<<endl;\n\t//\trety=find_y(1,h,y[i+1]);\n\t\trety=find_y(1,Dy[0],y[i+1]);\n\t\trety=min(find_y(Dy[0],Dy[1],y[i+1]),rety);\n\t\trety=min(find_y(Dy[1],h,y[i+1]),rety);\n//\t\tcout<<\"test\"<<i<<endl;\n\t\tsumx=Sum_x(retx)*2-max(x[i+1]-retx,retx-x[i+1]);\n//\t\tcout<<x[i]<<\" \"<<retx<<\" \"<<max(x[i]-retx,retx-x[i])<<endl;\n\t\tsumy=Sum_y(rety)*2-max(y[i+1]-rety,rety-y[i+1]);\n//\t\tcout<<y[i]<<\" \"<<rety<<\" \"<<max(y[i]-rety,rety-y[i])<<endl;\n\t\tif(ans>sumx+sumy){\n\t\t\tans=sumx+sumy;\n\t\t\tansx=retx;\n\t\t\tansy=rety;\n\t\t}\n\t\tif(ans==sumx+sumy){\n\t\t\tif(ansx>retx||(ansx==retx&&ansy>=rety)){\n\t\t\t\tans=sumx+sumy;\n\t\t\t\tansx=retx;\n\t\t\t\tansy=rety;\n\t\t\t}\n\t\t}\n//\t\tcout<<i<<\":\"<<sumx+sumy<<\" \"<<retx<<\",\"<<rety<<endl;\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\",ans,ansx,ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define MAX_N 1000000\n#define INF 1145141145141919810LL;\n\nlong long x[MAX_N],y[MAX_N],lx[MAX_N],ly[MAX_N],d[MAX_N],n,h,w,sx,sy,c,mx,my,sum,minx,dx,dy;\nvector<long long>X,Y,BX,BY;\n\nint main(){\n\tcin>>h>>w>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tlx[i]=x[i];ly[i]=y[i];\n\t\tsx+=x[i];\n\t\tsy+=y[i];\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tmx=INF;my=INF;minx=INF;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=x[0];}\n\t\telse{c=x[i]-x[i-1];}\n\t\tsx+=(-n-i*2)*c;\n\t\tif(mx==sx){X.push_back(x[i]);}\n\t\tif(mx>sx){mx=sx;X.clear();X.push_back(x[i]);}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){c=y[0];}\n\t\telse{c=y[i]-y[i-1];}\n\t\tsy+=(-n-i*2)*c;\n\t\tif(my==sy){Y.push_back(y[i]);}\n\t\tif(my>sy){my=sy;Y.clear();Y.push_back(y[i]);}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tif(i<10){BX.push_back(X[i]);}\n\t\telse{if(X[i]!=X[i-10]){BX.push_back(X[i]);}}\n\t}\n\tfor(int i=0;i<Y.size();i++){\n\t\tif(i<10){BY.push_back(Y[i]);}\n\t\telse{if(Y[i]!=Y[i-10]){BY.push_back(Y[i]);}}\n\t}\n\tfor(int i=0;i<X.size();i++){\n\t\tfor(int j=0;j<Y.size();j++){\n\t\t\tmemset(d,0,sizeof(d));\n\t\t\tsum=0;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\td[i]=abs(X[i]-lx[k])+(Y[j]-ly[k]);\n\t\t\t\tsum+=d[i];\n\t\t\t}\n\t\t\tsort(d,d+n);\n\t\t\tsum-=d[n-1];\n\t\t\tif(minx>sum){\n\t\t\t\tminx=sum;\n\t\t\t\tdx=X[i];\n\t\t\t\tdy=Y[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<minx<<endl<<dx<<' '<<dy<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define INF (1LL<<60)\n\ntypedef long long ll;\n\nll W,H,N;\nll X[100005],Y[100005];\nvector<int> sX,sY;\nll maxd;\nll sx[2],sy[2];\n\nll dist(ll ax, ll bx, ll ay, ll by){\n  ll ret = abs(ax-bx)+abs(ay-by);\n  maxd = max(maxd, ret);\n  return 2*ret;\n}\n\nint main(){\n  scanf(\"%lld%lld%lld\",&W,&H,&N);\n  rep(i,N) scanf(\"%lld%lld\", &X[i], &Y[i]);\n\n  rep(i,N){\n    sX.push_back(X[i]);\n    sY.push_back(Y[i]);\n  }\n  sort(sX.begin(), sX.end());\n  sort(sY.begin(), sY.end());\n  //  sX.erase(unique(sX.begin(), sX.end()), sX.end());\n  //  sY.erase(unique(sY.begin(), sY.end()), sY.end());\n\n  sx[0] = sX[(sX.size()-1)/2]; sx[1] = sX[(sX.size()+1)/2];\n  sy[0] = sY[(sY.size()-1)/2]; sy[1] = sY[(sY.size()+1)/2];\n  ll res=INF, rx, ry;\n  rep(i,4){\n    ll x = sx[i/2], y = sy[i%2];\n    //    cout << x << \" \" << y << endl;\n    ll sum = 0; maxd = 0;\n    rep(j,N) sum += dist(x, X[j], y, Y[j]);\n    sum -= maxd;\n    if(sum < res){\n      res = sum;\n      rx = x;\n      ry = y;\n    }\n  }\n  \n  /*  ll resX=W, distX=INF, resY=H, distY=INF;\n  rep(k,N){\n    ll mY=W, mX=H, mdX=INF, mdY=INF;\n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(X[i]-X[j])*2;\n      dist -= abs(X[i]-X[k]);\n      if(dist < mdX){\n\tmdX = dist;\n\tmX = X[i];\n      }\n    }\n    \n    rep(i,N){\n      if(i==k) continue;\n      ll dist = 0;\n      rep(j,N) dist += abs(Y[i]-Y[j])*2;\n      dist -= abs(Y[i]-Y[k]);\n\n      if(dist < mdY){\n\tmdY = dist;\n\tmY = Y[i];\n      }\n    }\n    if(distX+distY > mdX+mdY){\n      distX = mdX, distY = mdY;\n      resY = mY, resX = mX;\n    }else if(distX+distY == mdX+mdY && mX < resX){\n      resY = mY;\n      resX = mX;\n    }else if(distX+distY == mdX+mdY && mX == resX && mY < resY){\n      resY = mY;\n      resX = mX;\n    }\n    }*/\n\n  printf(\"%lld\\n%lld %lld\\n\", res, rx, ry);\n  //  printf(\"%lld\\n\", distX+distY);\n  //  printf(\"%lld %lld\\n\", resX, resY);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define mp make_pair\n\nvector<int> median(vector<int> v) {\n\tsort(v.begin(), v.end());\n\tint n = v.size();\n\tvector<int> ret(1, v[n/2]);\n\tif (n % 2 == 0) {\n\t\tret.push_back(v[n/2-1]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\tvector<int> xs(N), ys(N);\n\tfor (int i=0; i<N; ++i) {\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tvector<int> mx = median(xs);\n\tvector<int> my = median(ys);\n\tlong long res = LLONG_MAX;\n\tint x, y;\n\tfor (int i=0; i<(int)mx.size(); ++i) {\n\t\tfor (int j=0; j<(int)my.size(); ++j) {\n\t\t\tlong long time = 0, m = 0;\n\t\t\tfor (int k=0; k<N; ++k) {\n\t\t\t\tlong long t = abs(xs[k] - mx[i]) + abs(ys[k] - my[j]);\n\t\t\t\ttime += t;\n\t\t\t\tm = max(m, t);\n\t\t\t}\n\t\t\tlong long res2 = 2 * time - m;\n\t\t\tif (mp(res2, mp(mx[i], my[j])) < mp(res, mp(x, y))) {\n\t\t\t\tres = res2;\n\t\t\t\tx = mx[i];\n\t\t\t\ty = my[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1012345678;\nint W, H, N, x[100009], y[100009], sx[100009], sy[100009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tassert(N <= 1000);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[i], &y[i]), sx[i] = x[i], sy[i] = y[i];\n\tlong long ret = 1LL << 60; int px = 0, py = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tlong long sum = 0; int m = 0;\n\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\tint dist =  abs(x[i] - x[k]) + abs(y[j] - y[k]);\n\t\t\t\tsum += dist;\n\t\t\t\tm = max(m, dist);\n\t\t\t}\n\t\t\tsum = sum * 2 - m;\n\t\t\tif(ret > sum) ret = sum, px = inf, py = inf;\n\t\t\tif(ret == sum) {\n\t\t\t\tif(px > x[i] || (px == x[i] && py > y[i])) {\n\t\t\t\t\tpx = x[i]; py = y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\tprintf(\"%d %d\\n\", px, py);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<long long> X;\nvector<long long> Y;\n\nvector<pair<long long, long long> > P;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\n\t\tP.push_back(make_pair(X[i], Y[i]));\n\t}\n\n\tsort(P.begin(), P.end());\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tX[i] = P[i].first;\n\t\tY[i] = P[i].second;\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; long long maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[i]) + abs(Y[k] - Y[j]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[i]) + abs(Y[k] - Y[j]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = X[j];\n\t\t\t\ty = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long int w,h;\n    long int n;\n    long int a[100001],b[100001],A[100001],B[100001];\n    long int x,y;\n    long  int xa,ya;\n    long int mem[4]={0},mem1=0,c;\n    long long int sum=0;\n    scanf(\"%ld%ld%ld\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%ld%ld\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%ld\\n\",sum-mem[0]);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            if(i==0){\n                mem[3]=c;\n            }\n            if(mem[3]==c){\n                if(mem[1]<=a[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[1]>a[i]){//////error\n                }\n                else{\n                    if(mem[2]<=b[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<=c){//////error\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%lld\\n\",sum-mem1);\n        printf(\"%ld %ld\\n\",x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,(int)x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,(int)y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      int xind = (*X.find(in[k].second)).first;\n      int yind = (*Y.find(in[k].first )).first;\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      /*\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  ll h,w,n;\n  ll x[100100],y[100100];\n  ll wx[200100],wy[200100];\n\n  scanf(\"%lld%lld%lld\",&h,&w,&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%lld%lld\",&x[i],&y[i]);\n    wx[2*i] = wx[2*i+1] = x[i];\n    wy[2*i] = wy[2*i+1] = y[i];\n  }\n\n  sort(wx,wx+2*n); sort(wy,wy+2*n);\n  ll sumx[2]={}, sumy[2]={};\n  int med = n-1;\n\n  for(int i=0;i<2*n;i++){\n    sumx[0] += abs(wx[i]-wx[med]);\n    sumy[0] += abs(wy[i]-wy[med]);\n    sumx[1] += abs(wx[i]-wx[med+1]);\n    sumy[1] += abs(wy[i]-wy[med+1]);\n  }\n\n  ll ans = 1e18;\n  pair<ll,ll> cord(0,0);\n  for(int i=0;i<n;i++){\n    int dx = 0, dy = 0;\n    if(x[i]<=wx[med])dx=1;\n    if(y[i]<=wy[med])dy=1;\n\n    ll X = wx[med+dx], Y = wy[med+dy];\n    ll cur = sumx[dx] + sumy[dy] - abs(X-x[i]) - abs(Y-y[i]);\n    if(ans > cur){\n      ans = cur; cord = make_pair(X,Y);\n    }else if(ans == cur){\n      cord = min(cord, make_pair(X,Y));\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n  printf(\"%lld %lld\\n\",cord.first, cord.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size())cur += 2*((ll)in[i].first-(ll)mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    if (w <= 10 && h <= 10);\n    else assert(false);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nll x[100000], y[100000], tx[100000], ty[100000], sum1[100001], sum2[100001];\n#define dist(x,y)(abs(i-x)+abs(j-y))\nint main() {\n\tll w, h, n; scanf(\"%lld%lld%lld\", &w, &h, &n);\n\trep(i, n) {\n\t\tscanf(\"%lld%lld\", &x[i], &y[i]);\n\t\ttx[i] = x[i]; ty[i] = y[i];\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tset<ll>ax, ay;\n\tll mx = LLONG_MAX, my = LLONG_MAX;\n\trep(i, n) {\n\t\tll a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a)mx = a, ax.clear();\n\t\tif (mx == a)ax.insert(x[i]);\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a)my = a, ay.clear();\n\t\tif (my == a)ay.insert(y[i]);\n\t}\n\tll ansx, ansy, ans = LLONG_MAX;\n\tfor (ll i : ax)for (ll j : ay)rep(k, n) {\n\t\tll d = mx + my - dist(tx[k], ty[k]);\n\t\tif (ans > d) {\n\t\t\tans = d;\n\t\t\tansx = i; ansy = j;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%lld %lld\\n\", ans, ansx, ansy);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_W=1000000000,MAX_H=1000000000;\nconst int MAX_N=100000;\n\nint W,H;\nint N;\nint X[MAX_N],Y[MAX_N];\n\nint dis(int a,int b){\n\tint res=0;\n\tint ma=-1;\n\tfor (int i=0;i<N;i++){\n\t\tres+=(abs(a-X[i])+abs(b-Y[i]))*2;\n\t\tma=max(ma,abs(a-X[i])+abs(b-Y[i]));\n\t}\n\tres-=ma;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor (int i=0;i<N;i++){\n\t\tscanf(\"%d %d\",X+i,Y+i);\n\t}\n\tint x,y;\n\tint ma_x,ma_y;\n\tint ma=-1;\n\tfor (x=1;x<=W;x++){\n\t\tfor (y=1;y<=H;y++){\n\t\t\tint d=dis(x,y);\n\t\t\tif (d<ma || ma==-1){\n\t\t\t\tma=d;\n\t\t\t\tma_x=x;\n\t\t\t\tma_y=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ma);\n\tprintf(\"%d %d\\n\",ma_x,ma_y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF;\n\tP *p;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = (2 * n - 1) / 2;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + 2 * n, search);\n\t\tsave = house[0][j]; save2 = *p;\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time >= sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thouse[0][2 * n - 1] = save;\n\t\thouse[1][2 * n - 1] = save2;\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=5;\nconst ll inf = 1LL<<60;\ninline ll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\ninline ll mymin(ll a, ll b){\n  return a < b?a:b;\n}\n\ninline ll mymax(ll a, ll b){\n  return a > b?a:b;\n}\n\ninline int mymin(int a, int b){\n  return a < b?a:b;\n}\n\ninline int mymax(int a, int b){\n  return a > b?a:b;\n}\n\ninline void precalc(const vector<pair<ll,ll> > & in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = mymin(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index;index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    assert(fir > prev);\n    Y[fir] = index;index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  ll w,h;\n  int n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,y,Y);\n\n\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,(int)x.size()){\n      if (x[i].first < x[mx].first)mx = i;\n      else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n    }\n    rep(i,(int)y.size()){\n      if (y[i].first < y[my].first)my = i;    \n      else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n    }\n\n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      //assert(X.find(in[k].second) != X.end() && Y.find(in[k].first) != Y.end());\n      //int xind = X[in[k].second];\n      //int yind = Y[in[k].first ];\n      \n      //int xind = (*X.find(in[k].second)).first;\n      //int yind = (*Y.find(in[k].first )).first;\n\n      REP(i,mymax(0,my-D),mymin(my+D,(int)Y.size())){\n\tREP(j,mymax(0,mx-D),mymin(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      /*\n      //¦ÌêðßéB(i,j)\n      REP(i,mymax(0,yind-D),mymin(yind+D,(int)Y.size())){\n\tREP(j,mymax(0,xind-D),mymin(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n      */\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}\n\n\n\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<ll,ll> P;\ntypedef std::pair<ll,P> Q;\n\nint W, H, N; // W: 南北, H: 東西\nint X[100000], Y[100000];\n\nll work(ll x, ll y){\n    ll res = 0, max_cost = 0;\n\n    REP(i, N){\n        ll cost = std::abs(x-X[i]) + std::abs(y-Y[i]);\n        res += 2 * cost;\n        max_cost = std::max(max_cost, cost);\n    }\n    \n    return res - max_cost;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        std::cin >> X[i] >> Y[i];\n        X[i]--; Y[i]--;\n    }\n\n    Q q = mp(INF, mp(-1, -1));\n    ll lbX = 0, ubX = W;\n    while(ubX-lbX > 1){\n        ll midX = (ubX+lbX) / 2;\n        ll lbY = 0, ubY = H;\n        bool isSucceed = false;\n\n        while(ubY-lbY > 1){\n            ll midY = (ubY+lbY) / 2;\n            ll w = work(midX, midY);\n            if(w <= q.first){\n                isSucceed = true;\n                \n                q = mp(w, mp(midX, midY));\n                ubY = midY;\n            }else{\n                lbY = midY;\n            }\n        }\n\n        if(isSucceed){\n            ubX = midX;\n        }else{\n            lbX = midX;\n        }\n\n        //printf(\"X: [%lld, %lld)\\nY: [%lld, %lld)\\n\", lbX, ubX, lbY, ubY);\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", q.first, q.second.first+1, q.second.second+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint x[100000], y[100000];\nint sum1[100001], sum2[100001];\n#define dist(x)(abs(ax-x.first)+abs(ay-x.second))\nint main() {\n\tint w, h, n; scanf(\"%d%d%d\", &w, &h, &n);\n\tP maxx(0, 0), maxy(0, 0), minx(INF, 0), miny(0, INF);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tif (maxx.first < x[i]) {\n\t\t\tmaxx.first = x[i];\n\t\t\tmaxx.second = y[i];\n\t\t}\n\t\tif (minx.first > x[i]) {\n\t\t\tminx.first = x[i];\n\t\t\tminx.second = y[i];\n\t\t}\n\t\tif (maxy.second < y[i]) {\n\t\t\tmaxy.first = x[i];\n\t\t\tmaxy.second = y[i];\n\t\t}\n\t\tif (miny.second > y[i]) {\n\t\t\tminy.first = x[i];\n\t\t\tminy.second = y[i];\n\t\t}\n\t}\n\tsort(x, x + n); sort(y, y + n);\n\trep(i, n) {\n\t\tsum1[i + 1] = sum1[i] + x[i];\n\t\tsum2[i + 1] = sum2[i] + y[i];\n\t}\n\tint ax, ay;\n\tint mx = INT_MAX, my = INT_MAX;\n\trep(i, n) {\n\t\tint a = ((x[i] * i - sum1[i]) + (sum1[n] - sum1[i] - x[i] * (n - i))) * 2;\n\t\tif (mx > a) {\n\t\t\tmx = a; ax = x[i];\n\t\t}\n\t\ta = ((y[i] * i - sum2[i]) + (sum2[n] - sum2[i] - y[i] * (n - i))) * 2;\n\t\tif (my > a) {\n\t\t\tmy = a; ay = y[i];\n\t\t}\n\t};\n\tint M[] = { dist(minx),dist(maxx),dist(miny),dist(maxy) };\n\tprintf(\"%d\\n%d %d\\n\", mx + my - *max_element(M, M + 4), ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nint n;\nint xi[100010], yi[100010];\nint xj[100010], yj[100010];\nlong long count(int sx, int sy){\n  long long time = 0, l, m = 0;\n  for(int i = 0;i < n; i++){\n    l = llabs(sx - xj[i]) + llabs(sy - yj[i]);\n    m = max(m, l);\n    time += l * 2;\n  }\n  return time - m;\n}\nvoid comp(long long *t, long long k, int *x1, int *y1, int x2, int y2){\n  if(k < *t){\n    *t = k; *x1 = x2; *y1 = y2;\n  }\n}\nint main(void){\n  int w, h;\n  int x1, y1, x2, y2, sx, sy;\n  long long t, k;\n  scanf(\"%d %d %d\", &w, &h, &n);\n  for(int i = 0;i < n; i++){\n    scanf(\"%d %d\", xi + i, yi + i);\n    xj[i] = xi[i]; yj[i] = yi[i];\n  }\n  sort(xi, xi + n); sort(yi, yi + n);\n  if(!(n % 2)){\n    sx = x1 = xi[n / 2 - 1]; sy = y1 = yi[n / 2 - 1];\n    x2 = xi[n / 2]; y2 = yi[n / 2];\n    t = count(x1, y1);\n    k = count(x1, y2);\n    comp(&t, k, &sx, &sy, x1, y2); \n    k = count(x2, y1);\n    comp(&t, k, &sx, &sy, x2, y1); \n    k = count(x2, y2);\n    comp(&t, k, &sx, &sy, x2, y2); \n  } else{\n    sx = xi[n / 2]; sy = yi[n / 2];\n    t = count(sx, sy);\n  }\n  printf(\"%lld\\n\", t);\n  printf(\"%d %d\\n\", sx, sy);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<vector>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int D=1;\nconst ll inf = 1LL<<60;\n\nvector<pll> precalc(const vector<pair<ll,ll> >  in,bool flag){\n  vector<pll> ret;\n  int n = in.size();\n  //yÀWÌ³kAÅ¬lßÄ¨­\n  map<ll,int> M;\n  vector<ll> all;\n  rep(i,(int)in.size()){\n    if (flag){\n      M[in[i].first]++;\n      all.push_back(in[i].first);\n    }else {\n      M[in[i].second]++;\n      all.push_back(in[i].second);\n    }\n  }\n  sort(all.begin(),all.end());\n  all.erase(unique(all.begin(),all.end()),all.end());\n\n  //yÀWªêÔ¬³¢ê©ç·×ÄÌÆÜÅÌ£ðvZµÄ¨­\n  int num = M[all[0]];\n  ll pos = 2*num;\n  ll neg = 2*(n-num);\n  ll prev = all[0];\n   ll cur=0;\n   rep(i,(int)in.size()){\n     if (flag)cur = cur + 2*((ll)in[i].first-(ll)all[0]);\n     else cur = cur + 2*((ll)in[i].second-(ll)all[0]);\n   }\n   ret.push_back(make_pair(cur,all[0]));\n\n   //½ÊìÁÛ¢±ÆðµÄAeyÀW©çÆÜÅÌ£ÌaðvZµÄ¨­B\n   REP(i,1,all.size()){\n     ll fir = all[i];\n     int sec=M[all[i]];\n     ll diff = fir - prev;\n     cur = cur + (pos * diff);\n     cur = cur - (neg * diff);\n     neg=neg-(sec*2);\n     pos=pos+(sec*2);\n     assert(neg+pos == 2*n);\n     prev = fir;\n     ret.push_back(make_pair(cur,fir));\n   }\n   return ret;\n }\n\n//STõ\n void bf(vector<pair<ll,ll> > &in,ll tans,ll tansx,ll tansy){\n   vector<ll> x,y;\n   rep(i,in.size()){\n     swap(in[i].second,in[i].first);\n     x.push_back(in[i].second);\n     y.push_back(in[i].first);\n   }\n   sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n   sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n   ll ans = inf;\n   ll ansx,ansy;\n   rep(i,y.size()){\n     rep(j,x.size()){\n       vector<ll> dist;\n       rep(k,in.size()){\n\t dist.push_back(llabs(in[k].second-x[j])+llabs(in[k].first-y[i]));\n       }\n       sort(dist.begin(),dist.end());\n       ll tmp = 0;\n       rep(k,dist.size()){\n\t tmp += dist[k]*2;\n       }\n       tmp -= dist[dist.size()-1];\n       if (tmp < ans){\n\t ans = tmp;\n\t ansy = x[j];\n\t ansx = y[i];\n       }else if (tmp == ans && x[j] < ansx){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\t ans = tmp;\n\t ansx = x[j];\n\t ansy = y[i];\n       }\n     }\n   }\n   //cout << \"brute force \" << endl;\n   //cout << ans <<endl << ansy <<\" \" << ansx << endl;\n }\n\n/*\n  ðûjB\n  ðµÈ¢ÆªPÂ éÆ¢¤ðð³·éêB\n  eÆª¯¶êÉñÓ éÆl¦ÄâéB\n  x,yÀWÍÆ§Él¦çé±ÆªÅ«éB\n  xÀWÌ£ÌaªÅà¬³¢ÊuÍAÇê©ÌÆÆÀWªêv·éêÉ é(Otðl¦ÄÝéÆí©é)\n  Æ¢¤ÌÍæÔÌrÅ êÎÇ¿ç©É¸çµ½Ù¤ªaª¬³­Èé©çÅ éBiÀWÌÔÌOtÌX«Íµ¢B)\n  yÀWà¯lB\n  ðµÈ¢Æ¢¤ðð³µÄ¢éÌÅA±ÌÌ¦ÍxÀW©çÌ£ªÅ¬ÉÈé_ÆyÀW©çÌ£ªÅ¬ÉÈé_ÌaÉÈéB\n\n  ðµÈ¢Æðl¦éêB\n  Ü¸P³Ål¦éB\n  ðµÈ¢_ðæè¢ÄÝéÆæÙÇl¦½OtÉá±ÌÏ»ª éB( éæÔÅÌX«ªÏ»·é)\n  ½¾µ±êÉæée¿Í»±ÜÅå«­È­AæÙÇl¦½OtÌÅ¬ÆÈé_ª1¸êéÂ\\«ª é¾¯Å éB\n  ÈÌÅæè­ÆiµÈ¢ÆjðßÅ¿µÄA\n  ðl¦½êÉ ÆÍÅ¬ÉÈél(2*2=4Êè)Ìüèð²×êÎ\\ªÅ éB\n */\n\n main(){\n   ll w,h;\n   int n;\n   while(cin>>w>>h){\n     cin>>n;\n     vector<pair<ll,ll> > in(n);\n     //input is x,y\n     rep(i,n){\n       cin>>in[i].first>>in[i].second;\n     }\n     vector<pll> y,x;//XRAAÀWÌyA\n     map<ll,int> X,Y;\n     x = precalc(in,false);\n     y = precalc(in,true);\n\n     //xÀWAyÀWA»ê¼ê£ÌaªÅ¬ÉÈé_ÌÊuðvZµÄ¨­\n     //±êÍ½©¾©QÂiRÂHjµ©¶ÝµÈ¢Í¸\n     int mx = 0,my=0;\n     vector<int> mxs,mys;\n     rep(i,(int)x.size()){\n       X[x[i].second]=i;\n       if (x[i].first < x[mx].first)mx = i;\n       else if (x[i].first == x[mx].first && x[i].second < x[mx].second)mx = i;\n     }\n     rep(i,x.size())if (x[i].first == x[mx].first)mxs.push_back(i);\n     rep(i,(int)y.size()){\n       Y[y[i].second]=i;\n       if (y[i].first < y[my].first)my = i;    \n       else if (y[i].first == y[my].first && y[i].second < y[my].second)my = i;\n     }\n     rep(i,y.size())if (y[i].first == y[my].first)mys.push_back(i);\n\n     //ðsíÈ¢ÆðßÅ¿µÄA·éêÌÅ¬lüÓð²×éB\n     ll ansx=-1,ansy=-1;\n     ll ans = inf;\n     rep(k,(int)in.size()){\n       rep(ii,mys.size()){\n\t rep(jj,mxs.size()){\n\t   REP(i,max(0,mys[ii]-D),min(mys[ii]+D,(int)y.size())){\n\t     REP(j,max(0,mxs[jj]-D),min(mxs[jj]+D,(int)x.size())){\n\t       ll tmp = y[i].first;\n\t       tmp = tmp + x[j].first;\n\t       tmp = tmp - llabs(y[i].second-in[k].first);\n\t       tmp = tmp - llabs(x[j].second-in[k].second); \n\t       ll ty=y[i].second;\n\t       ll tx=x[j].second;\n\t       if (tmp < ans || (tmp == ans && ty < ansy) || (tmp == ans && ty == ansy && tx < ansx) ){\n\t\t ans = tmp;\n\t\t ansx = tx;\n\t\t ansy = ty;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n    }\n    assert(ansx != -1);\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = LONG_LONG_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff) - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg-=(sec*2);\n    pos+=(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = LONG_LONG_MAX;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    assert(n<=100);\n    vector<pair<ll,ll> > in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    ll ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define LL long long\nusing namespace std;\nint W, H, N;\nvector<LL> sx, sy, x, y, rx, ry;\nLL ansd = 1LL << 60, ansx, ansy;\nint main(){\n\tcin >> W >> H >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tLL X, Y;\n\t\tcin >> X >> Y;\n\t\tx.push_back(X);\n\t\trx.push_back(X);\n\t\ty.push_back(Y);\n\t\try.push_back(Y);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsx.push_back(x[N / 2 - 1]);\n\tsx.push_back(x[N / 2]);\n\tsy.push_back(y[N / 2 - 1]);\n\tsy.push_back(y[N / 2]);\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tLL sum = 0, maxd = 0;\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tsum += (abs(sx[i] - rx[k]) + abs(sy[j] - ry[k])) * 2;\n\t\t\t\tmaxd = max(maxd, abs(sx[i] - rx[k]) + abs(sy[j] - ry[k]));\n\t\t\t}\n\t\t\tsum -= maxd;\n\t\t\tif(ansd > sum){\n\t\t\t\tansd = sum;\n\t\t\t\tansx = sx[i];\n\t\t\t\tansy = sy[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ansd << endl;\n\tcout << ansx << \" \" << ansy << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nvoid precalc(vector<pii> &in,vector<pii> & ret,map<int,int> & Y){\n  int n = in.size();\n  int mini =INT_MAX;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<int,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  int pos = 2*M[mini],neg = 2*(n-M[mini]),prev = mini,cur=0;\n  rep(i,(int)in.size())cur += 2*(in[i].first-mini);\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<int,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    int diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + pos * diff - neg * diff;\n    //    cout << cur << \" \" << pos/2 <<\" \" << neg/2 <<\" \" << diff << endl;\n    ret.push_back(make_pair(cur,fir));\n    neg-=sec*2;\n    pos+=sec*2;\n    prev = fir;\n    itr++;\n  }\n}\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pii> in(n);\n    //input is x,y\n    rep(i,n){\n      cin>>in[i].first>>in[i].second;\n    }\n    vector<pii> y,x;\n    map<int,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n    /*\n    cout <<\"xinfo \" << endl;\n    rep(i,x.size())cout << x[i].first <<\" \" << x[i].second << endl;\n    cout <<\"yinfo \" << endl;\n    rep(i,y.size())cout << y[i].first <<\" \" << y[i].second << endl;\n    */\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[mx].first)my = i;    \n\n    const int D=10;\n    ll ans = LONG_LONG_MAX;\n    int ansx,ansy;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      REP(i,max(0,xind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp <= 6){\n\t    cout << y[i].second <<\" \" << x[j].second <<\" \" << y[i].first + x[j].first << endl;\n\t  }\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = y[i].first + x[j].first;\n\t  tmp -= llabs(y[i].second-in[k].first);\n\t  tmp -= llabs(x[j].second-in[k].second); \n\t  int ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n\n    }\n    cout << ans << endl << ansy <<\" \" << ansx << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAX_H 1000000000 //10^9\n#define MAX_W 1000000000 //10^9\n#define MAX_N 100000 //10^5\n#define mp make_pair\n#define INF 1001001001\n#define LLINF 1001001001001001001\n#define llint long long int\n#define ppp pair<int, pair<int,int> >\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n ; i++)\nusing namespace std;\nllint homesx[MAX_N];\nllint homesy[MAX_N];\nllint homesxs[MAX_N];\nllint homesys[MAX_N];\nint main(void){\n    // Your code here!\n    llint W,H,N;\n    scanf(\"%lld %lld %lld\",&W,&H,&N);\n    rep(i,N){\n        llint X,Y;\n        scanf(\"%lld %lld\",&X,&Y);X--;Y--;\n        homesx[i]=X;homesy[i]=Y;\n        homesxs[i]=X;homesys[i]=Y;\n    }\n    \n    //X座標について求める\n    if(N==1){printf(\"%lld\\n%lld %lld\",0,homesx[0],homesy[0]);return 0;}\n    llint ans=LLINF;\n    llint zans[2]={-1,-1};\n    sort(&homesxs[0], &homesxs[N]);\n    sort(&homesys[0], &homesys[N]);\n    llint Center1=(llint)(N/2)-1;\n    llint Center2=(llint)(N/2);\n    \n    llint sum=0;llint maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n    if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center1]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center1];zans[1]=homesys[Center2];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center1]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center1];}\n    sum=0;maxl=0;\n    rep(i,N){\n        llint leng=abs(homesx[i]-homesxs[Center2]) + abs(homesy[i]-homesys[Center2]);\n        sum+=2*leng;\n        maxl=max(leng,maxl);\n    }\n     if(ans>sum-maxl){ans=sum-maxl;zans[0]=homesxs[Center2];zans[1]=homesys[Center2];}\n    printf(\"%lld\\n%lld %lld\\n\",ans,zans[0]+1,zans[1]+1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint W,H;\nint N;\nint X[100000];\nint Y[100000];\nint XC[100000];\nint YC[100000];\nll ans;\nint ansx,ansy;\nint main()\n{\n\tscanf(\"%d%d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);\n\t\tXC[i]=X[i];YC[i]=Y[i];\n\t}\n\tsort(XC,XC+N);sort(YC,YC+N);\n\tif(N&1){\n\t\tll ma=0;\n\t\tansx=XC[N/2];ansy=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans+=(ll)(abs(X[i]-ansx));\n\t\t\tans+=(ll)(abs(Y[i]-ansy));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx)+abs(Y[i]-ansy)));\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",2*ans-ma,ansx,ansy);\n\t}\n\telse{\n\t\tint ansx1=XC[N/2-1];int ansy1=YC[N/2-1];\n\t\tll ans1=0;\n\t\tll ma=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tansx=ansx1;ansy=ansy1;\n\t\tans=2*ans1-ma;\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2-1];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2-1];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,ll> P;\n\nll W, H;\nint N;\nstd::vector<P> ps;\nstd::vector<ll> X, Y;\n\nll work(ll x, ll y){\n    ll cost = 0, max_d = 0;\n    REP(i, N){\n        ll d = std::abs(x-ps[i].first) + std::abs(y-ps[i].second);\n        cost += 2 * d;\n        max_d = std::max(max_d, d);\n    }\n\n    return cost - max_d;\n}\n\nint main(){\n    std::cin >> W >> H >> N;\n\n    REP(i, N){\n        ll x, y;\n        std::cin >> x >> y;\n\n        ps.push_back(mp(x, y));\n        X.push_back(x);\n        Y.push_back(y);\n    }\n\n    std::sort(X.begin(), X.end());\n    X.erase(std::unique(X.begin(), X.end()), X.end());\n    std::sort(Y.begin(), Y.end());\n    Y.erase(std::unique(Y.begin(), Y.end()), Y.end());\n\n    ll xs[2], ys[2];\n    if((X.size()-1)/2-1 >= 0){\n        xs[0] = X[(X.size()-1)/2-1];\n    }\n    xs[1] = X[(X.size()+1)/2-1];\n\n    if((Y.size()-1)/2-1 >= 0){\n        ys[0] = Y[(Y.size()-1)/2-1];\n    }\n    ys[1] = Y[(Y.size()+1)/2-1];\n\n    ll max_cost = INF, x, y;\n    REP(i, 2){\n        REP(j, 2){\n            ll cost = work(xs[i], ys[j]);\n            if(cost < max_cost){\n                max_cost = cost;\n                x = xs[i];\n                y = ys[i];\n            }\n        }\n    }\n\n    printf(\"%lld\\n%lld %lld\\n\", max_cost, x, y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], sx, sy, sum, d[1000000];\ndouble dx, dy;\n\nint main() {\n\tcin >> h >> w >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsx += x[i];\n\t\tsy += y[i];\n\t}\n\tdx = 1.0*sx / n;\n\tdy = 1.0*sy / n;\n\tsx = (1.0*dx + 0.5);\n\tsy = (1.0*dy + 0.5);\n\tfor (int i = 0; i < n; i++) {\n\t\td[i] = (abs(sx - x[i]) + abs(sy - y[i]));\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << sx << ' ' << sy << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nlong long h, w, n, x[1000000], y[1000000], sum, d[1000000];\nlong long sx[1000000], sy[1000000], sumx, sumy, mx, my, dx = 1145141919810LL, dy = 1145141919810LL;\n\nint main() {\n\tcin >> h >> w >> n;\n\tx[0] = 0; y[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx -= (n - i * 2 + 2)*(x[i] - x[i - 1]);\n\t\tsx[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsumx -= (n - i * 2 + 2)*(x[i] - x[i - 1]);\n\t\tsy[i] = sumx;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dx > sx[i]) { dx = sx[i]; mx = x[i]; }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dy > sy[i]) { dy = sy[i]; my = y[i]; }\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\td[i] = (abs(mx - x[i]) + abs(my - y[i]));\n\t\tsum += d[i] * 2;\n\t}\n\tsort(d, d + n);\n\tsum -= d[n - 1];\n\tcout << sum << endl << mx << ' ' << my << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int w,h,n;\n    int a[100001],b[100001],A[100001],B[100001];\n    int x,y;\n    int xa,ya;\n    int mem[4]={0},sum=0,c,mem1=0;\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        A[i]=a[i];\n        B[i]=b[i];\n    }\n    sort(A,A+n);\n    sort(B,B+n);\n    if(n%2==1){\n        x=A[n/2];\n        y=B[n/2];\n    }\n    else{\n        xa=A[n/2]+A[n/2-1];\n        ya=B[n/2]+B[n/2-1];\n    }\n    if(n%2==1){\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem[0]<c){\n                mem[0]=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem[0]);\n        printf(\"%d %d\\n\",x,y);\n    }\n    else{\n        for(int i=0;i<n;i++){\n            if(a[i]*2>=xa){\n                c=a[i]*2-xa;\n            }\n            else{\n                c=xa-a[i]*2;\n            }\n            if(b[i]*2>=ya){\n                c=c+b[i]*2-ya;\n            }\n            else{\n                c=c+ya-b[i]*2;\n            }\n            ///////////////////////////////////ok\n            if(mem[3]==c){\n                if(mem[2]<b[i]){\n                    mem[0]=i;\n                    mem[1]=a[i];\n                    mem[2]=b[i];\n                    mem[3]=c;\n                }\n                else if(mem[2]>b[i]){\n                }\n                else{\n                    if(mem[1]<a[i]){\n                        mem[0]=i;\n                        mem[1]=a[i];\n                        mem[2]=b[i];\n                        mem[3]=c;\n                    }\n                    else{\n                    }\n                }\n            }\n            else if(mem[3]<c){\n                mem[0]=i;\n                mem[1]=a[i];\n                mem[2]=b[i];\n                mem[3]=c;\n            }\n        }\n        if(mem[1]*2>=xa){\n            x=A[n/2-1];\n        }\n        else{\n            x=A[n/2];\n        }\n        if(mem[2]*2>=ya){\n            y=B[n/2-1];\n        }\n        else{\n            y=B[n/2];\n        }\n        for(int i=0;i<n;i++){\n            if(a[i]>=x){\n                sum=sum+(a[i]-x)*2;\n                c=a[i]-x;\n            }\n            else{\n                sum=sum+(x-a[i])*2;\n                c=x-a[i];\n            }\n            if(b[i]>=y){\n                sum=sum+(b[i]-y)*2;\n                c=c+b[i]-y;\n            }\n            else{\n                sum=sum+(y-b[i])*2;\n                c=c+y-b[i];\n            }\n            if(mem1<c){\n                mem1=c;\n            }\n        }\n        printf(\"%d\\n\",sum-mem1);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n/*10 10\n4\n3 1\n2 3\n4 4\n2 5*/"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<int> X;\nvector<int> Y;\nvector<int> EX; // sorted X\nvector<int> EY; // sorted Y\nvector<int> UX; // unique X\nvector<int> UY; // unique Y\nvector<int> CX; // unique counts X\nvector<int> CY; // unique counts Y\n\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tint leftx = 0, lefty = 0;\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t\tCX.push_back(i - leftx);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t\tCY.push_back(i - lefty);\n\t\t}\n\t}\n\n\tCX.push_back(N - leftx);\n\tCY.push_back(N - lefty);\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < A; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - UX[j]) * CX[j];\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - UY[j]) * CY[j];\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tlong long rx = UX[i] + UY[j];\n\t\t\tlong long ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = max(l - 1, 0);\n\t\tpr = min(r + 1, B);\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nlong long X[100000];\nlong long Y[100000];\npair<int,int> d[100000];\nint abs(int a){\n\treturn a<0?-a:a;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",&d[i].first,&d[i].second);\n\t\tx[i]=d[i].first;\n\t\ty[i]=d[i].second;\n\t}\n\tif(c==1){\n\t\tprintf(\"%d\\n%d %d\\n\",0,d[0].first,d[0].second);\n\t\treturn 0;\n\t}\n\tstd::sort(x,x+c);\n\tstd::sort(y,y+c);\n\tX[0]=x[0];\n\tY[0]=y[0];\n\tfor(int i=1;i<c;i++){\n\t\tX[i]=X[i-1]+x[i];\n\t\tY[i]=Y[i-1]+y[i];\n\t}\n\tlong long ans=999999999999999LL;\n\tint row=9999999;\n\tint col=9999999;\n\tfor(int i=0;i<c;i++){\n\t\tint xat=lower_bound(x,x+c,d[i].first)-x;\n\t\tint yat=lower_bound(y,y+c,d[i].second)-y;\n\t\tint CenterX=c/2;\n\t\tif(c/2>xat){\n\t\t\t;\n\t\t}else{\n\t\t\tCenterX--;\n\t\t}\n\t\tint CenterY=c/2;\n\t\tif(c/2>yat){;}\n\t\telse CenterY--;\n\t\tlong long T=-abs(x[CenterX]-d[i].first);\n\t\tT+=-abs(y[CenterY]-d[i].second);\n\t\tT+=((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2;\n\t\tT+=((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2;\n\t\t\n\t//\tprintf(\"%lld %lld %lld\\n\",T,((long long)(CenterX)*x[CenterX]-(CenterX?X[CenterX-1]:0))*2+(-(long long)(c-CenterX-1)*x[CenterX]+(X[c-1]-X[CenterX]))*2,((long long)(CenterY)*y[CenterY]-(CenterY?Y[CenterY-1]:0))*2+(-(long long)(c-CenterY-1)*y[CenterY]+(Y[c-1]-Y[CenterY]))*2);\n\t\tif(T<ans||(T==ans&&x[CenterX]<row)||(T==ans&&x[CenterX]==row&&y[CenterY]<col)){\n\t\t\tans=T;\n\t\t\trow=x[CenterX];\n\t\t\tcol=y[CenterY];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,row,col);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint W,H;\nint N;\nint X[100000];\nint Y[100000];\nint XC[100000];\nint YC[100000];\nll ans;\nint ansx,ansy;\nint main()\n{\n\tscanf(\"%d%d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);\n\t\tXC[i]=X[i];YC[i]=Y[i];\n\t}\n\tsort(XC,XC+N);sort(YC,YC+N);\n\tif(N&1){\n\t\tll ma=0;\n\t\tansx=XC[N/2];ansy=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans+=(ll)(abs(X[i]-ansx));\n\t\t\tans+=(ll)(abs(Y[i]-ansy));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx)+abs(Y[i]-ansy)));\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",2*ans-ma,ansx,ansy);\n\t}\n\telse{\n\t\tint ansx1=XC[N/2-1];int ansy1=YC[N/2-1];\n\t\tll ans1=0;\n\t\tll ma=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tansx=ansx1;ansy=ansy1;\n\t\tans=2*ans1-ma;\n\t\t\n\t\tma=0;\n\t\tansx1=XC[N/2-1];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2-1];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\t\n\t\tma=0;\n\t\tans1=0;\n\t\tansx1=XC[N/2];ansy1=YC[N/2];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans1+=(ll)(abs(X[i]-ansx1));\n\t\t\tans1+=(ll)(abs(Y[i]-ansy1));\n\t\t\tma=max(ma,(ll)(abs(X[i]-ansx1)+abs(Y[i]-ansy1)));\n\t\t}\n\t\tif(2*ans1-ma<ans){\n\t\t\tans=2*ans1-ma;\n\t\t\tansx=ansx1;ansy=ansy1;\n\t\t}\n\t\tprintf(\"%lld\\n%d %d\\n\",ans,ansx,ansy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n#define F first\n#define S second\n#define MAX_N 100000\n#define INF 1e18\nP house[2][2 * MAX_N + 1];\nint main() {\n\tlong long int w, h, n, sum = 0, time = INF, ma = 0, mid, x, y, ansx = INF, ansy = INF;\n\tP *p;\n\tP save, save2, search;\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i <2 * n; i += 2) {\n\t\tlong long int a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\thouse[0][i] = make_pair(a, b);\n\t\thouse[0][i + 1] = house[0][i];\n\t\thouse[1][i] = make_pair(b, a);\n\t\thouse[1][i + 1] = house[1][i];\n\t}\n\tsort(house[0], house[0] + 2 * n);\n\tsort(house[1], house[1] + 2 * n);\n\n\tmid = n - 1;\n\tfor (int j = 0; j < 2 * n; j += 2) {\n\t\tsum = 0;\n\t\tsearch = make_pair(house[0][j].S, house[0][j].F);\n\t\tp = lower_bound(house[1], house[1] + 2 * n, search);\n\t\tsave = house[0][j]; save2 = *p;\n\t\t*p = make_pair(INF, INF);\n\t\thouse[0][j] = make_pair(INF, INF);\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\t\tx = house[0][mid].F;\n\t\ty = house[1][mid].F;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tsum += abs(house[0][i].F - x) + abs(house[0][i].S - y);\n\t\t}\n\t\tif (time == sum) {\n\t\t\ttime = sum;\n\t\t\tif (ansx > x) {\n\t\t\t\tansx = x;\n\t\t\t\tansy = y;\n\t\t\t}\n\t\t\tif (ansx == x) {\n\t\t\t\tif (ansy > y) {\n\t\t\t\t\tansy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (time > sum) {\n\t\t\ttime = sum;\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\thouse[0][2 * n - 1] = save;\n\t\thouse[1][2 * n - 1] = save2;\n\t\tsort(house[0], house[0] + 2 * n);\n\t\tsort(house[1], house[1] + 2 * n);\n\n\t}\n\tcout << time << endl;\n\tcout << ansx << ' ' << ansy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  0563.cpp\n//  2012/11/07.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst ll INF = 1LL << 62;\nconst int D = 250;\n\nll calc(vint& v, int p)\n{\n\tll res = 0;\n\t\n\trep(i, v.size()) res += 2 * abs(p - v[i]);\n\t\n\treturn res;\n}\n\nint main()\n{\n    int W, H, N;\n\tcin >> W >> H >> N;\n\t\n\tvint X(N), Y(N);\n\tvector<pint> points(N);\n\trep(i, N)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tpoints[i] = mp(X[i], Y[i]);\n\t}\n\t\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\t\n\tll best = INF, best_x = 0, best_y = 0;\n\tint mid_x = X[N / 2], mid_y = Y[N / 2];\n\t\n\trep(last, N)\n\t{\n\t\tfor(int x = max(mid_x - D, X[0]); x <= min(mid_x + D, X[N-1]); x++)\n\t\t{\n\t\t\tfor(int y = max(mid_y - D, Y[0]); y <= min(mid_y + D, Y[N-1]); y++)\n\t\t\t{\n\t\t\t\tll sub = calc(X, x) + calc(Y, y);\n\t\t\t\tsub -= abs(x - points[last].first);\n\t\t\t\tsub -= abs(y - points[last].second);\n\t\t\t\t\n\t\t\t\tif(sub < best)\n\t\t\t\t{\n\t\t\t\t\tbest = sub;\n\t\t\t\t\tbest_x = x;\n\t\t\t\t\tbest_y = y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(sub == best)\n\t\t\t\t{\n\t\t\t\t\tif(x < best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_x = x;\n\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == best_x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < best_y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbest_y = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << best << endl << best_x << \" \" << best_y << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<long long,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nP pa1[100005];\nP pa2[100005];\nint h,w,n;\nbool comp1(P a,P b){\n&#160;&#160;&#160;&#160;return a.first<b.first;\n}\nbool comp2(P a,P b){\n&#160;&#160;&#160;&#160;return a.second<b.second;\n}\nbool decide(P1 a,P1 b){\n&#160;&#160;&#160;&#160;if(a.first<b.first){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;\n&#160;&#160;&#160;&#160;}else if(a.first>b.first){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;\n&#160;&#160;&#160;&#160;}else{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(a.second.first<b.second.first){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}else if(a.second.first>b.second.first){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}else{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return a.second.second<b.second.second;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;}\n}\nint main(){\n&#160;&#160;&#160;&#160;scanf(\"%d %d\",&h,&w);\n&#160;&#160;&#160;&#160;scanf(\"%d\",&n);\n&#160;&#160;&#160;&#160;for(int i=1;i<=n;i++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int x,y;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scanf(\"%d %d\",&x,&y);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pa1[i]=mp(x,y);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pa2[i]=pa1[i];\n&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;sort(pa2+1,pa2+(n+1),comp2);\n&#160;&#160;&#160;&#160;sort(pa1+1,pa1+(n+1),comp1);\n&#160;&#160;&#160;&#160;int ha=(n+1)/2;\n&#160;&#160;&#160;&#160;int ax=pa1[ha].first;\n&#160;&#160;&#160;&#160;int ay=pa2[ha].second;\n&#160;&#160;&#160;&#160;vector<P1>vec;\n&#160;&#160;&#160;&#160;vector<int>dx,dy;\n&#160;&#160;&#160;&#160;if(pa1[ha+1].first!=ax){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dx.pb(ax);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dx.pb(pa1[ha+1].first);\n&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;else{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dx.pb(ax);\n&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;if(pa2[ha+1].second!=ay){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dy.pb(ay);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dy.pb(pa2[ha+1].second);\n&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;else{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dy.pb(ay);&#160;&#160;&#160;&#160;&#160; \n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;for(int i=0;i<dx.size();i++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int j=0;j<=dy.size();j++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;long long sd=0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int maxi=0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int g=1;g<=n;g++){\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sd+=(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j]));\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxi=max(maxi,(abs(pa1[g].first-dx[i])+abs(pa1[g].second-dy[j])));\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vec.pb(mp(sd*2-maxi,mp(dx[i],dy[j])));\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;}\n    sort(vec.begin(),vec.end(),decide);   printf(\"%lld\\n%d%d\\n\",vec[0].first,vec[0].second.first,vec[0].second.second);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100000];\nint y[100000];\nint sx[100000];\nint sy[100000];\nlong long abs(long long a){return a>=0?a:-a;}\nlong long max(long long a,long long b){return a>b?a:b;}\nint main(){\n\tint w,h,n,i,j,k;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&sx[i],&sy[i]);\n\t\tx[i]=sx[i];\n\t\ty[i]=sy[i];\n\t}\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tsort(x,x+n);\n\tsort(y,y+n);\n\tint m=(n-1)/2;\n\tlong long ans=1000000000000000LL;\n\tint ax,ay;\n\tfor(i=m;i<=m+1;i++){\n\t\tfor(j=m;j<=m+1;j++){\n\t\t\tlong long res=0;\n\t\t\tlong long mx=0;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tlong long dis=abs(sx[k]-x[i])+abs(sy[k]-y[j]);\n\t\t\t\tres+=dis*2;\n\t\t\t\tmx=max(mx,dis);\n\t\t\t}\n\t\t\tres-=mx;\n\t\t\tif(res<ans){\n\t\t\t\tans=res;\n\t\t\t\tax=x[i];\n\t\t\t\tay=y[j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\",ans,ax,ay);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, x[2][100009], p[4]; long long v[4];\nint main() {\n\tscanf(\"%*d%*d%d\", &N);\n\tfor(int i = 0; i < N; i++) scanf(\"%d%d\", &x[0][i], &x[1][i]);\n\tfor(int i = 0; i < 2; i++) {\n\t\tsort(x[i], x[i] + N); v[i] = 1LL << 60;\n\t\tfor(int j = (N - 1) / 2; j <= N / 2; j++) {\n\t\t\tlong long sum = 0;\n\t\t\tfor(int k = 0; k < N; k++) sum += abs(x[i][j] - x[i][k]) * 2;\n\t\t\tsum -= max(x[i][j] - x[i][0], x[i][N - 1] - x[i][j]);\n\t\t\tif(v[i] > sum) v[i] = sum, p[i] = x[i][j];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", v[0] + v[1]);\n\tprintf(\"%d %d\\n\", p[0], p[1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll LLINF = 1LL << 60;\ninline ll llabs(ll n) { return (n < 0 ? -n : n); }\nll W, H, N;\nll X[100005], Y[100005];\nll sx[100005], sy[100005];\nll dy[] = {-1, 0, -1, 0};\nll dx[] = {-1, -1, 0, 0};\nint main()\n{\n    ll ansx, ansy, val = LLINF;\n    cin >> W >> H >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n        sx[i] = X[i], sy[i] = Y[i];\n    }\n    sort(X, X + N), sort(Y, Y + N);\n    for(int p = 0; p < 4; p++) {\n        ll x = X[(N + dx[p]) / 2], y = Y[(N + dy[p]) / 2];\n        ll maxv = 0, sum = 0;\n        for(int i = 0; i < N; i++) {\n            ll dist = llabs(x - sx[i]) + llabs(y - sy[i]);\n            maxv = max(dist, maxv);\n            sum += dist * 2;\n        }\n        if(val > sum - maxv) {\n            val = sum - maxv;\n            ansx = x, ansy = y;\n        }\n    }\n    cout << val << endl << ansx << \" \" << ansy << endl;\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  This program is accepted in my computer.\n */\n#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=10;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\nvoid precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\n  int n = in.size();\n  ll mini = inf;\n  //yÀWÌ³kAÅ¬lßÄ¨­\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //úlðvZ\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//XRAAÀWÌyA\n    map<ll,int> Y,X;\n    precalc(in,y,Y);\n    rep(i,n)swap(in[i].first,in[i].second);\n    precalc(in,x,X);\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //ð­\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //æè­yÀWÌCfbNX,æè­ÀWnkÍin[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //¦ÌêðßéB(i,j)\n      int is = max(0,yind-D),ie=min(yind+D,(int)Y.size());\n      REP(i,is,ie){\n\tint js = max(0,xind-D),je=min(yind+D,(int)X.size());\n\tREP(j,js,je){\n      //REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\t//REP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //¦ÌêÌAðæè©È©Á½lðßé\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx < ansx){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }else if (tmp == ans && tx == ansx && ty < ansy){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 60;\n\nvoid solve() {\n    int n;\n    std::cin >> n >> n >> n;\n\n    std::vector<std::pair<lint, lint>> ps(n);\n    std::vector<lint> xs, ys;\n    for (auto& p : ps) {\n        std::cin >> p.first >> p.second;\n        for (int i = 0; i < 2; ++i) {\n            xs.push_back(p.first);\n            ys.push_back(p.second);\n        }\n    }\n\n    std::sort(xs.begin(), xs.end());\n    std::sort(ys.begin(), ys.end());\n\n    std::vector<lint>\n        xmid{xs[n - 1], xs[n]},\n        ymid{ys[n - 1], ys[n]};\n\n    std::vector<lint> xsum(2, 0), ysum(2, 0);\n    for (int i = 0; i < 2; ++i) {\n        for (auto x : xs) xsum[i] += std::abs(x - xmid[i]);\n        for (auto y : ys) ysum[i] += std::abs(y - ymid[i]);\n    }\n\n    int bxi = 1, byi = 1;\n    lint ans = INF;\n    for (int i = 0; i < n; ++i) {\n        int xi = (ps[i].first <= xmid[0]),\n            yi = (ps[i].second <= ymid[0]);\n        lint sum = (xsum[xi] - std::abs(ps[i].first - xmid[xi])) +\n                   (ysum[yi] - std::abs(ps[i].second - ymid[yi]));\n\n        if (sum < ans || (sum == ans && xi < bxi) ||\n            (sum == ans && xi == bxi && yi < byi)) {\n            ans = sum;\n            bxi = xi;\n            byi = yi;\n        }\n    }\n\n    std::cout << ans << \"\\n\"\n              << xmid[bxi] << \" \" << ymid[byi] << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tll w,h,n;\n\tvector<ll> x,y;\n\t\n\tll add_min = INF ,x_add_min,y_add_min;\n\tll add_max = -INF,x_add_max,y_add_max;\n\tll dif_min = INF ,x_dif_min,y_dif_min;\n\tll dif_max = -INF,x_dif_max,y_dif_max;\n\t\n\t\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\trep(i,n){\n\t\tll a,b;\n\t\tscanf(\"%lld%lld\",&a,&b);\n\t\tif(a+b < add_min){\n\t\t\tadd_min = a+b;\n\t\t\tx_add_min = a;\n\t\t\ty_add_min = b;\n\t\t}\n\t\tif(a+b > add_max){\n\t\t\tadd_max = a+b;\n\t\t\tx_add_max = a;\n\t\t\ty_add_max = b;\n\t\t}\n\t\tif(a-b < dif_min){\n\t\t\tdif_min = a-b;\n\t\t\tx_dif_min = a;\n\t\t\ty_dif_min = b;\n\t\t}\n\t\tif(a-b > dif_max){\n\t\t\tdif_max = a-b;\n\t\t\tx_dif_max = a;\n\t\t\ty_dif_max = b;\n\t\t}\n\t\tx.pb( a );\n\t\ty.pb( b );\n\t\t\n\t}\n\t\n\tsor(x);\n\tsor(y);\n\t\n\tll ret = INF,ret_x,ret_y;\n\tll X[4] = { x_add_min , x_add_max , x_dif_min , x_dif_max };\n\tll Y[4] = { y_add_min , y_add_max , y_dif_min , y_dif_max };\n\t\n\trep(i,4){\n\t\tvector<ll> x_,y_;\n\t\trep(j,x.size()){\n\t\t\tif(x[j] != X[i]){\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_.pb ( x[j] );\n\t\t\t\tX[i] = -1;\n\t\t\t}\n\t\t}\n\t\trep(j,y.size()){\n\t\t\tif(y[j] != Y[i]){\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty_.pb ( y[j] );\n\t\t\t\tY[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans_x = x_[x_.size()/2],ans_y = y_[y_.size()/2];\n\t\tll sum = 0;\n\t\t\n\t\trep(i,x_.size()){\n\t\t\tsum += abs( x_[i]-ans_x );\n\t\t}\n\t\trep(i,y_.size()){\n\t\t\tsum += abs( y_[i]-ans_y );\n\t\t}\n\t\t\n\t\tif(sum < ret){\n\t\t\tret = sum;\n\t\t\tret_x = ans_x;\n\t\t\tret_y = ans_y;\n\t\t}\n\t\telse if(sum == ret){\n\t\t\tif(ans_x < ret_x){\n\t\t\t\tret_x = ans_x;\n\t\t\t\tret_y = ans_y;\n\t\t\t}\n\t\t\telse if(ans_x == ret_x){\n\t\t\t\tif(ans_y < ret_y){\n\t\t\t\t\tret_y = ans_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ret << endl;\n\tcout << ret_x << \" \" << ret_y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\t\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\t\t\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tfor (int j = 0; j < B; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = min(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = UX[i];\n\t\t\t\ty = UY[j];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N, A, B;\n\nlong long LX, LY, RX, RY; // rotate\n\nvector<long long> X;\nvector<long long> Y;\nvector<long long> EX; // sorted X\nvector<long long> EY; // sorted Y\nvector<long long> UX; // unique X\nvector<long long> UY; // unique Y\nvector<long long> DX; // distance sum from UX\nvector<long long> DY; // distance sum from UY\n\nint main()\n{\n\t// ------ Input ------ //\n\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<long long>(N);\n\tY = vector<long long>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\n\n\t// ------ Sort & Unique ------ //\n\n\tEX = X;\n\tEY = Y;\n\n\tsort(EX.begin(), EX.end()); UX.push_back(EX[0]);\n\tsort(EY.begin(), EY.end()); UY.push_back(EY[0]);\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (EX[i] != EX[i - 1])\n\t\t{\n\t\t\tUX.push_back(EX[i]);\n\t\t}\n\n\t\tif (EY[i] != EY[i - 1])\n\t\t{\n\t\t\tUY.push_back(EY[i]);\n\t\t}\n\t}\n\n\tA = UX.size();\n\tB = UY.size();\n\n\n\t// ------ Rotate ------ //\n\n\tLX = 999999999999999999LL;\n\tLY = 999999999999999999LL;\n\tRX = -999999999999999999LL;\n\tRY = -999999999999999999LL;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong long tx = X[i] + Y[i];\n\t\tlong long ty = X[i] - Y[i];\n\n\t\tLX = min(LX, tx);\n\t\tLY = min(LY, ty);\n\t\tRX = max(RX, tx);\n\t\tRY = max(RY, ty);\n\t}\n\n\n\t// ------ Distance Calculation ------ //\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UX[i] - X[j]);\n\t\t}\n\n\t\tDX.push_back(sum);\n\t}\n\n\tfor (int i = 0; i < B; i++)\n\t{\n\t\tlong long sum = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tsum += abs(UY[i] - Y[j]);\n\t\t}\n\n\t\tDY.push_back(sum);\n\t}\n\n\n\t// ------ Calculate ------ //\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1, pl = 0, pr = B, l, r;\n\n\tfor (int i = 0; i < A; i++)\n\t{\n\t\tlong long res = 999999999999999999LL;\n\t\t\n\t\tfor (int j = pl; j < pr; j++)\n\t\t{\n\t\t\tint rx = UX[i] + UY[j];\n\t\t\tint ry = UX[i] - UY[j];\n\n\t\t\tlong long maxs = max(max(rx - LX, RX - rx), max(ry - LY, RY - ry));\n\n\t\t\tlong long sum = 2LL * (DX[i] + DY[j]) - maxs;\n\n\t\t\tif (sum < res)\n\t\t\t{\n\t\t\t\tres = sum;\n\t\t\t\t\n\t\t\t\tl = j;\n\t\t\t\tr = j + 1;\n\n\t\t\t\tif (sum < ret)\n\t\t\t\t{\n\t\t\t\t\tx = UX[i];\n\t\t\t\t\ty = UY[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sum == res)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tpl = l;\n\t\tpr = r;\n\n\t\tret = min(ret, res);\n\t}\n\n\n\t// ------ Output ------ //\n\n\tprintf(\"%lld\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 100005;\n\nint n, w, h, x[100005], y[100005];\npii pos[100005];\n\nint calDist(int bx, int by) {\n  int ans = 0, tmax = 0;\n  \n  for (int i = 0; i < n; ++i) {\n    int temp = abs(bx - pos[i].first) + abs(by -pos[i].second);\n    ans += temp * 2;\n    tmax = max(tmax, temp);\n  }\n  ans -= tmax;\n\n  return ans;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> w >> h >> n;\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    x[i] = a;\n    y[i] = b;\n    pos[i] = pii({a, b});\n  }\n  sort(x, x + n);\n  sort(y, y + n);\n\n  int bx, by, ans = INF;\n\n  for (int i = -1; i < 1; ++i) {\n    for (int j = -1; j < 1; ++j) {\n      int tx = x[n / 2 + i], ty = y[n / 2 + j], dist = calDist(tx, ty);\n      if (dist < ans) {\n\tbx = tx;\n\tby = ty;\n\tans = dist;\n      }\n    }\n  }\n\n  cout << ans << endl << bx << \" \" << by << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<map>\n#include<climits>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int D=20;\nconst ll inf = 1LL<<60;\nll myabs(ll a,ll b){\n  return max(a,b)-min(a,b);\n}\n\n//void precalc(vector<pair<ll,ll> > in,vector<pli> & ret,map<ll,int> & Y){\npair<vector<pli>,map<ll,int> > precalc(vector<pair<ll,ll> > in){\n  vector<pli> ret;\n  map<ll,int> Y;\n  int n = in.size();\n  ll mini = inf;\n  //yåº§æ¨ã®å§ç¸®ãæå°å¤æ±ãã¦ãã\n\n  map<ll,int> M;\n  rep(i,(int)in.size()){\n    M[in[i].first]++;\n    mini = min(mini,in[i].first);\n  }\n  //åæå¤ãè¨ç®\n  ll pos = 2*M[mini];\n  ll neg = 2*(n-M[mini]);\n  ll prev = mini;\n  ll cur=0;\n  rep(i,(int)in.size()){\n    cur = cur + 2*((ll)in[i].first-(ll)mini);\n  }\n  ret.push_back(make_pair(cur,mini));\n\n  //\n  int index = 0;\n  Y[mini] = index++;\n  map<ll,int>::iterator itr = M.begin();itr++;\n  while(itr != M.end()){\n    int fir = (*itr).first,sec=(*itr).second;\n    ll diff = fir - prev;\n    Y[fir] = index++;\n    cur = cur + (pos * diff);\n    cur = cur - (neg * diff);\n    ret.push_back(make_pair(cur,fir));\n    neg=neg-(sec*2);\n    pos=pos+(sec*2);\n    prev = fir;\n    itr++;\n  }\n  return make_pair(ret,Y);\n}\n/*\nvoid bf(vector<pair<ll,ll> > &in){\n  vector<ll> x,y;\n  rep(i,in.size()){\n    swap(in[i].second,in[i].first);\n    x.push_back(in[i].second);\n    y.push_back(in[i].first);\n  }\n  sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n  sort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n  ll ans = inf;\n  ll ansx,ansy;\n  rep(i,y.size()){\n    rep(j,x.size()){\n      vector<ll> dist;\n      rep(k,in.size()){\n\tdist.push_back(myabs(in[k].second,x[j])+myabs(in[k].first,y[i]));\n      }\n      sort(dist.begin(),dist.end());\n      ll tmp = 0;\n      rep(k,dist.size()){\n\ttmp += dist[k]*2;\n      }\n      tmp -= dist[dist.size()-1];\n      if (tmp < ans){\n\tans = tmp;\n\tansy = x[j];\n\tansx = y[i];\n      }else if (tmp == ans && x[j] < ansx){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }else if (tmp == ans && x[j] == ansx && y[i] < ansy){\n\tans = tmp;\n\tansx = x[j];\n\tansy = y[i];\n      }\n    }\n  }\n  cout << \"brute force \" << endl;\n  cout << ans <<endl << ansx <<\" \" << ansy << endl;\n}\n*/\n\nmain(){\n  int w,h,n;\n  while(cin>>w>>h>>n){\n    vector<pair<ll,ll> > in;\n    //input is x,y\n    rep(i,n){\n      ll f,s;cin>>f>>s;\n      in.push_back(make_pair(f,s));\n    }\n    vector<pli> y,x;//ã¹ã³ã¢ãåº§æ¨ã®ãã¢\n    map<ll,int> Y,X;\n\n    pair<vector<pli>,map<ll,int> > tm = precalc(in);\n    y = tm.first;\n    Y = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n    tm = precalc(in);\n    x = tm.first;\n    X = tm.second;\n    rep(i,n)swap(in[i].first,in[i].second);\n\n    //è§£ã\n    int mx = 0,my=0;\n    rep(i,x.size())if (x[i].first < x[mx].first)mx = i;\n    rep(i,y.size())if (y[i].first < y[my].first)my = i;    \n\n    ll ans = inf;\n    ll ansx=-1,ansy=-1;\n    rep(k,(int)in.size()){\n      //åãé¤ãyåº§æ¨ã®ã¤ã³ããã¯ã¹,åãé¤ãåº§æ¨å°éã¯in[k].first,in[k].second\n      assert(X.find(in[k].second) != X.end() && \n\t     Y.find(in[k].first) != Y.end());\n      int xind = X[in[k].second];\n      int yind = Y[in[k].first ];\n      //ç­ãã®å ´æãæ±ºããã(i,j)\n      REP(i,max(0,yind-D),min(yind+D,(int)Y.size())){\n\tREP(j,max(0,xind-D),min(xind+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp = tmp - myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp = tmp - myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n      REP(i,max(0,my-D),min(my+D,(int)Y.size())){\n\tREP(j,max(0,mx-D),min(mx+D,(int)X.size())){\n\t  //ç­ãã®å ´æã®ãå¾å¾©ãåãé¤ããªãã£ãå¤ãæ±ãã\n\t  ll tmp = (ll)y[i].first + (ll)x[j].first;\n\t  tmp -= myabs((ll)y[i].second,(ll)in[k].first);\n\t  tmp -= myabs((ll)x[j].second,(ll)in[k].second); \n\t  ll ty=y[i].second,tx=x[j].second;\n\t  if (tmp < ans || (tmp == ans && tx == ansx) || (tmp == ans && tx == ansx && ty == ansy) ){\n\t    ans = tmp;\n\t    ansx = tx;\n\t    ansy = ty;\n\t  }\n\t}\n      }\n\n    }\n    cout << ans << endl;\n    cout << ansy <<\" \" << ansx << endl;\n    //bf(in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nll solve(ll *t, ll n){\n  ll sum = -n * t[0];\n\n  for(int i = 0; i < n; i++){\n    sum += t[i];\n  }\n\n  ll minSum = sum, res = t[0];\n\n  for(int i = 1; i < n; i++){\n    sum -= (n - i) * (t[i] - t[i - 1]);\n    sum += i * (t[i] - t[i - 1]);\n\n    if(minSum > sum){\n      minSum = sum;\n      res = t[i];\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  ll w, h, n;\n  ll dx[] = {-1, 0, 0, 0, 1};\n  ll dy[] = { 0,-1, 0, 1, 0};\n\n  while(cin >> w >> h >> n){\n    P t[n];\n    ll x[n], y[n];\n\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i];\n      t[i] = P(x[i], y[i]);\n    }\n\n    sort(x, x + n);\n    sort(y, y + n);\n\n    ll X = solve(x, n);\n    ll Y = solve(y, n);\n    ll ansX = X, ansY = Y, ans = LONG_LONG_MAX;\n\n    for(int j = 0; j < 5; j++){\n      ll x = X + dx[j], y = Y + dy[j];\n      ll sum = 0, maxDist = 0;\n\n      for(int i = 0; i < n; i++){\n        ll dist = llabs(t[i].first - x) + llabs(t[i].second - y);\n        maxDist = max(maxDist, dist);\n        sum += dist * 2;\n      }\n\n      if(ans > sum - maxDist){\n        ans = sum - maxDist;\n        ansX = x;\n        ansY = y;\n      }\n    }\n\n    cout << ans << endl;\n    cout << ansX << \" \" << ansY << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF (1<<31);\nusing namespace std;\nint main(){\n  int points[100000][2], xs[100000], ys[100000], n, w, h;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  for(int i = 0;i < n;i++){\n    scanf(\"%d%d\", xs + i, ys + i);\n    points[i][0] = xs[i];\n    points[i][1] = ys[i];\n  }\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  int ans = INF;\n  int ansx, ansy;\n  int up = min( (n / 2) + 2, n - 1);\n  int down = max(0, (n / 2) - 2);\n  for(int i = down;i <= up;i++){\n    for(int j = down;j <= up;j++){\n      int res = 0, far = 0;\n      for(int k = 0;k < n;k++){\n\tfar = max(far, abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j]));\n\tres += (abs(points[k][0] - xs[i]) + abs(points[k][1] - ys[j])) * 2;\n      }\n      if(ans > res - far){\n\tans = res - far;\n\tansx = xs[i];\n\tansy = ys[j];\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  printf(\"%d %d\\n\", ansx, ansy);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nusing pl = pair<ll,ll>;\n\nconst int N=100000;\n\nll W,H;\nint n;\nll X[N],Y[N];\n\nll G(ll x, ll y)\n{\n    ll ret = 0, MAX = 0;\n    rep(i,n)\n    {\n        ll d = abs(x-X[i])+abs(y-Y[i]);\n        ret += d*2;\n        MAX = max(MAX, d);\n    }\n    return ret-MAX;\n}\n\n// (val,y)\npl F(ll x)\n{\n    ll ly=1, ry=H;\n    rep(loop,55)\n    {\n        ll y1 = (2*ly+ry)/3, y2 = (ly+2*ry)/3;\n        if(G(x,y1)<G(x,y2)) ry=y2;\n        else ly=y1;\n    }\n\n    ll yy=ly;\n    for(ll y=ly; y<=ry; ++y)if(G(x,yy)>G(x,y)) yy=y;\n\n    return pl(G(x,yy),yy);\n}\n\nint main()\n{\n    scanf(\" %lld %lld %d\", &W, &H, &n);\n    rep(i,n) scanf(\"  %lld %lld\", &X[i], &Y[i]);\n\n    ll lx=1, rx=W;\n    rep(loop,55)\n    {\n        ll x1 = (2*lx+rx)/3, x2 = (lx+2*rx)/3;\n        if(F(x1).fi<F(x2).fi) rx=x2;\n        else lx=x1;\n    }\n\n    ll ansx = lx;\n    for(ll x=lx; x<=rx; ++x) if(F(ansx).fi>F(x).fi) ansx = x;\n\n    pl res = F(ansx);\n    ll ans = res.fi, ansy = res.se;\n    printf(\"%lld\\n%lld %lld\\n\", ans,ansx,ansy);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, N;\n\nvector<int> X;\nvector<int> Y;\n\nvector<pair<int, int> > P;\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &N);\n\n\tX = vector<int>(N);\n\tY = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\n\t\tP.push_back(make_pair(X[i], Y[i]));\n\t}\n\n\tsort(P.begin(), P.end());\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tX[i] = P[i].first;\n\t\tY[i] = P[i].second;\n\t}\n\n\tlong long ret = 999999999999999999LL;\n\n\tint x = -1, y = -1;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tlong long sum = 0; int maxs = 0;\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tsum += 2LL * (abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\n\t\t\t\tmaxs = max(maxs, abs(X[k] - X[j]) + abs(Y[k] - Y[i]));\n\t\t\t}\n\n\t\t\tsum -= maxs;\n\n\t\t\tif (sum < ret)\n\t\t\t{\n\t\t\t\tret = sum;\n\n\t\t\t\tx = X[j];\n\t\t\t\ty = Y[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\tprintf(\"%d %d\\n\", x, y);\n\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n \nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\nfnBin op f g x = op (f x) $ g x\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nmodifyArray :: (Ix i, MArray a e m) => a i e -> i -> (e -> e) -> m ()\nmodifyArray arr ix f = readArray arr ix >>= writeArray arr ix . f\n-- end of templete\n\n\nmain = do\n    [w, h] <- getInts\n    n <- getInt\n    d <- replicateM n getIntegers\n    let [x,y] = map (!!(div (n-1) 2)) $ map sort $ transpose d\n    let costs = [abs (x-i) + abs (y-j) | [i,j] <- d]\n    print $ 2 * sum costs - maximum costs\n    putStrLn $ sjoin [x,y]"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT (100000000000000000LL)\n#define MAX_N   (100000)\n\n/* typedef */\n\ntypedef long long ll;\n\n/* global variables */\n\nstatic ll hxs[MAX_N], hys[MAX_N], hsxs[MAX_N], hsys[MAX_N];\n\n/* subroutines */\n\nll distxy(ll x0, ll y0, ll x1, ll y1) {\n  ll dx, dy;\n\n  dx = x1 - x0;\n  if (dx < 0) dx = -dx;\n  dy = y1 - y0;\n  if (dy < 0) dy = -dy;\n\n  return (dx + dy);\n}\n\nint compll(const void *a, const void *b) {\n  ll diff = *((ll *)a) - *((ll *)b);\n  return (diff == 0) ? 0 : (diff < 0) ? -1 : 1;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int h, i, k, n, w;\n  ll d, max_dist, min_sx, min_sy, min_sumd;\n  ll sxs[2], sys[2];\n\n  scanf(\"%d %d\", &w, &h);\n  scanf(\"%d\", &n);\n\n  for (i = 0; i < n; i++) {\n    ll xi, yi;\n\n    scanf(\"%lld %lld\", &xi, &yi);\n    hxs[i] = hsxs[i] = xi;\n    hys[i] = hsys[i] = yi;\n  }\n\n  qsort(hsxs, n, sizeof(ll), compll);\n  qsort(hsys, n, sizeof(ll), compll);\n\n  sxs[0] = hsxs[(n - 1) / 2];\n  sys[0] = hsys[(n - 1) / 2];\n  sxs[1] = hsxs[(n + 1) / 2];\n  sys[1] = hsys[(n + 1) / 2];\n\n  min_sumd = MAX_INT;\n  min_sx = min_sy = -1;\n\n  for (k = 0; k < 4; k++) {\n    ll sumd = 0;\n    ll max_dist = 0;\n    ll sx = sxs[k / 2];\n    ll sy = sys[k % 2];\n    /*printf(\"sx=%lld, sy=%lld\\n\", sx, sy);*/\n\n    for (i = 0; i < n; i++) {\n      d = distxy(hxs[i], hys[i], sx, sy);\n      sumd += d;\n      if (max_dist < d) max_dist = d;\n    }\n\n    sumd = sumd * 2 - max_dist;\n\n    if (min_sumd > sumd) {\n      min_sumd = sumd;\n      min_sx = sx;\n      min_sy = sy;\n    }\n  }\n\n  printf(\"%lld\\n\", min_sumd);\n  printf(\"%lld %lld\\n\", min_sx, min_sy);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k;\n\tlong long ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=abs(a[i].x-nx)*2+abs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%lld\\n\",ans-m);\n\tprintf(\"%d %d\\n\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#define mem(x,y)\t\t(x*)malloc(sizeof(x)*(y))\n#define PI 3.14159265358979\n\nint int_sort(const void* a,const void* b)\n{\n\tif(*(int*)a > *(int*)b)\n\t{\n\t\treturn 1;\n\t}\n\telse if(*(int*)a == *(int*)b)\n\t{\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint w,h,n;\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tint** list = mem(int*,2);\n\tint** data = mem(int*,n);\n\tlist[0] = mem(int,n);\n\tlist[1] = mem(int,n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tdata[i] = mem(int,2);\n\t\tscanf(\"%d %d\",&data[i][0],&data[i][1]);\n\t\tlist[0][i] = data[i][0];\n\t\tlist[1][i] = data[i][1];\n\t}\n\tqsort(list[0],n,sizeof(int),int_sort);\n\tqsort(list[1],n,sizeof(int),int_sort);\n\tint a,b,c,d;\n\ta = list[0][(n-1)/2];\n\tb = list[1][(n-1)/2];\n\tc = list[0][n/2];\n\td = list[1][n/2];\n\tlong long int time = 0;\n\tlong long int maxtime = 0;\n\tint maxp = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tint times[4];\n\t\tconst int dis[4] = {abs(a-data[i][0]),abs(b-data[i][1]),abs(c-data[i][0]),abs(d-data[i][1])};\n\t\ttimes[0] = dis[0]+dis[1];\n\t\ttimes[1] = dis[0]+dis[3];\n\t\ttimes[2] = dis[2]+dis[1];\n\t\ttimes[3] = dis[2]+dis[3];\n\t\ttime += times[0];\n\t\tfor(j = 0;j < 4;j++)\n\t\t{\n\t\t\tif(times[j] > maxtime)\n\t\t\t{\n\t\t\t\tmaxtime = times[j];\n\t\t\t\tmaxp = j;\n\t\t\t}\n\t\t\telse if(times[j] == maxtime)\n\t\t\t{\n\t\t\t\tif(maxp > j)\n\t\t\t\t{\n\t\t\t\t\tmaxp = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",time*2-maxtime);\n\tswitch(maxp)\n\t{\n\t\tcase 0:\n\t\t\tprintf(\"%d %d\\n\",a,b);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"%d %d\\n\",a,d);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"%d %d\\n\",c,b);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%d %d\\n\",c,d);\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[65], *p;\nint getInt(void)\n{\n\tint n;\n\tif (*p == ' ') p++;\n\tn = 0; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\ntypedef struct { int x, y; } PP;\nPP pp[100002];\nint x[100002], y[100002];\n\nlong long calc(int x0, int y0, int n)\n{\n\tint i, dx, dy, max;\n\tlong long sum, ans;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tfor (p = pp, i = n; i--; p++) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\tif (dy < 0) dy = -dy;\n\t\tdx += dy;\n\t\tsum += dx << 1;\n\t\tif (dx > max) max = dx;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, n, i, xpos, ypos;\n\n\tfgets(p=buf, 64, stdin), w = getInt(), h = getInt();\n\tfgets(p=buf, 64, stdin), n = getInt();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 64, stdin);\n\t\tpp[i].x = x[i] = getInt(), pp[i].y = y[i] = getInt();\n\t}\n\tqsort(x, n, sizeof(int), cmp), qsort(y, n, sizeof(int), cmp);\n\n\txpos = x[(n-1)/2], ypos = y[(n-1)/2]; \n\tprintf(\"%lld\\n%d %d\\n\", calc(xpos, ypos, n), xpos, ypos);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nlong long mabs(long long a){\n\treturn (a>0)?a:-a;\n}\nint main(){\n\tlong long i,j,n,w,h,nx,ny,an,bn,k;\n\tlong long ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=mabs(a[i].x-nx)*2+mabs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%lld\\n\",ans-m);\n\tprintf(\"%lld %lld\\n\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n// 2018.1.5\n\n#include <stdio.h>\n//#include <stdlib.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define THRESHOLD 10\n#define STACKSIZE 35\t\t// 2^32 for int\n\nvoid quicksort(int *a, int n)\n{\n\tint i, j, l, r, m, p;\n\tint lsp[STACKSIZE], rsp[STACKSIZE];\n\tint t;\n\t\n\tl = 0, r = n-1, p = 0;\n\twhile (1) {\n\t\tif (r-l <= THRESHOLD) {\n\t\t\tif (!p--) break;\n\t\t\tl = lsp[p], r = rsp[p];\n\t\t}\n\t\tm = a[(l+r)>>1];\n\t\ti = l, j = r;\n\t\twhile (1) {\n\t\t\twhile (a[i] < m) i++;\n\t\t\twhile (m < a[j]) j--;\n\t\t\tif (i >= j) break;\n\t\t\tt = a[i], a[i] = a[j], a[j] = t;\n\t\t\ti++, j--;\n\t\t}\n\t\tif (i-l > r-j) {\n\t\t\tif (i-l > THRESHOLD) {\n\t\t\t\tlsp[p] = l;\n\t\t\t\trsp[p] = i-1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tl = j+1;\n\t\t} else {\n\t\t\tif (r-j > THRESHOLD) {\n\t\t\t\tlsp[p] = j+1;\n\t\t\t\trsp[p] = r;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tr = i-1;\n\t\t}\n\t}\n\t\n\t// insert sorting\n\tfor (i = 1; i < n; i++) {\n\t\tm = a[i];\n\t\tfor (j = i-1; j >= 0 && a[j] > m; j--) a[j+1] = a[j];\n\t\ta[j+1] = m;\n\t}\n}\n\n\n//int cmp(int *a, int *b) { return *a - *b; }\n\ntypedef struct { int x, y; } PP;\nPP pp[100002];\nint x[100002], y[100002];\n\nlong long calc(int x0, int y0, int n)\n{\n\tint i;\n\tlong long sum, ans, dx, dy, max;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tp = pp, i = n;\n\twhile (i--) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\tif (dy < 0) dy = -dy;\n\t\tdx += dy;\n\t\tsum += dx << 1;\n\t\tif (dx > max) max = dx;\n\t\tp++;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, n, i, xpos, ypos, m;\n\tlong long ans, a;\n\n\tw = in(), h = in(), n = in();\n\tfor (i = 0; i < n; i++) {\n\t\tpp[i].x = x[i] = in(), pp[i].y = y[i] = in();\n\t}\n#if 0\n\tqsort(x, n, sizeof(int), cmp), qsort(y, n, sizeof(int), cmp);\n#else\n\tquicksort(x, n), quicksort(y, n), \n#endif\n\tm = (n-1)>>1, xpos = x[m], ypos = y[m];\n\tans = calc(xpos, ypos, n);\n\tif (!(n & 1)) {\n\t\tif (x[m] == x[m+1] && y[m] == y[m+1]);\n\t\telse if (x[m] == x[m+1]) {\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t} else if (y[m] == y[m+1]) {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t} else {\n\t\t\ta = calc(x[m], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m], ypos = y[m+1];\n\t\t\ta = calc(x[m+1], y[m], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m];\n\t\t\ta = calc(x[m+1], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m+1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, xpos, ypos);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef long long ll;\nint max;\n\nll dist(int x1, int y1, int x2, int y2)\n{\n    if (abs(x2 - x1) + abs(y2 - y1) > max){\n        max = abs(x2 - x1) + abs(y2 - y1);\n    }\n    return (2 * (abs(x2 - x1) + abs(y2 - y1)));\n}\n\nint comp(const void *a, const void * b)\n{\n    int x, y;\n    \n    x = *(int *)a;\n    y = *(int *)b;\n    \n    return (x - y);\n}\n\nint main(void)\n{\n    static int hx[100000], hy[100000];\n    static int mx[100000], my[100000];\n    int i;\n    int w, h, n;\n    int pivx, pivy;\n    ll res;\n    \n    scanf(\"%d%d\", &w, &h);\n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++){\n        scanf(\"%d%d\", &hx[i], &hy[i]);\n    }\n    \n    memcpy(my, hy, sizeof(hy));\n    memcpy(mx, hx, sizeof(hx));\n    \n    qsort(hx, n, sizeof(int), comp);\n    qsort(hy, n, sizeof(int), comp);\n    \n    pivx = hx[(n - 1) / 2];\n    pivy = hy[(n - 1) / 2];\n    \n    res = 0;\n    \n    for (i = 0; i < n; i++){\n        res += dist(pivx, pivy, mx[i], my[i]);\n    }\n    res -= max;\n    \n    printf(\"%lld\\n%d %d\\n\", res, pivx, pivy);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k,ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=abs(a[i].x-nx)*2+abs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%d\\n\",ans-m);\n\tprintf(\"%d %d\\n\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[65], *p;\nint getInt(void)\n{\n\tint n;\n\tif (*p == ' ') p++;\n\tn = 0; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\ntypedef struct { int x, y; } PP;\nPP pp[100002];\nint x[100002], y[100002];\n\nlong long calc(int x0, int y0, int n)\n{\n\tint i;\n\tlong long sum, ans, dx, dy, max;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tfor (p = pp, i = n; i--; p++) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\tif (dy < 0) dy = -dy;\n\t\tdx += dy;\n\t\tsum += dx << 1;\n\t\tif (dx > max) max = dx;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, n, i, xpos, ypos, m;\n\tlong long ans, a;\n\n\tfgets(p=buf, 64, stdin), w = getInt(), h = getInt();\n\tfgets(p=buf, 64, stdin), n = getInt();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 64, stdin);\n\t\tpp[i].x = x[i] = getInt(), pp[i].y = y[i] = getInt();\n\t}\n\tqsort(x, n, sizeof(int), cmp), qsort(y, n, sizeof(int), cmp);\n\n\tm = (n-1)/2, xpos = x[m], ypos = y[m];\n\tans = calc(xpos, ypos, n);\n\tif (!(n & 1)) {\n\t\tif (x[m] == x[m+1] && y[m] == y[m+1]);\n\t\telse if (x[m] == x[m+1]) {\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t} else if (y[m] == y[m+1]) {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t} else {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t\ta = calc(x[m+1], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m+1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, xpos, ypos);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k,ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=abs(a[i].x-nx)*2+abs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%d\\n\",ans-m);\n\tprintf(\"%d %d\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint dx[100000],dy[100000];\nint main(){\n  unsigned long min=0,s;\n  int X[]={1,0,-1,0};\n  int Y[]={0,1,0,-1};\n  int w,h,n,i,j,max=0,d;\n  scanf(\"%d %d %d\",&w,&h,&n);\n  int x=w/2,y=h/2;\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&dx[i],&dy[i]);\n    d=abs(x-dx[i])+abs(y-dy[i]);\n    if(max<d)max=d;\n    min+=2*d;\n  }\n  min-=max;\n  while(1){//printf(\"%d %d\\n\",x,y);\n    for(i=0;i<4;i++){\n      max=0;\n      s=0;\n      for(j=0;j<n;j++){\n\td=abs(x+X[i]-dx[j])+abs(y+Y[i]-dy[j]);\n\tif(max<d)max=d;\n\ts+=d;\n      }\n      if(min>s*2-max||(min>=s*2-max&&i>1)){\n\tmin=s*2-max;\n\tx+=X[i];\n\ty+=Y[i];\n\tbreak;\n      }\n    }\n    if(i==4)break;\n  }\n  printf(\"%d\\n%d %d\\n\",min,x,y);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint dx[100000],dy[100000];\nint main(){\n  unsigned long min=0,s;\n  int X[]={1,0,-1,0};\n  int Y[]={0,1,0,-1};\n  int w,h,n,i,j,max=0,d;\n  scanf(\"%d %d %d\",&w,&h,&n);\n  int x=w/2,y=h/2;\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&dx[i],&dy[i]);\n    d=abs(x-dx[i])+abs(y-dy[i]);\n    if(max<d)max=d;\n    min+=2*d;\n  }\n  min-=max;\n  while(1){printf(\"%d %d\\n\",x,y);\n    for(i=0;i<4;i++){\n      max=0;\n      s=0;\n      for(j=0;j<n;j++){\n\td=abs(x+X[i]-dx[j])+abs(y+Y[i]-dy[j]);\n\tif(max<d)max=d;\n\ts+=d;\n      }\n      if(min>s*2-max||(min>=s*2-max&&i>1)){\n\tmin=s*2-max;\n\tx+=X[i];\n\ty+=Y[i];\n\tbreak;\n      }\n    }\n    if(i==4)break;\n  }\n  printf(\"%d\\n%d %d\\n\",min,x,y);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint house_x[100000];\nint house_y[100000];\nint house_sort[100000];\n\nint qsort_comp(const void* x,const void* y) {\n\tint* a=(int*)x;\n\tint* b=(int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint W,H;\n\tint N;\n\tint i;\n\tlong long nowkyori;\n\tlong long kyorisum;\n\tlong long longest;\n\tint center_x,center_y;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&house_x[i],&house_y[i]);\n\t}\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_x[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tcenter_x=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_y[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tcenter_y=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tkyorisum=0;\n\tlongest=0;\n\tfor(i=0;i<N;i++) {\n\t\tnowkyori=abs(house_x[i]-center_x)+abs(house_y[i]-center_y);\n\t\tkyorisum+=nowkyori*2LL;\n\t\tif(nowkyori>longest)longest=nowkyori;\n\t}\n\tkyorisum-=longest;\n\tprintf(\"%lld\\n\",kyorisum);\n\tprintf(\"%d %d\\n\",center_x,center_y);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nlong long mabs(long long a){\n\treturn (a>0)?a:-a;\n}\nint main(){\n\tlong long i,j,n,w,h,nx,ny,an,bn,k;\n\tlong long ans,m;\n\tscanf(\"%lld%lld%lld\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=mabs(a[i].x-nx)*2+mabs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%lld\\n\",ans-m);\n\tprintf(\"%lld %lld\\n\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[65], *p;\nint getInt(void)\n{\n\tint n;\n\tif (*p == ' ') p++;\n\tn = 0; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\ntypedef struct { int x, y; } PP;\nPP pp[100002];\nint x[100002], y[100002];\n\nlong long calc(int x0, int y0, int n)\n{\n\tint i;\n\tlong long sum, ans, dx, dy, max;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tfor (p = pp, i = n; i--; p++) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\tif (dy < 0) dy = -dy;\n\t\tdx += dy;\n\t\tsum += dx << 1;\n\t\tif (dx > max) max = dx;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, n, i, xpos, ypos, m;\n\tlong long ans, a;\n\n\tfgets(p=buf, 64, stdin), w = getInt(), h = getInt();\n\tfgets(p=buf, 64, stdin), n = getInt();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 64, stdin);\n\t\tpp[i].x = x[i] = getInt(), pp[i].y = y[i] = getInt();\n\t}\n\tqsort(x, n, sizeof(int), cmp), qsort(y, n, sizeof(int), cmp);\n\n\tm = (n-1)/2, xpos = x[m], ypos = y[m];\n\tans = calc(xpos, ypos, n);\n\tif (!(n & 1)) {\n\t\tif (x[m] == x[m+1] && y[m] == y[m+1]);\n\t\telse if (x[m] == x[m+1]) {\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t} else if (y[m] == y[m+1]) {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t} else {\n\t\t\ta = calc(x[m], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m], ypos = y[m+1];\n\t\t\ta = calc(x[m+1], y[m], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m];\n\t\t\ta = calc(x[m+1], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m+1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, xpos, ypos);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n// 2018.1.2\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int x, y; } PP;\nPP pp[100002];\nint x[100002], y[100002];\n\nint cmp(int *a, int *b) { return *a - *b; }\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n, c;\n\n\twhile ((c = getchar_unlocked()) < '0');\n\tn = 0;\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nlong long calc(int x0, int y0, int n)\n{\n\tint i;\n\tlong long sum, ans, dx, dy, max;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tfor (p = pp, i = n; i--; p++) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\tif (dy < 0) dy = -dy;\n\t\tdx += dy;\n\t\tsum += dx << 1;\n\t\tif (dx > max) max = dx;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, n, i, xpos, ypos, m;\n\tlong long ans, a;\n\n\tw = in(), h = in(), n = in();\n\tfor (i = 0; i < n; i++) {\n\t\tpp[i].x = x[i] = in(), pp[i].y = y[i] = in();\n\t}\n\tqsort(x, n, sizeof(int), cmp), qsort(y, n, sizeof(int), cmp);\n\n\tm = (n-1)>>1, xpos = x[m], ypos = y[m];\n\tans = calc(xpos, ypos, n);\n\tif (!(n & 1)) {\n\t\tif (x[m] == x[m+1] && y[m] == y[m+1]);\n\t\telse if (x[m] == x[m+1]) {\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t} else if (y[m] == y[m+1]) {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t} else {\n\t\t\ta = calc(x[m], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m], ypos = y[m+1];\n\t\t\ta = calc(x[m+1], y[m], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m];\n\t\t\ta = calc(x[m+1], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m+1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, xpos, ypos);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef long long ll;\nll max;\n\nll mabs(ll a)\n{\n    if (a < 0){\n        return (-1 * a);\n    }\n    return (a);\n}\n\nll dist(ll x1, ll y1, ll x2, ll y2)\n{\n    if (mabs(x2 - x1) + mabs(y2 - y1) > max){\n        max = mabs(x2 - x1) + mabs(y2 - y1);\n    }\n    return (2 * (mabs(x2 - x1) + mabs(y2 - y1)));\n}\n\nint comp(const void *a, const void * b)\n{\n    ll x, y;\n    \n    x = *(ll *)a;\n    y = *(ll *)b;\n    \n    return (x - y);\n}\n\nint main(void)\n{\n    static ll hx[100000], hy[100000];\n    static ll mx[100000], my[100000];\n    int i, j;\n    int w, h, n;\n    ll pivx[2], pivy[2];\n    ll res, temp;\n    ll ax, ay;\n    \n    scanf(\"%d%d\", &w, &h);\n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++){\n        scanf(\"%lld%lld\", &hx[i], &hy[i]);\n    }\n    \n    memcpy(my, hy, sizeof(hy));\n    memcpy(mx, hx, sizeof(hx));\n    \n    qsort(hx, n, sizeof(ll), comp);\n    qsort(hy, n, sizeof(ll), comp);\n    \n    pivx[0] = hx[(n - 1) / 2];\n    pivy[0] = hy[(n - 1) / 2];\n    pivx[1] = hx[(n + 1) / 2];\n    pivy[1] = hy[(n + 1) / 2];\n    \n    res = -1;\n    for (i = 0; i < 4; i++){\n        max = 0;\n        temp = 0;\n        for (j = 0; j < n; j++){\n            temp += dist(pivx[i / 2], pivy[i % 2], mx[j], my[j]);\n        }\n        temp -= max;\n        if (res == -1 || temp < res){\n            res = temp;\n            ax = pivx[i / 2];\n            ay = pivy[i % 2];\n        }\n    }\n    \n    printf(\"%lld\\n%lld %lld\\n\", res, ax, ay);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[65], *p;\nint getInt(void)\n{\n\tint n;\n\tif (*p == ' ') p++;\n\tn = 0; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\ntypedef struct { int x, y; } PP;\nPP pp[100002]; int n;\n\nint xcmp(PP *a, PP *b) { return a->x - b->x; }\nint ycmp(PP *a, PP *b) { return a->y - b->y; }\n\nlong long calc(int x0, int y0, int yid)\n{\n\tint i, dx, dy;\n\tlong long sum, ans, d, max;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tfor (p = pp, i = 0; i <= yid; i++, p++) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\td = dx + dy;\n\t\tsum += d << 1;\n\t\tif (d > max) max = d;\n\t}\n\tfor ( ; i < n; i++, p++) {\n\t\tdx = x0 - p->x, dy = p->y - y0;\n\t\tif (dx < 0) dx = -dx;\n\t\td = dx + dy;\n\t\tsum += d << 1;\n\t\tif (d > max) max = d;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, i, m, x1, x2, y1, y2, x0, y0;\n\tlong long ans, a;\n\tPP *pt;\n\n\tfgets(p=buf, 64, stdin), w = getInt(), h = getInt();\n\tfgets(p=buf, 64, stdin), n = getInt();\n\tfor (pt = pp, i = n; i--; pt++) {\n\t\tfgets(p=buf, 64, stdin);\n\t\tpt->x = getInt(), pt->y = getInt();\n\t}\n\tm = (n-1)/2;\n\tqsort(pp, n, sizeof(PP), xcmp);\n\tx0 = x1 = pp[m].x, x2 = pp[m+1].x;\n\tqsort(pp, n, sizeof(PP), ycmp);\n\ty0 = y1 = pp[m].y, y2 = pp[m+1].y;\n\n\tans = calc(x0, y0, m);\n\tif (!(n & 1)) {\n\t\tif (x1 == x2 && y1 == y2);\n\t\telse if (x1 == x2) {\n\t\t\ta = calc(x0, y2, m+1);\n\t\t\tif (a < ans) ans = a, y0 = y2;\n\t\t} else if (y1 == y2) {\n\t\t\ta = calc(x2, y0, m);\n\t\t\tif (a < ans) ans = a, x0 = x2;\n\t\t} else {\n\t\t\ta = calc(x1, y2, m+1);\n\t\t\tif (a < ans) ans = a, x0 = x1, y0 = y2;\n\t\t\ta = calc(x2, y1, m);\n\t\t\tif (a < ans) ans = a, x0 = x2, y0 = y1;\n\t\t\ta = calc(x2, y2, m+1);\n\t\t\tif (a < ans) ans = a, x0 = x2, y0 = y2;\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, x0, y0);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint mabs(int a,int b){\n\tif(a>=b)return a-b;\n\telse return b-a;\n}\nint id[100005],x[100005],y[100005];\nint x2[100005],y2[100005];\nint x3[5],y3[5];\nint main(){\n\tint i,j,k;\n\tint w,h,n,t,xn,yn;\n\tlong long ans,sa[5],md,z;\n\t\n\tscanf(\"%d%d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tx2[i]=x[i];\n\t\ty2[i]=y[i];\n\t}\n\tqsort(x,n,sizeof(int),comp);\n\tt=0;id[t++]=x[0];\n\tfor(i=1;i<n;i++)if(x[i]!=id[t-1])id[t++]=x[i];\n\tfor(i=0;i<t;i++)x[i]=id[i];\n\txn=t;\n\tqsort(y,n,sizeof(int),comp);\n\tt=0;id[t++]=y[0];\n\tfor(i=1;i<n;i++)if(y[i]!=id[t-1])id[t++]=y[i];\n\tfor(i=0;i<t;i++)y[i]=id[i];\n\tyn=t;\n\t\n\tx3[0]=x[xn/2];y3[0]=y[yn/2];\n\tx3[1]=x[xn/2];y3[1]=y[yn/2-1];\n\tx3[2]=x[xn/2-1];y3[2]=y[yn/2];\n\tx3[3]=x[xn/2-1];y3[3]=y[yn/2-1];\n\t\n\tfor(k=0;k<4;k++){\n\t\t//printf(\"%d %d\\n\",x3[k],y3[k]);\n\t\tmd=0;\n\t\tsa[k]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tz=mabs(x2[i],x3[k])+mabs(y2[i],y3[k]);\n\t\t\tsa[k]+=z*2;\n\t\t\tif(md<z)md=z;\n\t\t}\n\t\tsa[k]-=md;\n\t\t//printf(\"%d %d\\n\",k,sa[k]);\n\t\tif(k==0)ans=sa[k];\n\t\tif(ans>sa[k])ans=sa[k];\n\t}\n\tfor(k=3;k>=0;k--){\n\t\tif(ans==sa[k]){\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\tprintf(\"%d %d\\n\",x3[k],y3[k]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#define mem(x,y)\t\t(x*)malloc(sizeof(x)*(y))\n#define PI 3.14159265358979\n\nint int_sort(const void* a,const void* b)\n{\n\tif(*(int*)a > *(int*)b)\n\t{\n\t\treturn 1;\n\t}\n\telse if(*(int*)a == *(int*)b)\n\t{\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint w,h,n;\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tint** list = mem(int*,2);\n\tint** data = mem(int*,n);\n\tlist[0] = mem(int,n);\n\tlist[1] = mem(int,n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tdata[i] = mem(int,2);\n\t\tscanf(\"%d %d\",&data[i][0],&data[i][1]);\n\t\tlist[0][i] = data[i][0];\n\t\tlist[1][i] = data[i][1];\n\t}\n\tqsort(list[0],n,sizeof(int),int_sort);\n\tqsort(list[1],n,sizeof(int),int_sort);\n\tint a,b,c,d;\n\ta = list[0][(n-1)/2];\n\tb = list[1][(n-1)/2];\n\tc = list[0][n/2];\n\td = list[1][n/2];\n\tint time = 0;\n\tint maxtime = 0;\n\tint maxp = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tint times[4];\n\t\ttimes[0] = abs(a-data[i][0])+abs(b-data[i][1]);\n\t\ttimes[1] = abs(a-data[i][0])+abs(d-data[i][1]);\n\t\ttimes[2] = abs(c-data[i][0])+abs(b-data[i][1]);\n\t\ttimes[3] = abs(c-data[i][0])+abs(d-data[i][1]);\n\t\ttime += times[0];\n\t\tfor(j = 0;j < 4;j++)\n\t\t{\n\t\t\tif(times[j] > maxtime)\n\t\t\t{\n\t\t\t\tmaxtime = times[j];\n\t\t\t\tmaxp = j;\n\t\t\t}\n\t\t\telse if(times[j] == maxtime)\n\t\t\t{\n\t\t\t\tif(maxp > j)\n\t\t\t\t{\n\t\t\t\t\tmaxp = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",time*2-maxtime);\n\tswitch(maxp)\n\t{\n\t\tcase 0:\n\t\t\tprintf(\"%d %d\\n\",a,b);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"%d %d\\n\",a,d);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"%d %d\\n\",c,b);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%d %d\\n\",c,d);\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k,ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=abs(a[i].x-nx)*2+abs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%d\\n\",ans-m);\n\tprintf(\"%d %d\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k;\n\tlong long ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=abs(a[i].x-nx)*2+abs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%lld\\n\",ans-m);\n\tprintf(\"%d %d\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef __int64 ll;\nint max;\n\nll dist(int x1, int y1, int x2, int y2)\n{\n    if (abs(x2 - x1) + abs(y2 - y1) > max){\n        max = abs(x2 - x1) + abs(y2 - y1);\n    }\n    return (2 * (abs(x2 - x1) + abs(y2 - y1)));\n}\n\nint comp(const void *a, const void * b)\n{\n    int x, y;\n    \n    x = *(int *)a;\n    y = *(int *)b;\n    \n    return (x - y);\n}\n\nint main(void)\n{\n    static int hx[100000], hy[100000];\n    static int mx[100000], my[100000];\n    int i;\n    int w, h, n;\n    int pivx, pivy;\n    ll res;\n    \n    scanf(\"%d%d\", &w, &h);\n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++){\n        scanf(\"%d%d\", &hx[i], &hy[i]);\n    }\n    \n    memcpy(my, hy, sizeof(hy));\n    memcpy(mx, hx, sizeof(hx));\n    \n    qsort(hx, n, sizeof(int), comp);\n    qsort(hy, n, sizeof(int), comp);\n    \n    pivx = hx[(n - 1) / 2];\n    pivy = hy[(n - 1) / 2];\n    \n    res = 0;\n    \n    for (i = 0; i < n; i++){\n        res += dist(pivx, pivy, mx[i], my[i]);\n    }\n    res -= max;\n    \n    printf(\"%I64d\\n%d %d\\n\", res, pivx, pivy);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint house_x[100000];\nint house_y[100000];\nint house_sort[100000];\n\nint qsort_comp(const void* x,const void* y) {\n\tint* a=(int*)x;\n\tint* b=(int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint W,H;\n\tint N;\n\tint i;\n\tlong long nowkyori;\n\tlong long kyorisum;\n\tlong long longest;\n\tint center_x,center_y;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&house_x[i],&house_y[i]);\n\t}\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_x[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tcenter_x=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_y[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tcenter_y=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tkyorisum=0;\n\tlongest=0;\n\tfor(i=0;i<N;i++) {\n\t\tnowkyori=abs(house_x[i]-center_x)+abs(house_y[i]-center_y);\n\t\tkyorisum+=nowkyori*2LL;\n\t\tif(nowkyori>longest)longest=nowkyori;\n\t}\n\tkyorisum-=longest;\n\tprintf(\"%lld\\n\",kyorisum);\n\tprintf(\"%d %d\\n\",center_x,center_y);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[65], *p;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\ntypedef struct { int x, y; } PP;\nPP pp[100002]; int n;\nlong long ans; int xx, yy;\n\nint xcmp(PP *a, PP *b) { return a->x - b->x; }\nint ycmp(PP *a, PP *b) { return a->y - b->y; }\n\nvoid calc(int x0, int y0, int yid)\n{\n\tint i, dx;\n\tlong long sum, d, max;\n\tPP *p;\n\n\tsum = 0, max = 0;\n\tfor (p = pp, i = 0; i <= yid; i++, p++) {\n\t\tdx = x0 - p->x;\tif (dx < 0) dx = -dx;\n\t\tif ((d = dx + y0 - p->y) > max) max = d;\n\t\tsum += d << 1;\n\t}\n\tfor ( ; i < n; i++, p++) {\n\t\tdx = x0 - p->x; if (dx < 0) dx = -dx;\n\t\tif ((d = dx + p->y - y0) > max) max = d;\n\t\tsum += d << 1;\n\t}\n\tsum -= max;\n\tif (sum < ans) ans = sum, xx = x0, yy = y0;\n}\n\nint main()\n{\n\tint w, h, i, m, x1, x2, y1, y2;\n\tPP *pt;\n\n\tfgets(p=buf, 64, stdin), w = getInt(), p++, h = getInt();\n\tfgets(p=buf, 64, stdin), n = getInt();\n\tfor (pt = pp, i = n; i--; pt++) {\n\t\tfgets(p=buf, 64, stdin);\n\t\tpt->x = getInt(), p++, pt->y = getInt();\n\t}\n\tm = (n-1)/2;\n\tqsort(pp, n, sizeof(PP), xcmp), x1 = pp[m].x, x2 = pp[m+1].x;\n\tqsort(pp, n, sizeof(PP), ycmp), y1 = pp[m].y, y2 = pp[m+1].y;\n\n\tans = 1LL << 62, xx = x1, yy = y1;\n\tcalc(x1, y1, m);\n\tif (!(n & 1)) {\n\t\tif (x1 == x2 && y1 == y2);\n\t\telse if (x1 == x2) calc(x1, y2, m+1);\n\t\telse if (y1 == y2) calc(x2, y1, m);\n\t\telse calc(x1, y2, m+1), calc(x2, y1, m), calc(x2, y2, m+1);\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, xx, yy);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k,ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=abs(a[i].x-nx)*2+abs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%d\\n\",ans-m);\n\tprintf(\"%d %d\\n\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint house_x[100000];\nint house_y[100000];\nint house_sort[100000];\n\nint qsort_comp(const void* x,const void* y) {\n\tint* a=(int*)x;\n\tint* b=(int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint W,H;\n\tint N;\n\tint i;\n\tlong long nowkyori;\n\tlong long kyorisum;\n\tlong long longest;\n\tint center_x,center_y;\n\tint test_a,test_b,test_c,test_d;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&house_x[i],&house_y[i]);\n\t}\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_x[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tif(N%2==0) {\n\t\ttest_a=house_sort[N/2]-house_sort[0];\n\t\ttest_b=house_sort[N-1]-house_sort[N/2];\n\t\ttest_c=house_sort[N/2-1]-house_sort[0];\n\t\ttest_d=house_sort[N-1]-house_sort[N/2-1];\n\t\tif(test_b>test_a)test_a=test_b;\n\t\tif(test_a<test_c || test_a<test_d) {\n\t\t\tcenter_x=house_sort[N/2];\n\t\t} else {\n\t\t\tcenter_x=house_sort[N/2-1];\n\t\t}\n\t} else {\n\t\tcenter_x=house_sort[N/2];\n\t}\n\tcenter_x=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_y[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tif(N%2==0) {\n\t\ttest_a=house_sort[N/2]-house_sort[0];\n\t\ttest_b=house_sort[N-1]-house_sort[N/2];\n\t\ttest_c=house_sort[N/2-1]-house_sort[0];\n\t\ttest_d=house_sort[N-1]-house_sort[N/2-1];\n\t\tif(test_b>test_a)test_a=test_b;\n\t\tif(test_a<test_c || test_a<test_d) {\n\t\t\tcenter_y=house_sort[N/2];\n\t\t} else {\n\t\t\tcenter_y=house_sort[N/2-1];\n\t\t}\n\t} else {\n\t\tcenter_y=house_sort[N/2];\n\t}\n\tkyorisum=0;\n\tlongest=0;\n\tfor(i=0;i<N;i++) {\n\t\tnowkyori=abs(house_x[i]-center_x)+abs(house_y[i]-center_y);\n\t\tkyorisum+=nowkyori*2LL;\n\t\tif(nowkyori>longest)longest=nowkyori;\n\t}\n\tkyorisum-=longest;\n\tprintf(\"%lld\\n\",kyorisum);\n\tprintf(\"%d %d\\n\",center_x,center_y);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#define mem(x,y)\t\t(x*)malloc(sizeof(x)*(y))\n#define PI 3.14159265358979\n\nint int_sort(const void* a,const void* b)\n{\n\tif(*(int*)a > *(int*)b)\n\t{\n\t\treturn 1;\n\t}\n\telse if(*(int*)a == *(int*)b)\n\t{\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint w,h,n;\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tint** list = mem(int*,2);\n\tint** data = mem(int*,n);\n\tlist[0] = mem(int,n);\n\tlist[1] = mem(int,n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tdata[i] = mem(int,2);\n\t\tscanf(\"%d %d\",&data[i][0],&data[i][1]);\n\t\tlist[0][i] = data[i][0];\n\t\tlist[1][i] = data[i][1];\n\t}\n\tqsort(list[0],n,sizeof(int),int_sort);\n\tqsort(list[1],n,sizeof(int),int_sort);\n\tint a,b,c,d;\n\ta = list[0][(n-1)/2];\n\tb = list[1][(n-1)/2];\n\tc = list[0][n/2];\n\td = list[1][n/2];\n\tlong long int time = 0;\n\tlong long int maxtime = 0;\n\tint maxp = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tint times[4];\n\t\ttimes[0] = abs(a-data[i][0])+abs(b-data[i][1]);\n\t\ttimes[1] = abs(a-data[i][0])+abs(d-data[i][1]);\n\t\ttimes[2] = abs(c-data[i][0])+abs(b-data[i][1]);\n\t\ttimes[3] = abs(c-data[i][0])+abs(d-data[i][1]);\n\t\ttime += times[0];\n\t\tfor(j = 0;j < 4;j++)\n\t\t{\n\t\t\tif(times[j] > maxtime)\n\t\t\t{\n\t\t\t\tmaxtime = times[j];\n\t\t\t\tmaxp = j;\n\t\t\t}\n\t\t\telse if(times[j] == maxtime)\n\t\t\t{\n\t\t\t\tif(maxp > j)\n\t\t\t\t{\n\t\t\t\t\tmaxp = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",time*2-maxtime);\n\tswitch(maxp)\n\t{\n\t\tcase 0:\n\t\t\tprintf(\"%d %d\\n\",a,b);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"%d %d\\n\",a,d);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"%d %d\\n\",c,b);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%d %d\\n\",c,d);\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct pair{int x,y;}PAIR;\nPAIR a[10005];\nint x[10005],y[10005];\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint comp2(const void *p,const void *q){\n\tPAIR *a=(PAIR *)p,*b=(PAIR *)q;\n\tif(a->x==b->x)return a->y-b->y;\n\telse return a->x-b->x;\n}\nlong long mabs(long long a){\n\treturn (a>0)?a:-a;\n}\nint main(){\n\tint i,j,n,w,h,nx,ny,an,bn,k;\n\tlong long ans,m;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tan=bn=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tfor(j=0;j<an;j++)if(x[j]==a[i].x)break;\n\t\tif(j==an)x[an++]=a[i].x;\n\t\tfor(j=0;j<bn;j++)if(y[j]==a[i].y)break;\n\t\tif(j==bn)y[bn++]=a[i].y;\n\t}\n\tqsort(x,an,sizeof(int),comp);\n\tqsort(y,bn,sizeof(int),comp);\n\tqsort(a,n,sizeof(PAIR),comp2);\n\tnx=x[0];ny=y[0];\n\tfor(i=0,k=0;i<an;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].x<=x[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tnx=x[i];\n\tfor(i=0,k=0;i<bn;i++){\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(a[j].y<=y[i])k++;\n\t\tif(k>=(n+1)/2)break;\n\t}\n\tny=y[i];\n\tans=m=0;\n\tfor(i=0;i<n;i++){\n\t\tj=mabs(a[i].x-nx)*2+mabs(a[i].y-ny)*2;\n\t\tans+=j;\n\t\tm=Max(m,j/2);\n\t}\n\tprintf(\"%lld\\n\",ans-m);\n\tprintf(\"%d %d\\n\",nx,ny);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint mabs(int a,int b){\n\tif(a>=b)return a-b;\n\telse return b-a;\n}\nint id[100005],x[100005],y[100005];\nint x2[100005],y2[100005];\nint x3[5],y3[5];\nint main(){\n\tint i,j,k;\n\tint w,h,n,t,xn,yn;\n\tlong long ans,sa[5],md,z;\n\t\n\tscanf(\"%d%d\",&w,&h);\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tx2[i]=x[i];\n\t\ty2[i]=y[i];\n\t}\n\txn=yn=n;\n\tqsort(x,n,sizeof(int),comp);\n\t//t=0;id[t++]=x[0];\n\t//for(i=1;i<n;i++)if(x[i]!=id[t-1])id[t++]=x[i];\n\t//for(i=0;i<t;i++)x[i]=id[i];\n\t//xn=t;\n\tqsort(y,n,sizeof(int),comp);\n\t//t=0;id[t++]=y[0];\n\t//for(i=1;i<n;i++)if(y[i]!=id[t-1])id[t++]=y[i];\n\t//for(i=0;i<t;i++)y[i]=id[i];\n\t//yn=t;\n\t\n\t//printf(\"xn %d   xn/2 %d\\n\",xn,xn/2);\n\tx3[0]=x[xn/2];y3[0]=y[yn/2];\n\tx3[1]=x[xn/2];y3[1]=y[yn/2-1];\n\tx3[2]=x[xn/2-1];y3[2]=y[yn/2];\n\tx3[3]=x[xn/2-1];y3[3]=y[yn/2-1];\n\t\n\tfor(k=0;k<4;k++){\n\t\t//printf(\"%d %d\\n\",x3[k],y3[k]);\n\t\tmd=0;\n\t\tsa[k]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tz=mabs(x2[i],x3[k])+mabs(y2[i],y3[k]);\n\t\t\tsa[k]+=z*2;\n\t\t\tif(md<z)md=z;\n\t\t}\n\t\tsa[k]-=md;\n\t\t//printf(\"%d %d\\n\",k,sa[k]);\n\t\tif(k==0)ans=sa[k];\n\t\tif(ans>sa[k])ans=sa[k];\n\t}\n\tfor(k=3;k>=0;k--){\n\t\tif(ans==sa[k]){\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\tprintf(\"%d %d\\n\",x3[k],y3[k]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0563: Walking Santa\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[65], *p;\nint getInt(void)\n{\n\tint n;\n\tif (*p == ' ') p++;\n\tn = 0; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\ntypedef struct { int x, y; } PP;\nPP pp[100002];\nint x[100002], y[100002];\n\nlong long calc(int x0, int y0, int n)\n{\n\tint i, dx, dy, max;\n\tlong long sum, ans;\n\tPP *p;\n\n\tsum = 0, max = 0, ans = 1LL << 60;\n\tfor (p = pp, i = n; i--; p++) {\n\t\tdx = x0 - p->x, dy = y0 - p->y;\n\t\tif (dx < 0) dx = -dx;\n\t\tif (dy < 0) dy = -dy;\n\t\tdx += dy;\n\t\tsum += dx << 1;\n\t\tif (dx > max) max = dx;\n\t}\n\tif (sum - max < ans) ans = sum - max;\n\treturn ans;\n}\n\nint main()\n{\n\tint w, h, n, i, xpos, ypos, m;\n\tlong long ans, a;\n\n\tfgets(p=buf, 64, stdin), w = getInt(), h = getInt();\n\tfgets(p=buf, 64, stdin), n = getInt();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 64, stdin);\n\t\tpp[i].x = x[i] = getInt(), pp[i].y = y[i] = getInt();\n\t}\n\tqsort(x, n, sizeof(int), cmp), qsort(y, n, sizeof(int), cmp);\n\n\tm = (n-1)/2, xpos = x[m], ypos = y[m];\n\tans = calc(xpos, ypos, n);\n\tif (!(n & 1)) {\n\t\tif (x[m] == x[m+1] && y[m] == y[m+1]);\n\t\telse if (x[m] == x[m+1]) {\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t} else if (y[m] == y[m+1]) {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t} else {\n\t\t\ta = calc(x[m+1], ypos, n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1];\n\t\t\ta = calc(xpos, y[m+1], n);\n\t\t\tif (a < ans) ans = a, ypos = y[m+1];\n\t\t\ta = calc(x[m+1], y[m+1], n);\n\t\t\tif (a < ans) ans = a, xpos = x[m+1], ypos = y[m+1];\n\t\t}\n\t}\n\tprintf(\"%lld\\n%d %d\\n\", ans, xpos, ypos);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint house_x[100000];\nint house_y[100000];\nint house_sort[100000];\n\nint qsort_comp(const void* x,const void* y) {\n\tint* a=(int*)x;\n\tint* b=(int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint W,H;\n\tint N;\n\tint i;\n\tint center;\n\tlong long bestkyori;\n\tlong long nowkyori;\n\tlong long kyorisum;\n\tlong long longest;\n\tint center_x_list[2],center_y_list[2];\n\tint center_x,center_y;\n\tint best_x,best_y;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&house_x[i],&house_y[i]);\n\t}\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_x[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tif(N%2==0) {\n\t\tcenter_x_list[0]=house_sort[N/2-1];\n\t\tcenter_x_list[1]=house_sort[N/2];\n\t} else {\n\t\tcenter_x_list[0]=center_x_list[1]=house_sort[N/2];\n\t}\n\tcenter_x=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_y[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tif(N%2==0) {\n\t\tcenter_y_list[0]=house_sort[N/2-1];\n\t\tcenter_y_list[1]=house_sort[N/2];\n\t} else {\n\t\tcenter_y_list[0]=center_y_list[1]=house_sort[N/2];\n\t}\n\tbestkyori=0x7fffffffffffffffLL;\n\tfor(center=0;center<4;center++) {\n\t\tcenter_x=center_x_list[center/2];\n\t\tcenter_y=center_y_list[center%2];\n\t\tkyorisum=0;\n\t\tlongest=0;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tnowkyori=abs(house_x[i]-center_x)+abs(house_y[i]-center_y);\n\t\t\tkyorisum+=nowkyori*2LL;\n\t\t\tif(nowkyori>longest)longest=nowkyori;\n\t\t}\n\t\tkyorisum-=longest;\n\t\tif(kyorisum<bestkyori) {\n\t\t\tbestkyori=kyorisum;\n\t\t\tbest_x=center_x;\n\t\t\tbest_y=center_y;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",bestkyori);\n\tprintf(\"%d %d\\n\",best_x,best_y);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint house_x[100000];\nint house_y[100000];\nint house_sort[100000];\n\nint qsort_comp(const void* x,const void* y) {\n\tint* a=(int*)x;\n\tint* b=(int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint W,H;\n\tint N;\n\tint i;\n\tlong long nowkyori;\n\tlong long kyorisum;\n\tlong long longest;\n\tint center_x,center_y;\n\tscanf(\"%d %d\",&W,&H);\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) {\n\t\tscanf(\"%d %d\",&house_x[i],&house_y[i]);\n\t}\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_x[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tif(N%2==0) {\n\t\tif(house_sort[N/2]-house_sort[0]>\n\t\t\t\thouse_sort[N-1]-house_sort[N/2-1]) {\n\t\t\tcenter_x=house_sort[N/2];\n\t\t} else {\n\t\t\tcenter_x=house_sort[N/2-1];\n\t\t}\n\t} else {\n\t\tcenter_x=house_sort[N/2];\n\t}\n\tcenter_x=house_sort[(N%2==0)?(N/2-1):(N/2)];\n\tfor(i=0;i<N;i++) {\n\t\thouse_sort[i]=house_y[i];\n\t}\n\tqsort(house_sort,N,sizeof(int),qsort_comp);\n\tif(N%2==0) {\n\t\tif(house_sort[N/2]-house_sort[0]>\n\t\t\t\thouse_sort[N-1]-house_sort[N/2-1]) {\n\t\t\tcenter_y=house_sort[N/2];\n\t\t} else {\n\t\t\tcenter_y=house_sort[N/2-1];\n\t\t}\n\t} else {\n\t\tcenter_y=house_sort[N/2];\n\t}\n\tkyorisum=0;\n\tlongest=0;\n\tfor(i=0;i<N;i++) {\n\t\tnowkyori=abs(house_x[i]-center_x)+abs(house_y[i]-center_y);\n\t\tkyorisum+=nowkyori*2LL;\n\t\tif(nowkyori>longest)longest=nowkyori;\n\t}\n\tkyorisum-=longest;\n\tprintf(\"%lld\\n\",kyorisum);\n\tprintf(\"%d %d\\n\",center_x,center_y);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tint[][] p = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = p[i][0] = sc.nextInt(); y[i] = p[i][1] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tlong res = 1L<<60, rx = -1, ry = -1;\n\t\tfor(int px = x[(n-1)/2];px<x[(n-1)/2]+100;px++)for(int py=y[(n-1)/2];py<y[(n-1)/2]+100;py++){\n\t\t\tlong max = 0, sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlong len = Math.abs(px-p[i][0])+Math.abs(py-p[i][1]);\n\t\t\t\tsum+=2*len;\n\t\t\t\tmax = Math.max(max, len);\n\t\t\t}\n\t\t\tif(sum-max < res){\n\t\t\t\tres = sum-max;\n\t\t\t\trx = px; ry = py;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\tSystem.out.println(rx+\" \"+ry);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint w = scanner.nextInt();\n\t\tint h = scanner.nextInt();\n\t\tint n = scanner.nextInt();\n\t\tint[] y = new int[n];\n\t\tint[] x = new int[n];\n\t\tint[] sy = new int[n];\n\t\tint[] sx = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsx[i] = x[i] = scanner.nextInt();\n\t\t\tsy[i] = y[i] = scanner.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint ax = 0;\n\t\tint ay = 0;\n\t\tlong ans = Long.MAX_VALUE;\n\t\tint m = (n - 1) / 2;\n\t\tfor (int i = m; i <= m + 1; i++) {\n\t\t\tfor (int j = m; j <= m + 1; j++) {\n\t\t\t\tlong res = 0;\n\t\t\t\tlong max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tlong dis = Math.abs(sx[k] - x[i]) + Math.abs(sy[k] - y[j]);\n\t\t\t\t\tres += dis * 2;\n\t\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\t}\n\t\t\t\tres -= max;\n\t\t\t\tif (res < ans) {\n\t\t\t\t\tans = res;\n\t\t\t\t\tax = x[i];\n\t\t\t\t\tay = y[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(ax + \" \" + ay);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tint[][] pos = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpos[i][0] = x[i] = sc.nextInt(); pos[i][1] = y[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x); Arrays.sort(y);\n\t\tint rx = x[0], ry = y[0];\n\t\tlong sx = 0, sy = 0, mx = 0, my = 0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tsx += x[i]-x[0]; sy += y[i]-y[0];\n\t\t\tmx = 2*sx-x[n-1]+x[0]; my = 2*sy-y[n-1]+y[0];\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint dx = x[i]-x[i-1], dy = y[i]-y[i-1];\n\t\t\tsx = sx-(n-i)*dx+i*dx;\n\t\t\tsy = sy-(n-i)*dy+i*dy;\n\t\t\tlong nx = 2*sx-Math.max(x[n-1]-x[i], x[i]-x[0]), ny = 2*sy-Math.max(y[n-1]-y[i], y[i]-y[0]);\n\t\t\tif(nx<mx){\n\t\t\t\tmx = nx; rx = x[i];\n\t\t\t}\n\t\t\tif(ny<my){\n\t\t\t\tmy = ny; ry = y[i];\n\t\t\t}\n\t\t}\n\t\tlong res = 0, max = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres += 2*(Math.abs(x[i]-rx)+Math.abs(y[i]-ry));\n\t\t\tmax = Math.max(max, Math.abs(pos[i][0]-rx)+Math.abs(pos[i][1]-ry));\n\t\t}\n\t\tSystem.out.println((res-max)+\"\\n\"+rx+\" \"+ry);\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tio.nextLong(); //w\n\t\tio.nextLong(); //h\n\t\tint n = io.nextInt();\n\t\tHouse[] h = new House[n];\n\t\tHouse[] hx = new House[n];\n\t\tHouse[] hy = new House[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = io.nextInt();\n\t\t\tint y = io.nextInt();\n\t\t\th[i] = hx[i] = hy[i] = new House(x,y,i);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.out.println(h[0].x + \" \" + h[0].y);\n\t\t\treturn;\n\t\t}\n\t\tArrays.sort(hx, new Comparator<House>() {\n\t\t\tpublic int compare(House h0, House h1) {\n\t\t\t\treturn Long.signum(h0.x - h1.x);\n\t\t\t}\n\t\t});\n\t\tArrays.sort(hy, new Comparator<House>() {\n\t\t\tpublic int compare(House h0, House h1) {\n\t\t\t\treturn Long.signum(h0.y - h1.y);\n\t\t\t}\n\t\t});\n\t\tfor(int i=0;i<n;i++) {\n\t\t\thx[i].rx = i;\n\t\t\thy[i].ry = i;\n\t\t}\n//\t\tSystem.out.println(Arrays.toString(h));\n//\t\tSystem.out.println(Arrays.toString(hx));\n//\t\tSystem.out.println(Arrays.toString(hy));\n\t\tint mid = (n - 1) / 2;\n\t\tlong min = Long.MAX_VALUE;\n\t\tlong minX = -1;\n\t\tlong minY = -1;\n\t\tlong[] sumx = new long[3];\n\t\tArrays.fill(sumx, Long.MAX_VALUE);\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint i2 = mid - 1 + i;\n\t\t\tif (i2 < 0 || i2 >= n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsumx[i] = 0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tsumx[i] += Math.abs(hx[j].x - hx[i2].x);\n\t\t\t}\n\t\t}\n\t\tlong[] sumy = new long[3];\n\t\tArrays.fill(sumy, Long.MAX_VALUE / 4);\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint i2 = mid - 1 + i;\n\t\t\tif (i2 < 0 || i2 >= n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsumy[i] = 0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tsumy[i] += Math.abs(hy[j].y - hy[i2].y);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\tlong sx = hx[mid-1+i].x;\n\t\t\t\tlong sy = hy[mid-1+j].y;\n\t\t\t\tlong max = 0;\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tmax = Math.max(max,Math.abs(h[k].x-sx) + Math.abs(h[k].y-sy));\n\t\t\t\t}\n\t\t\t\tlong sum = 2 * (sumx[i] + sumy[j]) - max;\n\t\t\t\tif (sum < min) {\n\t\t\t\t\tmin = sum;\n\t\t\t\t\tminX = sx;\n\t\t\t\t\tminY = sy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t\tSystem.out.println(minX + \" \" + minY);\n\t}\n\tstatic int comp(long x1,long y1,long x2,long y2) {\n\t\tif (x1 != x2) {\n\t\t\treturn Long.signum(x1 - x2);\n\t\t}\n\t\treturn Long.signum(y1 - y2);\n\t}\n\tstatic class House {\n\t\tlong x;\n\t\tlong y;\n\t\tint rx;\n\t\tint ry;\n\t\tint id;\n\t\tpublic House(long x,long y,int id) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + x + \",\" + y + \"],[\" + rx + \",\" + ry + \"]:\" + id;\n\t\t}\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, W, H;\n\tstatic int[] X, Y;\n\tstatic int minY, maxY;\n\n\tpublic static void main(String[] args) {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tX = new int[N];\n\t\tY = new int[N];\n\t\tint minX = Integer.MAX_VALUE;\n\t\tint maxX = 0;\n\t\tminY = Integer.MAX_VALUE;\n\t\tmaxY = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = Integer.parseInt(sc.next());\n\t\t\tY[i] = Integer.parseInt(sc.next());\n\t\t\tminX = Math.min(minX, X[i]);\n\t\t\tmaxX = Math.max(maxX, X[i]);\n\t\t\tminY = Math.min(minY, Y[i]);\n\t\t\tmaxY = Math.max(maxY, Y[i]);\n\t\t}\n\t\tlong left = minX;\n\t\tlong right = maxX;\n\t\twhile (right - left > 2) {\n\t\t\tlong m1 = (2 * left + right) / 3;\n\t\t\tlong m2 = (left + 2 * right) / 3;\n\t\t\tlong v1 = calcX(m1)[0];\n\t\t\tlong v2 = calcX(m2)[0];\n\t\t\tif (v1 <= v2) {\n\t\t\t\tright = m2;\n\t\t\t} else {\n\t\t\t\tleft = m1;\n\t\t\t}\n\t\t}\n\t\tlong ans = Long.MAX_VALUE;\n\t\tlong ansX = 0;\n\t\tlong ansY = 0;\n\t\tfor (long x = left; x <= right; ++x) {\n\t\t\tlong[] v = calcX(x);\n\t\t\tif (v[0] < ans) {\n\t\t\t\tans = v[0];\n\t\t\t\tansX = x;\n\t\t\t\tansY = v[1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(ansX + \" \" + ansY);\n\t}\n\n\tstatic long[] calcX(long x) {\n\t\tlong bottom = minY;\n\t\tlong top = maxY;\n\t\twhile (top - bottom > 2) {\n\t\t\tlong m1 = (2 * bottom + top) / 3;\n\t\t\tlong m2 = (bottom + 2 * top) / 3;\n\t\t\tlong v1 = calc(x, m1);\n\t\t\tlong v2 = calc(x, m2);\n\t\t\tif (v1 <= v2) {\n\t\t\t\ttop = m2;\n\t\t\t} else {\n\t\t\t\tbottom = m1;\n\t\t\t}\n\t\t}\n\t\tlong ret = Long.MAX_VALUE;\n\t\tlong retY = 0;\n\t\tfor (long y = bottom; y <= top; ++y) {\n\t\t\tlong d = calc(x, y);\n\t\t\tif (d < ret) {\n\t\t\t\tret = d;\n\t\t\t\tretY = y;\n\t\t\t}\n\t\t}\n\t\treturn new long[] { ret, retY };\n\t}\n\n\tstatic long calc(long x, long y) {\n\t\tlong max = 0;\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong d = Math.abs(X[i] - x) + Math.abs(Y[i] - y);\n\t\t\tmax = Math.max(max, d);\n\t\t\tsum += d;\n\t\t}\n\t\treturn sum * 2 - max;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, W, H;\n\tstatic int[] X, Y;\n\tstatic int minY, maxY;\n\n\tpublic static void main(String[] args) {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tX = new int[N];\n\t\tY = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = Integer.parseInt(sc.next());\n\t\t\tY[i] = Integer.parseInt(sc.next());\n\t\t}\n\t\tint[] ax = X.clone();\n\t\tint[] ay = Y.clone();\n\t\tArrays.sort(ax);\n\t\tArrays.sort(ay);\n\t\tint[] x = new int[] { ax[(N - 1) / 2], ax[N / 2] };\n\t\tint[] y = new int[] { ay[(N - 1) / 2], ay[N / 2] };\n\t\tlong ans = Long.MAX_VALUE;\n\t\tint ansX = 0;\n\t\tint ansY = 0;\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tlong v = calc(x[i], y[j]);\n\t\t\t\tif (v < ans) {\n\t\t\t\t\tans = v;\n\t\t\t\t\tansX = x[i];\n\t\t\t\t\tansY = y[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(ansX + \" \" + ansY);\n\t}\n\n\tstatic long calc(long x, long y) {\n\t\tlong max = 0;\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong d = Math.abs(X[i] - x) + Math.abs(Y[i] - y);\n\t\t\tmax = Math.max(max, d);\n\t\t\tsum += d;\n\t\t}\n\t\treturn sum * 2 - max;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tint[][] p = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = p[i][0] = sc.nextInt(); y[i] = p[i][1] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tlong res = 1L<<60, rx = -1, ry = -1;\n\t\tfor(int px = x[(n-1)/2];px<x[(n-1)/2]+10;px++)for(int py=y[(n-1)/2];py<y[(n-1)/2]+10;py++){\n\t\t\tlong max = 0, sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlong len = Math.abs(px-p[i][0])+Math.abs(py-p[i][1]);\n\t\t\t\tsum+=2*len;\n\t\t\t\tmax = Math.max(max, len);\n\t\t\t}\n\t\t\tif(sum-max < res){\n\t\t\t\tres = sum-max;\n\t\t\t\trx = px; ry = py;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\tSystem.out.println(rx+\" \"+ry);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tio.nextLong(); //w\n\t\tio.nextLong(); //h\n\t\tint n = io.nextInt();\n\t\tHouse[] h = new House[n];\n\t\tHouse[] hx = new House[n];\n\t\tHouse[] hy = new House[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = io.nextInt();\n\t\t\tint y = io.nextInt();\n\t\t\th[i] = hx[i] = hy[i] = new House(x,y,i);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.out.println(h[0].x + \" \" + h[0].y);\n\t\t\treturn;\n\t\t}\n\t\tArrays.sort(hx, new Comparator<House>() {\n\t\t\tpublic int compare(House h0, House h1) {\n\t\t\t\treturn Long.signum(h0.x - h1.x);\n\t\t\t}\n\t\t});\n\t\tArrays.sort(hy, new Comparator<House>() {\n\t\t\tpublic int compare(House h0, House h1) {\n\t\t\t\treturn Long.signum(h0.y - h1.y);\n\t\t\t}\n\t\t});\n\t\tfor(int i=0;i<n;i++) {\n\t\t\thx[i].rx = i;\n\t\t\thy[i].ry = i;\n\t\t}\n//\t\tSystem.out.println(Arrays.toString(h));\n//\t\tSystem.out.println(Arrays.toString(hx));\n//\t\tSystem.out.println(Arrays.toString(hy));\n\t\tint mid = (n - 1) / 2;\n\t\tlong min = Long.MAX_VALUE;\n\t\tlong minX = -1;\n\t\tlong minY = -1;\n\t\tlong[] sumx = new long[3];\n\t\tArrays.fill(sumx, Long.MAX_VALUE);\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint i2 = mid - 1 + i;\n\t\t\tif (i2 < 0 || i2 >= n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsumx[i] = 0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tsumx[i] += Math.abs(hx[j].x - hx[i2].x);\n\t\t\t}\n\t\t}\n\t\tlong[] sumy = new long[3];\n\t\tArrays.fill(sumy, Long.MAX_VALUE / 4);\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint i2 = mid - 1 + i;\n\t\t\tif (i2 < 0 || i2 >= n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsumy[i] = 0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tsumy[i] += Math.abs(hy[j].y - hy[i2].y);\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(Arrays.toString(sumx));\n//\t\tSystem.out.println(Arrays.toString(sumy));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlong sum = 0;\n\t\t\tint xi = 1;\n\t\t\tif (n % 2 == 1 && h[i].rx >= mid) {\n\t\t\t\txi = 0;\n\t\t\t}else if(n % 2 == 0 && h[i].rx <= mid) {\n\t\t\t\txi = 2;\n\t\t\t}\n\t\t\tsum += 2 * sumx[xi];\n\t\t\tint yi = 1;\n\t\t\tif (n % 2 == 1 && h[i].ry >= mid) {\n\t\t\t\tyi = 0;\n\t\t\t}else if(n % 2 == 0 && h[i].ry <= mid) {\n\t\t\t\tyi = 2;\n\t\t\t}\n\t\t\tsum += 2 * sumy[xi];\n\t\t\tlong sx = hx[mid-1+xi].x;\n\t\t\tlong sy = hy[mid-1+yi].y;\n\t\t\tsum -= Math.abs(h[i].x - sx);\n\t\t\tsum -= Math.abs(h[i].y - sy);\n\t\t\tif (sum < min || sum == min && comp(minX,minY,sx,sy) > 0) {\n\t\t\t\tmin = sum;\n\t\t\t\tminX = sx;\n\t\t\t\tminY = sy;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t\tSystem.out.println(minX + \" \" + minY);\n\t}\n\tstatic int comp(long x1,long y1,long x2,long y2) {\n\t\tif (x1 != x2) {\n\t\t\treturn Long.signum(x1 - x2);\n\t\t}\n\t\treturn Long.signum(y1 - y2);\n\t}\n\tstatic class House {\n\t\tlong x;\n\t\tlong y;\n\t\tint rx;\n\t\tint ry;\n\t\tint id;\n\t\tpublic House(long x,long y,int id) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + x + \",\" + y + \"],[\" + rx + \",\" + ry + \"]:\" + id;\n\t\t}\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tint[][] p = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = p[i][0] = sc.nextInt(); y[i] = p[i][1] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tlong res = 1L<<60, rx = -1, ry = -1;\n\t\tfor(int px = x[(n-1)/2]-100;px<x[(n-1)/2]+100;px++)for(int py=y[(n-1)/2]-100;py<y[(n-1)/2]+100;py++){\n\t\t\tlong max = 0, sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlong len = Math.abs(px-p[i][0])+Math.abs(py-p[i][1]);\n\t\t\t\tsum+=2*len;\n\t\t\t\tmax = Math.max(max, len);\n\t\t\t}\n\t\t\tif(sum-max < res){\n\t\t\t\tres = sum-max;\n\t\t\t\trx = px; ry = py;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\tSystem.out.println(rx+\" \"+ry);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\treader.readLine();\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\t\n\t\tint[] y = new int[n];\n\t\tint[] x = new int[n];\n\t\tint[] sy = new int[n];\n\t\tint[] sx = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tStringTokenizer to = new StringTokenizer(reader.readLine());\n\t\t\tsx[i] = x[i] = Integer.parseInt(to.nextToken());\n\t\t\tsy[i] = y[i] = Integer.parseInt(to.nextToken());\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint ax = 0;\n\t\tint ay = 0;\n\t\tlong ans = Long.MAX_VALUE;\n\t\tint m = (n - 1) / 2;\n\t\tint nm = n/2;\n\t\tint[] xx = {x[m],x[nm]};\n\t\tint[] yy  ={y[m],y[nm]};\n\t\tfor (int i = 0; i <= 1; i++) {\n\t\t\tfor (int j = 0; j <= 1; j++) {\n\t\t\t\tlong res = 0;\n\t\t\t\tlong max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tlong dis = Math.abs(sx[k] - xx[i]) + Math.abs(sy[k] - yy[j]);\n\t\t\t\t\tres += dis * 2;\n\t\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\t}\n\t\t\t\tres -= max;\n\t\t\t\tif (res < ans) {\n\t\t\t\t\tans = res;\n\t\t\t\t\tax = xx[i];\n\t\t\t\t\tay = yy[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(ax + \" \" + ay);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tint[][] p = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = p[i][0] = sc.nextInt(); y[i] = p[i][1] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint px = x[(n-1)/2], py = y[(n-1)/2];\n\t\tlong res = 0, max = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong len = Math.abs(px-p[i][0])+Math.abs(py-p[i][1]);\n\t\t\tres+=2*len;\n\t\t\tmax = Math.max(max, len);\n\t\t}\n\t\tSystem.out.println(res-max);\n\t\tSystem.out.println(px+\" \"+py);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint w = scanner.nextInt();\n\t\tint h = scanner.nextInt();\n\t\tint n = scanner.nextInt();\n\t\tint[] y = new int[n];\n\t\tint[] x = new int[n];\n\t\tint[] sy = new int[n];\n\t\tint[] sx = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsx[i] = x[i] = scanner.nextInt();\n\t\t\tsy[i] = y[i] = scanner.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint ax = 0;\n\t\tint ay = 0;\n\t\tlong ans = Long.MAX_VALUE;\n\t\tint m = (n - 1) / 2;\n\t\tint nm = n/2;\n\t\tint[] xx = {x[m],x[nm]};\n\t\tint[] yy  ={y[m],y[nm]};\n\t\tfor (int i = 0; i <= 1; i++) {\n\t\t\tfor (int j = 0; j <= 1; j++) {\n\t\t\t\tlong res = 0;\n\t\t\t\tlong max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tlong dis = Math.abs(sx[k] - xx[i]) + Math.abs(sy[k] - yy[j]);\n\t\t\t\t\tres += dis * 2;\n\t\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\t}\n\t\t\t\tres -= max;\n\t\t\t\tif (res < ans) {\n\t\t\t\t\tans = res;\n\t\t\t\t\tax = xx[i];\n\t\t\t\t\tay = yy[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(ax + \" \" + ay);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\treader.readLine();\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\t\n\t\tint[] y = new int[n];\n\t\tint[] x = new int[n];\n\t\tint[] sy = new int[n];\n\t\tint[] sx = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tStringTokenizer to = new StringTokenizer(reader.readLine());\n\t\t\tsx[i] = x[i] = Integer.parseInt(to.nextToken());\n\t\t\tsy[i] = y[i] = Integer.parseInt(to.nextToken());\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint ax = 0;\n\t\tint ay = 0;\n\t\tlong ans = Long.MAX_VALUE;\n\t\tint m = (n - 1) / 2;\n\t\tint nm = n/2;\n\t\tint[] xx = {x[m],x[nm]};\n\t\tint[] yy  ={y[m],y[nm]};\n\t\tfor (int i :xx) {\n\t\t\tfor (int j :yy) {\n\t\t\t\tlong res = 0;\n\t\t\t\tlong max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tlong dis = Math.abs(sx[k] - i) + Math.abs(sy[k] - j);\n\t\t\t\t\tres += dis * 2;\n\t\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\t}\n\t\t\t\tres -= max;\n\t\t\t\tif (res < ans) {\n\t\t\t\t\tans = res;\n\t\t\t\t\tax = i;\n\t\t\t\t\tay = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(ax + \" \" + ay);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tint[][] p = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = p[i][0] = sc.nextInt(); y[i] = p[i][1] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tlong res = 1L<<60, rx = -1, ry = -1;\n\t\tfor(int px = x[(n-1)/2]-50;px<x[(n-1)/2]+50;px++)for(int py=y[(n-1)/2]-50;py<y[(n-1)/2]+50;py++){\n\t\t\tlong max = 0, sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlong len = Math.abs(px-p[i][0])+Math.abs(py-p[i][1]);\n\t\t\t\tsum+=2*len;\n\t\t\t\tmax = Math.max(max, len);\n\t\t\t}\n\t\t\tif(sum-max < res){\n\t\t\t\tres = sum-max;\n\t\t\t\trx = px; ry = py;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\tSystem.out.println(rx+\" \"+ry);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Walking Santa\npublic class Main{\n\n\tlong res, rx, ry;\n\tint n;\n\tint[] x, y;\n\tint[][] p;\n\t\n\tvoid f(int px, int py){\n\t\tlong max = 0, sum = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong len = Math.abs(px-p[i][0])+Math.abs(py-p[i][1]);\n\t\t\tsum+=2*len;\n\t\t\tmax = Math.max(max, len);\n\t\t}\n\t\tif(sum-max < res){\n\t\t\tres = sum-max;\n\t\t\trx = px; ry = py;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.nextInt(); sc.nextInt();\n\t\tn = sc.nextInt();\n\t\tx = new int[n]; y = new int[n];\n\t\tp = new int[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = p[i][0] = sc.nextInt(); y[i] = p[i][1] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tres = 1L<<60;\n\t\tf(x[(n-1)/2], y[(n-1)/2]);\n\t\tf(x[(n-1)/2], y[n/2]);\n\t\tf(x[n/2], y[(n-1)/2]);\n\t\tf(x[n/2], y[n/2]);\n\t\tSystem.out.println(res);\n\t\tSystem.out.println(rx+\" \"+ry);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 10 ** 16\n\n### subroutines\n\ndef distxy(x0, y0, x1, y1)\n  (x1 - x0).abs + (y1 - y0).abs\nend\n\n### main\n\nw, h = gets.strip.split(' ').map{|s| s.to_i}\nn = gets.strip.to_i\n\nhouses = []\nhxs = []\nhys = []\n\nn.times do\n  xi, yi = gets.strip.split(' ').map{|s| s.to_i}\n  houses << [xi, yi]\n  hxs << xi\n  hys << yi\nend\n#p houses\n\nhxs.sort!\nhys.sort!\n\nsx0 = hxs[(n - 1) / 2]\nsy0 = hys[(n - 1) / 2]\nsx1 = hxs[(n + 1) / 2]\nsy1 = hys[(n + 1) / 2]\n\nmin_sumd = MAX_INT\nmin_sx = min_sy = -1\n\nfor sxy in [[sx0, sy0], [sx0, sy1], [sx1, sy0], [sx1, sy1]]\n  sx, sy = sxy\n\n  sumd = 0\n  max_dist = 0\n\n  for hxy in houses\n    hx, hy = hxy\n\n    dist = distxy(hx, hy, sx, sy)\n    sumd += dist\n    max_dist = dist if max_dist < dist\n  end\n\n  sumd = sumd * 2 - max_dist\n\n  if min_sumd > sumd\n    min_sumd = sumd\n    min_sx = sx\n    min_sy = sy\n  end\nend\n\nputs min_sumd\nputs [min_sx, min_sy].join(' ')"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 10 ** 17\n\n### subroutines\n\ndef distxy(x0, y0, x1, y1)\n  (x1 - x0).abs + (y1 - y0).abs\nend\n\n### main\n\nw, h = gets.strip.split(' ').map{|s| s.to_i}\nn = gets.strip.to_i\n\nhouses = []\nhxs = []\nhys = []\n\nn.times do\n  xi, yi = gets.strip.split(' ').map{|s| s.to_i}\n  houses << [xi, yi]\n  hxs << xi\n  hys << yi\nend\n#p houses\n\nhxs.sort!\nhys.sort!\n\nsx0 = hxs[(n - 1) / 2]\nsy0 = hys[(n - 1) / 2]\nsx1 = hxs[(n + 1) / 2]\nsy1 = hys[(n + 1) / 2]\n\nmin_sumd = MAX_INT\nmin_sx = min_sy = -1\n\nfor sxy in [[sx0, sy0], [sx0, sy1], [sx1, sy0], [sx1, sy1]]\n  sx, sy = sxy\n\n  sumd = 0\n  max_dist = 0\n\n  for hxy in houses\n    hx, hy = hxy\n\n    dist = distxy(hx, hy, sx, sy)\n    sumd += dist\n    max_dist = dist if max_dist < dist\n  end\n\n  sumd = sumd * 2 - max_dist\n\n  if min_sumd > sumd\n    min_sumd = sumd\n    min_sx = sx\n    min_sy = sy\n  end\nend\n\nputs min_sumd\nputs [min_sx, min_sy].join(' ')"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\nw, h = map(int, input().split())\nn = int(input())\nxlst = []\nylst = []\nfor i in range(n):\n  x, y = map(int,input().split())\n  xlst.append(x)\n  ylst.append(y)\n\nsorted_xlst = sorted(xlst)\nsorted_ylst = sorted(ylst)\naccx = accy = 0\ncum_sum_xlst = []\ncum_sum_ylst = []\n\nfor i in range(n):\n  accx += sorted_xlst[i]\n  accy += sorted_ylst[i]\n  cum_sum_xlst.append(accx)\n  cum_sum_ylst.append(accy)\n\n#print(cum_sum_xlst)\n#print(cum_sum_ylst)\nsx = accx\nsy = accy\n\nnum = n * 2 - 1\n\nans = INF\nansx = 10 ** 10\nansy = 10 ** 10\n\ndef make_lenx(avx, xi):\n  px = bl(sorted_xlst, avx)\n  if px: \n    lenx = (avx * px - cum_sum_xlst[px - 1]) * 2 + (sx - cum_sum_xlst[px - 1] - avx * (n - px)) * 2 - abs(xi - avx)\n  else:\n    lenx = (sx - avx * n) * 2 - abs(xi - avx)\n#  print(\"px:\",px,\"avx:\",avx,\"lenx:\",lenx)\n  return lenx\ndef make_leny(avy, yi):\n  py = bl(sorted_ylst, avy)\n  if py:\n    leny = (avy * py - cum_sum_ylst[py - 1]) * 2 + (sy - cum_sum_ylst[py - 1] - avy * (n - py)) * 2 - abs(yi - avy)\n  else:\n    leny = (sy - avy * n) * 2 - abs(yi - avy)\n#  print(\"py:\",py,\"avy:\",avy,\"leny:\",leny)\n  return leny\n\nfor i in range(n):\n  xi = xlst[i]\n  yi = ylst[i]\n  \n  sumx = sx * 2 - xi\n  avx1 = sumx // num - 1\n  avx2 = avx1 + 1\n  avx3 = avx2 + 1\n\n  sumy = sy * 2 - yi\n  avy1 = sumy // num - 1\n  avy2 = avy1 + 1\n  avy3 = avy2 + 1\n  \n  lenx1, lenx2, lenx3 = make_lenx(avx1, xi), make_lenx(avx2, xi), make_lenx(avx3, xi)\n  leny1, leny2, leny3 = make_leny(avy1, yi), make_leny(avy2, yi), make_leny(avy3, yi)\n\n  lenx = min(lenx1, lenx2, lenx3)\n  leny = min(leny1, leny2, leny3)\n  \n  if lenx == lenx1:\n    avx = avx1\n  elif lenx == lenx2:\n    avx = avx2\n  else:\n    avx = avx3\n\n  if leny == leny1:\n    avy = avy1\n  elif leny == leny2:\n    avy = avy2\n  else:\n    avy = avy3\n\n\n#  print(lenx, leny, avx, avy)\n  lent = lenx + leny\n  \n  if lent <= ans:\n    if lent == ans:\n      if avx < ansx:\n        ansx = avx\n        ansy = avy\n      elif avx == ansx:\n        if avy < ansy:\n          ansy = avy\n    else:\n      ansx = avx\n      ansy = avy\n    ans = lent\nprint(ans)\nprint(ansx, ansy)\n"
  },
  {
    "language": "Python",
    "code": "import numpy\n\ndef cal_time(W, H, x, y):\n    return 2*(abs(W-x) + abs(H-y))\n\ngeo = input(\"Input W H: \").split()\nW = int(geo[0])\nH = int(geo[1])\n\nif W<1 or W>1000000000:\n    print(\"wrong W\")\n    exit()\nif H<1 or H>1000000000:\n    print(\"wrong H\")\n    exit()\n\nN = int(input(\"N: \"))\nif N<1 or N>100000:\n    print(\"wrong N\")\n    exit()\n\ntotal_time = 0\n\n''' Input houses and calculate time'''\nhouses = []\nx_list = []\ny_list = []\nfor i in range(N):\n    co = input(\"x y: \").split()\n    x = int(co[0])\n    if x<1 or x>W:\n        print(\"wrong x\")\n        exit()\n    x_list.append(x)\n    y = int(co[1])\n    if y<1 or y>H:\n        print(\"wrong y\")\n        exit()\n    y_list.append(y)\n    if (x,y) in houses:\n        print(\"Coordinate exists\")\n        exit()\n    houses.append((x,y))\n    #total_time += cal_time(W, H, x, y)\n\n\navg_x = numpy.mean(x_list)\navg_y = numpy.mean(y_list)\n\n# round\ntarget_x = int(round(avg_x))\ntarget_y = int(round(avg_y))\n\n#print(target_x)\n#print(target_y)\n\nall_time = []\nfor co in houses:\n    #print(co)\n    time = cal_time(target_x, target_y, co[0], co[1])\n    #print(time)\n    all_time.append(time)\n    total_time += time\n\ntotal_time -= int(max(all_time)/2)\nprint(total_time)\nprint(target_x, target_y)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\n\ndef main():\n  \n  w, h = map(int, input().split())\n  n = int(input())\n  \n  xlst = []\n  ylst = []\n  appx = xlst.append\n  appy = ylst.append\n\n  for i in range(n):\n    x, y = map(int,input().split())\n    appx(x)\n    appy(y)\n  \n  sorted_xlst = sorted(xlst)\n  sorted_ylst = sorted(ylst)\n\n  clx = sorted_xlst[n // 2 if n % 2 else n // 2 - 1]\n  crx = sorted_xlst[n // 2]\n  cly = sorted_ylst[n // 2 if n % 2 else n // 2 - 1]\n  cry = sorted_ylst[n // 2]\n \n  plx = bl(sorted_xlst, clx)\n  prx = bl(sorted_xlst, crx)\n  ply = bl(sorted_ylst, cly)\n  pry = bl(sorted_ylst, cry)\n\n  sumx = sum(xlst)\n  sumy = sum(ylst)\n\n  xllen = (sumx - sum(sorted_xlst[:plx]) * 2 - clx * (n - plx * 2)) * 2\n  xrlen = (sumx - sum(sorted_xlst[:prx]) * 2 - crx * (n - prx * 2)) * 2\n  yllen = (sumy - sum(sorted_ylst[:ply]) * 2 - cly * (n - ply * 2)) * 2\n  yrlen = (sumy - sum(sorted_ylst[:pry]) * 2 - cry * (n - pry * 2)) * 2\n\n  ans = ansx = ansy = INF\n  max_sumd = 0\n  \n  for i in range(n):\n    xi = xlst[i]\n    yi = ylst[i]\n\n    if xi <= clx:\n      cx = crx\n      xlen = xrlen\n    else:\n      cx = clx\n      xlen = xllen\n    if yi <= cly:\n      cy = cry\n      ylen = yrlen\n    else:\n      cy = cly\n      ylen = yllen\n  \n    dx = xi - cx\n    if dx < 0:\n      dx = -dx\n    dy = yi - cy\n    if dy < 0:\n      dy = -dy\n\n    if max_sumd > dx + dy:\n      continue\n    else:\n      max_sumd = dx + dy\n    \n    tlen = xlen + ylen - max_sumd\n\n    if ans > tlen:\n      ans = tlen\n      ansx = cx\n      ansy = cy\n    elif ans == tlen:\n      if ansx > cx:\n        ansx = cx\n        ansy = cy\n      elif ansx == cx:\n        if ansy > cy:\n          ansy = cy \n  \n  print(ans)\n  print(ansx, ansy)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\n\ndef main():\n  \n  w, h = map(int, input().split())\n  n = int(input())\n  \n  xlst = []\n  ylst = []\n  appx = xlst.append\n  appy = ylst.append\n  for i in range(n):\n    x, y = map(int,input().split())\n    appx(x)\n    appy(y)\n  \n  sorted_xlst = sorted(xlst)\n  sorted_ylst = sorted(ylst)\n  accx = accy = 0\n  cum_sum_xlst = []\n  cum_sum_ylst = []\n  appx = cum_sum_xlst.append\n  appy = cum_sum_ylst.append\n\n  for i in range(n):\n    accx += sorted_xlst[i]\n    accy += sorted_ylst[i]\n    appx(accx)\n    appy(accy)\n  \n  if n % 2:\n    clx = crx = sorted_xlst[n // 2]\n    cly = cry = sorted_ylst[n // 2]\n  else:\n    clx = sorted_xlst[n // 2 - 1]\n    crx = sorted_xlst[n // 2]\n    cly = sorted_ylst[n // 2 - 1]\n    cry = sorted_ylst[n // 2]\n  plx = bl(sorted_xlst, clx)\n  prx = bl(sorted_xlst, crx)\n  ply = bl(sorted_ylst, cly)\n  pry = bl(sorted_ylst, cry)\n\n\n  \n  ans = ansx = ansy = INF\n  \n  for i in range(n):\n    xi = xlst[i]\n    yi = ylst[i]\n\n    if xi <= clx:\n      cx = crx\n      px = prx\n    else:\n      cx = clx\n      px = plx\n    if yi <= cly:\n      cy = cry\n      py = pry\n    else:\n      cy = cly\n      py = ply\n  \n    dx = xi - cx\n    if dx < 0:\n      dx = -dx\n\n    if px:\n      csx = cum_sum_xlst[px - 1]\n      xlen = (accx - csx * 2 - cx * (n - px * 2)) * 2 - dx\n    else:\n      xlen = (accx - cx * n) * 2 - dx\n \n    dy = yi - cy\n    if dy < 0:\n      dy = -dy\n   \n    if py:\n      csy = cum_sum_ylst[py - 1]\n      ylen = (accy - csy * 2 - cy * (n - py * 2)) * 2 - dy\n    else:\n      ylen = (accy - cy * n) * 2 - dy\n    \n    tlen = xlen + ylen\n\n    if ans > tlen:\n      ans = tlen\n      ansx = cx\n      ansy = cy\n    elif ans == tlen:\n      if ansx > cx:\n        ansx = cx\n        ansy = cy\n      elif ansx == cx:\n        if ansy > cy:\n          ansy = cy \n  \n  print(ans)\n  print(ansx, ansy)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import numpy\n\ndef cal_time(W, H, x, y):\n    return 2*(abs(W-x) + abs(H-y))\n\ngeo = input().split()\nW = int(geo[0])\nH = int(geo[1])\n\nif W<1 or W>1000000000:\n    print(\"wrong W\")\n    exit()\nif H<1 or H>1000000000:\n    print(\"wrong H\")\n    exit()\n\nN = int(input())\nif N<1 or N>100000:\n    print(\"wrong N\")\n    exit()\n\ntotal_time = 0\n\n''' Input houses and calculate time'''\nhouses = []\nx_list = []\ny_list = []\nfor i in range(N):\n    co = input(\"x y: \").split()\n    x = int(co[0])\n    if x<1 or x>W:\n        print(\"wrong x\")\n        exit()\n    x_list.append(x)\n    y = int(co[1])\n    if y<1 or y>H:\n        print(\"wrong y\")\n        exit()\n    y_list.append(y)\n    if (x,y) in houses:\n        print(\"Coordinate exists\")\n        exit()\n    houses.append((x,y))\n    #total_time += cal_time(W, H, x, y)\n\n\navg_x = numpy.mean(x_list)\navg_y = numpy.mean(y_list)\n\n# round\ntarget_x = int(round(avg_x))\ntarget_y = int(round(avg_y))\n\n#print(target_x)\n#print(target_y)\n\nall_time = []\nfor co in houses:\n    #print(co)\n    time = cal_time(target_x, target_y, co[0], co[1])\n    #print(time)\n    all_time.append(time)\n    total_time += time\n\ntotal_time -= int(max(all_time)/2)\nprint(total_time)\nprint(target_x, target_y)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\n\ndef main():\n  \n  w, h = map(int, input().split())\n  n = int(input())\n  \n  xlst = []\n  ylst = []\n  appx = xlst.append\n  appy = ylst.append\n  for i in range(n):\n    x, y = map(int,input().split())\n    appx(x)\n    appy(y)\n  \n  sorted_xlst = sorted(xlst)\n  sorted_ylst = sorted(ylst)\n  accx = accy = 0\n  cum_sum_xlst = []\n  cum_sum_ylst = []\n  appx = cum_sum_xlst.append\n  appy = cum_sum_ylst.append\n\n  for i in range(n):\n    accx += sorted_xlst[i]\n    accy += sorted_ylst[i]\n    appx(accx)\n    appy(accy)\n  \n  if n % 2:\n    clx = crx = sorted_xlst[n // 2]\n    cly = cry = sorted_ylst[n // 2]\n  else:\n    clx = sorted_xlst[n // 2 - 1]\n    crx = sorted_xlst[n // 2]\n    cly = sorted_ylst[n // 2 - 1]\n    cry = sorted_ylst[n // 2]\n  plx = bl(sorted_xlst, clx)\n  prx = bl(sorted_xlst, crx)\n  ply = bl(sorted_ylst, cly)\n  pry = bl(sorted_ylst, cry)\n\n  xllen = (accx - cum_sum_xlst[plx - 1] * 2 - clx * (n - plx * 2)) * 2 if plx != 0 else (accx - clx * n) * 2\n  xrlen = (accx - cum_sum_xlst[prx - 1] * 2 - crx * (n - prx * 2)) * 2 if prx != 0 else (accx - crx * n) * 2\n  yllen = (accy - cum_sum_ylst[ply - 1] * 2 - cly * (n - ply * 2)) * 2 if ply != 0 else (accy - cly * n) * 2\n  yrlen = (accy - cum_sum_ylst[pry - 1] * 2 - cry * (n - pry * 2)) * 2 if pry != 0 else (accy - cry * n) * 2\n\n\n  ans = ansx = ansy = INF\n  max_sumd = 0\n  \n  for i in range(n):\n    xi = xlst[i]\n    yi = ylst[i]\n\n    if xi <= clx:\n      cx = crx\n      xlen = xrlen\n    else:\n      cx = clx\n      xlen = xllen\n    if yi <= cly:\n      cy = cry\n      ylen = yrlen\n    else:\n      cy = cly\n      ylen = yllen\n  \n    dx = xi - cx\n    if dx < 0:\n      dx = -dx\n\n    dy = yi - cy\n    if dy < 0:\n      dy = -dy\n\n    if max_sumd > dx + dy:\n      continue\n    else:\n      max_sumd = dx + dy\n    \n    tlen = xlen + ylen - max_sumd\n\n    if ans > tlen:\n      ans = tlen\n      ansx = cx\n      ansy = cy\n    elif ans == tlen:\n      if ansx > cx:\n        ansx = cx\n        ansy = cy\n      elif ansx == cx:\n        if ansy > cy:\n          ansy = cy \n  \n  print(ans)\n  print(ansx, ansy)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\n\ndef main():\n  \n  w, h = map(int, input().split())\n  n = int(input())\n  \n  xlst = []\n  ylst = []\n  appx = xlst.append\n  appy = ylst.append\n  for i in range(n):\n    x, y = map(int,input().split())\n    appx(x)\n    appy(y)\n  \n  sorted_xlst = sorted(xlst)\n  sorted_ylst = sorted(ylst)\n  accx = accy = 0\n  cum_sum_xlst = []\n  cum_sum_ylst = []\n  appx = cum_sum_xlst.append\n  appy = cum_sum_ylst.append\n\n  for i in range(n):\n    accx += sorted_xlst[i]\n    accy += sorted_ylst[i]\n    appx(accx)\n    appy(accy)\n  \n  if n % 2:\n    clx = crx = sorted_xlst[n // 2]\n    cly = cry = sorted_ylst[n // 2]\n  else:\n    clx = sorted_xlst[n // 2 - 1]\n    crx = sorted_xlst[n // 2]\n    cly = sorted_ylst[n // 2 - 1]\n    cry = sorted_ylst[n // 2]\n  \n  ans = ansx = ansy = INF\n  \n  for i in range(n):\n    xi = xlst[i]\n    yi = ylst[i]\n\n    if xi <= clx:\n      cx = crx\n    else:\n      cx = clx\n\n    if yi <= cly:\n      cy = cry\n    else:\n      cy = cly\n  \n    px = bl(sorted_xlst, cx)\n    py = bl(sorted_ylst, cy)\n\n    dx = xi - cx\n    if dx < 0:\n      dx = -dx\n\n    if px:\n      csx = cum_sum_xlst[px - 1]\n      xlen = (accx - csx * 2 - cx * (n - px * 2)) * 2 - dx\n    else:\n      xlen = (accx - cx * n) * 2 - dx\n \n    dy = yi - cy\n    if dy < 0:\n      dy = -dy\n   \n    if py:\n      csy = cum_sum_ylst[py - 1]\n      ylen = (accy - csy * 2 - cy * (n - py * 2)) * 2 - dy\n    else:\n      ylen = (accy - cy * n) * 2 - dy\n    \n    tlen = xlen + ylen\n\n    if ans > tlen:\n      ans = tlen\n      ansx = cx\n      ansy = cy\n    elif ans == tlen:\n      if ansx > cx:\n        ansx = cx\n        ansy = cy\n      elif ansx == cx:\n        if ansy > cy:\n          ansy = cy \n  \n  print(ans)\n  print(ansx, ansy)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import numpy\n\ndef cal_time(W, H, x, y):\n    return 2*(abs(W-x) + abs(H-y))\n\ngeo = input().split()\nW = int(geo[0])\nH = int(geo[1])\n\nif W<1 or W>1000000000:\n    print(\"wrong W\")\n    exit()\nif H<1 or H>1000000000:\n    print(\"wrong H\")\n    exit()\n\nN = int(input())\nif N<1 or N>100000:\n    print(\"wrong N\")\n    exit()\n\ntotal_time = 0\n\n''' Input houses and calculate time'''\nhouses = []\nx_list = []\ny_list = []\nfor i in range(N):\n    co = input().split()\n    x = int(co[0])\n    if x<1 or x>W:\n        print(\"wrong x\")\n        exit()\n    x_list.append(x)\n    y = int(co[1])\n    if y<1 or y>H:\n        print(\"wrong y\")\n        exit()\n    y_list.append(y)\n    if (x,y) in houses:\n        print(\"Coordinate exists\")\n        exit()\n    houses.append((x,y))\n    #total_time += cal_time(W, H, x, y)\n\n\navg_x = numpy.mean(x_list)\navg_y = numpy.mean(y_list)\n\n# round\ntarget_x = int(round(avg_x))\ntarget_y = int(round(avg_y))\n\n#print(target_x)\n#print(target_y)\n\nall_time = []\nfor co in houses:\n    #print(co)\n    time = cal_time(target_x, target_y, co[0], co[1])\n    #print(time)\n    all_time.append(time)\n    total_time += time\n\ntotal_time -= int(max(all_time)/2)\nprint(total_time)\nprint(target_x, target_y)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nINF = 10 ** 20\nw, h = map(int, input().split())\nn = int(input())\nxlst = []\nylst = []\nfor i in range(n):\n  x, y = map(int,input().split())\n  xlst.append(x)\n  ylst.append(y)\n\nsorted_xlst = sorted(xlst)\nsorted_xlst_d = sorted(xlst * 2)\nsorted_ylst = sorted(ylst)\nsorted_ylst_d = sorted(ylst * 2)\naccx = accy = 0\ncum_sum_xlst = []\ncum_sum_ylst = []\n\nfor i in range(n):\n  accx += sorted_xlst[i]\n  accy += sorted_ylst[i]\n  cum_sum_xlst.append(accx)\n  cum_sum_ylst.append(accy)\n\nclx = sorted_xlst_d[n - 1]\ncrx = sorted_xlst_d[n]\ncly = sorted_ylst_d[n - 1]\ncry = sorted_ylst_d[n]\n\nnum = n * 2 - 1\n\nans = INF\nansx = 10 ** 10\nansy = 10 ** 10\nfor i in range(n):\n  xi = xlst[i]\n  yi = ylst[i]\n  if xi <= clx:\n    cx = crx\n  else:\n    cx = clx\n  if yi <= cly:\n    cy = cry\n  else:\n    cy = cly\n\n  px = bl(sorted_xlst, cx)\n  py = bl(sorted_ylst, cy)\n \n  if px:\n    xlen = (cx * px - cum_sum_xlst[px - 1]) * 2 + (accx - cum_sum_xlst[px - 1] - cx * (n - px)) * 2 - abs(xi - cx)\n  else:\n    xlen = (accx - cx * n) * 2 - abs(xi - cx)\n\n  if py:\n    ylen = (cy * py - cum_sum_ylst[py - 1]) * 2 + (accy - cum_sum_ylst[py - 1] - cy * (n - py)) * 2 - abs(yi - cy)\n  else:\n    ylen = (accy - cy * n) * 2 - abs(yi - cy)\n  \n  tlen = xlen + ylen\n  if ans > tlen:\n    ans = tlen\n    ansx = cx\n    ansy = cy\n  elif ans == tlen:\n    if ansx > cx:\n      ansx = cx\n      ansy = cy\n    elif ansx == cx:\n      if ansy > cy:\n        ansy = cy \nprint(ans)\nprint(ansx, ansy)\n"
  },
  {
    "language": "Python",
    "code": "import numpy\n\ndef cal_time(W, H, x, y):\n    return 2*(abs(W-x) + abs(H-y))\n\ngeo = input().split()\nW = int(geo[0])\nH = int(geo[1])\n\nif W<1 or W>1000000000:\n    print(\"wrong W\")\n    exit()\nif H<1 or H>1000000000:\n    print(\"wrong H\")\n    exit()\n\nN = int(input())\nif N<1 or N>100000:\n    print(\"wrong N\")\n    exit()\n\ntotal_time = 0\n\n''' Input houses and calculate time'''\nhouses = []\nx_list = []\ny_list = []\nfor i in range(N):\n    co = input(\"x y: \").split()\n    x = int(co[0])\n    if x<1 or x>W:\n        print(\"wrong x\")\n        exit()\n    x_list.append(x)\n    y = int(co[1])\n    if y<1 or y>H:\n        print(\"wrong y\")\n        exit()\n    y_list.append(y)\n    if (x,y) in houses:\n        print(\"Coordinate exists\")\n        exit()\n    houses.append((x,y))\n    #total_time += cal_time(W, H, x, y)\n\n\navg_x = numpy.mean(x_list)\navg_y = numpy.mean(y_list)\n\n# round\ntarget_x = int(round(avg_x))\ntarget_y = int(round(avg_y))\n\n#print(target_x)\n#print(target_y)\n\nall_time = []\nfor co in houses:\n    #print(co)\n    time = cal_time(target_x, target_y, co[0], co[1])\n    #print(time)\n    all_time.append(time)\n    total_time += time\n\ntotal_time -= int(max(all_time)/2)\nprint(total_time)\nprint(target_x, target_y)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\n\ndef main():\n  \n  w, h = map(int, input().split())\n  n = int(input())\n  \n  xlst = []\n  ylst = []\n  \n  for i in range(n):\n    x, y = map(int,input().split())\n    xlst.append(x)\n    ylst.append(y)\n  \n  sorted_xlst = sorted(xlst)\n  sorted_ylst = sorted(ylst)\n  accx = accy = 0\n  cum_sum_xlst = []\n  cum_sum_ylst = []\n  \n  for i in range(n):\n    accx += sorted_xlst[i]\n    accy += sorted_ylst[i]\n    cum_sum_xlst.append(accx)\n    cum_sum_ylst.append(accy)\n  \n  if n % 2:\n    clx = crx = sorted_xlst[n // 2]\n    cly = cry = sorted_ylst[n // 2]\n  else:\n    clx = sorted_xlst[n // 2 - 1]\n    crx = sorted_xlst[n // 2]\n    cly = sorted_ylst[n // 2 - 1]\n    cry = sorted_ylst[n // 2]\n  \n  ans = ansx = ansy = INF\n  \n  for i in range(n):\n    xi = xlst[i]\n    yi = ylst[i]\n\n    if xi <= clx:\n      cx = crx\n    else:\n      cx = clx\n\n    if yi <= cly:\n      cy = cry\n    else:\n      cy = cly\n  \n    px = bl(sorted_xlst, cx)\n    py = bl(sorted_ylst, cy)\n   \n    if px:\n      csx = cum_sum_xlst[px - 1]\n      xlen = (cx * px - csx) * 2 + (accx - csx - cx * (n - px)) * 2 - abs(xi - cx)\n    else:\n      xlen = (accx - cx * n) * 2 - abs(xi - cx)\n  \n    if py:\n      csy = cum_sum_ylst[py - 1]\n      ylen = (cy * py - csy) * 2 + (accy - csy - cy * (n - py)) * 2 - abs(yi - cy)\n    else:\n      ylen = (accy - cy * n) * 2 - abs(yi - cy)\n    \n    tlen = xlen + ylen\n\n    if ans > tlen:\n      ans = tlen\n      ansx = cx\n      ansy = cy\n    elif ans == tlen:\n      if ansx > cx:\n        ansx = cx\n        ansy = cy\n      elif ansx == cx:\n        if ansy > cy:\n          ansy = cy \n  \n  print(ans)\n  print(ansx, ansy)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\n\ndef main():\n  \n  w, h = map(int, input().split())\n  n = int(input())\n  \n  xlst = []\n  ylst = []\n  appx = xlst.append\n  appy = ylst.append\n\n  for i in range(n):\n    x, y = map(int,input().split())\n    appx(x)\n    appy(y)\n  \n  sorted_xlst = sorted(xlst)\n  sorted_ylst = sorted(ylst)\n\n  #x, yの中央値の候補\n  clx = sorted_xlst[n // 2 if n % 2 else n // 2 - 1]\n  crx = sorted_xlst[n // 2]\n  cly = sorted_ylst[n // 2 if n % 2 else n // 2 - 1]\n  cry = sorted_ylst[n // 2]\n\n  #x, yの中央値の候補のindex\n  ilx = bl(sorted_xlst, clx)\n  irx = bl(sorted_xlst, crx)\n  ily = bl(sorted_ylst, cly)\n  iry = bl(sorted_ylst, cry)\n\n  sumx = sum(xlst)\n  sumy = sum(ylst)\n\n  #x, yそれぞれについての中央値と各点までの往復距離の総和\n  xllen = (sumx - sum(sorted_xlst[:ilx]) * 2 - clx * (n - ilx * 2)) * 2\n  xrlen = (sumx - sum(sorted_xlst[:irx]) * 2 - crx * (n - irx * 2)) * 2\n  yllen = (sumy - sum(sorted_ylst[:ily]) * 2 - cly * (n - ily * 2)) * 2\n  yrlen = (sumy - sum(sorted_ylst[:iry]) * 2 - cry * (n - iry * 2)) * 2\n\n  ans = ansx = ansy = INF\n  max_sumd = 0\n  \n  #各点について復路を省いた場合の距離の和を求める\n  for i in range(n):\n    xi = xlst[i]\n    yi = ylst[i]\n\n    cx, xlen = (crx, xrlen) if xi <= clx else (clx, xllen)\n    cy, ylen = (cry, yrlen) if yi <= cly else (cly, yllen)\n\n    dx = xi - cx if xi >= cx else cx - xi\n    dy = yi - cy if yi >= cy else cy - yi\n\n    if max_sumd > dx + dy:\n      continue\n    else:\n      max_sumd = dx + dy\n    \n    tlen = xlen + ylen - max_sumd\n\n    if ans > tlen:\n      ans = tlen\n      ansx = cx\n      ansy = cy\n    elif ans == tlen:\n      if ansx > cx:\n        ansx = cx\n        ansy = cy\n      elif ansx == cx:\n        if ansy > cy:\n          ansy = cy \n  \n  print(ans)\n  print(ansx, ansy)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nINF = 10 ** 20\nw, h = map(int, input().split())\nn = int(input())\nxlst = []\nylst = []\nfor i in range(n):\n  x, y = map(int,input().split())\n  xlst.append(x)\n  ylst.append(y)\n\nsorted_xlst = sorted(xlst)\nsorted_ylst = sorted(ylst)\naccx = accy = 0\ncum_sum_xlst = []\ncum_sum_ylst = []\n\nfor i in range(n):\n  accx += sorted_xlst[i]\n  accy += sorted_ylst[i]\n  cum_sum_xlst.append(accx)\n  cum_sum_ylst.append(accy)\n\n\nsx = accx\nsy = accy\n\nnum = n * 2 - 1\n\nans = INF\nansx = 10 ** 10\nansy = 10 ** 10\n\nfor i in range(n):\n  xi = xlst[i]\n  yi = ylst[i]\n  \n  sumx = sx * 2 - xi\n  avx1 = sumx // num\n  avx2 = avx1 + 1\n  \n  sumy = sy * 2 - yi\n  avy1 = sumy // num\n  avy2 = avy1 + 1\n  \n  px1 = bl(sorted_xlst, avx1)\n  px2 = bl(sorted_xlst, avx2)\n\n  lenx1 = (avx1 * px1 - cum_sum_xlst[px1 - 1]) * 2 + (sx - cum_sum_xlst[px1 - 1] - avx1 * (n - px1)) * 2 - abs(xi - avx1)\n  lenx2 = (avx2 * px2 - cum_sum_xlst[px2 - 1]) * 2 + (sx - cum_sum_xlst[px2 - 1] - avx2 * (n - px2)) * 2 - abs(xi - avx2)\n\n  py1 = bl(sorted_ylst, avy1)\n  py2 = bl(sorted_ylst, avy2)\n  \n  leny1 = (avy1 * py1 - cum_sum_ylst[py1 - 1]) * 2 + (sy - cum_sum_ylst[py1 - 1] - avy1 * (n - py1)) * 2 - abs(yi - avy1)\n  leny2 = (avy2 * py2 - cum_sum_ylst[py2 - 1]) * 2 + (sy - cum_sum_ylst[py2 - 1] - avy2 * (n - py2)) * 2 - abs(yi - avy2)\n\n  if lenx1 <= lenx2:\n    avx = avx1\n  else:\n    avx = avx2\n  \n  if leny1 <= leny2:\n    avy = avy1\n  else:\n    avy = avy2\n\n  lenx = min(lenx1, lenx2)\n  leny = min(leny1, leny2)\n  \n  lent = lenx + leny\n  \n  if lent <= ans:\n    ans = lent\n    if lent == ans:\n      if avx < ansx:\n        ansx = avx\n        ansy = avy\n      elif avx == ansx:\n        if avy < ansy:\n          ansy = avy\n    else:\n      ansx = avx\n      ansy = avy\nprint(ans)\nprint(ansx, ansy)\n"
  }
]