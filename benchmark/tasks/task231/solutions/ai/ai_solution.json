[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int team;\n    int solved;\n    int time;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    if (ta->solved != tb->solved) {\n        return tb->solved - ta->solved;\n    } else if (ta->time != tb->time) {\n        return ta->time - tb->time;\n    } else {\n        return ta->team - tb->team;\n    }\n}\n\nint main() {\n    int M, T, P, R;\n    while (1) {\n        scanf(\"%d %d %d %d\", &M, &T, &P, &R);\n        if (M == 0 && T == 0 && P == 0 && R == 0) break;\n\n        int solved[T + 1][P + 1];\n        int penalty[T + 1][P + 1];\n        int total_solved[T + 1];\n        int total_time[T + 1];\n        memset(solved, 0, sizeof(solved));\n        memset(penalty, 0, sizeof(penalty));\n        memset(total_solved, 0, sizeof(total_solved));\n        memset(total_time, 0, sizeof(total_time));\n\n        for (int i = 0; i < R; i++) {\n            int m, t, p, j;\n            scanf(\"%d %d %d %d\", &m, &t, &p, &j);\n            if (j == 0) {\n                if (!solved[t][p]) {\n                    solved[t][p] = 1;\n                    total_solved[t]++;\n                    total_time[t] += m + penalty[t][p];\n                }\n            } else {\n                penalty[t][p] += 20;\n            }\n        }\n\n        Team teams[T];\n        for (int i = 0; i < T; i++) {\n            teams[i].team = i + 1;\n            teams[i].solved = total_solved[i + 1];\n            teams[i].time = total_time[i + 1];\n        }\n\n        qsort(teams, T, sizeof(Team), compare);\n\n        for (int i = 0; i < T; i++) {\n            if (i > 0) {\n                if (teams[i].solved == teams[i - 1].solved && teams[i].time == teams[i - 1].time) {\n                    printf(\"=\");\n                } else {\n                    printf(\",\");\n                }\n            }\n            printf(\"%d\", teams[i].team);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ICPCRanking {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int numTeams = scanner.nextInt();\n            int numProblems = scanner.nextInt();\n            int numSubmissions = scanner.nextInt();\n            \n            if (numTeams == 0 && numProblems == 0 && numSubmissions == 0) {\n                break;\n            }\n            \n            Team[] teams = new Team[numTeams + 1];\n            for (int i = 1; i <= numTeams; i++) {\n                teams[i] = new Team(i);\n            }\n            \n            for (int i = 0; i < numSubmissions; i++) {\n                int time = scanner.nextInt();\n                int teamNum = scanner.nextInt();\n                int problemNum = scanner.nextInt();\n                String judgment = scanner.next();\n                \n                teams[teamNum].processSubmission(time, problemNum, judgment);\n            }\n            \n            Arrays.sort(teams, 1, numTeams + 1, (a, b) -> {\n                if (a.solvedProblems != b.solvedProblems) {\n                    return Integer.compare(b.solvedProblems, a.solvedProblems);\n                }\n                return Integer.compare(a.totalTime, b.totalTime);\n            });\n            \n            int currentRank = 1;\n            for (int i = 1; i <= numTeams; i++) {\n                if (i > 1 && (teams[i].solvedProblems != teams[i-1].solvedProblems || \n                    teams[i].totalTime != teams[i-1].totalTime)) {\n                    currentRank = i;\n                }\n                System.out.println(currentRank + \" \" + teams[i].teamNumber + \" \" + \n                    teams[i].solvedProblems + \" \" + teams[i].totalTime);\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    static class Team {\n        int teamNumber;\n        int solvedProblems;\n        int totalTime;\n        Set<Integer> problemsSolved;\n        Map<Integer, Integer> incorrectSubmissions;\n        \n        Team(int teamNumber) {\n            this.teamNumber = teamNumber;\n            this.solvedProblems = 0;\n            this.totalTime = 0;\n            this.problemsSolved = new HashSet<>();\n            this.incorrectSubmissions = new HashMap<>();\n        }\n        \n        void processSubmission(int time, int problemNum, String judgment) {\n            if (problemsSolved.contains(problemNum)) {\n                return;\n            }\n            \n            if (judgment.equals(\"AC\")) {\n                solvedProblems++;\n                problemsSolved.add(problemNum);\n                totalTime += time + (incorrectSubmissions.getOrDefault(problemNum, 0) * 20);\n            } else if (judgment.equals(\"WA\")) {\n                incorrectSubmissions.put(problemNum, \n                    incorrectSubmissions.getOrDefault(problemNum, 0) + 1);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:12:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Team {\n    int number;\n    int solved;\n    int time;\n\n    Team(int num) : number(num), solved(0), time(0) {}\n};\n\nbool compareTeams(const Team &a, const Team &b) {\n    if (a.solved != b.solved) {\n        return a.solved > b.solved;\n    } else if (a.time != b.time) {\n        return a.time < b.time;\n    } else {\n        return a.number < b.number;\n    }\n}\n\nint main() {\n    int M, T, P, R;\n    while (cin >> M >> T >> P >> R, M || T || P || R) {\n        vector<Team> teams;\n        for (int i = 1; i <= T; ++i) {\n            teams.emplace_back(i);\n        }\n\n        vector<vector<int>> incorrect(T + 1, vector<int>(P + 1, 0));\n\n        for (int i = 0; i < R; ++i) {\n            int m, t, p, j;\n            cin >> m >> t >> p >> j;\n            if (j == 0) {\n                teams[t - 1].solved++;\n                teams[t - 1].time += m + 20 * incorrect[t][p];\n            } else {\n                incorrect[t][p]++;\n            }\n        }\n\n        sort(teams.begin(), teams.end(), compareTeams);\n\n        vector<vector<int>> ranks;\n        if (!teams.empty()) {\n            vector<int> current = {teams[0].number};\n            for (size_t i = 1; i < teams.size(); ++i) {\n                if (teams[i].solved == teams[i-1].solved && teams[i].time == teams[i-1].time) {\n                    current.push_back(teams[i].number);\n                } else {\n                    ranks.push_back(current);\n                    current = {teams[i].number};\n                }\n            }\n            ranks.push_back(current);\n        }\n\n        for (size_t i = 0; i < ranks.size(); ++i) {\n            sort(ranks[i].begin(), ranks[i].end(), greater<int>());\n            for (size_t j = 0; j < ranks[i].size(); ++j) {\n                if (j > 0) cout << \"=\";\n                cout << ranks[i][j];\n            }\n            if (i < ranks.size() - 1) cout << \",\";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_TEAMS 100\n#define MAX_PROBLEMS 10\n\ntypedef struct {\n    int team_num;\n    int problems_solved;\n    int total_time;\n    int attempts[MAX_PROBLEMS];\n    int solved[MAX_PROBLEMS];\n} TeamResult;\n\nint compare_teams(const void *a, const void *b) {\n    TeamResult *team1 = (TeamResult *)a;\n    TeamResult *team2 = (TeamResult *)b;\n\n    if (team1->problems_solved != team2->problems_solved)\n        return team2->problems_solved - team1->problems_solved;\n    \n    return team1->total_time - team2->total_time;\n}\n\nint main() {\n    int num_teams, num_problems, num_submissions;\n    int dataset = 1;\n\n    while (1) {\n        scanf(\"%d %d %d\", &num_teams, &num_problems, &num_submissions);\n        \n        if (num_teams == 0 && num_problems == 0 && num_submissions == 0)\n            break;\n\n        TeamResult teams[MAX_TEAMS] = {0};\n        for (int i = 0; i < num_teams; i++)\n            teams[i].team_num = i + 1;\n\n        for (int i = 0; i < num_submissions; i++) {\n            int time, team, problem;\n            char judgment[4];\n            scanf(\"%d %d %d %s\", &time, &team, &problem, judgment);\n            team--;\n            problem--;\n\n            if (!teams[team].solved[problem]) {\n                if (strcmp(judgment, \"AC\") == 0) {\n                    teams[team].solved[problem] = 1;\n                    teams[team].problems_solved++;\n                    teams[team].total_time += time + 20 * teams[team].attempts[problem];\n                } else {\n                    teams[team].attempts[problem]++;\n                }\n            }\n        }\n\n        qsort(teams, num_teams, sizeof(TeamResult), compare_teams);\n\n        printf(\"Contest %d\\n\", dataset++);\n        for (int i = 0; i < num_teams; i++) {\n            int j = i;\n            while (j + 1 < num_teams && \n                   teams[j+1].problems_solved == teams[i].problems_solved && \n                   teams[j+1].total_time == teams[i].total_time)\n                j++;\n\n            for (int k = i; k <= j; k++)\n                printf(\"%d \", teams[k].team_num);\n            \n            printf(\"%d %d\\n\", teams[i].problems_solved, teams[i].total_time);\n            \n            i = j;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct TeamStats {\n    int solved = 0;\n    int time = 0;\n};\n\nstruct Team {\n    int number;\n    int solved;\n    int time;\n    \n    bool operator<(const Team& other) const {\n        if (solved != other.solved) return solved > other.solved;\n        return time < other.time;\n    }\n};\n\nint main() {\n    int dataset = 1;\n    while (true) {\n        int n, m, q;\n        cin >> n >> m >> q;\n        \n        if (n == 0 && m == 0 && q == 0) break;\n        \n        map<int, map<int, bool>> solved;\n        map<int, map<int, int>> attempts;\n        map<int, TeamStats> teamStats;\n        \n        for (int i = 0; i < q; i++) {\n            int time, team, problem;\n            string verdict;\n            cin >> time >> team >> problem >> verdict;\n            \n            if (solved[team][problem]) continue;\n            \n            if (verdict == \"right\") {\n                solved[team][problem] = true;\n                teamStats[team].solved++;\n                teamStats[team].time += time + 20 * attempts[team][problem];\n            } else {\n                attempts[team][problem]++;\n            }\n        }\n        \n        vector<Team> rankings;\n        for (auto& entry : teamStats) {\n            rankings.push_back({entry.first, entry.second.solved, entry.second.time});\n        }\n        \n        sort(rankings.begin(), rankings.end());\n        \n        cout << \"Dataset \" << dataset++ << endl;\n        \n        int rank = 1;\n        for (size_t i = 0; i < rankings.size(); i++) {\n            if (i > 0 && (rankings[i].solved != rankings[i-1].solved || rankings[i].time != rankings[i-1].time)) {\n                rank = i + 1;\n            }\n            cout << rank << \" \" << rankings[i].number << \" \" << rankings[i].solved << \" \" << rankings[i].time << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Team {\n    int number;\n    int solved;\n    int time;\n\n    Team(int number) {\n        this.number = number;\n        this.solved = 0;\n        this.time = 0;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        while (true) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int M = Integer.parseInt(st.nextToken());\n            int T = Integer.parseInt(st.nextToken());\n            int P = Integer.parseInt(st.nextToken());\n            int R = Integer.parseInt(st.nextToken());\n\n            if (M == 0 && T == 0 && P == 0 && R == 0) break;\n\n            Team[] teams = new Team[T + 1];\n            for (int i = 1; i <= T; i++) {\n                teams[i] = new Team(i);\n            }\n\n            int[][] penalty = new int[T + 1][P + 1];\n            boolean[][] solved = new boolean[T + 1][P + 1];\n\n            for (int i = 0; i < R; i++) {\n                st = new StringTokenizer(br.readLine());\n                int m = Integer.parseInt(st.nextToken());\n                int t = Integer.parseInt(st.nextToken());\n                int p = Integer.parseInt(st.nextToken());\n                int j = Integer.parseInt(st.nextToken());\n\n                if (j == 0) {\n                    if (!solved[t][p]) {\n                        teams[t].solved++;\n                        teams[t].time += m + penalty[t][p] * 20;\n                        solved[t][p] = true;\n                    }\n                } else {\n                    if (!solved[t][p]) {\n                        penalty[t][p]++;\n                    }\n                }\n            }\n\n            Arrays.sort(teams, 1, T + 1, new Comparator<Team>() {\n                public int compare(Team a, Team b) {\n                    if (a.solved != b.solved) {\n                        return b.solved - a.solved;\n                    } else if (a.time != b.time) {\n                        return a.time - b.time;\n                    } else {\n                        return b.number - a.number;\n                    }\n                }\n            });\n\n            StringBuilder sb = new StringBuilder();\n            for (int i = 1; i <= T; i++) {\n                if (i > 1) {\n                    if (teams[i].solved == teams[i - 1].solved && teams[i].time == teams[i - 1].time) {\n                        sb.append(\"=\");\n                    } else {\n                        sb.append(\",\");\n                    }\n                }\n                sb.append(teams[i].number);\n            }\n            out.println(sb.toString());\n        }\n        out.flush();\n    }\n}",
    "timestamp": "2025-08-05 19:13:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def process_contests():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    while index < len(data):\n        scores = defaultdict(lambda: {'solved': set(), 'time': 0, 'penalties': defaultdict(int)})\n        \n        while True:\n            # Read one line of the dataset\n            line = data[index]\n            index += 1\n            if line.strip() == \"0 0 0 0\":\n                break\n            \n            elapsed_time, team_number, problem_number, judgment = line.split()\n            elapsed_time, team_number, problem_number = int(elapsed_time), int(team_number), int(problem_number)\n            \n            if judgment == 'N':\n                scores[team_number]['penalties'][problem_number] += 1\n            elif judgment == 'Y':\n                if problem_number not in scores[team_number]['solved']:\n                    scores[team_number]['solved'].add(problem_number)\n                    scores[team_number]['time'] += elapsed_time + 20 * scores[team_number]['penalties'][problem_number]\n        \n        # Sort teams based on rules: more solved first, then less time\n        rankings = sorted(scores.items(), key=lambda x: (-len(x[1]['solved']), x[1]['time'], x[0]))\n        \n        # Format ranking output\n        result = []\n        for _, group in itertools.groupby(rankings, key=lambda x: (len(x[1]['solved']), x[1]['time'])):\n            teams = sorted(team_number for team_number, _ in group)\n            result.append(' '.join(map(str, teams)))\n        \n        for res in result:\n            print(res)\n\nimport itertools\n\nprocess_contests()",
    "timestamp": "2025-08-13 02:58:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ICPCRanking {\n\n    static class Submission {\n        int time;\n        int team;\n        int problem;\n        String judgment;\n\n        Submission(int time, int team, int problem, String judgment) {\n            this.time = time;\n            this.team = team;\n            this.problem = problem;\n            this.judgment = judgment;\n        }\n    }\n\n    static class Team implements Comparable<Team> {\n        int number;\n        int solvedProblems;\n        int totalTime;\n\n        Team(int number) {\n            this.number = number;\n            this.solvedProblems = 0;\n            this.totalTime = 0;\n        }\n\n        @Override\n        public int compareTo(Team other) {\n            if (this.solvedProblems != other.solvedProblems) {\n                return other.solvedProblems - this.solvedProblems;\n            }\n            if (this.totalTime != other.totalTime) {\n                return this.totalTime - other.totalTime;\n            }\n            return this.number - other.number;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            Map<Integer, Team> teams = new HashMap<>();\n            Map<String, Integer> penalties = new HashMap<>();\n            List<Submission> submissions = new ArrayList<>();\n\n            while (true) {\n                int time = sc.nextInt();\n                int teamNumber = sc.nextInt();\n                int problemNumber = sc.nextInt();\n                String judgment = sc.next();\n\n                if (time == 0 && teamNumber == 0 && problemNumber == 0 && judgment.equals(\"0\")) break;\n\n                submissions.add(new Submission(time, teamNumber, problemNumber, judgment));\n            }\n\n            for (Submission s : submissions) {\n                String key = s.team + \"-\" + s.problem;\n                if (!teams.containsKey(s.team)) {\n                    teams.put(s.team, new Team(s.team));\n                }\n\n                if (s.judgment.equals(\"CORRECT\")) {\n                    Team team = teams.get(s.team);\n                    team.solvedProblems++;\n                    team.totalTime += s.time + penalties.getOrDefault(key, 0);\n                } else {\n                    penalties.put(key, penalties.getOrDefault(key, 0) + 20);\n                }\n            }\n\n            List<Team> teamList = new ArrayList<>(teams.values());\n            Collections.sort(teamList);\n\n            for (int i = 0; i < teamList.size(); i++) {\n                if (i == 0 || teamList.get(i).compareTo(teamList.get(i - 1)) != 0) {\n                    if (i > 0) System.out.print(\", \");\n                    System.out.print(teamList.get(i).number);\n                    for (int j = i + 1; j < teamList.size(); j++) {\n                        if (teamList.get(j).compareTo(teamList.get(i)) == 0) {\n                            System.out.print(\"=\");\n                            System.out.print(teamList.get(j).number);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n            System.out.println();\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 02:58:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_TEAMS 100\n#define MAX_PROBLEMS 10\n\ntypedef struct {\n    int problemsSolved;\n    int totalTime;\n    int teamNumber;\n} Team;\n\ntypedef struct {\n    int attempts[MAX_TEAMS][MAX_PROBLEMS];\n    int solvedTime[MAX_TEAMS][MAX_PROBLEMS];\n    int problemsSolved[MAX_TEAMS];\n    int totalConsumedTime[MAX_TEAMS];\n} Contest;\n\nint compareTeams(const void *a, const void *b) {\n    Team *teamA = (Team *)a;\n    Team *teamB = (Team *)b;\n\n    if (teamA->problemsSolved != teamB->problemsSolved)\n        return teamB->problemsSolved - teamA->problemsSolved;\n    if (teamA->totalTime != teamB->totalTime)\n        return teamA->totalTime - teamB->totalTime;\n    return teamA->teamNumber - teamB->teamNumber;\n}\n\nvoid processDataset(Contest *contest) {\n    Team teams[MAX_TEAMS];\n    for (int i = 1; i < MAX_TEAMS; i++) {\n        teams[i].teamNumber = i;\n        teams[i].problemsSolved = contest->problemsSolved[i];\n        teams[i].totalTime = contest->totalConsumedTime[i];\n    }\n\n    qsort(&teams[1], MAX_TEAMS - 1, sizeof(Team), compareTeams);\n    \n    for (int i = 1; i < MAX_TEAMS && teams[i].problemsSolved > 0; i++) {\n        if (i > 1 && teams[i - 1].problemsSolved == teams[i].problemsSolved\n            && teams[i - 1].totalTime == teams[i].totalTime) {\n            printf(\"=\");\n        }\n        printf(\"%d\", teams[i].teamNumber);\n        if (i < MAX_TEAMS -1 && teams[i + 1].problemsSolved > 0) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char line[50];\n    while (fgets(line, sizeof(line), stdin)) {\n        Contest contest;\n        memset(&contest, 0, sizeof(contest));\n        int elapsedTime, teamNumber, problemNumber;\n        char judgment;\n\n        while (sscanf(line, \"%d %d %d %c\", &elapsedTime, &teamNumber, &problemNumber, &judgment) == 4) {\n            if (elapsedTime == 0 && teamNumber == 0 && problemNumber == 0 && judgment == '0') {\n                break;\n            }\n\n            if (judgment == 'Y') {\n                if (contest.solvedTime[teamNumber][problemNumber] == 0) {\n                    contest.solvedTime[teamNumber][problemNumber] = elapsedTime;\n                    contest.problemsSolved[teamNumber]++;\n                    contest.totalConsumedTime[teamNumber] += elapsedTime + contest.attempts[teamNumber][problemNumber] * 20;\n                }\n            } else if (judgment == 'N') {\n                contest.attempts[teamNumber][problemNumber]++;\n            }\n      \n            fgets(line, sizeof(line), stdin);\n        }\n        \n        processDataset(&contest);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:58:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_icpc_ranking(submissions):\n    team_problems = {}\n    team_times = {}\n    team_penalties = {}\n    \n    for time, team, problem, judgment in submissions:\n        if team not in team_problems:\n            team_problems[team] = set()\n            team_times[team] = 0\n            team_penalties[team] = 0\n        \n        if problem not in team_problems[team]:\n            if judgment == 'Y':\n                team_problems[team].add(problem)\n                team_times[team] += time\n                team_times[team] += 20 * team_penalties[team].get(problem, 0)\n            elif judgment == 'N':\n                team_penalties[team][problem] = team_penalties[team].get(problem, 0) + 1\n    \n    ranking = {}\n    sorted_teams = sorted(team_problems.keys(), \n                          key=lambda t: (-len(team_problems[t]), team_times[t]))\n    \n    current_rank = 1\n    current_problems = None\n    current_time = None\n    \n    for team in sorted_teams:\n        problems_solved = len(team_problems[team])\n        total_time = team_times[team]\n        \n        if current_problems != problems_solved or current_time != total_time:\n            current_rank = sum(1 for t in sorted_teams \n                               if len(team_problems[t]) > problems_solved or \n                               (len(team_problems[t]) == problems_solved and team_times[t] < total_time)) + 1\n            current_problems = problems_solved\n            current_time = total_time\n        \n        ranking[team] = current_rank\n    \n    return ranking\n\ndef main():\n    while True:\n        submissions = []\n        while True:\n            line = input().split()\n            if len(line) == 4:\n                time, team, problem, judgment = map(str, line)\n                time = int(time)\n                team = int(team)\n                submissions.append((time, team, problem, judgment))\n            else:\n                break\n        \n        if not submissions:\n            break\n        \n        ranking = solve_icpc_ranking(submissions)\n        \n        sorted_teams = sorted(ranking.keys(), \n                               key=lambda t: (ranking[t], t))\n        \n        for team in sorted_teams:\n            print(f\"{team} {ranking[team]}\")\n        \n        print()\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:59:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    while True:\n        M, T, P, R = map(int, sys.stdin.readline().split())\n        if M == T == P == R == 0:\n            break\n        \n        # Initialize data structures\n        solved = [0] * (T + 1)  # 1-based indexing\n        penalty = [0] * (T + 1)\n        # For each team, for each problem, track if solved and number of incorrect attempts\n        team_problem = [[False, 0] for _ in range((T + 1) * (P + 1))]  # (T+1)*(P+1) array\n        \n        for _ in range(R):\n            m, t, p, j = map(int, sys.stdin.readline().split())\n            if j == 0:  # correct\n                if not team_problem[t * P + p][0]:\n                    team_problem[t * P + p][0] = True\n                    solved[t] += 1\n                    penalty[t] += m + 20 * team_problem[t * P + p][1]\n            else:  # incorrect\n                if not team_problem[t * P + p][0]:\n                    team_problem[t * P + p][1] += 1\n        \n        # Prepare list of teams (excluding team 0)\n        teams = list(range(1, T + 1))\n        \n        # Sort teams based on solved problems (descending) and penalty (ascending)\n        teams.sort(key=lambda x: (-solved[x], penalty[x]))\n        \n        # Prepare the output\n        output = []\n        i = 0\n        n = len(teams)\n        while i < n:\n            current_solved = solved[teams[i]]\n            current_penalty = penalty[teams[i]]\n            start = i\n            # Find all teams with same solved and penalty\n            while i < n and solved[teams[i]] == current_solved and penalty[teams[i]] == current_penalty:\n                i += 1\n            # Extract the group\n            group = teams[start:i]\n            group.sort(reverse=True)\n            if len(output) > 0:\n                output.append(',')\n            output.append(','.join(map(str, group)))\n        \n        print(' '.join(output))\n\nif __name__ == '__main__':\n    solve()",
    "timestamp": "2025-08-13 02:59:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Submission {\n    int time;\n    int team;\n    int problem;\n    string judgment;\n};\n\nstruct TeamResult {\n    int problemsSolved = 0;\n    int totalTime = 0;\n    unordered_map<int, int> problemAttempts;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int time, team, problem;\n    string judgment;\n\n    while (true) {\n        map<int, TeamResult> teams;\n        vector<Submission> submissions;\n        while (cin >> time >> team >> problem >> judgment) {\n            if (time == 0 && team == 0 && problem == 0 && judgment == \"0\") break;\n            submissions.push_back({time, team, problem, judgment});\n        }\n\n        if (submissions.empty()) break;\n\n        for (const auto &sub : submissions) {\n            auto &teamResult = teams[sub.team];\n            if (sub.judgment == \"CORRECT\") {\n                if (teamResult.problemAttempts[sub.problem] != -1) {\n                    teamResult.problemsSolved++;\n                    teamResult.totalTime += sub.time + teamResult.problemAttempts[sub.problem] * 20;\n                    teamResult.problemAttempts[sub.problem] = -1;\n                }\n            } else if (sub.judgment == \"WRONG\") {\n                if (teamResult.problemAttempts[sub.problem] != -1)\n                    teamResult.problemAttempts[sub.problem]++;\n            }\n        }\n\n        vector<pair<int, TeamResult>> results(teams.begin(), teams.end());\n        sort(results.begin(), results.end(), [](const auto &a, const auto &b) {\n            if (a.second.problemsSolved != b.second.problemsSolved)\n                return a.second.problemsSolved > b.second.problemsSolved;\n            if (a.second.totalTime != b.second.totalTime)\n                return a.second.totalTime < b.second.totalTime;\n            return a.first < b.first;\n        });\n\n        set<int> previousTeams;\n        int lastProblemsSolved = -1;\n        int lastTotalTime = -1;\n\n        for (const auto &result : results) {\n            if (result.second.problemsSolved != lastProblemsSolved ||\n                result.second.totalTime != lastTotalTime) {\n\n                if (!previousTeams.empty()) {\n                    for (auto it = previousTeams.begin(); it != previousTeams.end(); ++it) {\n                        if (it != previousTeams.begin()) cout << \"=\";\n                        cout << *it;\n                    }\n                    cout << \"\\n\";\n                    previousTeams.clear();\n                }\n                lastProblemsSolved = result.second.problemsSolved;\n                lastTotalTime = result.second.totalTime;\n            }\n            previousTeams.insert(result.first);\n        }\n\n        if (!previousTeams.empty()) {\n            for (auto it = previousTeams.begin(); it != previousTeams.end(); ++it) {\n                if (it != previousTeams.begin()) cout << \"=\";\n                cout << *it;\n            }\n            cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:09:02"
  }
]