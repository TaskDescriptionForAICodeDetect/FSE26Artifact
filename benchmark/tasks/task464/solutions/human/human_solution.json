[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long dp[13][1<<18];\nint L[10];\nint R[10];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d\",L+i,R+i);\n\t\t}\n\t\tfor(int i=0;i<13;i++)for(int j=0;j<(1<<(a*3));j++)dp[i][j]=0;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint to=0;\n\t\t\tif(L[0]<=i&&i<=R[0])to+=1;\n\t\t\tif((L[0]/10<=i&&i<R[0]/10)||(L[0]/10==R[0]/10&&i==L[0]/10))to+=2;\n\t\t\tif(L[0]/10<i&&i<=R[0]/10)to+=4;\n\t\t\tdp[1][to]++;\n\t\t}\n\t\tfor(int i=1;i<a*2;i++){\n\t\t\tfor(int j=0;j<(1<<(a*3));j++){\n\t\t\t\tif(!dp[i][j])continue;\n\t\t\t\tif(!j)continue;\n\t\t\t//\tprintf(\"%d %d: %lld\\n\",i,j,dp[i][j]);\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tint to=0;\n\t\t\t\t\tfor(int l=0;l<a*3;l++){\n\t\t\t\t\t\tif(!(j&(1<<l)))continue;\n\t\t\t\t\t\tif(l==a*3-3)continue;\n\t\t\t\t\t\tif(l%3==0){\n\t\t\t\t\t\t\tif(k==0)continue;\n\t\t\t\t\t\t\tif(L[l/3+1]<=k&&k<=R[l/3+1])to|=(1<<(l+3));\n\t\t\t\t\t\t\tif((L[l/3+1]/10<=k&&k<R[l/3+1]/10)||(L[l/3+1]/10==R[l/3+1]/10&&k==L[l/3+1]/10))to|=(1<<(l+4));\n\t\t\t\t\t\t\tif(L[l/3+1]/10<k&&k<=R[l/3+1]/10)to|=(1<<(l+5));\n\t\t\t\t\t\t}else if(l%3==1){\n\t\t\t\t\t\t\tif(L[l/3]/10==R[l/3]/10){\n\t\t\t\t\t\t\t\tif(L[l/3]%10<=k&&k<=R[l/3]%10)to|=(1<<(l-1));\n\t\t\t\t\t\t\t}else if(L[l/3]%10<=k)to|=(1<<(l-1));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(k<=R[l/3]%10)to|=(1<<(l-2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(to)dp[i+1][to]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<=a*2;i++){\n\t\t\tfor(int j=0;j<(1<<(a*3));j++){\n\t\t\t\tif(j&(1<<(a*3-3)))ret+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nint sbstr[1000000][15];\nint lgt[1000000];\nint pow_10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nint cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tint c=0;\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) {\n\t\t\t\tsbstr[i][c]=stoi(s.substr(j,k));\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tlgt[i]=(int)s.length();\n\t}\n\tpow_10[0]=1;\n\tpow_10[1]=10;\n\tpow_10[2]=100;\n\tpow_10[3]=1000;\n\tpow_10[4]=10000;\n\tpow_10[5]=100000;\n\treturn;\n}\n\nint sbst(int n, int l, int m) {\n\tif(l==0) return sbstr[n][m];\n\tif(l==1) return sbstr[n][6+m];\n\tif(l==2) return sbstr[n][11+m];\n\tif(l==3) return sbstr[n][15+m];\n\tif(l==4) return sbstr[n][18+m];\n\tif(l==5) return sbstr[n][20+m];\n\treturn 0;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbst(j,1,0)!=0&&sbst(j,0,0)>=el[i].first&&sbst(j,0,0)<=el[i].second&&dp1[i+1][sbst(j,1,lgt[j]-2)]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbst(j,2,0)!=0&&sbst(j,0,1)>=el[i].first&&sbst(j,0,1)<=el[i].second&&dp1[i+1][sbst(j,2,lgt[j]-3)]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbst(j,1,0)!=0&&sbst(j,0,0)>=el[i].first&&sbst(j,0,0)<=el[i].second&&dp2[i+1-mid][sbst(j,1,lgt[j]-2)]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbst(j,2,0)!=0&&sbst(j,0,1)>=el[i].first&&sbst(j,0,1)<=el[i].second&&dp2[i+1-mid][sbst(j,2,lgt[j]-3)]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow_10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow_10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbst(i,0,j-1)]&&sbst(i,j,0)!=0)  {\n\t\t\t\tret-=cnt[sbst(i,j,lgt[i]-j-1)];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nunordered_set<int> se;\nvector<string> vs1;\nvector<string> vs2;\nvector<pii> v1,v2;\nvoid foo1(int x,string y){\n\tif(x==v1.size()){\n\t\tvs1.PB(y);\n\t\treturn;\n\t}\n\treep(i,v1[x].F,v1[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo1(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid foo2(int x,string y){\n\tif(x==v2.size()){\n\t\tvs2.PB(y);\n\t\treturn;\n\t}\n\treep(i,v2[x].F,v2[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo2(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tse.clear();\n\t\tv1=vector<pii>(n/2);\n\t\tv2=vector<pii>(n-v1.size());\n\t\tvs1.clear();\n\t\tvs2.clear();\n\t\trep(i,n/2) cin>>v1[i].F>>v1[i].S;\n\t\trep(i,v2.size()) cin>>v2[i].F>>v2[i].S;\n\t\tfoo1(0,\"\");\n\t\tfoo2(0,\"\");\n\t\t// cout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\tsort(ALL(vs1));\n\t\tsort(ALL(vs2));\n\t\tvs1.erase(unique(ALL(vs1)),vs1.end());\n\t\tvs2.erase(unique(ALL(vs2)),vs2.end());\n\t\t// cout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\trep(i,vs1.size()){\n\t\t\trep(j,vs2.size()){\n\t\t\t\tint t;\n\t\t\t\tconvert(vs1[i]+vs2[j],t);// cout<<vs1[i]+vs2[j]<<endl;\n\t\t\t\tse.insert(t);\n\t\t\t}\n\t\t}\n\t\tcout<<se.size()<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int maton_size = 10;\nstruct n_maton {\n\tint n_id;\n\tvector<vector<int>>edgess;\n\tn_maton(const int id_, const vector<vector<int>>edgess_) :n_id(id_), edgess(edgess_) {\n\t\tassert(maton_size + 1 == edgess.size());\n\t}\n\tn_maton() :n_id(0), edgess(maton_size+1) {}\n};\nstruct nfa{\n\tstruct d_maton {\n\t\tint d_id;\n\t\tvector<int>n_ids;\n\t\tvector<int>d_edges;\n\t\td_maton(const int id_, const n_maton&mat) :d_id(id_), n_ids(1, mat.n_id),d_edges(maton_size) {}\n\t\td_maton(const int id_, const vector<n_maton>&mats) :\n\t\t\td_id(id_), n_ids(),d_edges(maton_size) {\n\t\t\tfor (auto m : mats) {\n\t\t\t\tn_ids.emplace_back(m.n_id);\n\t\t\t\tvector<vector<int>>n_edgess;\n\t\t\t\tfor (auto es : m.edgess) {\n\t\t\t\t\tfor (int i = 0; i < maton_size + 1; ++i) {\n\t\t\t\t\t\tfor (auto e : es) {\n\t\t\t\t\t\t\tn_edgess[i].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < maton_size + 1; ++i) {\n\t\t\t\t\tsort(n_edgess[i].begin(), n_edgess[i].end());\n\t\t\t\t\tn_edgess[i].erase(unique(n_edgess[i].begin(), n_edgess[i].end()), n_edgess[i].end());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td_maton(const int id_, const vector<int>n_ids_) :\n\t\t\td_id(id_), n_ids(n_ids_),d_edges(maton_size) {}\n\t};\n\tvector<n_maton>n_nodes;\n\tvector<d_maton>d_nodes;\n\tvector<int> get_epsilons(const vector<int>&now_n_ids) {\n\t\tvector<int>epsilons(n_nodes.size());\n\t\tqueue<int>ep_que;\n\t\tfor (auto n_id : now_n_ids) {\n\t\t\tepsilons[n_id] = true;\n\t\t\tep_que.push(n_id);\n\t\t}\n\t\twhile (!ep_que.empty()) {\n\t\t\tconst int ep_n_id = ep_que.front();\n\t\t\tep_que.pop();\n\t\t\tfor (auto e : n_nodes[ep_n_id].edgess[maton_size]) {\n\t\t\t\tif (!epsilons[e]) {\n\t\t\t\t\tepsilons[e] = true;\n\t\t\t\t\tep_que.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>eps_n_ids;\n\t\tfor (int i = 0; i < static_cast<int>(n_nodes.size()); ++i) {\n\t\t\tif (epsilons[i])eps_n_ids.push_back(i);\n\t\t}\n\t\treturn eps_n_ids;\n\t}\n\tvector<int>get_next_ids(const vector<int>&now_n_ids,const int n) {\n\t\tvector<int>next_n_ids;\n\t\tfor (auto n_id:now_n_ids){\n\t\t\tfor (auto e : n_nodes[n_id].edgess[n]) {\n\t\t\t\tnext_n_ids.emplace_back(e);\n\t\t\t}\n\t\t}\n\t\tsort(next_n_ids.begin(), next_n_ids.end());\n\t\tnext_n_ids.erase(unique(next_n_ids.begin(), next_n_ids.end()), next_n_ids.end());\n\t\treturn next_n_ids;\n\t}\n\tnfa(const int num):n_nodes(num),d_nodes() {\n\t\tfor (int i = 0; i < num; ++i)n_nodes[i].n_id = i;\n\t}\n\tnfa(const vector<n_maton>&n_mats) :n_nodes(n_mats) {\n\t}\n\tvoid add_edge(const int from, const int num,const int to) {\n\t\tn_nodes[from].edgess[num].push_back(to);\n\t}\n\tvoid make_dfa(const int start_id) {\n\t\tqueue<int>que;\n\t\tvector<int>starts(1,n_nodes[0].n_id);\n\t\tstarts = get_epsilons(starts);\n\t\td_nodes.push_back(d_maton(0,n_nodes[0]));\n\t\tque.push(0);\n\t\tint num = 1;\n\t\twhile (!que.empty()) {\n\t\t\tconst int now_d_id = que.front();\n\t\t\tque.pop();\n\t\t\tfor (int n = 0; n < maton_size; ++n) {\n\t\t\t\tvector<int>now_n_ids(d_nodes[now_d_id].n_ids);\n\n\t\t\t\tvector<int>next_n_ids = get_next_ids(now_n_ids, n);\n\t\t\t\tnext_n_ids = get_epsilons(next_n_ids);\n\t\t\t\tauto it = find_if(d_nodes.begin(), d_nodes.end(), [=](const d_maton&mat) {\n\t\t\t\t\treturn mat.n_ids == next_n_ids;\n\t\t\t\t});\n\t\t\t\tif (!next_n_ids.empty()) {\n\t\t\t\t\tif (it == d_nodes.end()) {\n\t\t\t\t\t\td_nodes.emplace_back(num, next_n_ids);\n\t\t\t\t\t\tque.push(num);\n\t\t\t\t\t\td_nodes[now_d_id].d_edges[n] = num;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\td_nodes[now_d_id].d_edges[n] = it - d_nodes.begin();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td_nodes[now_d_id].d_edges[n] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tconst int ps = 0;\n\t\tconst int ss = ps+N+1;\n\t\tconst int rs = ss + N;\n\t\tconst int qs = rs + N;\n\t\tvector<n_maton>matons(qs + N);\n\t\tnfa anfa(qs + N);\n\t\t\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, r; cin >> l >> r;\n\t\t\t//1~9\n\t\t\tif (r < 10) {\n\t\t\t\tfor (int n = l; n <= r; ++n) {\n\t\t\t\t\tanfa.add_edge(ps + i, n, ps + i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (l < 10) {\n\t\t\t\t\tfor (int n = l; n <= 9; ++n) {\n\t\t\t\t\t\tanfa.add_edge(ps + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = max(l, 10); r = max(r, 10);\n\t\t\t\tif (l / 10 == r / 10) {\n\t\t\t\t\tanfa.add_edge(ps + i, l / 10, ss + i);\n\t\t\t\t\tfor (int n = l % 10; n <= r % 10; ++n) {\n\t\t\t\t\t\tanfa.add_edge(ss + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tanfa.add_edge(ps + i, l / 10, qs + i);\n\t\t\t\t\tfor (int n = l % 10; n < 10; ++n) {\n\t\t\t\t\t\tanfa.add_edge(qs + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = l / 10 + 1; m < r / 10; ++m) {\n\t\t\t\t\t\tanfa.add_edge(ps + i, m, rs + i);\n\t\t\t\t\t\tfor (int n = 0; n < 10; ++n) {\n\t\t\t\t\t\t\tanfa.add_edge(rs + i, n, ps + i + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tanfa.add_edge(ps + i, r / 10, ss + i);\n\t\t\t\t\tfor (int n = 0; n <= r % 10; ++n) {\n\t\t\t\t\t\tanfa.add_edge(ss + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tanfa.make_dfa(0);\n\t\tvector<int>goals(anfa.d_nodes.size());\n\t\tvector < vector<int>>edges(anfa.d_nodes.size());\n\t\tvector<int>nums(anfa.d_nodes.size());\n\t\tvector<long long int>memos(anfa.d_nodes.size());\n\t\tfor (auto n : anfa.d_nodes) {\n\t\t\tif (find(n.n_ids.begin(), n.n_ids.end(), ss - 1) != n.n_ids.end()) {\n\t\t\t\tgoals[n.d_id] = true;\n\t\t\t}\n\t\t\tfor (auto e : n.d_edges) {\n\t\t\t\tif (e != -1) {\n\t\t\t\t\tedges[n.d_id].push_back(e);\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\tqueue<int>que;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tif (!nums[i]) {\n\t\t\t\tque.push(i);\n\t\t\t\tmemos[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tint n = que.front();\n\t\t\tque.pop();\n\t\t\tif (goals[n])ans += memos[n];\n\t\t\tfor (auto e : edges[n]) {\n\t\t\t\tmemos[e] += memos[n];\n\t\t\t\tnums[e]--;\n\t\t\t\tif (!nums[e]) {\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint N;\nvector<pii> D;\nvector<int> G[12][10][10];\nll dp[14][1 << 12][10];\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tD.clear();\n\t\trep(i,12) {\n\t\t\trep(j,1<<12) {\n\t\t\t\trep(k,10) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,12)\n\t\t\trep(j,10)\n\t\t\t\trep(k,10)\n\t\t\t\t\tG[i][j][k].clear();\n\n\t\tD.resize(N);\n\t\trep(i,N) {\n\t\t\tcin >> D[i].fi >> D[i].se;\n\t\t}\n\n\t\trep(i, D.size()) {\n\t\t\tfor(int j = max(10, D[i].fi); j <= D[i].se; j++)\n\t\t\t\tG[i*2][j / 10][j%10].push_back(i*2+1);\n\t\t\t\n\t\t\trep(j, 10) {\n\t\t\t\tif(i < (int)D.size()-1) {\n\t\t\t\t\tfor(int k = D[i+1].fi; k <= min(9, D[i+1].se); k++)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2+1);\n\t\t\t\t\tfor(int k = max(D[i+1].fi / 10, 1); k <= D[i+1].se / 10; k++) {\n\t\t\t\t\t\tif(k == 0) continue;\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trep(k,10)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < 10; i++) {\n\t\t\tint s = 0;\n\t\t\tif(D[0].fi <= i && i <= D[0].se)\n\t\t\t\ts |= 1 << 1;\n\t\t\tif(D[0].fi / 10 <= i && i <= D[0].se / 10)\n\t\t\t\ts |= 1;\n\t\t\tdp[1][s][i] = !!s;\n\t\t}\n\n\t\tll res = 0;\n\t\tfor(int i = 1; i <= D.size()*2; i++) {\n\t\t\tfor(int j = 1; j < (1 << (D.size()*2)); j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif(dp[i][j][k] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/*\n\t\t\t\t\tcout << i << \" \";\n\t\t\t\t\tfor(int m = 0; m < 16; m++) {\n\t\t\t\t\t\tcout << !!(j & (1 << m));\n\t\t\t\t\t} cout << \" \" << k << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tint s = 0;\n\t\t\t\t\t\tfor(int m = 0; m < D.size()*2; m++) {\n\t\t\t\t\t\t\tif(j & (1 << m)) {\n\t\t\t\t\t\t\t\tfor(int a = 0; a < G[m][k][l].size(); a++) {\n\t\t\t\t\t\t\t\t\ts |= 1 << G[m][k][l][a];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s & (1 << (D.size()*2))) {\n\t\t\t\t\t\t\tres += dp[i][j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i+1][s & ((1 << (D.size()*2)) - 1)][l] += dp[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i <= D.size()*2; i++) {\n\t\t\tfor(int j = 0; j < (1 << (D.size()*2)); j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t\t} cout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\t\tcout << res / 10 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long dp[13][1<<18];\nint L[10];\nint R[10];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d\",L+i,R+i);\n\t\t}\n\t\tfor(int i=0;i<13;i++)for(int j=0;j<(1<<(a*3));j++)dp[i][j]=0;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint to=0;\n\t\t\tif(L[0]<=i&&i<=R[0])to+=1;\n\t\t\tif((L[0]/10<=i&&i<R[0]/10)||(L[0]/10==R[0]/10&&i==L[0]/10))to+=2;\n\t\t\tif(L[0]/10<i&&i<=R[0]/10)to+=4;\n\t\t\tdp[1][to]++;\n\t\t}\n\t\tfor(int i=1;i<a*2;i++){\n\t\t\tfor(int j=0;j<(1<<(a*3));j++){\n\t\t\t\tif(!dp[i][j])continue;\n\t\t\t\tif(!j)continue;\n\t\t\t//\tprintf(\"%d %d: %lld\\n\",i,j,dp[i][j]);\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tint to=0;\n\t\t\t\t\tfor(int l=0;l<a*3;l++){\n\t\t\t\t\t\tif(!(j&(1<<l)))continue;\n\t\t\t\t\t\tif(l==a*3-3)continue;\n\t\t\t\t\t\tif(l%3==0){\n\t\t\t\t\t\t\tif(k==0)continue;\n\t\t\t\t\t\t\tif(L[l/3+1]<=k&&k<=R[l/3+1])to|=(1<<(l+3));\n\t\t\t\t\t\t\tif((L[l/3+1]/10<=k&&k<R[l/3+1]/10)||(L[l/3+1]/10==R[l/3+1]/10&&k==L[l/3+1]/10))to|=(1<<(l+4));\n\t\t\t\t\t\t\tif(L[l/3+1]/10<k&&k<=R[l/3+1]/10)to|=(1<<(l+5));\n\t\t\t\t\t\t}else if(l%3==1){\n\t\t\t\t\t\t\tif(L[l/3]/10==R[l/3]/10){\n\t\t\t\t\t\t\t\tif(L[l/3]%10<=k&&k<=R[l/3]%10)to|=(1<<(l-1));\n\t\t\t\t\t\t\t}else if(L[l/3]%10<=k)to|=(1<<(l-1));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(k<=R[l/3]%10)to|=(1<<(l-2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(to)dp[i+1][to]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<=a*2;i++){\n\t\t\tfor(int j=0;j<(1<<18);j++){\n\t\t\t\tif(j&(1<<(a*3-3)))ret+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll sbstr[1000000][6][7];\nll lgt[1000000];\nll pow10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nll cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) sbstr[i][j][k]=stol(s.substr(j,k));\n\t\t}\n\t\tlgt[i]=(ll)s.length();\n\t}\n\tpow10[0]=1;\n\tpow10[1]=10;\n\tpow10[2]=100;\n\tpow10[3]=1000;\n\tpow10[4]=10000;\n\tpow10[5]=100000;\n\treturn;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp1[i+1][sbstr[j][1][lgt[j]-1]]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp1[i+1][sbstr[j][2][lgt[j]-2]]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp2[i+1-mid][sbstr[j][1][lgt[j]-1]]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp2[i+1-mid][sbstr[j][2][lgt[j]-2]]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbstr[i][0][j]]&&sbstr[i][j][1]!=0)  {\n\t\t\t\tret-=cnt[sbstr[i][j][lgt[i]-j]];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint N;\nvector<pii> D;\nvector<int> G[12][10][10];\nll dp[14][1 << 12][10];\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tD.clear();\n\t\trep(i,14) {\n\t\t\trep(j,1<<12) {\n\t\t\t\trep(k,10) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,12)\n\t\t\trep(j,10)\n\t\t\t\trep(k,10)\n\t\t\t\t\tG[i][j][k].clear();\n\n\t\tD.resize(N);\n\t\trep(i,N) {\n\t\t\tcin >> D[i].fi >> D[i].se;\n\t\t}\n\n\t\trep(i, D.size()) {\n\t\t\tfor(int j = max(10, D[i].fi); j <= D[i].se; j++)\n\t\t\t\tG[i*2][j/10][j%10].push_back(i*2+1);\n\t\t\t\n\t\t\trep(j, 10) {\n\t\t\t\tif(i < (int)D.size()-1) {\n\t\t\t\t\tfor(int k = D[i+1].fi; k <= min(9, D[i+1].se); k++)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2+1);\n\t\t\t\t\tfor(int k = max(D[i+1].fi / 10, 1); k <= D[i+1].se / 10; k++)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trep(k,10)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < 10; i++) {\n\t\t\tint s = 0;\n\t\t\tif(D[0].fi <= i && i <= D[0].se)\n\t\t\t\ts |= 1 << 1;\n\t\t\tif(D[0].fi / 10 <= i && i <= D[0].se / 10)\n\t\t\t\ts |= 1;\n\t\t\tdp[1][s][i] = !!s;\n\t\t}\n\n\t\tll res = 0;\n\t\tfor(int i = 1; i <= D.size()*2; i++) {\n\t\t\tfor(int j = 1; j < (1 << (D.size()*2)); j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif(dp[i][j][k] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/*\n\t\t\t\t\tcout << i << \" \";\n\t\t\t\t\tfor(int m = 0; m < 16; m++) {\n\t\t\t\t\t\tcout << !!(j & (1 << m));\n\t\t\t\t\t} cout << \" \" << k << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tint s = 0;\n\t\t\t\t\t\tfor(int m = 0; m < D.size()*2; m++) {\n\t\t\t\t\t\t\tif(j & (1 << m)) {\n\t\t\t\t\t\t\t\tfor(int a = 0; a < G[m][k][l].size(); a++) {\n\t\t\t\t\t\t\t\t\ts |= 1 << G[m][k][l][a];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s & (1 << (D.size()*2))) {\n\t\t\t\t\t\t\tres += dp[i][j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i+1][s & ((1 << (D.size()*2)) - 1)][l] += dp[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i <= D.size()*2; i++) {\n\t\t\tfor(int j = 0; j < (1 << (D.size()*2)); j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t\t} cout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\t\tcout << res / 10 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nvector<int> sbstr[1000000][6];\nint lgt[1000000];\nint pow_10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nint cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) sbstr[i][j].push_back(stoi(s.substr(j,k)));\n\t\t}\n\t\tlgt[i]=(int)s.length();\n\t}\n\tpow_10[0]=1;\n\tpow_10[1]=10;\n\tpow_10[2]=100;\n\tpow_10[3]=1000;\n\tpow_10[4]=10000;\n\tpow_10[5]=100000;\n\treturn;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][0]!=0&&sbstr[j][0][0]>=el[i].first&&sbstr[j][0][0]<=el[i].second&&dp1[i+1][sbstr[j][1][lgt[j]-2]]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][0]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp1[i+1][sbstr[j][2][lgt[j]-3]]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][0]!=0&&sbstr[j][0][0]>=el[i].first&&sbstr[j][0][0]<=el[i].second&&dp2[i+1-mid][sbstr[j][1][lgt[j]-2]]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][0]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp2[i+1-mid][sbstr[j][2][lgt[j]-3]]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow_10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow_10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbstr[i][0][j-1]]&&sbstr[i][j][0]!=0)  {\n\t\t\t\tret-=cnt[sbstr[i][j][lgt[i]-j-1]];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll _pow(ll a,ll n) {\n\tif(n==0) return 1;\n\tif(n==1) return 10;\n\tif(n==2) return 100;\n\tif(n==3) return 1000;\n\tif(n==4) return 10000;\n\tif(n==5) return 100000;\n\tif(n==6) return 1000000;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tvector<vector<bool>> dp1(mid,vector<bool>(1000000,false));\n\tvector<vector<bool>> dp2(n-mid,vector<bool>(1000000,false));\n\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tvector<ll> cnt(1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nll dp[13][1<<13][10]; //桁数, 現在のエレベーター,　前の桁 \n\nbool solve(){\n  int n;\n  int low[7], up[7];\n  \n  scanf(\"%d\", &n);\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++) scanf(\"%d%d\", low+i, up+i);\n\n  memset(dp, 0, sizeof(dp));\n\n  dp[0][1][0] = 1;\n\n  ll ans = 0;\n\n  for(int i=0;i<n*2;i++){\n    for(int j=0;j<(1<<(2*n));j++){\n      for(int k=0;k<10;k++){\n        int next[10] = {};\n\n        for(int l=0;l<n;l++){\n          //1桁目\n          if((1 << (l*2)) & j){\n            for(int x=max(1,low[l]);x<=min(9, up[l]);x++)\n              next[x] |= 1 << (l*2+2);\n            for(int x=max(1,low[l]/10);x<=min(9,up[l]/10);x++)\n              next[x] |= 1 << (l*2+1);\n          }\n          //2桁目\n          if((1 << (l*2+1)) & j){\n            for(int x=max(0,(low[l]-k*10));x<=min(9, up[l]-k*10);x++)\n              next[x] |= 1 << (l*2+2);\n          }\n        }\n\n        for(int l=0;l<10;l++){\n          dp[i+1][next[l] & ((1 << n*2) - 1)][l] += dp[i][j][k];\n          if(next[l] & (1 << (n*2))) ans += dp[i][j][k];\n        }\n        \n      }\n    }\n  }\n  \n  cout << ans << endl;\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nll dp[13][1<<13][10]; //桁数, 現在のエレベーター,　前の桁 \n\nbool solve(){\n  int n;\n  int low[7], up[7];\n  \n  scanf(\"%d\", &n);\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++) scanf(\"%d%d\", low+i, up+i);\n\n  memset(dp, 0, sizeof(dp));\n\n  dp[0][1][0] = 1;\n\n  ll ans = 0;\n\n  for(int i=0;i<n*2;i++){\n    for(int j=0;j<(1<<(2*n));j++){\n      for(int k=0;k<10;k++){\n        if(!dp[i][j][k]) continue;\n        int next[10] = {};\n\n        for(int l=0;l<n;l++){\n          //1桁目\n          if((1 << (l*2)) & j){\n            for(int x=max(1,low[l]);x<=min(9, up[l]);x++)\n              next[x] |= 1 << (l*2+2);\n            for(int x=max(1,low[l]/10);x<=min(9,up[l]/10);x++)\n              next[x] |= 1 << (l*2+1);\n          }\n          //2桁目\n          if((1 << (l*2+1)) & j){\n            for(int x=max(0,(low[l]-k*10));x<=min(9, up[l]-k*10);x++)\n              next[x] |= 1 << (l*2+2);\n          }\n        }\n\n        for(int l=0;l<10;l++){\n          dp[i+1][next[l] & ((1 << n*2) - 1)][l] += dp[i][j][k];\n          if(next[l] & (1 << (n*2))) ans += dp[i][j][k];\n        }\n        \n      }\n    }\n  }\n  \n  cout << ans << endl;\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\nvector<int> HEAD[6];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\ttail_max[i] = max(tail_max[i],tmp);\n\t\t\t\ttail_min[i] = min(tail_min[i],tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\n\t\tHEAD[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()));\n\t}\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\tint tmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = tail_min[b_len]; tmp_B <= tail_max[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=int;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nint cnt[1000000];\nll _pow(ll a,ll n) {\n\tif(n==0) return 1;\n\tif(n==1) return 10;\n\tif(n==2) return 100;\n\tif(n==3) return 1000;\n\tif(n==4) return 10000;\n\tif(n==5) return 100000;\n\tif(n==6) return 1000000;\n}\n\nlong long solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tdp1[i][j]=false;\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tdp2[i-mid][j]=false;\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=0;\n\tll sum=0;\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nunordered_set<string> se;\nvector<string> vs1;\nvector<string> vs2;\nvector<pii> v1,v2;\nvoid foo1(int x,string y){\n\tif(x==v1.size()){\n\t\tvs1.PB(y);\n\t\treturn;\n\t}\n\treep(i,v1[x].F,v1[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo1(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid foo2(int x,string y){\n\tif(x==v2.size()){\n\t\tvs2.PB(y);\n\t\treturn;\n\t}\n\treep(i,v2[x].F,v2[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo2(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tse.clear();\n\t\tv1=vector<pii>(n/2);\n\t\tv2=vector<pii>(n-v1.size());\n\t\tvs1.clear();\n\t\tvs2.clear();\n\t\trep(i,n/2) cin>>v1[i].F>>v1[i].S;\n\t\trep(i,v2.size()) cin>>v2[i].F>>v2[i].S;\n\t\tfoo1(0,\"\");\n\t\tfoo2(0,\"\");\n\t\t// cout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\tsort(ALL(vs1));\n\t\tsort(ALL(vs2));\n\t\tvs1.erase(unique(ALL(vs1)),vs1.end());\n\t\tvs2.erase(unique(ALL(vs2)),vs2.end());\n\t\t// cout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\trep(i,vs1.size()){\n\t\t\trep(j,vs2.size()){\n\t\t\t\t// cout<<vs1[i]+vs2[j]<<endl;\n\t\t\t\tse.insert(vs1[i]+vs2[j]);\n\t\t\t}\n\t\t}\n\t\tcout<<se.size()<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<queue>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint getNum(char ch){\n\treturn ch-'0';\n}\n\nint toInt(string str){\n\tint res=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tres*=10;\n\t\tres+=(str[i]-'0');\n\t}\n\treturn res;\n}\n\nstruct PMA{\n\tstruct node{\n\t\tint nxt[10];\n\t\tint par;\n\t\tint parc;\n\t\tint fail;\n\t\tbool leaf;\n\t\tint d;\n\t\tnode(){\n\t\t\tfor(int i=0;i<10;i++) nxt[i]=-1;\n\t\t\tpar=-1;\n\t\t\tparc=-1;\n\t\t\td=0;\n\t\t\tfail=0;\n\t\t\tleaf=false;\n\t\t}\n\t};\n\tnode nodes[1000100];\n\tint c;\n\tint leafN;\n\tvoid init(){\n\t\tfor(int i=0;i<c;i++){\n\t\t\tnodes[i]=node();\n\t\t}\n\t\tc=1;\n\t\tleafN=0;\n\t}\n\tvoid add(string str){\n\t\tint cur=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tint n=getNum(str[i]);\n\t\t\tif(nodes[cur].nxt[n]==-1){\n\t\t\t\tnodes[cur].nxt[n]=c;\n\t\t\t\tnodes[c].par=cur;\n\t\t\t\tnodes[c].parc=n;\n\t\t\t\tnodes[c].d=nodes[cur].d+1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tcur=nodes[cur].nxt[n];\n\t\t}\n\t\tif(nodes[cur].leaf==false){\n\t\t\tnodes[cur].leaf=true;\n\t\t\tleafN++;\n\t\t}\n\t}\n\tvoid getFail(){\n\t\tqueue<int> que;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tif(nodes[0].nxt[i]!=-1){\n\t\t\t\tint v=nodes[0].nxt[i];\n\t\t\t\tnodes[v].fail=0;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint u=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tint v=nodes[u].nxt[i];\n\t\t\t\tif(v==-1) continue;\n\t\t\t\tque.push(v);\n\t\t\t\tint w=nodes[u].fail;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(w==0) break;\n\t\t\t\t\tif(nodes[w].nxt[i]!=-1) break;\n\t\t\t\t\tw=nodes[w].fail;\n\t\t\t\t}\n\t\t\t\tif(nodes[w].nxt[i]!=-1){\n\t\t\t\t\tnodes[v].fail=nodes[w].nxt[i];\n\t\t\t\t}else{\n\t\t\t\t\tnodes[v].fail=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid goUp(int* mp,int *mp2){\n\t\tfor(int i=0;i<c;i++){\n\t\t\tif(nodes[i].leaf){\n\t\t\t\tint v=i;\n\t\t\t\tstring str;\n\t\t\t\twhile(v!=0){\n\t\t\t\t\tint p=nodes[v].par;\n\t\t\t\t\tint num=nodes[v].parc;\n\t\t\t\t\tstring tmp;\n\t\t\t\t\ttmp+=('0'+num);\n\t\t\t\t\tstr=tmp+str;\n\t\t\t\t\tif(nodes[p].leaf){\n\t\t\t\t\t\tint a=toInt(str);\n\t\t\t\t\t\tmp[a]++;\n\t\t\t\t\t\tif(mp2[a]>0) break;\n\t\t\t\t\t}\n\t\t\t\t\tv=p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,string str,int* mp){\n\t//\tcout<<\"v=\"<<v<<\",str=\"<<str<<\"\\n\";\n\t//\tif(v==46){\n\t//\t\tcout<<\"v=46\"<<\" str=\"<<str<<\"\\n\";\n\t//\t}\n\t\tif(nodes[v].leaf){\n\t\t\tint f=nodes[v].fail;\n\t\t\twhile(f!=0){\n\t\t\t\tif(nodes[f].leaf){\n\t\t\t\t\tint dif=nodes[v].d-nodes[f].d;\n\t\t\t\t\tstring tmp=\"\";\n\t\t\t\t\tfor(int i=0;i<dif;i++) tmp+=str[i];\n\t\t\t\t\tmp[toInt(tmp)]++;\n\t\t\t\t}\n\t\t\t\tf=nodes[f].fail;\n//\t\t\t\tmp[toInt(tmp)]++;\n\t\t\t}/*\n\t\t\twhile(f!=0&&nodes[f].leaf==false) f=nodes[f].fail;\n\t\t\tif(f!=0){\n\t//\t\t\tcout<<\"leaf fail=\"<<f<<\"\\n\";\n\t\t\t\tint dif=nodes[v].d-nodes[f].d;\n\t\t\t\tstring tmp=\"\";\n\t\t\t//\tfor(int i=str.size()-dif;i<str.size();i++){\n\t\t\t\tfor(int i=0;i<dif;i++){\n\t\t\t\t\ttmp+=str[i];\n\t\t\t\t}\n\t\t\t\tmp[tmp]++;\n\t\t\t//\tif(tmp==\"1\"){\n\t\t\t//\t\tcout<<\"to fail:\\\"1\\\"\"<<str<<\"\\n\";\n\t\t\t//\t}\n\t\t\t//\tif(str==\"189\"){\n\t\t\t//\t\tcout<<v<<\"&\"<<nodes[v].fail<<\"\\n\";\n\t\t\t//\t}\n\t\t\t}*/\n\t\t}\n\t\tfor(int i=0;i<10;i++){\n\t\t\tif(nodes[v].nxt[i]==-1) continue;\n\t//\t\tcout<<\"move i=\"<<i<<\"\\n\";\n\t\t\tstring nxtS=str+(char)('0'+i);\n\t\t\tdfs(nodes[v].nxt[i],nxtS,mp);\n\t\t}\n\t}\n};\n\nPMA fi,se;\n/*\nmap<string,int> cntF,cntS;\n*/\n\nint cntF[1100100],cntS[1100100];\nvoid init(){\n\tfi.init();\n\tse.init();\n\t/*map<string,int> tmp;\n\tswap(cntF,tmp);\n\tmap<string,int> tmp2;\n\tswap(cntS,tmp2);\n\t*/\n\tfor(int i=0;i<1111;i++){\n\t\tcntF[i]=0;\n\t\tcntS[i]=0;\n\t}\n}\n\nint lo[6],hi[6];\n\nvoid dfs(int id,int n,string cur,PMA &p){\n\tif(id==n){\n\t//\tif(cur==\"89\"){\n\t//\t\tcout<<\"id===\"<<id<<\" \"<<n<<\"\\n\";\n\t//\t}\n\t\tp.add(cur);\n\t\treturn;\n\t}\n\tfor(int i=lo[id];i<=hi[id];i++){\n\t\tstringstream ss;\n\t\tss<<i;\n\t\tstring tmp;\n\t\tss>>tmp;\n\t\tdfs(id+1,n,cur+tmp,p);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d%d\",lo+i,hi+i);\n\t\t}\n\t\tif(N==1){\n\t\t\tprintf(\"%d\\n\",hi[0]-lo[0]+1);\n\t\t\tcontinue;\n\t\t}\n\t//\tprintf(\"a\\n\");\n\t\tdfs(0,N/2,\"\",fi);\n\t\tdfs(N/2,N,\"\",se);\n\t//\tprintf(\"b\\n\");\n\t\tse.getFail();\n\t//\tprintf(\"c\\n\");\n\t\tse.dfs(0,\"\",cntS);\n\t//\tprintf(\"d\\n\");\n\t\tfi.goUp(cntF,cntS);\n\t//\tprintf(\"e\\n\");\n\t\tlong long ans=(long long)(fi.leafN)*(se.leafN);/*\n\t\tmap<string,int>::iterator itF=cntF.begin(),itS=cntS.begin();\n\t\tfor(;itF!=cntF.end()&&itS!=cntS.end();){\n\t\t\tstring strF=itF->first;\n\t\t\tstring strS=itS->first;\n\t//\t\tcout<<itF->first<<\" \"<<itF->second<<\" \"<<itS->first<<\" \"<<itS->second<<\"\\n\";\n\t\t\tif(strF==strS){\n\t//\t\t\tcout<<itF->first<<\" \"<<itF->second<<\" \"<<itS->first<<\" \"<<itS->second<<\"\\n\";\n\t\t\t\tans-=(long long)(itF->second)*(itS->second);\n\t\t\t\titF++;\n\t\t\t\titS++;\n\t\t\t}else if(strF<strS){\n\t\t\t\titF++;\n\t\t\t}else{\n\t\t\t\titS++;\n\t\t\t}\n\t\t}*/\n\t\tfor(int i=0;i<=1000000;i++){\n\t\t\tans-=(long long)cntF[i]*cntS[i];\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t//\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n\nusing namespace std;\n\nllint n;\nllint l[6], r[6];\nbool can10[6][10], can1[6][10], can[6][10][10];\nllint dp[15][1<<13][10];\nllint nx[1<<13][10][10];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++) cin >> l[i] >> r[i];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tcan10[i][j] = can1[i][j] = false;\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tcan[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = l[i]; j <= r[i]; j++){\n\t\t\t\tif(j/10 > 0) can10[i][j/10] = true;\n\t\t\t\tif(j/10 > 0) can[i][j/10][j%10] = true;\n\t\t\t\tif(j <= 9) can1[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tllint S = 1 << (2*n+1);\n\t\tfor(int j = 0; j < S; j++){\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tfor(int l = 0; l < 10; l++){\n\t\t\t\t\tint nj = 0;\n\t\t\t\t\tfor(int m = 0; m < 2*n; m++){\n\t\t\t\t\t\tif((j & (1<<m)) == 0) continue;\n\t\t\t\t\t\tint p = (m+1)/2-1;\n\t\t\t\t\t\tif(m % 2 == 0){\n\t\t\t\t\t\t\tif(can10[p+1][l]) nj |= 1<<(m+1);\n\t\t\t\t\t\t\tif(can1[p+1][l]) nj |= 1<<(m+2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(can[p][k][l]) nj |= 1<<(m+1);\n\t\t\t\t\t}\n\t\t\t\t\tnx[j][k][l] = nj;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i <= 2*n; i++){\n\t\t\tfor(int j = 0; j < S; j++){\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0][1][0] = 1;\n\t\t\n\t\tfor(int i = 0; i < 2*n; i++){\n\t\t\tfor(int j = 0; j < S; j++){\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tfor(int l = 0; l < 10; l++){\n\t\t\t\t\t\tint nj = nx[j][k][l];\n\t\t\t\t\t\tdp[i+1][nj][l] += dp[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 1; i <= 2*n; i++){\n\t\t\tfor(int j = 0; j < S; j++){\n\t\t\t\tif((j & (1<<(2*n))) == 0) continue;\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tans += dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n, l[9], r[9]; long long dp[14][14][4104]; bool vis[14][14][4104];\nlong long solve(int digit, int last, int bit) {\n\tif (vis[digit][last][bit]) return dp[digit][last][bit];\n\tlong long ret = 0;\n\tif (bit & 2) ret = 1;\n\telse if ((bit & 1) && l[0] <= last && last <= r[0]) ret = 1;\n\tfor (int i = 0; i <= 9; i++) {\n\t\tint nbit = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (j != 0 && ((bit >> (2 * j)) & 1) && l[j] <= last && last <= r[j]) nbit |= 1 << (2 * j - 2);\n\t\t\tif (j != 0 && ((bit >> (2 * j + 1)) & 1)) nbit |= 1 << (2 * j - 2);\n\t\t\tif (i != 0 && ((bit >> (2 * j)) & 1) && l[j] <= i * 10 + last && i * 10 + last <= r[j]) nbit |= 1 << (2 * j + 1);\n\t\t}\n\t\tif (nbit != 0) ret += solve(digit + 1, i, nbit);\n\t}\n\tvis[digit][last][bit] = true;\n\tdp[digit][last][bit] = ret;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> l[i] >> r[i];\n\t\tfor (int i = 0; i <= 2 * n; i++) {\n\t\t\tfor (int j = 0; j <= 9; j++) {\n\t\t\t\tfor (int k = 0; k < 1 << (2 * n); k++) {\n\t\t\t\t\tvis[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret = 0;\n\t\tfor (int i = 0; i <= 9; i++) ret += solve(1, i, 1 << (2 * n - 2));\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[6],POW_10[6];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nmap<int,bool> TABLE[2];\nvector<int> num_list[2][NUM]; //長さ別の数字のリスト\n\n\nint get_length(int num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint S = 10;\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int len){\n\tnum /= POW_10[len-1];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length].push_back(num);\n\n\t\tif(type == A){\n\n\t\t\t//先頭から、1～tmp_length切り出す\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\tTABLE[A][substr_front(num,i)] = true;\n\t\t\t}\n\n\t\t}else{\n\n\t\t\t//末尾から、1～tmp_length切り出す\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\tTABLE[B][substr_tail(num,i)] = true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i].clear();\n\t\tnum_list[B][i].clear();\n\t}\n\n\tTABLE[A].clear();\n\tTABLE[B].clear();\n\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\t/*printf(\"A_MIN:%d A_MAX:%d B_MIN:%d B_MAX:%d\\n\",MIN_LEN[A],MAX_LEN[A],MIN_LEN[B],MAX_LEN[B]);\n\tprintf(\"\\nA\\n\");\n\tfor(int a_len = MIN_LEN[A]; a_len <= MAX_LEN[A]; a_len++){\n\t\tfor(int k = 0; k < num_list[A][a_len].size(); k++){\n\t\t\tprintf(\"%d\\n\",num_list[A][a_len][k]);\n\t\t}\n\t}\n\n\tprintf(\"\\n\\nB\\n\");\n\tfor(int b_len = MIN_LEN[B]; b_len <= MAX_LEN[B]; b_len++){\n\t\tfor(int k = 0; k < num_list[B][b_len].size(); k++){\n\t\t\tprintf(\"%d\\n\",num_list[B][b_len][k]);\n\t\t}\n\t}*/\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\t//for(int total_len = 7; total_len <= 7; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\t//printf(\"total:%d common:%d\\n\",total_len,common_part_len);\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min].size();\n\t\t\tll count_B = num_list[B][B_max].size();\n\n\t\t\tans += count_A*count_B;\n\n\t\t\t//printf(\"加算: %lld\\n\",count_A*count_B);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\t\t//printf(\"common_max %d\\n\",common_max);\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\t\t//for(int common_num = 0; common_num <= 0; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\t//printf(\"common_num:%d\\n\",common_num);\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = POW_10[a_len-1]; tmp_A < POW_10[a_len]; tmp_A++){\n\n\t\t\t\tauto first_at = TABLE[A].find(tmp_A);\n\t\t\t\tif(first_at == TABLE[A].end())continue;\n\n\t\t\t\t//printf(\"\\n\\ntmp_A:%d\\n\",tmp_A);\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\t//printf(\"state:%d\\n\",state);\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\t//printf(\"A\\n\");\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\t\t\tadd_A_len = common_part_len-loop;\n\t\t\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//printf(\"loop:%d add_A_len:%d\\n\",loop,add_A_len);\n\t\t\t\t\t\t\tpart_num = substr_front(common_num,add_A_len);\n\t\t\t\t\t\t\t//printf(\"part_num:%d\\n\",part_num);\n\n\t\t\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\t//printf(\"今回のstateは計上しない\\n\");\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//printf(\"tmp_num:%d 有り\\n\",tmp_num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[A][state] += 1;\n\t\t\t\t\t//printf(\"common:%d tmp_A:%d state:%d\\n\",common_num,tmp_A,state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//continue;\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = 0; tmp_B < POW_10[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\tauto first_at = TABLE[B].find(tmp_B);\n\t\t\t\tif(first_at == TABLE[B].end())continue;\n\n\t\t\t\t//printf(\"\\n\\ntmp_B:%d\\n\",tmp_B);\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\t\t\t\t\t\t\tadd_B_len = loop;\n\t\t\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\t\t\t\t\t\t\t//printf(\"add_B_len:%d part_num:%d\\n\",add_B_len,part_num);\n\n\t\t\t\t\t\t\tif(part_num < POW_10[common_part_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\t\t\t//printf(\"part:%dが%d以下なので不可\\n\",part_num,POW_10[common_part_len-1]);\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\t\t\t\t\t\t\t//printf(\"tmp_num:%d\\n\",tmp_num);\n\n\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//printf(\"%dあり\\n\",tmp_num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[B][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//printf(\"common_num:%d\\n\",common_num);\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\t\t\t\tnum_bit = 0;\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop))num_bit++;\n\t\t\t\t}\n\n\t\t\t\t//printf(\"state:%d num_bit:%d A:%d B:%d\\n\",state,num_bit,dp[A][state],dp[B][state]);\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 6; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int PW = 10;\nint pw[PW];\n\nconst int INF = 19191919;\n\nint n;\nint l[6],r[6];\nint A,B;\n\nvector<bool> va,vb;\nvector<bool> appear;\nint END;\nvoid dfs(int idx, int val){\n    if(idx == END){\n        appear[val] = true;\n        return;\n    }\n\n    for(int i=l[idx]; i<=r[idx]; ++i){\n        if(i<10) dfs(idx+1, val*10 + i);\n        else dfs(idx+1, val*100 + i);\n    }\n}\n\n\nconst int N = 1000000;\nint low_a[N][4], high_b[N][4], val_b[N][4];\n\nint main(){\n    pw[0] = 1;\n    for(int i=1; i<PW; ++i) pw[i] = pw[i-1]*10;\n\n    memset(low_a,-1,sizeof(low_a));\n    for(int i=1; i<N; ++i){\n        int tv = i;\n        int tmp = 0;\n        for(int j=1; j<=3; ++j){\n            tmp += (tv%10) * pw[j-1];\n            low_a[i][j] = tmp;\n            tv /= 10;\n            if(tv==0) break;\n        }\n    }\n\n    memset(high_b,-1,sizeof(high_b));\n    memset(val_b,-1,sizeof(val_b));\n    for(int i=1; i<N; ++i){\n        int tv = i;\n        vector<int> vv;\n        while(tv>0){\n            vv.pb(tv%10);\n            tv /= 10;\n        }\n        reverse(all(vv));\n        int VV = vv.size();\n\n        int tmp = 0;\n        for(int j=1; j<=min(3,VV); ++j){\n            tmp = tmp*10 + vv[j-1];\n            high_b[i][j] = tmp;\n\n            val_b[i][j] = 0;\n            for(int k=j; k<VV; ++k) val_b[i][j] = 10*val_b[i][j] + vv[k];\n        }\n        val_b[i][0] = i;\n    }\n\n    while(scanf(\" %d\", &n),n){\n        rep(i,n) scanf(\" %d %d\", &l[i], &r[i]);\n\n        A = n/2;\n        B = n-A;\n\n        appear = vector<bool>(N,false);\n        END = A;\n        dfs(0,0);\n        va = appear;\n\n        appear = vector<bool>(N,false);\n        END = A+B;\n        dfs(A,0);\n        vb = appear;\n\n        ll ans = 0;\n        for(int D=A+B; D<=2*(A+B); ++D){\n            // printf(\" ---- D  %d ----\\n\",D);\n            int W = min(D-(A+B), 2*(A+B)-D);\n\n            rep(i,pw[W]){\n                unordered_map<int,int> ppa,ppb;\n\n                // calc pata,patb\n                vector<int> pata(W+1),patb(W+1);\n                rep(j,W+1){\n                    patb[j] = -1;\n                    if(j>0){\n                        patb[j] = i%pw[j];\n\n                        // no leading zero\n                        int tmp = patb[j];\n                        rep(_,j-1) tmp /= 10;\n                        if(tmp%10==0) patb[j] = -INF;\n                    }\n\n                    pata[j] = -1;\n                    if(j<W) pata[j] = i/pw[j];\n                }\n\n                int DB = B-1;\n                int DA = D-DB;\n                while(DA>2*A+1){\n                    ++DB;\n                    --DA;\n                }\n\n                rep(j,W+1){\n                    ++DB;\n                    --DA;\n                    if(patb[j] == -INF) continue;\n                    // printf(\"CHECK (%d %d)  DA DB ( %d %d )  pat ( %d %d )\\n\",i,j,DA,DB,pata[j],patb[j]);\n                    // printf(\" ?? %d digits,  %d digits \\n\", DA-(W-j), DB - j);\n\n                    for(int k=pw[DA-(W-j)-1]; k<pw[DA-(W-j)]; ++k){\n                        int num =  k*pw[W-j];\n                        if(pata[j]>=0) num += pata[j];\n                        if(!va[num]) continue;\n\n                        // 下から W-j 桁\n                        if(pata[j]<0 || (pata[j] == low_a[num][W-j])){\n                            int val = num;\n                            if(j<W) val /= pw[W-j];\n                            // printf(\" ! MATCH  A ! %d ,  val %d\\n\", num,val);\n                            ppa[val] |= (1<<j);\n                        }\n                    }\n\n                    int st = pw[DB-j-1];\n                    if(st==1 || patb[j]>=0) st = 0;\n                    for(int k=st; k<pw[DB-j]; ++k){\n                        int num = k;\n                        if(patb[j]>=0) num += patb[j]*pw[DB-j];\n                        if(!vb[num]) continue;\n\n                        // 上から j 桁\n                        if(patb[j]<0 || (patb[j] == high_b[num][j])){\n                            // printf(\" ! MATCH  B ! %d ,  val %d\\n\", num,val_b[num][j]);\n                            ppb[val_b[num][j]] |= (1<<j);\n                        }\n                    }\n                }\n\n                if(!ppa.empty() && !ppb.empty()){\n                    vector<ll> cta(1<<(W+1)), ctb(1<<(W+1));\n                    for(const auto &p:ppa) ++cta[p.se];\n                    for(const auto &p:ppb) ++ctb[p.se];\n\n                    // 高速ゼータ変換\n                    rep(ii,W+1){\n                        rep(jj,1<<(W+1)){\n                            if((jj>>ii&1) == 0){\n                                cta[jj] += cta[jj|(1<<ii)];\n                                ctb[jj] += ctb[jj|(1<<ii)];\n                            }\n                        }\n                    }\n\n                    // 包除原理で数える\n                    for(int j=1; j<(1<<(W+1)); ++j){\n                        if(__builtin_popcount(j)%2==1) ans += cta[j]*ctb[j];\n                        else ans -= cta[j]*ctb[j];\n                    }\n                }\n            }\n            // dbg(ans);\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\thead_max[i] = max(head_max[i],tmp);\n\t\t\t\thead_min[i] = min(head_min[i],tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\ttail_max[i] = max(tail_max[i],tmp);\n\t\t\t\ttail_min[i] = min(tail_min[i],tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = head_min[a_len]; tmp_A <= head_max[a_len]; tmp_A++){\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = tail_min[b_len]; tmp_B <= tail_max[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<string>\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<stack>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;\nconst int SZ = 1 << 13;\nint g[13][10][2][10];\nLL dp[SZ][10];\nint n;\nvoid dfs(int bit, int val) {\n\tLL &ret = dp[bit][val];\n\tif (ret != -1)return;\n\tret = 0;\n\tconst int ed = 1 << (2 * n);\n\tif (bit&ed)ret++;\n\tREP(i, 10) {\n\t\tint nxtbit = 0;\n\t\tREP(j, 2 * n + 1) {\n\t\t\tif ((bit >> j) & 1) {\n\t\t\t\tif (g[j][val][0][i])nxtbit |= 1 << (j + 1);\n\t\t\t\tif (g[j][val][1][i])nxtbit |= 1 << (j + 2);\n\t\t\t}\n\t\t}\n\t\tif (nxtbit == 0)continue;\n\t\tdfs(nxtbit, i);\n\t\tret += dp[nxtbit][i];\n\t}\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tREP(i, SZ)REP(j, 10)dp[i][j] = -1;\n\t\tREP(i, 13)REP(j, 10)REP(k, 2)REP(l, 10)g[i][j][k][l] = 0;\n\t\tREP(i, n) {\n\t\t\tint x = i * 2;\n\t\t\tint y = x + 1;\n\t\t\tint z = x + 2;\n\t\t\tint lb, ub;\n\t\t\tcin >> lb >> ub;\n\t\t\tREP(j, 10) {\n\t\t\t\tif (lb <= j&&j <= ub) {\n\t\t\t\t\tREP(k, 10)g[x][k][1][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j, 10, 99) {\n\t\t\t\tif (lb <= j&&j <= ub) {\n\t\t\t\t\tREP(k, 10)g[x][k][0][j / 10] = 1;\n\t\t\t\t\tg[y][j / 10][0][j % 10] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(1, 0);\n\t\tcout << dp[1][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, A[7], B[7], dp[13][10][1 << 13];\n\nvoid init() {\n\tfor (int i = 0; i < 13; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tfor (int k = 0; k < (1 << 13); k++) dp[i][j][k] = -1;\n\t\t}\n\t}\n}\nlong long solve(int pos, int mae, int mask) {\n\tif (mask == 0) return 0;\n\tif (dp[pos][mae][mask] >= 0) return dp[pos][mae][mask];\n\n\tint bit[13]; for (int j = 0; j <= N * 2; j++) bit[j] = (mask / (1 << j)) % 2;\n\n\tlong long ans = 0;\n\tif (mask >= (1LL << (2 * N - 1)) && A[N - 1] <= mae && mae <= B[N - 1]) ans++;\n\telse if (mask >= (1LL << (2 * N))) ans++;\n\n\tfor (int i = 0; i < 10; i++) {\n\t\tint bit2[13]; for (int j = 0; j <= N * 2; j++) bit2[j] = 0;\n\n\t\tfor (int j = 0; j <= N * 2; j++) {\n\t\t\tif (bit[j] == 0) continue;\n\t\t\tint V1 = ((j - 1) >> 1), V2 = 0; if (j >= 1) V2 = ((j - 1) & 1) + 1; else V1 = 0;\n\n\t\t\tif (V2 == 0) {\n\t\t\t\tif (i >= 1 && i <= B[V1]) bit2[j + 1] = 1;\n\t\t\t}\n\t\t\telse if (V2 == 1) {\n\t\t\t\tif (A[V1] <= mae && i <= B[V1 + 1] && i >= 1) bit2[j + 2] = 1;\n\t\t\t\tif (A[V1] <= mae * 10 + i && mae * 10 + i <= B[V1]) bit2[j + 1] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i >= 1 && i <= B[V1 + 1]) bit2[j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tint F = 0; for (int j = 0; j <= N * 2; j++) F += (bit2[j] << j);\n\n\t\tans += solve(pos + 1, i, F);\n\t}\n\tdp[pos][mae][mask] = ans;\n\treturn ans;\n}\n\nint main() {\n\twhile (true) {\n\t\tinit();\n\t\tcin >> N; if (N == 0) break;\n\t\tfor (int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\n\t\tlong long ret = solve(0, 0, 1);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[6],POW_10[6];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nvector<int> num_list[2][NUM]; //長さ別の数字のリスト\n\nint get_length(int num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint S = 10;\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length].push_back(num);\n\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int len){\n\tnum /= POW_10[len-1];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i].clear();\n\t\tnum_list[B][i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min].size();\n\t\t\tll count_B = num_list[B][B_max].size();\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = MIN_LEN[A];\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = POW_10[a_len-1]; tmp_A < POW_10[a_len]; tmp_A++){\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\t\t\tadd_A_len = common_part_len-loop;\n\t\t\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_front(common_num,add_A_len);\n\n\t\t\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[A][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = MIN_LEN[B];\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = 0; tmp_B < POW_10[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tif(dp[A][state] == 0)continue;\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\t\t\t\t\t\t\tadd_B_len = loop;\n\t\t\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\t\t\tif(part_num < POW_10[common_part_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[B][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\t\t\t\tnum_bit = 0;\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop))num_bit++;\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 6; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\nvector<int> HEAD[NUM],TAIL[NUM];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\tTAIL[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\n\t\tHEAD[i].clear();\n\t\tTAIL[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()),HEAD[i].end());\n\n\t\tsort(TAIL[i].begin(),TAIL[i].end());\n\t\tTAIL[i].erase(unique(TAIL[i].begin(),TAIL[i].end()),TAIL[i].end());\n\t}\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\tint tmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int b = 0; b < TAIL[b_len].size(); b++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_B = TAIL[b_len][b];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<int> low(n), high(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> low[i] >> high[i];\n        }\n\n        // build NFA\n        const int fin = n * 4; // finish node\n        vector<vector<vector<int>>> nfa(n * 4 + 1, vector<vector<int>>(10));\n        for(int i = 0; i < n; ++i) {\n            if(low[i] < 10) { // Pi -> Pi+1\n                for(int x = low[i]; x <= min(9, high[i]); ++x) {\n                    nfa[i * 4][x].push_back(i * 4 + 4);\n                }\n            } else {\n                // Pi -> Qi -> Pi+1\n                nfa[i * 4][low[i] / 10].push_back(i * 4 + 1);\n                const int ub = low[i] / 10 == high[i] / 10 ? high[i] % 10 : 9;\n                for(int x = low[i] % 10; x <= ub; ++x) {\n                    nfa[i * 4 + 1][x].push_back(i * 4 + 4);\n                }\n            }\n            // Pi -> Ri -> Pi+1\n            for(int x = low[i] / 10 + 1; x < high[i] / 10; ++ x) {\n                nfa[i * 4][x].push_back(i * 4 + 2);\n            }\n            for(int x = 0; x <= 9; ++x) {\n                nfa[i * 4 + 2][x].push_back(i * 4 + 4);\n            }\n            if(high[i] >= 10) {// Pi -> Si -> Pi+1\n                nfa[i * 4][high[i] / 10].push_back(i * 4 + 3);\n                const int lb = low[i] / 10 == high[i] / 10 ? low[i] % 10 : 0;\n                for(int x = lb; x <= high[i] % 10; ++x) {\n                    nfa[i * 4 + 3][x].push_back(i * 4 + 4);\n                }\n            }\n        }\n\n        // build DFA\n        map<int, array<int, 10>> dfa;\n        {\n            queue<int> que;\n            que.push(1);\n            set<int> vis = {1};\n            while(!que.empty()) {\n                const int S = que.front();\n                que.pop();\n                for(int x = 0; x <= 9; ++x) {\n                    int nS = 0;\n                    for(int i = 0; i < 4 * n; ++i) {\n                        if(!(S & (1 << i))) continue;\n                        for(auto const to : nfa[i][x]) {\n                            nS |= 1 << to;\n                        }\n                    }\n                    dfa[S][x] = nS == 0 ? -1 : nS;\n                    if(nS == 0 || vis.count(nS)) continue;\n                    que.push(nS);\n                    vis.insert(nS);\n                }\n            }\n        }\n\n        map<int, ll> memo;\n        function<ll(int)> solve = [&] (int S) {\n            if(memo.count(S)) return memo[S];\n            if(S == (1 << fin)) return 1LL;\n            for(int x = 0; x <= 9; ++x) {\n                if(dfa[S][x] == -1) continue;\n                memo[S] += solve(dfa[S][x]);\n            }\n            if(S & (1 << fin)) {\n                memo[S] += 1;\n            }\n            return memo[S];\n        };\n\n        cout << solve(1) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nunordered_set<int> se;\nvector<string> vs1;\nvector<string> vs2;\nvector<pii> v1,v2;\nvoid foo1(int x,string y){\n\tif(x==v1.size()){\n\t\tvs1.PB(y);\n\t\treturn;\n\t}\n\treep(i,v1[x].F,v1[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo1(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid foo2(int x,string y){\n\tif(x==v2.size()){\n\t\tvs2.PB(y);\n\t\treturn;\n\t}\n\treep(i,v2[x].F,v2[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo2(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tse.clear();\n\t\tint a;\n\t\tint b;\n\t\tif(n==6){\n\t\t\ta=4;\n\t\t\tb=2;\n\t\t}\n\t\telse{\n\t\t\ta=n/2;\n\t\t\tb=n-a;\n\t\t}\n\t\tv1=vector<pii>(a);\n\t\tv2=vector<pii>(b);\n\t\tvs1.clear();\n\t\tvs2.clear();\n\t\trep(i,a) cin>>v1[i].F>>v1[i].S;\n\t\trep(i,b) cin>>v2[i].F>>v2[i].S;\n\t\tfoo1(0,\"\");\n\t\tfoo2(0,\"\");\n\t\t// cout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\tsort(ALL(vs1));\n\t\tsort(ALL(vs2));\n\t\tvs1.erase(unique(ALL(vs1)),vs1.end());\n\t\tvs2.erase(unique(ALL(vs2)),vs2.end());\n\t\t// cout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\trep(i,vs1.size()){\n\t\t\trep(j,vs2.size()){\n\t\t\t\tint t;\n\t\t\t\tconvert(vs1[i]+vs2[j],t);// cout<<vs1[i]+vs2[j]<<endl;\n\t\t\t\tse.insert(t);\n\t\t\t}\n\t\t}\n\t\tcout<<se.size()<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[6],POW_10[6];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nvector<int> num_list[2][NUM]; //長さ別の数字のリスト\n\nint get_length(int num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint S = 10;\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length].push_back(num);\n\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int len){\n\tnum /= POW_10[len-1];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i].clear();\n\t\tnum_list[B][i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\t/*printf(\"A_MIN:%d A_MAX:%d B_MIN:%d B_MAX:%d\\n\",MIN_LEN[A],MAX_LEN[A],MIN_LEN[B],MAX_LEN[B]);\n\tprintf(\"\\nA\\n\");\n\tfor(int a_len = MIN_LEN[A]; a_len <= MAX_LEN[A]; a_len++){\n\t\tfor(int k = 0; k < num_list[A][a_len].size(); k++){\n\t\t\tprintf(\"%d\\n\",num_list[A][a_len][k]);\n\t\t}\n\t}\n\n\tprintf(\"\\n\\nB\\n\");\n\tfor(int b_len = MIN_LEN[B]; b_len <= MAX_LEN[B]; b_len++){\n\t\tfor(int k = 0; k < num_list[B][b_len].size(); k++){\n\t\t\tprintf(\"%d\\n\",num_list[B][b_len][k]);\n\t\t}\n\t}*/\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\t//for(int total_len = 7; total_len <= 7; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\t//printf(\"total:%d common:%d\\n\",total_len,common_part_len);\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min].size();\n\t\t\tll count_B = num_list[B][B_max].size();\n\n\t\t\tans += count_A*count_B;\n\n\t\t\t//printf(\"加算: %lld\\n\",count_A*count_B);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\t\t//printf(\"common_max %d\\n\",common_max);\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\t\t//for(int common_num = 0; common_num <= 0; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\t//printf(\"common_num:%d\\n\",common_num);\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = POW_10[a_len-1]; tmp_A < POW_10[a_len]; tmp_A++){\n\n\t\t\t\t//printf(\"\\n\\ntmp_A:%d\\n\",tmp_A);\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\t//printf(\"state:%d\\n\",state);\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\t//printf(\"A\\n\");\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\t\t\tadd_A_len = common_part_len-loop;\n\t\t\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//printf(\"loop:%d add_A_len:%d\\n\",loop,add_A_len);\n\t\t\t\t\t\t\tpart_num = substr_front(common_num,add_A_len);\n\t\t\t\t\t\t\t//printf(\"part_num:%d\\n\",part_num);\n\n\t\t\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\t//printf(\"今回のstateは計上しない\\n\");\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//printf(\"tmp_num:%d 有り\\n\",tmp_num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[A][state] += 1;\n\t\t\t\t\t//printf(\"common:%d tmp_A:%d state:%d\\n\",common_num,tmp_A,state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//continue;\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = 0; tmp_B < POW_10[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\t//printf(\"\\n\\ntmp_B:%d\\n\",tmp_B);\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\t\t\t\t\t\t\tadd_B_len = loop;\n\t\t\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\t\t\t\t\t\t\t//printf(\"add_B_len:%d part_num:%d\\n\",add_B_len,part_num);\n\n\t\t\t\t\t\t\tif(part_num < POW_10[common_part_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\t\t\t//printf(\"part:%dが%d以下なので不可\\n\",part_num,POW_10[common_part_len-1]);\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\t\t\t\t\t\t\t//printf(\"tmp_num:%d\\n\",tmp_num);\n\n\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//printf(\"%dあり\\n\",tmp_num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[B][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//printf(\"common_num:%d\\n\",common_num);\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\t\t\t\tnum_bit = 0;\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop))num_bit++;\n\t\t\t\t}\n\n\t\t\t\t//printf(\"state:%d num_bit:%d A:%d B:%d\\n\",state,num_bit,dp[A][state],dp[B][state]);\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 6; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nint sbstr[1000000][6][7];\nint lgt[1000000];\nint pow_10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nint cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) sbstr[i][j][k]=stoi(s.substr(j,k));\n\t\t}\n\t\tlgt[i]=(int)s.length();\n\t}\n\tpow_10[0]=1;\n\tpow_10[1]=10;\n\tpow_10[2]=100;\n\tpow_10[3]=1000;\n\tpow_10[4]=10000;\n\tpow_10[5]=100000;\n\treturn;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp1[i+1][sbstr[j][1][lgt[j]-1]]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp1[i+1][sbstr[j][2][lgt[j]-2]]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp2[i+1-mid][sbstr[j][1][lgt[j]-1]]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp2[i+1-mid][sbstr[j][2][lgt[j]-2]]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow_10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow_10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbstr[i][0][j]]&&sbstr[i][j][1]!=0)  {\n\t\t\t\tret-=cnt[sbstr[i][j][lgt[i]-j]];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n#define to_string to_s\n#define stol to_ll\nstring buf=\"\";\nvector<vector<bool>> dp1(3,vector<bool>(1000000,false));\nvector<vector<bool>> dp2(3,vector<bool>(1000000,false));\n\nstring to_s(ll n){\n\tstring ret;\n\twhile(n>0){\n\t\tret+=n%10 +'0';\n\t\tn/=10;\n\t}\n\treverse(ALL(ret));\n\treturn ret;\n}\n\nll to_ll(string s){\n\tll ret=0;\n\tREP(i,s.size()){\n\t\tret*=10;\n\t\tret+=s[i]-'0';\t\n\t}\n\treturn ret;\n}\nll _pow(ll a,ll n) {\n\tif(n==0) return 1;\n\tif(n==1) return 10;\n\tif(n==2) return 100;\n\tif(n==3) return 1000;\n\tif(n==4) return 10000;\n\tif(n==5) return 100000;\n\tif(n==6) return 1000000;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tdp1[i][j]=false;\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tdp2[i-mid][j]=false;\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tvector<ll> cnt(1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll sbstr[1000000][6][7];\nll lgt[1000000];\nll pow_10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nll cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) sbstr[i][j][k]=stol(s.substr(j,k));\n\t\t}\n\t\tlgt[i]=(ll)s.length();\n\t}\n\tpow_10[0]=1;\n\tpow_10[1]=10;\n\tpow_10[2]=100;\n\tpow_10[3]=1000;\n\tpow_10[4]=10000;\n\tpow_10[5]=100000;\n\treturn;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp1[i+1][sbstr[j][1][lgt[j]-1]]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp1[i+1][sbstr[j][2][lgt[j]-2]]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp2[i+1-mid][sbstr[j][1][lgt[j]-1]]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp2[i+1-mid][sbstr[j][2][lgt[j]-2]]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow_10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow_10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbstr[i][0][j]]&&sbstr[i][j][1]!=0)  {\n\t\t\t\tret-=cnt[sbstr[i][j][lgt[i]-j]];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint l[7],h[7] ={};\nint N;\nstruct Condition{\n\tint finished;\n\tint unprocessed;\n\tint lb,ub;\n};\n\nbool operator < (const Condition &a,const Condition &b){\n\treturn \tarray<int,4>{a.finished,a.unprocessed,a.lb,a.ub} < \n\t\t\tarray<int,4>{b.finished,b.unprocessed,b.lb,b.ub};\n}\ntypedef set<Condition> Conditions;\n\nConditions trans(Condition c,int d){\n\tif( c.finished == N ) return {};\n\tif( c.unprocessed != -1 ){\n\t\tif( d < c.lb or d > c.ub ) return {};\n\t\tc.unprocessed = -1;\n\t\tc.finished++;\n\t\tc.lb = l[c.finished];\n\t\tc.ub = h[c.finished];\n\t\treturn {c};\n\t}else{\n\t\tConditions res;\n\t\tif( c.ub >= 10 ){\n\t\t\tif( max(1,c.lb / 10) <= d and d <= c.ub / 10 ){\n\t\t\t\tauto cpy = c;\n\t\t\t\tcpy.unprocessed = cpy.finished;\n\t\t\t\t\n\t\t\t\tcpy.lb = 0;\n\t\t\t\tcpy.ub = 9;\n\t\t\t\tif( c.lb / 10 == d ){\n\t\t\t\t\tcpy.lb = c.lb % 10;\n\t\t\t\t}\n\t\t\t\tif( c.ub / 10 == d ){\n\t\t\t\t\tcpy.ub = c.ub % 10;\n\t\t\t\t}\n\t\t\t\tres.insert(cpy);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif( c.lb <= d and d <= c.ub ){\n\t\t\tauto cpy = c;\n\t\t\tcpy.unprocessed = -1;\n\t\t\tcpy.finished++;\n\t\t\tcpy.lb = l[cpy.finished];\n\t\t\tcpy.ub = h[cpy.finished];\n\t\t\tres.insert(cpy);\n\t\t}\n\t\treturn res;\n\t}\n}\nmap<Conditions, long long> memo;\nlong long dfs(Conditions c){\t\n\tif( c.size() == 0 ) return 0;\n\tif( memo.count(c) ) return memo[c];\n\n\tlong long ans = 0;\n\tfor( auto e : c ){\n\t\tif( N == e.finished ) ans = 1;\n\t}\n\tfor(int i = 0 ; i <= 9 ; i++){\n\t\tConditions nc;\n\t\tfor( auto e : c ){\n\t\t\tauto tmp = trans(e,i);\n\t\t\tnc.insert(tmp.begin(),tmp.end());\n\t\t}\n\t\tans += dfs(nc);\n\t}\n\treturn memo[c] = ans;\n}\nint main(){\n\t\n\twhile(cin >> N&&N){\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tcin >> l[i] >> h[i];\n\t\t}\n\t\tcout << dfs({Condition{0,-1,l[0],h[0]}}) << endl;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\thead_max[i] = max(head_max[i],tmp);\n\t\t\t\thead_min[i] = min(head_min[i],tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\ttail_max[i] = max(tail_max[i],tmp);\n\t\t\t\ttail_min[i] = min(tail_min[i],tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = head_min[a_len]; tmp_A <= head_max[a_len]; tmp_A++){\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = tail_min[b_len]; tmp_B <= tail_max[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef long long LL;\ntypedef array<int,10> ai10;\n\nstruct info{\n\tint cnt;\n\tLL val;\n\tai10 to;\n\t\n\tinfo() : cnt{}, val{}, to{} {}\n};\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> low(n), high(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d\", &low[i], &high[i]);\n\t\t}\n\t\t\n\t\tvector<ai10> to(4 * n + 1);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < 10; ++j){\n\t\t\t\tto[i * 4 + 2][j] |= 1 << (i * 4 + 4);\n\t\t\t}\n\t\t\n\t\t\tint ld = (low[i] + 9) / 10 * 10;\n\t\t\tint hd = high[i] / 10 * 10;\n\t\t\tfor(int j = ld; j < hd; j += 10){\n\t\t\t\tto[i * 4][j / 10] |= 1 << (i * 4 + 2);\n\t\t\t}\n\t\t\tfor(int j = min(ld - 1, high[i]); j >= low[i]; --j){\n\t\t\t\tint s;\n\t\t\t\tif(j < 10){\n\t\t\t\t\ts = i * 4;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts = i * 4 + 1;\n\t\t\t\t\tto[i * 4][j / 10] |= 1 << s;\n\t\t\t\t}\n\t\t\t\tto[s][j % 10] |= 1 << (i * 4 + 4);\n\t\t\t}\n\t\t\tfor(int j = max(hd, low[i]); j <= high[i]; ++j){\n\t\t\t\tint s;\n\t\t\t\tif(j < 10){\n\t\t\t\t\ts = i * 4;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts = i * 4 + 3;\n\t\t\t\t\tto[i * 4][j / 10] |= 1 << s;\n\t\t\t\t}\n\t\t\t\tto[s][j % 10] |= 1 << (i * 4 + 4);\n\t\t\t}\n\t\t}\n\n\t\tmap<int,info> mp;\n\t\tmp[0].cnt = 1010101010;\n\t\tmp[1].val = 1;\n\t\tqueue<int> q;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint s = q.front();\n\t\t\tinfo &in = mp[s];\n\t\t\tq.pop();\n\t\t\tfor(int d = 0; d < 10; ++d){\n\t\t\t\tint t = 0;\n\t\t\t\tfor(size_t i = 0; i < to.size(); ++i){\n\t\t\t\t\tif(s >> i & 1){\n\t\t\t\t\t\tt |= to[i][d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tin.to[d] = t;\n\t\t\t\tif(++mp[t].cnt == 1){\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLL ans = 0;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint s = q.front();\n\t\t\tq.pop();\n\t\t\tinfo &in1 = mp[s];\n\t\t\t\n\t\t\tif(s >> (n * 4) & 1){\n\t\t\t\tans += in1.val;\n\t\t\t}\n\t\t\tfor(int d = 0; d < 10; ++d){\n\t\t\t\tinfo &in2 = mp[in1.to[d]];\n\t\t\t\tin2.val += in1.val;\n\t\t\t\tif(--in2.cnt == 0){\n\t\t\t\t\tq.push(in1.to[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> low(n), high(n);\n        for(int i=0; i<n; ++i)\n            cin >> low[i] >> high[i];\n\n        map<pair<int, int>, long long> m;\n        m[make_pair(0, 1)] = 1;\n        long long ans = 0;\n        while(!m.empty()){\n            map<pair<int, int>, long long> m2;\n            for(const auto& p : m){\n                int prev = p.first.first;\n                bitset<32> bs = p.first.second;\n\n                for(int a=0; a<=9; ++a){\n                    bitset<32> bs2;\n                    for(int i=0; i<n; ++i){\n                        if(bs[2*i]){\n                            if(0 < a)\n                                bs2[2*i+1] = true;\n                            if(low[i] <= a && a <= high[i])\n                                bs2[2*(i+1)] = true;\n                        }\n                        if(bs[2*i+1]){\n                            int x = prev * 10 + a;\n                            if(low[i] <= x && x <= high[i])\n                                bs2[2*(i+1)] = true;\n                        }\n                    }\n                    if(bs2[2*n]){\n                        ans += p.second;\n                        bs2[2*n] = false;\n                    }\n\n                    if(bs2.any())\n                        m2[make_pair(a, bs2.to_ulong())] += p.second;\n                }\n            }\n            m.swap(m2);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct DFA{\n\tint Q;//state\n\tint A; //alphabet\n\tvector<vector<int> > t;\n\tint q0;\n\tvector<int> F;\n\tDFA(){}\n\tDFA(int Q,int A,vector<vector<int> > t,int q0,vector<int> F):Q(Q),A(A),t(t),q0(q0),F(F){}\n};\n\nstruct NFA{\n\tint Q;\n\tint A;\n\tvector<vector<vector<int> > > t;\n\tint q0;\n\tvector<int> F;\n\tNFA(int Q,int A,vector<vector<vector<int> > > t,int q0,vector<int> F): Q(Q),A(A),t(t),q0(q0),F(F){}\n\tDFA NFAtoDFA(){\n\t\tint DN=1;\n\t\tvector<vector<int> > dt(1,vector<int>(A,0));\n\t\tvector<int> DF;\n\t\tmap<vector<int>, int> mp; //sets->id\n\t\tqueue<vector<int> > que;\n\t\tque.push(vector<int>{q0});\n\t\tmp[vector<int>{q0}]=0;\n\t\twhile(que.size()){\n\t\t\tvector<int> vc=que.front();\n\t\t\tque.pop();\n\t\t\tbool flag=false;\n\t\t\tfor(int i=0;i<F.size();i++){\n\t\t\t\tfor(int j=0;j<vc.size();j++){\n\t\t\t\t\tif(F[i]==vc[j])flag=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tDF.push_back(mp[vc]);\n\t\t\t}\n\t\t\tfor(int i=0;i<A;i++){\n\t\t\t\tvector<int> nvc;\n\t\t\t\tfor(int j=0;j<vc.size();j++){\n\t\t\t\t\tfor(int k=0;k<t[vc[j]][i].size();k++){\n\t\t\t\t\t\tnvc.push_back(t[vc[j]][i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(nvc.begin(),nvc.end());\n\t\t\t\tnvc.erase(unique(nvc.begin(),nvc.end()),nvc.end());\n\t\t\t\tif(!mp.count(nvc)){\n\t\t\t\t\tmp[nvc]=DN++;\n\t\t\t\t\tdt.push_back(vector<int>(A,0));\n\t\t\t\t\tque.push(nvc);\n\t\t\t\t}\n\t\t\t\tdt[mp[vc]][i]=mp[nvc];\n\t\t\t}\n\t\t}\n\t\treturn DFA(mp.size(),A,dt,0,DF);\n\t}\n};\n\nint n;\nint a[6],b[6];\nll dp[1005];\nbool visited[1005];\nvector<int> vc;\nDFA M;\n\nvoid dfs(int v){\n\tvisited[v]=true;\n\tfor(int i=0;i<10;i++){\n\t\tif(!visited[M.t[v][i]]){\n\t\t\tdfs(M.t[v][i]);\n\t\t}\n\t}\n\tvc.push_back(v);\n}\n\nvoid solve(){\n\tint Q=4*n+1;\n\tint A=10,q0=0;\n\tvector<int> F;\n\tF.push_back(4*n);\n\tvector<vector<vector<int> > > t(Q,vector<vector<int> >(A,vector<int>{}));\n\tfor(int i=0;i<n;i++){\n\t\tint x=a[i]/10;\n\t\tint y=b[i]/10;\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(a[i]<=j && j<=b[i]){\n\t\t\t\tt[4*i][j].push_back(4*i+4);\n\t\t\t}\n\t\t}\n\t\tif(x>0){\n\t\t\tt[4*i][x].push_back(4*i+1);\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif(a[i]<=x*10+j &&x*10+j<=b[i]){\n\t\t\t\t\tt[4*i+1][j].push_back(4*i+4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x+1<y){\n\t\t\tfor(int j=x+1;j<y;j++){\n\t\t\t\tt[4*i][j].push_back(4*i+2);\n\t\t\t}\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tt[4*i+2][j].push_back(4*i+4);\n\t\t\t}\n\t\t}\n\t\tif(x<y){\n\t\t\tt[4*i][y].push_back(4*i+3);\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif(a[i]<=y*10+j&& y*10+j<=b[i]){\n\t\t\t\t\tt[4*i+3][j].push_back(4*i+4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tM=NFA(Q,A,t,q0,F).NFAtoDFA();\n\tqueue<int> que;\n\tn=M.Q;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=0;\n\t\tvisited[i]=false;\n\t}\n\tdp[M.q0]=1;\n\tvc.clear();\n\tdfs(M.q0);\n\treverse(vc.begin(),vc.end());\n\tfor(int i=0;i<vc.size();i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tdp[M.t[vc[i]][j]]+=dp[vc[i]];\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0;i<M.F.size();i++){\n\t\tans+=dp[M.F[i]];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\t}\n\t\tsolve();\n\t\t\n\t}\n\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\nstruct DFA{\n\tint Q;\t\t//state\n\tint A;\t\t//alphabet\n\tvector<vi> t;\n\tint q0;\n\tvi F;\n\tDFA(){}\n\tDFA(int Q,int A,vector<vi> t,int q0,vi F) :Q(Q),A(A),t(t),q0(q0),F(F){}\n};\nstruct NFA{\n\tint Q;\n\tint A;\n\tvector<vector<vi> > t;\n\tint q0;\n\tvi F;\n\tNFA(int Q,int A,vector<vector<vi> >t,int q0,vi F) :Q(Q),A(A),t(t),q0(q0),F(F){}\n\tDFA NFAtoDFA(){\n\t\tint DN=1;\n\t\tvector<vi> dt(1,vi(A,0));\n\t\tvi DF;\n\t\tmap<vi,int> mp;\t\t//sets->id\n\t\tqueue<vi> que;\n\t\tque.push(vi{q0});\n\t\tmp[vi{q0}]=0;\n\t\twhile(!que.empty()){\n\t\t\tvi vc=que.front();que.pop();\n\t\t\tbool isF=0;\n\t\t\tfor(int f:F) for(int v:vc) if(f==v) isF=1;\n\t\t\tif(isF) DF.pb(mp[vc]);\n\t\t\trep(i,A){\n\t\t\t\tvi nvc;\n\t\t\t\tfor(int v:vc){\n\t\t\t\t\tfor(int u:t[v][i]) nvc.pb(u);\n\t\t\t\t}\n\t\t\t\tsort(all(nvc));nvc.erase(unique(all(nvc)),nvc.end());\n\t\t\t\tif(!mp.count(nvc)){\n\t\t\t\t\tmp[nvc]=DN++;\n\t\t\t\t\tdt.pb(vi(A,0));\n\t\t\t\t\tque.push(nvc);\n\t\t\t\t}\n\t\t\t\tdt[mp[vc]][i]=mp[nvc];\n\t\t\t}\n\t\t}\n\t\treturn DFA(mp.size(),A,dt,0,DF);\n\t}\n};\n\ntypedef long long ll;\nll dp[1000];\nbool vis[1000];\nvector<int> vc;\nDFA M;\nvoid dfs(int v){\n\tvis[v]=1;\n\trep(i,10) if(!vis[M.t[v][i]]) dfs(M.t[v][i]);\n\tvc.pb(v);\n}\nint main(){\n\twhile(true){\n\t\tint N,a[6],b[6];\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>a[i]>>b[i];\n\t\tint Q=4*N+1,A=10,q0=0;\n\t\tvector<int> F;\n\t\tF.pb(4*N);\n\t\tvector<vector<vi> > t(Q,vector<vi>(A,vi{}));\n\t\trep(i,N){\n\t\t\tint x=a[i]/10,y=b[i]/10;\n\t\t\trep(j,10){\n\t\t\t\tif(a[i]<=j&&j<=b[i]) t[4*i][j].pb(4*i+4);\n\t\t\t}\n\t\t\tif(x>0){\n\t\t\t\tt[4*i][x].pb(4*i+1);\n\t\t\t\trep(j,10) if(a[i]<=x*10+j&&x*10+j<=b[i]) t[4*i+1][j].pb(4*i+4);\n\t\t\t}\n\t\t\tif(x+1<y){\n\t\t\t\tfor(int j=x+1;j<y;j++) t[4*i][j].pb(4*i+2);\n\t\t\t\trep(j,10) t[4*i+2][j].pb(4*i+4);\n\t\t\t}\n\t\t\tif(x<y){\n\t\t\t\tt[4*i][y].pb(4*i+3);\n\t\t\t\trep(j,10) if(a[i]<=y*10+j&&y*10+j<=b[i]) t[4*i+3][j].pb(4*i+4);\n\t\t\t}\n\t\t}\n\t\tM=NFA(Q,A,t,q0,F).NFAtoDFA();\n\t\tqueue<int> que;\n\t\tN=M.Q;\n\t\trep(i,N) dp[i]=0,vis[i]=0;\n\t\tdp[M.q0]=1;\n\t\tvc.clear();\n\t\tdfs(M.q0);\n\t\treverse(all(vc));\n\t\tfor(int v:vc){\n\t\t\trep(i,10) dp[M.t[v][i]]+=dp[v];\n\t\t}\n\t\tll ans=0;\n\t\tfor(int f:M.F) ans+=dp[f];\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\thead_max[i] = max(head_max[i],tmp);\n\t\t\t\thead_min[i] = min(head_min[i],tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\ttail_max[i] = max(tail_max[i],tmp);\n\t\t\t\ttail_min[i] = min(tail_min[i],tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = head_min[a_len]; tmp_A <= head_max[a_len]; tmp_A++){\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = tail_min[b_len]; tmp_B <= tail_max[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define double long double\ndouble PI = acos(-1);\ndouble l[8];\n\ndouble f(double t0,vector<double> L){\n\tdouble v = cos(t0) * L[0] * L[1];\n\tdouble sum = 0;\n\tfor(int i = 0 ; i < L.size() - 1 ; i++){\n\t\t\n\t\t//cout << v / L[i] / L[i+1] << endl;\n\t\tsum += acos(v / L[i] / L[i+1]);\n\t}\n\treturn sum;\n}\ndouble calc(double t0,vector<double> L){\n\tdouble v = cos(t0) * L[0] * L[1];\n\tdouble sum = 0;\n\tfor(int i = 0 ; i < L.size() - 1 ; i++){\n\t\tsum += sin(acos(v / L[i] / L[i+1])) * L[i] * L[i+1] / 2.0;\n\t}\n\treturn sum;\n}\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++) cin >> l[i];\n\t\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < (1<<N) ; i++){\n\t\tvector<double> L;\n\t\tfor(int j = 0 ; j < N ; j++)\n\t\t\tif( i >> j & 1 ) L.push_back(l[j]);\n\t\tif( L.size() < 3 ) continue;\n\t\tsort(L.begin(),L.end());\n\t\tdo{\n\t\t\tL.push_back(L.front());\n\t\t\t\n\t\t\tdouble le = 0 , ri = PI;\n\t\t\tfor(int k = 0 ; k < 80 ; k++){\n\t\t\t\tdouble mi = (le+ri) / 2.;\n\t\t\t\tif( f(mi,L) > 2 * PI ){\n\t\t\t\t\tri = mi;\n\t\t\t\t}else{\n\t\t\t\t\tle = mi;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,calc(le,L));\n\t\t\tL.pop_back();\n\t\t}while(next_permutation(L.begin(),L.end()));\n\t\t// cout << L.size() << \"|\" <<  f(2*PI/6,L) << endl;\n\t}\n\tprintf(\"%.10Lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 6;\nconstexpr int MAX_V = 4 * MAX_N + 1;\n\nenum { L = 1, M = 2, H = 3, N = 4 };\n\nint n;\nint low[MAX_N], high[MAX_N];\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n && n) {\n\t\tconst int V = 4 * n + 1;\n\n\t\t// construct NFA\n\t\tvector<unordered_map<int, int>> G_nfa(V);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int v = 4 * i;\n\n\t\t\tcin >> low[i] >> high[i];\n\n\t\t\tconst int low_f = low[i] / 10;\n\t\t\tconst int low_s = low[i] % 10;\n\t\t\tconst int high_f = high[i] / 10;\n\t\t\tconst int high_s = high[i] % 10;\n\n\t\t\tconst int l_from = (low_f ? v + L : v);\n\n\t\t\tif(low_f) G_nfa[v][low_f] |= (1 << (v + L));\n\n\t\t\tif(low_f == high_f) {\n\t\t\t\tfor(int j = low_s; j <= high_s; ++j) {\n\t\t\t\t\tG_nfa[l_from][j] |= (1 << (v + N));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG_nfa[v][high_f] |= (1 << (v + H));\n\n\t\t\t\tfor(int j = low_s; j < 10; ++j) {\n\t\t\t\t\tG_nfa[l_from][j] |= (1 << (v + N));\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j <= high_s; ++j) {\n\t\t\t\t\tG_nfa[v + H][j] |= (1 << (v + N));\n\t\t\t\t}\n\n\t\t\t\tif(low_f + 1 < high_f) {\n\t\t\t\t\tfor(int j = low_f + 1; j < high_f; ++j) {\n\t\t\t\t\t\tG_nfa[v][j] |= (1 << (v + M));\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 10; ++j) {\n\t\t\t\t\t\tG_nfa[v + M][j] |= (1 << (v + N));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// construct DFA and topological sort\n\t\tunordered_map<int, unordered_map<int, int>> G_dfa;\n\t\tunordered_map<int, int> in;\n\t\tqueue<int> que;\n\t\tque.push(1);\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int state = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(int i = state; i > 0; i -= i & -i) {\n\t\t\t\tconst int v = __builtin_ctz(i & -i);\n\n\t\t\t\tfor(const auto &e : G_nfa[v]) {\n\t\t\t\t\tG_dfa[state][e.first] |= e.second;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(const auto &e : G_dfa[state]) {\n\t\t\t\tconst int to_state = e.second;\n\n\t\t\t\tif(++in[to_state] == 1) {\n\t\t\t\t\tque.push(to_state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// dp\n\t\tconst int accept_state = (1 << 4 * n);\n\n\t\tlong long ans = 0;\n\t\tunordered_map<int, long long> dp;\n\n\t\tdp[1] = 1;\n\t\tque.push(1);\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int state = que.front();\n\t\t\tque.pop();\n\n\t\t\tif(state & accept_state) {\n\t\t\t\tans += dp[state];\n\t\t\t}\n\n\t\t\tfor(const auto &e : G_dfa[state]) {\n\t\t\t\tconst int to_state = e.second;\n\t\t\t\tdp[to_state] += dp[state];\n\n\t\t\t\tif(--in[to_state] == 0) {\n\t\t\t\t\tque.push(to_state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct TopologicalSort{\n  Int n;\n  vector<set<Int> > G;\n  vector<bool> used;\n  vector<Int> indeg,p;\n  \n  TopologicalSort(){}\n  TopologicalSort(Int sz):n(sz),G(n),used(n),indeg(n),p(0){}\n\n  void add_edge(Int s,Int t){\n    G[s].insert(t);\n  }\n  \n  void bfs(Int s){\n    queue<Int> q;\n    q.push(s);\n    used[s]=1;\n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      p.push_back(v);\n      for(Int u:G[v]){\n        indeg[u]--;\n        if(indeg[u]==0&&!used[u]){\n          used[u]=1;\n          q.push(u);\n        }\n      }\n    }\n  }\n  \n  vector<Int>  build(){\n    fill(used.begin(),used.end(),0);\n    fill(indeg.begin(),indeg.end(),0);\n    \n    for(Int i=0;i<n;i++)\n      for(Int v:G[i]) indeg[v]++;\n    \n    for(Int i=0;i<n;i++)\n      if(indeg[i]==0&&!used[i]) bfs(i);\n    \n    return p;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<Int> ls(n+1),hs(n+1);\n    for(Int i=1;i<=n;i++) cin>>ls[i]>>hs[i];\n\n    vector<Int> as(n+1),bs(n+1);\n    vector<Int> a0(n+1),b0(n+1);\n    vector<Int> a1(n+1),b1(n+1);\n    vector<Int> a2(n+1),b2(n+1);\n    for(Int i=1;i<=n;i++){\n      a0[i]=ls[i]%10;\n      b0[i]=10;\n      if((ls[i]/10)==(hs[i]/10)) b0[i]=hs[i]%10+1;\n    \n      a1[i]=0;\n      b1[i]=10;    \n      a2[i]=0;\n      b2[i]=hs[i]%10+1;\n       \n      if(ls[i]>=10){\n        as[i]=10;bs[i]=-1;\n        continue;\n      }\n      as[i]=ls[i];\n      if(hs[i]>=10) bs[i]=10;\n      else bs[i]=hs[i]+1;\n    }\n\n    auto calc=[&](Int k,Int p){return k*7+p;};  \n    Int G[100][10]={};  \n    for(Int i=1;i<=n;i++){\n    \n      for(Int c=0;c<10;c++){\n        if(a0[i]<=c&&c<b0[i])\n          G[calc(i,0)][c]|=1LL<<calc(i,3);\n        if(a1[i]<=c&&c<b1[i])\n          G[calc(i,1)][c]|=1LL<<calc(i,4);\n        if(a2[i]<=c&&c<b2[i])\n          G[calc(i,2)][c]|=1LL<<calc(i,5);\n      }    \n    \n      if(i+1<=n){\n        for(Int j=3;j<7;j++){\n          for(Int c=0;c<10;c++){\n            Int x=ls[i+1]/10;\n            Int y=hs[i+1]/10;\n        \n            if(c==x&&x!=0)\n              G[calc(i,j)][c]|=1LL<<calc(i+1,0);\n\n            if(x<c&&c<y)\n              G[calc(i,j)][c]|=1LL<<calc(i+1,1);\n        \n            if(x!=y&&c==y&&y!=0)\n              G[calc(i,j)][c]|=1LL<<calc(i+1,2);\n        \n            if(as[i+1]<=c&&c<bs[i+1])\n              G[calc(i,j)][c]|=1LL<<calc(i+1,6);\n          }\n        }\n      }\n    }\n    \n    for(Int c=0;c<10;c++){\n      Int x=ls[1]/10;\n      Int y=hs[1]/10;\n        \n      if(c==x&&x!=0)\n        G[0][c]|=1LL<<calc(1,0);\n\n      if(x<c&&c<y)\n        G[0][c]|=1LL<<calc(1,1);\n        \n      if(x!=y&&c==y&&y!=0)\n        G[0][c]|=1LL<<calc(1,2);\n        \n      if(as[1]<=c&&c<bs[1])\n        G[0][c]|=1LL<<calc(1,6);\n    }\n     \n    vector<Int> rev;\n    map<Int, Int> idx;  \n    idx[1]=rev.size();\n    rev.emplace_back(1);\n  \n    TopologicalSort ts(1000);\n    set<Int> used;\n    queue<Int> que;\n    used.emplace(1);\n    que.emplace(1);\n    while(!que.empty()){\n      Int bit=que.front();que.pop();\n      for(Int c=0;c<10;c++){\n        Int nxt=0;\n        for(Int i=0;i<60;i++)\n          if((bit>>i)&1) nxt|=G[i][c];      \n        if(nxt==0) continue;\n        if(!idx.count(nxt)){\n          idx[nxt]=rev.size();\n          rev.emplace_back(nxt);\n        }\n        ts.add_edge(idx[bit],idx[nxt]);\n        if(used.count(nxt)) continue;\n        used.emplace(nxt);        \n        que.emplace(nxt);\n      }\n    }\n    //cout<<\"sz:\"<<rev.size()<<endl;\n\n    vector<Int> ord=ts.build();  \n    vector<Int> dp(ts.G.size(),0);\n    dp[0]=1;  \n    for(Int x:ord){\n      if(x>=(Int)rev.size()) continue;\n      //cout<<x<<\":\"<<dp[x]<<endl;\n      \n      Int bit=rev[x];    \n      for(Int c=0;c<10;c++){\n        Int nxt=0;\n        for(Int i=0;i<60;i++)\n          if((bit>>i)&1) nxt|=G[i][c];      \n        if(nxt==0) continue;\n        \n        dp[idx[nxt]]+=dp[x];      \n      }\n    }\n  \n    Int ans=0;\n    for(Int i=0;i<(Int)rev.size();i++){\n      Int flg=0,bit=rev[i];\n      for(Int j=3;j<7;j++)\n        if((bit>>calc(n,j))&1) flg=1;\n      if(flg) ans+=dp[i];    \n    }  \n    cout<<ans<<endl;\n    //break;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\ntypedef vector<vector<pii> > Graph;\n\nvoid NFAtoDFA(Graph &g, map<pii, unsigned char> &G){\n\tint n = g.size();\n\tunordered_map<int, unsigned char> vis;\n\tvis[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile(!q.empty()){\n\t\tint i = q.front();\n\t\tq.pop();\n\t\tREP(j, 10){\n\t\t\tint tar = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(((i>>k)&1) == 0) continue;\n\t\t\t\tFOR(e, g[k]){\n\t\t\t\t\tif(e->second & (1<<j)) tar |= 1<<e->first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tar){\n\t\t\t\tG[pii(i, tar)] ++;\n\t\t\t\tif(!vis[tar]){\n\t\t\t\t\tvis[tar] = 1;\n\t\t\t\t\tq.push(tar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nll dfs(int s, unordered_map<int, ll> &memo, map<pii, unsigned char> &G, int accept){\n\tif(memo[s]) return memo[s];\n\tauto it = G.lower_bound(pii(s, 0));\n\tauto it2 = G.lower_bound(pii(s+1, 0));\n\tll res = !!(s&accept);\n\tfor(;it!=it2;++it){\n\t\tres += it->second * dfs(it->first.second, memo, G, accept);\n\t}\n\treturn memo[s] = res;\n}\n\nmain(){\n\twhile(cin >> n, n){\n\t\tint low[6], hi[6];\n\t\tREP(i, n) cin >> low[i] >> hi[i];\n\t\tGraph g(n*4+1);\n\t\tREP(i, n){\n\t\t\tif(low[i]/10 == hi[i]/10){\n\t\t\t\tint ev = 0;\n\t\t\t\tREP(j, 10) if(low[i]%10 <= j && j <= hi[i]%10) ev |= 1<<j;\n\t\t\t\tif(low[i] < 10){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+4, ev));\n\t\t\t\t}else{\n\t\t\t\t\tg[4*i].push_back(pii(4*i+1, 1<<(low[i]/10)));\n\t\t\t\t\tg[4*i+1].push_back(pii(4*i+4, ev));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint ev = 0;\n\t\t\t\tREP(j, 10) if(low[i]%10 <= j) ev |= 1<<j;\n\t\t\t\tif(low[i] < 10){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+4, ev));\n\t\t\t\t}else{\n\t\t\t\t\tg[4*i].push_back(pii(4*i+1, 1<<(low[i]/10)));\n\t\t\t\t\tg[4*i+1].push_back(pii(4*i+4, ev));\n\t\t\t\t}\t\n\n\t\t\t\tev = 0;\n\t\t\t\tREP(j, 10) if(low[i]/10 < j && j < hi[i]/10) ev |= 1<<j;\n\t\t\t\tif(ev){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+2, ev));\n\t\t\t\t\tg[4*i+2].push_back(pii(4*i+4, (1<<10)-1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tev = 0;\n\t\t\t\tREP(j, 10) if(hi[i]%10 >= j) ev |= 1<<j;\n\t\t\t\tg[4*i].push_back(pii(4*i+3, 1<<(hi[i]/10)));\n\t\t\t\tg[4*i+3].push_back(pii(4*i+4, ev));\n\t\t\t}\n\t\t}\n\t\tmap<pii, unsigned char> g2;\n\t\tNFAtoDFA(g, g2);\n\t\tunordered_map<int, ll> memo;\n\t\tcout << dfs(1, memo, g2, 1<<(4*n)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define ALL(v) v.begin(),v.end()\n\nint sbstr[1000000][21];\nint lgth[1000000];\nint pow_10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nint cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tint c=0;\n\t\tstring s=to_string(i);\n\t\tlgth[i]=(int)(s.length());\n\t\tREP(j,s.length()) {\n\t\t\tfor(ll k=1; j+k<=(int)s.length(); k++) {\n\t\t\t\tsbstr[i][c]=stoi(s.substr(j,k));\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\tpow_10[0]=1;\n\tpow_10[1]=10;\n\tpow_10[2]=100;\n\tpow_10[3]=1000;\n\tpow_10[4]=10000;\n\tpow_10[5]=100000;\n\treturn;\n}\n\nint sbst(int n, int l, int m) {\n\tint sum=0;\n\tif(l==0) return sbstr[n][sum+m];\n\tsum+=lgth[n];\n\tif(l==1) return sbstr[n][sum+m];\n\tsum+=lgth[n]-1;\n\tif(l==2) return sbstr[n][sum+m];\n\tsum+=lgth[n]-2;\n\tif(l==3) return sbstr[n][sum+m];\n\tsum+=lgth[n]-3;\n\tif(l==4) return sbstr[n][sum+m];\n\tsum+=lgth[n]-4;\n\tif(l==5) return sbstr[n][sum+m];\n\treturn 0;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgth[j]>1&&sbst(j,1,0)!=0&&sbst(j,0,0)>=el[i].first&&sbst(j,0,0)<=el[i].second&&dp1[i+1][sbst(j,1,lgth[j]-2)]) dp1[i][j]=true;\n\t\t\t\tif(lgth[j]>2&&sbst(j,2,0)!=0&&sbst(j,0,1)>=el[i].first&&sbst(j,0,1)<=el[i].second&&dp1[i+1][sbst(j,2,lgth[j]-3)]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgth[j]>1&&sbst(j,1,0)!=0&&sbst(j,0,0)>=el[i].first&&sbst(j,0,0)<=el[i].second&&dp2[i+1-mid][sbst(j,1,lgth[j]-2)]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgth[j]>2&&sbst(j,2,0)!=0&&sbst(j,0,1)>=el[i].first&&sbst(j,0,1)<=el[i].second&&dp2[i+1-mid][sbst(j,2,lgth[j]-3)]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow_10[6-lgth[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\t//cout<<i*pow_10[lgt[j]]+j<<endl;\n\t\t\t//cout<<j<<\" \"<<lgt[j]<<endl;\n\t\t\tif(dp2[0][i*pow_10[lgth[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgth[i];j++) {\n\t\t\tif(dp1[0][sbst(i,0,j-1)]&&sbst(i,j,0)!=0)  {\n\t\t\t\tret-=cnt[sbst(i,j,lgth[i]-j-1)];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<string>\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<stack>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;\nconst int SZ = 1 << 13;\nint g[13][10][2][10];\nLL dp[SZ][10];\nint n;\nvoid dfs(int bit, int val) {\n\tLL &ret = dp[bit][val];\n\tif (ret != -1)return;\n\tret = 0;\n\tconst int ed = 1 << (2 * n);\n\tif (bit&ed)ret++;\n\tREP(i, 10) {\n\t\tint nxtbit = 0;\n\t\tREP(j, 2 * n + 1) {\n\t\t\tif ((bit >> j) & 1) {\n\t\t\t\tif (g[j][val][0][i])nxtbit |= 1 << (j + 1);\n\t\t\t\tif (g[j][val][1][i])nxtbit |= 1 << (j + 2);\n\t\t\t}\n\t\t}\n\t\tif (nxtbit == 0)continue;\n\t\tdfs(nxtbit, i);\n\t\tret += dp[nxtbit][i];\n\t}\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tREP(i, SZ)REP(j, 10)dp[i][j] = -1;\n\t\tREP(i, 13)REP(j, 10)REP(k, 2)REP(l, 10)g[i][j][k][l] = 0;\n\t\tREP(i, n) {\n\t\t\tint x = i * 2;\n\t\t\tint y = x + 1;\n\t\t\tint z = x + 2;\n\t\t\tint lb, ub;\n\t\t\tcin >> lb >> ub;\n\t\t\tREP(j, 10) {\n\t\t\t\tif (lb <= j&&j <= ub) {\n\t\t\t\t\tREP(k, 10)g[x][k][1][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j, 10, 100) {\n\t\t\t\tif (lb <= j&&j <= ub) {\n\t\t\t\t\tREP(k, 10)g[x][k][0][j / 10] = 1;\n\t\t\t\t\tg[y][j / 10][0][j % 10] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(1, 0);\n\t\tcout << dp[1][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint l[7],h[7] ={};\nint N;\nstruct Condition{\n\tint finished;\n\tint unprocessed;\n\tint lb,ub;\n};\n\nbool operator < (const Condition &a,const Condition &b){\n\treturn \tarray<int,4>{a.finished,a.unprocessed,a.lb,a.ub} < \n\t\t\tarray<int,4>{b.finished,b.unprocessed,b.lb,b.ub};\n}\ntypedef set<Condition> Conditions;\n\nConditions trans(Condition c,int d){\n\tif( c.finished == N ) return {};\n\tif( c.unprocessed != -1 ){\n\t\tif( d < c.lb or d > c.ub ) return {};\n\t\tc.unprocessed = -1;\n\t\tc.finished++;\n\t\tc.lb = l[c.finished];\n\t\tc.ub = h[c.finished];\n\t\treturn {c};\n\t}else{\n\t\tConditions res;\n\t\tif( c.ub >= 10 ){\n\t\t\tif( max(1,c.lb / 10) <= d and d <= c.ub / 10 ){\n\t\t\t\tauto cpy = c;\n\t\t\t\tcpy.unprocessed = cpy.finished;\n\t\t\t\t\n\t\t\t\tcpy.lb = 0;\n\t\t\t\tcpy.ub = 9;\n\t\t\t\tif( c.lb / 10 == d ){\n\t\t\t\t\tcpy.lb = c.lb % 10;\n\t\t\t\t}\n\t\t\t\tif( c.ub / 10 == d ){\n\t\t\t\t\tcpy.ub = c.ub % 10;\n\t\t\t\t}\n\t\t\t\tres.insert(cpy);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif( c.lb <= d and d <= c.ub ){\n\t\t\tauto cpy = c;\n\t\t\tcpy.unprocessed = -1;\n\t\t\tcpy.finished++;\n\t\t\tcpy.lb = l[cpy.finished];\n\t\t\tcpy.ub = h[cpy.finished];\n\t\t\tres.insert(cpy);\n\t\t}\n\t\treturn res;\n\t}\n}\nmap<Conditions, long long> memo;\nlong long dfs(Conditions c){\t\n\tif( c.size() == 0 ) return 0;\n\tif( memo.count(c) ) return memo[c];\n\n\tlong long ans = 0;\n\tfor( auto e : c ){\n\t\tif( N == e.finished ) ans = 1;\n\t}\n\tfor(int i = 0 ; i <= 9 ; i++){\n\t\tConditions nc;\n\t\tfor( auto e : c ){\n\t\t\tauto tmp = trans(e,i);\n\t\t\tnc.insert(tmp.begin(),tmp.end());\n\t\t}\n\t\tans += dfs(nc);\n\t}\n\treturn memo[c] = ans;\n}\nint main(){\n\t\n\twhile(cin >> N&&N){\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tcin >> l[i] >> h[i];\n\t\t}\n\t\tcout << dfs({Condition{0,-1,l[0],h[0]}}) << endl;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\nvector<int> HEAD[NUM];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\ttail_max[i] = max(tail_max[i],tmp);\n\t\t\t\ttail_min[i] = min(tail_min[i],tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\n\t\tHEAD[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()),HEAD[i].end());\n\t}\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\tint tmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = tail_min[b_len]; tmp_B <= tail_max[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nconst int _MOD = 1000000009;\ndouble EPS = 1e-10;\nll INF = INT_MAX / 2;\n\nll solve(int N, vector<int> lb, vector<int> ub) {\n\tmap<int, ll> dp; dp[1] = 1;\n\tll ans = 0;\n\trep(t, 12) {\n\t\tmap<int, ll> _dp;\n\t\tint cnt = 0;\n\t\tfor (i_ll Sx: dp) {\n\t\t\tint S = Sx.first; ll x = Sx.second;\n\t\t\trep(d, 10) {\n\t\t\t\tint _S = 0;\n\t\t\t\trep(i, N) if (S>>i & 1) {\n\t\t\t\t\tif (lb[i] <= d && d <= ub[i])\n\t\t\t\t\t\t_S |= 1<<(i + 1);\n\t\t\t\t\tif (lb[i]/10 < d && d < ub[i]/10)\n\t\t\t\t\t\t_S |= 1<<(N+1 + i);\n\t\t\t\t\tif (d && d == lb[i]/10 && d < ub[i]/10)\n\t\t\t\t\t\t_S |= 1<<(N*2+1 + i);\n\t\t\t\t\tif (d && lb[i]/10 < d && d == ub[i]/10)\n\t\t\t\t\t\t_S |= 1<<(N*3+1 + i);\n\t\t\t\t\tif (d && d == lb[i]/10 && d == ub[i]/10)\n\t\t\t\t\t\t_S |= 1<<(N*4+1 + i);\n\t\t\t\t}\n\t\t\t\trep(i, N) if (S>>(N+1 + i) & 1) {\n\t\t\t\t\t_S |= 1<<(i + 1);\n\t\t\t\t}\n\t\t\t\trep(i, N) if (S>>(N*2+1 + i) & 1) {\n\t\t\t\t\tif (d >= lb[i]%10)\n\t\t\t\t\t\t_S |= 1<<(i + 1);\n\t\t\t\t}\n\t\t\t\trep(i, N) if (S>>(N*3+1 + i) & 1) {\n\t\t\t\t\tif (d <= ub[i]%10)\n\t\t\t\t\t\t_S |= 1<<(i + 1);\n\t\t\t\t}\n\t\t\t\trep(i, N) if (S>>(N*4+1 + i) & 1) {\n\t\t\t\t\tif (lb[i]%10 <= d && d <= ub[i]%10)\n\t\t\t\t\t\t_S |= 1<<(i + 1);\n\t\t\t\t}\n\t\t\t\t_dp[_S] += x;\n\t\t\t}\n\t\t}\n\t\tdp = _dp;\n\t\tfor (i_ll Sx: dp) {\n\t\t\tint S = Sx.first; ll x = Sx.second;\n\t\t\tif (S>>N & 1) ans += x;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (!N) break;\n\t\tvector<int> lb(N), ub(N);\n\t\trep(i, N) cin >> lb[i] >> ub[i];\n\t\tcout << solve(N, lb, ub) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[6],POW_10[6];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nvector<int> num_list[2][NUM]; //長さ別の数字のリスト\n\nint get_length(int num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint S = 10;\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length].push_back(num);\n\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int len){\n\tnum /= POW_10[len-1];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i].clear();\n\t\tnum_list[B][i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min].size();\n\t\t\tll count_B = num_list[B][B_max].size();\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = MIN_LEN[A];\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = POW_10[a_len-1]; tmp_A < POW_10[a_len]; tmp_A++){\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\t\t\tadd_A_len = common_part_len-loop;\n\t\t\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_front(common_num,add_A_len);\n\n\t\t\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[A][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = MIN_LEN[B];\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = 0; tmp_B < POW_10[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\t\t\t\t\t\t\tadd_B_len = loop;\n\t\t\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\t\t\tif(part_num < POW_10[common_part_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[B][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\t\t\t\tnum_bit = 0;\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop))num_bit++;\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 6; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\ntypedef vector<vector<pii> > Graph;\n\nvoid NFAtoDFA(Graph &g, map<pii, unsigned char> &G){\n\tint n = g.size();\n\tunordered_map<int, unsigned char> vis;\n\tvis[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile(!q.empty()){\n\t\tint i = q.front();\n\t\tq.pop();\n\t\tREP(j, 10){\n\t\t\tint tar = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(((i>>k)&1) == 0) continue;\n\t\t\t\tFOR(e, g[k]){\n\t\t\t\t\tif(e->second & (1<<j)) tar |= 1<<e->first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tar){\n\t\t\t\tG[pii(i, tar)] ++;\n\t\t\t\tif(!vis[tar]){\n\t\t\t\t\tvis[tar] = 1;\n\t\t\t\t\tq.push(tar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nll dfs(int s, unordered_map<int, ll> &memo, map<pii, unsigned char> &G, int accept){\n\tif(memo[s]) return memo[s];\n\tauto it = G.lower_bound(pii(s, 0));\n\tauto it2 = G.lower_bound(pii(s+1, 0));\n\tll res = !!(s&accept);\n\tfor(;it!=it2;++it){\n\t\tres += it->second * dfs(it->first.second, memo, G, accept);\n\t}\n\treturn memo[s] = res;\n}\n\nmain(){\n\twhile(cin >> n, n){\n\t\tint low[6], hi[6];\n\t\tREP(i, n) cin >> low[i] >> hi[i];\n\t\tGraph g(n*4+1);\n\t\tREP(i, n){\n\t\t\tif(low[i]/10 == hi[i]/10){\n\t\t\t\tint ev = 0;\n\t\t\t\tREP(j, 10) if(low[i]%10 <= j && j <= hi[i]%10) ev |= 1<<j;\n\t\t\t\tif(low[i] < 10){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+4, ev));\n\t\t\t\t}else{\n\t\t\t\t\tg[4*i].push_back(pii(4*i+1, 1<<(low[i]/10)));\n\t\t\t\t\tg[4*i+1].push_back(pii(4*i+4, ev));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint ev = 0;\n\t\t\t\tREP(j, 10) if(low[i]%10 <= j) ev |= 1<<j;\n\t\t\t\tif(low[i] < 10){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+4, ev));\n\t\t\t\t}else{\n\t\t\t\t\tg[4*i].push_back(pii(4*i+1, 1<<(low[i]/10)));\n\t\t\t\t\tg[4*i+1].push_back(pii(4*i+4, ev));\n\t\t\t\t}\t\n\n\t\t\t\tev = 0;\n\t\t\t\tREP(j, 10) if(low[i]/10 < j && j < hi[i]/10) ev |= 1<<j;\n\t\t\t\tif(ev){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+2, ev));\n\t\t\t\t\tg[4*i+2].push_back(pii(4*i+4, (1<<10)-1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tev = 0;\n\t\t\t\tREP(j, 10) if(hi[i]%10 >= j) ev |= 1<<j;\n\t\t\t\tg[4*i].push_back(pii(4*i+3, 1<<(hi[i]/10)));\n\t\t\t\tg[4*i+3].push_back(pii(4*i+4, ev));\n\t\t\t}\n\t\t}\n\t\tmap<pii, unsigned char> g2;\n\t\tNFAtoDFA(g, g2);\n\t\tunordered_map<int, ll> memo;\n\t\tcout << dfs(1, memo, g2, 1<<(4*n)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<queue>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint getNum(char ch){\n\treturn ch-'0';\n}\n\nstruct PMA{\n\tstruct node{\n\t\tint nxt[10];\n\t\tint par;\n\t\tint parc;\n\t\tint fail;\n\t\tbool leaf;\n\t\tint d;\n\t\tnode(){\n\t\t\tfor(int i=0;i<10;i++) nxt[i]=-1;\n\t\t\tpar=-1;\n\t\t\tparc=-1;\n\t\t\td=0;\n\t\t\tfail=0;\n\t\t\tleaf=false;\n\t\t}\n\t};\n\tnode nodes[1000100];\n\tint c;\n\tint leafN;\n\tvoid init(){\n\t\tfor(int i=0;i<c;i++){\n\t\t\tnodes[i]=node();\n\t\t}\n\t\tc=1;\n\t\tleafN=0;\n\t}\n\tvoid add(string str){\n\t\tint cur=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tint n=getNum(str[i]);\n\t\t\tif(nodes[cur].nxt[n]==-1){\n\t\t\t\tnodes[cur].nxt[n]=c;\n\t\t\t\tnodes[c].par=cur;\n\t\t\t\tnodes[c].parc=n;\n\t\t\t\tnodes[c].d=nodes[cur].d+1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tcur=nodes[cur].nxt[n];\n\t\t}\n\t\tif(nodes[cur].leaf==false){\n\t\t\tnodes[cur].leaf=true;\n\t\t\tleafN++;\n\t\t}\n\t}\n\tvoid getFail(){\n\t\tqueue<int> que;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tif(nodes[0].nxt[i]!=-1){\n\t\t\t\tint v=nodes[0].nxt[i];\n\t\t\t\tnodes[v].fail=0;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint u=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tint v=nodes[u].nxt[i];\n\t\t\t\tif(v==-1) continue;\n\t\t\t\tque.push(v);\n\t\t\t\tint w=nodes[u].fail;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(w==0) break;\n\t\t\t\t\tif(nodes[w].nxt[i]!=-1) break;\n\t\t\t\t\tw=nodes[w].fail;\n\t\t\t\t}\n\t\t\t\tif(nodes[w].nxt[i]!=-1){\n\t\t\t\t\tnodes[v].fail=nodes[w].nxt[i];\n\t\t\t\t}else{\n\t\t\t\t\tnodes[v].fail=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid goUp(map<string,int> &mp){\n\t\tfor(int i=0;i<c;i++){\n\t\t\tif(nodes[i].leaf){\n\t\t\t\tint v=i;\n\t\t\t\tstring str;\n\t\t\t\twhile(v!=0){\n\t\t\t\t\tint p=nodes[v].par;\n\t\t\t\t\tint num=nodes[v].parc;\n\t\t\t\t\tstring tmp;\n\t\t\t\t\ttmp+=('0'+num);\n\t\t\t\t\tstr=tmp+str;\n\t\t\t\t\tif(nodes[p].leaf){\n\t\t\t\t\t\tmp[str]++;\n\t\t\t\t\t}\n\t\t\t\t\tv=p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,string str,map<string,int> &mp){\n\t//\tcout<<\"v=\"<<v<<\",str=\"<<str<<\"\\n\";\n\t//\tif(v==46){\n\t//\t\tcout<<\"v=46\"<<\" str=\"<<str<<\"\\n\";\n\t//\t}\n\t\tif(nodes[v].leaf){\n\t\t\tint f=nodes[v].fail;\n\t\t\tif(f!=0&&nodes[f].leaf){\n\t//\t\t\tcout<<\"leaf fail=\"<<f<<\"\\n\";\n\t\t\t\tint dif=nodes[v].d-nodes[f].d;\n\t\t\t\tstring tmp=\"\";\n\t\t\t//\tfor(int i=str.size()-dif;i<str.size();i++){\n\t\t\t\tfor(int i=0;i<dif;i++){\n\t\t\t\t\ttmp+=str[i];\n\t\t\t\t}\n\t\t\t\tmp[tmp]++;\n\t\t\t//\tif(tmp==\"1\"){\n\t\t\t//\t\tcout<<\"to fail:\\\"1\\\"\"<<str<<\"\\n\";\n\t\t\t//\t}\n\t\t\t//\tif(str==\"189\"){\n\t\t\t//\t\tcout<<v<<\"&\"<<nodes[v].fail<<\"\\n\";\n\t\t\t//\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<10;i++){\n\t\t\tif(nodes[v].nxt[i]==-1) continue;\n\t//\t\tcout<<\"move i=\"<<i<<\"\\n\";\n\t\t\tstring nxtS=str+(char)('0'+i);\n\t\t\tdfs(nodes[v].nxt[i],nxtS,mp);\n\t\t}\n\t}\n};\n\nPMA fi,se;\n\nmap<string,int> cntF,cntS;\n\nvoid init(){\n\tfi.init();\n\tse.init();\n\tmap<string,int> tmp;\n\tswap(cntF,tmp);\n\tmap<string,int> tmp2;\n\tswap(cntS,tmp2);\n}\n\nint lo[6],hi[6];\n\nvoid dfs(int id,int n,string cur,PMA &p){\n\tif(id==n){\n\t//\tif(cur==\"89\"){\n\t//\t\tcout<<\"id===\"<<id<<\" \"<<n<<\"\\n\";\n\t//\t}\n\t\tp.add(cur);\n\t\treturn;\n\t}\n\tfor(int i=lo[id];i<=hi[id];i++){\n\t\tstringstream ss;\n\t\tss<<i;\n\t\tstring tmp;\n\t\tss>>tmp;\n\t\tdfs(id+1,n,cur+tmp,p);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tinit();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d%d\",lo+i,hi+i);\n\t\t}\n\t\tif(N==1){\n\t\t\tprintf(\"%d\\n\",hi[0]-lo[0]+1);\n\t\t\tcontinue;\n\t\t}\n\t//\tprintf(\"a\\n\");\n\t\tdfs(0,N/2,\"\",fi);\n\t\tdfs(N/2,N,\"\",se);\n\t//\tprintf(\"b\\n\");\n\t\tse.getFail();\n\t//\tprintf(\"c\\n\");\n\t\tse.dfs(0,\"\",cntS);\n\t//\tprintf(\"d\\n\");\n\t\tfi.goUp(cntF);\n\t//\tprintf(\"e\\n\");\n\t\tlong long ans=(long long)(fi.leafN)*(se.leafN);\n\t\tmap<string,int>::iterator itF=cntF.begin(),itS=cntS.begin();\n\t\tfor(;itF!=cntF.end()&&itS!=cntS.end();){\n\t\t\tstring strF=itF->first;\n\t\t\tstring strS=itS->first;\n\t//\t\tcout<<itF->first<<\" \"<<itF->second<<\" \"<<itS->first<<\" \"<<itS->second<<\"\\n\";\n\t\t\tif(strF==strS){\n\t//\t\t\tcout<<itF->first<<\" \"<<itF->second<<\" \"<<itS->first<<\" \"<<itS->second<<\"\\n\";\n\t\t\t\tans-=(long long)(itF->second)*(itS->second);\n\t\t\t\titF++;\n\t\t\t\titS++;\n\t\t\t}else if(strF<strS){\n\t\t\t\titF++;\n\t\t\t}else{\n\t\t\t\titS++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t//\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[6],POW_10[6];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nvector<int> num_list[2][NUM]; //長さ別の数字のリスト\n\nint get_length(int num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint S = 10;\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length].push_back(num);\n\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int len){\n\tnum /= POW_10[len-1];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i].clear();\n\t\tnum_list[B][i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min].size();\n\t\t\tll count_B = num_list[B][B_max].size();\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = MIN_LEN[A];\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int tmp_A = POW_10[a_len-1]; tmp_A < POW_10[a_len]; tmp_A++){\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\t\t\tadd_A_len = common_part_len-loop;\n\t\t\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_front(common_num,add_A_len);\n\n\t\t\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[A][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = MIN_LEN[B];\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = 0; tmp_B < POW_10[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){ //2^(common_part_len+1)の状態発生\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\t\t\t\t\t\t\tadd_B_len = loop;\n\t\t\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\t\t\tif(part_num < POW_10[common_part_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tdp[B][state] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\t\t\t\tnum_bit = 0;\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop))num_bit++;\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 6; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint N;\nvector<pii> D;\nvector<int> G[12][10][10];\nll dp[14][1 << 12][10];\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tD.clear();\n\t\trep(i,12) {\n\t\t\trep(j,1<<12) {\n\t\t\t\trep(k,10) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,12)\n\t\t\trep(j,10)\n\t\t\t\trep(k,10)\n\t\t\t\t\tG[i][j][k].clear();\n\n\t\tD.resize(N);\n\t\trep(i,N) {\n\t\t\tcin >> D[i].fi >> D[i].se;\n\t\t}\n\n\t\trep(i, D.size()) {\n\t\t\tfor(int j = max(10, D[i].fi); j <= D[i].se; j++)\n\t\t\t\tG[i*2][j/10][j%10].push_back(i*2+1);\n\t\t\t\n\t\t\trep(j, 10) {\n\t\t\t\tif(i < (int)D.size()-1) {\n\t\t\t\t\tfor(int k = D[i+1].fi; k <= min(9, D[i+1].se); k++)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2+1);\n\t\t\t\t\tfor(int k = max(D[i+1].fi / 10, 1); k <= D[i+1].se / 10; k++)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trep(k,10)\n\t\t\t\t\t\tG[i*2+1][j][k].push_back((i+1)*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < 10; i++) {\n\t\t\tint s = 0;\n\t\t\tif(D[0].fi <= i && i <= D[0].se)\n\t\t\t\ts |= 1 << 1;\n\t\t\tif(D[0].fi / 10 <= i && i <= D[0].se / 10)\n\t\t\t\ts |= 1;\n\t\t\tdp[1][s][i] = !!s;\n\t\t}\n\n\t\tll res = 0;\n\t\tfor(int i = 1; i <= D.size()*2; i++) {\n\t\t\tfor(int j = 1; j < (1 << (D.size()*2)); j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif(dp[i][j][k] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/*\n\t\t\t\t\tcout << i << \" \";\n\t\t\t\t\tfor(int m = 0; m < 16; m++) {\n\t\t\t\t\t\tcout << !!(j & (1 << m));\n\t\t\t\t\t} cout << \" \" << k << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tint s = 0;\n\t\t\t\t\t\tfor(int m = 0; m < D.size()*2; m++) {\n\t\t\t\t\t\t\tif(j & (1 << m)) {\n\t\t\t\t\t\t\t\tfor(int a = 0; a < G[m][k][l].size(); a++) {\n\t\t\t\t\t\t\t\t\ts |= 1 << G[m][k][l][a];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s & (1 << (D.size()*2))) {\n\t\t\t\t\t\t\tres += dp[i][j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i+1][s & ((1 << (D.size()*2)) - 1)][l] += dp[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i <= D.size()*2; i++) {\n\t\t\tfor(int j = 0; j < (1 << (D.size()*2)); j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t\t} cout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\t\tcout << res / 10 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint N;\nint hit(int k, int i) {\n    assert(0 <= k && k < N);\n    assert(i == 1 || i == 10);\n    return 1 << (2 * k + (i == 1 ? 0 : 1));\n}\n\ntypedef long long LL;\n\nint main(){\n    while(cin >> N && N > 0){\n        vector<int> low(N);\n        vector<int> high(N);\n        REP(i, N) cin >> low[i] >> high[i];\n        LL ans = 0;\n\n        for(int len = N; len <= 2 * N; len++) {\n            static LL dp[20][20][1 << 12] = {};\n            memset(dp, 0, sizeof(dp));\n\n            REP(x, 10) if(x > 0) {\n                int s = hit(0, 10);\n                if(low[0] <= x && x <= high[0]) {\n                    s |= hit(0, 1);\n                }\n                dp[1][x][s] = 1;\n            }\n\n            REP(i, len) if(i > 0) REP(x, 10) REP(s, 1 << (2 * N)) if(dp[i][x][s] > 0) REP(y, 10) {\n                int ns = 0;\n                REP(k, N - 1) if(s & hit(k, 1)) {\n                    // 10\n                    if(y > 0) ns |= hit(k + 1, 10);\n                    // 1\n                    if(low[k + 1] <= y && y <= high[k + 1]) {\n                        ns |= hit(k + 1, 1);\n                    }\n                }\n                REP(k, N) if(s & hit(k, 10)) {\n                    assert(x != 0);\n                    int d = x * 10 + y;\n                    if(low[k] <= d && d <= high[k]) {\n                        ns |= hit(k, 1);\n                    }\n                }\n                // printf(\"(%d, %d, %x) -> (%d, %d, %x) : %d\\n\", i, x, s, i + 1, y, ns, dp[i][x][s]);\n                dp[i + 1][y][ns] += dp[i][x][s];\n            }\n\n            LL subans = 0;\n            REP(x, 10) REP(s, 1 << (2 * N)) if(s & hit(N - 1, 1)) {\n                subans += dp[len][x][s];\n            }\n            // cout << len << \" \" << subans << endl;\n            ans += subans;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvoid solve() {\n  int n; cin >> n;\n  if (n == 0) exit(0);\n  vector<int> l(n), h(n);\n  for (int i = 0; i < n; i++) cin >> l[i] >> h[i];\n\n  vector<unordered_map<int, int>> dp(2);\n  dp[0][1] = 1;\n  int ans = 0;\n  for (int i = 0; i < 2 * n + 1; i++) {\n    for (const auto& p : dp[0]) {\n      const int S = p.first;\n      if (S >> (4 * n) & 1) ans += p.second;\n      for (int x = 0; x < 10; x++) {\n        int T = 0;\n        for (int j = 0; j < 25; j++) {\n          int k = j / 4;\n          if ((S >> j & 1) == 0 || k >= n) continue;\n          if (j % 4 == 0) {\n            // k個目はじめから\n            if (l[k] <= x && x <= h[k]) T |= 1 << (j + 4);\n            if (x == 0) continue;\n            if (l[k] / 10 == x) {\n              T |= 1 << (j + 1);\n            } else if (h[k] / 10 == x) {\n              T |= 1 << (j + 3);\n            } else if (l[k] / 10 < x && x < h[k] / 10) {\n              T |= 1 << (j + 2);\n            }\n          } else if (j % 4 == 1) {\n            // k個目10の位最小を使った\n            int up = l[k] / 10 == h[k] / 10 ? h[k] % 10 : 9;\n            if (l[k] % 10 <= x && x <= up) T |= 1 << (j + 3);\n          } else if (j % 4 == 2) {\n            // k個目10の位真ん中を使った\n            T |= 1 << (j + 2);\n          } else {\n            // k個目10の位最大を使った\n            if (x <= h[k] % 10) T |= 1 << (j + 1);\n          }\n        }\n        dp[1][T] += p.second;\n      }\n    }\n    swap(dp[0], dp[1]);\n    dp[1].clear();\n  }\n  cout << ans << endl;\n}\nsigned main() {\n  while (1) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nconst int maton_size = 10;\nstruct n_maton {\n\tint n_id;\n\tvector<vector<int>>edgess;\n\tn_maton(const int id_, const vector<vector<int>>edgess_) :n_id(id_), edgess(edgess_) {\n\t\tassert(maton_size + 1 == edgess.size());\n\t}\n\tn_maton() :n_id(0), edgess(maton_size+1) {}\n};\nstruct nfa{\n\tstruct d_maton {\n\t\tint d_id;\n\t\tvector<int>n_ids;\n\t\tvector<int>d_edges;\n\t\td_maton(const int id_, const n_maton&mat) :d_id(id_), n_ids(1, mat.n_id),d_edges(maton_size) {}\n\t\td_maton(const int id_, const vector<n_maton>&mats) :\n\t\t\td_id(id_), n_ids(),d_edges(maton_size) {\n\t\t\tfor (auto m : mats) {\n\t\t\t\tn_ids.emplace_back(m.n_id);\n\t\t\t\tvector<vector<int>>n_edgess;\n\t\t\t\tfor (auto es : m.edgess) {\n\t\t\t\t\tfor (int i = 0; i < maton_size + 1; ++i) {\n\t\t\t\t\t\tfor (auto e : es) {\n\t\t\t\t\t\t\tn_edgess[i].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < maton_size + 1; ++i) {\n\t\t\t\t\tsort(n_edgess[i].begin(), n_edgess[i].end());\n\t\t\t\t\tn_edgess[i].erase(unique(n_edgess[i].begin(), n_edgess[i].end()), n_edgess[i].end());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td_maton(const int id_, const vector<int>n_ids_) :\n\t\t\td_id(id_), n_ids(n_ids_),d_edges(maton_size) {}\n\t};\n\tvector<n_maton>n_nodes;\n\tvector<d_maton>d_nodes;\n\tvector<int> get_epsilons(const vector<int>&now_n_ids) {\n\t\tvector<int>epsilons(n_nodes.size());\n\t\tqueue<int>ep_que;\n\t\tfor (auto n_id : now_n_ids) {\n\t\t\tepsilons[n_id] = true;\n\t\t\tep_que.push(n_id);\n\t\t}\n\t\twhile (!ep_que.empty()) {\n\t\t\tconst int ep_n_id = ep_que.front();\n\t\t\tep_que.pop();\n\t\t\tfor (auto e : n_nodes[ep_n_id].edgess[maton_size]) {\n\t\t\t\tif (!epsilons[e]) {\n\t\t\t\t\tepsilons[e] = true;\n\t\t\t\t\tep_que.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>eps_n_ids;\n\t\tfor (int i = 0; i < static_cast<int>(n_nodes.size()); ++i) {\n\t\t\tif (epsilons[i])eps_n_ids.push_back(i);\n\t\t}\n\t\treturn eps_n_ids;\n\t}\n\tvector<int>get_next_ids(const vector<int>&now_n_ids,const int n) {\n\t\tvector<int>next_n_ids;\n\t\tfor (auto n_id:now_n_ids){\n\t\t\tfor (auto e : n_nodes[n_id].edgess[n]) {\n\t\t\t\tnext_n_ids.emplace_back(e);\n\t\t\t}\n\t\t}\n\t\tsort(next_n_ids.begin(), next_n_ids.end());\n\t\tnext_n_ids.erase(unique(next_n_ids.begin(), next_n_ids.end()), next_n_ids.end());\n\t\treturn next_n_ids;\n\t}\n\tnfa(const int num):n_nodes(num),d_nodes() {\n\t\tfor (int i = 0; i < num; ++i)n_nodes[i].n_id = i;\n\t}\n\tnfa(const vector<n_maton>&n_mats) :n_nodes(n_mats) {\n\t}\n\tvoid add_edge(const int from, const int num,const int to) {\n\t\tn_nodes[from].edgess[num].push_back(to);\n\t}\n\tvoid make_dfa(const int start_id) {\n\t\tqueue<int>que;\n\t\td_nodes.push_back(d_maton(0,n_nodes[0]));\n\t\tque.push(0);\n\t\tint num = 1;\n\t\twhile (!que.empty()) {\n\t\t\tconst int now_d_id = que.front();\n\t\t\tque.pop();\n\t\t\tfor (int n = 0; n < maton_size; ++n) {\n\t\t\t\tvector<int>now_n_ids(d_nodes[now_d_id].n_ids);\n\t\t\t\tnow_n_ids = get_epsilons(now_n_ids);\n\n\t\t\t\tvector<int>next_n_ids = get_next_ids(now_n_ids, n);\n\t\t\t\tauto it = find_if(d_nodes.begin(), d_nodes.end(), [=](const d_maton&mat) {\n\t\t\t\t\treturn mat.n_ids == next_n_ids;\n\t\t\t\t});\n\t\t\t\tif (!next_n_ids.empty()) {\n\t\t\t\t\tif (it == d_nodes.end()) {\n\t\t\t\t\t\td_nodes.emplace_back(num, next_n_ids);\n\t\t\t\t\t\tque.push(num);\n\t\t\t\t\t\td_nodes[now_d_id].d_edges[n] = num;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\td_nodes[now_d_id].d_edges[n] = it - d_nodes.begin();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td_nodes[now_d_id].d_edges[n] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tconst int ps = 0;\n\t\tconst int ss = ps+N+1;\n\t\tconst int rs = ss + N;\n\t\tconst int qs = rs + N;\n\t\tvector<n_maton>matons(qs + N);\n\t\tnfa anfa(qs + N);\n\t\t\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, r; cin >> l >> r;\n\t\t\t//1~9\n\t\t\tif (r < 10) {\n\t\t\t\tfor (int n = l; n <= r; ++n) {\n\t\t\t\t\tanfa.add_edge(ps + i, n, ps + i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (l < 10) {\n\t\t\t\t\tfor (int n = l; n <= 9; ++n) {\n\t\t\t\t\t\tanfa.add_edge(ps + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = max(l, 10); r = max(r, 10);\n\t\t\t\tif (l / 10 == r / 10) {\n\t\t\t\t\tanfa.add_edge(ps + i, l / 10, ss + i);\n\t\t\t\t\tfor (int n = l % 10; n <= r % 10; ++n) {\n\t\t\t\t\t\tanfa.add_edge(ss + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tanfa.add_edge(ps + i, l / 10, qs + i);\n\t\t\t\t\tfor (int n = l % 10; n < 10; ++n) {\n\t\t\t\t\t\tanfa.add_edge(qs + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = l / 10 + 1; m < r / 10; ++m) {\n\t\t\t\t\t\tanfa.add_edge(ps + i, m, rs + i);\n\t\t\t\t\t\tfor (int n = 0; n < 10; ++n) {\n\t\t\t\t\t\t\tanfa.add_edge(rs + i, n, ps + i + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tanfa.add_edge(ps + i, r / 10, ss + i);\n\t\t\t\t\tfor (int n = 0; n <= r % 10; ++n) {\n\t\t\t\t\t\tanfa.add_edge(ss + i, n, ps + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tanfa.make_dfa(0);\n\t\tvector<int>goals(anfa.d_nodes.size());\n\t\tvector < vector<int>>edges(anfa.d_nodes.size());\n\t\tvector<int>nums(anfa.d_nodes.size());\n\t\tvector<long long int>memos(anfa.d_nodes.size());\n\t\tfor (auto n : anfa.d_nodes) {\n\t\t\tif (find(n.n_ids.begin(), n.n_ids.end(), ss - 1) != n.n_ids.end()) {\n\t\t\t\tgoals[n.d_id] = true;\n\t\t\t}\n\t\t\tfor (auto e : n.d_edges) {\n\t\t\t\tif (e != -1) {\n\t\t\t\t\tedges[n.d_id].push_back(e);\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\tqueue<int>que;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tif (!nums[i]) {\n\t\t\t\tque.push(i);\n\t\t\t\tmemos[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tint n = que.front();\n\t\t\tque.pop();\n\t\t\tif (goals[n])ans += memos[n];\n\t\t\tfor (auto e : edges[n]) {\n\t\t\t\tmemos[e] += memos[n];\n\t\t\t\tnums[e]--;\n\t\t\t\tif (!nums[e]) {\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region preprocessor\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n    #define mesg(str) std::cerr << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]  \" << str << \"\\n\"\n#else\n    #define dump(...) ((void)0)\n    #define mesg(str) ((void)0)\n#endif\n#pragma endregion // preprocessor\n\n#pragma region std-overload\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#pragma endregion // std-overload\n\n#pragma region executive-setting\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#pragma endregion // executive-setting\n\n#pragma region fucntion-utility\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n// #define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    assert(__ok != __ng);\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    assert(__ok != __ng);\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type __first, iter_type __last, comp_type comp)\n{\n    assert(__first < __last);\n    std::ptrdiff_t dist(__last - __first);\n    while(dist > 2)\n    {\n        iter_type __left(__first + dist / 3), __right = (__first + dist * 2 / 3);\n        if(comp(__left, __right)) __last = __right, dist = dist * 2 / 3;\n        else __first = __left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(next(__first), __first)) ++__first;\n    return __first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double __first, long double __last, const long double eps, comp_type comp)\n{\n    assert(__first < __last);\n    while(__last - __first > eps)\n    {\n        long double __left{(__first * 2 + __last) / 3}, __right{(__first + __last * 2) / 3};\n        if(comp(__left, __right)) __last = __right;\n        else __first = __left;\n    }\n    return __first;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n#pragma endregion // function-utility\n\n#pragma region using-alias\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n#pragma endregion // using-alias\n\n#pragma region library\n\n\n\n#pragma endregion // library\n\n#pragma region main-code\nstruct solver; template <class> void main_(); int main() { main_<solver>(); }\ntemplate <class solver> void main_()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n        int n; cin>>n;\n        if(!n) exit(0);\n        vector<int> l(n),r(n);\n        for(int i=0; i<n; ++i)\n        {\n            cin>>l[i]>>r[i];\n        }\n        i64 dp[13][1<<13][10]={};\n        dp[0][1][0]=1;\n        for(int x=1; x<=12; x++)\n        {\n            for(int s=1; s<1<<(n*2+1); s++)\n            {\n                for(int d=0; d<10; d++)\n                {\n                    if(!dp[x-1][s][d]) continue;\n                    for(int e=0; e<10; e++)\n                    {\n                        int ss=0;\n                        for(int i=0; i<n*2; i++)\n                        {\n                            if(s>>i&1)\n                            {\n                                int p=i/2;\n                                int q=i&1;\n                                if(q)\n                                {\n                                    int nw=d*10+e;\n                                    if(l[p]<=nw and r[p]>=nw)\n                                    {\n                                        ss|=1<<(i+1);\n                                    }\n                                }\n                                else\n                                {\n                                    if(l[p]<=e and r[p]>=e) // use 1 digit\n                                    {\n                                        ss|=1<<(i+2);\n                                    }\n                                    if(e) // use 2 digit\n                                    {\n                                        if(l[p]<10*(e+1) and r[p]>=10*e)\n                                        {\n                                            ss|=1<<(i+1);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        dp[x][ss][e]+=dp[x-1][s][d];\n                    }\n                }\n            }\n        }\n        i64 ans=0;\n        for(int x=1; x<=12; x++)\n        {\n            for(int d=0; d<10; ++d)\n            {\n                for(int s=0; s<1<<(n*2); s++)\n                {\n                    ans+=dp[x][s|1<<(n*2)][d];\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n};\n#pragma endregion // main-code\n"
  },
  {
    "language": "C++",
    "code": "//AOJ2587\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main () {\n\tlong long int count,counter;\n\tlong long int b, c;\n\tint x, y;\n\tint a[6][4] = { 0 };\n\twhile(1) {\n\t\tcin >> count;\n\t\tif(count == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(size_t i = 0; i < count; i++) {\n\t\t\tcin >> a[i][0] >> a[i][1];\n\t\t\ta[i][2] = (a[i][0] < 10 ? 1:0);\n\t\t\ta[i][3] = (a[i][1] >= 10 ? 1:0);\n\t\t}\n\t\tcounter = 0;\n\t\tfor(size_t i = 0; i < count - 1; i++) {\n\t\t\tif(a[i][2] && a[i][3]) {\n\t\t\t\tfor(size_t j = i + 1; j < count; j++) {\n\t\t\t\t\tif(a[j][2] && a[j][3]) {\n\t\t\t\t\t\tfor(size_t k = a[i][0]; k <= a[i][1] / 10; k++) {\n\t\t\t\t\t\t\tint o = i;\n\t\t\t\t\t\t\t/*while(o+1 != j) {\n\n\t\t\t\t\t\t\t}*/\n\t\t\t\t\t\t\t//do{\n\t\t\t\t\t\t\tif(o + 1 == j) {\n\t\t\t\t\t\t\t\tfor(size_t l = k * 10 + 1; l <= a[o][1] && l < ( k + 1 ) * 10; l++) {\n\t\t\t\t\t\t\t\t\tfor(size_t m = 1; m < 10; m++) {\n\t\t\t\t\t\t\t\t\t\tif(a[j][0] <= ( l % 10 ) * 10 + m&&a[j][1] >= ( l % 10 ) * 10 + m) {\n\t\t\t\t\t\t\t\t\t\t\tint test = 1;\n\t\t\t\t\t\t\t\t\t\t\tfor(size_t n = 0; n < count; n++) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(n < i || j < n) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttest *= a[n][1] - a[n][0] + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t//cout << test << \" \" << i << \" \" << j << \" \" << ( l % 10 ) * 10 + m << endl;\n\t\t\t\t\t\t\t\t\t\t\tcounter += test;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(o + 2 == j) {\n\t\t\t\t\t\t\t\tfor(size_t l = a[o+1][0]/10; l <= a[o+1][1]/10; l++) {\n\t\t\t\t\t\t\t\t\tif(10 * k + l <= a[o][1] && 10 * k + l >= a[o][0]) {\n\t\t\t\t\t\t\t\t\t\tfor(size_t m = a[o+2][0]/10; m <=a[o+1][1]/10 ; m++) {\n\t\t\t\t\t\t\t\t\t\t\tif(10 * l + m <= a[o + 1][1] && 10 * l + m >= a[o + 1][0]) {\n\t\t\t\t\t\t\t\t\t\t\t\tint test = 1;\n\t\t\t\t\t\t\t\t\t\t\t\tfor(size_t n = 0; n < count; n++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(n < i || j < n) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttest *= a[n][1] - a[n][0] + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t//cout << test << \" \" << i << \" \" << j << \" \" << ( l % 10 ) * 10 + m << endl;\n\t\t\t\t\t\t\t\t\t\t\t\tcounter += test/2;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t//cout << counter << endl;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//o++;\n\t\t\t\t\t\t\t//}while(o != j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << counter << endl;\n\t\tfor(size_t i = 0; i < count; i++) {\n\t\t\tfor(size_t j = 0; j < 4; j++) {\n\t\t\t\t//cout << a[i][j] << \" \";\n\n\t\t\t}\n\t\t\t//cout << \"\\n\";\n\n\t\t}\n\t\tb = 1;\n\t\tfor(size_t i = 0; i < count; i++) {\n\t\t\tb *= a[i][1] - a[i][0] + 1;\n\t\t}\n\t\t//cout << counter << endl;\n\t\tb -= counter;\n\t\tcout << b << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll sbstr[1000000][6][7];\nll lgt[1000000];\nll pow10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nll cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) sbstr[i][j][k]=stol(s.substr(j,k));\n\t\t}\n\t\tlgt[i]=(ll)s.length();\n\t}\n\tpow10[0]=1;\n\tpow10[1]=10;\n\tpow10[2]=100;\n\tpow10[3]=1000;\n\tpow10[4]=10000;\n\tpow10[5]=100000;\n\treturn;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp1[i+1][sbstr[j][1][lgt[j]-1]]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp1[i+1][sbstr[j][2][lgt[j]-2]]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][1]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp2[i+1-mid][sbstr[j][1][lgt[j]-1]]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][1]!=0&&sbstr[j][0][2]>=el[i].first&&sbstr[j][0][2]<=el[i].second&&dp2[i+1-mid][sbstr[j][2][lgt[j]-2]]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbstr[i][0][j]]&&sbstr[i][j][1]!=0)  {\n\t\t\t\tret-=cnt[sbstr[i][j][lgt[i]-j]];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll _pow(ll a,ll n) {\n\tll ret=1;\n\tREP(i,n) ret*=a;\n\treturn ret;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tvector<vector<bool>> dp1(mid,vector<bool>(1000000,false));\n\tvector<vector<bool>> dp2(n-mid,vector<bool>(1000000,false));\n\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tvector<ll> cnt(1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 1000\n\n\nint main() {\n\tlong long n;\n\tlong long m[15][10][10];\n\tlong long dp[12][4096][10];\n\tlong long lo[7];\n\tlong long hi[7];\n\tlong long p2[15];\n\tlong long x, y, z, s, ans;\n\tp2[0] = 1;\n\tf(i, 14)p2[i + 1] = p2[i] * 2;\n\twhile(true) {\n\t\tans = 0;\n\t\tscanf(\"%lld\", &n);\n\t\tif (n == 0)return 0;\n\t\tf(i, n)scanf(\"%lld %lld\", &lo[i], &hi[i]);\n\t\tf(i, 15) {\n\t\t\tf(ii, 10) {\n\t\t\t\tf(jj, 10)m[i][ii][jj] = 0;\n\t\t\t}\n\t\t}\n\t\tf(i, (2 * n) - 1) {\n\t\t\tf(ii, 10) {\n\t\t\t\tf(jj, 10) {\n\t\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\t\tif (ii == 0)m[i][ii][jj] = 0;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tx = 10 * ii + jj;\n\t\t\t\t\t\t\ty = i / 2;\n\t\t\t\t\t\t\tif ((lo[y] <= x) && (x <= hi[y]))m[i][ii][jj] = p2[i + 1];\n\t\t\t\t\t\t\telse m[i][ii][jj] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tm[i][ii][jj] = 0;\n\t\t\t\t\t\tif (jj != 0) {\n\t\t\t\t\t\tx = jj;\n\t\t\t\t\t\ty = (i + 1) / 2;\n\t\t\t\t\t\tif ((lo[y] <= x) && (x <= hi[y]))m[i][ii][jj] += p2[i + 2];\n\t\t\t\t\t\tx = 10 * jj;\n\t\t\t\t\t\tif ((lo[y] <= (x + 9)) && (x <= hi[y]))m[i][ii][jj] += p2[i + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf(i, 12) {\n\t\t\tf(j, 4096) {\n\t\t\t\tf(ii, 10)dp[i][j][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (long long i = 1; i <= 9; i++) {\n\t\t\tz = 0;\n\t\t\tx = i;\n\t\t\tif ((lo[0] <= x) && (x <= hi[0]))z += 2;\n\t\t\tx = 10 * i;\n\t\t\tif ((lo[0] <= (x + 9)) && (x <= hi[0]))z += 1;\n\t\t\tif (z > 0)dp[0][z][i] = 1;\n\t\t}\n\t\tf(i, 2 * n) {\n\t\t\tf(j, p2[(2 * n)]) {\n\t\t\t\tf(ii, 10) {\n\t\t\t\t\tif (dp[i][j][ii] > 0) {\n\t\t\t\t\t\tf(jj, 10) {\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\tf(iii, 2 * n) {\n\t\t\t\t\t\t\t\tif (x % 2 == 1) {\n\t\t\t\t\t\t\t\t\tif (iii == ((2 * n) - 1)){\n                                     if(jj==0) ans += dp[i][j][ii];\n                                    }\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\ty = (y | m[iii][ii][jj]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tx /= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (y > 0)dp[i + 1][y][jj] += dp[i][j][ii];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll _pow(ll a,ll n) {\n\tll ret=1;\n\tREP(i,n) ret*=a;\n\treturn ret;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tvector<vector<bool>> dp1(mid,vector<bool>(1000000,false));\n\tvector<vector<bool>> dp2(n-mid,vector<bool>(1000000,false));\n\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tvector<ll> cnt(1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\nvector<int> HEAD[NUM];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\ttail_max[i] = max(tail_max[i],tmp);\n\t\t\t\ttail_min[i] = min(tail_min[i],tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\n\t\tHEAD[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()));\n\t}\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\tint tmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int tmp_B = tail_min[b_len]; tmp_B <= tail_max[b_len]; tmp_B++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nunordered_set<int> se;\nvector<string> vs1;\nvector<string> vs2;\nvector<pii> v1,v2;\nvoid foo1(int x,string y){\n\tif(x==v1.size()){\n\t\tvs1.PB(y);\n\t\treturn;\n\t}\n\treep(i,v1[x].F,v1[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo1(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid foo2(int x,string y){\n\tif(x==v2.size()){\n\t\tvs2.PB(y);\n\t\treturn;\n\t}\n\treep(i,v2[x].F,v2[x].S+1){\n\t\tstring t;\n\t\tconvert(i,t);\n\t\t// t1=t1+t;\n\t\tfoo2(x+1,y+t);\n\t\t// t1\n\t}\n}\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tse.clear();\n\t\tint a=n/2;\n\t\tint b=n-a;\n\t\tv1=vector<pii>(a);\n\t\tv2=vector<pii>(b);\n\t\tvs1.clear();\n\t\tvs2.clear();\n\t\trep(i,a) cin>>v1[i].F>>v1[i].S;\n\t\trep(i,b) cin>>v2[i].F>>v2[i].S;\n\t\tfoo1(0,\"\");\n\t\tfoo2(0,\"\");\n\t\tcontinue;\n\t\tcout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\tsort(ALL(vs1));\n\t\tsort(ALL(vs2));\n\t\tvs1.erase(unique(ALL(vs1)),vs1.end());\n\t\tvs2.erase(unique(ALL(vs2)),vs2.end());\n\t\tcout<<vs1.size()<<\" \"<<vs2.size()<<endl;\n\t\treturn;\n\t\trep(i,vs1.size()){\n\t\t\trep(j,vs2.size()){\n\t\t\t\tint t;\n\t\t\t\tconvert(vs1[i]+vs2[j],t);// cout<<vs1[i]+vs2[j]<<endl;\n\t\t\t\tse.insert(t);\n\t\t\t}\n\t\t}\n\t\tcout<<se.size()<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\nvector<vector<bool>> dp1(3,vector<bool>(1000000,false));\nvector<vector<bool>> dp2(3,vector<bool>(1000000,false));\n\n\nll _pow(ll a,ll n) {\n\tif(n==0) return 1;\n\tif(n==1) return 10;\n\tif(n==2) return 100;\n\tif(n==3) return 1000;\n\tif(n==4) return 10000;\n\tif(n==5) return 100000;\n\tif(n==6) return 1000000;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tdp1[i][j]=false;\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tdp2[i-mid][j]=false;\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tvector<ll> cnt(1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n// #define DEBUGGING\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace __init {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n#include \"../debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\ntemplate <size_t Q, size_t Label>\nclass Automaton {\n    \n    template <size_t S>\n    struct BitsetComparator {\n        bool operator()(const bitset<S> &s1, const bitset<S> &s2) {\n            return s1.to_string() < s2.to_string();\n        }\n    };\n    \npublic:\n    using State = ll;\n    using States = bitset<Q>;\n    using StatesComparator = BitsetComparator<Q>;\n    using StatesSet = set<States, StatesComparator>;\n    using Edge = array<V<ll>, Label>;\n    using Edges = V<Edge>;\n\n    ll start;\n    V<ll> finish_v;\n    States finish_states;\n    Edges edges;\n\n    Automaton(ll start, V<ll> finish_v, Edges edges)\n        : start(start),\n          finish_v(finish_v),\n          finish_states(vec2states(finish_v)),\n          edges(edges) \n    {\n    }\n\n    Automaton(ll start, V<ll> finish_v)\n        : Automaton(start, finish_v, Edges(Q)) {}\n\n    void add_edge(ll now, ll nxt, ll label) {\n        // cout << label << \" : \" << now << \" -> \" << nxt << endl;\n        edges[now][label].push_back(nxt); \n    }\n\n    Automaton<Q, Label> nfa2dfa() {\n        StatesSet states_set;\n        StatesSet finish_states_set;\n        queue<States> que;\n        map<States, array<StatesSet, Label>, StatesComparator> dfa_edges;\n        que.push(start_state());\n\n        states_set.insert(start_state());\n\n        while(que.size()) {\n            trans_states(states_set, finish_states_set, que, dfa_edges);\n        }\n\n        return move(create_dfa(states_set, finish_states_set, dfa_edges));\n    }\n\nprivate:\n    // TODO: 前計算したほうが良いかもしれないね\n    States vec2states(const V<ll> &finish_v) {\n        States ret(0);\n        for(ll e : finish_v) ret.set(e, 1);\n        return move(ret);\n    }\n\n    States start_state() { return move(States(0).set(start, 1)); }\n\n    States next_states(const States &now, ll label) {\n        States ret(0);\n        for(ll q = 0; q < Q; q++) {\n            if(!now.test(q)) continue;\n            for(auto nxt : edges[q][label]) {\n                ret.set(nxt, 1);\n            }\n        }\n        return move(ret);\n    }\n\n    void trans_states(StatesSet &states_set,\n                      StatesSet &finish_states_set,\n                      queue<States> &que, \n                      map<States, array<StatesSet, Label>, StatesComparator> &dfa_edges)\n    {\n        States now = que.front();\n        que.pop();\n        \n        for(ll label = 0; label < Label; label++) {\n            auto nxt = next_states(now, label);\n            if(nxt == States(0)) continue;\n            dfa_edges[now][label].insert(nxt);\n            if(states_set.find(nxt) != states_set.end()) continue;\n            states_set.insert(nxt);\n            if((nxt & finish_states).any()) finish_states_set.insert(nxt);\n            que.push(nxt);\n        }\n    }\n\n    map<States, ll, StatesComparator> create_states_id(const StatesSet &states_set) {\n        map<States, ll, StatesComparator> states_id;\n        for(const auto &states : states_set) {\n            auto id = states_id.size();\n            states_id[states] = id;\n        }\n        return move(states_id);\n    }\n\n    Automaton<Q, Label> create_dfa(const StatesSet &states_set,\n                                   const StatesSet &finish_states_set,\n                                   const map<States, array<StatesSet, Label>, StatesComparator> &dedges)\n    {\n        auto states_id = create_states_id(states_set);\n        Edges dfa_edges(states_id.size());\n        for(const auto &ele : dedges) {\n            ll id = states_id[ele.first];\n            for(ll label = 0; label < Label; label++) {\n                for(auto next_states : ele.second[label]) {\n                    dfa_edges[id][label].push_back(states_id[next_states]);\n                }\n            }\n        }\n\n        V<ll> dfa_finish_v;\n        for(const auto &states : finish_states_set) {\n            dfa_finish_v.push_back(states_id[states]);\n        }\n        sort(ALL(dfa_finish_v));\n\n        ll start_id = states_id[start_state()];\n\n        return move(Automaton<Q, Label>(start_id, dfa_finish_v, dfa_edges));\n    }\n};\n\nll get_idx(ll i, ll dnum) {\n    return i * 10 + dnum;\n}\n\nusing Auto = Automaton<256, 10>;\n\nll calc(ll now, const Auto::Edges &edges, V<ll> &memo, const Auto::States &finish) {\n    if(memo[now] != -1) return memo[now];\n    ll val = finish.test(now);\n    for(ll label = 0; label < 10; label++) {\n        const auto &edge = edges[now][label];\n        for(ll nxt : edge) {\n            val += calc(nxt, edges, memo, finish);\n        }\n    }\n    return memo[now] = val;\n}\n\nbool solve() {\n    ll N;\n    cin >> N;\n\n    if(!N) return false;\n\n    V<PLL> ev;\n\n    Auto atm(0, { 10 * N });\n    V<PLL> elev;\n\n    for(ll i = 0; i < N; i++) {\n        ll low, high;\n        cin >> low >> high;\n        elev.emplace_back(low, high);\n    }\n    \n    ll next_node = 0;\n    reverse(ALL(elev));\n    for(ll i = 0; i < N; i++) {\n        ll low, high;\n        tie(low, high) = elev[i];\n        next_node += 10;\n        for(ll j = 1; j <= 9; j++) atm.add_edge(get_idx(i, j), next_node, j);\n        for(ll j = 1; j <= 99; j++) {\n            if(!(low <= j && j <= high)) continue;\n            if(j < 10) atm.add_edge(get_idx(i, 0), next_node, j);\n            else atm.add_edge(get_idx(i, 0), get_idx(i, j / 10), j % 10);\n        }\n    }\n\n    atm = atm.nfa2dfa();\n    V<ll> memo(atm.edges.size() + 10, -1);\n    ll start = atm.start;\n    auto finish_states = atm.finish_states;\n    calc(start, atm.edges, memo, finish_states);\n    cout << memo[start] << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nll dp[13][1<<13][10]; //桁数, 現在のエレベーター,　前の桁 \n\nbool solve(){\n  int n;\n  int low[7], up[7];\n  \n  scanf(\"%d\", &n);\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++) scanf(\"%d%d\", low+i, up+i);\n\n  memset(dp, 0, sizeof(dp));\n\n  dp[0][1][0] = 1;\n\n  for(int i=0;i<n*2;i++){\n    for(int j=0;j<(1<<(2*n+1));j++){\n      for(int k=0;k<10;k++){\n        int next[10] = {};\n\n        for(int l=0;l<n;l++){\n          //1桁目\n          if((1 << (l*2)) & j){\n            for(int x=max(1,low[l]);x<=min(9, up[l]);x++)\n              next[x] |= 1 << (l*2+2);\n            for(int x=max(1,low[l]/10);x<=min(9,up[l]/10);x++)\n              next[x] |= 1 << (l*2+1);\n          }\n          //2桁目\n          if((1 << (l*2+1)) & j){\n            for(int x=max(0,(low[l]-k*10));x<=min(9, up[l]-k*10);x++)\n              next[x] |= 1 << (l*2+2);\n          }\n        }\n\n        for(int l=0;l<10;l++){\n          dp[i+1][next[l]][l] += dp[i][j][k];\n        }\n        \n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(int i=0;i<=n*2;i++)\n    for(int j=0;j<(1<<(2*n));j++)\n      for(int k=0;k<10;k++)\n        ans += dp[i][j + (1<<n*2)][k];\n\n  cout << ans << endl;\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nvoid solve(int n) {\n    vi low(n), high(n);\n    rep (i, n) cin >> low[i] >> high[i];\n\n    vector<vll> dp(2 * n + 1, vll(1 << (2 * n), vl(10)));\n    rep (j, 10) {\n        int ni = 0;\n        if (in(j, low[0], high[0] + 1)) ni |= (1 << 1);\n        if (j != 0 and in(j, low[0] / 10, high[0] / 10 + 1)) ni |= (1 << 0);\n        dp[1][ni][j] = 1;\n    }\n\n    for (int i = 1; i < 2 * n; i++) {\n        rep (j, 1 << (2 * n)) {\n            if (j == 0) continue;\n            rep (k, 10) {\n                if (dp[i][j][k] == 0) continue;\n                rep (nk, 10) {\n                    int nj = 0;\n                    rep (l, 2 * n) {\n                        if ((j & (1 << l)) == 0) continue;\n                        if (l % 2 == 0) {\n                            int val = k * 10 + nk;\n                            if (in(val, low[l / 2], high[l / 2] + 1)) nj |= 1 << (l + 1);\n                        }\n                        else {\n                            if (l != 2 * n - 1) {\n                                if (in(nk, low[(l + 1) / 2], high[(l + 1) / 2] + 1)) nj |= 1 << (l + 2);\n                                if (nk != 0 and in(nk, low[(l + 1) / 2] / 10, high[(l + 1) / 2] / 10 + 1)) nj |= 1 << (l + 1);\n                            }\n                        }\n                    }\n                    dp[i + 1][nj][nk] += dp[i][j][k];\n                }\n            }\n        }\n    }\n\n    // rep1 (i, 2 * n) {\n    //     rep (j, 1 << (2 * n)) {\n    //         rep (k, 10) {\n    //             cout << dp[i][j][k] << \" \";\n    //         }\n    //         cout << endl;\n    //     }\n    //     cout << endl;\n    // }\n\n    ll ans = 0;\n    rep (i, 2 * n + 1) {\n        rep (j, 1 << (2 * n)) {\n            if ((j & (1 << (2 * n - 1))) == 0) continue;\n            rep (k, 10) {\n                ans += dp[i][j][k];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return 0;\n        solve(n);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM];\nint head_table[1000][4][4];\n\nvector<int> state_table[16];\nvector<int> HEAD[NUM],TAIL[NUM];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return;\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\tTAIL[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\tHEAD[i].clear();\n\t\tTAIL[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()),HEAD[i].end());\n\n\t\tsort(TAIL[i].begin(),TAIL[i].end());\n\t\tTAIL[i].erase(unique(TAIL[i].begin(),TAIL[i].end()),TAIL[i].end());\n\t}\n\n\tint common_part_len;\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue;\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){\n\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\ttmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\tfor(int b = 0; b < TAIL[b_len].size(); b++){\n\n\t\t\t\ttmp_B = TAIL[b_len][b];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM]; //長さ別の数字のリスト\nint head_min[NUM],head_max[NUM]; //先頭[len]文字の最小・最大数(A用)\nint tail_min[NUM],tail_max[NUM]; //末尾[len]文字の最小・最大長(B用)\nint head_table[1000][4][4]; //head_table[common_part_len][先頭から切り出す桁数] = 数\n\nvector<int> state_table[16];\nvector<int> HEAD[NUM],TAIL[NUM];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\n//numの先頭len文字の数字を作る\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\n//numの末尾len文字の数字を作る\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\n//数字を作る\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return; //登録済\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\tTAIL[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\t//次の数字を全探索する\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\thead_min[i] = BIG_NUM;\n\t\ttail_min[i] = BIG_NUM;\n\n\t\thead_max[i] = 0;\n\t\ttail_max[i] = 0;\n\n\t\tHEAD[i].clear();\n\t\tTAIL[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\t//前半・後半でグループを作り、あらかじめ数字を作っておく\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()),HEAD[i].end());\n\n\t\tsort(TAIL[i].begin(),TAIL[i].end());\n\t\tTAIL[i].erase(unique(TAIL[i].begin(),TAIL[i].end()),TAIL[i].end());\n\t}\n\n\tint common_part_len; //中央部の長さ:0～3であるはず\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint tmp_A,tmp_B,add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tbool FLG;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\t//中央部の長さと、中央部の数の上限を求める\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue; //Bの長さが不適ならSKIP\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){ //共通部の長さが0\n\n\t\t\t//包除原理の適用不要\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★共通部として考えられる、長さcommon_part_lenの数字を全探索★\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\t//★★★★共通の数字別に数え上げる★★★★\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\t//Aの数字全探索\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\tint tmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\t//★common_numのうち、先頭common_part_len-loopがcommon_numにおけるAの専有部\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){ //tmp_Aが存在しない数字なら不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\t//先頭から現れるべき数字\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\t//Bの数字全探索\n\t\t\tfor(int b = 0; b < TAIL[b_len].size(); b++){ //★★Bは左に数字を付け加えるので0スタート★★\n\n\t\t\t\ttmp_B = TAIL[b];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\t//★common_numのうち、末尾loopがcommon_numにおけるBの専有部\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){ //先頭0は不可\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){ //作れない数字は不可\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){ //★★先頭0は不可★★\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bとして現れるべき数字\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){ //条件を満たす数字がないので、今回のsateは計上しない\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//★中央の数字ごとにdp集計<包除原理>★\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n//1～15の状態の、サブstateをあらかじめ求める関数\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state); //stateにおいて、add_stateがsub stateとして存在\n\t\t\t}\n\t\t}\n\t}\n}\n\n//0～999の数字の、先頭1～3桁の数の事前計算\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){ //数字\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){ //右詰めで数字を配置\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){ //全体の桁数\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\nconst ll INF = 1e9;\n\nint main() {\n\t#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n\t#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\twhile (true) {\n\t\tll n; cin >> n;\n\t\tif (n == 0) break;\n\n\t\tvl low(n), high(n);\n\t\tREP(i, n) cin >> low[i] >> high[i];\n\n\t\tusing vvvl = vector<vvl>;\n\t\tvvvl dp(2 * n + 1, vvl(1 << (2 * n), vl(10, -1)));\n\t\tdp[0][0][0] = 1;\n\t\tREP(i, 2 * n) REP(j, 1 << (2 * n)) REP(k, 10) if (dp[i][j][k] != -1) {\n\t\t\tREP(k_next, 10) { // k : next digit\n\t\t\t\tll j_next = 0;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tif (k_next != 0 && low[0]/10 <= k_next && k_next <= high[0]/10) j_next |= 1 << 0;\n\t\t\t\t\tif (               low[0]    <= k_next && k_next <= high[0])    j_next |= 1 << 1;\n\t\t\t\t} else {\n\t\t\t\t\tREP(l, 2 * n - 1) if ((j >> l) & 1) { // l : ?????????index\n\t\t\t\t\t\tif (l % 2 == 0) {\n\t\t\t\t\t\t\tif (k == high[l / 2] / 10 && k_next > high[(l + 1) / 2] % 10) continue;\n\t\t\t\t\t\t\tif (k == low[l / 2] / 10  && low[(l + 1) / 2] % 10 > k_next) continue;\n\t\t\t\t\t\t\tj_next |= 1 << (l + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (k_next != 0 && low[(l + 1) / 2] / 10 <= k_next && k_next <= high[(l + 1) / 2] / 10) {\n\t\t\t\t\t\t\t\tj_next |= 1 << (l + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (low[(l + 2) / 2] <= k_next && k_next <= high[(l + 2) / 2]) {\n\t\t\t\t\t\t\t\tj_next |= 1 << (l + 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j_next][k_next] = max(0ll, dp[i + 1][j_next][k_next]) + dp[i][j][k];\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(i, 1, 2 * n + 1) FOR(j, 1 << (2 * n - 1), 1 << (2 * n)) REP(k, 10) if(dp[i][j][k] != -1) ans += dp[i][j][k];\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 7\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Info{\n\tint low,high;\n};\n\nint N;\nint POW_2[7],POW_10[7];\nint MIN_LEN[2],MAX_LEN[2];\nInfo info[NUM];\nll dp[2][16];\nmap<int,bool> MAP[2];\nll num_list[2][NUM];\nint head_table[1000][4][4];\n\nvector<int> state_table[16];\nvector<int> HEAD[NUM],TAIL[NUM];\n\nint get_length(ll num){\n\n\tif(num == 0){\n\t\treturn 1;\n\t}\n\n\tint ret = 0;\n\n\twhile(num > 0){\n\t\tnum /= 10;\n\t\tret++;\n\t}\n\n\treturn ret;\n}\n\nint substr_front(int num,int tmp_len,int cut_len){\n\n\tnum /= POW_10[tmp_len-cut_len];\n\treturn num;\n}\n\nint substr_tail(int num,int len){\n\tnum %= POW_10[len];\n\treturn num;\n}\n\nvoid recursive(Type type,int index,int finish_index,int num){\n\n\tint tmp_length;\n\n\tif(index == finish_index+1){\n\n\t\tauto at = MAP[type].find(num);\n\t\tif(at != MAP[type].end())return;\n\n\t\tMAP[type][num] = true;\n\t\ttmp_length = get_length(num);\n\t\tMAX_LEN[type] = max(MAX_LEN[type],tmp_length);\n\t\tMIN_LEN[type] = min(MIN_LEN[type],tmp_length);\n\t\tnum_list[type][tmp_length] += 1;\n\n\t\tint tmp;\n\n\t\tif(type == A){\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_front(num,tmp_length,i);\n\t\t\t\tHEAD[i].push_back(tmp);\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = 1; i <= tmp_length; i++){\n\t\t\t\ttmp = substr_tail(num,i);\n\t\t\t\tTAIL[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint tmp_num,tmp_len,next_num;\n\n\tfor(int i = info[index].low; i <= info[index].high; i++){\n\t\ttmp_len = get_length(i);\n\t\tnext_num = num*POW_10[tmp_len]+i;\n\t\trecursive(type,index+1,finish_index,next_num);\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tdp[A][i] = 0;\n\t\tdp[B][i] = 0;\n\t}\n}\n\nbool rangeCheck(int num_B){\n\tif(num_B >= MIN_LEN[B] && num_B <= MAX_LEN[B]){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tMAP[A].clear();\n\tMAP[B].clear();\n\n\tfor(int i = 1; i < NUM; i++){\n\t\tnum_list[A][i] = 0;\n\t\tnum_list[B][i] = 0;\n\n\t\tHEAD[i].clear();\n\t\tTAIL[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].low,&info[i].high);\n\t}\n\n\tMIN_LEN[A] = BIG_NUM;\n\tMIN_LEN[B] = BIG_NUM;\n\n\tMAX_LEN[A] = -1;\n\tMAX_LEN[B] = -1;\n\n\trecursive(A,0,N/2-1,0);\n\trecursive(B,N/2,N-1,0);\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tsort(HEAD[i].begin(), HEAD[i].end());\n\t\tHEAD[i].erase(unique(HEAD[i].begin(),HEAD[i].end()),HEAD[i].end());\n\n\t\tsort(TAIL[i].begin(),TAIL[i].end());\n\t\tTAIL[i].erase(unique(TAIL[i].begin(),TAIL[i].end()),TAIL[i].end());\n\t}\n\n\tint common_part_len;\n\tint common_max;\n\n\tll ans = 0;\n\n\tbool is_First;\n\tint A_min,A_max,B_min,B_max;\n\tint add_A_len,add_B_len,part_num,tmp_num;\n\tint num_bit,a_len,b_len,tmp_state;\n\n\tfor(int total_len = MIN_LEN[A]+MIN_LEN[B]; total_len <= MAX_LEN[A]+MAX_LEN[B]; total_len++){\n\n\t\tis_First = true;\n\t\tfor(int a = MIN_LEN[A]; a <= min(MAX_LEN[A],total_len); a++){\n\n\t\t\tif(!rangeCheck(total_len-a))continue;\n\n\t\t\tif(is_First){\n\n\t\t\t\tA_min = a;\n\t\t\t\tA_max = a;\n\n\t\t\t\tB_min = total_len-a;\n\t\t\t\tB_max = total_len-a;\n\t\t\t\tis_First = false;\n\t\t\t}else{\n\t\t\t\tA_max = a;\n\t\t\t\tB_min = total_len-a;\n\t\t\t}\n\t\t}\n\n\t\tcommon_part_len = A_max-A_min;\n\n\t\tif(common_part_len == 0){\n\n\t\t\tll count_A = num_list[A][A_min];\n\t\t\tll count_B = num_list[B][B_max];\n\n\t\t\tans += count_A*count_B;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tcommon_max = POW_10[common_part_len]-1;\n\n\t\tfor(int common_num = 0; common_num <= common_max; common_num++){\n\n\t\t\tinit_dp();\n\n\t\t\ta_len = A_min;\n\n\t\t\tfor(int a = 0; a < HEAD[a_len].size(); a++){\n\n\t\t\t\tint tmp_A = HEAD[a_len][a];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\tadd_A_len = common_part_len-loop;\n\n\t\t\t\t\tif(add_A_len == 0){\n\t\t\t\t\t\tauto at = MAP[A].find(tmp_A);\n\t\t\t\t\t\tif(at == MAP[A].end()){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = head_table[common_num][common_part_len][add_A_len];\n\n\t\t\t\t\ttmp_num = tmp_A*POW_10[add_A_len]+part_num;\n\n\t\t\t\t\tauto at = MAP[A].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[A].end()){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[A][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb_len = B_min;\n\n\t\t\tfor(int b = 0; b < TAIL[b_len].size(); b++){\n\n\t\t\t\ttmp_B = TAIL[b_len][b];\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\n\t\t\t\t\tadd_B_len = loop;\n\n\t\t\t\t\tif(add_B_len == 0){\n\t\t\t\t\t\tif(tmp_B < POW_10[b_len-1]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto at = MAP[B].find(tmp_B);\n\t\t\t\t\t\tif(at == MAP[B].end()){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpart_num = substr_tail(common_num,add_B_len);\n\n\t\t\t\t\tif(part_num < POW_10[add_B_len-1]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp_num = part_num*POW_10[b_len]+tmp_B;\n\n\t\t\t\t\tauto at = MAP[B].find(tmp_num);\n\n\t\t\t\t\tif(at == MAP[B].end()){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_state += POW_2[loop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < state_table[tmp_state].size(); i++){\n\t\t\t\t\tdp[B][state_table[tmp_state][i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int state = 1; state < POW_2[common_part_len+1]; state++){\n\n\t\t\t\tnum_bit = 0;\n\n\t\t\t\tfor(int loop = 0; loop < common_part_len+1; loop++){\n\t\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t\tnum_bit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num_bit%2 == 1){\n\n\t\t\t\t\tans += dp[A][state]*dp[B][state];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tans -= dp[A][state]*dp[B][state];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nvoid make_state_table(){\n\n\tbool check[4];\n\tbool FLG;\n\n\tfor(int state = 1; state < 16; state++){\n\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int add_state = 1; add_state < 16; add_state++){\n\t\t\tFLG = true;\n\t\t\tfor(int loop = 0; loop < 4; loop++){\n\t\t\t\tif(add_state & (1 << loop)){\n\t\t\t\t\tif(!check[loop]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tstate_table[state].push_back(add_state);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tint work[3],tmp;\n\tstack<int> S;\n\n\tfor(int num = 0; num <= 999; num++){\n\n\t\ttmp = num;\n\n\t\tfor(int i = 2; i >= 0; i--){\n\t\t\twork[i] = tmp%10;\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tfor(int common_part_len = 1; common_part_len <= 3; common_part_len++){\n\t\t\tfor(int head_len = 1; head_len <= common_part_len; head_len++){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; k < head_len; k++){\n\t\t\t\t\ttmp = 10*tmp+work[3-common_part_len+k];\n\t\t\t\t}\n\t\t\t\thead_table[num][common_part_len][head_len] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tPOW_2[i] = pow(2,i);\n\t\tPOW_10[i] = pow(10,i);\n\t}\n\n\tmakeTable();\n\n\tmake_state_table();\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef long long LL;\ntypedef array<int,10> ai10;\n\nstruct info{\n\tint cnt;\n\tLL val;\n\tai10 to;\n\t\n\tinfo() : cnt{}, val{}, to{} {}\n};\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<int> low(n), high(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d\", &low[i], &high[i]);\n\t\t}\n\t\t\n\t\tvector<ai10> to(4 * n + 1);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < 10; ++j){\n\t\t\t\tto[i * 4 + 2][j] |= 1 << (i * 4 + 4);\n\t\t\t}\n\t\t\n\t\t\tint ld = (low[i] + 9) / 10 * 10;\n\t\t\tint hd = high[i] / 10 * 10;\n\t\t\tfor(int j = ld; j < hd; j += 10){\n\t\t\t\tto[i * 4][j / 10] |= 1 << (i * 4 + 2);\n\t\t\t}\n\t\t\tfor(int j = min(ld - 1, high[i]); j >= low[i]; --j){\n\t\t\t\tint s;\n\t\t\t\tif(j < 10){\n\t\t\t\t\ts = i * 4;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts = i * 4 + 1;\n\t\t\t\t\tto[i * 4][j / 10] |= 1 << s;\n\t\t\t\t}\n\t\t\t\tto[s][j % 10] |= 1 << (i * 4 + 4);\n\t\t\t}\n\t\t\tfor(int j = max(hd, low[i]); j <= high[i]; ++j){\n\t\t\t\tint s;\n\t\t\t\tif(j < 10){\n\t\t\t\t\ts = i * 4;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts = i * 4 + 3;\n\t\t\t\t\tto[i * 4][j / 10] |= 1 << s;\n\t\t\t\t}\n\t\t\t\tto[s][j % 10] |= 1 << (i * 4 + 4);\n\t\t\t}\n\t\t}\n\n\t\tmap<int,info> mp;\n\t\tmp[0].cnt = 1010101010;\n\t\tmp[1].val = 1;\n\t\tqueue<int> q;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint s = q.front();\n\t\t\tinfo &in = mp[s];\n\t\t\tq.pop();\n\t\t\tfor(int d = 0; d < 10; ++d){\n\t\t\t\tint t = 0;\n\t\t\t\tfor(size_t i = 0; i < to.size(); ++i){\n\t\t\t\t\tif(s >> i & 1){\n\t\t\t\t\t\tt |= to[i][d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tin.to[d] = t;\n\t\t\t\tif(++mp[t].cnt == 1){\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLL ans = 0;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint s = q.front();\n\t\t\tq.pop();\n\t\t\tinfo &in1 = mp[s];\n\t\t\t\n\t\t\tif(s >> (n * 4) & 1){\n\t\t\t\tans += in1.val;\n\t\t\t}\n\t\t\tfor(int d = 0; d < 10; ++d){\n\t\t\t\tinfo &in2 = mp[in1.to[d]];\n\t\t\t\tin2.val += in1.val;\n\t\t\t\tif(--in2.cnt == 0){\n\t\t\t\t\tq.push(in1.to[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nvector<int> sbstr[1000000][6];\nint lgt[1000000];\nint pow_10[6];\nbool dp1[3][1000000];\nbool dp2[3][1000000];\nint cnt[1000000];\n\nvoid init() {\n\tREP(i,1000000) {\n\t\tstring s=to_string(i);\n\t\tREP(j,(ll)s.length()) {\n\t\t\tfor(ll k=1; j+k<=(ll)s.length(); k++) sbstr[i][j].push_back(stoi(s.substr(j,k)));\n\t\t}\n\t\tlgt[i]=(int)s.length();\n\t}\n\tpow_10[0]=1;\n\tpow_10[1]=10;\n\tpow_10[2]=100;\n\tpow_10[3]=1000;\n\tpow_10[4]=10000;\n\tpow_10[5]=100000;\n\treturn;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tfill(dp1[0],dp1[3],false);\n\tfill(dp2[0],dp2[3],false);\n\tfill(cnt,cnt+1000000,0);\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][0]!=0&&sbstr[j][0][0]>=el[i].first&&sbstr[j][0][0]<=el[i].second&&dp1[i+1][sbstr[j][1][lgt[j]-2]]) dp1[i][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][0]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp1[i+1][sbstr[j][2][lgt[j]-3]]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tif(lgt[j]>1&&sbstr[j][1][0]!=0&&sbstr[j][0][0]>=el[i].first&&sbstr[j][0][0]<=el[i].second&&dp2[i+1-mid][sbstr[j][1][lgt[j]-2]]) dp2[i-mid][j]=true;\n\t\t\t\tif(lgt[j]>2&&sbstr[j][2][0]!=0&&sbstr[j][0][1]>=el[i].first&&sbstr[j][0][1]<=el[i].second&&dp2[i+1-mid][sbstr[j][2][lgt[j]-3]]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tfor(ll i=1; i<1000000; i++) {\n\t\tfor(ll j=1; j<pow_10[6-lgt[i]]; j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][i*pow_10[lgt[j]]+j]) cnt[i]++;\n\t\t}\n\t}\n\tREP(i,1000000) if(dp2[0][i]) sum++;\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\tfor(ll j=1;j<lgt[i];j++) {\n\t\t\tif(dp1[0][sbstr[i][0][j-1]]&&sbstr[i][j][0]!=0)  {\n\t\t\t\tret-=cnt[sbstr[i][j][lgt[i]-j-1]];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tinit();\n\t/*\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve(n)<<endl;\n\t}\n\t */\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstring>\n#define pb push_back\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pipii;\ntypedef long long ll;\nmap<pii,int > dfa;\nmap<int,ll> memo;\nvector<int> nfa[100][100];\nqueue<int > que;\nint N,low[10],high[10],nfafin;\nset<int> used,dfafin;\n\nvoid makeNFA(){\n  int i,j,k;\n  for(i=0;i<N;i++){\n    if(low[i]/10==high[i]/10){\n      if(low[i]<10){\n\tfor(j=low[i]%10;j<=high[i]%10;j++)\n\t  nfa[i*4][j].pb(i*4+4);\n      }else{\n\tnfa[i*4][low[i]/10].pb(i*4+1);\n\tfor(j=low[i]%10;j<=high[i]%10;j++)\n\t  nfa[i*4+1][j].pb(i*4+4);\n      }\n    }else{\n      if(low[i]<10){\n\tfor(j=low[i]%10;j<10;j++)\n\t  nfa[i*4][j].pb(i*4+4);\n      }else{\n\tnfa[i*4][low[i]/10].pb(i*4+1);\n\tfor(j=low[i]%10;j<10;j++)\n\t  nfa[i*4+1][j].pb(i*4+4);\n      }\n\n      for(j=low[i]/10+1;j<high[i]/10;j++){\n\tnfa[i*4][j].pb(i*4+2);\n      }\n      if(high[i]/10-low[i]/10>1)for(k=0;k<10;k++)\n\tnfa[i*4+2][k].pb(i*4+4);\n      \n      nfa[i*4][high[i]/10].pb(i*4+3);\n      for(k=0;k<=high[i]%10;k++)\n\tnfa[i*4+3][k].pb(i*4+4);\n    }\n  }\n  nfafin=4*N;\n  return;\n}\n\nvoid makeDFA(){\n  int i,j,k;\n  que.push(1);\n  while(!que.empty()){\n    int cur=que.front();que.pop();\n    int to=0;\n    for(int in=0;in<10;in++){\n      to=0;\n      for(i=0;i<30;i++){\n\tif(cur&(1<<i)){\n\t  for(j=0;j<nfa[i][in].size();j++)\n\t    to|=(1<<nfa[i][in][j]);\n\t}\n      }\n      if(to==0)continue;\n      if(used.count(to)==0){\n\tused.insert(to);\n\tque.push(to);\n      }\n      dfa[pii(cur,to)]++;\n    }\n  }\n  return;\n}\n\nll dfs(int pos){\n  if(pos == (1<<nfafin))\n    return 1;\n  if(memo.count(pos))\n    return memo[pos];\n  ll re=0;\n  map<pii,int>::iterator it;\n  it=dfa.lower_bound(pii(pos,0));\n  for(;it!=dfa.end();++it){\n    if(it->X.X!=pos)break;\n    re+=(it->Y)*dfs(it->X.Y);\n  }\n  return memo[pos]=re+!!(pos&(1<<nfafin));\n}\n\nint main(){\n  int i,j,k;\n  while(1){\n    cin>>N;\n    if(N==0)break;\n\n    dfa.clear();memo.clear();\n    for(i=0;i<100;i++)for(j=0;j<100;j++)nfa[i][j].clear();\n    while(!que.empty())que.pop();\n    used.clear(),dfafin.clear();\n\n    for(i=0;i<N;++i)\n      cin>>low[i]>>high[i];\n    // cout<<N<<endl;\n    makeNFA();\n    /*    for(i=0;i<100;i++)for(j=0;j<100;j++){\n\tif(nfa[i][j].size()){\n\t  cout<<i<<\",\"<<j<<\":\";\n\t  for(k=0;k<nfa[i][j].size();k++)\n\t    cout<<nfa[i][j][k]<<\",\";\n\t  cout<<endl;\n\t}\n\t}*/\n    makeDFA();/*\n    for(map<pii,int>::iterator it=dfa.begin();it!=dfa.end();++it)\n    cout<<it->X.X<<\",\"<<it->X.Y<<\",\"<<it->Y<<endl;*/\n    cout<<dfs(1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\nstring buf=\"\";\n\nll _pow(ll a,ll n) {\n\tll ret=1;\n\tREP(i,n) ret*=a;\n\treturn ret;\n}\n\nll solve(ll n) {\n\tvector<pair<ll,ll>> el(n);\n\tREP(i,n) cin>>el[i].first>>el[i].second;\n\tll mid = n/2;\n\tvector<vector<bool>> dp1(mid,vector<bool>(1000000,false));\n\tvector<vector<bool>> dp2(n-mid,vector<bool>(1000000,false));\n\t\n\tfor(ll i=mid-1; i>=0; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==mid-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp1[i][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp1[i+1][stol(buf.substr(1,(ll)buf.length()-1))]) dp1[i][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp1[i+1][stol(buf.substr(2,(ll)buf.length()-2))]) dp1[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=n-1; i>=mid; i--) {\n\t\tfor(ll j=0; j<1000000; j++) {\n\t\t\tif(i==n-1) {\n\t\t\t\tif(el[i].first<=j&&el[i].second>=j) dp2[i-mid][j]=true;\n\t\t\t} else {\n\t\t\t\tbuf=to_string(j);\n\t\t\t\tif((ll)buf.length()>1&&buf[1]!='0'&&stol(buf.substr(0,1))>=el[i].first&&stol(buf.substr(0,1))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(1,(ll)buf.length()-1))]) dp2[i-mid][j]=true;\n\t\t\t\tif((ll)buf.length()>2&&buf[2]!='0'&&stol(buf.substr(0,2))>=el[i].first&&stol(buf.substr(0,2))<=el[i].second&&dp2[i+1-mid][stol(buf.substr(2,(ll)buf.length()-2))]) dp2[i-mid][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tll sum=0;\n\tvector<ll> cnt(1000000,0);\n\tfor(ll i=1; i<1000000; i++) {\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<_pow(10,6-(ll)buf.size());j++) {\n\t\t\tif(!dp2[0][j]) continue;\n\t\t\tif(dp2[0][stol(buf+to_string(j))]) {\n\t\t\t\t//cout<<i<<\" \"<<stol(buf+to_string(j))<<endl;\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,1000000) if(dp2[0][i]) {\n\t\tsum++;\n\t\t//cout<<i<<endl;\n\t}\n\tREP(i,1000000) {\n\t\tif(!dp1[0][i]) continue;\n\t\tret+=sum;\n\t\t//cout<<i<<\" \"<<ret<<endl;\n\t\tbuf=to_string(i);\n\t\tfor(ll j=1; j<(ll)buf.size();j++) {\n\t\t\tif(dp1[0][stol(buf.substr(0,j))]&&buf[j]!='0')  {\n\t\t\t\t//cout<<j<<endl;\n\t\t\t\tret-=cnt[stol(buf.substr(j,(ll)buf.size()-j))];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<ret<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\ntypedef vector<vector<pii> > Graph;\n\nmap<pii, int> NFAtoDFA(Graph &g){\n\tint n = g.size();\n\tvi vis(1<<n);\n\tvis[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\tmap<pii, int> G;\n\twhile(!q.empty()){\n\t\tint i = q.front();\n\t\tq.pop();\n\t\tREP(j, 10){\n\t\t\tint tar = 0;\n\t\t\tREP(k, n){\n\t\t\t\tif(((i>>k)&1) == 0) continue;\n\t\t\t\tFOR(e, g[k]){\n\t\t\t\t\tif(e->second & (1<<j)) tar |= 1<<e->first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tar){\n\t\t\t\tG[pii(i, tar)] ++;\n\t\t\t\tif(!vis[tar]){\n\t\t\t\t\tvis[tar] = 1;\n\t\t\t\t\tq.push(tar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn G;\n}\n\nll dfs(int s, unordered_map<int, ll> &memo, map<pii, int> &G, int accept){\n\tif(memo[s]) return memo[s];\n\tauto it = G.lower_bound(pii(s, 0));\n\tauto it2 = G.lower_bound(pii(s+1, 0));\n\tll res = !!(s&accept);\n\tfor(;it!=it2;++it){\n\t\tres += it->second * dfs(it->first.second, memo, G, accept);\n\t}\n\treturn memo[s] = res;\n}\n\nmain(){\n\twhile(cin >> n, n){\n\t\tint low[6], hi[6];\n\t\tREP(i, n) cin >> low[i] >> hi[i];\n\t\tGraph g(n*4+1);\n\t\tREP(i, n){\n\t\t\tif(low[i]/10 == hi[i]/10){\n\t\t\t\tint ev = 0;\n\t\t\t\tREP(j, 10) if(low[i]%10 <= j && j <= hi[i]%10) ev |= 1<<j;\n\t\t\t\tif(low[i] < 10){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+4, ev));\n\t\t\t\t}else{\n\t\t\t\t\tg[4*i].push_back(pii(4*i+1, 1<<(low[i]/10)));\n\t\t\t\t\tg[4*i+1].push_back(pii(4*i+4, ev));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint ev = 0;\n\t\t\t\tREP(j, 10) if(low[i]%10 <= j) ev |= 1<<j;\n\t\t\t\tif(low[i] < 10){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+4, ev));\n\t\t\t\t}else{\n\t\t\t\t\tg[4*i].push_back(pii(4*i+1, 1<<(low[i]/10)));\n\t\t\t\t\tg[4*i+1].push_back(pii(4*i+4, ev));\n\t\t\t\t}\t\n\n\t\t\t\tev = 0;\n\t\t\t\tREP(j, 10) if(low[i]/10 < j && j < hi[i]/10) ev |= 1<<j;\n\t\t\t\tif(ev){\n\t\t\t\t\tg[4*i].push_back(pii(4*i+2, ev));\n\t\t\t\t\tg[4*i+2].push_back(pii(4*i+4, (1<<10)-1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tev = 0;\n\t\t\t\tREP(j, 10) if(hi[i]%10 >= j) ev |= 1<<j;\n\t\t\t\tg[4*i].push_back(pii(4*i+3, 1<<(hi[i]/10)));\n\t\t\t\tg[4*i+3].push_back(pii(4*i+4, ev));\n\t\t\t}\n\t\t}\n\t\tmap<pii, int> g2 = NFAtoDFA(g);\n\t\tunordered_map<int, ll> memo;\n\t\tcout << dfs(1, memo, g2, 1<<(4*n)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long dp[13][1<<18];\nint L[10];\nint R[10];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d\",L+i,R+i);\n\t\t}\n\t\tfor(int i=0;i<13;i++)for(int j=0;j<(1<<(a*3));j++)dp[i][j]=0;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint to=0;\n\t\t\tif(L[0]<=i&&i<=R[0])to+=1;\n\t\t\tif((L[0]/10<=i&&i<R[0]/10)||(L[0]/10==R[0]/10&&i==L[0]/10))to+=2;\n\t\t\tif(L[0]/10<i&&i<=R[0]/10)to+=4;\n\t\t\tdp[1][to]++;\n\t\t}\n\t\tfor(int i=1;i<a*2;i++){\n\t\t\tfor(int j=0;j<(1<<(a*3));j++){\n\t\t\t\tif(!dp[i][j])continue;\n\t\t\t\tif(!j)continue;\n\t\t\t//\tprintf(\"%d %d: %lld\\n\",i,j,dp[i][j]);\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tint to=0;\n\t\t\t\t\tfor(int l=0;l<a*3;l++){\n\t\t\t\t\t\tif(!(j&(1<<l)))continue;\n\t\t\t\t\t\tif(l==a*3-3)continue;\n\t\t\t\t\t\tif(l%3==0){\n\t\t\t\t\t\t\tif(k==0)continue;\n\t\t\t\t\t\t\tif(L[l/3+1]<=k&&k<=R[l/3+1])to|=(1<<(l+3));\n\t\t\t\t\t\t\tif((L[l/3+1]/10<=k&&k<R[l/3+1]/10)||(L[l/3+1]/10==R[l/3+1]/10&&k==L[l/3+1]/10))to|=(1<<(l+4));\n\t\t\t\t\t\t\tif(L[l/3+1]/10<k&&k<=R[l/3+1]/10)to|=(1<<(l+5));\n\t\t\t\t\t\t}else if(l%3==1&&(j&(1<<(l+1)))){\n\t\t\t\t\t\t\tto|=(1<<(l-1));\n\t\t\t\t\t\t}else if(l%3==1){\n\t\t\t\t\t\t\tif(L[l/3]/10==R[l/3]/10){\n\t\t\t\t\t\t\t\tif(L[l/3]%10<=k&&k<=R[l/3]%10)to|=(1<<(l-1));\n\t\t\t\t\t\t\t}else if(L[l/3]%10<=k)to|=(1<<(l-1));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(k<=R[l/3]%10)to|=(1<<(l-2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(to)dp[i+1][to]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<=a*2;i++){\n\t\t\tfor(int j=0;j<(1<<(a*3));j++){\n\t\t\t\tif(j&(1<<(a*3-3)))ret+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint N;\nint lo[6],hi[6];\nll dp[2][1<<6][1<<6][1<<6][10];\nbool match0[6][10];\nbool match1[6][10];\nbool match2[6][10][10];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    memset(match0,0,sizeof(match0)); memset(match1,0,sizeof(match1)); memset(match2,0,sizeof(match2));\n    rep(i,N){\n      cin>>lo[i]>>hi[i];\n      repl(j,lo[i],hi[i]+1){\n        if(j>=10){\n          match0[i][j/10]=true;\n          match2[i][j/10][j%10]=true;\n        }\n        if(j<10)match1[i][j]=true;\n      }\n    }\n    int crt=0,nxt=1;\n    rep(s0,1<<N)rep(s1,1<<N)rep(s2,1<<N)rep(j,10)dp[crt][s0][s1][s2][j]=0;\n    dp[crt][1][1][0][0]=1;\n    ll res=0;\n    rep(i,N*2){\n      rep(s0,1<<N)rep(s1,1<<N)rep(s2,1<<N)rep(j,10)dp[nxt][s0][s1][s2][j]=0;\n      rep(s0,1<<N)rep(s1,1<<N)rep(s2,1<<N)rep(j,10){\n        if(dp[crt][s0][s1][s2][j]==0)continue;\n        rep(d,10){\n          ll ns0=0,ns1=0,ns2=0;\n          bool done=false;\n          rep(l,N){\n            if(((s0>>l)&1)&&match0[l][d]){\n              ns2|=(1<<l);\n            }\n            if(((s1>>l)&1)&&match1[l][d]){\n              if(l<N-1){\n                ns0|=(1<<(l+1)); ns1|=(1<<(l+1));\n              }else{\n                done=true;\n              }\n            }\n            if(((s2>>l)&1)&&match2[l][j][d]){\n              if(l<N-1){\n                ns0|=(1<<(l+1)); ns1|=(1<<(l+1));\n              }else{\n                done=true;\n              }\n            }\n          }\n\n          dp[nxt][ns0][ns1][ns2][d]+=dp[crt][s0][s1][s2][j];\n          if(done)res+=dp[crt][s0][s1][s2][j];\n        }\n      }\n      swap(crt,nxt);\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] hi, lo;\n\tstatic int[] pow10 = new int[8];\n\n\tpublic static void main(String[] args) {\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; ++i) {\n\t\t\tpow10[i] = pow10[i - 1] * 10;\n\t\t}\n\t\twhile (sc.hasNext()) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\thi = new int[N];\n\t\t\tlo = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tlo[i] = sc.nextInt();\n\t\t\t\thi[i] = sc.nextInt();\n\t\t\t}\n\t\t\tlong ans = solve();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tboolean[] first = new boolean[1000000];\n\t\tboolean[] second = new boolean[1000000];\n\t\tenumerate(0, 0, N / 2, first);\n\t\tenumerate(0, N / 2, N, second);\n\t\tlong ret = 0;\n\t\tfor (int i = N; i <= 2 * N; ++i) {\n\t\t\tret += solveDigits(i, first, second);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic void enumerate(int cur, int idx, int ei, boolean[] bitmap) {\n\t\tif (idx == ei) {\n\t\t\tbitmap[cur] = true;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = lo[idx]; i <= Math.min(hi[idx], 9); ++i) {\n\t\t\tenumerate(cur * 10 + i, idx + 1, ei, bitmap);\n\t\t}\n\t\tfor (int i = Math.max(10, lo[idx]); i <= hi[idx]; ++i) {\n\t\t\tenumerate(cur * 100 + i, idx + 1, ei, bitmap);\n\t\t}\n\t}\n\n\t// 全体がdigits桁あるパターン数を数える\n\tstatic long solveDigits(int digits, boolean[] first, boolean[] second) {\n\t\tlong ret = 0;\n\t\tint fFix = Math.max(N / 2, digits - (N - N / 2) * 2); // 必ず前半部になる桁数\n\t\tint sFix = Math.max(N - N / 2, digits - (N / 2) * 2); // 必ず後半部になる桁数\n\t\tint center = digits - fFix - sFix;\n\t\tif (center == 0) {\n\t\t\tlong fc = 0;\n\t\t\tlong sc = 0;\n\t\t\tfor (int i = pow10[fFix - 1]; i < pow10[fFix]; ++i) {\n\t\t\t\tif (first[i]) ++fc;\n\t\t\t}\n\t\t\tfor (int i = pow10[sFix - 1]; i < pow10[sFix]; ++i) {\n\t\t\t\tif (second[i]) ++sc;\n\t\t\t}\n\t\t\treturn fc * sc;\n\t\t}\n\n\t\tfor (int i = 0; i < pow10[center]; ++i) {\n\t\t\tint[] fb = new int[pow10[fFix]];\n\t\t\tint[] sb = new int[pow10[sFix]];\n\t\t\tfor (int j = 0; j <= center; ++j) { // 中央部の値がiであり、うち初めのj桁が前半部に含まれる場合\n\t\t\t\tint cf = i / pow10[center - j];\n\t\t\t\tint cs = i % pow10[center - j];\n\t\t\t\tint fd = fFix + j;\n\t\t\t\tfor (int k = pow10[fd - 1] + cf; k < pow10[fd]; k += pow10[j]) {\n\t\t\t\t\tif (first[k]) {\n\t\t\t\t\t\tfb[k / pow10[j]] |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != center && cs < pow10[center - j - 1]) {\n\t\t\t\t\tcontinue; // 後半部がleading zeroになっている\n\t\t\t\t}\n\t\t\t\tfor (int k = (j == center ? pow10[sFix - 1] : 0); k < pow10[sFix]; ++k) {\n\t\t\t\t\tif (second[k + cs * pow10[sFix]]) {\n\t\t\t\t\t\tsb[k] |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// inclusion-exclusion\n\t\t\tfor (int j = 1; j < (1 << (center + 1)); ++j) {\n\t\t\t\tlong fc = 0;\n\t\t\t\tlong sc = 0;\n\t\t\t\tfor (int k = 0; k < fb.length; ++k) {\n\t\t\t\t\tif ((fb[k] & j) == j) ++fc;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < sb.length; ++k) {\n\t\t\t\t\tif ((sb[k] & j) == j) ++sc;\n\t\t\t\t}\n\t\t\t\tlong count = fc * sc;\n\t\t\t\tret += Integer.bitCount(j) % 2 == 0 ? -count : count;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tstatic int N;\n\tstatic int[] low, high;\n\tstatic boolean[] f, s;\n\tstatic int[] pow = new int[8];\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tpow[0] = 1;\n\t\tfor (int i = 1; i < pow.length; ++i) {\n\t\t\tpow[i] = pow[i - 1] * 10;\n\t\t}\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tlow = new int[N];\n\t\t\thigh = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tlow[i] = sc.nextInt();\n\t\t\t\thigh[i] = sc.nextInt();\n\t\t\t}\n\t\t\tf = new boolean[pow[6]];\n\t\t\ts = new boolean[pow[6]];\n\t\t\tdfs(0, N / 2, f, 0);\n\t\t\tdfs(N / 2, N, s, 0);\n\t\t\tlong ans = 0;\n\t\t\tfor (int L = N; L <= 2 * N; ++L) {\n\t\t\t\tans += solve(L);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic long solve(int length) {\n\t\tint fFix = Math.max(length - (N - N / 2) * 2, N / 2);\n\t\tint sFix = Math.max(length - N / 2 * 2, N - N / 2);\n\t\tint middleLen = length - fFix - sFix;\n\t\tif (middleLen == 0) {\n\t\t\tlong sc = 0, fc = 0;\n\t\t\tfor (int i = pow[fFix - 1]; i < pow[fFix]; ++i) {\n\t\t\t\tif (f[i])\n\t\t\t\t\t++sc;\n\t\t\t}\n\t\t\tfor (int i = pow[sFix - 1]; i < pow[sFix]; ++i) {\n\t\t\t\tif (s[i])\n\t\t\t\t\t++fc;\n\t\t\t}\n\t\t\treturn sc * fc;\n\n\t\t} else {\n\t\t\tlong ret = 0;\n\t\t\tfor (int middle = 0; middle < pow[middleLen]; ++middle) {\n\t\t\t\tboolean[][] fok = new boolean[middleLen + 1][pow[fFix]];\n\t\t\t\tboolean[][] sok = new boolean[middleLen + 1][pow[sFix]];\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tint add = pow[i];\n\t\t\t\t\tint res = middle / pow[middleLen - i];\n\t\t\t\t\tfor (int cur = res + pow[fFix + i - 1]; cur < pow[fFix + i]; cur += add) {\n\t\t\t\t\t\tif (f[cur])\n\t\t\t\t\t\t\tfok[i][cur / pow[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tif (i > 0 && middle % pow[i] / pow[i - 1] == 0) {// leading0\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = middle % pow[i] * pow[sFix];\n\t\t\t\t\tfor (int cur = res; cur < res + pow[sFix]; cur++) {\n\t\t\t\t\t\tif (s[cur])\n\t\t\t\t\t\t\tsok[middleLen - i][cur % pow[sFix]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < (1 << (middleLen + 1)); ++i) {\n\t\t\t\t\tlong fc = 0;\n\t\t\t\t\tlong sc = 0;\n\t\t\t\t\tout: for (int j = pow[fFix - 1]; j < pow[fFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !fok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++fc;\n\t\t\t\t\t}\n\t\t\t\t\tout: for (int j = 0; j < pow[sFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !sok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++sc;\n\t\t\t\t\t}\n\t\t\t\t\tret += fc * sc * (Integer.bitCount(i) % 2 == 1 ? 1 : -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic void dfs(int curIdx, int endIdx, boolean[] arr, int sum) {\n\t\tif (curIdx == endIdx) {\n\t\t\tarr[sum] = true;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = low[curIdx]; i <= Math.min(9, high[curIdx]); ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 10 + i);\n\t\t}\n\t\tfor (int i = Math.max(10, low[curIdx]); i <= high[curIdx]; ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 100 + i);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tstatic int N;\n\tstatic int[] low, high;\n\tstatic boolean[] f, s;\n\tstatic int[] pow = new int[8];\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tpow[0] = 1;\n\t\tfor (int i = 1; i < pow.length; ++i) {\n\t\t\tpow[i] = pow[i - 1] * 10;\n\t\t}\n\t\twhile (true) {\n\t\t\tint maxLen = 0;\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tlow = new int[N];\n\t\t\thigh = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tlow[i] = sc.nextInt();\n\t\t\t\thigh[i] = sc.nextInt();\n\t\t\t\tif (high[i] >= 10)\n\t\t\t\t\tmaxLen += 2;\n\t\t\t\telse\n\t\t\t\t\tmaxLen += 1;\n\t\t\t}\n\t\t\tf = new boolean[pow[6]];\n\t\t\ts = new boolean[pow[6]];\n\t\t\tdfs(0, N / 2, f, 0);\n\t\t\tdfs(N / 2, N, s, 0);\n\t\t\tlong ans = 0;\n\t\t\tfor (int L = N; L <= maxLen; ++L) {\n\t\t\t\tans += solve(L);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic long solve(int length) {\n\t\tint fFix = Math.max(length - (N - N / 2) * 2, N / 2);\n\t\tint sFix = Math.max(length - N / 2 * 2, N - N / 2);\n\t\tint middleLen = length - fFix - sFix;\n\t\tif (middleLen == 0) {\n\t\t\tlong sc = 0, fc = 0;\n\t\t\tfor (int i = pow[fFix - 1]; i < pow[fFix]; ++i) {\n\t\t\t\tif (f[i])\n\t\t\t\t\t++sc;\n\t\t\t}\n\t\t\tfor (int i = pow[sFix - 1]; i < pow[sFix]; ++i) {\n\t\t\t\tif (s[i])\n\t\t\t\t\t++fc;\n\t\t\t}\n\t\t\treturn fc * sc;\n\n\t\t} else {\n\t\t\tlong ret = 0;\n\t\t\tfor (int middle = 0; middle < pow[middleLen]; ++middle) {\n\t\t\t\tboolean[][] fok = new boolean[middleLen + 1][pow[fFix]];\n\t\t\t\tboolean[][] sok = new boolean[middleLen + 1][pow[sFix]];\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tint add = pow[i];\n\t\t\t\t\tint res = middle / pow[middleLen - i];\n\t\t\t\t\tfor (int cur = res + pow[fFix + i - 1]; cur < pow[fFix + i]; cur += add) {\n\t\t\t\t\t\tif (f[cur])\n\t\t\t\t\t\t\tfok[i][cur / pow[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tif (i > 0 && (middle % pow[i] / pow[i - 1] == 0)) {// leading0\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = middle % pow[i] * pow[sFix];\n\t\t\t\t\tfor (int cur = res + (i == 0 ? pow[sFix - 1] : 0); cur < res + pow[sFix]; cur++) {\n\t\t\t\t\t\tif (s[cur])\n\t\t\t\t\t\t\tsok[middleLen - i][cur % pow[sFix]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < (1 << (middleLen + 1)); ++i) {\n\t\t\t\t\tlong fc = 0;\n\t\t\t\t\tlong sc = 0;\n\t\t\t\t\tout1: for (int j = pow[fFix - 1]; j < pow[fFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !fok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++fc;\n\t\t\t\t\t}\n\t\t\t\t\tout2: for (int j = 0; j < pow[sFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !sok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++sc;\n\t\t\t\t\t}\n\t\t\t\t\tret += fc * sc * (Integer.bitCount(i) % 2 == 1 ? 1 : -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic void dfs(int curIdx, int endIdx, boolean[] arr, int sum) {\n\t\tif (curIdx == endIdx) {\n\t\t\tarr[sum] = true;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = low[curIdx]; i <= Math.min(9, high[curIdx]); ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 10 + i);\n\t\t}\n\t\tfor (int i = Math.max(10, low[curIdx]); i <= high[curIdx]; ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 100 + i);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tstatic int N;\n\tstatic int[] low, high;\n\tstatic boolean[] f, s;\n\tstatic int[] pow = new int[8];\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tpow[0] = 1;\n\t\tfor (int i = 1; i < pow.length; ++i) {\n\t\t\tpow[i] = pow[i - 1] * 10;\n\t\t}\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tlow = new int[N];\n\t\t\thigh = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tlow[i] = sc.nextInt();\n\t\t\t\thigh[i] = sc.nextInt();\n\t\t\t}\n\t\t\tf = new boolean[pow[7]];\n\t\t\ts = new boolean[pow[7]];\n\t\t\tdfs(0, N / 2, f, 0);\n\t\t\tdfs(N / 2, N, s, 0);\n\t\t\tlong ans = 0;\n\t\t\tfor (int L = N; L <= 2 * N; ++L) {\n\t\t\t\tans += solve(L);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic long solve(int length) {\n\t\tint fFix = Math.max(length - (N - N / 2) * 2, N / 2);\n\t\tint sFix = Math.max(length - N / 2 * 2, N - N / 2);\n\t\tint middleLen = length - fFix - sFix;\n\t\tif (middleLen == 0) {\n\t\t\tlong sc = 0, fc = 0;\n\t\t\tfor (int i = pow[fFix - 1]; i < pow[fFix]; ++i) {\n\t\t\t\tif (f[i])\n\t\t\t\t\t++sc;\n\t\t\t}\n\t\t\tfor (int i = pow[sFix - 1]; i < pow[sFix]; ++i) {\n\t\t\t\tif (s[i])\n\t\t\t\t\t++fc;\n\t\t\t}\n\t\t\treturn sc * fc;\n\n\t\t} else {\n\t\t\tlong ret = 0;\n\t\t\tfor (int middle = 0; middle < pow[middleLen]; ++middle) {\n\t\t\t\tboolean[][] fok = new boolean[middleLen + 1][pow[fFix]];\n\t\t\t\tboolean[][] sok = new boolean[middleLen + 1][pow[sFix]];\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tint add = pow[i];\n\t\t\t\t\tint res = middle / pow[middleLen - i];\n\t\t\t\t\tfor (int cur = res + pow[fFix + i - 1]; cur < pow[fFix + i]; cur += add) {\n\t\t\t\t\t\tif (f[cur])\n\t\t\t\t\t\t\tfok[i][cur / pow[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tif (i > 0 && middle % pow[i] / pow[i - 1] == 0) {// leading0\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = middle % pow[i] * pow[sFix];\n\t\t\t\t\tfor (int cur = res; cur < res + pow[sFix]; cur++) {\n\t\t\t\t\t\tif (s[cur])\n\t\t\t\t\t\t\tsok[middleLen - i][cur % pow[sFix]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < (1 << (middleLen + 1)); ++i) {\n\t\t\t\t\tlong fc = 0;\n\t\t\t\t\tlong sc = 0;\n\t\t\t\t\tout: for (int j = pow[fFix - 1]; j < pow[fFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !fok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++fc;\n\t\t\t\t\t}\n\t\t\t\t\tout: for (int j = 0; j < pow[sFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !sok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++sc;\n\t\t\t\t\t}\n\t\t\t\t\tret += fc * sc * (Integer.bitCount(i) % 2 == 1 ? 1 : -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic void dfs(int curIdx, int endIdx, boolean[] arr, int sum) {\n\t\tif (curIdx == endIdx) {\n\t\t\tarr[sum] = true;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = low[curIdx]; i <= Math.min(9, high[curIdx]); ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 10 + i);\n\t\t}\n\t\tfor (int i = Math.max(10, low[curIdx]); i <= high[curIdx]; ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 100 + i);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tstatic int N;\n\tstatic int[] low, high;\n\tstatic boolean[] f, s;\n\tstatic int[] pow = new int[8];\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tpow[0] = 1;\n\t\tfor (int i = 1; i < pow.length; ++i) {\n\t\t\tpow[i] = pow[i - 1] * 10;\n\t\t}\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tlow = new int[N];\n\t\t\thigh = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tlow[i] = sc.nextInt();\n\t\t\t\thigh[i] = sc.nextInt();\n\t\t\t}\n\t\t\tf = new boolean[pow[7]];\n\t\t\ts = new boolean[pow[7]];\n\t\t\tdfs(0, N / 2, f, 0);\n\t\t\tdfs(N / 2, N, s, 0);\n\t\t\tlong ans = 0;\n\t\t\tfor (int L = N; L <= 2 * N; ++L) {\n\t\t\t\tans += solve(L);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic long solve(int length) {\n\t\tint fFix = Math.max(length - (N - N / 2) * 2, N / 2);\n\t\tint sFix = Math.max(length - N / 2 * 2, N - N / 2);\n\t\tint middleLen = length - fFix - sFix;\n\t\tif (middleLen == 0) {\n\t\t\tlong sc = 0, fc = 0;\n\t\t\tfor (int i = pow[fFix - 1]; i < pow[fFix]; ++i) {\n\t\t\t\tif (f[i])\n\t\t\t\t\t++sc;\n\t\t\t}\n\t\t\tfor (int i = pow[sFix - 1]; i < pow[sFix]; ++i) {\n\t\t\t\tif (s[i])\n\t\t\t\t\t++fc;\n\t\t\t}\n\t\t\treturn sc * fc;\n\n\t\t} else {\n\t\t\tlong ret = 0;\n\t\t\tfor (int middle = 0; middle < pow[middleLen]; ++middle) {\n\t\t\t\tboolean[][] fok = new boolean[middleLen + 1][pow[fFix]];\n\t\t\t\tboolean[][] sok = new boolean[middleLen + 1][pow[sFix]];\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tint add = pow[i];\n\t\t\t\t\tint res = middle / pow[middleLen - i];\n\t\t\t\t\tfor (int cur = res + pow[fFix + i - 1]; cur < pow[fFix + i]; cur += add) {\n\t\t\t\t\t\tif (f[cur])\n\t\t\t\t\t\t\tfok[i][cur / pow[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i <= middleLen; ++i) {\n\t\t\t\t\tif (i > 0 && middle % pow[i] / pow[i - 1] == 0) {// leading0\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = middle % pow[i] * pow[sFix];\n\t\t\t\t\tfor (int cur = res; cur < res + pow[sFix]; cur++) {\n\t\t\t\t\t\tif (s[cur])\n\t\t\t\t\t\t\tsok[middleLen - i][cur % pow[sFix]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i < (1 << (middleLen + 1)); ++i) {\n\t\t\t\t\tlong fc = 0;\n\t\t\t\t\tlong sc = 0;\n\t\t\t\t\tout: for (int j = pow[fFix - 1]; j < pow[fFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !fok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++fc;\n\t\t\t\t\t}\n\t\t\t\t\tout: for (int j = 0; j < pow[sFix]; ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < (1 + middleLen); ++k) {\n\t\t\t\t\t\t\tif ((i & (1 << k)) > 0 && !sok[k][j]) {\n\t\t\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++sc;\n\t\t\t\t\t}\n\t\t\t\t\tret += fc * sc * (Integer.bitCount(i) % 2 == 1 ? 1 : -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic void dfs(int curIdx, int endIdx, boolean[] arr, int sum) {\n\t\tif (curIdx == endIdx) {\n\t\t\tarr[sum] = true;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = low[curIdx]; i <= Math.min(9, high[curIdx]); ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 10 + i);\n\t\t}\n\t\tfor (int i = Math.max(10, low[curIdx]); i <= high[curIdx]; ++i) {\n\t\t\tdfs(curIdx + 1, endIdx, arr, sum * 100 + i);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    A = [0]*N; B = [0]*N\n    for i in range(N):\n        A[i], B[i] = map(int, readline().split())\n    dp = [[0]*(1 << (3*N)) for i in range(2*N+1)]\n    for i in range(1, 10):\n        c = 0\n        if A[0] <= i <= B[0]:\n            c |= 1\n        if A[0]//10 <= i < B[0]//10 or A[0]//10 == B[0]//10 == i:\n            c |= 2\n        if A[0]//10 < i <= B[0]//10:\n            c |= 4\n        dp[1][c] += 1\n    N0 = 1 << (3*N)\n    for i in range(1, N*2):\n        dp0 = dp[i]\n        dp1 = dp[i+1]\n        for j in range(1, N0):\n            v = dp0[j]\n            if v == 0:\n                continue\n            for k in range(10):\n                c = 0\n                for l in range(N):\n                    a0 = A[l]; b0 = B[l]\n                    s = 1 << (3*l)\n                    if j & s and l < N-1 and k > 0:\n                        a1 = A[l+1]; b1 = B[l+1]\n                        if a1 <= k <= b1:\n                            c |= (s << 3)\n                        if a1//10 <= k < b1//10 or a1//10 == b1//10 == k:\n                            c |= (s << 4)\n                        if a1//10 < k <= b1//10:\n                            c |= (s << 5)\n                    if j & (s << 1):\n                        if j & (s << 2):\n                            c |= s\n                        elif a0//10 == b0//10:\n                            if a0%10 <= k <= b0%10:\n                                c |= s\n                        elif a0%10 <= k:\n                            c |= s\n                    if j & (s << 2):\n                        if k <= b0%10:\n                            c |= s\n                if c:\n                    dp1[c] += v\n    ans = 0\n    for i in range(2*N+1):\n        dpi = dp[i]\n        ans += sum(dpi[j] for j in range(N0) if j & (1 << (3*N-3)))\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  }
]