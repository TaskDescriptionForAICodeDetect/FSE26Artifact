[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VERTICES 105\n\ntypedef struct {\n    int adj[MAX_VERTICES][MAX_VERTICES];\n    int degree[MAX_VERTICES];\n    char labels[MAX_VERTICES];\n    int n;\n} Graph;\n\nvoid initGraph(Graph* g, int vertices) {\n    g->n = vertices;\n    memset(g->adj, 0, sizeof(g->adj));\n    memset(g->degree, 0, sizeof(g->degree));\n}\n\nvoid addEdge(Graph* g, int u, int v) {\n    g->adj[u][g->degree[u]++] = v;\n    g->adj[v][g->degree[v]++] = u;\n}\n\nbool canCreateAllPermutations(Graph* g) {\n    bool hasA = false, hasB = false;\n    for (int i = 0; i < g->n; i++) {\n        if (g->labels[i] == 'A') hasA = true;\n        if (g->labels[i] == 'B') hasB = true;\n    }\n    \n    if (!hasA || !hasB) return false;\n    \n    for (int start = 0; start < g->n; start++) {\n        bool visited[MAX_VERTICES] = {false};\n        bool canVisitAll = true;\n        int currentVertex = start;\n        \n        for (int i = 0; i < g->n; i++) {\n            visited[currentVertex] = true;\n            bool foundUnvisited = false;\n            \n            for (int j = 0; j < g->degree[currentVertex]; j++) {\n                int nextVertex = g->adj[currentVertex][j];\n                if (!visited[nextVertex]) {\n                    currentVertex = nextVertex;\n                    foundUnvisited = true;\n                    break;\n                }\n            }\n            \n            if (!foundUnvisited) {\n                for (int j = 0; j < g->n; j++) {\n                    if (!visited[j]) {\n                        currentVertex = j;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < g->n; i++) {\n            if (!visited[i]) {\n                canVisitAll = false;\n                break;\n            }\n        }\n        \n        if (canVisitAll) return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        int N, M;\n        scanf(\"%d %d\", &N, &M);\n        \n        Graph g;\n        initGraph(&g, N);\n        \n        for (int i = 0; i < N; i++) {\n            scanf(\" %c\", &g.labels[i]);\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            addEdge(&g, u-1, v-1);\n        }\n        \n        printf(\"%s\\n\", canCreateAllPermutations(&g) ? \"YES\" : \"NO\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[2 * MAX_N];\nint head[MAX_N];\nint edge_count = 0;\nchar label[MAX_N];\nbool hasA = false, hasB = false;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\" %c\", &label[i]);\n        if (label[i] == 'A') hasA = true;\n        if (label[i] == 'B') hasB = true;\n        head[i] = -1;\n    }\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n\n    bool possible = true;\n    if (!hasA || !hasB) {\n        possible = false;\n    } else {\n        bool has_aa = false, has_bb = false, has_ab = false, has_ba = false;\n        for (int u = 1; u <= N; ++u) {\n            for (int e = head[u]; e != -1; e = edges[e].next) {\n                int v = edges[e].to;\n                if (label[u] == 'A' && label[v] == 'A') has_aa = true;\n                if (label[u] == 'B' && label[v] == 'B') has_bb = true;\n                if (label[u] == 'A' && label[v] == 'B') has_ab = true;\n                if (label[u] == 'B' && label[v] == 'A') has_ba = true;\n            }\n        }\n        if (!has_ab && !has_ba && !(has_aa && has_bb)) {\n            possible = false;\n        }\n    }\n\n    printf(possible ? \"Yes\\n\" : \"No\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string labels;\n    cin >> labels;\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    bool hasA = false, hasB = false;\n    for (char c : labels) {\n        if (c == 'A') hasA = true;\n        if (c == 'B') hasB = true;\n    }\n    if (!hasA || !hasB) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    bool hasAA = false, hasBB = false, hasAB = false;\n    for (int u = 0; u < N; ++u) {\n        for (int v : adj[u]) {\n            if (labels[u] == 'A' && labels[v] == 'A') hasAA = true;\n            if (labels[u] == 'B' && labels[v] == 'B') hasBB = true;\n            if ((labels[u] == 'A' && labels[v] == 'B') || (labels[u] == 'B' && labels[v] == 'A')) hasAB = true;\n        }\n    }\n\n    if ((hasAA && hasAB) || (hasBB && hasAB) || (hasAA && hasBB)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class NusookGraph {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        scanner.nextLine();\n        String labels = scanner.nextLine().trim();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        boolean hasA = labels.contains(\"A\");\n        boolean hasB = labels.contains(\"B\");\n\n        if (!hasA || !hasB) {\n            System.out.println(\"No\");\n            return;\n        }\n\n        boolean aSelfLoop = false;\n        boolean bSelfLoop = false;\n        boolean aAndBConnected = false;\n\n        for (int i = 0; i < N; i++) {\n            char c = labels.charAt(i);\n            for (int neighbor : adj.get(i)) {\n                if (neighbor == i) {\n                    if (c == 'A') aSelfLoop = true;\n                    else bSelfLoop = true;\n                }\n                if ((c == 'A' && labels.charAt(neighbor) == 'B') || (c == 'B' && labels.charAt(neighbor) == 'A')) {\n                    aAndBConnected = true;\n                }\n            }\n        }\n\n        if ((aSelfLoop && bSelfLoop) || (aAndBConnected)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:03:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static boolean canCreateAllPermutations(int N, int M, int[] from, int[] to, char[] labels) {\n        // Create adjacency list representation of the graph\n        List<List<Integer>> graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Build the graph\n        for (int i = 0; i < M; i++) {\n            graph.get(from[i]).add(to[i]);\n            graph.get(to[i]).add(from[i]);\n        }\n        \n        // Check if all 'A' and 'B' vertices are connected\n        boolean[] visited = new boolean[N];\n        List<Integer> aVertices = new ArrayList<>();\n        List<Integer> bVertices = new ArrayList<>();\n        \n        // Separate A and B vertices\n        for (int i = 0; i < N; i++) {\n            if (labels[i] == 'A') {\n                aVertices.add(i);\n            } else {\n                bVertices.add(i);\n            }\n        }\n        \n        // If no 'A' or 'B' vertices, return false\n        if (aVertices.isEmpty() || bVertices.isEmpty()) {\n            return false;\n        }\n        \n        // DFS to check connectivity\n        dfs(aVertices.get(0), graph, visited, labels);\n        \n        // Check if all 'A' vertices are visited\n        for (int vertex : aVertices) {\n            if (!visited[vertex]) {\n                return false;\n            }\n        }\n        \n        // Reset visited array\n        Arrays.fill(visited, false);\n        \n        // DFS from first 'B' vertex\n        dfs(bVertices.get(0), graph, visited, labels);\n        \n        // Check if all 'B' vertices are visited\n        for (int vertex : bVertices) {\n            if (!visited[vertex]) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private static void dfs(int vertex, List<List<Integer>> graph, boolean[] visited, char[] labels) {\n        visited[vertex] = true;\n        \n        for (int neighbor : graph.get(vertex)) {\n            if (!visited[neighbor] && labels[vertex] == labels[neighbor]) {\n                dfs(neighbor, graph, visited, labels);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:03:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canCreateAllPermutations(int N, vector<vector<int>>& edges, vector<char>& labels) {\n        vector<vector<int>> graph(N);\n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n\n        for (int start = 0; start < N; start++) {\n            if (canReachAllNodes(N, graph, labels, start)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\nprivate:\n    bool canReachAllNodes(int N, vector<vector<int>>& graph, vector<char>& labels, int start) {\n        vector<bool> visited(N, false);\n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n\n        unordered_set<int> aNodes, bNodes;\n        if (labels[start] == 'A') aNodes.insert(start);\n        else bNodes.insert(start);\n\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n\n            for (int neighbor : graph[curr]) {\n                if (!visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n\n                    if (labels[neighbor] == 'A') aNodes.insert(neighbor);\n                    else bNodes.insert(neighbor);\n                }\n            }\n        }\n\n        return aNodes.size() > 0 && bNodes.size() > 0;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> edges(M, vector<int>(2));\n    for (int i = 0; i < M; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n        edges[i][0]--;\n        edges[i][1]--;\n    }\n\n    vector<char> labels(N);\n    for (int i = 0; i < N; i++) {\n        cin >> labels[i];\n    }\n\n    Solution solution;\n    cout << (solution.canCreateAllPermutations(N, edges, labels) ? \"YES\" : \"NO\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:03:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef can_create_permutations(n, m, labels, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start, target_sequence, visited):\n        queue = deque([(start, labels[start])])\n        visited.add(start)\n        while queue:\n            current, current_sequence = queue.popleft()\n            if len(current_sequence) == len(target_sequence):\n                if set(current_sequence) == set(target_sequence):\n                    return True\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, current_sequence + labels[neighbor]))\n                    visited.remove(neighbor)\n        return False\n\n    all_sequences = ['A' * n + 'B' * m for n in range(n + 1) for m in range(m + 1) if n + m <= n + m]\n    \n    for sequence in all_sequences:\n        for start in range(1, n + 1):\n            visited = set()\n            if bfs(start, sequence, visited):\n                break\n        else:\n            return False\n    return True\n\n# Example usage\nn = 3\nm = 3\nlabels = {1: 'A', 2: 'B', 3: 'A'}\nedges = [(1, 2), (2, 3), (3, 1)]\n\nprint(can_create_permutations(n, m, labels, edges))",
    "timestamp": "2025-08-13 13:26:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PhantomThief {\n\n    public static boolean canFormAllPermutations(int n, int m, char[] labels, int[][] edges) {\n        ArrayList<Integer>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        boolean[] visited = new boolean[n];\n        int countA = 0;\n        int countB = 0;\n        \n        for (char label : labels) {\n            if (label == 'A') countA++;\n            else countB++;\n        }\n        \n        if (countA == 0 || countB == 0) return false;\n        \n        int totalCount = (1 << countA) + (1 << countB) - 2;\n        \n        for (int start = 0; start < n; start++) {\n            if (labels[start] == 'A') {\n                for (int i = 0; i < n; i++) visited[i] = false;\n                if (dfs(graph, labels, start, visited, 'A', totalCount, countA, countB)) return true;\n            } else {\n                for (int i = 0; i < n; i++) visited[i] = false;\n                if (dfs(graph, labels, start, visited, 'B', totalCount, countA, countB)) return true;\n            }\n        }\n        \n        return false;\n    }\n\n    private static boolean dfs(ArrayList<Integer>[] graph, char[] labels, int current, boolean[] visited, char startChar, int totalCount, int countA, int countB) {\n        visited[current] = true;\n        totalCount -= (startChar == labels[current]) ? 0 : (1 << (labels[current] == 'A' ? countB : countA));\n        \n        if (totalCount <= 0) return true;\n        \n        for (int neighbor : graph[current]) {\n            if (!visited[neighbor]) {\n                if (dfs(graph, labels, neighbor, visited, startChar, totalCount, countA, countB)) return true;\n            }\n        }\n        \n        visited[current] = false;\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        int n = 4;\n        int m = 3;\n        char[] labels = {'A', 'B', 'A', 'B'};\n        int[][] edges = {{0, 1}, {1, 2}, {2, 3}};\n        \n        System.out.println(canFormAllPermutations(n, m, labels, edges));\n    }\n}",
    "timestamp": "2025-08-13 13:27:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAXN 100\n\nint N, M;\nchar label[MAXN];\nbool graph[MAXN][MAXN];\nbool visited[MAXN];\n\nvoid dfs(int v, bool visitedA[], bool visitedB[]) {\n    visited[v] = true;\n    if (label[v] == 'A') visitedA[v] = true;\n    if (label[v] == 'B') visitedB[v] = true;\n    for (int u = 0; u < N; ++u) {\n        if (graph[v][u] && !visited[u]) {\n            dfs(u, visitedA, visitedB);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; ++i) {\n        scanf(\" %c\", &label[i]);\n    }\n    memset(graph, false, sizeof(graph));\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        --u; --v;\n        graph[u][v] = graph[v][u] = true;\n    }\n    \n    // Check for connected components that each contain at least one 'A' and one 'B'.\n    memset(visited, false, sizeof(visited));\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            bool visitedA[MAXN] = {0};\n            bool visitedB[MAXN] = {0};\n            dfs(i, visitedA, visitedB);\n            bool hasA = false, hasB = false;\n            for (int j = 0; j < N; ++j) {\n                if (visitedA[j]) hasA = true;\n                if (visitedB[j]) hasB = true;\n            }\n            if (!hasA || !hasB) {\n                printf(\"No\\n\");\n                return 0;\n            }\n        }\n    }\n    \n    printf(\"Yes\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 13:27:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canCreateAllPermutations(n, m, edges, labels) {\n    const graph = Array.from({ length: n }, () => []);\n    \n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    function hasCycle() {\n        const visited = Array(n).fill(false);\n        const dfs = (node, parent) => {\n            visited[node] = true;\n            \n            for (const neighbor of graph[node]) {\n                if (!visited[neighbor]) {\n                    if (dfs(neighbor, node)) return true;\n                } else if (neighbor !== parent) {\n                    return true;\n                }\n            }\n            \n            return false;\n        };\n        \n        for (let i = 0; i < n; i++) {\n            if (!visited[i] && dfs(i, -1)) return true;\n        }\n        \n        return false;\n    }\n    \n    const labelsSet = new Set(labels);\n    return labelsSet.size === 2 && hasCycle();\n}",
    "timestamp": "2025-08-13 13:27:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Dict\nfrom collections import defaultdict\n\ndef can_create_all_permutations(N: int, edges: List[List[int]], labels: str) -> bool:\n    # Create adjacency list representation of the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check connectivity and label restrictions\n    def dfs(node: int, visited: set) -> None:\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n    \n    # Check graph is connected\n    visited = set()\n    dfs(0, visited)\n    if len(visited) != N:\n        return False\n    \n    # Check if there's at least one 'A' and one 'B'\n    a_count = labels.count('A')\n    b_count = labels.count('B')\n    if a_count == 0 or b_count == 0:\n        return False\n    \n    # Check each vertex has a connection to both 'A' and 'B' vertices\n    for node in range(N):\n        a_reachable = False\n        b_reachable = False\n        \n        def explore(current: int, visited_nodes: set) -> None:\n            nonlocal a_reachable, b_reachable\n            visited_nodes.add(current)\n            \n            if labels[current] == 'A':\n                a_reachable = True\n            if labels[current] == 'B':\n                b_reachable = True\n            \n            for neighbor in graph[current]:\n                if neighbor not in visited_nodes:\n                    explore(neighbor, visited_nodes)\n        \n        explore(node, set())\n        \n        if not (a_reachable and b_reachable):\n            return False\n    \n    return True\n\n# Read input\nN, M = map(int, input().split())\nlabels = input()\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n# Print result\nprint(\"YES\" if can_create_all_permutations(N, edges, labels) else \"NO\")",
    "timestamp": "2025-08-13 13:27:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canCreateAllPermutations(N, edges, labels) {\n    const graph = Array.from({ length: N }, () => []);\n    \n    for (const [u, v] of edges) {\n        graph[u - 1].push(v - 1);\n        graph[v - 1].push(u - 1);\n    }\n    \n    const visited = new Array(N).fill(false);\n    const connectedA = new Set();\n    const connectedB = new Set();\n    \n    function dfs(node, type) {\n        visited[node] = true;\n        if (type === 'A') connectedA.add(node);\n        else connectedB.add(node);\n        \n        for (const neighbor of graph[node]) {\n            if (!visited[neighbor] && labels[neighbor] === type) {\n                dfs(neighbor, type);\n            }\n        }\n    }\n    \n    for (let i = 0; i < N; i++) {\n        if (!visited[i]) {\n            if (labels[i] === 'A') dfs(i, 'A');\n            else dfs(i, 'B');\n        }\n    }\n    \n    return connectedA.size > 0 && connectedB.size > 0;\n}",
    "timestamp": "2025-08-13 13:27:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M = map(int, input[ptr:ptr+2])\n    ptr +=2\n    labels = input[ptr]\n    ptr +=1\n    \n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr +=2\n        u -=1\n        v -=1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Check for all possible patterns: \"AA\", \"AB\", \"BA\", \"BB\"\n    possible = [False]*4\n    \n    # Check for AA or BB\n    for u in range(N):\n        for v in adj[u]:\n            if labels[u] == 'A' and labels[v] == 'A':\n                possible[0] = True  # AA\n            if labels[u] == 'A' and labels[v] == 'B':\n                possible[1] = True  # AB\n            if labels[u] == 'B' and labels[v] == 'A':\n                possible[2] = True  # BA\n            if labels[u] == 'B' and labels[v] == 'B':\n                possible[3] = True  # BB\n    \n    # To generate all permutations, we need:\n    # 1. Both A and B are present in the graph (trivially true if we have any edge)\n    # 2. We can generate AA and BB (to repeat characters)\n    # 3. We can generate AB or BA (to switch characters)\n    \n    has_A = 'A' in labels\n    has_B = 'B' in labels\n    \n    if not has_A or not has_B:\n        print(\"No\")\n        return\n    \n    can_repeat_A = possible[0]\n    can_repeat_B = possible[3]\n    can_switch = possible[1] or possible[2]\n    \n    if (can_repeat_A or can_repeat_B) and can_switch:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nsolve()",
    "timestamp": "2025-08-13 13:27:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N, M;\n    let labels = [];\n    let adj = [];\n    let lineCount = 0;\n\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            [N, M] = line.split(' ').map(Number);\n            adj = Array.from({ length: N + 1 }, () => []);\n            lineCount++;\n        } else if (lineCount === 1) {\n            labels = line.split('');\n            lineCount++;\n        } else {\n            const [u, v] = line.split(' ').map(Number);\n            adj[u].push(v);\n            adj[v].push(u);\n            lineCount++;\n            if (lineCount === M + 2) {\n                rl.close();\n            }\n        }\n    });\n\n    rl.on('close', () => {\n        let hasA = false, hasB = false;\n        for (let i = 0; i < N; i++) {\n            if (labels[i] === 'A') hasA = true;\n            if (labels[i] === 'B') hasB = true;\n        }\n\n        if (!hasA || !hasB) {\n            console.log(\"No\");\n            return;\n        }\n\n        let hasSelfLoop = false;\n        for (let i = 1; i <= N; i++) {\n            if (adj[i].includes(i)) {\n                hasSelfLoop = true;\n                break;\n            }\n        }\n\n        if (hasSelfLoop) {\n            console.log(\"Yes\");\n            return;\n        }\n\n        let hasBothLabels = false;\n        for (let i = 1; i <= N; i++) {\n            for (const neighbor of adj[i]) {\n                if (labels[i - 1] !== labels[neighbor - 1]) {\n                    hasBothLabels = true;\n                    break;\n                }\n            }\n            if (hasBothLabels) break;\n        }\n\n        if (hasBothLabels) {\n            console.log(\"Yes\");\n        } else {\n            console.log(\"No\");\n        }\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:27:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nbool canFormAllPermutations(vector<vector<int>>& adj, vector<char>& labels, int n) {\n    vector<bool> visited(n, false);\n    set<string> foundPermutations;\n    string current;\n\n    function<void(int)> dfs = [&](int node) {\n        if (visited[node]) return;\n        visited[node] = true;\n        current.push_back(labels[node]);\n        if (current.size() > 1)\n            foundPermutations.insert(current);\n\n        for (int neighbor : adj[node]) {\n            dfs(neighbor);\n        }\n\n        visited[node] = false;\n        current.pop_back();\n    };\n\n    for (int i = 0; i < n; ++i) {\n        dfs(i);\n    }\n\n    int requiredPermutations = 1 << n;\n    return foundPermutations.size() == requiredPermutations;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n);\n    vector<char> labels(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> labels[i];\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    bool result = canFormAllPermutations(adj, labels, n);\n    if (result) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:44"
  }
]