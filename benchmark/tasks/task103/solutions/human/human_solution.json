[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <utility>\n#include <cctype>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<vector<int>,int> M;\nvector<vector<int> > VS;\nvoid solve1(int x,int y,vector<int> &V) {\n\tif(x==0) {\n\t\tVS.push_back(V);\n\t\treturn;\n\t}\n\tfor(int i=y;i<=min(x,9);i++) {\n\t\tV[i-1]++;\n\t\tsolve1(x-i,i,V);\n\t\tV[i-1]--;\n\t}\n}\nint solve2(vector<int> &V) {\n\tif(M.find(V)!=M.end()) {\n\t\treturn M[V];\n\t}\n\tint ans=0;\n\tfor(int i=0;i<VS.size();i++) {\n\t\tbool OK=1;\n\t\tfor(int j=0;j<9;j++) {\n\t\t\tV[j]-=VS[i][j];\n\t\t\tif(V[j]<0) OK=0;\n\t\t}\n\t\tif(OK) {\n\t\t\tans=max(ans,solve2(V)+1);\n\t\t}\n\t\tfor(int j=0;j<9;j++) {\n\t\t\tV[j]+=VS[i][j];\n\t\t}\n\t}\n\treturn M[V]=ans;\n}\nint main() {\n\tvector<int> V(9);\n\tfill(V.begin(),V.end(),0);\n\tsolve1(10,1,V);\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tfill(V.begin(),V.end(),0);\n\t\tM.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint m;\n\t\t\tscanf(\"%d\",&m);\n\t\t\tV[m-1]++;\n\t\t}\n\t\tprintf(\"%d\\n\",solve2(V));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nmap<ull,int> memo;\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\tint res = max(a, b);\n\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 1;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tull r = s;\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull p = r;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((p >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tp -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tr = p;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10, thr);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 99 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint ans; // ツ暫ツ津ィツ嘉ー\nvoid dfs(int i,int sum,int *a,int now=0){\n\t// ツ篠ゥツ鳴セツづ按枝ツ環?づィ\n\tint rem=sum;\n\tfor(int j=1;j<10;j++) rem+=a[j]*j;\n\tif(now+rem/10<=ans) return;\n\n\tans=max(ans,now);\n\n\tif(sum==10){\n\t\tdfs(1,0,a,now+1);\n\t\treturn;\n\t}\n\tif(i>=10) return;\n\n\tdfs(i+1,sum,a,now);\n\tif(a[i]>0 && sum+i<=10){\n\t\ta[i]--;\n\t\tdfs(i,sum+i,a,now);\n\t\ta[i]++;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\n\t\tans=-1;\n\t\tdfs(1,0,a);\n\t\tprintf(\"%d\\n\",sum+ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nlong long conv(wolf a){\n\tlong long ret=0;\n\tfor(int i=0;i<9;i++){\n\t\tret*=128;\n\t\tret+=a.t[i];\n\t}\n\treturn ret;\n}\nmap<long long,int> dp;\nint solve(wolf a,int b){\n\tif((int)(dp.count(conv(a))))return dp[conv(a)];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[conv(a)]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tdp.clear();\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 7500000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 1000000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nbool dfs(vector<int>& manju, int start, int n, int sum) {\n    if(sum == 0) return n == 0;\n    if(n == 0) return false;\n    for(int i = start; i < manju.size(); ++i) {\n        if(manju[i] > sum) continue;\n        if(!dfs(manju, i + 1, n - 1, sum - manju[i])) continue;\n        manju.erase(manju.begin() + i);\n        return true;\n    }\n    return false;\n}\n\nint solve(vector<int>& manju) {\n    int result = 0;\n    sort(manju.begin(), manju.end(), greater<int>());\n    for(int i = 2; i < manju.size(); ++i) {\n        while(dfs(manju, 0, i, 10)) ++result;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<int> manju(n);\n        for(auto& v: manju) cin >> v;\n        cout << solve(manju) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;\nset<vector<int> > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(table.count(tmp))return 0;\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n// int N;\n// int MS[101];\n// vector<map<char,char> > howToGet;\n// map<map<char,char>,char> dp[43];\n// void dfs(const int kind,int wgt,map<char,char> v){\n//   if(kind==0){\n//     map<char,char> nv=v;\n//     dfs(kind+1,wgt,nv);\n//   }\n//   else if(wgt==0)howToGet.push_back(v);\n//   else if(kind==10)return;\n//   else{\n//     for(int i=0;i*kind<=10;i++){\n//       if(wgt-i*kind>=0){\n// \tmap<char,char> nv=v;\n// \tif(i>=1)nv[kind]=i;\n// \tdfs(kind+1,wgt-i*kind,nv);\n//       }\n//     }\n//   }\n// }\n\n// void dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n//   if(pos==(int)howToGet.size())return;\n//   if(preLast/10+cnt<=maxVal)return;\n//   // 1セット分取れるか\n//   map<char,char> nv=v;\n//   bool ok=true;\n//   int sz=0;\n//   for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n//     if(nv.count(it->first)==0\n//        ||nv[it->first]-(it->second)<0){\n//       ok=false;\n//       break;\n//     }\n//     else{\n//       nv[it->first]-=it->second;\n//       sz+=it->second;\n//     }\n//   }\n//   // 1セット取れるならとる\n//   if(ok){\n//     maxVal=max(maxVal,cnt+1);\n//     dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n//   }\n//   // 取らずに次のセットへ\n//   dfs2(pos+1,v,cnt,maxVal,preLast);\n// }\n\n// void greedy(int &maxVal,map<char,char> v){\n//   for(int pos=0;pos<(int)howToGet.size();pos++){\n//     while(1){\n//       bool ok=true;\n//       for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n// \tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n// \t  ok=false;\n// \t  break;\n// \t}\n//       }\n//       if(ok){\n// \tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n// \t  v[it->first]-=it->second;\n// \tmaxVal++;\n//       }\n//       else\n// \tbreak;\n//     }\n//   }\n// }\n\n// int main(){\n//   dfs(0,10,map<char,char>());\n//   while(cin>>N&&N){\n//     map<char,char> cnts;\n//     int preLast=0;\n//     for(int i=0;i<N;i++)cin>>MS[i];\n//     for(int i=0;i<N;i++){\n//       cnts[MS[i]]++;\n//       preLast+=MS[i];\n//     }\n//     for(int i=0;i<43;i++)dp[i].clear();\n//     int maxVal=0;\n//     greedy(maxVal,cnts);\n//     // cout<<maxVal<<endl;\n//     // dfs2(0,cnts,0,maxVal,preLast);\n//     cout<<maxVal<<endl;\n//   }\n//   return 0;\n// }\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    int sum=0;\n    // for(int i=1;i<=9;i++)\n    //   cout<<(int)cnts[i]<<\" \";\n    // cout<<endl;\n    for(int i=1;i<=4;i++){\n      int a=min(cnts[i],cnts[10-i]);\n      cnts[i]-=a;cnts[10-i]-=a;\n      sum+=a;\n    }\n    int a=cnts[5]/2;\n    cnts[5]-=2*a;\n    sum+=a;\n    //cout<<sum<<endl;\n    int res=dfs2(cnts)+sum;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    map<int,int,greater<int> > manju;\n    for(int i=0,a;i<n;++i){cin>>a;++manju[a];}\n    int ans=0;\n    for(map<int,int,greater<int> >::iterator it=manju.begin();it!=manju.end();++it){//prior heavy manju\n      while(it->second){\n        int w=it->first;--(it->second);\n        for(map<int,int,greater<int> >::iterator it2=it;it2!=manju.end();++it2){\n          while(it2->second&&w+it2->first<=10){\n            w+=it2->first;\n            --(it2->second);\n          }\n        }\n        if(w==10)++ans;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(int i, vector<int> v)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tint sum = 0;\n\tfor (int j = 0; j < 9; j++){\n\t\tsum += (j + 1) * v[j];\n\t}\n\tif (sum < 10) return 0;\n\t\n\tif (i == T.size()) return 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tint sum = 0;\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tsum += (k + 1) * v[k];\n\t\t}\n\t\tif (j + sum / 10 <= res) continue;\n\t\t\n\t\tres = max(res, j + dfs(i + 1, v));\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint ans; // ツ暫ツ津ィツ嘉ー\nvoid dfs(int i,int sum,int *a,int now=0){\n\t// ツ篠ゥツ鳴セツづ按枝ツ環?づィ\n\tint rem=sum;\n\tfor(int j=1;j<10;j++) rem+=a[j]*j;\n\tif(now+rem/10<=ans) return;\n\n\tans=max(ans,now);\n\n\tif(sum==10){\n\t\tdfs(1,0,a,now+1);\n\t\treturn;\n\t}\n\tif(i>=10) return;\n\n\tdfs(i+1,sum,a);\n\tif(a[i]>0 && sum+i<=10){\n\t\ta[i]--;\n\t\tdfs(i,sum+i,a,now);\n\t\ta[i]++;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\n\t\tans=-1;\n\t\tdfs(1,0,a);\n\t\tprintf(\"%d\\n\",sum+ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 100000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 99 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n\nint N;\nint MS[101];\nint lim;\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(const int kind,int wgt,const map<char,char> &v){\n  if(kind==0){\n    map<char,char> nv=v;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nvoid dfs2(const int pos,const map<char,char> &v,int cnt,int &maxVal,int preLast){\n  if(pos==(int)howToGet.size())return;\n  if(preLast/2+cnt<=maxVal)return;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  int sz=0;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0\n       ||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else nv[it->first]-=it->second;\n    sz++;\n  }\n  // 1セット取れるならとる\n  if(ok){\n    maxVal=max(maxVal,cnt+1);\n    dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n  }\n  // 取らずに次のセットへ\n  dfs2(pos+1,v,cnt,maxVal,preLast);\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    lim=0;\n    map<char,char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int maxVal=0;\n    int preLast=N;\n    dfs2(0,cnts,0,maxVal,preLast);\n    cout<<maxVal<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[11], ans, total;\n\nint f1[5][2] = {\n\t{9,1},\n\t{8,2},\n\t{7,3},\n\t{6,4},\n\t{5,5}\n};\nint f2[8][3] = {\n\t{8,1,1},\n\t{7,2,1},\n\t{6,3,1},\n\t{6,2,2},\n\t{5,4,1},\n\t{5,3,2},\n\t{4,4,2},\n\t{4,3,3}\n};\nint f3[8][4] = {\n\t{7,1,1,1},\n\t{6,2,1,1},\n\t{5,3,1,1},\n\t{5,2,2,1},\n\t{4,4,1,1},\n\t{4,3,2,1},\n\t{4,2,2,2},\n\t{3,3,2,2}\n};\nint f4[7][5] = {\n\t{6,1,1,1,1},\n\t{5,2,1,1,1},\n\t{4,3,1,1,1},\n\t{4,2,2,1,1},\n\t{3,3,2,1,1},\n\t{3,2,2,2,1},\n\t{2,2,2,2,2},\n};\nint f5[5][6] = {\n\t{5,1,1,1,1,1},\n\t{4,2,1,1,1,1},\n\t{3,3,1,1,1,1},\n\t{3,2,2,1,1,1},\n\t{2,2,2,2,1,1},\n};\n\nvoid solve(int cnt, int sum){\n\tans = max( ans , cnt );\n\tif( total-sum < 10 ) return;\n\tif( (total - sum) / 10 + cnt < ans ) return;\n\t\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f1[i][0]]--;\n\t\ta[f1[i][1]]--;\n\t\tif( a[f1[i][0]] >= 0 && a[f1[i][1]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f1[i][0]]++;\n\t\ta[f1[i][1]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f2[i][0]]--;\n\t\ta[f2[i][1]]--;\n\t\ta[f2[i][2]]--;\n\t\tif( a[f2[i][0]] >= 0 && a[f2[i][1]] >= 0 && a[f2[i][2]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f2[i][0]]++;\n\t\ta[f2[i][1]]++;\n\t\ta[f2[i][2]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f3[i][0]]--;\n\t\ta[f3[i][1]]--;\n\t\ta[f3[i][2]]--;\n\t\ta[f3[i][3]]--;\n\t\tif( a[f3[i][0]] >= 0 && a[f3[i][1]] >= 0 && a[f3[i][2]] >= 0 && a[f3[i][3]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f3[i][0]]++;\n\t\ta[f3[i][1]]++;\n\t\ta[f3[i][2]]++;\n\t\ta[f3[i][3]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 7 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f4[i][0]]--;\n\t\ta[f4[i][1]]--;\n\t\ta[f4[i][2]]--;\n\t\ta[f4[i][3]]--;\n\t\ta[f4[i][4]]--;\n\t\tif( a[f4[i][0]] >= 0 && a[f4[i][1]] >= 0 && a[f4[i][2]] >= 0 && a[f4[i][3]] >= 0 && a[f4[i][4]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f4[i][0]]++;\n\t\ta[f4[i][1]]++;\n\t\ta[f4[i][2]]++;\n\t\ta[f4[i][3]]++;\n\t\ta[f4[i][4]]++;\n\t\t//if( flag ) return;\n\t}\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f5[i][0]]--;\n\t\ta[f5[i][1]]--;\n\t\ta[f5[i][2]]--;\n\t\ta[f5[i][3]]--;\n\t\ta[f5[i][4]]--;\n\t\ta[f5[i][5]]--;\n\t\tif( a[f5[i][0]] >= 0 && a[f5[i][1]] >= 0 && a[f5[i][2]] >= 0 && a[f5[i][3]] >= 0 && a[f5[i][4]] >= 0 && a[f5[i][5]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f5[i][0]]++;\n\t\ta[f5[i][1]]++;\n\t\ta[f5[i][2]]++;\n\t\ta[f5[i][3]]++;\n\t\ta[f5[i][4]]++;\n\t\ta[f5[i][5]]++;\n\t\t//if( flag ) return;\n\t}\n\t\n\tif( a[4] >= 1 && a[1] >= 6 ){\n\t\ta[4] -= 1;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[4] += 1;\n\t\ta[1] += 6;\n\t}\n\tif( a[3] >= 1 && a[2] >= 1 && a[1] >= 5 ){\n\t\ta[3] -= 1;\n\t\ta[2] -= 1;\n\t\ta[1] -= 5;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[2] += 1;\n\t\ta[1] += 5;\n\t}\n\tif( a[2] >= 3 && a[1] >= 4 ){\n\t\ta[2] -= 3;\n\t\ta[1] -= 4;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 3;\n\t\ta[1] += 4;\n\t}\n\tif( a[3] >= 1 && a[1] >= 7 ){\n\t\ta[3] -= 1;\n\t\ta[1] -= 7;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[1] += 7;\n\t}\n\tif( a[2] >= 2 && a[1] >= 6 ){\n\t\ta[2] -= 2;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 2;\n\t\ta[1] += 6;\n\t}\n\tif( a[2] >= 1 && a[1] >= 8 ){\n\t\ta[2]--;\n\t\ta[1] -= 8;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2]++;\n\t\ta[1] += 8;\n\t}\n\tif( a[1] >= 10 ){\n\t\ta[1] -= 10;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[1] += 10;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\ttotal = 0;\n\t\tfor(int i=0 ; i < 10 ; i++ ){\n\t\t\ta[i] = 0;\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ttotal += e;\n\t\t\ta[e]++;\n\t\t}\n\t\tans = 0;\n\t\tsolve(0,0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nVV(pii) vp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int t1){\n\tull aa=hash();\n\tif(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\t// if(y<2) return 0;\n\tint ret=0;\n\treep(i,t1,vp.size()){\n\t\tbool f=true;\n\t\trep(j,vp[i].size()){\n\t\t\tf&=(0<=(a[vp[i][j].F]-=vp[i][j].S));\t\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(i)+1);\n\t\t}\n\t\trep(j,vp[i].size()){\n\t\t\ta[vp[i][j].F]+=vp[i][j].S;\n\t\t}\n\t}\n\t// reep(j,t2,vp[t1].size()){\n\t\t// rep(k,vp[t1][j].size()){\n\t\t\t// a[vp[t1][j][k].F]-=vp[t1][j][k].S;\n\t\t// }\n\t\t// bool f=true;\n\t\t// reep(k,1,10){\n\t\t\t// if(a[k]<0) f=false;\n\t\t// }\n\t\t// if(f){\n\t\t\t// ret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t// }\n\t\t// rep(k,vp[t1][j].size()){\n\t\t\t// a[vp[t1][j][k].F]+=vp[t1][j][k].S;\n\t\t// }\n\t// }\n\t// reep(i,t1+1,11){\n\t\t// rep(j,vp[i].size()){\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// a[vp[i][j][k].F]-=vp[i][j][k].S;\n\t\t\t// }\n\t\t\t// bool f=true;\n\t\t\t// reep(k,1,10){\n\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t// }\n\t\t\t// if(f){\n\t\t\t\t// ret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t// }\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// a[vp[i][j][k].F]+=vp[i][j][k].S;\n\t\t\t// }\n\t\t// }\n\t// }\n\treturn ma[aa]=ret;\n\t// return ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\trep(i,vv.size()){\n\t\tVV(pii) tmp;\n\t\trep(j,vv[i].size()){\n\t\t\tint t1=vv[i][j][0];\n\t\t\tint t2=0;\n\t\t\tvector<pii> vpii;\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\tif(t1==vv[i][j][k]){\n\t\t\t\t\tt2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvpii.PB(pii(t1,t2));\n\t\t\t\t\tt1=vv[i][j][k];\n\t\t\t\t\tt2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvpii.PB(pii(t1,t2));\n\t\t\ttmp.PB(vpii);\n\t\t}\n\t\trep(i,tmp.size()){\n\t\t\tvp.PB(tmp[i]);\n\t\t}\n\t}\n\t// rep(i,vp.size()){\n\t\t// cout<<endl;\n\t\t// cout<<\"i \"<<i<<endl;\n\t\t// rep(j,vp[i].size()){\n\t\t\t// cout<<\" j \"<<j<<endl;\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// cout<<\"  \"<<vp[i][j][k].F<<\" \"<<vp[i][j][k].S<<endl;\n\t\t\t// }\n\t\t// }\n\t// }\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans1=0;\n\t\treep(i,1,5){\n\t\t\twhile(a[i]&&a[10-i]) ans1++,a[i]--,a[10-i]--;\n\t\t}\n\t\twhile(a[5]>=2) ans1++,a[5]-=2;\n\t\t// rep(i,vv[3].size()){\n\t\t\t// bool f=true;\n\t\t\t// while(f){\n\t\t\t\t// rep(j,vv[3][i].size()){\n\t\t\t\t\t// f&=0<=(--a[vv[3][i][j]]);\n\t\t\t\t// }\n\t\t\t\t// if(!f){\n\t\t\t\t\t// rep(j,vv[3][i].size()){\n\t\t\t\t\t\t// ++a[vv[3][i][j]];\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t// }\n\t\t\t\t// ans1++;\n\t\t\t// }\n\t\t// }\n\t\tint ans2=dfs(0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans1+ans2<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 1; i <= 9 ; i++ ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\n\nint n, a[128];\n\nint res, possi_max;\nint sack[11];\nvoid dfs(int d)\n{\n\tif (res == possi_max || sack[10] + (n - d) <= res)\n\t\treturn;\n\telse if (d == n)\n\t{\n\t\tres = sack[10];\n\t\treturn;\n\t}\n\n\tfor (int i = 10 - a[d]; i >= 0; --i)\n\t{\n\t\tif (sack[i] > 0)\n\t\t{\n\t\t\tint j = a[d] + i;\n\t\t\tif (j != 10 && j + a[n - 1] > 10)\n\t\t\t\tbreak;\n\n\t\t\t--sack[i];\n\t\t\t++sack[j];\n\n\t\t\tdfs(d + 1);\n\n\t\t\t++sack[i];\n\t\t\t--sack[j];\n\t\t}\n\t}\n}\nint remove_clear()\n{\n\tint s[11];\n\tCL(s, 0);\n\tfor (int i = 0; i < n; ++i)\n\t\t++s[a[i]];\n\n\tint res = 0;\n\tfor (int i = 1; i <= 4; ++i)\n\t{\n\t\tint t = min(s[i], s[10 - i]);\n\t\tres += t;\n\t\ts[i] -= t;\n\t\ts[10 - i] -= t;\n\t}\n\tres += s[5] / 2;\n\ts[5] -= s[5] / 2 * 2;\n\n\n\tint mini = 10;\n\tfor (int i = 9; i >= 1; --i)\n\t\tif (s[i] > 0)\n\t\t\tmini = i;\n\n\tn = 0;\n\tfor (int i = 1; i <= 9 && i + mini <= 10; ++i)\n\t\twhile (s[i] > 0)\n\t\t\ta[n++] = i, --s[i];\n\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tsack[0] = 114514;\n\twhile (cin >> n, n)\n\t{\n\t\tinput(a, n);\n\n\t\tint r = remove_clear();\n\n\t\tsort(a, a + n, greater<int>());\n\n\t\tpossi_max = accumulate(a, a + n, 0) / 10;\n\t\tres = 0;\n\t\tdfs(0);\n\n\t\tres += r;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND;\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\tprintf(\"%d\\n\", calc(v));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint ans;\nset<vector<int> > ss;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i+i<=10;i++){\n        int j = 10 - i;\n        vector<int> v2 = v;\n        if(v2[i] > 0){\n            v2[i]--;\n            if(v2[j] > 0){\n                v2[j]--;\n                if(ss.find(v2) != ss.end()) continue;\n                ss.insert(v2);\n                f = true;\n                dfs(v2,cnt+1);\n            }\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        if(ss.find(v2) != ss.end()) continue;\n                        ss.insert(v2);\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                if(ss.find(v2) != ss.end()) continue;\n                                ss.insert(v2);\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        if(ss.find(v2) != ss.end()) continue;\n                                        ss.insert(v2);\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                if(ss.find(v2) != ss.end()) continue;\n                                                ss.insert(v2);\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        if(ss.find(v2) != ss.end()) continue;\n                                                        ss.insert(v2);\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 1 && v[1] >= 8){\n        vector<int> v2 = v;\n        v2[2] -= 1;\n        v2[1] -= 8;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            dfs(v2,cnt+1);\n        return;\n        }\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        if(ss.find(v) != ss.end()) return;\n        ss.insert(v);\n        dfs(v,cnt+1);\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        ss.clear();\n        vector<int> v(10,0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1000000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nint cnt[10];\nvector<int> use;\n\n\nbool func(int x){\n\tif( x == 0 ) return true;\n\t\n\tfor(int i = x; i > 0; --i){\n\t\tif( !cnt[i] ) continue;\n\t\t\n\t\t--cnt[i];\n\t\tuse.push_back(i);\n\t\tif( func(x - i) ){\n\t\t\treturn true;\n\t\t}\n\t\t++cnt[i];\n\t\tuse.pop_back();\n\t}\n}\n\n\nint main(){\n\tint n, x;\n\tuse.reserve(16);\n\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tfill(cnt, cnt + 10, 0);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 9; i > 0; ){\n\t\t\tif( !cnt[i] ) --i;\n\t\t\telse{\n\t\t\t\t--cnt[i];\n\t\t\t\tuse.push_back(i);\n\t\t\t\t\n\t\t\t\tif( func(10 - i) ){\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j = 0; j < use.size(); ++j){\n\t\t\t\t\t\t++cnt[use[j]];\n\t\t\t\t\t}\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tuse.clear();\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(int kind,int wgt,const map<char,char> &v){\n  if(kind==0){\n    map<char,char> nv=v;\n    //nv[0]=0;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const map<char,char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else nv[it->first]-=it->second;\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  //return dp[pos][v]=res;\n  if(lim<100000){\n    lim++;\n    return dp[pos][v]=res;\n  }\n  else return res;\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    lim=0;\n    map<char,char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n// int N;\n// int MS[101];\n// vector<map<char,char> > howToGet;\n// map<map<char,char>,char> dp[43];\n// void dfs(const int kind,int wgt,map<char,char> v){\n//   if(kind==0){\n//     map<char,char> nv=v;\n//     dfs(kind+1,wgt,nv);\n//   }\n//   else if(wgt==0)howToGet.push_back(v);\n//   else if(kind==10)return;\n//   else{\n//     for(int i=0;i*kind<=10;i++){\n//       if(wgt-i*kind>=0){\n// \tmap<char,char> nv=v;\n// \tif(i>=1)nv[kind]=i;\n// \tdfs(kind+1,wgt-i*kind,nv);\n//       }\n//     }\n//   }\n// }\n\n// void dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n//   if(pos==(int)howToGet.size())return;\n//   if(preLast/10+cnt<=maxVal)return;\n//   // 1セット分取れるか\n//   map<char,char> nv=v;\n//   bool ok=true;\n//   int sz=0;\n//   for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n//     if(nv.count(it->first)==0\n//        ||nv[it->first]-(it->second)<0){\n//       ok=false;\n//       break;\n//     }\n//     else{\n//       nv[it->first]-=it->second;\n//       sz+=it->second;\n//     }\n//   }\n//   // 1セット取れるならとる\n//   if(ok){\n//     maxVal=max(maxVal,cnt+1);\n//     dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n//   }\n//   // 取らずに次のセットへ\n//   dfs2(pos+1,v,cnt,maxVal,preLast);\n// }\n\n// void greedy(int &maxVal,map<char,char> v){\n//   for(int pos=0;pos<(int)howToGet.size();pos++){\n//     while(1){\n//       bool ok=true;\n//       for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n// \tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n// \t  ok=false;\n// \t  break;\n// \t}\n//       }\n//       if(ok){\n// \tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n// \t  v[it->first]-=it->second;\n// \tmaxVal++;\n//       }\n//       else\n// \tbreak;\n//     }\n//   }\n// }\n\n// int main(){\n//   dfs(0,10,map<char,char>());\n//   while(cin>>N&&N){\n//     map<char,char> cnts;\n//     int preLast=0;\n//     for(int i=0;i<N;i++)cin>>MS[i];\n//     for(int i=0;i<N;i++){\n//       cnts[MS[i]]++;\n//       preLast+=MS[i];\n//     }\n//     for(int i=0;i<43;i++)dp[i].clear();\n//     int maxVal=0;\n//     greedy(maxVal,cnts);\n//     // cout<<maxVal<<endl;\n//     // dfs2(0,cnts,0,maxVal,preLast);\n//     cout<<maxVal<<endl;\n//   }\n//   return 0;\n// }\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    int sum=0;\n    for(int i=1;i<=5;i++){\n      int a=min(cnts[i],cnts[10-i]);\n      cnts[i]-=a;cnts[10-i]-=a;\n      sum+=a;\n    }\n    int res=dfs2(cnts)+sum;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\t// return;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=0;\n\t\treep(i,2,11){\n\t\t\tfor(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\tbool f=true;\n\t\t\t\trep(k,vv[i][j].size()){\n\t\t\t\t\ta[vv[i][j][k]]--;\n\t\t\t\t}\n\t\t\t\trep(k,10){\n\t\t\t\t\tif(a[k]<0) f=false;\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trep(k,vv[i][j].size()){\n\t\t\t\t\t\ta[vv[i][j][k]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 9; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n    dp.clear();\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(int i, vector<int> v)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tint sum = 0;\n\tfor (int j = 0; j < 9; j++){\n\t\tsum += (j + 1) * v[j];\n\t}\n\tif (sum < 10) return 0;\n\t\n\tif (i == T.size()) return 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tint sum = 0;\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tsum += (k + 1) * v[k];\n\t\t}\n\t\tif (j + sum / 10 > res){\n\t\t\tres = max(res, j + dfs(i + 1, v));\n\t\t}\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> diff(const vector<int>& a, const vector<int>& b)\n{\n    vector<int> res(10);\n    for (int i = 1; i <= 9; i++) {\n        res[i] = a[i] - b[i];\n    }\n    return res;\n}\n\nbool check_diff(const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 1; i <= 9; i++) {\n        if (a[i] < b[i]) return 0;\n    }\n    return 1;\n}\n\nmap<vector<int>, int> mem;\nvector<vector<int>> pat;\n\nbool check(const vector<int>& p)\n{\n    int res = 0, cnt = 0;\n    for (int i = 1; i <= 9; i++) {\n        cnt += p[i];\n        res += p[i] * i;\n    }\n    return (res == 10 && cnt > 2);\n}\n\nvoid make_pattern(int n, const vector<int>& p)\n{\n    if (n == 10) {\n        if (check(p)) {\n            pat.emplace_back(p);\n        }\n        return;\n    }\n    for (int i = 0; i <= 10 / n; i++) {\n        vector<int> np = p;\n        np[n] += i;\n        make_pattern(n + 1, np);\n    }\n}\n\nint solve(const vector<int>& m_cnt)\n{\n    int res = 0;\n    if (mem.count(m_cnt) != 0) {\n        return mem[m_cnt];\n    }\n\n    for (const auto& p : pat) {\n        if (check_diff(m_cnt, p)) {\n            res = max(res, solve(diff(m_cnt, p)) + 1);\n        }\n    }\n    return mem[m_cnt] = res;\n}\n\nint main()\n{\n    int N;\n    make_pattern(1, vector<int>(10));\n    while (cin >> N, N > 0) {\n        vector<int> m_cnt(10);\n        for (int i = 0; i < N; i++) {\n            int m;\n            cin >> m;\n            m_cnt[m]++;\n        }\n\n        int res = 0;\n        for (int i = 1; i <= 5; i++) {\n            int mini = min(m_cnt[i], m_cnt[10 - i]); \n            if (i == 5) mini /= 2;\n            res += mini;\n            m_cnt[i] -= mini;\n            m_cnt[10 - i] -= mini;\n        }\n        mem.clear();\n        res += solve(m_cnt);\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef pair<pr , pr > ppr;\nint num[5]={},numTimes[5]={},numbers;\nvector<vector<int> > p; \nvoid search(int times,int gets[5]){\n\tif(times==numbers){\n\t\n\t\tint sum=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\t\tsum+=num[i]*gets[i];\n\t\tif(sum==10){\n\t\t\tvector<int> a={gets[0],gets[1],gets[2],gets[3],gets[4]};\n\t\tp.push_back(a);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<=numTimes[times] && i<=10 ;i++){\n\t\tgets[times]=i;\n\t\tsearch(times+1,gets);\n\t\t}\n\t}\n}\nint findAns(int x,int times[]){\n\tif (x==p.size())\n\t\treturn 0;\n\tint maxim=0,ans=1;\n\tint ar[5];\n\tfor(int i=0;i<5;i++)\n\tar[i]=p[x][i];\n\tfor(int i=0;i<numbers;i++){\n\t\tif(ar[i]>times[i])\n\t\t\tans=0;\n\t\ttimes[i]-=ar[i];\n\t}\n\tif(ans)\n\tmaxim=max(maxim,1+findAns(x,times));\n\tfor(int i=0;i<numbers;i++)\n\t\ttimes[i]+=ar[i];\n\tmaxim=max(maxim,findAns(x+1,times));\n\treturn maxim;\n}\nint solved(vector<pr> v){\n\t\tint ans=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tnum[i]=v[i].first;\n\t\t\tnumTimes[i]=v[i].second;\n\t\t}\n\t\tnumbers=v.size();\n\t\tint gets[5]={};\n\t\tsearch(0,gets);\n\t\treturn findAns(0,numTimes);\n}\nint main() {\n\t// your code goes here\n\tint n,tmp;\n\twhile(cin >> n && n!=0){\n\t\tp.clear();\n\t\tnumbers=0;\n\t\tvector<pr > v;\n\t\tint nums[10]={},sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\tnums[tmp]++;\n\t\t}\n\t\tfor(int i=1;i<=4;i++)\n\t\t\tif(nums[i] && nums[10-i]){\n\t\t\t\tint manju=min(nums[i],nums[10-i]);\n\t\t\t\tsum+=manju;\n\t\t\t\tnums[i]-=manju;\n\t\t\t\tnums[10-i]-=manju;\n\t\t\t}\n\t\tsum+=nums[5]/2;\n\t\tnums[5]%=2;\n\t\tfor(int i=1;i<=8;i++)\n\t\t\tif(nums[i])\n\t\t\t\tv.push_back(pr(i,nums[i]));\n\t\tcout << sum+solved(v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nVV(pii) vp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int t1){\n\tull aa=hash();\n\tif(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\t// if(y<2) return 0;\n\tint ret=0;\n\treep(i,t1,vp.size()){\n\t\tbool f=true;\n\t\trep(j,vp[i].size()){\n\t\t\tf&=(0<=(a[vp[i][j].F]-=vp[i][j].S));\t\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(i)+1);\n\t\t}\n\t\trep(j,vp[i].size()){\n\t\t\ta[vp[i][j].F]+=vp[i][j].S;\n\t\t}\n\t}\n\t// reep(j,t2,vp[t1].size()){\n\t\t// rep(k,vp[t1][j].size()){\n\t\t\t// a[vp[t1][j][k].F]-=vp[t1][j][k].S;\n\t\t// }\n\t\t// bool f=true;\n\t\t// reep(k,1,10){\n\t\t\t// if(a[k]<0) f=false;\n\t\t// }\n\t\t// if(f){\n\t\t\t// ret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t// }\n\t\t// rep(k,vp[t1][j].size()){\n\t\t\t// a[vp[t1][j][k].F]+=vp[t1][j][k].S;\n\t\t// }\n\t// }\n\t// reep(i,t1+1,11){\n\t\t// rep(j,vp[i].size()){\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// a[vp[i][j][k].F]-=vp[i][j][k].S;\n\t\t\t// }\n\t\t\t// bool f=true;\n\t\t\t// reep(k,1,10){\n\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t// }\n\t\t\t// if(f){\n\t\t\t\t// ret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t// }\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// a[vp[i][j][k].F]+=vp[i][j][k].S;\n\t\t\t// }\n\t\t// }\n\t// }\n\treturn ma[aa]=ret;\n\t// return ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\trep(i,vv.size()){\n\t\tVV(pii) tmp;\n\t\trep(j,vv[i].size()){\n\t\t\tint t1=vv[i][j][0];\n\t\t\tint t2=0;\n\t\t\tvector<pii> vpii;\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\tif(t1==vv[i][j][k]){\n\t\t\t\t\tt2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvpii.PB(pii(t1,t2));\n\t\t\t\t\tt1=vv[i][j][k];\n\t\t\t\t\tt2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvpii.PB(pii(t1,t2));\n\t\t\ttmp.PB(vpii);\n\t\t}\n\t\trep(i,tmp.size()){\n\t\t\tvp.PB(tmp[i]);\n\t\t}\n\t}\n\t// rep(i,vp.size()){\n\t\t// cout<<endl;\n\t\t// cout<<\"i \"<<i<<endl;\n\t\t// rep(j,vp[i].size()){\n\t\t\t// cout<<\" j \"<<j<<endl;\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// cout<<\"  \"<<vp[i][j][k].F<<\" \"<<vp[i][j][k].S<<endl;\n\t\t\t// }\n\t\t// }\n\t// }\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans1=0;\n\t\treep(i,1,5){\n\t\t\twhile(a[i]&&a[10-i]) ans1++,a[i]--,a[10-i]--;\n\t\t}\n\t\twhile(a[5]>=2) ans1++,a[5]-=2;\n\t\trep(i,vv[3].size()){\n\t\t\tbool f=true;\n\t\t\twhile(f){\n\t\t\t\trep(j,vv[3][i].size()){\n\t\t\t\t\tf&=0<=(--a[vv[3][i][j]]);\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\trep(j,vv[3][i].size()){\n\t\t\t\t\t\t++a[vv[3][i][j]];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans1++;\n\t\t\t}\n\t\t}\n\t\tint ans2=dfs(0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans1+ans2<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint ans;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i<=5;i++){\n        if((i != 5 && v[i] >= 1 && v[10-i] >= 1) || (i == 5 && v[5] >= 2)){\n            vector<int> v2 = v;\n            v2[i]--;\n            v2[10-i]--;\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i<10;i++){\n        for(int j=i;i+j<10;j++){\n            int k = 10 - i - j;\n            if(k < j) break;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i<10;i++){\n        for(int j=i;i+j<10;j++){\n            for(int k=j;i+j+k<10;k++){\n                int l = 10 - i - j - k;\n                if(l < k) break;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i<10;i++){\n        for(int j=i;i+j<10;j++){\n            for(int k=j;i+j+k<10;k++){\n                for(int l=k;i+j+k+l<10;l++){\n                    int m = 10 - i - j - k - l;\n                    if(m < l) break;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i<10;i++){\n        for(int j=i;i+j<10;j++){\n            for(int k=j;i+j+k<10;k++){\n                for(int l=k;i+j+k+l<10;l++){\n                    for(int m=l;i+j+k+l+m<10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        if(n < m) break;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i<10;i++){\n        for(int j=i;i+j<10;j++){\n            for(int k=j;i+j+k<10;k++){\n                for(int l=k;i+j+k+l<10;l++){\n                    for(int m=l;i+j+k+l+m<10;m++){\n                        for(int n=m;i+j+k+l+m+n<10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            if(o < n) break;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 2 && v[1] >= 7){\n        v[2] -= 2;\n        v[1] -= 7;\n        dfs(v,cnt+1);\n        return;\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        dfs(v,cnt+1);\n        return;\n    }\n}\n\n\nint main(){\n    int n;\n\twhile(cin >> n && n){\n        vector<int> v(10,0);\n\t\tans = 0;\n\t\tfor(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 1; i <= 9 ; i++ ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 99 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\n\nint dfs(int cnt,int sum,vector<int> remain){\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n  int maxcost = cnt;\n  REP(i,1,10){\n    if( remain[i] == 0 ) continue;\n    int nsum = sum + i;\n    if( nsum >  10 ) continue;\n    remain[i]--;\n    if( nsum == 10 ) {\n      maxcost = max(maxcost,dfs(cnt+1,0,remain));\n    } else {\n      maxcost = max(maxcost,dfs(cnt,nsum,remain));\n    }\n    remain[i]++;\n  }\n  if( sum == 0 ) memo[remain] = maxcost;\n  return maxcost;  \n}\n\n\nint main() {\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= 2*tmp;\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 10; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1800000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1800000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\nvector<vector<int> > LOOP;\n\nint dfs(int cur,int cnt,vector<int> &remain){\n\n  if( cur >= limit ) {\n    return cnt;\n  }\n\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n\n  vector<int> tmp = remain;\n  bool update = true;\n  int ret = cnt;\n  while( update ){\n    ret = max(ret,dfs(cur+1,cnt,remain));\n    cnt++;\n    REP(i,1,10) {\n      remain[i] -= LOOP[cur][i];\n      if( remain[i] < 0 ) {\n        update = false;\n        break;\n      }\n    }\n  }\n  remain = tmp;\n  return memo[remain] = ret;\n}\n\nvoid precalc(int value,int sum,vector<int> &vec) {\n  if( value >= 10 ) {\n    if( sum == 10 ) LOOP.push_back(vec);\n    return;\n  }\n  rep(i,11){\n    if( sum + i * value > 10 ) break;\n    vec[value] = i;\n    precalc(value+1,sum+i*value,vec);\n    vec[value] = 0;\n  }\n  return;\n}\n\nint main() {\n\n  vector<int> buf(10,0);\n  precalc(1,0,buf);\n  sort(LOOP.begin(),LOOP.end());\n\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= 2*tmp;\n    limit = LOOP.size();\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1000000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > a;\nvoid manju(vector<int>& b, int prev, int sum, const vector<int>& x)\n{\n    if(sum > 10)\n        return;\n    if(sum == 10){\n        if(accumulate(b.begin(), b.end(), 0) > 2)\n            a.push_back(b);\n        return;\n    }\n\n    for(int i=prev; i<=9; ++i){\n        if(x[i] == 0)\n            continue;\n        ++ b[i];\n        sum += i;\n        manju(b, i, sum, x);\n        sum -= i;\n        -- b[i];\n    }\n}\n\nvector<map<vector<int>, int> > memo;\nint solve(const vector<int>& x, int k)\n{\n    if(k >= a.size())\n        return 0;\n\n    if(memo[k].find(x) != memo[k].end())\n        return memo[k][x];\n\n    int ret = solve(x, k+1);\n\n    vector<int> y = x;\n    bool ok = true;\n    for(int i=1; i<=9; ++i){\n        y[i] -= a[k][i];\n        if(y[i] < 0)\n            ok = false;\n    }\n    if(ok)\n        ret = max(ret, solve(y, k) + 1);\n\n    return memo[k][x] = ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        int ret = 0;\n        vector<int> x(10, 0);\n        for(int i=0; i<n; ++i){\n            int y;\n            cin >> y;\n            if(x[10-y] > 0){\n                -- x[10-y];\n                ++ ret;\n            }else{\n                ++ x[y];\n            }\n        }\n\n        a.clear();\n        vector<int> b(10, 0);\n        manju(b, 1, 0, x);\n\n        memo.assign(a.size(), map<vector<int>, int>());\n        ret += solve(x, 0);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint rec(vector< char >& cur);\n\nmap< vector< char >, int > dp;\n\nint make(vector< char >& cur, int idx, int sum)\n{\n  if(sum > 10)  return(0);\n  if(sum == 10) return(rec(cur) + 1);\n  if(idx == 10) return(0);\n  int ret = 0;\n  if(cur[idx] > 0) {\n    cur[idx]--;\n    ret += make(cur, idx, sum + idx);\n    cur[idx]++;\n  }\n  ret = max(ret, make(cur, idx + 1, sum));\n  return(ret);\n}\n\nint rec(vector< char >& cur)\n{\n  // if(dp.find(cur) != dp.end()) return(dp[cur]);\n  return(dp[cur] = make(cur, 1, 0));\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n\n    vector< char > cur(10, 0);\n    for(int i = 0; i < n; i++) {\n      int digit;\n      cin >> digit;\n      cur[digit]++;\n    }\n    int build = 0;\n    for(int i = 1; i < 5; i++) {\n      int cost = min(cur[i], cur[10 - i]);\n      build += cost;\n      cur[i] -= cost;\n      cur[10 - i] -= cost;\n    }\n    build += cur[5] / 2;\n    cur[5] -= cur[5] / 2;\n    cout << build + rec(cur) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<vector<int> > howToGet;\nmap<vector<int>,int> dp[43];\nvoid dfs(int kind,int wgt,const vector<int> &v){\n  if(kind==0){\n    vector<int>nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<int> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\nint dfs2(int pos,vector<int> v){\n  if(pos==(int)howToGet.size())return 0;\n  if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 今回の取り方でいくつとるか\n  for(int i=0;;i++){\n    vector<int> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=i*howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(ok)res=max(res,dfs2(pos+1,nv)+i);\n    else break;\n  }\n  return dp[pos][v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<int>());\n  while(cin>>N&&N){\n    vector<int> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\n\tif(num > 10){\n\t\tif(nowmax[num] < ko)\n\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n\tif(!find(flag,flag+N,true)){\n\t\tif(nowmax[num] < ko)\n\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n\t\t\tif(nowmax[num] > ko){\n\t\t\t\tans = max(ans,nowmax[num]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<Windows.h>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\n\treturn ret / 10;\n}\n\nbool solve(int m[], int pre, int step)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\t\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\t// solve(m, i, step + 1);\n\t\t\tif (solve(m, i, step + 1)) return true;\n\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\t\t}\n\t}\n\t// cout << (res) << endl;\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < s.size(); ++i){\n\t\t\tif (s[i].size() == sz){\n\t\t\t\tfor (int j = 0; j < s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ( true ) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tsolve(m, 0, 0);\n\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint t[10];\n\nint solve(int s = 10, int k = 9, int z = 999){\n\tint c = 0;\n\n\twhile( k && c < z ){\n\t\tint a;\n\t\tif( k != s - k ){\ta = min( t[k], t[s - k] );\t}\n\t\telse{\ta = t[k] / 2;\t}\n\n\t\tif( c + a >= z ){\n\t\t\tt[k] -= z - c;\n\t\t\tt[s - k] -= z - c;\n\t\t\treturn z;\n\t\t}\n\n\t\tc += a;\n\t\tt[k] -= a;\n\t\tt[s - k] -= a;\n\t\t\n\t\twhile( t[k] > 0 && c < z ){\n\t\t\t--t[k];\n\t\t\tif( solve( s - k, min(k, s - k - 1), 1) ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++t[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( c == z ){\n\t\t\treturn z;\n\t\t}\n\t\t\n\t\tif( s == 10 ) t[k] = 0;\n\t\t--k;\n\t}\n\n\treturn c;\n}\n\nint main(){\n\tint n, m;\n\tfor( ; scanf(\"%d\", &n), n; ){\n\t\tfill(t, t + 10, 0);\n\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf(\"%d\", &m);\n\t\t\t++t[m];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve() );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\tif(No == 9)\n\t\t\t\t\tmanto[10]++;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tprintf(\"%d\\n\", manto[10])\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nint sz[11];\n\nbool pack(int c, int d) {\n    if (d == 0) return c == 10;\n    for (int i = 10; i >= 1; i--) {\n        if (sz[i] > 0) {\n            sz[i]--;\n            if (pack(c+i, d-1)) {\n                return true;\n            } \n            sz[i]++;\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> n, n) {\n        memset(sz, 0, sizeof(sz));\n        for (int i = 0; i < n; i++) {\n            int cake; cin >> cake;\n            if (cake > 10) continue;\n            sz[cake]++;\n        }\n        int cnt = 0;\n        for (int i = 1; i <= 10; i++) {\n            while (pack(0, i)) {\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<vector<int> > sum10;\nvector<int> as;\n\nvoid dfs(vector<int> v, int now, int sum) {\n  if (sum == 10) {\n    sum10.push_back(v);\n    return;\n  }\n  if (now == as.size()) return;\n  dfs(v,now+1,sum);\n  if (sum + as[now] <= 10) {\n    v.push_back(now);\n    dfs(v,now,sum+as[now]);\n  }\n}\n\nmap<vector<int> , int> mp[50];\n\nint solve(int now, vector<int> v) {\n  if (now == sum10.size()) return 0;\n  if (mp[now].count(v)) return mp[now][v];\n  int &r = mp[now][v];\n  // if (now == 20) {\n  //   FOR(it, v) {\n  //     cout << *it << \" \";\n  //   }\n  //   cout << endl;\n  //   cout << now << endl;\n  // }\n  int res = 0;\n  REP(i,100) {\n    bool dame = 0;\n    res = max(res, solve(now+1, v) + i);\n    FOR(it, sum10[now]) {\n      if (v[*it]-- == 0) dame = 1;\n    }\n    if(dame) break;\n  }\n  return r = res;\n}\n\nint a[10];\n\nint main() {\n  // REP(i,9) as.push_back(i+1);\n  // vector<int> t;\n  // dfs(t,0,0);\n  // FOR(it, sum10) {\n  //   FOR(jt, *it) cout << *jt << \" \";\n  //   cout << endl;\n  // }\n  int n;\n  while(cin>>n,n) {\n    int ans = 0;\n    memset(a,0,sizeof(a));\n    REP(i,n) {\n      int b;cin >> b;\n      if (b >= 10) {\n        if (b == 10) ans++;\n      } else {\n        a[b]++;\n      }\n    }\n    for (int i=1; i<=4; ++i) {\n      int j = 10-i;\n      int m = min(a[i], a[j]);\n      a[i] -= m;\n      a[j] -= m;\n      ans += m;\n    }\n    ans += a[5] / 2;\n    a[5] -= a[5]/2;\n    vector<int> v;\n    as.clear();\n    REP(i,10) if (a[i]) {\n      as.push_back(i);\n      v.push_back(a[i]);\n    }\n    sum10.clear();\n    vector<int> t;\n    dfs(t,0,0);\n    REP(i,sum10.size()) mp[i].clear();\n    ans += solve(0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n;\nmap<vi, int> dp;\nint rec(vi &v, int sum, int pos){\n\tif(sum == 0 && pos == 0 && dp.count(v)) return dp[v];\n\tif(pos == 9) return sum == 10;\n\t\n\tint res = rec(v, sum, pos + 1);\n\tif(v[pos] && sum + pos + 1 <= 10){\n\t\tv[pos]--;\n\t\tres = max(res, rec(v, sum + pos + 1, pos + 1));\n\t\tv[pos]++;\n\t}\n\t\n\tif(sum == 0 && pos == 0) dp[v] = res;\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tdp.clear();\n\t\tvi v(9);\n\t\tint ans = 0;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t - 1]++;\n\t\t}\n\t\trep(i, 4){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tans += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tans += v[4] / 2;\n\t\tv[4] %= 2;\n\t\tcout << ans + rec(v, 0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint num[10];\n\nint getMax(int sum, int u)\n{\n\tint ans;\n\t\n\tif (u == 10){\n\t\treturn (0);\n\t}\n\t\n\tif (sum == 10){\n\t\treturn (1);\n\t}\n\t\n\tans = 0;\n\tfor (int i = u; i <= 9; i++){\n\t\tif (num[i] && sum + i <= 10){\n\t\t\tnum[i]--;\n\t\t\tans = max(ans, getMax(sum + i, u));\n\t\t\tnum[i]++;\n\t\t}\n\t}\n\t\n\treturn (max(ans, getMax(sum, u + 1)));\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\t\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(0, 1));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp[43];\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const vector<char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  vector<char> nv=v;\n  bool ok=true;\n  for(int j=1;j<(int)howToGet[pos].size();j++){\n    nv[j]-=howToGet[pos][j];\n    if(nv[j]<0){\n      ok=false;\n      break;\n    }\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  if(lim<1000000){\n    lim++;\n    return dp[pos][v]=res;\n  }\n  else\n    return res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    lim=0;\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint n;\nvi a(10);\nmap<vi,int> memo;\n\nint rec(vi v){\n  if(memo.find(v)!=memo.end())return memo[v];\n  \n  int res = 0;\n  for(int i=8;i>=1;i--){\n    if(v[i]){\n      if(v[0]+i==10){\n\tv[i]--; v[0] = 0;\n\tres = max(res,rec(v)+1);\n\tv[i]++; v[0] = 10-i;\n      }else if(v[0]+i<10){\n\tv[i]--; v[0] += i;\n\tres = max(res,rec(v));\n\tv[i]++; v[0] -= i;\n      }\n    }\n  }\n\n  return memo[v] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<10;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp]++;\n    }\n\n    int res = 0;\n    for(int i=1;i<=4;i++){\n      tmp = min(a[i],a[10-i]);\n      a[i]-=tmp; a[10-i]-=tmp;\n      res += tmp;\n    }\n    res += a[5]/2; a[5] &= 1;\n\n    memo.clear();\n    cout << res+rec(a) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// ナニソレイミワカンナイ\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    assert(i+base[0]*(j+base[1]*(k+base[2]*l)) < 1000000);\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d, %d\\n\", a, b, c, d, index, a+b+c+d);\n    // printf(\"[%d][%d][%d][%d]: %d\\n\",\n    //        i, j, k, l,\n    //        i+j*(at2(0)+1)+k*(at2(0)+at2(1)+2)+l*(at2(0)+at2(1)+at2(2)+3));\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", a, b, c, d, index, res);\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 500000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tvector<int> s_ = s;\n\t\tif( check(i, s_) ){\n\t\t\t\n\t\t\t//used(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[902394][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1800000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;\nset<vector<int> > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n//    if(table.count(tmp))return 0;\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n    table.insert(tmp);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> diff(const vector<int>& a, const vector<int>& b)\n{\n    vector<int> res(10);\n    for (int i = 1; i <= 9; i++) {\n        res[i] = a[i] - b[i];\n    }\n    return res;\n}\n\nbool check_diff(const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 1; i <= 9; i++) {\n        if (a[i] < b[i]) return 0;\n    }\n    return 1;\n}\n\nmap<vector<int>, int> mem;\nvector<vector<int>> pat;\n\nint sum(const vector<int>& p)\n{\n    int res = 0;\n    for (int i = 1; i <= 9; i++) {\n        res += p[i] * i;\n    }\n    return res;\n}\n\nvoid make_pattern(int n, const vector<int>& p)\n{\n    if (n == 10) {\n        if (sum(p) == 10) {\n            pat.emplace_back(p);\n        }\n        return;\n    }\n    for (int i = 0; i <= 10 / n; i++) {\n        vector<int> np = p;\n        np[n] += i;\n        make_pattern(n + 1, np);\n    }\n}\n\nint solve(const vector<int>& m_cnt)\n{\n    int res = 0;\n    if (mem.count(m_cnt) != 0) {\n        return mem[m_cnt];\n    }\n\n    for (const auto& p : pat) {\n        if (check_diff(m_cnt, p)) {\n            res = max(res, solve(diff(m_cnt, p)) + 1);\n        }\n    }\n    return mem[m_cnt] = res;\n}\n\nint main()\n{\n    int N;\n    make_pattern(1, vector<int>(10));\n    while (cin >> N, N > 0) {\n        vector<int> m_cnt(10);\n        for (int i = 0; i < N; i++) {\n            int m;\n            cin >> m;\n            m_cnt[m]++;\n        }\n\n        int res = 0;\n        for (int i = 1; i <= 5; i++) {\n            int mini = min(m_cnt[i], m_cnt[10 - i]); \n            if (i == 5) mini /= 2;\n            res += mini;\n            m_cnt[i] -= mini;\n            m_cnt[10 - i] -= mini;\n        }\n        mem.clear();\n        res += solve(m_cnt);\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> v, int sum)\n{\n\tif (sum < 10) return dp[v] = 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int i = 0; i < T.size(); i++){\n\t\tvector<int> vv = v;\n\t\tbool f = true;\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tvv[k] -= T[i][k];\n\t\t\tif (vv[k] < 0) f = false;\n\t\t}\n\t\tif (!f) continue;\n\t\tif (sum / 10 <= res) continue;\n\t\tres = max(res, 1 + dfs(vv, sum - 10));\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tdp.clear();\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 9; i++){\n\t\t\tsum += (i + 1) * v[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(v, sum));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n\n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\nint rem()\n{\n    int s[10] = { };\n    for (int i = 0; i < n; ++i)\n        ++s[a[i]];\n\n    int ten = 0;\n    for (int i = 1; i < 5; ++i)\n    {\n        int t = min(s[i], s[10 - i]);\n        s[i] -= t;\n        s[10 - i] -= t;\n        ten += t;\n    }\n    ten += s[5] / 2;\n    s[5] %= 2;\n\n    n = 0;\n    for (int i = 1; i <= 9; ++i)\n        while (s[i]-- > 0)\n            a[n++] = i;\n\n    return ten;\n}\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < 100; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        int t = rem();\n        int res = solve() + t;\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<pair<int, Manju>, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(int pos, Manju T) {\n\tif (pos == S.size())return 0;\n\tif (M[make_pair(pos, T)] != 0)return M[make_pair(pos, T)];\n\tint maxn = 0, cnt = 0; Manju U = T;\n\twhile (true) {\n\t\tmaxn = max(maxn, manju(pos + 1, U) + cnt);\n\t\tfor (int i = 0; i < 10; i++) { U.k[i] -= S[pos].k[i]; }\n\t\tbool flag = true; for (int i = 0; i < 10; i++) { if (U.k[i] < 0)flag = false; }\n\t\tif (flag == false)break;\n\t\tcnt++;\n\t}\n\tM[make_pair(pos, T)] = maxn;\n\treturn  maxn;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tfor (int i = 1; i < 5; i++) { int WW = min(A.k[10 - i], A.k[i]); A.k[10 - i] -= WW; A.k[i] -= WW; adv += WW; }\n\t\tadv += A.k[5] / 2; A.k[5] %= 2;\n\t\tcout << manju(0, A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef pair<pr , pr > ppr;\ntypedef pair<int,vector<int> > pv;\nint num[5]={},numTimes[5]={},numbers,alls;\nvector<pv > p; \nvoid search(int times,int gets[5]){\n\tif(times==numbers){\n\t\n\t\tint sum=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\t\tsum+=num[i]*gets[i];\n\t\tif(sum==10){\n\t\t\tpv a;\n\t\t\ta.first=-1;\n\t\t\tfor(int i=0;i<numbers;i++){\n\t\t\t\ta.second.push_back(gets[i]);\n\t\t\t\tif(a.first==-1 && gets[i]!=0)\n\t\t\t\ta.first=100-num[i];\n\t\t\t}\n\t\t\t\t\n\t\tp.push_back(a);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<=numTimes[times] && i<=10 ;i++){\n\t\tgets[times]=i;\n\t\tsearch(times+1,gets);\n\t\t}\n\t}\n}\nint findAns(int x,int times[]){\n\tif (x==p.size())\n\t\treturn 0;\n\tint maxim=0,ans=1;\n\tint ar[5];\n\tfor(int i=0;i<5;i++)\n\tar[i]=p[x].second[i];\n\tfor(int i=0;i<numbers;i++){\n\t\tif(ar[i]>times[i])\n\t\t\tans=0;\n\t\ttimes[i]-=ar[i];\n\t}\n\tif(ans)\n\tmaxim=max(maxim,1+findAns(x,times));\n\tfor(int i=0;i<numbers;i++)\n\t\ttimes[i]+=ar[i];\n\tif(!ans)\n\tmaxim=max(maxim,findAns(x+1,times));\n\treturn maxim;\n}\nint solved(vector<pr> v){\n\t\tint ans=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tnum[i]=v[i].first;\n\t\t\tnumTimes[i]=v[i].second;\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tnumbers=v.size();\n\t\tint gets[5]={};\n\t\talls=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\talls+=num[i]*numTimes[i];\n\t\tsort(p.begin(),p.end());\n\t\tsearch(0,gets);\n\t\treturn findAns(0,numTimes);\n}\nint main() {\n\t// your code goes here\n\tint n,tmp;\n\twhile(cin >> n && n!=0){\n\t\tp.clear();\n\t\tfor(int i=0;i<5;i++){\n\t\t\tnum[i]=0;\n\t\t\tnumTimes[i]=0;\n\t\t}\n\t\t\n\t\tnumbers=0;\n\t\tvector<pr > v;\n\t\tint nums[10]={},sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\tnums[tmp]++;\n\t\t}\n\t\tfor(int i=1;i<=4;i++)\n\t\t\tif(nums[i] && nums[10-i]){\n\t\t\t\tint manju=min(nums[i],nums[10-i]);\n\t\t\t\tsum+=manju;\n\t\t\t\tnums[i]-=manju;\n\t\t\t\tnums[10-i]-=manju;\n\t\t\t}\n\t\tsum+=nums[5]/2;\n\t\tnums[5]%=2;\n\t\tfor(int i=1;i<=8;i++)\n\t\t\tif(nums[i])\n\t\t\t\tv.push_back(pr(i,nums[i]));\n\t\tcout << sum+solved(v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\n//map<wolf,int> dp;\nint solve(wolf a,int b){\n//\tif((int)(dp.count(a)))return dp[a];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n//\treturn dp[a]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\t//if( 800000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int> buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 10; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[33*33*33*33][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    assert(i+base[0]*(j+base[1]*(k+base[2]*l)) < 33*33*33*33);\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d, %d\\n\", a, b, c, d, index, a+b+c+d);\n    // printf(\"[%d][%d][%d][%d]: %d\\n\",\n    //        i, j, k, l,\n    //        i+j*(at2(0)+1)+k*(at2(0)+at2(1)+2)+l*(at2(0)+at2(1)+at2(2)+3));\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", a, b, c, d, index, res);\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint n;\nvi a(10);\nmap<vi,int> memo;\n\nint rec(vi v){\n  if(memo.find(v)!=memo.end())return memo[v];\n  \n  int res = 0;\n  for(int i=8;i>=1;i--){\n    if(v[i]){\n      if(v[9]+i==10){\n\tv[i]--; v[9] = 0;\n\tres = max(res,rec(v)+1);\n\tv[i]++; v[9] = 10-i;\n      }else if(v[9]+i<10){\n\tv[i]--; v[9] += i;\n\tres = max(res,rec(v));\n\tv[i]++; v[9] -= i;\n      }\n    }\n  }\n\n  return memo[v] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<10;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp]++;\n    }\n\n    int res = 0;\n    for(int i=1;i<=4;i++){\n      tmp =  min(a[i],a[10-i]);\n      a[i]-=tmp; a[10-i]-=tmp;\n      res += tmp;\n    }\n    res += a[5]/2; a[5] &= 1;\n      \n    memo.clear();\n    cout << res+rec(a) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nbool dfs(vector<int>& manju, int start, int n, int sum) {\n    if(sum == 0) return true;\n    if(n == 0) return false;\n    for(int i = start; i < manju.size(); ++i) {\n        if(manju[i] > sum) continue;\n        if(!dfs(manju, i + 1, n - 1, sum - manju[i])) continue;\n        manju.erase(manju.begin() + i);\n        return true;\n    }\n    return false;\n}\n\nint solve(vector<int>& manju) {\n    int result = 0;\n    sort(manju.begin(), manju.end(), greater<int>());\n    for(int i = 2; i < manju.size(); ++i) {\n        while(dfs(manju, 0, i, 10)) ++result;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<int> manju(n);\n        for(auto& v: manju) cin >> v;\n        cout << solve(manju) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nint cnt[10];\n\n\nbool func(int x){\n\tif( x == 0 ) return true;\n\t\n\tfor(int i = x; i > 0; --i){\n\t\tif( !cnt[i] ) continue;\n\t\t\n\t\t--cnt[i];\n\t\tif( func(x - i) ){\n\t\t\treturn true;\n\t\t}\n\t\t++cnt[i];\n\t}\n\t\n\treturn false;\n}\n\n\nint main(){\n\tint n, x;\n\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tfill(cnt, cnt + 10, 0);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t\t\n\t\t\tif(x < 1 || x > 9) throw 1;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 9; i > 0; ){\n\t\t\tif( !cnt[i] ) --i;\n\t\t\telse{\n\t\t\t\t--cnt[i];\n\t\t\t\t\n\t\t\t\tif( func(10 - i) ){\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint f[5];\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nbool ok[10];\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tif (ok[i]){\n\t\t\tt[i]++;\n\t\t\tmake(t, rem - i, rem - i);\n\t\t\tt[i]--;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tmemset(ok, false, sizeof(ok));\n\t\t\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\tif (num[i]) ok[i] = true;\n\t\t}\n\t\t\n\t\tmp.clear();\n\t\tmake(t, 9, 10);\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<vector<int>, int> dp;\n\nint rec(vector<int> &v, int sum){\n    if(dp.count(v)) return dp[v];\n    int res = 0;\n    for(int i=9; i>=1; i--){\n        if(v[i]>0 && sum+i<=10){\n            v[i]--;\n            res = max(res, rec(v, (sum+i)%10)+(sum+i)/10);\n            v[i]++;\n        }\n    }\n    return dp[v] = res;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<int> v(10,0);\n        int ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n        for(int i=1;i<=4;i++){\n            int tmp = min(v[i], v[10-i]);\n            ans += tmp;\n            v[i] -= tmp;\n            v[10-i] -= tmp;\n        }\n        ans += v[5]/2;\n        v[5] %= 2;\n        dp.clear();\n        ans += rec(v, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n;\nmap<vi, int> dp;\nint rec(vi &v, int sum, int pos){\n\tif(sum == 0 && pos == 0 && dp.count(v)) return dp[v];\n\tif(pos == 9) return sum == 10 ? 1 + rec(v, 0, 0) : 0;\n\t\n\tint res = rec(v, sum, pos + 1);\n\tfor(int i = 1; i <= v[pos] && sum + (pos + 1) * i <= 10; i++){\n\t\tv[pos] -= i;\n\t\tres = max(res, rec(v, sum + (pos + 1) * i, pos + 1));\n\t\tv[pos] += i;\n\t}\n\tif(sum == 0 && pos == 0) dp[v] = res;\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tdp.clear();\n\t\tvi v(9);\n\t\tint ans = 0;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t - 1]++;\n\t\t}\n\t\trep(i, 4){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tans += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tans += v[4] / 2;\n\t\tv[4] %= 2;\n\t\tcout << ans + rec(v, 0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // (i+base[0]*(j+base[1]*(k+base[2]*l)) < 1000000)\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // assert(i+base[0]*(j+base[1]*(k+base[2]*l)) < 1000000);\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d, %d\\n\", a, b, c, d, index, a+b+c+d);\n    // printf(\"[%d][%d][%d][%d]: %d\\n\",\n    //        i, j, k, l,\n    //        i+j*(at2(0)+1)+k*(at2(0)+at2(1)+2)+l*(at2(0)+at2(1)+at2(2)+3));\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", a, b, c, d, index, res);\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\n//map<wolf,int> dp;\nint solve(wolf a,int b){\n//\tif((int)(dp.count(a)))return dp[a];\n\tint ret=0;\n\tfor(int i=b;i>=0;i--){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,35));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\nset<vector<int> > mm;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( mm.count(s) ) return;\n\t\n\tif( foo < 100000 ){\n\t\tmm.insert(s);\n\t}\n\t\n\tfoo++;\n\t//if( 7500000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tmm.clear();\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 9; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  buns = prev;\n  res = max(res,dfs(buns,sum,comb_i + 1,all_combinations));\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n    dp.clear();\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint solve(vi& ms,vi& used,int remain,int index)\n{\n\tint n=ms.size();\n\t\n\tif(remain==0)\n\t\treturn 1+solve(ms,used,10,0);\n\telse{\n\t\tint res=0;\n\t\trepi(i,index,n){\n\t\t\tif(used[i] || ms[i]>remain)\n\t\t\t\tcontinue;\n\t\t\tif(i>0 && ms[i-1]==ms[i] && !used[i-1]) // 1つ前の同じ重さの饅頭を選んでいない\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tused[i]=1;\n\t\t\tres=max(res,solve(ms,used,remain-ms[i],i+1));\n\t\t\tused[i]=0;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi hist(10);\n\t\trep(i,n){\n\t\t\tint m; scanf(\"%d\",&m);\n\t\t\thist[m]++;\n\t\t}\n\t\t\n\t\tint res=0;\n\t\trepi(i,1,5)\n\t\t\twhile(hist[i] && hist[10-i]){\n\t\t\t\tres++;\n\t\t\t\thist[i]--;\n\t\t\t\thist[10-i]--;\n\t\t\t}\n\t\twhile(hist[5]>=2){\n\t\t\tres++;\n\t\t\thist[5]-=2;\n\t\t}\n\t\t\n\t\tvi ms;\n\t\tper(i,10)\n\t\t\tms.insert(ms.end(),hist[i],i);\n\t\tvi used(ms.size());\n\t\tres+=solve(ms,used,10,0);\n\t\t\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint greedy;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\n\treturn ret / 10;\n}\n\nbool solve(int m[], int pre, int step, bool bgreedy)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\n\tif (!bgreedy) {\n\t\t// cout << step << \" \"  << ideal(m) << endl;\n\t\tif (step + ideal(m) <= greedy){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tif (bgreedy){\n\t\t\t\tif (solve(m, i, step + 1, greedy)) return true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsolve(m, i, step + 1, greedy);\n\t\t\t}\n\t\t\t\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\t\t}\n\t}\n\t// cout << (res) << endl;\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < s.size(); ++i){\n\t\t\tif (s[i].size() == sz){\n\t\t\t\tfor (int j = 0; j < s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ( true ) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tsolve(m, 0, 0, true);\n\t\tgreedy = res;\n\t\t// cout << greedy << endl;\n\t\tres = 0;\n\t\tsolve(m, 0, 0, false);\n\n\t\tif (res < greedy) res = greedy;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[11],da[43][11],dn[43],h,v,n,f,an,z;\n\nint list(int n,int k,int g) {\n\tint i; \n\tif (k==10 && n==h) { for (i=0;i<h;i++) da[v][a[i]]++; dn[v]=h; v++; }\n\tif (n==h || k>=10) return 1;\n\tfor (i=g;i<10;i++) { a[n]=i; list(n+1,k+i,i);}\n\treturn 0;\n}\n\nint dfs(int g,int u,int t) {\n\tint i,j;\n\tif (an<g)  an=g;\n\tif (g+t/dn[u]<=an) return 0;\n\tfor (i=u;i<41;i++) {\n\t\tf=0;\n\t\tfor (j=1;j<10;j++) if (a[j]<da[i][j]) f=1;\n\t\tif (f==0) { for(j=1;j<10;j++) a[j]-=da[i][j]; dfs(g+1,i,t-dn[i]); for(j=1;j<10;j++) a[j]+=da[i][j];}\n\t\t}\n  return 0;\n}\n\nint main() {\n\tint i,j;\n\tv=0;\n\tfor (i=0;i<40;i++) for (j=0;j<11;j++) da[i][j]=0;\n\tfor (i=2;i<11;i++) { h=i; list(0,0,1); }\n\twhile(cin >> n && n>0) {\n\t\tfor (i=0;i<11;i++) a[i]=0;\n\t\tfor (i=0;i<n;i++) { cin >> j; a[j]++; }\n\t\tv=0; an=0;\n\t\tdfs(0,0,n);\n\t\tcout << an << endl;\t\n\t    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n\nint ans = 0;\nint C = 0; \nvoid dfs(int pos,long long v){\n    if( pos >= e.size() ) return;\n\tans = max( ans , C );\n    int c = 0;\n    while(1){\n\t\tC += c;\n        dfs(pos+1,v);\n\t\tC -= c;\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n}\n  \n  \n \n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n    while(cin >> n && n){\n\t\t//random_shuffle(e.begin(),e.end());\n        vector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n\t\tC = 0;\n\t\tans = 0;\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n\t\tdfs(0,enc);\n        cout << ans+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint dfs(int i,int sum,int *a){\n\tif(sum==10){\n\t\treturn 1+dfs(1,0,a);\n\t}\n\tif(i>=10) return 0;\n\n\tint res=dfs(i+1,sum,a);\n\tif(a[i]>0 && sum+i<=10){\n\t\ta[i]--;\n\t\tres=max(res,dfs(i,sum+i,a));\n\t\ta[i]++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum+dfs(1,0,a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 9; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  buns = prev;\n  res = max(res,dfs(buns,sum,comb_i + 1,all_combinations));\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n  sort(all_combinations.begin(),all_combinations.end());\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n    dp.clear();\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef pair<pr , pr > ppr;\ntypedef array<int,5> arafi;\nint num[5]={},numTimes[5]={},numbers;\nvector<array<int,5> > p; \nvoid search(int times,int gets[5]){\n\tif(times==numbers){\n\t\n\t\tint sum=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\t\tsum+=num[i]*gets[i];\n\t\tif(sum==10){\n\t\t\tarafi a={gets[0],gets[1],gets[2],gets[3],gets[4]};\n\t\tp.push_back(a);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<=numTimes[times] && i<=10 ;i++){\n\t\tgets[times]=i;\n\t\tsearch(times+1,gets);\n\t\t}\n\t}\n}\nint findAns(int x,int times[]){\n\tif (x==p.size())\n\t\treturn 0;\n\tint maxim=0,ans=1;\n\tarafi ar=p[x];\n\tfor(int i=0;i<numbers;i++){\n\t\tif(ar[i]>times[i])\n\t\t\tans=0;\n\t\ttimes[i]-=ar[i];\n\t}\n\tif(ans)\n\tmaxim=max(maxim,1+findAns(x,times));\n\tfor(int i=0;i<numbers;i++)\n\t\ttimes[i]+=ar[i];\n\tmaxim=max(maxim,findAns(x+1,times));\n\treturn maxim;\n}\nint solved(vector<pr> v){\n\t\tint ans=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tnum[i]=v[i].first;\n\t\t\tnumTimes[i]=v[i].second;\n\t\t}\n\t\tnumbers=v.size();\n\t\tint gets[5]={};\n\t\tsearch(0,gets);\n\t\treturn findAns(0,numTimes);\n}\nint main() {\n\t// your code goes here\n\tint n,tmp;\n\twhile(cin >> n && n!=0){\n\t\tp.clear();\n\t\tnumbers=0;\n\t\tvector<pr > v;\n\t\tint nums[10]={},sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\tnums[tmp]++;\n\t\t}\n\t\tfor(int i=1;i<=4;i++)\n\t\t\tif(nums[i] && nums[10-i]){\n\t\t\t\tint manju=min(nums[i],nums[10-i]);\n\t\t\t\tsum+=manju;\n\t\t\t\tnums[i]-=manju;\n\t\t\t\tnums[10-i]-=manju;\n\t\t\t}\n\t\tsum+=nums[5]/2;\n\t\tnums[5]%=2;\n\t\tfor(int i=1;i<=8;i++)\n\t\t\tif(nums[i])\n\t\t\t\tv.push_back(pr(i,nums[i]));\n\t\tcout << sum+solved(v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int y,int t1,int t2){\n\t// ull aa=hash();\n\t// if(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\tif(y<2) return 0;\n\tint ret=0;\n\treep(j,t2,vv[t1].size()){\n\t\trep(k,vv[t1][j].size()){\n\t\t\ta[vv[t1][j][k]]--;\n\t\t}\n\t\tbool f=true;\n\t\trep(k,10){\n\t\t\tif(a[k]<0) f=false;\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t}\n\t\trep(k,vv[t1][j].size()){\n\t\t\ta[vv[t1][j][k]]++;\n\t\t}\n\t}\n\treep(i,t1+1,11){\n\t\trep(j,vv[i].size()){\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]--;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\trep(k,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t}\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]++;\n\t\t\t}\n\t\t}\n\t}\n\t// return ma[aa]=ret;\n\treturn ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n,2,0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap< pair<int,long long>, int>  dp;\nvector< long long > e;\n\nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n\nint dfs(int pos,long long v){\n    if( pos >= e.size() ) return 0;\n    if( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n    long long V = v;\n    int ans = 0 , c = 0;\n    while(1){\n        ans = max( dfs(pos+1,v) + c , ans);\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n    v = V;\n    return dp[make_pair(pos,V)] = ans;\n}\n\n\n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n    while(cin >> n && n){\n        vector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u;\n            v[10-i] -= u;\n        }\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n        dp.clear();\n        cout << dfs(0,enc)+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0; id = 1;\n    }\n    if(sum == 0 and dp.count(vec)) return dp[vec];\n    if(id > 9 or sum + id > 10) return 0;\n\n    int add = 0;\n    if(vec[id] > 0) {\n        vec[id]--;\n        chmax(add, solve(vec, sum + id, id));\n        vec[id]++;\n    }\n    chmax(add, solve(vec, sum, id + 1));\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        /*\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n        */\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nint cnt[10];\nvector<int> use;\n\n\nbool func(int x){\n\tif( x == 0 ) return true;\n\t\n\tfor(int i = x; i > 0; --i){\n\t\tif( !cnt[i] ) continue;\n\t\t\n\t\t--cnt[i];\n\t\tuse.push_back(i);\n\t\tif( func(x - i) ){\n\t\t\treturn true;\n\t\t}\n\t\t++cnt[i];\n\t\tuse.pop_back();\n\t}\n\t\n\treturn false;\n}\n\n\nint main(){\n\tint n, x;\n\tuse.reserve(16);\n\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tfill(cnt, cnt + 10, 0);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 9; i > 0; ){\n\t\t\tif( !cnt[i] ) --i;\n\t\t\telse{\n\t\t\t\t--cnt[i];\n\t\t\t\tuse.push_back(i);\n\t\t\t\t\n\t\t\t\tif( func(10 - i) ){\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j = 0; j < use.size(); ++j){\n\t\t\t\t\t\t++cnt[use[j]];\n\t\t\t\t\t}\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tuse.clear();\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a)\n{\n\tos<<'[';\n\trep(i,a.size())\n\t\tos<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint solve(vi& ms,vi& label,int remain,int index)\n{\n\tint n=ms.size();\n\t\n\tif(remain==0){\n\t\treturn 1+solve(ms,label,10,0);\n\t}\n\telse{\n\t\tint res=0;\n\t\trepi(i,index,n){\n\t\t\tif(!label[i] && ms[i]<=remain){\n\t\t\t\tlabel[i]=1;\n\t\t\t\tres=max(res,solve(ms,label,remain-ms[i],i+1));\n\t\t\t\tlabel[i]=0;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi ms(n);\n\t\trep(i,n) scanf(\"%d\",&ms[i]);\n\t\t\n\t\tsort(all(ms),greater<int>());\n\t\t//dump(ms);\n\t\tvi label(n);\n\t\tint res=solve(ms,label,10,0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    int greedy_sum = 0;\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      if(weight == 10){\n        greedy_sum++;\n        continue;\n      }\n      buns[weight]++;\n    }\n\n\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0; id = 1;\n    }\n    if(dp.count(vec)) return dp[vec];\n\n    int add = 0;\n    for(int i=id; i<=9; i++) {\n        if(vec[i] > 0 && sum + i <= 10) {\n            vec[i]--; sum += i;\n            chmax(add, solve(vec, sum, i));\n            vec[i]++; sum -= i;\n        }\n    }\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nlong long conv(wolf a){\n\tlong long ret=0;\n\tfor(int i=0;i<9;i++){\n\t\tret*=128;\n\t\tret+=a.t[i];\n\t}\n\treturn ret;\n}\nmap<long long,int> dp;\nint solve(wolf a,int b){\n\tif((int)(dp.count(conv(a))))return dp[conv(a)];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[conv(a)]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tdp.clear();\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\n\treturn ret / 10;\n}\n\nbool solve(int m[], int pre, int step)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\t\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool ok = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\t\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tif (solve(m, i, step + 1)) return true;\n\n\t\t\t// Rollback\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\n\t\t}\n\t}\n\t// cout << (res) << endl;\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor ( int i = 0; i < s.size(); ++i ) {\n\t\tfor ( int j = 0; j < s[i].size(); ++j ) {\n\t\t\tparts[ i ][ s[ i ][ j ] - 1 ]++;\n\t\t}\n\t}\n\n\twhile ( true ) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tsolve(m, 0, 0);\n\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 1; i <= 9 ; i++ ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 30 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n\n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\n\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < 100; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<vector<int> > howToGet;\nmap<vector<int>,int> dp[43];\nvoid dfs(int kind,int wgt,const vector<int> &v){\n  if(kind==0){\n    vector<int>nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<int> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\nint dfs2(int pos,vector<int> v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 今回の取り方でいくつとるか\n  for(int i=1;i<=1;i++){\n    vector<int> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=i*howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(ok)res=max(res,dfs2(pos,nv)+i);\n    else break;\n  }\n  res=max(res,dfs2(pos+1,v));\n  return dp[pos][v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<int>());\n  while(cin>>N&&N){\n    vector<int> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\t// return;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=0;\n\t\treep(i,2,11){\n\t\t\trep(j,vv[i].size()){\n\t\t\t\tbool f=true;\n\t\t\t\trep(k,vv[i][j].size()){\n\t\t\t\t\ta[vv[i][j][k]]--;\n\t\t\t\t}\n\t\t\t\trep(k,10){\n\t\t\t\t\tif(a[k]<0) f=false;\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trep(k,vv[i][j].size()){\n\t\t\t\t\t\ta[vv[i][j][k]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\n\nint n, a[128];\n\nint res;\nint sack[11];\nvoid dfs(int d)\n{\n\tif (sack[10] + (n - d) < res)\n\t\treturn;\n\telse if (d == n)\n\t{\n\t\tres = sack[10];\n\t\treturn;\n\t}\n\n\tfor (int i = 10 - a[d]; i >= 0; --i)\n\t{\n\t\tif (sack[i] > 0)\n\t\t{\n\t\t\tint j = a[d] + i;\n\t\t\t--sack[i];\n\t\t\t++sack[j];\n\n\t\t\tdfs(d + 1);\n\n\t\t\t++sack[i];\n\t\t\t--sack[j];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tsack[0] = 114514;\n\twhile (cin >> n, n)\n\t{\n\t\tinput(a, n);\n\t\tsort(a, a + n, greater<int>());\n\n\t\tres = 0;\n\t\tdfs(0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[902394][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    if(rest[j] == 0){return 0;}\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    if(rest[i] == 0){return 0;}\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    if(rest[j] == 0){return 0;}\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 902394){puts(\"-1\"); exit(0);}\n    // return dp[i+26*(j+26*(k+26*l))][index];\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n}\n\ninline int at5(int i, int j){\n    if(j == 0){return 0;}\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 0);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> a;\nint ret;\nvoid solve(vector<int>& select, int n)\n{\n    int sum = accumulate(select.begin(), select.end(), 0);\n    if(select.size() == n){\n        if(sum < 10)\n            return;\n\n        vector<int> b(10, 0);\n        for(int i=0; i<n; ++i)\n            ++ b[select[i]];\n        for(int i=0; i<10; ++i){\n            if(b[i] > a[i])\n                return;\n        }\n\n        for(int i=0; i<10; ++i)\n            a[i] -= b[i];\n        ++ ret;\n        return;\n    }\n\n    for(int i=(select.size()==0? 1:select.back()); i<=9; ++i){\n        if(sum + (n - select.size()) * i > 10)\n            break;\n        select.push_back(i);\n        solve(select, n);\n        select.pop_back();\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        a.assign(10, 0);\n        for(int i=0; i<n; ++i){\n            int x;\n            cin >> x;\n            ++ a[x];\n        }\n\n        ret = 0;\n        vector<int> select;\n        for(int i=2; i<=10; ++i)\n            solve(select, i);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<pair<int, Manju>, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<pair<int, Manju>>Q; Q.push(make_pair(0, T)); M[make_pair(0, T)] = 1;\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front().second; int L = Q.front().first; Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\n\t\tManju RR = R; int EE = 0; if (L == 41)continue;\n\t\twhile (true) {\n\t\t\tif (M[make_pair(L + 1, RR)] != 1) { Q.push(make_pair(L + 1, RR)); }\n\t\t\tbool OK = true;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (S[L].k[j] > RR.k[j])OK = false;\n\t\t\t}\n\t\t\tif (OK == false)break;\n\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[L].k[j];\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tfor (int i = 1; i < 5; i++) { int WW = min(A.k[10 - i], A.k[i]); A.k[10 - i] -= WW; A.k[i] -= WW; adv += WW; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko, int lim)\t// 合計, 10個出来た個数, 残り\n{\n\n\tif(num > 10){\n\t\tif(nowmax[lim] < ko)\n\t\t\tnowmax[lim] = ko;\n\t\treturn nowmax[lim];\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t\tif(nowmax[lim] < ko)\n\t\t\tnowmax[lim] = ko;\n\t}\n\tif(lim == N){\n\t\tif(nowmax[lim] < ko)\n\t\t\tnowmax[lim] = ko;\n\t\treturn nowmax[lim];\n\t}\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i] && num + manto[i] <= 10){\n\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko, lim+1));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tnowmax[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap< pair<int,vector<int> >, int > dp;\nvector< vector<int> > e;\n\n//int dp[51][51][51][51][2];\n\nint dfs(int pos,vector<int> &v){\n\tif( pos >= e.size() ) return 0;\n\tif( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n\tvector<int> V = v;\n\tint ans = 0 , c = 0;\n\twhile(1){\n\t\tans = max( dfs(pos+1,v) + c , ans);\n\t\t\n\t\tc++;\n\t\tfor(int i = 0 ; i < v.size() ; i++)\n\t\t\tv[i] -= e[pos][i];\n\t\t\n\t\tbool f = true;\n\t\tfor(int i = 0 ; i < v.size() ; i++)\n\t\t\tif( v[i] < 0 ) f = false;\n\t\tif( !f ) break;\n\t}\n\tv = V;\n\treturn dp[make_pair(pos,V)] = ans;\n}\n\n\nvector<int> bt;\nvoid gen_pattern(int pos,int r){\n\tif( pos >= 10 ){\n\t\tif( r == 0 ){\n\t\t\te.push_back( bt );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; r - pos * i >= 0 ; i++){\n\t\tbt[pos] = i;\n\t\tgen_pattern(pos+1,r - pos*i);\n\t}\n}\n\nint main(){\n\tint n;\n\tbt.resize(10);\n\tgen_pattern(1,10);\n\twhile(cin >> n && n){\n\t\tvector<int> v(10);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t]++;\n\t\t}\n\t\tint greedy = 0;\n\t\tfor(int i = 1 ; i < 5 ; i++){\n\t\t\tint u = min(v[i],v[10-i]);\n\t\t\tgreedy += u;\n\t\t\tv[i] -= u; \n\t\t\tv[10-i] -= u;\n\t\t}\n\t\tdp.clear();\n\t\tgreedy += v[5] / 2;\n\t\tv[5] %= 2;\n\t\tcout << dfs(0,v)+greedy << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> &p, int sum)\n{\n\tint a;\n\tvector<int> c;\n\tif (m.count(p) != 0){\n\t\treturn (m[p]);\n\t}\n\t\n\tif (sum < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tc = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c, sum - 10));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tint s = 0;\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\ts += i * num[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num, s));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0; id = 1;\n    }\n    if(sum == 0 and dp.count(vec)) return dp[vec];\n    if(id > 9 or sum + id > 10) return 0;\n\n    int add = 0;\n    if(vec[id] > 0) {\n        vec[id]--;\n        chmax(add, solve(vec, sum + id, id));\n        vec[id]++;\n    }\n    chmax(add, solve(vec, sum, id + 1));\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint f[5];\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\t\n\tvector<int> t(10, 0);\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint dfs(int i,int sum,int *a){\n\tif(sum==10){\n\t\treturn 1+dfs(0,0,a);\n\t}\n\tif(i>=10) return 0;\n\n\tint res=dfs(i+1,sum,a);\n\tif(a[i]>0 && sum+a[i]<=10){\n\t\ta[i]--;\n\t\tres=max(res,dfs(i,sum+i,a));\n\t\ta[i]++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\t// int sum=0;\n\t\t// for(int i=1;i<5;i++){\n\t\t\t// int c=min(a[i],a[10-i]);\n\t\t\t// sum+=c;\n\t\t\t// a[i]-=c;\n\t\t\t// a[10-i]-=c;\n\t\t// }\n\t\t// { // i==5\n\t\t\t// sum+=a[5]/2;\n\t\t\t// a[5]%=2;\n\t\t// }\n\n\t\tprintf(\"%d\\n\",dfs(0,0,a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    static const int M = 1000;\n    if (res == possi_max || sack[10] + (n - d) <= res\n        || (d < M && memo[d].count(encode(sack))))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n    if (d < M)\n        memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\n\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < 100; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nlong long conv(wolf a){\n\tlong long ret=0;\n\tfor(int i=0;i<9;i++){\n\t\tret*=128;\n\t\tret+=a.t[i];\n\t}\n\treturn ret;\n}\nmap<long long,int> dp;\nint solve(wolf a,int b){\n\tif((int)(dp.count(conv(a))))return dp[conv(a)];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[conv(a)]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int m[11] = {0};\n        rep(i,n){\n            int a;\n            cin >> a;\n            m[a]++;\n        }\n\n        int ans = 0, f = true;\n        map<pair<int,int>, pair<int,int>> pre;\n        while(f){\n            f = false;\n            bool dp[1005][11] = {{0}};\n            dp[0][0] = true;\n            rep(i,9){\n                rep(j,11){\n                    for(int k = 0; k <= m[9 - i] && k * (9 - i) <= j; k++){\n                        if(not dp[i + 1][j] && dp[i][j - k * (9 - i)]){\n                            dp[i + 1][j] = true;\n                            pre[make_pair(i + 1, j)] = make_pair(k, 9 - i);\n                        }\n                    }\n                }\n            }\n            if(dp[9][10]){\n                f = true;\n                ans++;\n                int num = 9, sum = 10;\n                while(sum != 0){\n                    pair<int, int> prev = pre[make_pair(num, sum)];\n                    //show(prev.first)\n                    //show(prev.second)\n                    m[prev.second]-=prev.first;\n                    sum -= prev.second * prev.first;\n                    num--;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;\nmap<vector<int>, int > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(table.count(tmp))return table[tmp];\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    table[tmp] = res;\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 1; i <= 9 ; i++ ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 50 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint m[10];\nvector<vector<int> > pattern;\nvoid rekkyo(int sum,int i){\n\tstatic vector<int> hoge(10);\n\tint res=0;\n\tif(sum==10){\n\t\tpattern.push_back(hoge);\n\t\treturn;\n\t}\n\tif(10<sum || i==10)return;\n\tfor(int j=0;sum+i*j<=10;j++){\n\t\thoge[i]=j;\n\t\trekkyo(sum+i*j,i+1);\n\t}\n\thoge[i]=0;\n\treturn;\n}\nbool ok(int num[10],vector<int> &p,int n){\n\tfor(int i=1;i<10;i++){\n\t\tif(m[i]-num[i] < p[i]*n)return false;\n\t}\n\treturn true;\n}\nint bsearch(int num[10],vector<int> &p){\n\tint l=0,r=50,m;\n\twhile(l<r){\n\t\tm=(l+r)/2+1;\n\t\tif(ok(num,p,m))l=m;\n\t\telse r=m-1;\n\t}\n\treturn r;\n}\nint search(int i){\n\tint res=0,tmp;\n\tstatic int num[10];\n\tif(i==pattern.size())return 0;\n\tfor(int j=bsearch(num,pattern[i]);0<=j;j--){\t\n\t\tfor(int k=0;k<10;k++)num[k] += j*pattern[i][k];\n\t\ttmp = j+search(i+1);\n\t\tres = max(res,tmp);\n\t\tfor(int k=0;k<10;k++)num[k] -= j*pattern[i][k];\t\t\n\t}\n\treturn res;\n}\nint main(){\n\tint n,t,ans;\n\trekkyo(0,1);\n\twhile(cin>>n&&n){\n\t\tans=0;\n\t\tfill(m,m+10,0);\n\t\twhile(n--){\n\t\t\tcin>>t;\n\t\t\tm[t]++;\n\t\t}\n\t\tcout<<search(0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n/*\n  組み合わせをあらかじめ列挙しておく\n  \n */\n\nint N;\nint MS[101];\nint lim;\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(const int kind,int wgt,const map<char,char> &v){\n  if(kind==0){\n    map<char,char> nv=v;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nvoid dfs2(const int pos,const map<char,char> &v,int cnt,int &maxVal,int preLast){\n  if(pos==(int)howToGet.size())return;\n  if(preLast/2+cnt<=maxVal)return;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  int sz=0;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0\n       ||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else nv[it->first]-=it->second;\n    sz++;\n  }\n  // 1セット取れるならとる\n  if(ok){\n    maxVal=max(maxVal,cnt+1);\n    dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n  }\n  // 取らずに次のセットへ\n  dfs2(pos+1,v,cnt,maxVal,preLast);\n}\n\nvoid greedy(int &maxVal,map<char,char> v){\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    while(1){\n      bool ok=true;\n      for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n\tif(v.count(it->first)==0\n\t   ||v[it->first]-(it->second)<0){\n\t  ok=false;\n\t  break;\n\t}\n\t//else v[it->first]-=it->second;\n      }\n      if(ok){\n\tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n\t  v[it->first]-=it->second;\n\tmaxVal++;\n      }\n      else break;\n    }\n  }\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    lim=0;\n    map<char,char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int maxVal=0;\n    int preLast=N;\n    greedy(maxVal,cnts);\n    dfs2(0,cnts,0,maxVal,preLast);\n    cout<<maxVal<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\ntypedef pair<vector<int>, int> P;\nvector< vector<int> > tens;\nmap<pair<vector<int>, int>, int > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(table.count(P(tmp, n)))return table[P(tmp, n)];\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    table[P(tmp, n)] = res;\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 1; i <= 9 ; i++ ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\tif( 30 < n ) continue;\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint ans; // ツ暫ツ津ィツ嘉ー\nvoid dfs(int i,int sum,int *a,int now=0){\n\t// ツ篠ゥツ鳴セツづ按枝ツ環?づィ\n\tint rem=sum;\n\tfor(int j=1;j<10;j++) rem+=a[j]*j;\n\tif(now+rem/10<=ans) return;\n\n\tans=max(ans,now);\n\n\tif(sum==10){\n\t\tdfs(1,0,a,now+1);\n\t\treturn;\n\t}\n\tif(i>=10) return;\n\n\tdfs(i+1,sum,a);\n\tif(a[i]>0 && sum+i<=10){\n\t\ta[i]--;\n\t\tdfs(i,sum+i,a,now);\n\t\ta[i]++;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\t\ta[9]=0; // 9 ツつェツ単ツ禿?づ?残ツづ?づ?づ?使ツつ「ツ督ケツつェツづ按つ「\n\n\t\tans=-1;\n\t\tdfs(1,0,a);\n\t\tprintf(\"%d\\n\",sum+ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> a;\n\n\t\tmap<int, int> m;\n\t\trep(i,n){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tm[x]++;\n\t\t}\n\n\t\tint ans = 0;\n\t\trange(i,1,5){\n\t\t\tint tmp = min(m[i], m[10 - i]);\n\t\t\tans += tmp;\n\t\t\tm[i]-=tmp;\n\t\t\tm[10 - i]-=tmp;\n\t\t}\n\t\tans += m[5] / 2;\n\t\tm[5] %= 2;\n\n\t\tfor(auto i : m){\n\t\t\trep(j,i.second){\n\t\t\t\ta.emplace_back(i.first);\n\t\t\t}\n\t\t}\n\n\t\tsort(all(a),greater<int>());\n\n\t\tvector<bool> used(a.size(),0); //?????§????¢???°????????????????????????\n\t\twhile(true){\n\t\t\tint pre[15];\n\t\t\tmemset(pre, -1, sizeof(pre));\n\t\t\tbool dp[15] = {0};\n\t\t\tdp[0] = 1;\n\t\t\trep(i,a.size()){\n\t\t\t\tif(used[i]) continue;\n\n\t\t\t\tfor(int k = 10; k >= 0; k--){\n\t\t\t\t\tif(k + a[i] > 10) continue;\n\t\t\t\t\tif(pre[k + a[i]] != -1) continue;\n\t\t\t\t\tdp[k + a[i]] |= dp[k];\n\t\t\t\t\t//cout << j + 1 << ' ' << k + a[j] << endl;\n\t\t\t\t\tif(dp[k]) pre[k + a[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(dp[10]){\n\t\t\t\tans++;\n\t\t\t\tint cur = 10;\n\t\t\t\twhile(cur != 0){\n\t\t\t\t\tint p = pre[cur];\n\t\t\t\t\tcur = cur - a[p];\n\t\t\t\t\tused[p] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n\t\tvector<int> a(n);\n        rep(i,n) cin >> a[i];\n        sort(all(a),greater<int>());\n\n\t\tvector<bool> used(n,0); //?????§????¢???°????????????????????????\n\t\tint ans = 0;\n\t\trep(i,n - 1){ //????????????????????????????????£???10 - a[i]???????????????\n\t\t\tif(used[i]) continue;\n\t\t\tint need = 10 - a[i];\n\n\t\t\tint pre[15];\n\t\t\tmemset(pre, -1, sizeof(pre));\n\t\t\tbool dp[15] = {0};\n\t\t\tdp[0] = 1;\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tfor(int k = need; k >= 0; k--){\n\t\t\t\t\tif(k + a[j] > 10) continue;\n\t\t\t\t\tif(pre[k + a[j]] != -1) continue;\n\t\t\t\t\tdp[k + a[j]] |= dp[k];\n\t\t\t\t\t//cout << j + 1 << ' ' << k + a[j] << endl;\n\t\t\t\t\tif(dp[k]) pre[k + a[j]] = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(dp[need]){\n\t\t\t\tans++;\n\t\t\t\tint cur = need;\n\t\t\t\twhile(cur != 0){\n\t\t\t\t\tint p = pre[cur];\n\t\t\t\t\tcur = cur - a[p];\n\t\t\t\t\tused[p] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int a[105];\n        rep(i,n) cin >> a[i];\n        sort(a,a + n,greater<int>());\n\n        int ans = 0, f = true;\n        map<int, int> pre;\n\n        /*\n        range(i,1,5){\n            int a = min(m[i], m[10 - i]);\n            ans += a;\n            m[i] -= a;\n            m[10 - i] -= a;\n        }\n        int a = m[5] / 2;\n        ans += a;\n        m[5] -= a * 2;\n        */\n\n        while(f){\n            f = false;\n            bool dp[11] = {0};\n            dp[0] = true;\n            rep(i,n){\n                for(int j = 10; j >= 0; j--){\n                    if(j - a[i] < 0) continue;\n                    if(not dp[j] && dp[j - a[i]]){\n                        //cout << i << ' ' << j << endl;\n                        dp[j] = true;\n                        pre[j] = i;\n                    }\n                }\n            }\n            if(dp[10]){\n                f = true;\n                ans++;\n                int num = n, sum = 10;\n                while(sum != 0){\n                    int prev = pre[sum];\n                    //cout << prev.first << ' ' << prev.second << endl;\n                    sum -= a[prev];\n                    a[prev] = 0;\n                    num--;\n                    //show(sum)\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[11], ans, total;\n\nint f1[5][2] = {\n\t{9,1},\n\t{8,2},\n\t{7,3},\n\t{6,4},\n\t{5,5}\n};\nint f2[8][3] = {\n\t{8,1,1},\n\t{7,2,1},\n\t{6,3,1},\n\t{6,2,2},\n\t{5,4,1},\n\t{5,3,2},\n\t{4,4,2},\n\t{4,3,3}\n};\nint f3[8][4] = {\n\t{7,1,1,1},\n\t{6,2,1,1},\n\t{5,3,1,1},\n\t{5,2,2,1},\n\t{4,4,1,1},\n\t{4,3,2,1},\n\t{4,2,2,2},\n\t{3,3,2,2}\n};\nint f4[7][5] = {\n\t{6,1,1,1,1},\n\t{5,2,1,1,1},\n\t{4,3,1,1,1},\n\t{4,2,2,1,1},\n\t{3,3,2,1,1},\n\t{3,2,2,2,1},\n\t{2,2,2,2,2},\n};\nint f5[5][6] = {\n\t{5,1,1,1,1,1},\n\t{4,2,1,1,1,1},\n\t{3,3,1,1,1,1},\n\t{3,2,2,1,1,1},\n\t{2,2,2,2,1,1},\n};\n\nvoid solve(int cnt, int sum){\n\tans = max( ans , cnt );\n\tif( total-sum < 10 ) return;\n\tif( (total - sum) / 10 + cnt < ans ) return;\n\t\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f1[i][0]]--;\n\t\ta[f1[i][1]]--;\n\t\tif( a[f1[i][0]] >= 0 && a[f1[i][1]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f1[i][0]]++;\n\t\ta[f1[i][1]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f2[i][0]]--;\n\t\ta[f2[i][1]]--;\n\t\ta[f2[i][2]]--;\n\t\tif( a[f2[i][0]] >= 0 && a[f2[i][1]] >= 0 && a[f2[i][2]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f2[i][0]]++;\n\t\ta[f2[i][1]]++;\n\t\ta[f2[i][2]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f3[i][0]]--;\n\t\ta[f3[i][1]]--;\n\t\ta[f3[i][2]]--;\n\t\ta[f3[i][3]]--;\n\t\tif( a[f3[i][0]] >= 0 && a[f3[i][1]] >= 0 && a[f3[i][2]] >= 0 && a[f3[i][3]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f3[i][0]]++;\n\t\ta[f3[i][1]]++;\n\t\ta[f3[i][2]]++;\n\t\ta[f3[i][3]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 7 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f4[i][0]]--;\n\t\ta[f4[i][1]]--;\n\t\ta[f4[i][2]]--;\n\t\ta[f4[i][3]]--;\n\t\ta[f4[i][4]]--;\n\t\tif( a[f4[i][0]] >= 0 && a[f4[i][1]] >= 0 && a[f4[i][2]] >= 0 && a[f4[i][3]] >= 0 && a[f4[i][4]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f4[i][0]]++;\n\t\ta[f4[i][1]]++;\n\t\ta[f4[i][2]]++;\n\t\ta[f4[i][3]]++;\n\t\ta[f4[i][4]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f5[i][0]]--;\n\t\ta[f5[i][1]]--;\n\t\ta[f5[i][2]]--;\n\t\ta[f5[i][3]]--;\n\t\ta[f5[i][4]]--;\n\t\ta[f5[i][5]]--;\n\t\tif( a[f5[i][0]] >= 0 && a[f5[i][1]] >= 0 && a[f5[i][2]] >= 0 && a[f5[i][3]] >= 0 && a[f5[i][4]] >= 0 && a[f5[i][5]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f5[i][0]]++;\n\t\ta[f5[i][1]]++;\n\t\ta[f5[i][2]]++;\n\t\ta[f5[i][3]]++;\n\t\ta[f5[i][4]]++;\n\t\ta[f5[i][5]]++;\n\t\tif( flag ) return;\n\t}\n\t\n\tif( a[4] >= 1 && a[1] >= 6 ){\n\t\ta[4] -= 1;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[4] += 1;\n\t\ta[1] += 6;\n\t}\n\tif( a[3] >= 1 && a[2] >= 1 && a[1] >= 5 ){\n\t\ta[3] -= 1;\n\t\ta[2] -= 1;\n\t\ta[1] -= 5;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[2] += 1;\n\t\ta[1] += 5;\n\t}\n\tif( a[2] >= 3 && a[1] >= 4 ){\n\t\ta[2] -= 3;\n\t\ta[1] -= 4;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 3;\n\t\ta[1] += 4;\n\t}\n\tif( a[3] >= 1 && a[1] >= 7 ){\n\t\ta[3] -= 1;\n\t\ta[1] -= 7;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[1] += 7;\n\t}\n\tif( a[2] >= 2 && a[1] >= 6 ){\n\t\ta[2] -= 2;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 2;\n\t\ta[1] += 6;\n\t}\n\tif( a[2] >= 1 && a[1] >= 8 ){\n\t\ta[2]--;\n\t\ta[1] -= 8;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2]++;\n\t\ta[1] += 8;\n\t}\n\tif( a[1] >= 10 ){\n\t\ta[1] -= 10;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[1] += 10;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\ttotal = 0;\n\t\tfor(int i=0 ; i < 10 ; i++ ){\n\t\t\ta[i] = 0;\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ttotal += e;\n\t\t\ta[e]++;\n\t\t}\n\t\tans = 0;\n\t\tsolve(0,0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint res;\n\nvoid solve(vi& hist,int i,int remain,int cur)\n{\n\tres=max(res,cur);\n\tif(i==10)\n\t\treturn;\n\t\n\tint x=0;\n\trepi(j,1,10) x+=hist[j]*j;\n\tif(cur+x/10<res)\n\t\treturn;\n\t\n\tif(remain==0){\n\t\tremain=10;\n\t\tcur++;\n\t\ti=1;\n\t}\n\t\n\tsolve(hist,i+1,remain,cur);\n\tif(hist[i]>0 && remain>=i){\n\t\thist[i]--;\n\t\tsolve(hist,i,remain-i,cur);\n\t\thist[i]++;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi hist(10);\n\t\trep(i,n){\n\t\t\tint m; scanf(\"%d\",&m);\n\t\t\thist[m]++;\n\t\t}\n\t\t\n\t\tint sum=hist[5]/2;\n\t\thist[5]%=2;\n\t\trepi(i,1,5)\n\t\t\twhile(hist[i] && hist[10-i]){\n\t\t\t\tsum++;\n\t\t\t\thist[i]--;\n\t\t\t\thist[10-i]--;\n\t\t\t}\n\t\t\n\t\tres=0;\n\t\tsolve(hist,1,10,0);\n\t\tprintf(\"%d\\n\",res+sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 100;\nint n, a[MAX_N+1], ans;\n// sum[i] := a[i] + a[i+1] + ... + a[n-1]\nint sum[MAX_N+1];\n// f[i] := 重さ i の饅頭の個数\nint f[11];\n// 貪欲に使う組合せ\nint c[5][2] = { {9,1}, {8,2}, {7,3}, {6,4}, {5,5} };\n\nvoid solve(int pos, int w, int cnt){\n\tans = max( ans , cnt );\n\tif( pos == n ) return;\n\tif( sum[pos]/10 + cnt < ans ) return;\n\t\n\tif( w + a[pos] == 10 ){\n\t\tsolve( pos+1 , 0 , cnt+1 );\n\t}else if( w + a[pos] < 10 ){\n\t\tsolve( pos+1 , w+a[pos] , cnt );\n\t}\n\tsolve( pos+1 , w , cnt );\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\t// 初期化\n\t\tfor(int i=0 ; i < 11 ; i++ ) f[i] = 0;\n\t\tfor(int i=0 ; i < n ; i++ ) sum[i] = 0;\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\tf[e]++;\n\t\t}\n\t\t// {9,1} {8,2} {7,3} {6,4}, {5,5} の組合せは貪欲に使う.\n\t\tint cnt = 0;\n\t\tfor(int i=0 ; i < 5 ; i++ ){\n\t\t\twhile( true ){\n\t\t\t\tf[c[i][0]]--;\n\t\t\t\tf[c[i][1]]--;\n\t\t\t\tif( f[c[i][0]] >= 0 && f[c[i][1]] >= 0 ){\n\t\t\t\t\tcnt++;\n\t\t\t\t}else{\n\t\t\t\t\tf[c[i][0]]++;\n\t\t\t\t\tf[c[i][1]]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn = 0;\n\t\tfor(int i=9 ; i >= 1 ; i-- ){\n\t\t\tfor(; f[i] ; f[i]-- ){\n\t\t\t\ta[n++] = i;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint s=0;\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\ts += a[i];\n\t\t\t}\n\t\t\tsum[0] = s;\n\t\t\tfor(int i=1 ; i < n ; i++ ){\n\t\t\t\tsum[i] = sum[i-1] - a[i-1];\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\t{\n\t\t\t\n\t\t}\n\t\tsolve(0,0,0);\n\t\tcout << ans+cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nll a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint N, manju[10];\nint rest[4], rest_b;\nint dp[26*26*26*26][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline int& at4(int i, int j, int l, int k, int index){\n    return dp[i+j*(rest[0]+1)+k*(rest[0]+rest[1]+2)+l*(rest[0]+rest[1]+rest[2]+3)][index];\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 10){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d\\n\", a, b, c, d, index);\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    int res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        // printf(\"%d: %d, %d, %d, %d | %d, %d, %d, %d | %d\\n\",\n        //       index, a, b, c, d, at(index, 0), at(index, 1), at(index, 2), at(index, 3), rest_b);\n        res = std::max(res, rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1);\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        int r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5){continue;}\n                if(manju[i] > 0){rest[n] = i; rest_b |= 1 << i; n += 1;}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        int r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1);\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef pair<pr , pr > ppr;\ntypedef pair<int,vector<int> > pv;\nint num[5]={},numTimes[5]={},numbers,alls;\nvector<pv > p; \nvoid search(int times,int gets[5]){\n\tif(times==numbers){\n\t\n\t\tint sum=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\t\tsum+=num[i]*gets[i];\n\t\tif(sum==10){\n\t\t\tpv a;\n\t\t\ta.first=-1;\n\t\t\tfor(int i=0;i<numbers;i++){\n\t\t\t\ta.second.push_back(gets[i]);\n\t\t\t\tif(a.first==-1 && gets[i]!=0)\n\t\t\t\ta.first=100-num[i];\n\t\t\t}\n\t\t\t\t\n\t\tp.push_back(a);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<=numTimes[times] && i<=10 ;i++){\n\t\tgets[times]=i;\n\t\tsearch(times+1,gets);\n\t\t}\n\t}\n}\nint findAns(int x,int times[]){\n\tif (x==p.size())\n\t\treturn 0;\n\tint maxim=0,ans=1;\n\tint ar[5];\n\tfor(int i=0;i<5;i++)\n\tar[i]=p[x].second[i];\n\tfor(int i=0;i<numbers;i++){\n\t\tif(ar[i]>times[i])\n\t\t\tans=0;\n\t\ttimes[i]-=ar[i];\n\t}\n\tif(ans)\n\tmaxim=max(maxim,1+findAns(x,times));\n\tfor(int i=0;i<numbers;i++)\n\t\ttimes[i]+=ar[i];\n\tmaxim=max(maxim,findAns(x+1,times));\n\treturn maxim;\n}\nint solved(vector<pr> v){\n\t\tint ans=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tnum[i]=v[i].first;\n\t\t\tnumTimes[i]=v[i].second;\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tnumbers=v.size();\n\t\tint gets[5]={};\n\t\talls=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\talls+=num[i]*numTimes[i];\n\t\tsort(p.begin(),p.end());\n\t\tsearch(0,gets);\n\t\treturn findAns(0,numTimes);\n}\nint main() {\n\t// your code goes here\n\tint n,tmp;\n\twhile(cin >> n && n!=0){\n\t\tp.clear();\n\t\tfor(int i=0;i<5;i++){\n\t\t\tnum[i]=0;\n\t\t\tnumTimes[i]=0;\n\t\t}\n\t\t\n\t\tnumbers=0;\n\t\tvector<pr > v;\n\t\tint nums[10]={},sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\tnums[tmp]++;\n\t\t}\n\t\tfor(int i=1;i<=4;i++)\n\t\t\tif(nums[i] && nums[10-i]){\n\t\t\t\tint manju=min(nums[i],nums[10-i]);\n\t\t\t\tsum+=manju;\n\t\t\t\tnums[i]-=manju;\n\t\t\t\tnums[10-i]-=manju;\n\t\t\t}\n\t\tsum+=nums[5]/2;\n\t\tnums[5]%=2;\n\t\twhile(nums[3]>=2 && nums[4] >= 1){\n\t\t\tnums[3]-=2;\n\t\t\tnums[4]-=1;\n\t\t\tsum++;\n\t\t}\n\t\tfor(int i=1;i<=8;i++)\n\t\t\tif(nums[i])\n\t\t\t\tv.push_back(pr(i,nums[i]));\n\t\tcout << sum+solved(v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap< pair<int,vector<int> >, int > dp;\nvector< vector<int> > e;\nint dfs(int pos,vector<int> v){\n\tif( pos >= e.size() ) return 0;\n\tif( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n\tvector<int> V = v;\n\tint ans = 0 , c = 0;\n\twhile(1){\n\t\tans = max( dfs(pos+1,v) + c , ans);\n\t\t\n\t\tc++;\n\t\tfor(int i = 0 ; i < v.size() ; i++)\n\t\t\tv[i] -= e[pos][i];\n\t\t\n\t\tbool f = true;\n\t\tfor(int i = 0 ; i < v.size() ; i++)\n\t\t\tif( v[i] < 0 ) f = false;\n\t\tif( !f ) break;\n\t}\n\treturn dp[make_pair(pos,V)] = ans;\n}\n\n\nvector<int> bt;\nvoid gen_pattern(int pos,int r){\n\tif( pos >= 10 ){\n\t\tif( r == 0 ){\n\t\t\te.push_back( bt );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; r - pos * i >= 0 ; i++){\n\t\tbt[pos] = i;\n\t\tgen_pattern(pos+1,r - pos*i);\n\t}\n}\n\nint main(){\n\tint n;\n\tbt.resize(10);\n\tgen_pattern(1,10);\n\twhile(cin >> n && n){\n\t\tvector<int> v(10);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t]++;\n\t\t}\n\t\tint greedy = 0;\n\t\tfor(int i = 1 ; i < 5 ; i++){\n\t\t\tint u = min(v[i],v[10-i]);\n\t\t\tgreedy += u;\n\t\t\tv[i] -= u; \n\t\t\tv[10-i] -= u;\n\t\t}\n\t\tgreedy += v[5] / 2;\n\t\tv[5] %= 2;\n\t\tcout << dfs(0,v)+greedy << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint num[10];\n\nint getMax(int sum, int u)\n{\n\tint ans;\n\t\n\tif (u == 10){\n\t\treturn (0);\n\t}\n\t\n\tint remain = 0;\n\tfor (int i = 1; i <= 9; i++){\n\t\tremain += num[i] * i;\n\t}\n\tif (remain < 10) return (0);\n\t\n\tif (sum == 10){\n\t\treturn (1 + getMax(0, u));\n\t}\n\t\n\tans = 0;\n\tfor (int i = u; i <= 9; i++){\n\t\tif (num[i] && sum + i <= 10){\n\t\t\tnum[i]--;\n\t\t\tans = max(ans, getMax(sum + i, u));\n\t\t\tnum[i]++;\n\t\t}\n\t}\n\tans = max(ans, getMax(sum, u + 1));\n\t\n\treturn (ans);\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\t\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(0, 1));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<vi,int> state;\n\nint n;\nvi a(10);\nmap<state,int> memo;\n\nint rec(vi v,int sum){\n  if(memo.find(state(v,sum))!=memo.end())return memo[state(v,sum)];\n\n  int res = 0;\n  for(int i=7;i>=0;i--){\n    if(v[i]){\n      if(sum+i==10){\n\tv[i]--;\n\tres = max(res,rec(v,0)+1);\n\tv[i]++;\n      }else if(sum+i<10){\n\tv[i]--;\n\tres = max(res,rec(v,sum+i));\n\tv[i]++;\n      }\n    }\n  }\n\n  return memo[state(v,sum)] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<10;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp]++;\n    }\n\n    int res = 0;\n    for(int i=1;i<=4;i++){\n      tmp = min(a[i],a[10-i]);\n      a[i] -= tmp; a[10-i] -= tmp;\n      res += tmp;\n    }\n    res += a[5]/2; a[5] &= 1;\n\n    memo.clear();\n    cout << res+rec(a,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju { \n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<Manju, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<pair<int, Manju>>Q; Q.push(make_pair(0, T)); M[T] = 1;\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front().second; int L = Q.front().first; Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\t\tfor (int i = L; i < S.size(); i++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (S[i].k[j]>R.k[j])OK = false;\n\t\t\t}\n\t\t\tif (OK == false)continue; Manju RR = R;\n\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[i].k[j];\n\t\t\tif (M[RR] != 1) { Q.push(make_pair(i, RR)); M[RR] = 1; }\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\ntypedef pair<vector<int>, int> P;\nvector< vector<int> > tens;\nmap<pair<vector<int>, int>, int > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(n == tens.size())return 0;\n\n    if(table.find(P(tmp, n)) != table.end())return table[P(tmp, n)];\n    int res = dfs(n + 1);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    table[P(tmp, n)] = res;\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND(8108931919ull);\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\t\n\t\tint t = 0;\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\twhile (v[i] > 0 && v[10 - i] > 0){\n\t\t\t\tt++;\n\t\t\t\tv[i]--;\n\t\t\t\tv[10 - i]--;\n\t\t\t}\n\t\t}\n\t\tt += v[5] / 2;\n\t\tv[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", t + calc(v));\n\t\tdp.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\tif(nowmax[num] < ko)\n\t\tnowmax[num] = ko;\n\tif(num > 10)\n\t\treturn ko;\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n\tif(M == 0)\n\t\treturn ko;\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n\t\t\tif(nowmax[num] > ko){\n\t\t\t\tans = max(ans,nowmax[num]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint rec(vector< char >& cur);\n\nmap< vector< char >, int > dp;\n\nint make(vector< char >& cur, int idx, int sum)\n{\n  if(sum > 10)  return(0);\n  if(sum == 10) return(rec(cur) + 1);\n  if(idx == 10) return(0);\n  int ret = 0;\n  if(cur[idx] > 0) {\n    cur[idx]--;\n    ret += make(cur, idx, sum + idx);\n    cur[idx]++;\n  }\n  ret = max(ret, make(cur, idx + 1, sum));\n  return(ret);\n}\n\nint rec(vector< char >& cur)\n{\n  if(dp.find(cur) != dp.end()) return(dp[cur]);\n  return(dp[cur] = make(cur, 1, 0));\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n\n    vector< char > cur(10, 0);\n    for(int i = 0; i < n; i++) {\n      int digit;\n      cin >> digit;\n      cur[digit]++;\n    }\n    int build = 0;\n    for(int i = 1; i < 5; i++) {\n      int cost = min(cur[i], cur[10 - i]);\n      build += cost;\n      cur[i] -= cost;\n      cur[10 - i] -= cost;\n    }\n    build += cur[5] / 2;\n    cur[5] -= cur[5] / 2;\n    cout << build + rec(cur) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <ctime>\n#include <sys/time.h>\nusing namespace std;\n\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n\nint ans = 0;\nint C = 0; \nclock_t start,end;\n\nvoid dfs(int pos,long long v){\n\tend = clock();\n\tif( (double)(end - start) / CLOCKS_PER_SEC > 7.95) return; \n    if( pos >= e.size() ) return;\n\tans = max( ans , C );\n    int c = 0;\n    while(1){\n\t\tC += c;\n        dfs(pos+1,v);\n\t\tC -= c;\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n}\n  \n  \n \n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n\t//sort(e.rbegin(),e.rend());\n    while(cin >> n && n){\n\t\tvector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n\t\tclock_t start, end;\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n\t\tC = 0;\n\t\tans = 0;\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n\t\tstart = clock();\n\t\tdfs(0,enc);\n        cout << ans+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint greedy;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\n\treturn ret / 10;\n}\n\nbool solve(int m[], int pre, int step, bool bgreedy)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\n\tif (!bgreedy) {\n\t\tif (step + ideal(m) <= greedy) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tif ( bgreedy ){\n\t\t\t\tif ( solve(m, i, step + 1, bgreedy) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsolve(m, i, step + 1, bgreedy);\n\t\t\t}\n\t\t\t\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < s.size(); ++i){\n\t\t\tif ( s[i].size() == sz ){\n\t\t\t\tfor (int j = 0; j < s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tgreedy = 0;\n\t\tsolve(m, 0, 0, true);\n\t\tgreedy = res;\n\t\tres = 0;\n\t\tsolve(m, 0, 0, false);\n\n\t\tif (res < greedy){\n\t\t\tres = greedy;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint f[5];\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nbool ok[10];\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tif (ok[i]){\n\t\t\tt[i]++;\n\t\t\tmake(t, rem - i, rem - i);\n\t\t\tt[i]--;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tmemset(ok, false, sizeof(ok));\n\t\t\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\tif (num[i]) ok[i] = true;\n\t\t}\n\t\t\n\t\tmp.clear();\n\t\tmake(t, 9, 10);\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(int i, vector<int> v)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tif (i == T.size()) return 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tres = max(res, j + dfs(i + 1, v));\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nVV(pii) vp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int t1){\n\tull aa=hash();\n\tif(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\t// if(y<2) return 0;\n\tint ret=0;\n\treep(i,t1,vp.size()){\n\t\tbool f=true;\n\t\trep(j,vp[i].size()){\n\t\t\tf&=(0<=(a[vp[i][j].F]-=vp[i][j].S));\t\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(i)+1);\n\t\t}\n\t\trep(j,vp[i].size()){\n\t\t\ta[vp[i][j].F]+=vp[i][j].S;\n\t\t}\n\t}\n\t// reep(j,t2,vp[t1].size()){\n\t\t// rep(k,vp[t1][j].size()){\n\t\t\t// a[vp[t1][j][k].F]-=vp[t1][j][k].S;\n\t\t// }\n\t\t// bool f=true;\n\t\t// reep(k,1,10){\n\t\t\t// if(a[k]<0) f=false;\n\t\t// }\n\t\t// if(f){\n\t\t\t// ret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t// }\n\t\t// rep(k,vp[t1][j].size()){\n\t\t\t// a[vp[t1][j][k].F]+=vp[t1][j][k].S;\n\t\t// }\n\t// }\n\t// reep(i,t1+1,11){\n\t\t// rep(j,vp[i].size()){\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// a[vp[i][j][k].F]-=vp[i][j][k].S;\n\t\t\t// }\n\t\t\t// bool f=true;\n\t\t\t// reep(k,1,10){\n\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t// }\n\t\t\t// if(f){\n\t\t\t\t// ret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t// }\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// a[vp[i][j][k].F]+=vp[i][j][k].S;\n\t\t\t// }\n\t\t// }\n\t// }\n\treturn ma[aa]=ret;\n\t// return ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\trep(i,vv.size()){\n\t\tVV(pii) tmp;\n\t\trep(j,vv[i].size()){\n\t\t\tint t1=vv[i][j][0];\n\t\t\tint t2=0;\n\t\t\tvector<pii> vpii;\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\tif(t1==vv[i][j][k]){\n\t\t\t\t\tt2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvpii.PB(pii(t1,t2));\n\t\t\t\t\tt1=vv[i][j][k];\n\t\t\t\t\tt2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvpii.PB(pii(t1,t2));\n\t\t\ttmp.PB(vpii);\n\t\t}\n\t\trep(i,tmp.size()){\n\t\t\tvp.PB(tmp[i]);\n\t\t}\n\t}\n\t// rep(i,vp.size()){\n\t\t// cout<<endl;\n\t\t// cout<<\"i \"<<i<<endl;\n\t\t// rep(j,vp[i].size()){\n\t\t\t// cout<<\" j \"<<j<<endl;\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// cout<<\"  \"<<vp[i][j][k].F<<\" \"<<vp[i][j][k].S<<endl;\n\t\t\t// }\n\t\t// }\n\t// }\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp[43];\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const vector<char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  vector<char> nv=v;\n  bool ok=true;\n  for(int j=1;j<(int)howToGet[pos].size();j++){\n    nv[j]-=howToGet[pos][j];\n    if(nv[j]<0){\n      ok=false;\n      break;\n    }\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  if(lim<100000){\n    lim++;\n    return dp[pos][v]=res;\n  }\n  else\n    return res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    lim=0;\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n  \nmap< pair<int,long long>, int>  dp;\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n    for(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n \nint dfs(int pos,long long v){\n    if( pos >= e.size() ) return 0;\n    if( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n    long long V = v;\n    int ans = 0 , c = 0;\n    while(1){\n        ans = max( dfs(pos+1,v) + c , ans);\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n    v = V;\n    return dp[make_pair(pos,V)] = ans;\n}\n  \n  \n \nint main(){\n    int n;\n    gen_pattern(1,10,0);\n    while(cin >> n && n){\n        vector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n        cout << dfs(0,enc)+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 100;\nint n, a[MAX_N+1], ans;\n// sum[i] := a[i] + a[i+1] + ... + a[n-1]\nint sum[MAX_N+1];\n// f[i] := 重さ i の饅頭の個数\nint f[11];\n// 貪欲に使う組合せ\nint c[5][2] = { {9,1}, {8,2}, {7,3}, {6,4}, {5,5} };\n\nvoid solve(int pos, int w, int cnt){\n\tans = max( ans , cnt );\n\tif( pos == n ) return;\n\tif( sum[pos]/10 + cnt < ans ) return;\n\t\n\tif( w + a[pos] == 10 ){\n\t\tsolve( pos+1 , 0 , cnt+1 );\n\t}else if( w + a[pos] < 10 ){\n\t\tsolve( pos+1 , w+a[pos] , cnt );\n\t}\n\tsolve( pos+1 , w , cnt );\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\t// 初期化\n\t\tfor(int i=0 ; i < 11 ; i++ ) f[i] = 0;\n\t\tfor(int i=0 ; i < n ; i++ ) sum[i] = 0;\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\tf[e]++;\n\t\t}\n\t\t// {9,1} {8,2} {7,3} {6,4}, {5,5} の組合せは貪欲に使う.\n\t\tint cnt = 0;\n\t\tfor(int i=0 ; i < 5 ; i++ ){\n\t\t\tf[c[i][0]]--;\n\t\t\tf[c[i][1]]--;\n\t\t\tif( f[c[i][0]] >= 0 && f[c[i][1]] >= 0 ){\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tf[c[i][0]]++;\n\t\t\t\tf[c[i][1]]++;\n\t\t\t}\n\t\t}\n\t\tn = 0;\n\t\tfor(int i=9 ; i >= 1 ; i-- ){\n\t\t\tfor(; f[i] ; f[i]-- ){\n\t\t\t\ta[n++] = i;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint s=0;\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\ts += a[i];\n\t\t\t}\n\t\t\tsum[0] = s;\n\t\t\tfor(int i=1 ; i < n ; i++ ){\n\t\t\t\tsum[i] = sum[i-1] - a[i-1];\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\t{\n\t\t\t\n\t\t}\n\t\tsolve(0,0,0);\n\t\tcout << ans+cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int> buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n  sort(all_combinations.begin(),all_combinations.end());\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 10; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[33*33*33*33][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // (i+base[0]*(j+base[1]*(k+base[2]*l)) < 1000000)\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index, int depth){\n    // printf(\"%d, %d, %d, %d, %d, %d\\n\", a, b, c, d, index, a+b+c+d);\n    // printf(\"[%d][%d][%d][%d]: %d\\n\",\n    //        i, j, k, l,\n    //        i+j*(at2(0)+1)+k*(at2(0)+at2(1)+2)+l*(at2(0)+at2(1)+at2(2)+3));\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", a, b, c, d, index, res);\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 100000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;\nset<vector<int> > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(table.count(tmp))return 0;\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n\n    table.insert(tmp);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint parts[NPAT][9];\n\ninline int ideal(const vector<int> &m)\n{\n\treturn (m[0] + 2*m[1] + 3*m[2] + 4*m[3] + 5*m[4] + 6*m[5] + 7*m[6] + 8*m[7] + 9*m[8]) / 10;\n}\n\nbool solve(vector<int> &m, int pre, int step)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tsolve(m, i, step + 1);\n\t\t\t\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < (int)s.size(); ++i){\n\t\t\tif ( s[i].size() == sz ){\n\t\t\t\tfor (int j = 0; j < (int)s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tvector<int> m(9,0);\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tint t = min(m[8 - i], m[i]);\n\t\t\tm[8 - i] -= t;\n\t\t\tm[i] -= t;\n\t\t\tres += t;\n\t\t}\n\t\tif (m[4] >= 2){\n\t\t\tres += m[4] / 2;\n\t\t\tm[4] %= 2;\n\t\t}\n\n\t\tsolve(m, 0, res);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint res;\n\nvoid solve(vi& hist,int i,int remain,int cur)\n{\n\tres=max(res,cur);\n\tif(i==10)\n\t\treturn;\n\t\n\tint x=0;\n\trepi(i,1,10) x+=hist[i]*i;\n\tif(cur+x/10<res)\n\t\treturn;\n\t\n\tif(remain==0){\n\t\tremain=10;\n\t\tcur++;\n\t\ti=1;\n\t}\n\t\n\tsolve(hist,i+1,remain,cur);\n\tif(hist[i]>0 && remain>=i){\n\t\thist[i]--;\n\t\tsolve(hist,i,remain-i,cur);\n\t\thist[i]++;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi hist(10);\n\t\trep(i,n){\n\t\t\tint m; scanf(\"%d\",&m);\n\t\t\thist[m]++;\n\t\t}\n\t\t\n\t\tint sum=hist[5]/2;\n\t\thist[5]%=2;\n\t\trepi(i,1,5)\n\t\t\twhile(hist[i] && hist[10-i]){\n\t\t\t\tsum++;\n\t\t\t\thist[i]--;\n\t\t\t\thist[10-i]--;\n\t\t\t}\n\t\t\n\t\tres=0;\n\t\tsolve(hist,1,10,0);\n\t\tprintf(\"%d\\n\",res+sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > a;\nvoid manju(vector<int>& select)\n{\n    int sum = accumulate(select.begin(), select.end(), 0);\n    if(sum > 10)\n        return;\n    if(sum == 10){\n        vector<int> b(10, 0);\n        for(int i=0; i<select.size(); ++i)\n            ++ b[select[i]];\n        a.push_back(b);\n        return;\n    }\n\n    for(int i=(select.size()==0? 1:select.back()); i<=9; ++i){\n        select.push_back(i);\n        manju(select);\n        select.pop_back();\n    }\n}\n\nint solve(vector<int> x, int k)\n{\n    if(k >= a.size())\n        return 0;\n\n    int ret = solve(x, k+1);\n    for(;;){\n        for(int i=1; i<=9; ++i){\n            x[i] -= a[k][i];\n            if(x[i] < 0)\n                return ret;\n        }\n        ret = max(ret, solve(x, k) + 1);\n    }\n}\n\nint main()\n{\n    vector<int> select;\n    manju(select);\n\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> x(10, 0);\n        for(int i=0; i<n; ++i){\n            int y;\n            cin >> y;\n            ++ x[y];\n        }\n\n        cout << solve(x, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int y){\n\t// ull aa=hash();\n\t// if(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\tif(y<2) return 0;\n\tint ret=0;\n\treep(i,2,11){\n\t\trep(j,vv[i].size()){\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]--;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\trep(k,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i)+1);\n\t\t\t}\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]++;\n\t\t\t}\n\t\t}\n\t}\n\t// return ma[aa]=ret;\n\treturn ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 2;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tull r = s;\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull p = r;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((p >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tp -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tr = p;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10, thr);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[11], ans, total;\n\nint f1[5][2] = {\n\t{9,1},\n\t{8,2},\n\t{7,3},\n\t{6,4},\n\t{5,5}\n};\nint f2[8][3] = {\n\t{8,1,1},\n\t{7,2,1},\n\t{6,3,1},\n\t{6,2,2},\n\t{5,4,1},\n\t{5,3,2},\n\t{4,4,2},\n\t{4,3,3}\n};\nint f3[8][4] = {\n\t{7,1,1,1},\n\t{6,2,1,1},\n\t{5,3,1,1},\n\t{5,2,2,1},\n\t{4,4,1,1},\n\t{4,3,2,1},\n\t{4,2,2,2},\n\t{3,3,2,2}\n};\nint f4[7][5] = {\n\t{6,1,1,1,1},\n\t{5,2,1,1,1},\n\t{4,3,1,1,1},\n\t{4,2,2,1,1},\n\t{3,3,2,1,1},\n\t{3,2,2,2,1},\n\t{2,2,2,2,2},\n};\nint f5[5][6] = {\n\t{5,1,1,1,1,1},\n\t{4,2,1,1,1,1},\n\t{3,3,1,1,1,1},\n\t{3,2,2,1,1,1},\n\t{2,2,2,2,1,1},\n};\n\nvoid solve(int cnt, int sum){\n\tans = max( ans , cnt );\n\tif( total-sum < 10 ) return;\n\tif( (total - sum) / 10 + cnt < ans ) return;\n\t\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\ta[f1[i][0]]--;\n\t\ta[f1[i][1]]--;\n\t\tif( a[f1[i][0]] >= 0 && a[f1[i][1]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f1[i][0]]++;\n\t\ta[f1[i][1]]++;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\ta[f2[i][0]]--;\n\t\ta[f2[i][1]]--;\n\t\ta[f2[i][2]]--;\n\t\tif( a[f2[i][0]] >= 0 && a[f2[i][1]] >= 0 && a[f2[i][2]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f2[i][0]]++;\n\t\ta[f2[i][1]]++;\n\t\ta[f2[i][2]]++;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\ta[f3[i][0]]--;\n\t\ta[f3[i][1]]--;\n\t\ta[f3[i][2]]--;\n\t\ta[f3[i][3]]--;\n\t\tif( a[f3[i][0]] >= 0 && a[f3[i][1]] >= 0 && a[f3[i][2]] >= 0 && a[f3[i][3]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f3[i][0]]++;\n\t\ta[f3[i][1]]++;\n\t\ta[f3[i][2]]++;\n\t\ta[f3[i][3]]++;\n\t}\n\tfor(int i=0 ; i < 7 ; i++ ){\n\t\ta[f4[i][0]]--;\n\t\ta[f4[i][1]]--;\n\t\ta[f4[i][2]]--;\n\t\ta[f4[i][3]]--;\n\t\ta[f4[i][4]]--;\n\t\tif( a[f4[i][0]] >= 0 && a[f4[i][1]] >= 0 && a[f4[i][2]] >= 0 && a[f4[i][3]] >= 0 && a[f4[i][4]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f4[i][0]]++;\n\t\ta[f4[i][1]]++;\n\t\ta[f4[i][2]]++;\n\t\ta[f4[i][3]]++;\n\t\ta[f4[i][4]]++;\n\t}\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\ta[f5[i][0]]--;\n\t\ta[f5[i][1]]--;\n\t\ta[f5[i][2]]--;\n\t\ta[f5[i][3]]--;\n\t\ta[f5[i][4]]--;\n\t\ta[f5[i][5]]--;\n\t\tif( a[f5[i][0]] >= 0 && a[f5[i][1]] >= 0 && a[f5[i][2]] >= 0 && a[f5[i][3]] >= 0 && a[f5[i][4]] >= 0 && a[f5[i][5]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f5[i][0]]++;\n\t\ta[f5[i][1]]++;\n\t\ta[f5[i][2]]++;\n\t\ta[f5[i][3]]++;\n\t\ta[f5[i][4]]++;\n\t\ta[f5[i][5]]++;\n\t}\n\t\n\tif( a[4] >= 1 && a[1] >= 6 ){\n\t\ta[4] -= 1;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[4] += 1;\n\t\ta[1] += 6;\n\t}\n\tif( a[3] >= 1 && a[2] >= 1 && a[1] >= 5 ){\n\t\ta[3] -= 1;\n\t\ta[2] -= 1;\n\t\ta[1] -= 5;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[2] += 1;\n\t\ta[1] += 5;\n\t}\n\tif( a[2] >= 3 && a[1] >= 4 ){\n\t\ta[2] -= 3;\n\t\ta[1] -= 4;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 3;\n\t\ta[1] += 4;\n\t}\n\tif( a[3] >= 1 && a[1] >= 7 ){\n\t\ta[3] -= 1;\n\t\ta[1] -= 7;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[1] += 7;\n\t}\n\tif( a[2] >= 2 && a[1] >= 6 ){\n\t\ta[2] -= 2;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 2;\n\t\ta[1] += 6;\n\t}\n\tif( a[2] >= 1 && a[1] >= 8 ){\n\t\ta[2]--;\n\t\ta[1] -= 8;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2]++;\n\t\ta[1] += 8;\n\t}\n\tif( a[1] >= 10 ){\n\t\ta[1] -= 10;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[1] += 10;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\ttotal = 0;\n\t\tfor(int i=0 ; i < 10 ; i++ ){\n\t\t\ta[i] = 0;\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ttotal += e;\n\t\t\ta[e]++;\n\t\t}\n\t\tans = 0;\n\t\tsolve(0,0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> diff(const vector<int>& a, const vector<int>& b)\n{\n    vector<int> res(10);\n    for (int i = 1; i <= 9; i++) {\n        res[i] = a[i] - b[i];\n    }\n    return res;\n}\n\nbool check_diff(const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 1; i <= 9; i++) {\n        if (a[i] < b[i]) return 0;\n    }\n    return 1;\n}\n\nusing ull = unsigned long long;\n\nclass Hash {\n  public:\n    size_t operator () (const vector<int>& v) const\n    {\n        const ull B = 100000007;\n        ull r = 0;\n        for (const auto& n : v) {\n            r = r * B + n;\n        }\n        return r;\n    }\n};\n\nunordered_map<vector<int>, int, Hash> mem;\nvector<vector<int>> pat;\n\nbool check(const vector<int>& p)\n{\n    int res = 0, cnt = 0;\n    for (int i = 1; i <= 9; i++) {\n        cnt += p[i];\n        res += p[i] * i;\n    }\n    return (res == 10 && cnt > 2);\n}\n\nvoid make_pattern(int n, const vector<int>& p)\n{\n    if (n == 10) {\n        if (check(p)) {\n            pat.emplace_back(p);\n        }\n        return;\n    }\n    for (int i = 0; i <= 10 / n; i++) {\n        vector<int> np = p;\n        np[n] += i;\n        make_pattern(n + 1, np);\n    }\n}\n\nint solve(const vector<int>& m_cnt)\n{\n    int res = 0;\n    if (mem.count(m_cnt) != 0) {\n        return mem[m_cnt];\n    }\n\n    for (const auto& p : pat) {\n        if (check_diff(m_cnt, p)) {\n            res = max(res, solve(diff(m_cnt, p)) + 1);\n        }\n    }\n    return mem[m_cnt] = res;\n}\n\nint main()\n{\n    int N;\n    make_pattern(1, vector<int>(10));\n    while (cin >> N, N > 0) {\n        vector<int> m_cnt(10);\n        for (int i = 0; i < N; i++) {\n            int m;\n            cin >> m;\n            m_cnt[m]++;\n        }\n\n        int res = 0;\n        for (int i = 1; i <= 5; i++) {\n            int mini = min(m_cnt[i], m_cnt[10 - i]); \n            if (i == 5) mini /= 2;\n            res += mini;\n            m_cnt[i] -= mini;\n            m_cnt[10 - i] -= mini;\n        }\n        mem.clear();\n        res += solve(m_cnt);\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint N, manju[10];\nint rest[4], rest_b;\nint dp[26*26*26*26][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline int& at4(int i, int j, int l, int k, int index){\n    return dp[i+j*(rest[0]+1)+k*(rest[0]+rest[1]+2)+l*(rest[0]+rest[1]+rest[2]+3)][index];\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d\\n\", a, b, c, d, index);\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    int res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        // printf(\"%d: %d, %d, %d, %d | %d, %d, %d, %d | %d\\n\",\n        //       index, a, b, c, d, at(index, 0), at(index, 1), at(index, 2), at(index, 3), rest_b);\n        res = std::max(res, rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1);\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        int r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){rest[n] = i; rest_b |= 1 << i; n += 1;}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        int r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1);\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nint n;\nstring a;\nmap<string,int> memo;\n\nint rec(string v){\n  if(memo.find(v)!=memo.end())return memo[v];\n  \n  int res = 0;\n  for(int i=8;i>=1;i--){\n    if(v[i]){\n      if(v[0]+i==10){\n\tv[i]--; v[0] = 0;\n\tres = max(res,rec(v)+1);\n\tv[i]++; v[0] = 10-i;\n      }else if(v[0]+i<10){\n\tv[i]--; v[0] += i;\n\tres = max(res,rec(v));\n\tv[i]++; v[0] -= i;\n      }\n    }\n  }\n\n  return memo[v] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    a.resize(10);\n    for(int i=0;i<10;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp]++;\n    }\n\n    int res = 0;\n    for(int i=1;i<=4;i++){\n      tmp = min(a[i],a[10-i]);\n      a[i]-=tmp; a[10-i]-=tmp;\n      res += tmp;\n    }\n    res += a[5]/2; a[5] &= 1;\n\n    memo.clear();\n    cout << res+rec(a) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n \nmap< pair<int,vector<char> >, int > dp;\nvector< vector<char> > e;\n \n//int dp[51][51][51][51][2];\n \nint dfs(int pos,vector<char> &v){\n    if( pos >= e.size() ) return 0;\n    if( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n    vector<char> V = v;\n    int ans = 0 , c = 0;\n    while(1){\n        ans = max( dfs(pos+1,v) + c , ans);\n         \n        c++;\n        for(int i = 0 ; i < v.size() ; i++)\n            v[i] -= e[pos][i];\n         \n        bool f = true;\n        for(int i = 0 ; i < v.size() ; i++)\n            if( v[i] < 0 ) f = false;\n        if( !f ) break;\n    }\n    v = V;\n    return dp[make_pair(pos,V)] = ans;\n}\n \n \nvector<char> bt;\nvoid gen_pattern(int pos,int r){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( bt );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        bt[pos] = i;\n        gen_pattern(pos+1,r - pos*i);\n    }\n}\n \nint main(){\n    int n;\n    bt.resize(10);\n    gen_pattern(1,10);\n    while(cin >> n && n){\n        vector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n        dp.clear();\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        cout << dfs(0,v)+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[128];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n \n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\nint remove_clear()\n{\n    int s[11];\n    CL(s, 0);\n    for (int i = 0; i < n; ++i)\n        ++s[a[i]];\n \n    int res = 0;\n    for (int i = 1; i <= 4; ++i)\n    {\n        int t = min(s[i], s[10 - i]);\n        res += t;\n        s[i] -= t;\n        s[10 - i] -= t;\n    }\n    res += s[5] / 2;\n    s[5] -= s[5] / 2 * 2;\n \n \n    // int mini = 10;\n    // for (int i = 9; i >= 1; --i)\n    //     if (s[i] > 0)\n    //         mini = i;\n \n    n = 0;\n    for (int i = 1; i <= 9; ++i)\n        while (s[i] > 0)\n            a[n++] = i, --s[i];\n \n    return res;\n}\n\nvoid test()\n{\n    n = 100;\n    for (int i = 0; i < n; ++i)\n        a[i] = rand () % 10 + 1;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n\n        sort(a, a + n, greater<int>());\n \n        for (int i = 0; i < n; ++i)\n            memo[i].clear();\n\n        possi_max = accumulate(a, a + n, 0) / 10;\n        res = 0;\n        dfs(0);\n \n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[11],da[43][11],dn[43],h,v,n,f,an,z;\n\nint list(int n,int k,int g) {\n\tint i; \n\tif (k==10 && n==h) { for (i=0;i<h;i++) da[v][a[i]]++; dn[v]=h; v++; }\n\tif (n==h || k>=10) return 1;\n\tfor (i=g;i<10;i++) { a[n]=i; list(n+1,k+i,i);}\n\treturn 0;\n}\n\nint dfs(int g,int u,int t) {\n\tint i,j,k;\n\tif (an<g)  an=g;\n\tif (g+t/dn[u]<=an) return 0;\n\tfor (i=u;i<41;i++) {\n\t\tf=0;\n\t\tfor (j=1;j<10;j++) {a[j]-=da[i][j]; if (a[j]<0) { f=1; for (k=j;k>0;k--) a[k]+=da[i][k]; break;}}\n\t\tif (f==0) {dfs(g+1,i,t-dn[i]); for(j=1;j<10;j++) a[j]+=da[i][j];}\n\t\t}\n  return 0;\n}\n\nint main() {\n\tint i,j;\n\tv=0;\n\tfor (i=0;i<40;i++) for (j=0;j<11;j++) da[i][j]=0;\n\tfor (i=2;i<11;i++) { h=i; list(0,0,1); }\n\twhile(cin >> n && n>0) {\n\t\tfor (i=0;i<11;i++) a[i]=0;\n\t\tfor (i=0;i<n;i++) { cin >> j; a[j]++; }\n\t\tv=0; an=0;\n\t\tdfs(0,0,n);\n\t\tcout << an << endl;\t\n\t    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\tif(nowmax[num] < ko)\n\t\tnowmax[num] = ko;\n\tif(num > 10)\n\t\treturn ko;\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n\tif(M == 0)\n\t\treturn ko;\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n\t\t\tif(nowmax[num] > ko){\n\t\t\t\tans = max(ans,ko);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<vector<int> > sum10;\nvector<int> as;\n\nvoid dfs(vector<int> v, int now, int sum) {\n  if (sum == 10) {\n    sum10.push_back(v);\n    return;\n  }\n  if (now == as.size()) return;\n  dfs(v,now+1,sum);\n  if (sum + as[now] <= 10) {\n    v.push_back(now);\n    dfs(v,now,sum+as[now]);\n  }\n}\n\nmap<vector<int> , int> mp[50];\n\nint solve(int now, vector<int> v) {\n  if (now == sum10.size()) return 0;\n  if (mp[now].count(v)) return mp[now][v];\n  int res = 0;\n  REP(i,100) {\n    bool dame = 0;\n    res = max(res, solve(now+1, v) + i);\n    FOR(it, sum10[now]) {\n      if (v[*it]-- == 0) dame = 1;\n    }\n    if(dame) break;\n  }\n  return mp[now][v] = res;\n}\n\nint a[10];\n\nint main() {\n  // REP(i,9) as.push_back(i+1);\n  // vector<int> t;\n  // dfs(t,0,0);\n  // FOR(it, sum10) {\n  //   FOR(jt, *it) cout << *jt << \" \";\n  //   cout << endl;\n  // }\n  int n;\n  while(cin>>n,n) {\n    int ans = 0;\n    memset(a,0,sizeof(a));\n    REP(i,n) {\n      int b;cin >> b;\n      if (b >= 10) {\n        if (b == 10) ans++;\n      } else {\n        a[b]++;\n      }\n    }\n    for (int i=1; i<=4; ++i) {\n      int j = 10-i;\n      int m = min(a[i], a[j]);\n      a[i] -= m;\n      a[j] -= m;\n      ans += m;\n    }\n    ans += a[5] / 2;\n    a[5] -= a[5]/2;\n    vector<int> v;\n    as.clear();\n    REP(i,10) if (a[i]) {\n      as.push_back(i);\n      v.push_back(a[i]);\n    }\n    sum10.clear();\n    vector<int> t;\n    dfs(t,0,0);\n    REP(i,sum10.size()) mp[i].clear();\n    ans += solve(0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0;\n    }\n    if(dp.count(vec)) return dp[vec];\n\n    int add = 0;\n    for(int i=id; i<=9; i++) {\n        if(vec[i] > 0) {\n            vec[i]--; sum += i;\n            chmax(add, solve(vec, sum, i));\n            vec[i]++; sum -= i;\n        }\n    }\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int m[11] = {0};\n        rep(i,n){\n            int a;\n            cin >> a;\n            m[a]++;\n        }\n\n        int ans = 0, f = true;\n        map<pair<int,int>, pair<int,int>> pre;\n\n        range(i,1,5){\n            int a = min(m[i], m[10 - i]);\n            ans += a;\n            m[i] -= a;\n            m[10 - i] -= a;\n        }\n        int a = m[5] / 2;\n        ans += a;\n        m[5] -= a * 2;\n\n        while(f){\n            f = false;\n            bool dp[1005][11] = {{0}};\n            dp[0][0] = true;\n            rep(i,9){\n                rep(j,11){\n                    for(int k = 0; k <= m[9 - i] && k * (9 - i) <= j; k++){\n                        if(not dp[i + 1][j] && dp[i][j - k * (9 - i)]){\n                            dp[i + 1][j] = true;\n                            pre[make_pair(i + 1, j)] = make_pair(k, 9 - i);\n                        }\n                    }\n                }\n            }\n            if(dp[9][10]){\n                f = true;\n                ans++;\n                int num = 9, sum = 10;\n                while(sum != 0){\n                    pair<int, int> prev = pre[make_pair(num, sum)];\n                    //show(prev.first)\n                    //show(prev.second)\n                    m[prev.second]-=prev.first;\n                    sum -= prev.second * prev.first;\n                    num--;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\nvector<int> c;\n\nint getMax(vector<int> p, int sum)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tif (sum < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tc = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c, sum - 10));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tint s = 0;\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\ts += i * num[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num, s));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nstruct Manju { int k[10]; };\nvector<Manju>dp[11][11], S;//dp[end][sum]\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<Manju>Q; Q.push(T);\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front(); Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (S[i].k[j]>R.k[j])OK = false;\n\t\t\t}\n\t\t\tif (OK == false)continue; Manju RR = R;\n\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[i].k[j];\n\t\t\tQ.push(RR);\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 1000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 99 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <ctime>\n#include <sys/time.h>\nusing namespace std;\n\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n\nint ans = 0;\nint C = 0; \nclock_t start,end;\n\nvoid dfs(int pos,long long v){\n\tend = clock();\n\tif( (double)(end - start) / CLOCKS_PER_SEC > 5.0) return; \n    if( pos >= e.size() ) return;\n\tans = max( ans , C );\n    int c = 0;\n    while(1){\n\t\tC += c;\n        dfs(pos+1,v);\n\t\tC -= c;\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n}\n  \n  \n \n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n\tsort(e.rbegin(),e.rend());\n    while(cin >> n && n){\n\t\tvector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n\t\tclock_t start, end;\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n\t\tC = 0;\n\t\tans = 0;\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n\t\tstart = clock();\n\t\tdfs(0,enc);\n        cout << ans+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n// int N;\n// int MS[101];\n// vector<map<char,char> > howToGet;\n// map<map<char,char>,char> dp[43];\n// void dfs(const int kind,int wgt,map<char,char> v){\n//   if(kind==0){\n//     map<char,char> nv=v;\n//     dfs(kind+1,wgt,nv);\n//   }\n//   else if(wgt==0)howToGet.push_back(v);\n//   else if(kind==10)return;\n//   else{\n//     for(int i=0;i*kind<=10;i++){\n//       if(wgt-i*kind>=0){\n// \tmap<char,char> nv=v;\n// \tif(i>=1)nv[kind]=i;\n// \tdfs(kind+1,wgt-i*kind,nv);\n//       }\n//     }\n//   }\n// }\n\n// void dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n//   if(pos==(int)howToGet.size())return;\n//   if(preLast/10+cnt<=maxVal)return;\n//   // 1セット分取れるか\n//   map<char,char> nv=v;\n//   bool ok=true;\n//   int sz=0;\n//   for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n//     if(nv.count(it->first)==0\n//        ||nv[it->first]-(it->second)<0){\n//       ok=false;\n//       break;\n//     }\n//     else{\n//       nv[it->first]-=it->second;\n//       sz+=it->second;\n//     }\n//   }\n//   // 1セット取れるならとる\n//   if(ok){\n//     maxVal=max(maxVal,cnt+1);\n//     dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n//   }\n//   // 取らずに次のセットへ\n//   dfs2(pos+1,v,cnt,maxVal,preLast);\n// }\n\n// void greedy(int &maxVal,map<char,char> v){\n//   for(int pos=0;pos<(int)howToGet.size();pos++){\n//     while(1){\n//       bool ok=true;\n//       for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n// \tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n// \t  ok=false;\n// \t  break;\n// \t}\n//       }\n//       if(ok){\n// \tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n// \t  v[it->first]-=it->second;\n// \tmaxVal++;\n//       }\n//       else\n// \tbreak;\n//     }\n//   }\n// }\n\n// int main(){\n//   dfs(0,10,map<char,char>());\n//   while(cin>>N&&N){\n//     map<char,char> cnts;\n//     int preLast=0;\n//     for(int i=0;i<N;i++)cin>>MS[i];\n//     for(int i=0;i<N;i++){\n//       cnts[MS[i]]++;\n//       preLast+=MS[i];\n//     }\n//     for(int i=0;i<43;i++)dp[i].clear();\n//     int maxVal=0;\n//     greedy(maxVal,cnts);\n//     // cout<<maxVal<<endl;\n//     // dfs2(0,cnts,0,maxVal,preLast);\n//     cout<<maxVal<<endl;\n//   }\n//   return 0;\n// }\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    int a=min(cnts[9],cnts[1]);\n    cnts[9]-=a;\n    cnts[1]-=a;\n    int b=min(cnts[8],cnts[2]);\n    cnts[8]-=b;\n    cnts[2]-=b;\n    int c=min((int)cnts[8],(int)cnts[1]/2);\n    cnts[8]-=c;\n    cnts[2]-=c;\n    int res=dfs2(cnts)+a+b+c;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1800000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1800000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND;\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\t\n\t\tint t = 0;\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\twhile (v[i] && v[10 - i]){\n\t\t\t\tt++;\n\t\t\t\tv[i]--;\n\t\t\t\tv[10 - i]--;\n\t\t\t}\n\t\t}\n\t\tt += v[5] / 2;\n\t\tv[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", t + calc(v));\n\t\tdp.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    int sum=0;\n    for(int i=1;i<=4;i++){\n      int a=min(cnts[i],cnts[10-i]);\n      cnts[i]-=a;cnts[10-i]-=a;\n      sum+=a;\n    }\n    int a=cnts[5]/2;\n    cnts[5]-=2*a;\n    sum+=a;\n    int res=dfs2(cnts)+sum;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef pair<pr , pr > ppr;\ntypedef array<int,5> arafi;\nint num[5]={},numTimes[5]={},numbers;\nvector<array<int,5> > p; \nvoid search(int times,int gets[5]){\n\tif(times==numbers){\n\t\n\t\tint sum=0;\n\t\tfor(int i=0;i<numbers;i++)\n\t\t\tsum+=num[i]*gets[i];\n\t\tif(sum==10){\n\t\t\tarafi a={gets[0],gets[1],gets[2],gets[3],gets[4]};\n\t\tp.push_back(a);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<=numTimes[times] && i<=10 ;i++){\n\t\tgets[times]=i;\n\t\tsearch(times+1,gets);\n\t\t}\n\t}\n}\nint findAns(int x,int times[]){\n\tif (x==p.size())\n\t\treturn 0;\n\tint maxim=0,ans=1;\n\tarafi ar=p[x];\n\tfor(int i=0;i<numbers;i++){\n\t\tif(ar[i]>times[i])\n\t\t\tans=0;\n\t\ttimes[i]-=ar[i];\n\t}\n\tif(ans)\n\tmaxim=max(maxim,1+findAns(x,times));\n\tfor(int i=0;i<numbers;i++)\n\t\ttimes[i]+=ar[i];\n\tmaxim=max(maxim,findAns(x+1,times));\n\treturn maxim;\n}\nint solved(vector<pr> v){\n\t\tint ans=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tnum[i]=v[i].first;\n\t\t\tnumTimes[i]=v[i].second;\n\t\t}\n\t\tnumbers=v.size();\n\t\tint gets[5]={};\n\t\tsearch(0,gets);\n\t\treturn findAns(0,numTimes);\n}\nint main() {\n\t// your code goes here\n\tint n,tmp;\n\twhile(cin >> n && n!=0){\n\t\tp.clear();\n\t\tnumbers=0;\n\t\tvector<pr > v;\n\t\tint nums[10]={},sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\tnums[tmp]++;\n\t\t}\n\t\tfor(int i=1;i<=4;i++)\n\t\t\tif(nums[i] && nums[10-i]){\n\t\t\t\tint manju=min(nums[i],nums[10-i]);\n\t\t\t\tsum+=manju;\n\t\t\t\tnums[i]-=manju;\n\t\t\t\tnums[10-i]-=manju;\n\t\t\t}\n\t\tsum+=nums[5]/2;\n\t\tnums[5]%=2;\n\t\tfor(int i=1;i<=8;i++)\n\t\t\tif(nums[i])\n\t\t\t\tv.push_back(pr(i,nums[i]));\n\t\tcout << sum+solved(v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int y){\n\tull aa=hash();\n\tif(ma.count(aa)) return ma[aa];\n\tif(y<2) return ma[aa]=0;\n\tint ret=0;\n\treep(i,2,11){\n\t\trep(j,vv[i].size()){\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]--;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\trep(k,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i)+1);\n\t\t\t}\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ma[aa]=ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n \nmap< pair<int,long long>, int>  dp;\nvector< long long > e;\n \t\n//int dp[51][51][51][51][2];\n \nvoid gen_pattern(int pos,int r,long long v){\n\tif( pos >= 10 ){\n\t\tif( r == 0 ){\n\t\t\te.push_back( v );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; r - pos * i >= 0 ; i++){\n\t\tgen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n\t}\n}\n \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tcout << (v >> (7*i) & 127) <<\" \";\n\t}\n\tcout << endl;\n}\n\nint dfs(int pos,long long v){\n\tif( pos >= e.size() ) return 0;\n\tif( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n\tlong long V = v;\n\tint ans = 0 , c = 0;\n\twhile(1){\n\t\tans = max( dfs(pos+1,v) + c , ans);\n\t\tc++;\n\t\tbool f = true;\n\t\tfor(int i = 0 ; i < 9 ; i++){\n\t\t\tint s = v >> (7*i) & 127;\n\t\t\tint x = e[pos] >> (7*i) & 127;\n\t\t\tif( s < x ){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !f ) break;\n\t\tv -= e[pos];\n\t}\n\tv = V;\n\treturn dp[make_pair(pos,V)] = ans;\n}\n \n \n\nint main(){\n\tint n;\n\tgen_pattern(1,10,0);\n\twhile(cin >> n && n){\n\t\tvector<char> v(10);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t]++;\n\t\t}\n\t\tint greedy = 0;\n\t\tfor(int i = 1 ; i < 5 ; i++){\n\t\t\tint u = min(v[i],v[10-i]);\n\t\t\tgreedy += u;\n\t\t\tv[i] -= u; \n\t\t\tv[10-i] -= u;\n\t\t}\n\t\tgreedy += v[5] / 2;\n\t\tv[5] %= 2;\n\t\tlong long enc = 0;\n\t\tfor(int i = 1 ; i < 10 ; i++){\n\t\t\tenc += (long long)(v[i]) << (7 * (i-1));\n\t\t}\n\t\tdp.clear();\n\t\tcout << dfs(0,enc)+greedy << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint num[10];\n\nint getMax(int sum, int u)\n{\n\tint ans;\n\t\n\tif (u == 10){\n\t\treturn (0);\n\t}\n\t\n\tint remain = 0;\n\tfor (int i = 1; i <= 9; i++){\n\t\tremain += num[i] * i;\n\t}\n\tif (remain < 10) return (0);\n\t\n\tif (sum == 10){\n\t\treturn (1 + getMax(0, 1));\n\t}\n\t\n\tans = 0;\n\tfor (int i = u; i <= 9; i++){\n\t\tif (num[i] && sum + i <= 10){\n\t\t\tnum[i]--;\n\t\t\tans = max(ans, getMax(sum + i, i));\n\t\t\tnum[i]++;\n\t\t}\n\t}\n\tans = max(ans, getMax(sum, u + 1));\n\t\n\treturn (ans);\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\t\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(0, 1));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\n\nint dfs(int cnt,int sum,vector<int> remain){\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n  int maxcost = cnt;\n  REP(i,1,10){\n    if( remain[i] == 0 ) continue;\n    int nsum = sum + i;\n    if( nsum >  10 ) continue;\n    remain[i]--;\n    if( nsum == 10 ) {\n      maxcost = max(maxcost,dfs(cnt+1,0,remain));\n    } else {\n      maxcost = max(maxcost,dfs(cnt,nsum,remain));\n    }\n    remain[i]++;\n  }\n  return memo[remain] = maxcost;  \n}\n\n\nint main() {\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= 2*tmp;\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(int i, vector<int> v)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tint sum = 0;\n\tfor (int i = 0; i < 9; i++){\n\t\tsum += (i + 1) * v[i];\n\t}\n\tif (sum < 10) return 0;\n\tif (i == T.size()) return 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tres = max(res, j + dfs(i + 1, v));\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1800000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1800000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid MakeNextData(vector<int>&);\nbool Compare(const vector<int>&, const vector<int>&);\nint Search(vector<int>&, vector<int>);\n\nint main(){\n  int i, j, n, x, count;\n  vector<int> _data;\n  vector< vector<int> > data;\n\n  _data.push_back(10);\n  while(_data[0] != 1){\n    MakeNextData(_data);\n    data.push_back(_data);\n  }\n  sort(data.begin(), data.end(), Compare);\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    vector<int> manju(10, 0);\n    for(i=0; i<n; ++i){\n      cin >> x;\n      ++manju[x];\n    }\n\n    for(i=0, count=0; i<data.size(); ++i)\n      count += Search(manju, data[i]);\n\n    cout << count << endl;\n  }\n  return 0;\n}\n\nvoid MakeNextData(vector<int>& x){\n  int i, n, count;\n\n  for(i=x.size()-1, count=0; i>=0; --i, ++count){\n    if(x[i] == 1) x.pop_back();\n    else break;\n  }\n  x.erase(x.begin()+i+1, x.end());\n\n  --x[x.size()-1];\n  n = x[x.size()-1];\n  ++count;\n\n  while(count/n != 0){\n    x.push_back(n);\n    count -= n;\n  }\n  if(count != 0) x.push_back(count);\n}\n\nbool Compare(const vector<int>& x, const vector<int>& y){\n  int i;\n  if(x.size() == y.size()){\n    for(i=0; i<x.size(); ++i){\n      if(x[i] != y[i]) return (x[i] > y[i]);\n    }\n  }else{\n    return (x.size() < y.size());\n  }\n}\n\nint Search(vector<int>& data1, vector<int> data2){\n  int i, count=0;\n  vector<int> _data;\n  while(1){\n    _data = data1;\n    for(i=0; i<data2.size(); ++i){\n      --_data[data2[i]];\n      if(_data[data2[i]] < 0) return count;\n    }\n    ++count;\n    data1 = _data;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\tif(No == 9)\n\t\t\t\t\tmanto[10]++;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tprintf(\"%d\\n\", manto[10])\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool check(const vector<vector<pair<int, int>>>&humans, int x, int y) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto it=find(humans[i].begin(),humans[i].end(),make_pair(x,y));\n\t\tif(it!=humans[i].end())return false;\n\t}\n\treturn true;\n}\nint dx[] = { -1,0,1,0,0 };\nint dy[] = { 0,1,0,-1,0 };\n\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\nstruct sale {\n\tint id;\n\tint d;\n\tint s;\n\tint e;\n};\n\nstruct aa {\n\tint flag;\n\tint x;\n\tint y;\n\tint cost;\n};\n\nbool operator <(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]>r[i])return false;\n\t}\n\treturn false;\n}\nint solve(vector<int>haves, vector<int>nums) {\n\tmap<pair<vector<int>,int>,int>mp;\n\tmp[make_pair(nums,0)]=1;\n\n\tint ans=1;\n\tqueue<pair<vector<int>,int>>que;\n\tque.push(make_pair(nums,0));\n\twhile (!que.empty()) {\n\t\tauto atop(que.front());\n\t\tque.pop();\n\n\t\tint x=atop.second;\n\t\tvector<int>v(atop.first);\n\n\t\tint cost=mp[make_pair(atop.first,atop.second)];\n\t\tans=max(ans,cost);\n\t\tfor (int i = 0; i < haves.size(); ++i) {\n\t\t\tif (v[i]){\n\t\t\t\tif (x+haves[i] >= 11) {\n\n\t\t\t\t}\n\t\t\t\telse if (x + haves[i] == 10) {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,0);\n\t\t\t\t\tif (mp[np] < cost + 1) {\n\t\t\t\t\t\tmp[np]=cost+1;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,x+haves[i]);\n\t\t\t\t\tif (mp[np] < cost) {\n\t\t\t\t\t\tmp[np]=cost;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans-1;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint N;cin>>N;\n\t\tif(N==0)break;\n\t\tvector<int>vs(10);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a;cin>>a;\n\t\t\tvs[a]++;\n\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 6; i <= 9; ++i) {\n\t\t\tint x=min(vs[i],vs[10-i]);\n\t\t\tvs[i]-=x;\n\t\t\tvs[10-i]-=x;\n\t\t\tans+=x;\n\t\t}\n\t\t{\n\t\t\tint x=vs[5]/2;\n\t\t\tvs[5]-=x;\n\t\t\tans+=x;\n\t\t}\n\t\tvector<int>haves;\n\t\tvector<int>nums;\n\t\tfor (int i = 1; i <= 9; ++i) {\n\t\t\tif (vs[i]) {\n\t\t\t\thaves.push_back(i);\n\t\t\t\tnums.push_back(vs[i]);\n\t\t\t}\n\t\t}\n\t\tans+=solve(haves,nums);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\tmanto[10]++;\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\n\tif(No == 9 && x < manto[10])\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tcout << manto[10] << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nmap<ull,int> memo;\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s <= 0xff){\n\t\treturn s / 10;\n\t}\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\tint res = max(a, b);\n\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(t != 9 && s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju { \n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<Manju, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<Manju>Q; Q.push(T); M[T] = 1;\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front(); Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (S[i].k[j]>R.k[j])OK = false;\n\t\t\t}\n\t\t\tif (OK == false)continue; Manju RR = R;\n\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[i].k[j];\n\t\t\tif (M[RR] != 1) { Q.push(RR); M[RR] = 1; }\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\n//map<wolf,int> dp;\nint solve(wolf a,int b){\n//\tif((int)(dp.count(a)))return dp[a];\n\tint ret=0;\n\tfor(int i=35;i>=0;i--){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,35));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tshort k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<pair<int, Manju>, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(int pos, Manju T) {\n\tif (pos == S.size())return 0;\n\tif (M[make_pair(pos, T)] != 0)return M[make_pair(pos, T)];\n\tint maxn = 0, cnt = 0; Manju U = T;\n\twhile (true) {\n\t\tmaxn = max(maxn, manju(pos + 1, U) + cnt);\n\t\tfor (int i = 0; i < 10; i++) { U.k[i] -= S[pos].k[i]; }\n\t\tbool flag = true; for (int i = 0; i < 10; i++) { if (U.k[i] < 0)flag = false; }\n\t\tif (flag == false)break;\n\t\tcnt++;\n\t}\n\tM[make_pair(pos, T)] = maxn;\n\treturn  maxn;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tfor (int i = 1; i < 5; i++) { int WW = min(A.k[10 - i], A.k[i]); A.k[10 - i] -= WW; A.k[i] -= WW; adv += WW; }\n\t\tadv += A.k[5] / 2; A.k[5] %= 2;\n\t\tcout << manju(0, A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct s {\n\tchar a[6];\n\ts() {\n\t\tfor(int i = 0; i < 6; i++)\n\t\t\ta[i] = 0;\n\t}\n\tbool operator==(const s & obj) const {\n\t\tbool res = true;\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tres &= a[i] == obj.a[i];\n\t\t}\n\t\treturn res;\n\t}\n\tbool operator<(const s & obj) const {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(a[i] < obj.a[i])\n\t\t\t\treturn true;\n\t\t\telse if(a[i] > obj.a[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<s> v;\n\t\tvector<int> in;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tin.push_back(tmp);\n\t\t\tsum += tmp;\n\t\t}\n\t\tsort(in.rbegin(), in.rend());\n\t\tv.push_back(s());\n\t\tint res = 0;\n\t\tfor(int k = 0; k < in.size(); k++) {\n\t\t\tint m;\n\t\t\tvector<s> nex;\n\t\t\tm = in[k];\n\t\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\t\tres = max(res, (int)v[i].a[5]);\n\t\t\t\tif(res - v[i].a[5] > sum / 10)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j = 0; j + m <= 10; j++) {\n\t\t\t\t\ts p = v[i];\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t\t;\n\t\t\t\t\telse if(j <= 5) {\n\t\t\t\t\t\tif(p.a[j-1] <= 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tp.a[j-1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(p.a[10-j-1] >= 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tp.a[10-j-1]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(j+m <= 5) {\n\t\t\t\t\t\tp.a[j+m-1]++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j+m < 10) {\n\t\t\t\t\t\tp.a[10-(j+m)-1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.a[5]++;\n\t\t\t\t\t}\n//\t\t\t\t\tcout << j + m << endl;\n\t\t\t\t\tnex.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(nex.begin(), nex.end());\n\t\t\tnex.erase(unique(nex.begin(), nex.end()), nex.end());\n\t\t\tv = nex;\n\t\t\tsum -= in[k];\n\t\t}\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tres = max(res, (int)v[i].a[5]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[11],da[40][11],h,v,n;\n\nint list(int n,int k,int g) {\n\tint i; \n\tif (k==10 && n==h) { for (i=0;i<h;i++) da[v][a[i]]++;\tv++; }\n\tif (n==h || k>=10) return 1;\n\tfor (i=g;i<10;i++) { a[n]=i; list(n+1,k+i,i);}\n\treturn 0;\n}\n\n\nint main() {\n\tint i,j,an;\n\tv=0;\n\tfor (i=0;i<40;i++) for (j=0;j<11;j++) da[i][j]=0;\n\tfor (i=2;i<11;i++) { h=i; list(0,0,1); }\n\twhile(cin >> n && n>0) {\n\t\tfor (i=0;i<12;i++) a[i]=0;\n\t\tfor (i=0;i<n;i++) { cin >> j; a[j]++; }\n\t\tv=0; an=0;\n\t\twhile(v<40) {\n\t\t\twhile(true) {\n\t\t\t\th=0;\n\t\t\t\tfor (i=1;i<11;i++) if (da[v][i]>a[i]) { h=1; break;}\n\t\t\t\tif (h==1) break;\n\t\t\t\tan++; for (i=1;i<11;i++) a[i]=a[i]-da[v][i];\n\t\t\t} \n\t\t   v++;\n\t\t   }\n\t   cout << an << endl;\n   }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nvector<VV(pii)> vp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int y,int t1,int t2){\n\t// ull aa=hash();\n\t// if(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\tif(y<2) return 0;\n\tint ret=0;\n\treep(j,t2,vp[t1].size()){\n\t\trep(k,vp[t1][j].size()){\n\t\t\ta[vp[t1][j][k].F]-=vp[t1][j][k].S;\n\t\t}\n\t\tbool f=true;\n\t\treep(k,1,10){\n\t\t\tif(a[k]<0) f=false;\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t}\n\t\trep(k,vp[t1][j].size()){\n\t\t\ta[vp[t1][j][k].F]+=vp[t1][j][k].S;\n\t\t}\n\t}\n\treep(i,t1+1,11){\n\t\trep(j,vp[i].size()){\n\t\t\trep(k,vp[i][j].size()){\n\t\t\t\ta[vp[i][j][k].F]-=vp[i][j][k].S;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\treep(k,1,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t}\n\t\t\trep(k,vp[i][j].size()){\n\t\t\t\ta[vp[i][j][k].F]+=vp[i][j][k].S;\n\t\t\t}\n\t\t}\n\t}\n\t// return ma[aa]=ret;\n\treturn ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tvp=vector<VV(pii)>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\trep(i,vv.size()){\n\t\tVV(pii) tmp;\n\t\trep(j,vv[i].size()){\n\t\t\tint t1=vv[i][j][0];\n\t\t\tint t2=0;\n\t\t\tvector<pii> vpii;\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\tif(t1==vv[i][j][k]){\n\t\t\t\t\tt2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvpii.PB(pii(t1,t2));\n\t\t\t\t\tt1=vv[i][j][k];\n\t\t\t\t\tt2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvpii.PB(pii(t1,t2));\n\t\t\ttmp.PB(vpii);\n\t\t}\n\t\tvp[i]=tmp;\n\t}\n\t// rep(i,vp.size()){\n\t\t// cout<<endl;\n\t\t// cout<<\"i \"<<i<<endl;\n\t\t// rep(j,vp[i].size()){\n\t\t\t// cout<<\" j \"<<j<<endl;\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// cout<<\"  \"<<vp[i][j][k].F<<\" \"<<vp[i][j][k].S<<endl;\n\t\t\t// }\n\t\t// }\n\t// }\n\t// return;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n,2,0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint rest[10];\nvector<vector<int> > pat;\nvector<int> stk;\nint edge[64][64];\nvector<int> greedy;\nbool check[64];\n\nvoid mkpat(int num, int sum) {\n\tif(sum > 10)\n\t\treturn;\n\tif(sum == 10)\n\t\tpat.push_back(stk);\n\n\tfor(int i = num; i; i--) {\n\t\tstk.push_back(i);\n\t\tmkpat(i, sum+i);\n\t\tstk.pop_back();\n\t}\n}\n\nint mkedge(int a, int b) {\n\tvector<int> va, vb;\n\tint i, j;\n\ti = j = 0;\n\twhile(i < pat[a].size() && j < pat[b].size()) {\n\t\tif(pat[a][i] == pat[b][j]) {\n\t\t\ti++; j++;\n\t\t}\n\t\telse if(pat[a][i] < pat[b][j]) {\n\t\t\tvb.push_back(pat[b][j]);\n\t\t\tj++;\n\t\t}\n\t\telse if(pat[a][i] > pat[b][j]) {\n\t\t\tva.push_back(pat[a][i]);\n\t\t\ti++;\n\t\t}\n\t}\n\twhile(i < pat[a].size())\n\t\tva.push_back(pat[a][i++]);\n\twhile(j < pat[b].size())\n\t\tvb.push_back(pat[b][j++]);\n\n\tint aa, bb;\n\taa = bb = 1;\n\tfor(int i = 0; i < va.size(); i++) {\n\t\tfor(int j = 10; j-va[i] >= 0; j--) {\n\t\t\taa |= (!!(aa & (1 << (j-va[i])))) << j;\n\t\t}\n\t}\n\tfor(int i = 0; i < vb.size(); i++) {\n\t\tfor(int j = 10; j-vb[i] >= 0; j--) {\n\t\t\tbb |= (!!(bb & (1 << (j-va[i])))) << j;\n\t\t}\n\t}\n\taa >>= 1; bb >>= 1;\n\n\tif(!(aa ^ bb))\n\t\treturn 0;\n\tif(aa & (~bb))\n\t\treturn -1;\n\tif((~aa) & bb)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid mkgreedy(int n) {\n\tif(check[n])\n\t\treturn;\n\tcheck[n] = true;\n\tfor(int i = 0; i < 64; i++) {\n\t\tif(edge[n][i] == 1)\n\t\t\tmkgreedy(i);\n\t}\n\tgreedy.push_back(n);\n}\n\nint main() {\n\tint n;\n\tmkpat(9,0);\n\t/*\n\tcout << \"sz:\" << pat.size() << endl;\n\tfor(int i = 0; i < pat.size(); i++) {\n\t\tfor(int j = 0; j < pat[i].size(); j++)\n\t\t\tcout << pat[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\t// */\n\tfor(int i = 0; i < 64; i++)\n\t\tedge[i][i] = 1;\n\tfor(int i = 0; i < pat.size(); i++) {\n\t\tfor(int j = 0; j < pat.size(); j++) {\n\t\t\tif(i == j) continue;\n\t\t\tint res = mkedge(i,j);\n\t\t\tedge[i][j] = res;\n\t\t\tedge[j][i] = -res;\n\t\t}\n\t}\n\tfor(int i = 0; i < pat.size(); i++)\n\t\tmkgreedy(i);\n\treverse(greedy.begin(), greedy.end());\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\trest[i] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint in;\n\t\t\tcin >> in;\n\t\t\trest[in]++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < greedy.size(); i++) {\n\t\t\tint flg = true;\n\t\t\twhile(flg) {\n\t\t\t\tint use[10] = {0};\n\t\t\t\tfor(int j = 0; j < pat[greedy[i]].size(); j++) {\n\t\t\t\t\tuse[pat[greedy[i]][j]]++;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t\t\tflg &= use[j] <= rest[j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t\t\t\trest[j] -= use[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[33*33*33*33][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // (i+base[0]*(j+base[1]*(k+base[2]*l)) < 1000000)\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index, int depth){\n    if(depth > 100){return 110;}\n\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1, depth+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index, depth+1)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6, 0);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6, 0) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint ans;\nset<vector<int> > ss;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i+i<=10;i++){\n        int j = 10 - i;\n        vector<int> v2 = v;\n        if(v2[i] > 0){\n            v2[i]--;\n            if(v2[j] > 0){\n                v2[j]--;\n                if(ss.find(v2) != ss.end()) continue;\n                ss.insert(v2);\n                f = true;\n                dfs(v2,cnt+1);\n            }\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        if(ss.find(v2) != ss.end()) continue;\n                        ss.insert(v2);\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                if(ss.find(v2) != ss.end()) continue;\n                                ss.insert(v2);\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        if(ss.find(v2) != ss.end()) continue;\n                                        ss.insert(v2);\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                if(ss.find(v2) != ss.end()) continue;\n                                                ss.insert(v2);\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        if(ss.find(v2) != ss.end()) continue;\n                                                        ss.insert(v2);\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        if(ss.find(v2) != ss.end()){\n            ss.insert(v2);\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 1 && v[1] >= 8){\n        vector<int> v2 = v;\n        v2[2] -= 1;\n        v2[1] -= 8;\n        if(ss.find(v2) != ss.end()){\n            ss.insert(v2);\n            dfs(v2,cnt+1);\n        return;\n        }\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        if(ss.find(v) != ss.end()) return;\n        ss.insert(v);\n        dfs(v,cnt+1);\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        ss.clear();\n        vector<int> v(10,0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 10; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint solve(vi& ms,vi& label,int remain,int index)\n{\n\tint n=ms.size();\n\t\n\tif(remain==0)\n\t\treturn 1+solve(ms,label,10,0);\n\telse{\n\t\tint res=0;\n\t\trepi(i,index,n){\n\t\t\tif(label[i] || ms[i]>remain)\n\t\t\t\tcontinue;\n\t\t\tif(i>0 && ms[i-1]==ms[i] && !label[i-1]) // 1つ前の同じ重さの饅頭を選んでいない\n\t\t\t\tcontinue;\n\t\t\tlabel[i]=1;\n\t\t\tres=max(res,solve(ms,label,remain-ms[i],i+1));\n\t\t\tlabel[i]=0;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi ms(n);\n\t\trep(i,n) scanf(\"%d\",&ms[i]);\n\t\t\n\t\tsort(all(ms),greater<int>());\n\t\tvi label(n);\n\t\tint res=solve(ms,label,10,0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct s {\n\tchar a[6];\n\ts() {\n\t\tfor(int i = 0; i < 6; i++)\n\t\t\ta[i] = 0;\n\t}\n\tbool operator==(const s & obj) const {\n\t\tbool res = true;\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tres &= a[i] == obj.a[i];\n\t\t}\n\t\treturn res;\n\t}\n\tbool operator<(const s & obj) const {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(a[i] < obj.a[i])\n\t\t\t\treturn true;\n\t\t\telse if(a[i] > obj.a[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<s> v;\n\t\tv.push_back(s());\n\t\tint res = 0;\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\tint m;\n\t\t\tvector<s> nex;\n\t\t\tcin >> m;\n\t\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\t\tres = max(res, (int)v[i].a[5]);\n\t\t\t\tif(res > v[i].a[5] + (n - k))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j = 0; j + m <= 10; j++) {\n\t\t\t\t\ts p = v[i];\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t\t;\n\t\t\t\t\telse if(j <= 5) {\n\t\t\t\t\t\tif(p.a[j-1] <= 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tp.a[j-1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(p.a[10-j-1] >= 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tp.a[10-j-1]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(j+m <= 5) {\n\t\t\t\t\t\tp.a[j+m-1]++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j+m < 10) {\n\t\t\t\t\t\tp.a[10-(j+m)-1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.a[5]++;\n\t\t\t\t\t}\n//\t\t\t\t\tcout << j + m << endl;\n\t\t\t\t\tnex.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(nex.begin(), nex.end());\n\t\t\tnex.erase(unique(nex.begin(), nex.end()), nex.end());\n\t\t\tv = nex;\n\t\t}\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tres = max(res, (int)v[i].a[5]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND;\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v)\n{\t\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = 0;\n\tfor (auto &table : T){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < table.size(); i++){\n\t\t\tv[i] -= table[i];\n\t\t\tif (v[i] < 0) f = false;\n\t\t}\n\t\tif (f) res = std::max(res, 1 + calc(v));\n\t\tfor (int i = 0; i < table.size(); i++){\n\t\t\tv[i] += table[i];\n\t\t}\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\tprintf(\"%d\\n\", calc(v));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint solve(vi& ms,vi& used,int remain,int index,const vi& prev,vi& cur)\n{\n\tint n=ms.size();\n\t\n\tif(remain==0){\n\t\tvi next;\n\t\treturn 1+solve(ms,used,10,0,cur,next);\n\t}\n\telse{\n\t\tint res=0;\n\t\trepi(i,index,n){\n\t\t\tif(used[i] || ms[i]>remain)\n\t\t\t\tcontinue;\n\t\t\tif(i>0 && ms[i-1]==ms[i] && !used[i-1]) // 1つ前の同じ重さの饅頭を選んでいない\n\t\t\t\tcontinue;\n\t\t\tcur.push_back(ms[i]);\n\t\t\tif(prev>=cur){\n\t\t\t\tused[i]=1;\n\t\t\t\tres=max(res,solve(ms,used,remain-ms[i],i+1,prev,cur));\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t\tcur.pop_back();\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi hist(10);\n\t\trep(i,n){\n\t\t\tint m; scanf(\"%d\",&m);\n\t\t\thist[m]++;\n\t\t}\n\t\t\n\t\tint res=0;\n\t\trepi(i,1,5)\n\t\t\twhile(hist[i] && hist[10-i]){\n\t\t\t\tres++;\n\t\t\t\thist[i]--;\n\t\t\t\thist[10-i]--;\n\t\t\t}\n\t\twhile(hist[5]>=2){\n\t\t\tres++;\n\t\t\thist[5]-=2;\n\t\t}\n\t\t\n\t\tvi ms;\n\t\tper(i,10)\n\t\t\tms.insert(ms.end(),hist[i],i);\n\t\tvi used(ms.size()),cur;\n\t\tres+=solve(ms,used,10,0,vi(1,10),cur);\n\t\t\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 4;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tull r = s;\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull p = r;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((p >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tp -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tr = p;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10, thr);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[128];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n \n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n            if (j != 10 && j + a[n - 1] > 10)\n                break;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\nint remove_clear()\n{\n    int s[11];\n    CL(s, 0);\n    for (int i = 0; i < n; ++i)\n        ++s[a[i]];\n \n    int res = 0;\n    for (int i = 1; i <= 4; ++i)\n    {\n        int t = min(s[i], s[10 - i]);\n        res += t;\n        s[i] -= t;\n        s[10 - i] -= t;\n    }\n    res += s[5] / 2;\n    s[5] -= s[5] / 2 * 2;\n \n \n    int mini = 10;\n    for (int i = 9; i >= 1; --i)\n        if (s[i] > 0)\n            mini = i;\n \n    n = 0;\n    for (int i = 1; i <= 9 && i + mini <= 10; ++i)\n        while (s[i] > 0)\n            a[n++] = i, --s[i];\n \n    return res;\n}\n\nvoid test()\n{\n    n = 100;\n    for (int i = 0; i < n; ++i)\n        a[i] = rand () % 4 + 1;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n\n        int r = remove_clear();\n \n        sort(a, a + n, greater<int>());\n \n        for (int i = 0; i < n; ++i)\n            memo[i].clear();\n\n        possi_max = accumulate(a, a + n, 0) / 10;\n        res = 0;\n        dfs(0);\n \n        res += r;\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<Manju, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<pair<int, Manju>>Q; Q.push(make_pair(0, T)); M[T] = 1;\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front().second; int L = Q.front().first; Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\n\t\tManju RR = R;\n\t\twhile (true) {\n\t\t\tif (M[RR] != 1) { Q.push(make_pair(L + 1, RR)); M[RR] = 1; }\n\t\t\tbool OK = true;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (S[L].k[j] > RR.k[j])OK = false;\n\t\t\t}\n\t\t\tif (OK == false)break;\n\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[L].k[j];\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p, int sum)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tif (sum < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j < (int)mp[i].size(); j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c, sum - 10));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\n\nvoid make(vector<int> t, int n, int lim)\n{\n\tif (lim == 0 || n == 10){\n\t\tif (!lim){\n\t\t\tmp.push_back(t);\n\t\t\tm[t] = 1;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i * n <= lim; i++){\n\t\tvector<int> tn = t;\n\t\ttn.push_back(i);\n\t\tmake(tn, n + 1, lim - i * n);\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t;\n\t\n\tt.push_back(0);\n\tmake(t, 1, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tint s = 0;\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\ts += i * num[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num, s));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 3;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u = thr){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull r = s;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((r >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tr -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ts = r;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, 10 - k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<vi,int> state;\n\nint n;\nvi a(10);\nmap<state,int> memo;\n\nint rec(vi v,int sum){\n  if(memo.find(state(v,sum))!=memo.end())return memo[state(v,sum)];\n\n  int res = 0;\n  for(int i=8;i>=1;i--){\n    if(v[i]){\n      if(sum+i==10){\n\tv[i]--;\n\tres = max(res,rec(v,0)+1);\n\tv[i]++;\n      }else if(sum+i<10){\n\tv[i]--;\n\tres = max(res,rec(v,sum+i));\n\tv[i]++;\n      }\n    }\n  }\n\n  return memo[state(v,sum)] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<10;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp]++;\n    }\n\n    int res = min(a[1],a[9]); a[1]-=res; a[9]-=res;\n    \n    memo.clear();\n    cout << res+rec(a,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp[43];\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char>nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\nint dfs2(int pos,vector<char> v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 今回の取り方でいくつとるか\n  for(int i=1;i<=1;i++){\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=i*howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(ok)res=max(res,dfs2(pos,nv)+i);\n    else break;\n  }\n  res=max(res,dfs2(pos+1,v));\n  return dp[pos][v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint N, manju[10];\nint rest[4], rest_b;\nchar dp[26*26*26*26][30];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int l, int k, int index){\n    return dp[i+j*(rest[0]+1)+k*(rest[0]+rest[1]+2)+l*(rest[0]+rest[1]+rest[2]+3)][index];\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 10){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(!(rest_b >> i & 1) && at(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d\\n\", a, b, c, d, index);\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        // printf(\"%d: %d, %d, %d, %d | %d, %d, %d, %d | %d\\n\",\n        //       index, a, b, c, d, at(index, 0), at(index, 1), at(index, 2), at(index, 3), rest_b);\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5){continue;}\n                if(manju[i] > 0){rest[n] = i; rest_b |= 1 << i; n += 1;}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(at2(5) == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0; id = 1;\n    }\n    if(dp.count(vec)) return dp[vec];\n\n    int add = 0;\n    for(int i=id; i<=9; i++) {\n        if(vec[i] > 0 && sum + vec[i] <= 10) {\n            vec[i]--; sum += i;\n            chmax(add, solve(vec, sum, i));\n            vec[i]++; sum -= i;\n        }\n    }\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\n\tif(nowmax[num] > ko)\n\t\treturn nowmax[num];\n\tif(num > 10){\n//\t\tif(nowmax[num] < ko)\n//\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n/*\tif(!find(flag,flag+N,true)){\n\t\tif(nowmax[num] < ko)\n\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n*/\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n/*\t\t\tif(nowmax[num] > ko){\n\t\t\t\tans = max(ans,nowmax[num]);\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n;\nmap<vi, int> dp;\nint rec(vi &v, int sum, int pos){\n\tif(sum == 0 && pos == 0 && dp.count(v)) return dp[v];\n\tif(pos == 9) return sum == 10;\n\t\n\tint res = rec(v, sum, pos + 1);\n\tfor(int i = 1; i <= v[pos] && sum + (pos + 1) * i <= 10; i++){\n\t\tv[pos] -= i;\n\t\tres = max(res, rec(v, sum + (pos + 1) * i, pos + 1));\n\t\tv[pos] += i;\n\t}\n\tif(sum == 0 && pos == 0) dp[v] = res;\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tdp.clear();\n\t\tvi v(9);\n\t\tint ans = 0;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t - 1]++;\n\t\t}\n\t\trep(i, 4){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tans += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tans += v[4] / 2;\n\t\tv[4] %= 2;\n\t\tcout << ans + rec(v, 0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nmap<wolf,int> dp;\nint solve(wolf a){\n\tif((int)(dp.count(a)))return dp[a];\n\tint ret=0;\n\tfor(int i=0;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint ans;\nset<vector<int> > ss;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    if(ss.find(v) != ss.end()) return;\n    ss.insert(v);\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i+i<=10;i++){\n        int j = 10 - i;\n        vector<int> v2 = v;\n        if(v2[i] > 0){\n            v2[i]--;\n            if(v2[j] > 0){\n                v2[j]--;\n                f = true;\n                dfs(v2,cnt+1);\n            }\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 2 && v[1] >= 7){\n        v[2] -= 2;\n        v[1] -= 7;\n        dfs(v,cnt+1);\n        return;\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        dfs(v,cnt+1);\n        return;\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        ss.clear();\n        vector<int> v(10,0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\n\nint dfs(int cnt,int sum,vector<int> remain){\n\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n\n  int maxcost = cnt;\n  REP(i,1,10){\n    if( remain[i] == 0 ) continue;\n    int nsum = sum + i;\n    if( nsum >  10 ) continue;\n    remain[i]--;\n    if( nsum == 10 ) {\n      maxcost = max(maxcost,dfs(cnt+1,0,remain));\n    } else {\n      maxcost = max(maxcost,dfs(cnt,nsum,remain));\n    }\n    remain[i]++;\n  }\n  return maxcost;  \n}\n\n\nint main() {\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n      if( input )limit++;\n    }\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, dp[11][11], pre[11][11];\nint countManju[11];\n\nsigned main() {\n    while(cin >> N, N) {\n        fill(countManju, countManju + 11, 0);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        while(1) {\n            fill(dp[0], dp[11], INF);\n            fill(pre[0], pre[11], -1);\n            dp[0][0] = 0;\n\n            for(int i=1; i<=9; i++) {\n                for(int j=0; j<=10; j++) {\n                    for(int k=0; k<=countManju[i]; k++) {\n                        int nj = j + k * i;\n                        if(nj > 10) continue;\n\n                        if(dp[i][nj] > dp[i-1][j] + k) {\n                            dp [i][nj] = dp[i-1][j] + k;\n                            pre[i][nj] = j;\n                        }\n                    }\n                }\n            }\n\n            if(dp[9][10] == INF) break;\n            ans++;\n            int idx = 10;\n            for(int i=9; i>=1; i--) {\n                int nidx = pre[i][idx];\n                int num = (idx - nidx) / i;\n                countManju[i] -= num;\n                idx = nidx;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int P[]={-1,9901,9907,9923,9929,9931,9941,9949,9967,9973}; // primes\n\nmap<int,int> dp[11][11];\nint dfs(int i,int sum,int *a){\n\tint h=0;\n\tfor(int j=1;j<10;j++) h+=a[j]*P[j];\n\tif(dp[i][sum].count(h)>0) return dp[i][sum][h];\n\n\tif(sum==10){\n\t\treturn dp[i][sum][h]=1+dfs(1,0,a);\n\t}\n\tif(i>=10) return dp[i][sum][h]=0;\n\n\tint res=dfs(i+1,sum,a);\n\tif(a[i]>0 && sum+i<=10){\n\t\ta[i]--;\n\t\tres=max(res,dfs(i,sum+i,a));\n\t\ta[i]++;\n\t}\n\treturn dp[i][sum][h]=res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\t\ta[9]=0; // 9 ツつェツ単ツ禿?づ?残ツづ?づ?づ?使ツつ「ツ督ケツつェツづ按つ「\n\n\t\trep(i,11) rep(j,11) dp[i][j].clear();\n\t\tprintf(\"%d\\n\",sum+dfs(1,0,a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko, int lim)\t// 合計, 10個出来た個数, 残り\n{\n\n\tif(nowmax[lim] > ko)\n\t\treturn nowmax[lim];\n\tif(num > 10){\n\t\tif(nowmax[lim] < ko)\n\t\t\tnowmax[lim] = ko;\n\t\treturn nowmax[lim];\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t\tif(nowmax[lim] < ko)\n\t\t\tnowmax[lim] = ko;\n\t}\n\tif(lim == N){\n\t\tif(nowmax[lim] < ko)\n\t\t\tnowmax[lim] = ko;\n\t\treturn nowmax[lim];\n\t}\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i] && num + manto[i] <= 10){\n\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko, lim+1));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tnowmax[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 9; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  buns = prev;\n  res = max(res,dfs(buns,sum,comb_i + 1,all_combinations));\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\nset<vector<int> > mm;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( mm.count(s) ) return;\n\t\n\tif( foo < 100000 ){\n\t\tmm.insert(s);\n\t}\n\t\n\tfoo++;\n\tif( 4000000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tmm.clear();\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n// すでに訪れた状態をメモ\nset<vector<int> > mm;\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\n\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\t// すでに訪れたまんじゅうの状態なら探索打ち切り\n\tif( mm.count(s) ) return;\n\tmm.insert(s);\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tmm.clear();\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND(1145141919);\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\t\n\t\tint t = 0;\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\twhile (v[i] > 0 && v[10 - i] > 0){\n\t\t\t\tt++;\n\t\t\t\tv[i]--;\n\t\t\t\tv[10 - i]--;\n\t\t\t}\n\t\t}\n\t\tt += v[5] / 2;\n\t\tv[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", t + calc(v));\n\t\t//dp.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[11],da[42][11],h,v,n;\n\nint list(int n,int k,int g) {\n\tint i; \n\tif (k==10 && n==h) { for (i=0;i<h;i++) da[v][a[i]]++; v++; }\n\tif (n==h || k>=10) return 1;\n\tfor (i=g;i<10;i++) { a[n]=i; list(n+1,k+i,i);}\n\treturn 0;\n}\n\n\nint main() {\n\tint i,j,an;\n\tv=0;\n\tfor (i=0;i<40;i++) for (j=0;j<11;j++) da[i][j]=0;\n\tfor (i=2;i<11;i++) { h=i; list(0,0,1); }\n\twhile(cin >> n && n>0) {\n\t\tfor (i=0;i<12;i++) a[i]=0;\n\t\tfor (i=0;i<n;i++) { cin >> j; a[j]++; }\n\t\tv=0; an=0;\n\t\twhile(v<41) {\n\t\t\twhile(true) {\n\t\t\t\th=0;\n\t\t\t\tfor (i=1;i<11;i++) if (da[v][i]>a[i]) { h=1; break;}\n\t\t\t\tif (h==1) break;\n\t\t\t\tan++; for (i=1;i<11;i++) a[i]=a[i]-da[v][i];\n\t\t\t} \n\t\t   v++;\n\t\t   }\n\t   cout << an << endl;\n   }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tshort k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<pair<int, Manju>, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(int pos, Manju T) {\n\tif (pos == S.size())return 0;\n\tif (M[make_pair(pos, T)] != 0)return M[make_pair(pos, T)];\n\tint maxn = 0, cnt = 0; Manju U = T;\n\twhile (true) {\n\t\tmaxn = max(maxn, manju(pos + 1, U) + cnt);\n\t\tfor (int i = 0; i < 10; i++) { U.k[i] -= S[pos].k[i]; }\n\t\tbool flag = true; for (int i = 0; i < 10; i++) { if (U.k[i] < 0)flag = false; }\n\t\tif (flag == false)break;\n\t\tcnt++;\n\t}\n\tM[make_pair(pos, T)] = maxn;\n\treturn  maxn;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tfor (int i = 1; i < 5; i++) { int WW = min(A.k[10 - i], A.k[i]); A.k[10 - i] -= WW; A.k[i] -= WW; adv += WW; }\n\t\tadv += A.k[5] / 2; A.k[5] %= 2;\n\t\tcout << manju(0, A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n    dp.clear();\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(const int kind,int wgt,const map<char,char> &v){\n  if(kind==0){\n    map<char,char> nv=v;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nvoid dfs2(const int pos,const map<char,char> &v,int cnt,int &maxVal,int preLast){\n  if(pos==(int)howToGet.size())return;\n  if(preLast/10+cnt<=maxVal)return;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  int sz=0;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0\n       ||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else{\n      nv[it->first]-=it->second;\n      sz+=it->second;\n    }\n  }\n  // 1セット取れるならとる\n  if(ok){\n    maxVal=max(maxVal,cnt+1);\n    dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n  }\n  // 取らずに次のセットへ\n  dfs2(pos+1,v,cnt,maxVal,preLast);\n}\n\nvoid greedy(int &maxVal,map<char,char> v){\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    while(1){\n      bool ok=true;\n      for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n\tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n\t  ok=false;\n\t  break;\n\t}\n      }\n      if(ok){\n\tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n\t  v[it->first]-=it->second;\n\tmaxVal++;\n      }\n      else\n\tbreak;\n    }\n  }\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    lim=0;\n    map<char,char> cnts;\n    int preLast=0;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++){\n      cnts[MS[i]]++;\n      preLast+=MS[i];\n    }\n    for(int i=0;i<43;i++)dp[i].clear();\n    int maxVal=0;\n    greedy(maxVal,cnts);\n    dfs2(0,cnts,0,maxVal,preLast);\n    cout<<maxVal<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> Pr;\n\nint n;\nint v[10];\n\nvector<vector<Pr> > pat;\nvoid makepat(int i = 1, int x = 10, vector<Pr> vec = vector<Pr>()){\n\tif (x == 0) pat.push_back(vec);\n\tif (i > x) return;\n\tfor (; i <= 9; i++){\n\t\tif (v[i] <= 0) continue;\n\t\tif (i <= x){\n\t\t\tif (vec.size() && vec.back().first == i) vec.back().second++;\n\t\t\telse vec.push_back(Pr(i, 1));\n\t\t\tv[i]--;\n\t\t\tmakepat(i, x - i, vec);\n\t\t\tv[i]++;\n\t\t\tif (--vec.back().second == 0) vec.pop_back();\n\t\t}\n\t}\n}\n\nmap<vector<int>, int> dp;\nint calc(int pos){\n\tvector<int> st;\n\tfor (int i = 1; i <= 9; i++){\n\t\tst.push_back(v[i]);\n\t}\n\tif (dp.count(st)) return dp[st];\n\tif (pos == pat.size()) return 0;\n\t\n\tint res = 0;\n\tfor (; pos < pat.size(); pos++){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < pat[pos].size(); i++){\n\t\t\tPr &p = pat[pos][i];\n\t\t\tv[p.first] -= p.second;\n\t\t\tif (v[p.first] <= 0) f = false;\n\t\t}\n\t\tif (f){\n\t\t\tres = max(res, 1 + calc(pos));\n\t\t}\n\t\tfor (int i = 0; i < pat[pos].size(); i++){\n\t\t\tPr &p = pat[pos][i];\n\t\t\tv[p.first] += p.second;\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint res = 0;\n\tfor (int i = 1; i <= 4; i++){\n\t\tif (v[i] > 0 && v[10 - i] > 0){\n\t\t\tres++;\n\t\t\tv[i]--;\n\t\t\tv[10 - i]--;\n\t\t}\n\t}\n\twhile (v[5] >= 2){\n\t\tres++;\n\t\tv[5] -= 2;\n\t}\n\t\n\tpat.clear();\n\tmakepat();\n\tdp.clear();\n\tprintf(\"%d\\n\", res + calc(0));\n}\n\nint main()\n{\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint m;\n\t\t\tscanf(\"%d\", &m);\n\t\t\tv[m]++;\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint dfs(int i,int sum,int *a){\n\tif(sum==10){\n\t\treturn 1+dfs(0,0,a);\n\t}\n\tif(i>10) return 0;\n\n\tint res=dfs(i+1,sum,a);\n\tif(a[i]>0 && sum+a[i]<=10){\n\t\ta[i]--;\n\t\tres=max(res,dfs(i,sum+i,a));\n\t\ta[i]++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[11]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum+dfs(0,0,a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef pair< char, char > Pi; // 2個\ntypedef pair< Pi, Pi > Pii; // 4個\ntypedef pair< Pii, Pii > Piii; // 8個\ntypedef pair< Piii, int > Piiii; // 9個\n \nint n;\nvector< char > barabara(10);\nmap< Piiii, char > dp;\n \n \nvector< vector< char > > mask;\n \nchar manzyu(vector< char >& mans)\n{\n  if(dp.find(Piiii(Piii(Pii( Pi(mans[1], mans[2]), Pi(mans[3], mans[4])), Pii(Pi(mans[5], mans[6]), Pi(mans[7], mans[8]))), mans[9])) != dp.end()) return(dp[Piiii(Piii(Pii( Pi(mans[1], mans[2]), Pi(mans[3], mans[4])), Pii(Pi(mans[5], mans[6]), Pi(mans[7], mans[8]))), mans[9])]);\n  char ret = 0;\n  for(int i = 0; i < mask.size(); i++) {\n    if(mans[1] >= mask[i][1] && mans[2] >= mask[i][2] && mans[3] >= mask[i][3] && mans[4] >= mask[i][4] && mans[5] >= mask[i][5] && mans[6] >= mask[i][6] && mans[7] >= mask[i][7] && mans[8] >= mask[i][8] && mans[9] >= mask[i][9]) {\n      for(int j = 1; j < 10; j++) {\n        mans[j] -= mask[i][j];\n      }\n      ret = max(ret, (char)(manzyu(mans) + 1));\n      for(int j = 1; j < 10; j++) {\n        mans[j] += mask[i][j];\n      }\n    }\n  }\n  return(dp[Piiii(Piii(Pii( Pi(mans[1], mans[2]), Pi(mans[3], mans[4])), Pii(Pi(mans[5], mans[6]), Pi(mans[7], mans[8]))), mans[9])] = ret);\n}\n \n \n \nvoid isten(vector< char >& ret, int digit, int sum) {\n  if(digit <= 0 || sum > 10) {\n    return;\n  } else if(sum == 10) {\n    mask.push_back(ret);\n    return;\n  } else {\n    isten(ret, digit - 1, sum);\n    ret[digit]++;\n    isten(ret, digit, sum + digit);\n    ret[digit]--;\n  }\n}\n \nint main() {\n  vector< char > buff(10, 0);\n  isten(buff, 9, 0);\n \n  while(cin >> n, n) {\n    for(int i = 1; i < 10; i++) barabara[i] = 0;\n    dp.clear();\n    for(int i = 0; i < n; i++) {\n      int m;\n      cin >> m;\n      barabara[m]++;\n    }\n \n    int prad = 0;\n    for(int i = 1; i <= 4; i++) {\n      int cost = min(barabara[i], barabara[10 - i]);\n      prad += cost;\n      barabara[i] -= cost;\n      barabara[10 - i] -= cost;\n    }\n    prad += barabara[5] / 2;\n    barabara[5] -= barabara[5] / 2 * 2;\n     \n    cout << (int)manzyu(barabara) + prad << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(int i, vector<int> v)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tif (i == T.size()) return 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tres = max(res, j + dfs(i + 1, v));\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nvector<VV(pii)> vp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int y,int t1,int t2){\n\t// ull aa=hash();\n\t// if(ma.count(aa)) return ma[aa];\n\t// if(y<2) return ma[aa]=0;\n\tif(y<2) return 0;\n\tint ret=0;\n\treep(j,t2,vp[t1].size()){\n\t\trep(k,vp[t1][j].size()){\n\t\t\ta[vp[t1][j][k].F]-=vp[t1][j][k].S;\n\t\t}\n\t\tbool f=true;\n\t\trep(k,10){\n\t\t\tif(a[k]<0) f=false;\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t}\n\t\trep(k,vp[t1][j].size()){\n\t\t\ta[vp[t1][j][k].F]+=vp[t1][j][k].S;\n\t\t}\n\t}\n\treep(i,t1+1,11){\n\t\trep(j,vp[i].size()){\n\t\t\trep(k,vp[i][j].size()){\n\t\t\t\ta[vp[i][j][k].F]-=vp[i][j][k].S;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\trep(k,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t}\n\t\t\trep(k,vp[i][j].size()){\n\t\t\t\ta[vp[i][j][k].F]+=vp[i][j][k].S;\n\t\t\t}\n\t\t}\n\t}\n\t// return ma[aa]=ret;\n\treturn ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tvp=vector<VV(pii)>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\trep(i,vv.size()){\n\t\tVV(pii) tmp;\n\t\trep(j,vv[i].size()){\n\t\t\tint t1=vv[i][j][0];\n\t\t\tint t2=0;\n\t\t\tvector<pii> vpii;\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\tif(t1==vv[i][j][k]){\n\t\t\t\t\tt2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvpii.PB(pii(t1,t2));\n\t\t\t\t\tt1=vv[i][j][k];\n\t\t\t\t\tt2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvpii.PB(pii(t1,t2));\n\t\t\ttmp.PB(vpii);\n\t\t}\n\t\tvp[i]=tmp;\n\t}\n\t// rep(i,vp.size()){\n\t\t// cout<<endl;\n\t\t// cout<<\"i \"<<i<<endl;\n\t\t// rep(j,vp[i].size()){\n\t\t\t// cout<<\" j \"<<j<<endl;\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// cout<<\"  \"<<vp[i][j][k].F<<\" \"<<vp[i][j][k].S<<endl;\n\t\t\t// }\n\t\t// }\n\t// }\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n,2,0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nconst int N = 10;\nmap<vector<int>, int> memo;\n\nvector<vector<int>> listup(int start, int sum, vector<int> list) {\n    vector<vector<int>> result;\n    if(sum == 0) {\n        result.push_back(list);\n        return result;\n    }\n    for(int i = start; i < N; ++i) {\n        if(sum < i) continue;\n        list.push_back(i);\n        vector<vector<int>> add = listup(i, sum - i, list);\n        result.insert(result.begin(), add.begin(), add.end());\n        list.pop_back();\n    }\n    return result;\n}\n\nint dfs(const vector<vector<int>>& list, vector<int> count, int start) {\n    if(memo.count(count)) return memo[count];\n    int result = 0;\n    for(int i = start; i < list.size(); ++i) {\n        bool ok = true;\n        for(const auto& v: list[i]) ok &= 0 <= --count[v];\n        if(ok) result = max(result, 1 + dfs(list, count, i));\n        for(const auto& v: list[i]) ++count[v];\n    }\n    return memo[count] = result;\n}\n\nint main() {\n    vector<vector<int>> list = listup(1, N, vector<int>());\n\n    int n;\n    while(cin >> n, n) {\n        vector<int> manju(n);\n        for(auto& v: manju) cin >> v;\n\n        vector<int> count(11);\n        for(const auto& v: manju) ++count[v];\n\n        int answer = 0;\n\n        for(int i = 1; i < 5; ++i) while(count[i] && count[10 - i]) {\n            --count[i];\n            --count[10 - i];\n            ++answer;\n        }\n        while(count[5] > 2) {\n            count[5] -= 2;\n            ++answer;\n        }\n\n        memo.clear();\n\n        cout << answer + dfs(list, count, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap< pair<int,vector<int> >, int > dp;\nvector< vector<int> > e;\nint dfs(int pos,vector<int> v){\n\tif( pos >= e.size() ) return 0;\n\tif( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n\tvector<int> V = v;\n\tint ans = 0 , c = 0;\n\twhile(1){\n\t\tans = max( dfs(pos+1,v) + c , ans);\n\t\t\n\t\tc++;\n\t\tfor(int i = 0 ; i < v.size() ; i++)\n\t\t\tv[i] -= e[pos][i];\n\t\t\n\t\tbool f = true;\n\t\tfor(int i = 0 ; i < v.size() ; i++)\n\t\t\tif( v[i] < 0 ) f = false;\n\t\tif( !f ) break;\n\t}\n\treturn dp[make_pair(pos,V)] = ans;\n}\n\n\nvector<int> bt;\nvoid gen_pattern(int pos,int r){\n\tif( pos >= 10 ){\n\t\tif( r == 0 ){\n\t\t\te.push_back( bt );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; r - pos * i >= 0 ; i++){\n\t\tbt[pos] = i;\n\t\tgen_pattern(pos+1,r - pos*i);\n\t}\n}\n\nint main(){\n\tint n;\n\tbt.resize(10);\n\tgen_pattern(1,10);\n\twhile(cin >> n && n){\n\t\tvector<int> v(10);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t]++;\n\t\t}\n\t\tint greedy = 0;\n\t\tfor(int i = 1 ; i < 5 ; i++){\n\t\t\tint u = min(v[i],v[10-i]);\n\t\t\tgreedy += u;\n\t\t\tv[i] -= u; \n\t\t\tv[10-i] -= u;\n\t\t}\n\t\tdp.clear();\n\t\tgreedy += v[5] / 2;\n\t\tv[5] %= 2;\n\t\tcout << dfs(0,v)+greedy << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\nvector<vector<int> > LOOP;\n\nint dfs(int cur,int cnt,vector<int> &remain){\n\n  if( cur >= limit ) {\n    return cnt;\n  }\n\n  vector<int> tmp = remain;\n  bool update = true;\n  int ret = cnt;\n  while( update ){\n    ret = max(ret,dfs(cur+1,cnt,remain));\n    cnt++;\n    REP(i,1,10) {\n      remain[i] -= LOOP[cur][i];\n      if( remain[i] < 0 ) {\n        update = false;\n        break;\n      }\n    }\n  }\n  remain = tmp;\n  return ret;\n}\n\nvoid precalc(int value,int sum,vector<int> &vec) {\n  if( value >= 10 ) {\n    if( sum == 10 ) LOOP.push_back(vec);\n    return;\n  }\n  rep(i,11){\n    if( sum + i * value > 10 ) break;\n    vec[value] = i;\n    precalc(value+1,sum+i*value,vec);\n    vec[value] = 0;\n  }\n  return;\n}\n\nint main() {\n\n  vector<int> buf(10,0);\n  precalc(1,0,buf);\n  sort(LOOP.begin(),LOOP.end());\n\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= 2*tmp;\n    limit = LOOP.size();\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 6000000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;\nset<vector<int> > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(table.count(tmp))return 0;\n    table.insert(tmp);\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint f[5];\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\t\n\tvector<int> t(10, 0);\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 2;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u = thr){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull r = s;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((r >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tr -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ts = r;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, 10 - k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint dfs(int i,int sum,int *a){\n\tif(sum==10){\n\t\treturn 1+dfs(0,0,a);\n\t}\n\tif(i>10) return 0;\n\n\tint res=dfs(i+1,sum,a);\n\tif(a[i]>0 && sum+a[i]<=10){\n\t\ta[i]--;\n\t\tres=max(res,dfs(i,sum+i,a));\n\t\ta[i]++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[11]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\t// int sum=0;\n\t\t// for(int i=1;i<5;i++){\n\t\t\t// int c=min(a[i],a[10-i]);\n\t\t\t// sum+=c;\n\t\t\t// a[i]-=c;\n\t\t\t// a[10-i]-=c;\n\t\t// }\n\t\t// { // i==5\n\t\t\t// sum+=a[5]/2;\n\t\t\t// a[5]%=2;\n\t\t// }\n\n\t\tprintf(\"%d\\n\",dfs(0,0,a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nconst int N = 10;\nmap<vector<int>, int> memo;\n\nvector<vector<int>> listup(int start, int sum, vector<int> list) {\n    vector<vector<int>> result;\n    if(sum == 0) {\n        result.push_back(list);\n        return result;\n    }\n    for(int i = start; i < N; ++i) {\n        if(sum < i) continue;\n        list.push_back(i);\n        vector<vector<int>> add = listup(i, sum - i, list);\n        result.insert(result.begin(), add.begin(), add.end());\n        list.pop_back();\n    }\n    return result;\n}\n\nint dfs(const vector<vector<int>>& list, vector<int> count, int start) {\n    if(memo.count(count)) return memo[count];\n    int result = 0;\n    for(int i = start; i < list.size(); ++i) {\n        bool ok = true;\n        for(const auto& v: list[i]) ok &= 0 <= --count[v];\n        if(ok) result = max(result, 1 + dfs(list, count, i));\n        for(const auto& v: list[i]) ++count[v];\n    }\n    return memo[count] = result;\n}\n\nint main() {\n    vector<vector<int>> list = listup(1, N, vector<int>());\n\n    int n;\n    while(cin >> n, n) {\n        vector<int> manju(n);\n        for(auto& v: manju) cin >> v;\n\n        vector<int> count(11);\n        for(const auto& v: manju) ++count[v];\n\n        memo.clear();\n\n        cout << dfs(list, count, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint t[10];\n\nint solve(int s = 10, int k = 9, int z = 999){\n\tint c = 0;\n\n\twhile( k && c < z ){\n\t\tint a;\n\t\tif( k != s - k ){\ta = min( t[k], t[s - k] );\t}\n\t\telse{\ta = t[k] / 2;\t}\n\t\tif( c + a >= z ){\n\t\t\tt[k] -= z - c;\n\t\t\tt[s - k] -= z - c;\n\t\t\treturn z;\n\t\t}\n\n\t\tc += a;\n\t\tt[k] -= a;\n\t\tt[s - k] -= a;\n\t\t\n\t\twhile( t[k] > 0 && c < z ){\n\t\t\t--t[k];\n\t\t\tc += solve( s - k, min(k, s - k - 1), 1);\n\t\t}\n\t\t\n\t\tif( c == z ) return z;\n\t\t\n\t\t--k;\n\t}\n\treturn c;\n}\n\nint main(){\n\tint n, m;\n\tfor( ; scanf(\"%d\", &n), n; ){\n\t\tfill(t, t + 10, 0);\n\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf(\"%d\", &m);\n\t\t\t++t[m];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve() );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n// int N;\n// int MS[101];\n// vector<map<char,char> > howToGet;\n// map<map<char,char>,char> dp[43];\n// void dfs(const int kind,int wgt,map<char,char> v){\n//   if(kind==0){\n//     map<char,char> nv=v;\n//     dfs(kind+1,wgt,nv);\n//   }\n//   else if(wgt==0)howToGet.push_back(v);\n//   else if(kind==10)return;\n//   else{\n//     for(int i=0;i*kind<=10;i++){\n//       if(wgt-i*kind>=0){\n// \tmap<char,char> nv=v;\n// \tif(i>=1)nv[kind]=i;\n// \tdfs(kind+1,wgt-i*kind,nv);\n//       }\n//     }\n//   }\n// }\n\n// void dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n//   if(pos==(int)howToGet.size())return;\n//   if(preLast/10+cnt<=maxVal)return;\n//   // 1セット分取れるか\n//   map<char,char> nv=v;\n//   bool ok=true;\n//   int sz=0;\n//   for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n//     if(nv.count(it->first)==0\n//        ||nv[it->first]-(it->second)<0){\n//       ok=false;\n//       break;\n//     }\n//     else{\n//       nv[it->first]-=it->second;\n//       sz+=it->second;\n//     }\n//   }\n//   // 1セット取れるならとる\n//   if(ok){\n//     maxVal=max(maxVal,cnt+1);\n//     dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n//   }\n//   // 取らずに次のセットへ\n//   dfs2(pos+1,v,cnt,maxVal,preLast);\n// }\n\n// void greedy(int &maxVal,map<char,char> v){\n//   for(int pos=0;pos<(int)howToGet.size();pos++){\n//     while(1){\n//       bool ok=true;\n//       for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n// \tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n// \t  ok=false;\n// \t  break;\n// \t}\n//       }\n//       if(ok){\n// \tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n// \t  v[it->first]-=it->second;\n// \tmaxVal++;\n//       }\n//       else\n// \tbreak;\n//     }\n//   }\n// }\n\n// int main(){\n//   dfs(0,10,map<char,char>());\n//   while(cin>>N&&N){\n//     map<char,char> cnts;\n//     int preLast=0;\n//     for(int i=0;i<N;i++)cin>>MS[i];\n//     for(int i=0;i<N;i++){\n//       cnts[MS[i]]++;\n//       preLast+=MS[i];\n//     }\n//     for(int i=0;i<43;i++)dp[i].clear();\n//     int maxVal=0;\n//     greedy(maxVal,cnts);\n//     // cout<<maxVal<<endl;\n//     // dfs2(0,cnts,0,maxVal,preLast);\n//     cout<<maxVal<<endl;\n//   }\n//   return 0;\n// }\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    dp.clear();\n    int a=min(cnts[9],cnts[1]);\n    cnts[9]-=a;\n    cnts[1]-=a;\n    int res=dfs2(cnts)+a;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned char uchar;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nvector<ull> data;\n\nvoid make(ull mask, int rem, int p)\n{\n    if(rem == 0){\n        data.push_back(mask);\n        return;\n    }\n    \n    if(p >= 2){\n        make(mask, rem, p-1);\n    }\n    if(p <= rem){\n        reinterpret_cast<uchar*>(&mask)[p-1]++;\n        make(mask, rem-p, p);\n    }\n}\n\nbool ok(ull a, ull b)\n{\n    uchar* p = reinterpret_cast<uchar*>(&a);\n    uchar* q = reinterpret_cast<uchar*>(&b);\n    \n    rep(i, 8){\n        if(p[i] < q[i]) return false;\n    }\n    \n    return true;\n}\n\nunordered_map<ull, int> memo;\nint func(ull mask)\n{\n    if(memo.count(mask)) return memo[mask];\n    \n    int ans = 0;\n    for(ull d : data){\n        if(ok(mask, d)){\n            ans = max(ans, func(mask - d) + 1);\n        }\n    }\n    \n    return memo[mask] = ans;\n}\n\nvoid func(int n)\n{\n    int hist[10] = {};\n    rep(i, n){\n        int a;\n        cin >> a;\n        hist[a]++;\n    }\n    \n    int ans = hist[5] / 2;\n    hist[5] %= 2;\n    reps(i, 1, 5){\n        int v = min(hist[i], hist[10-i]);\n        ans += v;\n        hist[i] -= v;\n        hist[10-i] -= v;\n    }\n    \n    ull mask = 0;\n    rep(i, 8){\n        reinterpret_cast<uchar*>(&mask)[i] = hist[i+1];\n    }\n    ans += func(mask);\n    \n    cout << ans << endl;\n}\n\n\nint main()\n{\n    make(0, 10, 8);\n    \n    int n;\n    while(cin >> n, n){\n        func(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> a;\nint ret;\nvoid solve(vector<int>& select, int n)\n{\n    int sum = accumulate(select.begin(), select.end(), 0);\n    if(select.size() == n){\n        if(sum < 10)\n            return;\n\n        vector<int> b(10, 0);\n        for(int i=0; i<n; ++i)\n            ++ b[select[i]];\n        for(int i=0; i<10; ++i){\n            if(b[i] > a[i])\n                return;\n        }\n\n        for(int i=0; i<10; ++i)\n            a[i] -= b[i];\n        ++ ret;\n        return;\n    }\n\n    for(int i=(select.size()==0? 1:select.back()); i<=9; ++i){\n        if(sum + (n - select.size()) * i > 10)\n            break;\n        select.push_back(i);\n        solve(select, n);\n        select.pop_back();\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        a.assign(10, 0);\n        for(int i=0; i<n; ++i){\n            int x;\n            cin >> x;\n            ++ a[x];\n        }\n\n        ret = 0;\n        vector<int> select;\n        for(int i=1; i<=9; ++i)\n            solve(select, i);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\ntypedef unsigned long long ull;\nmap<ull,int> ma;\nvector<VV(pii)> vp;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\null bb=1145148931919;\null hash(){\n\tull ret=0;\n\trep(i,10){\n\t\tret*=bb;\n\t\tret+=a[i];\n\t}\n\treturn ret;\n}\nint dfs(int y,int t1,int t2){\n\tull aa=hash();\n\tif(ma.count(aa)) return ma[aa];\n\tif(y<2) return ma[aa]=0;\n\t// if(y<2) return 0;\n\tint ret=0;\n\treep(j,t2,vp[t1].size()){\n\t\trep(k,vp[t1][j].size()){\n\t\t\ta[vp[t1][j][k].F]-=vp[t1][j][k].S;\n\t\t}\n\t\tbool f=true;\n\t\treep(k,1,10){\n\t\t\tif(a[k]<0) f=false;\n\t\t}\n\t\tif(f){\n\t\t\tret=max(ret,dfs(y-t1,t1,j)+1);\n\t\t}\n\t\trep(k,vp[t1][j].size()){\n\t\t\ta[vp[t1][j][k].F]+=vp[t1][j][k].S;\n\t\t}\n\t}\n\treep(i,t1+1,11){\n\t\trep(j,vp[i].size()){\n\t\t\trep(k,vp[i][j].size()){\n\t\t\t\ta[vp[i][j][k].F]-=vp[i][j][k].S;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\treep(k,1,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i,i,j)+1);\n\t\t\t}\n\t\t\trep(k,vp[i][j].size()){\n\t\t\t\ta[vp[i][j][k].F]+=vp[i][j][k].S;\n\t\t\t}\n\t\t}\n\t}\n\treturn ma[aa]=ret;\n\t// return ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tvp=vector<VV(pii)>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\trep(i,vv.size()){\n\t\tVV(pii) tmp;\n\t\trep(j,vv[i].size()){\n\t\t\tint t1=vv[i][j][0];\n\t\t\tint t2=0;\n\t\t\tvector<pii> vpii;\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\tif(t1==vv[i][j][k]){\n\t\t\t\t\tt2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvpii.PB(pii(t1,t2));\n\t\t\t\t\tt1=vv[i][j][k];\n\t\t\t\t\tt2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvpii.PB(pii(t1,t2));\n\t\t\ttmp.PB(vpii);\n\t\t}\n\t\tvp[i]=tmp;\n\t}\n\t// rep(i,vp.size()){\n\t\t// cout<<endl;\n\t\t// cout<<\"i \"<<i<<endl;\n\t\t// rep(j,vp[i].size()){\n\t\t\t// cout<<\" j \"<<j<<endl;\n\t\t\t// rep(k,vp[i][j].size()){\n\t\t\t\t// cout<<\"  \"<<vp[i][j][k].F<<\" \"<<vp[i][j][k].S<<endl;\n\t\t\t// }\n\t\t// }\n\t// }\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n,2,0);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND;\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> &v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", calc(v));\n\t\tdp.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n\nint ans = 0;\nint C = 0; \nint dfs(int pos,long long v){\n    if( pos >= e.size() ) return 0;\n\tans = max( ans , C );\n    int c = 0;\n    while(1){\n\t\tC += c;\n        dfs(pos+1,v);\n\t\tC -= c;\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n}\n  \n  \n \n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n\tfor(int i = 0 ; i < e.size() ; i++){\n\t\t//view(e[i]);\n\t}\n    while(cin >> n && n){\n\t\trandom_shuffle(e.begin(),e.end());\n        vector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n\t\tans = 0;\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n\t\tdfs(0,enc);\n        cout << ans+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(int kind,int wgt,const map<char,char> &v){\n  if(kind==0){\n    map<char,char> nv=v;\n    //nv[0]=0;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const map<char,char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else nv[it->first]-=it->second;\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  return dp[pos][v]=res;\n  // if(lim<1000000){\n  //   lim++;\n  //   return dp[pos][v]=res;\n  // }\n  // else return res;\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    lim=0;\n    map<char,char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint t[10];\n\nint solve(int s = 10, int k = 9, int z = 999){\n\tint c = 0;\n\n\twhile( k && c < z ){\n\t\tint a;\n\t\tif( k != s - k ){\ta = min( t[k], t[s - k] );\t}\n\t\telse{\ta = t[k] / 2;\t}\n\n\t\tif( c + a >= z ){\n\t\t\tt[k] -= z - c;\n\t\t\tt[s - k] -= z - c;\n\t\t\treturn z;\n\t\t}\n\n\t\tc += a;\n\t\tt[k] -= a;\n\t\tt[s - k] -= a;\n\t\t\n\t\twhile( t[k] > 0 && c < z ){\n\t\t\t--t[k];\n\t\t\tif( solve( s - k, min(k, s - k), 1) ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++t[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( c == z ){\n\t\t\treturn z;\n\t\t}\n\t\t\n\t\tif( s == 10 ) t[k] = 0;\n\t\t--k;\n\t}\n\n\treturn c;\n}\n\nint main(){\n\tint n, m;\n\tfor( ; scanf(\"%d\", &n), n; ){\n\t\tfill(t, t + 10, 0);\n\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf(\"%d\", &m);\n\t\t\t++t[m];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve() );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n    buns = prev;\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 10; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> diff(const vector<int>& a, const vector<int>& b)\n{\n    vector<int> res(10);\n    for (int i = 1; i <= 9; i++) {\n        res[i] = a[i] - b[i];\n    }\n    return res;\n}\n\nbool check_diff(const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 1; i <= 9; i++) {\n        if (a[i] < b[i]) return 0;\n    }\n    return 1;\n}\n\nmap<vector<int>, int> mem;\nconst vector<int> pat[] = {\n    {0, 0, 1, 1, 0, 1, 0, 0, 0, 0},    \n    {0, 0, 2, 0, 0, 0, 1, 0, 0, 0},\n    {0, 0, 2, 2, 0, 0, 0, 0, 0, 0},\n    {0, 0, 3, 0, 1, 0, 0, 0, 0, 0},\n    {0, 0, 5, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 2, 1, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 2, 0, 0, 0, 0},\n    {0, 1, 1, 0, 0, 0, 0, 1, 0, 0},\n    {0, 1, 0, 1, 0, 0, 1, 0, 0, 0},\n    {0, 1, 0, 0, 1, 1, 0, 0, 0, 0},\n    {0, 1, 1, 1, 1, 0, 0, 0, 0, 0},    \n    {0, 2, 0, 0, 0, 0, 0, 0, 1, 0},\n    {0, 2, 1, 0, 0, 0, 1, 0, 0, 0},\n    {0, 2, 0, 1, 0, 1, 0, 0, 0, 0},\n    {0, 2, 0, 0, 2, 0, 0, 0, 0, 0},\n    {0, 2, 2, 0, 1, 0, 0, 0, 0, 0},\n    {0, 2, 1, 2, 0, 0, 0, 0, 0, 0},\n    {0, 2, 4, 0, 0, 0, 0, 0, 0, 0},    \n    {0, 3, 0, 0, 0, 0, 0, 1, 0, 0},\n    {0, 3, 1, 0, 0, 1, 0, 0, 0, 0},\n    {0, 3, 0, 1, 1, 0, 0, 0, 0, 0},\n    {0, 3, 2, 1, 0, 0, 0, 0, 0, 0},    \n    {0, 4, 0, 0, 0, 0, 1, 0, 0, 0},\n    {0, 4, 1, 0, 1, 0, 0, 0, 0, 0},\n    {0, 4, 0, 2, 0, 0, 0, 0, 0, 0},\n    {0, 4, 3, 0, 0, 0, 0, 0, 0, 0},    \n    {0, 5, 0, 0, 0, 1, 0, 0, 0, 0},\n    {0, 5, 1, 1, 0, 0, 0, 0, 0, 0},    \n    {0, 6, 0, 0, 1, 0, 0, 0, 0, 0},\n    {0, 6, 2, 0, 0, 0, 0, 0, 0, 0},\n    {0, 7, 0, 1, 0, 0, 0, 0, 0, 0},\n    {0, 8, 1, 0, 0, 0, 0, 0, 0, 0},\n    {0, 10, 0, 0, 0, 0, 0, 0, 0, 0}\n};\n\nint solve(const vector<int>& m_cnt)\n{\n    int res = 0;\n    if (mem.count(m_cnt) != 0) {\n        return mem[m_cnt];\n    }\n\n    for (const auto& p : pat) {\n        if (check_diff(m_cnt, p)) {\n            res = max(res, solve(diff(m_cnt, p)) + 1);\n        }\n    }\n    return mem[m_cnt] = res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N > 0) {\n        vector<int> m_cnt(10);\n        for (int i = 0; i < N; i++) {\n            int m;\n            cin >> m;\n            m_cnt[m]++;\n        }\n\n        int res = 0;\n        for (int i = 1; i <= 5; i++) {\n            int mini = min(m_cnt[i], m_cnt[10 - i]); \n            if (i == 5) mini /= 2;\n            res += mini;\n            m_cnt[i] -= mini;\n            m_cnt[10 - i] -= mini;\n        }\n        mem.clear();\n        res += solve(m_cnt);\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 3;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tull r = s;\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull p = r;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((p >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tp -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tr = p;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10, thr);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\nvector<int> c;\n\nint getMax(vector<int> p, int sum)\n{\n\tint a;\n\tif (m.count(p) != 0){\n\t\treturn (m[p]);\n\t}\n\t\n\tif (sum < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tc = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c, sum - 10));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tint s = 0;\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\ts += i * num[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num, s));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tshort k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<pair<int, Manju>, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(int pos, Manju T) {\n\tif (pos == S.size())return 0;\n\tif (M[make_pair(pos, T)] != 0)return M[make_pair(pos, T)];\n\tint maxn = 0, cnt = 0; Manju U = T;\n\twhile (true) {\n\t\tmaxn = max(maxn, manju(pos + 1, U) + cnt);\n\t\tfor (int i = 0; i < 10; i++) { U.k[i] -= S[pos].k[i]; }\n\t\tbool flag = true; for (int i = 0; i < 10; i++) { if (U.k[i] < 0)flag = false; }\n\t\tif (flag == false)break;\n\t\tcnt++;\n\t}\n\tM[make_pair(pos, T)] = maxn;\n\treturn  maxn;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tfor (int i = 1; i < 5; i++) { int WW = min(A.k[10 - i], A.k[i]); A.k[10 - i] -= WW; A.k[i] -= WW; adv += WW; }\n\t\tadv += A.k[5] / 2; A.k[5] %= 2;\n\t\tcout << manju(0, A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool check(const vector<vector<pair<int, int>>>&humans, int x, int y) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto it=find(humans[i].begin(),humans[i].end(),make_pair(x,y));\n\t\tif(it!=humans[i].end())return false;\n\t}\n\treturn true;\n}\nint dx[] = { -1,0,1,0,0 };\nint dy[] = { 0,1,0,-1,0 };\n\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\nstruct sale {\n\tint id;\n\tint d;\n\tint s;\n\tint e;\n};\n\nstruct aa {\n\tint flag;\n\tint x;\n\tint y;\n\tint cost;\n};\n\nbool operator <(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]>r[i])return false;\n\t}\n\treturn false;\n}\nint solve(vector<int>haves, vector<int>nums) {\n\tmap<pair<vector<int>,int>,int>mp;\n\tmp[make_pair(nums,0)]=1;\n\n\tint ans=1;\n\tqueue<pair<vector<int>,int>>que;\n\tque.push(make_pair(nums,0));\n\twhile (!que.empty()) {\n\t\tauto atop(que.front());\n\t\tque.pop();\n\n\t\tint x=atop.second;\n\t\tvector<int>v(atop.first);\n\n\t\tint cost=mp[make_pair(atop.first,atop.second)];\n\t\tans=max(ans,cost);\n\t\tfor (int i = 0; i < haves.size(); ++i) {\n\t\t\tif (v[i]){\n\t\t\t\tif (x+haves[i] >= 11) {\n\n\t\t\t\t}\n\t\t\t\telse if (x + haves[i] == 10) {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,0);\n\t\t\t\t\tif (mp[np] < cost + 1) {\n\t\t\t\t\t\tmp[np]=cost+1;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,x+haves[i]);\n\t\t\t\t\tif (mp[np] < cost) {\n\t\t\t\t\t\tmp[np]=cost;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans-1;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint N;cin>>N;\n\t\tif(N==0)break;\n\t\tvector<int>vs(10);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a;cin>>a;\n\t\t\tvs[a]++;\n\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 6; i <= 9; ++i) {\n\t\t\tint x=min(vs[i],vs[10-i]);\n\t\t\tvs[i]-=x;\n\t\t\tvs[10-i]-=x;\n\t\t\tans+=x;\n\t\t}\n\t\t{\n\t\t\tint x=vs[5]/2;\n\t\t\tvs[5]-=2*x;\n\t\t\tans+=x;\n\t\t}\n\t\tvector<int>haves;\n\t\tvector<int>nums;\n\t\tfor (int i = 1; i <= 9; ++i) {\n\t\t\tif (vs[i]) {\n\t\t\t\thaves.push_back(i);\n\t\t\t\tnums.push_back(vs[i]);\n\t\t\t}\n\t\t}\n\t\tans+=solve(haves,nums);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND;\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\nhash_t getHash(const std::vector<int> v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v)\n{\t\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = 0;\n\tfor (auto &table : T){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < table.size(); i++){\n\t\t\tv[i] -= table[i];\n\t\t\tif (v[i] < 0) f = false;\n\t\t}\n\t\tif (f) res = std::max(res, 1 + calc(v));\n\t\tfor (int i = 0; i < table.size(); i++){\n\t\t\tv[i] += table[i];\n\t\t}\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\tprintf(\"%d\\n\", calc(v));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct s {\n\tint a[6];\n\ts() {\n\t\tfor(int i = 0; i < 6; i++)\n\t\t\ta[i] = 0;\n\t}\n\tbool operator==(const s & obj) const {\n\t\tbool res = true;\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tres &= a[i] == obj.a[i];\n\t\t}\n\t\treturn res;\n\t}\n\tbool operator<(const s & obj) const {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(a[i] < obj.a[i])\n\t\t\t\treturn true;\n\t\t\telse if(a[i] > obj.a[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<s> v;\n\t\tv.push_back(s());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint m;\n\t\t\tvector<s> nex;\n\t\t\tcin >> m;\n\t\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\t\tfor(int j = 0; j + m <= 10; j++) {\n\t\t\t\t\ts p = v[i];\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t\t;\n\t\t\t\t\telse if(j <= 5) {\n\t\t\t\t\t\tif(p.a[j-1] <= 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tp.a[j-1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(p.a[10-j-1] >= 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tp.a[10-j-1]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(j+m <= 5) {\n\t\t\t\t\t\tp.a[j+m-1]++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j+m < 10) {\n\t\t\t\t\t\tp.a[10-(j+m)-1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.a[5]++;\n\t\t\t\t\t}\n//\t\t\t\t\tcout << j + m << endl;\n\t\t\t\t\tnex.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(nex.begin(), nex.end());\n\t\t\tnex.erase(unique(nex.begin(), nex.end()), nex.end());\n\t\t\tv = nex;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tres = max(res, v[i].a[5]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp[43];\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const vector<char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  vector<char> nv=v;\n  bool ok=true;\n  for(int j=1;j<(int)howToGet[pos].size();j++){\n    nv[j]-=howToGet[pos][j];\n    if(nv[j]<0){\n      ok=false;\n      break;\n    }\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  return dp[pos][v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n \nmap< pair<int,long long>, int>  dp;\nvector< long long > e;\n \t\n//int dp[51][51][51][51][2];\n \nvoid gen_pattern(int pos,int r,long long v){\n\tif( pos >= 10 ){\n\t\tif( r == 0 ){\n\t\t\te.push_back( v );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; r - pos * i >= 0 ; i++){\n\t\tgen_pattern(pos+1,r - pos*i,v+((long long)(i)<<(pos*6)));\n\t}\n}\n \nint view(long long v){\n\tfor(int i = 0 ; i < 10 ; i++){\n\t\tcout << (v >> (6*i) & 63) <<\" \";\n\t}\n\tcout << endl;\n}\n\nint dfs(int pos,long long v){\n\tif( pos >= e.size() ) return 0;\n\tif( dp.count(make_pair(pos,v)) ) return dp[make_pair(pos,v)];\n\tlong long V = v;\n\tint ans = 0 , c = 0;\n\twhile(1){\n\t\tans = max( dfs(pos+1,v) + c , ans);\n\t\tc++;\n\t\tbool f = true;\n\t\tfor(int i = 1 ; i < 10 ; i++){\n\t\t\tint s = v >> (6 * i) & 63;\n\t\t\tint x = e[pos] >> (6*i) & 63;\n\t\t\tif( s < x ){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !f ) break;\n\t\tv -= e[pos];\n\t}\n\tv = V;\n\treturn dp[make_pair(pos,V)] = ans;\n}\n \n \n\nint main(){\n\tint n;\n\tgen_pattern(1,10,0);\n\twhile(cin >> n && n){\n\t\tvector<char> v(10);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tv[t]++;\n\t\t}\n\t\tint greedy = 0;\n\t\tfor(int i = 1 ; i < 5 ; i++){\n\t\t\tint u = min(v[i],v[10-i]);\n\t\t\tgreedy += u;\n\t\t\tv[i] -= u; \n\t\t\tv[10-i] -= u;\n\t\t}\n\t\tdp.clear();\n\t\tgreedy += v[5] / 2;\n\t\tv[5] %= 2;\n\t\tlong long enc = 0;\n\t\tfor(int i = 1 ; i < 10 ; i++){\n\t\t\tenc += (long long)(v[i]) << (6 * i);\n\t\t}\n\t\tcout << dfs(0,enc)+greedy << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint greedy;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\treturn (m[0] + 2*m[1] + 3*m[2] + 4*m[3] + 5*m[4] + 6*m[5] + 7*m[6] + 8*m[7] + 9*m[8]) / 10;\n}\n\nbool solve(int m[], int pre, int step, bool bgreedy)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\n\tif (!bgreedy) {\n\t\tif (step + ideal(m) <= greedy) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\t\tbool ret = false;\n\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tif ( bgreedy ){\n\t\t\t\tif ( solve(m, i, step + 1, bgreedy) ) {\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsolve(m, i, step + 1, bgreedy);\n\t\t\t}\n\t\t\t\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tif (ret) return true;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < (int)s.size(); ++i){\n\t\t\tif ( s[i].size() == sz ){\n\t\t\t\tfor (int j = 0; j < (int)s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = greedy = 0;\n\t\tsolve(m, 0, 0, true);\n\t\tgreedy = res;\n\t\tres = 0;\n\t\tsolve(m, 0, 0, false);\n\n\t\tif (res < greedy){\n\t\t\tres = greedy;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n\n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\n\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < 100; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nmap<ull,int> memo;\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\tif(k <= 1){ return 0; }\n\n\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\tint res = max(a, b);\n\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\nvector<int> c;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tc = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int thr = 4;\n\nmap<ull,int> memo;\n\nvector<ull> tbl;\n\nvoid maketbl(ull s, int t, int u = thr){\n\tif(t == 0){\n\t\ttbl.push_back(s);\n\t}\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tmaketbl(s + (1ull << ((u - 1) * 8)), t - u, u);\n\t}\n}\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint res = 0;\n\tif(k <= thr){\n\t\tfor(size_t i = 0; i < tbl.size(); ){\n\t\t\tull r = s;\n\t\t\tbool ok = true;\n\t\t\tfor(int j = thr; j >= 1; --j){\n\t\t\t\tif((r >> ((j - 1) * 8) & 0xff) >= (tbl[i] >> ((j - 1) * 8) & 0xff)){\n\t\t\t\t\tr -= tbl[i] & (0xffull << ((j - 1) * 8));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ts = r;\n\t\t\t\t++res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, 10 - k);\n\t\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\t\tres = max(a, b);\n\t}\n\t\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tmaketbl(0, 10);\n\tsort(tbl.begin(), tbl.end(), greater<ull>());\n\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\tif(No == 9)\n\t\t\t\t\tmanto[10]++;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tcout << manto[10] << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\ntypedef pair<int, int> P;\nmap< vector<int>, int > memo;\nvector<deque<P>> opes;\nvoid dfs(int k, int sum, deque<P>& ope){\n    if(k == 9){\n        if(sum == 10) opes.push_back(ope);\n    }else{\n        dfs(k + 1, sum, ope);\n        for(int i = 1; sum + (k + 1) * i <= 10; i++){\n            ope.push_back(P(k + 1, i));\n            dfs(k + 1, sum + (k + 1) * i, ope);\n            ope.pop_back();\n        }\n    }\n}\nint calc(vector<int> cnt){\n    if(memo.count(cnt)) return memo[cnt];\n    int ans = 0;\n    for(auto ope : opes){\n        int bad = -1;\n        for(auto p : ope){\n            cnt[p.first - 1] -= p.second;\n            if(cnt[p.first - 1] < 0){\n                bad = p.first;\n                break;\n            }\n        }\n        if(bad == -1){\n            ans = max(ans, 1 + calc(cnt));\n        }\n        for(auto p : ope){\n            cnt[p.first - 1] += p.second;\n            if(p.first == bad) break;\n        }\n    }\n    return memo[cnt] = ans;\n}\nvoid init(){\n    deque<P> deq;\n    dfs(0, 0, deq);\n}\n\nint main(){\n    init();\n    int N;\n    while(cin >> N && N){\n        vector<int> init(9, 0);\n        REP(i, N) {\n            int t; cin >> t;\n            init[t - 1] ++;\n        }\n        cout << calc(init) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n\n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\n\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < n; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint N, manju[10];\nint rest[4], rest_b;\nchar dp[26*26*26*26][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int l, int k, int index){\n    return dp[i+j*(rest[0]+1)+k*(rest[0]+rest[1]+2)+l*(rest[0]+rest[1]+rest[2]+3)][index];\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 10){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(!(rest_b >> i & 1) && at(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d\\n\", a, b, c, d, index);\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        // printf(\"%d: %d, %d, %d, %d | %d, %d, %d, %d | %d\\n\",\n        //       index, a, b, c, d, at(index, 0), at(index, 1), at(index, 2), at(index, 3), rest_b);\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5){continue;}\n                if(manju[i] > 0){rest[n] = i; rest_b |= 1 << i; n += 1;}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(at2(5) == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND(1145141919);\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\t\n\t\tint t = 0;\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\twhile (v[i] > 0 && v[10 - i] > 0){\n\t\t\t\tt++;\n\t\t\t\tv[i]--;\n\t\t\t\tv[10 - i]--;\n\t\t\t}\n\t\t}\n\t\tt += v[5] / 2;\n\t\tv[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", t + calc(v));\n\t\tdp.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint t[10];\n\nint solve(int s = 10, int k = 9, int z = 999){\n\tint c = 0;\n\n\twhile( k && c < z ){\n\t\tint a;\n\t\tif( k != s - k ){\ta = min( t[k], t[s - k] );\t}\n\t\telse{\ta = t[k] / 2;\t}\n\n\t\tif( c + a >= z ){\n\t\t\tt[k] -= z - c;\n\t\t\tt[s - k] -= z - c;\n\t\t\treturn z;\n\t\t}\n\n\t\tc += a;\n\t\tt[k] -= a;\n\t\tt[s - k] -= a;\n\t\t\n\t\twhile( t[k] > 0 && c < z ){\n\t\t\t--t[k];\n\t\t\tif( solve( s - k, min(k, s - k - 1), 1) ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++t[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( c == z ){\n\t\t\treturn z;\n\t\t}\n\t\t\n\t\t--k;\n\t}\n\n\treturn c;\n}\n\nint main(){\n\tint n, m;\n\tfor( ; scanf(\"%d\", &n), n; ){\n\t\tfill(t, t + 10, 0);\n\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf(\"%d\", &m);\n\t\t\t++t[m];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve() );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 9; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  buns = prev;\n  res = max(res,dfs(buns,sum,comb_i + 1,all_combinations));\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n    dp.clear();\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> a;\n\n\t\tmap<int, int> m;\n\t\trep(i,n){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tm[x]++;\n\t\t}\n\n\t\tint ans = 0;\n\t\trange(i,1,5){\n\t\t\tint tmp = min(m[i], m[10 - i]);\n\t\t\tans += tmp;\n\t\t\tm[i]-=tmp;\n\t\t\tm[10 - i]-=tmp;\n\t\t}\n\t\tans += m[5] / 2;\n\t\tm[5] %= 2;\n\n\t\tfor(auto i : m){\n\t\t\trep(j,i.second){\n\t\t\t\ta.emplace_back(i.first);\n\t\t\t}\n\t\t}\n\n\t\tsort(all(a),greater<int>());\n\n\n\n\t\tvector<bool> used(a.size(),0); //?????§????¢???°????????????????????????\n\t\trep(i,a.size() - 1){ //????????????????????????????????£???10 - a[i]???????????????\n\t\t\tif(used[i]) continue;\n\t\t\tint need = 10 - a[i];\n\n\t\t\tint pre[15];\n\t\t\tmemset(pre, -1, sizeof(pre));\n\t\t\tbool dp[15] = {0};\n\t\t\tdp[0] = 1;\n\t\t\trange(j,i + 1,a.size()){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tfor(int k = need; k >= 0; k--){\n\t\t\t\t\tif(k + a[j] > 10) continue;\n\t\t\t\t\tif(pre[k + a[j]] != -1) continue;\n\t\t\t\t\tdp[k + a[j]] |= dp[k];\n\t\t\t\t\t//cout << j + 1 << ' ' << k + a[j] << endl;\n\t\t\t\t\tif(dp[k]) pre[k + a[j]] = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(dp[need]){\n\t\t\t\tans++;\n\t\t\t\tint cur = need;\n\t\t\t\twhile(cur != 0){\n\t\t\t\t\tint p = pre[cur];\n\t\t\t\t\tcur = cur - a[p];\n\t\t\t\t\tused[p] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;\nset<vector<int> > table;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n){\n    if(table.count(tmp))return 0;\n    if(n == tens.size())return 0;\n    int res = dfs(n + 1);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n) + 1, res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    table.insert(tmp);\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\twhile(table.size())table.erase(table.begin());\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n// int N;\n// int MS[101];\n// vector<map<char,char> > howToGet;\n// map<map<char,char>,char> dp[43];\n// void dfs(const int kind,int wgt,map<char,char> v){\n//   if(kind==0){\n//     map<char,char> nv=v;\n//     dfs(kind+1,wgt,nv);\n//   }\n//   else if(wgt==0)howToGet.push_back(v);\n//   else if(kind==10)return;\n//   else{\n//     for(int i=0;i*kind<=10;i++){\n//       if(wgt-i*kind>=0){\n// \tmap<char,char> nv=v;\n// \tif(i>=1)nv[kind]=i;\n// \tdfs(kind+1,wgt-i*kind,nv);\n//       }\n//     }\n//   }\n// }\n\n// void dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n//   if(pos==(int)howToGet.size())return;\n//   if(preLast/10+cnt<=maxVal)return;\n//   // 1セット分取れるか\n//   map<char,char> nv=v;\n//   bool ok=true;\n//   int sz=0;\n//   for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n//     if(nv.count(it->first)==0\n//        ||nv[it->first]-(it->second)<0){\n//       ok=false;\n//       break;\n//     }\n//     else{\n//       nv[it->first]-=it->second;\n//       sz+=it->second;\n//     }\n//   }\n//   // 1セット取れるならとる\n//   if(ok){\n//     maxVal=max(maxVal,cnt+1);\n//     dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n//   }\n//   // 取らずに次のセットへ\n//   dfs2(pos+1,v,cnt,maxVal,preLast);\n// }\n\n// void greedy(int &maxVal,map<char,char> v){\n//   for(int pos=0;pos<(int)howToGet.size();pos++){\n//     while(1){\n//       bool ok=true;\n//       for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n// \tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n// \t  ok=false;\n// \t  break;\n// \t}\n//       }\n//       if(ok){\n// \tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n// \t  v[it->first]-=it->second;\n// \tmaxVal++;\n//       }\n//       else\n// \tbreak;\n//     }\n//   }\n// }\n\n// int main(){\n//   dfs(0,10,map<char,char>());\n//   while(cin>>N&&N){\n//     map<char,char> cnts;\n//     int preLast=0;\n//     for(int i=0;i<N;i++)cin>>MS[i];\n//     for(int i=0;i<N;i++){\n//       cnts[MS[i]]++;\n//       preLast+=MS[i];\n//     }\n//     for(int i=0;i<43;i++)dp[i].clear();\n//     int maxVal=0;\n//     greedy(maxVal,cnts);\n//     // cout<<maxVal<<endl;\n//     // dfs2(0,cnts,0,maxVal,preLast);\n//     cout<<maxVal<<endl;\n//   }\n//   return 0;\n// }\n\nint N;\nint MS[101];\nint lim;\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  //if(pos==(int)howToGet.size())return 0;\n  if(dp.count(v)>0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n      }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    lim=0;\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    dp.clear();\n    int res=dfs2(cnts);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\nint ans;\nvoid dfs(int d,int sum,int *a,int c, int rem) {\n  if (c+rem/10<ans) return;\n  ans = max(ans, c);\n  if (sum==10) dfs(1,0,a,c+1,rem);\n  else {\n    if (d<9)dfs(d+1,sum,a,c,rem);\n    if (a[d]&&sum+d<=10) {\n      a[d]--;\n      dfs(d,sum+d,a,c,rem-d);\n      a[d]++;\n    }\n  }\n}\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int a[10]={};\n    REP(i,n) {\n      int b;cin>>b;\n      a[b]++;\n    }\n    int t = 0;\n    for (int i=1; i<=4; ++i) {\n      int m = min(a[i], a[10-i]);\n      a[i] -= m;\n      a[10-i] -= m;\n      t += m;\n    }\n    t += a[5] / 2;\n    a[5] %= 2;\n    int rem = 0;\n    REP(i,10) rem+=a[i]*i;\n    ans = 0;\n    dfs(1,0,a,0,rem);\n    cout << t+ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n#define char int\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    int sum=0;\n    for(int i=1;i<=4;i++){\n      int a=min(cnts[i],cnts[10-i]);\n      cnts[i]-=a;cnts[10-i]-=a;\n      sum+=a;\n    }\n    int a=cnts[5]/2;\n    cnts[5]-=2*a;\n    sum+=a;\n    int res=dfs2(cnts)+sum;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre){\n\tif (x == 0) a.push_back(d);\n\tfor (int i = pre; i >= 1; --i){\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint parts[NPAT][9];\n\nint ideal(int m[]){\n\tint ret = 0;\n\tfor (int i = 0; i < 9; ++i){\n\t\tret += m[i];\n\t}\n\treturn ret/10;\n}\n\nvoid solve(int m[], int pre, int step){\n\t/*\n\tcout << step << \" : \";\n\tfor (int i = 0; i < 9; ++i){\n\t\tcout << m[i] << ' ';\n\t}\n\tcout << endl;\n\t*/\n\t// cout << step << endl;\n\n\tif (step + ideal(m) < res) {\n\t\treturn;\n\t}\n\n\tif (res < step) {\n\t\tres = step;\n\t}\n\n\tfor (int i = pre; i < NPAT; ++i){\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < 9; ++j){\n\t\t\tif (m[j] < parts[i][j]){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok){\n\t\t\tfor (int j = 0; j < 9; ++j){\n\t\t\t\tm[j] -= parts[i][j];\n\t\t\t}\n\t\t\tsolve(m, i, step + 1);\n\t\t\tfor (int j = 0; j < 9; ++j){\n\t\t\t\tm[j] += parts[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor (int i = 0; i < s.size(); ++i){\n\t\tfor (int j = 0; j < s[i].size(); ++j) {\n\t\t\tparts[i][s[i][j] - 1]++;\n\t\t}\n\t}\n/*\n\tfor (int i = 0; i < NPAT; ++i){\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tcout << parts[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\n*/\n\twhile (true){\n\t\tint n;\n\t\tint m[9] = { 0, };\n\t\t\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tsolve(m,0,0);\n\n\t\tcout << res << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1000000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\tif(No == 9)\n\t\t\t\t\tmanto[10]++;\n\t\t\t\telse\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\n\tif(No == 9 && x < manto[10])\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tcout << manto[10] << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 500000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<vector<int> > sum10;\nvector<int> as;\n\nvoid dfs(vector<int> v, int now, int sum) {\n  if (sum == 10) {\n    sum10.push_back(v);\n    return;\n  }\n  if (now == as.size()) return;\n  dfs(v,now+1,sum);\n  if (sum + as[now] <= 10) {\n    v.push_back(now);\n    dfs(v,now,sum+as[now]);\n  }\n}\n\nmap<vector<int> , int> mp[50];\n\nint solve(int now, vector<int> v) {\n  if (now == sum10.size()) return 0;\n  if (mp[now].count(v)) return mp[now][v];\n\n  int a;\n  int &r = a;\n  if (now<sum10.size()-2) r = mp[now][v];\n  int res = 0;\n  REP(i,100) {\n    bool dame = 0;\n    res = max(res, solve(now+1, v) + i);\n    FOR(it, sum10[now]) {\n      if (v[*it]-- == 0) dame = 1;\n    }\n    if(dame) break;\n  }\n  if (now<sum10.size()-2) return r = res;\n  return res;\n}\n\nint a[10];\n\nint main() {\n  // REP(i,9) as.push_back(i+1);\n  // vector<int> t;\n  // dfs(t,0,0);\n  // FOR(it, sum10) {\n  //   FOR(jt, *it) cout << *jt << \" \";\n  //   cout << endl;\n  // }\n  int n;\n  while(cin>>n,n) {\n    int ans = 0;\n    memset(a,0,sizeof(a));\n    REP(i,n) {\n      int b;cin >> b;\n      if (b >= 10) {\n        if (b == 10) ans++;\n      } else {\n        a[b]++;\n      }\n    }\n    for (int i=1; i<=4; ++i) {\n      int j = 10-i;\n      int m = min(a[i], a[j]);\n      a[i] -= m;\n      a[j] -= m;\n      ans += m;\n    }\n    ans += a[5] / 2;\n    a[5] -= a[5]/2*2;\n    vector<int> v;\n    as.clear();\n    REP(i,10) if (a[i]) {\n      as.push_back(i);\n      v.push_back(a[i]);\n    }\n    sum10.clear();\n    vector<int> t;\n    dfs(t,0,0);\n    REP(i,sum10.size()) mp[i].clear();\n    ans += solve(0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "5\n4 9 1 3 8\n10\n8 5 3 6 2 1 4 5 4 5\n9\n5 7 3 8 2 9 6 4 1\n100\n1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1\n2 2 2 2 2 2 2 2 2 2\n2 2 2 2 2 2 2 2 2 2\n3 3 3 3 3 4 4 4 4 4\n3 3 3 3 3 4 4 4 4 4\n5 5 5 5 5 6 6 6 6 6\n7 7 7 7 7 8 8 8 8 8\n9 9 9 9 9 9 9 9 9 9\n0"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int>& buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 9; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  buns = prev;\n  res = max(res,dfs(buns,sum,comb_i + 1,all_combinations));\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight >= 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    vector<int> buns(11);\n    dp.clear();\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 5; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\nvector<vector<int> > LOOP;\n\nint dfs(int cur,int cnt,vector<int> &remain){\n\n  if( cur >= limit ) {\n    return cnt;\n  }\n\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n\n  vector<int> tmp = remain;\n  bool update = true;\n  int ret = cnt;\n  while( update ){\n    ret = max(ret,dfs(cur+1,cnt,remain));\n    cnt++;\n    REP(i,1,10) {\n      remain[i] -= LOOP[cur][i];\n      if( remain[i] < 0 ) {\n        update = false;\n        break;\n      }\n    }\n  }\n  remain = tmp;\n  return memo[remain] = ret;\n}\n\nvoid precalc(int value,int sum,vector<int> &vec) {\n  if( value >= 10 ) {\n    if( sum == 10 ) LOOP.push_back(vec);\n    return;\n  }\n  rep(i,11){\n    if( sum + i * value > 10 ) break;\n    vec[value] = i;\n    precalc(value+1,sum+i*value,vec);\n    vec[value] = 0;\n  }\n  return;\n}\n\nint main() {\n\n  vector<int> buf(10,0);\n  precalc(1,0,buf);\n  sort(LOOP.begin(),LOOP.end());\n\n  while( scanf(\"%d\",&n), n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      scanf(\"%d\",&input);\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= 2*tmp;\n    limit = LOOP.size();\n\n    printf(\"%d\\n\",coef + dfs(0,0,remain));\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int P[]={-1,999853,999863,999883,999907,999917,999931,999953,999959,999961}; // primes\n\nmap<int,int> dp[11][11];\nint dfs(int i,int sum,int *a){\n\tint h=0;\n\tfor(int j=1;j<10;j++) h+=a[j]*P[j];\n\tif(dp[i][sum].count(h)>0) return dp[i][sum][h];\n\n\tif(sum==10){\n\t\treturn dp[i][sum][h]=1+dfs(1,0,a);\n\t}\n\tif(i>=10) return dp[i][sum][h]=0;\n\n\tint res=dfs(i+1,sum,a);\n\tif(a[i]>0 && sum+i<=10){\n\t\ta[i]--;\n\t\tres=max(res,dfs(i,sum+i,a));\n\t\ta[i]++;\n\t}\n\treturn dp[i][sum][h]=res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint a[10]={};\n\t\trep(i,n){\n\t\t\tint b; scanf(\"%d\",&b);\n\t\t\ta[b]++;\n\t\t}\n\n\t\tint sum=0;\n\t\tfor(int i=1;i<5;i++){\n\t\t\tint c=min(a[i],a[10-i]);\n\t\t\tsum+=c;\n\t\t\ta[i]-=c;\n\t\t\ta[10-i]-=c;\n\t\t}\n\t\t{ // i==5\n\t\t\tsum+=a[5]/2;\n\t\t\ta[5]%=2;\n\t\t}\n\t\ta[9]=0; // 9 ツつェツ単ツ禿?づ?残ツづ?づ?づ?使ツつ「ツ督ケツつェツづ按つ「\n\n\t\trep(i,11) rep(j,11) dp[i][j].clear();\n\t\tprintf(\"%d\\n\",sum+dfs(1,0,a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\n\treturn ret / 10;\n}\n\nbool solve(int m[], int pre, int step)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\t\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\t// solve(m, i, step + 1);\n\t\t\tif (solve(m, i, step + 1)) return true;\n\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\t\t}\n\t}\n\t// cout << (res) << endl;\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < s.size(); ++i){\n\t\t\tif (s[i].size() == sz){\n\t\t\t\tfor (int j = 0; j < s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ( true ) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tsolve(m, 0, 0);\n\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, dp[11][11], pre[11][11];\nint countManju[11];\n\nsigned main() {\n    while(cin >> N, N) {\n        fill(countManju, countManju + 11, 0);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        while(1) {\n            fill(dp[0], dp[11], INF);\n            fill(pre[0], pre[11], -1);\n            dp[0][0] = 0;\n\n            for(int i=1; i<=9; i++) {\n                for(int j=0; j<=10; j++) {\n                    for(int k=0; k<=countManju[i]; k++) {\n                        int nj = j + k * i;\n                        if(nj > 10) continue;\n\n                        if(dp[i][nj] >= dp[i-1][j] + k) {\n                            dp [i][nj] = dp[i-1][j] + k;\n                            pre[i][nj] = j;\n                        }\n                    }\n                }\n            }\n\n            if(dp[9][10] == INF) break;\n            ans++;\n            int idx = 10;\n            for(int i=9; i>=1; i--) {\n                int nidx = pre[i][idx];\n                int num = (idx - nidx) / i;\n                countManju[i] -= num;\n                idx = nidx;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\n\tif(nowmax[num] > ko)\n\t\treturn nowmax[num];\n\tif(num > 10){\n//\t\tif(nowmax[num] < ko)\n//\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n/*\tif(!find(flag,flag+N,true)){\n\t\tif(nowmax[num] < ko)\n\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n*/\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n/*\t\t\tif(nowmax[num] > ko){\n\t\t\t\tans = max(ans,nowmax[num]);\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<vector<int> > howToGet;\nvoid dfs(int kind,int wgt,vector<int> v){\n  if(kind==0){\n    vector<int>nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<int> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\nmap<vector<int>,int> dp[43];\nint dfs2(int pos,vector<int> v){\n  if(pos==(int)howToGet.size())return 0;\n  if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 今回の取り方でいくつとるか\n  for(int i=0;;i++){\n    vector<int> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=i*howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(ok){\n      res=max(res,dfs2(pos+1,nv)+i);\n    }\n    else{\n      break;\n    }\n  }\n  return dp[pos][v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<int>());\n  while(cin>>N&&N){\n    vector<int> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint manju[16];\n\nint solve(int num, int sum) {\n\tif(sum == 10)\n\t\treturn 1;\n\tif(sum > 10)\n\t\treturn 0;\n\n\twhile(num > 0) {\n\t\tbool flg = false;\n\t\tif(manju[num] > 0) {\n\t\t\tint res;\n\t\t\tmanju[num]--;\n\t\t\tres = solve(num, sum+num);\n\t\t\tif(res)\n\t\t\t\treturn 1;\n\t\t\telse {\n\t\t\t\tmanju[num]++;\n\t\t\t\tflg = true;\t\n\t\t\t}\n\t\t}\n//\t\tcout << manju[num] << \",\" << num << \" \";\n\t\tif(manju[num] <= 0 || flg)\n\t\t\tnum--;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tmanju[i] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint tmp; cin >> tmp;\n\t\t\tmanju[tmp]++;\n\t\t}\n\t\tint ans = 0;\n\t\twhile(solve(10,0))\n\t\t\tans++;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\n//map<wolf,int> dp;\nint solve(wolf a,int b){\n//\tif((int)(dp.count(a)))return dp[a];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint m[10];\nvector<vector<int> > pattern;\nvoid rekkyo(int sum,int i){\n\tstatic vector<int> hoge(10);\n\tint res=0;\n\tif(sum==10){\n\t\tpattern.push_back(hoge);\n\t\treturn;\n\t}\n\tif(10<sum || i==10)return;\n\tfor(int j=0;sum+i*j<=10;j++){\n\t\thoge[i]=j;\n\t\trekkyo(sum+i*j,i+1);\n\t}\n\thoge[i]=0;\n\treturn;\n}\nbool ok(int num[10],vector<int> &p,int n){\n\tfor(int i=1;i<10;i++){\n\t\tif(m[i]-num[i] < p[i]*n)return false;\n\t}\n\treturn true;\n}\nint bsearch(int num[10],vector<int> &p){\n\tint l=0,r=50,m;\n\twhile(l<r){\n\t\tm=(l+r)/2+1;\n\t\tif(ok(num,p,m))l=m;\n\t\telse r=m-1;\n\t}\n\treturn r;\n}\nint search(int i,int pushed){\n\tint res=0,tmp;\n\tstatic int num[10];\n\tif(i==pattern.size())return 0;\n\tfor(int j=bsearch(num,pattern[i]) ;0<=j;j--){\n\t\ttmp=0;\n\t\tfor(int k=1;k<10;k++){\n\t\t\ttmp += j*pattern[i][k];\n\t\t\tnum[k] += j*pattern[i][k];\n\t\t}\n\t\tif(res < j+(n-pushed-tmp)/2){\n\t\t\ttmp = j+search(i+1,pushed+tmp);\n\t\t\tres = max(res,tmp);\n\t\t}\n\t\tfor(int k=1;k<10;k++)num[k] -= j*pattern[i][k];\t\t\n\t}\n\treturn res;\n}\nint main(){\n\tint t,ans;\n\trekkyo(0,1);\n\twhile(cin>>n&&n){\n\t\tans=0;\n\t\tfill(m,m+10,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>t;\n\t\t\tm[t]++;\n\t\t}\n\t\tcout<<search(0,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\tif(num > 10)\n\t\treturn ko;\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n\tif(M == 0)\n\t\treturn ko;\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nlong long conv(wolf a){\n\tlong long ret=0;\n\tfor(int i=0;i<9;i++){\n\t\tret*=128;\n\t\tret+=a.t[i];\n\t}\n\treturn ret;\n}\nmap<long long,int> dp;\nint solve(wolf a,int b){\n\tif((int)(dp.count(conv(a))))return dp[conv(a)];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[conv(a)]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\tmanto[10]++;\n\t\t\t\tsum = 0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\n\tif(No == 9 && x < manto[10])\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tcout << manto[10] << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0; id = 1;\n    }\n    if(dp.count(vec)) return dp[vec];\n    if(sum > 10) return 0;\n\n    int add = 0;\n    for(int i=id; i<=9; i++) {\n        if(vec[i] > 0) {\n            vec[i]--; sum += i;\n            chmax(add, solve(vec, sum, i));\n            vec[i]++; sum -= i;\n        }\n    }\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint n;\nvi a(10);\nmap<vi,int> memo;\n\nint rec(vi v){\n  if(memo.find(v)!=memo.end())return memo[v];\n  \n  int res = 0;\n  for(int i=8;i>=1;i--){\n    if(v[i]){\n      if(v[9]+i==10){\n\tv[i]--; v[9] = 0;\n\tres = max(res,rec(v)+1);\n\tv[i]++; v[9] = 10-i;\n      }else if(v[9]+i<10){\n\tv[i]--; v[9] += i;\n\tres = max(res,rec(v));\n\tv[i]++; v[9] -= i;\n      }\n    }\n  }\n\n  return memo[v] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<10;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp]++;\n    }\n\n    int res = min(a[1],a[9]); a[1]-=res; a[9] = 0;\n    \n    memo.clear();\n    cout << res+rec(a) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    static const int M = 95;\n    if (res == possi_max || sack[10] + (n - d) <= res\n        || (d < M && memo[d].count(encode(sack))))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n    if (d < M)\n        memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\n\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < 100; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <ctime>\n#include <sys/time.h>\nusing namespace std;\n\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n\nint ans = 0;\nint C = 0; \nclock_t start,end;\n\nvoid dfs(int pos,long long v){\n\tend = clock();\n\tif( (double)(end - start) / CLOCKS_PER_SEC > 2.0) return; \n    if( pos >= e.size() ) return;\n\tans = max( ans , C );\n    int c = 0;\n    while(1){\n\t\tC += c;\n        dfs(pos+1,v);\n\t\tC -= c;\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n}\n  \n  \n \n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n\tsort(e.rbegin(),e.rend());\n    while(cin >> n && n){\n\t\tvector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n\t\tclock_t start, end;\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n\t\tC = 0;\n\t\tans = 0;\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n\t\tstart = clock();\n\t\tdfs(0,enc);\n        cout << ans+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse{\n\t\t\t\tif(No == 9)\n\t\t\t\t\tmanto[10]++;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tprintf(\"%d\\n\", manto[10]);\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[11],da[43][11],dn[43],h,v,n,f,an,z;\n\nint list(int n,int k,int g) {\n\tint i; \n\tif (k==10 && n==h) { for (i=0;i<h;i++) da[v][a[i]]++; dn[v]=h; v++; }\n\tif (n==h || k>=10) return 1;\n\tfor (i=g;i<10;i++) { a[n]=i; list(n+1,k+i,i);}\n\treturn 0;\n}\n\nint dfs(int g,int u,int t) {\n\tint i,j,k;\n\tif (an<g) an=g;\n\tif (g+t/dn[u]<=an) return 0;\n\tfor (i=u;i<41;i++) {\n\t\tf=0;\n\t\tfor (j=1;j<10;j++) {a[j]-=da[i][j]; if (a[j]<0) { f=1; for (k=j;k>0;k--) a[k]+=da[i][k]; break;}}\n\t\tif (f==0) {dfs(g+1,i,t-dn[i]); for(j=1;j<10;j++) a[j]+=da[i][j];}\n\t\t}\n  return 0;\n}\n\nint main() {\n\tint i,j;\n\tv=0;\n\tfor (i=0;i<40;i++) for (j=0;j<11;j++) da[i][j]=0;\n\tfor (i=2;i<11;i++) { h=i; list(0,0,1); }\n\twhile(cin >> n && n>0) {\n\t\tfor (i=0;i<11;i++) a[i]=0;\n\t\tfor (i=0;i<n;i++) { cin >> j; a[j]++; }\n\t\tv=0; an=0;\n\t\twhile(v<5) {\n\t\t\twhile(true) {\n\t\t\t\tf=0;\n\t\t\t\tfor (i=1;i<10;i++) if (a[i]<da[v][i]) { f=1; break;}\n\t\t\t\tif (f==1) break;\n\t\t\t\tfor (i=1;i<10;i++) a[i]-=da[v][i]; an++; n-=2;\n\t\t\t}\n\t\t\tv++;\n\t\t}\n\t\tdfs(an,5,n);\n\t\tcout << an << endl;\t\n\t    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1000000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[128];\nvoid dfs(int d)\n{\n    if (res == possi_max || sack[10] + (n - d) <= res || memo[d].count(encode(sack)))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n \n    memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\nint remove_clear()\n{\n    int s[11];\n    CL(s, 0);\n    for (int i = 0; i < n; ++i)\n        ++s[a[i]];\n \n    int res = 0;\n    for (int i = 1; i <= 4; ++i)\n    {\n        int t = min(s[i], s[10 - i]);\n        res += t;\n        s[i] -= t;\n        s[10 - i] -= t;\n    }\n    res += s[5] / 2;\n    s[5] -= s[5] / 2 * 2;\n \n \n    int mini = 10;\n    for (int i = 9; i >= 1; --i)\n        if (s[i] > 0)\n            mini = i;\n \n    n = 0;\n    for (int i = 1; i <= 9 && i + mini <= 10; ++i)\n        while (s[i] > 0)\n            a[n++] = i, --s[i];\n \n    return res;\n}\n\nvoid test()\n{\n    n = 100;\n    for (int i = 0; i < n; ++i)\n        a[i] = rand () % 10 + 1;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        int r = remove_clear();\n \n        sort(a, a + n, greater<int>());\n \n        for (int i = 0; i < n; ++i)\n            memo[i].clear();\n\n        possi_max = accumulate(a, a + n, 0) / 10;\n        res = 0;\n        dfs(0);\n \n        res += r;\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0; id = 1;\n    }\n    if(dp.count(vec)) return dp[vec];\n    if(sum > 10) return 0;\n\n    int add = 0;\n    for(int i=id; i<=9; i++) {\n        if(vec[i] > 0 && sum + i <= 10) {\n            vec[i]--; sum += i;\n            chmax(add, solve(vec, sum, i));\n            vec[i]++; sum -= i;\n        }\n    }\n    res += add;\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector< long long > e;\n     \n//int dp[51][51][51][51][2];\n  \nvoid gen_pattern(int pos,int r,long long v){\n    if( pos >= 10 ){\n        if( r == 0 ){\n            e.push_back( v );\n        }\n        return;\n    }\n    for(int i = 0 ; r - pos * i >= 0 ; i++){\n        gen_pattern(pos+1,r - pos*i,v+((long long)(i)<<((pos-1)*7)));\n    }\n}\n  \nint view(long long v){\n\tfor(int i = 0 ; i < 9 ; i++){\n        cout << (v >> (7*i) & 127) <<\" \";\n    }\n    cout << endl;\n}\n\nint ans = 0;\nint C = 0; \nvoid dfs(int pos,long long v){\n    if( pos >= e.size() ) return;\n\tans = max( ans , C );\n    int c = 0;\n    while(1){\n\t\tC += c;\n        dfs(pos+1,v);\n\t\tC -= c;\n        c++;\n        bool f = true;\n        for(int i = 0 ; i < 9 ; i++){\n            int s = v >> (7*i) & 127;\n            int x = e[pos] >> (7*i) & 127;\n            if( s < x ){\n                f = false;\n                break;\n            }\n        }\n        if( !f ) break;\n        v -= e[pos];\n    }\n}\n  \n  \n \n\nint main(){\n    int n;\n    gen_pattern(1,10,0);\n\tsort(e.rbegin(),e.rend());\n    while(cin >> n && n){\n\t\tvector<char> v(10);\n        for(int i = 0 ; i < n ; i++){\n            int t;\n            cin >> t;\n            v[t]++;\n        }\n        int greedy = 0;\n        for(int i = 1 ; i < 5 ; i++){\n            int u = min(v[i],v[10-i]);\n            greedy += u;\n            v[i] -= u; \n            v[10-i] -= u;\n        }\n\t\tC = 0;\n\t\tans = 0;\n        greedy += v[5] / 2;\n        v[5] %= 2;\n        long long enc = 0;\n        for(int i = 1 ; i < 10 ; i++){\n            enc += (long long)(v[i]) << (7 * (i-1));\n        }\n\t\tdfs(0,enc);\n        cout << ans+greedy << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\n\tif(nowmax[num] > ko)\n\t\treturn nowmax[num];\n\tif(num > 10){\n\t\treturn ko;\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i] && num + manto[i] <= 10){\n\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nmap<ull,int> memo;\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s < 10){ return 0; }\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\tif(k == 1){\n\t\treturn s / 10;\n\t}\n\n\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\tint res = max(a, b);\n\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 4; ++i){\n\t\t\tx = min(cnt[i], cnt[10 - i]);\n\t\t\tans += x;\n\t\t\tcnt[i] -= x;\n\t\t\tcnt[10 - i] -= x;\n\t\t}\n\t\t\n\t\tans += cnt[5] / 2;\n\t\tcnt[5] &= 1;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[11],da[43][11],dn[43],h,v,n,f,an,z;\n\nint list(int n,int k,int g) {\n\tint i; \n\tif (k==10 && n==h) { for (i=0;i<h;i++) da[v][a[i]]++; dn[v]=h; v++; }\n\tif (n==h || k>=10) return 1;\n\tfor (i=g;i<10;i++) { a[n]=i; list(n+1,k+i,i);}\n\treturn 0;\n}\n\nint dfs(int g,int u,int t) {\n\tint i,j;\n\tif (an<g)  an=g;\n\tif (g+t/dn[u]<=an) return 0;\n\tfor (i=0;i<41;i++) {\n\t\tf=0;\n\t\tfor (j=1;j<10;j++) if (a[j]<da[i][j]) f=1;\n\t\tif (f==0) { for(j=1;j<10;j++) a[j]=a[j]-da[i][j]; dfs(g+1,i,t-dn[i]); for(j=1;j<10;j++) a[j]=a[j]+da[i][j];}\n\t\t}\n  return 0;\n}\n\nint main() {\n\tint i,j;\n\tv=0;\n\tfor (i=0;i<40;i++) for (j=0;j<11;j++) da[i][j]=0;\n\tfor (i=2;i<11;i++) { h=i; list(0,0,1); }\n\twhile(cin >> n && n>0) {\n\t\tfor (i=0;i<11;i++) a[i]=0;\n\t\tfor (i=0;i<n;i++) { cin >> j; a[j]++; }\n\t\tv=0; an=0;\n\t\tdfs(0,0,n);\n\t\tcout << an << endl;\t\n\t    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju {\n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<pair<int, Manju>, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(int pos, Manju T) {\n\tif (pos == S.size())return 0;\n\tif (M[make_pair(pos, T)] != 0)return M[make_pair(pos, T)];\n\tint maxn = 0, cnt = 0; Manju U = T;\n\twhile (true) {\n\t\tint maxn = max(maxn, manju(pos + 1, U) + cnt);\n\t\tfor (int i = 0; i < 10; i++) { U.k[i] -= S[pos].k[i]; }\n\t\tbool flag = true; for (int i = 0; i < 10; i++) { if (U.k[i] < 0)flag = false; }\n\t\tif (flag == false)break; cnt++;\n\t}\n\tM[make_pair(pos, T)] = maxn;\n\treturn  maxn;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tfor (int i = 1; i < 5; i++) { int WW = min(A.k[10 - i], A.k[i]); A.k[10 - i] -= WW; A.k[i] -= WW; adv += WW; }\n\t\tadv += A.k[5] / 2; A.k[5] %= 2;\n\t\tcout << manju(0, A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint N;\nint MS[101];\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(const int kind,int wgt,map<char,char> v){\n  if(kind==0){\n    map<char,char> nv=v;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nvoid dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n  if(pos==(int)howToGet.size())return;\n  if(preLast/10+cnt<=maxVal)return;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  int sz=0;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0\n       ||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else{\n      nv[it->first]-=it->second;\n      sz+=it->second;\n    }\n  }\n  // 1セット取れるならとる\n  if(ok){\n    maxVal=max(maxVal,cnt+1);\n    dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n  }\n  // 取らずに次のセットへ\n  dfs2(pos+1,v,cnt,maxVal,preLast);\n}\n\nvoid greedy(int &maxVal,map<char,char> v){\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    while(1){\n      bool ok=true;\n      for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n\tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n\t  ok=false;\n\t  break;\n\t}\n      }\n      if(ok){\n\tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n\t  v[it->first]-=it->second;\n\tmaxVal++;\n      }\n      else\n\tbreak;\n    }\n  }\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    map<char,char> cnts;\n    int preLast=0;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++){\n      cnts[MS[i]]++;\n      preLast+=MS[i];\n    }\n    for(int i=0;i<43;i++)dp[i].clear();\n    int maxVal=0;\n    greedy(maxVal,cnts);\n    // cout<<maxVal<<endl;\n    // dfs2(0,cnts,0,maxVal,preLast);\n    cout<<maxVal<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint rest[10];\nvector<vector<int> > pat;\nvector<int> stk;\nint edge[64][64];\nvector<int> greedy;\nbool check[64];\n\nvoid mkpat(int num, int sum) {\n\tif(sum > 10)\n\t\treturn;\n\tif(sum == 10)\n\t\tpat.push_back(stk);\n\n\tfor(int i = num; i; i--) {\n\t\tstk.push_back(i);\n\t\tmkpat(i, sum+i);\n\t\tstk.pop_back();\n\t}\n}\n\nbool comp(const vector<int> & a, const vector<int> & b) {\n\treturn a.size() < b.size();\n}\n\nint main() {\n\tint n;\n\tmkpat(9,0);\n\tsort(pat.begin(), pat.end(), comp);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\trest[i] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint in;\n\t\t\tcin >> in;\n\t\t\trest[in]++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < pat.size(); i++) {\n\t\t\tint flg = true;\n\t\t\twhile(flg) {\n\t\t\t\tint use[10] = {0};\n\t\t\t\tfor(int j = 0; j < pat[i].size(); j++) {\n\t\t\t\t\tuse[pat[i][j]]++;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t\t\tflg &= use[j] <= rest[j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t\t\t\trest[j] -= use[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp;\n\nint dfs(int i, vector<int> v)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tint sum = 0;\n\tfor (int j = 0; j < 9; j++){\n\t\tsum += (j + 1) * v[j];\n\t}\n\tif (sum < 10) return 0;\n\tif (i == T.size()) return 0;\n\tif (dp.count(v)) return dp[v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tres = max(res, j + dfs(i + 1, v));\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t}\n\treturn dp[v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> &p, int sum)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tif (sum < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j < (int)mp[i].size(); j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c, sum - 10));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\n\nvoid make(vector<int> &t, int n, int lim)\n{\n\tif (lim == 0 || n == 10){\n\t\tif (!lim){\n\t\t\tmp.push_back(t);\n\t\t\tm[t] = 1;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i * n <= lim; i++){\n\t\tvector<int> tn = t;\n\t\ttn.push_back(i);\n\t\tmake(tn, n + 1, lim - i * n);\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t;\n\t\n\tt.push_back(0);\n\tmake(t, 1, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tint s = 0;\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\ts += i * num[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num, s));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint num[10];\n\nint getMax(int sum, int u)\n{\n\tint ans;\n\t\n\tif (u == 10){\n\t\treturn (0);\n\t}\n\t\n\tif (sum == 10){\n\t\treturn (1 + getMax(0, u));\n\t}\n\t\n\tans = 0;\n\tfor (int i = u; i <= 9; i++){\n\t\tif (num[i] && sum + i <= 10){\n\t\t\tnum[i]--;\n\t\t\tans = max(ans, getMax(sum + i, u));\n\t\t\tnum[i]++;\n\t\t}\n\t}\n\tans = max(ans, getMax(sum, u + 1));\n\t\n\treturn (ans);\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\t\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(0, 1));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<map<char,char> > howToGet;\nmap<map<char,char>,char> dp[43];\nvoid dfs(int kind,int wgt,const map<char,char> &v){\n  if(kind==0){\n    map<char,char> nv=v;\n    //nv[0]=0;\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tmap<char,char> nv=v;\n\tif(i>=1)nv[kind]=i;\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const map<char,char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  map<char,char> nv=v;\n  bool ok=true;\n  for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n    if(nv.count(it->first)==0||nv[it->first]-(it->second)<0){\n      ok=false;\n      break;\n    }\n    else nv[it->first]-=it->second;\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  //return dp[pos][v]=res;\n  if(lim<1000000){\n    lim++;\n    return dp[pos][v]=res;\n  }\n  else return res;\n}\n\nint main(){\n  dfs(0,10,map<char,char>());\n  while(cin>>N&&N){\n    lim=0;\n    map<char,char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > select;\nvoid manju(vector<int>& a, int prev, int sum, const vector<int>& x)\n{\n    if(sum > 10)\n        return;\n    if(sum == 10){\n        if(accumulate(a.begin(), a.end(), 0) > 2)\n            select.push_back(a);\n        return;\n    }\n\n    for(int i=prev; i<=9; ++i){\n        if(x[i] == 0)\n            continue;\n        ++ a[i];\n        sum += i;\n        manju(a, i, sum, x);\n        sum -= i;\n        -- a[i];\n    }\n}\n\nvector<map<vector<int>, int> > memo;\nint solve(const vector<int>& x, int k)\n{\n    if(k >= select.size())\n        return 0;\n\n    if(memo[k].find(x) != memo[k].end())\n        return memo[k][x];\n\n    int ret = solve(x, k+1);\n\n    vector<int> y = x;\n    bool ok = true;\n    for(int i=1; i<=9; ++i){\n        y[i] -= select[k][i];\n        if(y[i] < 0)\n            ok = false;\n    }\n    if(ok)\n        ret = max(ret, solve(y, k) + 1);\n\n    return memo[k][x] = ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> x(10, 0);\n        for(int i=0; i<n; ++i){\n            int y;\n            cin >> y;\n            if(x[10-y] > 0)\n                -- x[10-y];\n            else\n                ++ x[y];\n        }\n\n        select.clear();\n        vector<int> a(10, 0);\n        manju(a, 1, 0, x);\n\n        memo.assign(select.size(), map<vector<int>, int>());\n        cout << solve(x, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\nint r,a[10],rem;\nvoid dfs(int d,int sum,int c){\n  if (c+rem/10<r) return;\n  r = max(r, c);\n  if (sum==10) dfs(1,0,c+1);\n  else {\n    if (d<9)dfs(d+1,sum,c);\n    if (a[d]&&sum+d<=10) {\n      a[d]--;rem-=d;\n      dfs(d,sum+d,c);\n      a[d]++;rem+=d;\n    }\n  }\n}\nmain() {\n  int n;\n  while(cin>>n,n) {\n    REP(i,n)a[i]=0;\n    REP(i,n){int b;cin>>b;a[b]++;}\n    int t=0;\n    for (int i=1; i<=4; ++i) {\n      int m=min(a[i],a[10-i]);\n      a[i]-=m;a[10-i]-=m;\n      t+=m;\n    }\n    t+=a[5]/2;\n    a[5]%=2;\n    rem=0;\n    REP(i,10) rem+=a[i]*i;\n    r=0;\n    dfs(1,0,0);\n    cout << t+r << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\nvector<int> loop;\n\nint dfs(int cnt,int sum,vector<int> remain){\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n  int maxcost = cnt;\n  rep(i,limit){\n    if( remain[loop[i]] == 0 ) continue;\n    int nsum = sum + loop[i];\n    if( nsum >  10 ) break;\n    remain[loop[i]]--;\n    if( nsum == 10 ) {\n      maxcost = max(maxcost,dfs(cnt+1,0,remain));\n      memo[remain] = maxcost;\n      remain[loop[i]]++;\n      return maxcost;\n    } else {\n      maxcost = max(maxcost,dfs(cnt,nsum,remain));\n    }\n    remain[loop[i]]++;\n  }\n  if( sum == 0 ) memo[remain] = maxcost;\n  return maxcost;  \n}\n\n\nint main() {\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= 2*tmp;\n    REP(i,1,10) if( remain[i] ) loop.push_back(i);\n    limit = loop.size();\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nbool ok[10];\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tif (ok[i]){\n\t\t\tt[i]++;\n\t\t\tmake(t, rem - i, rem - i);\n\t\t\tt[i]--;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tmemset(ok, false, sizeof(ok));\n\t\t\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\tif (num[i]) ok[i] = true;\n\t\t}\n\t\t\n\t\tmp.clear();\n\t\tmake(t, 9, 10);\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\nusing namespace std;\n\nconst vector<vector<int>> listup(vector<int> count, int start, int n, int sum, vector<int> list) {\n    vector<vector<int>> result;\n    if(sum == 0 || n == 0) {\n        if(sum == 0 && n == 0) result.push_back(list);\n//         if(sum == 0 && n == 0) {for(auto&v:list)cout<<\" \"<<v;cout<<endl;}\n        return result;\n    }\n    for(int i = start; i < count.size(); ++i) {\n        if(i > sum) continue;\n        if(count[i] <= 0) continue;\n        list.push_back(i);\n        --count[i];\n        vector<vector<int>> add = listup(count, i, n - 1, sum - i, list);\n        result.insert(result.begin(), add.begin(), add.end());\n        list.pop_back();\n        ++count[i];\n    }\n    return result;\n}\n\n\nvector<vector<int>> memo;\nint maxdepth;\n\nvoid dfs(const vector<vector<int>>& list, vector<int> count, int start, int depth) {\n    if(depth == maxdepth) {\n        memo.push_back(count);\n    } else if(depth > maxdepth) {\n        memo.clear();\n        maxdepth = depth;\n        memo.push_back(count);\n    }\n\n    for(int i = start; i < list.size(); ++i) {\n        bool ok = true;\n        for(const auto& v: list[i]) ok &= 0 <= --count[v];\n        if(ok) dfs(list, count, i, depth + 1);\n        for(const auto& v: list[i]) ++count[v];\n    }\n}\n\nint solve(const vector<int>& manju) {\n    enum {COST, COUNT};\n    typedef tuple<int, vector<int>> CANDIDATE;\n\n    vector<int> count(11, 0);\n    for(const auto& v: manju) ++count[v];\n\n    vector<CANDIDATE> candidate;\n    candidate.push_back(CANDIDATE(0, count));\n\n    for(int i = 2; i <= 10; ++i) {\n        vector<vector<int>> list = listup(count, 0, i, 10, vector<int>());\n\n        vector<CANDIDATE> next;\n        for(const auto& c: candidate) {\n            int cost = get<COST>(c);\n            vector<int> count = get<COUNT>(c);\n            maxdepth = 0; memo.clear();\n            dfs(list, count, 0, 0);\n            cost += maxdepth;\n            for(const auto& v: memo) next.push_back(CANDIDATE(cost, v));\n        }\n        candidate = next;\n    }\n\n    return get<COST>(candidate[0]);\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<int> manju(n);\n        for(auto& v: manju) cin >> v;\n        cout << solve(manju) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint rest[10];\n\nint solve(int num, int sum) {\n\tint nex_num;\n\tint res = 0;\n\n\tif(sum == 10)\n\t\treturn solve(num, 0) + 1;\n\tif(num == 0)\n\t\treturn 0;\n\n\tfor(int i = num; i; i--) {\n\t\tint j;\n\t\tfor(j = 1; sum + j*i <= 10 && rest[i]; j++) {\n\t\t\trest[i]--;\n\t\t\tres = max(res, solve(num, sum + j*i));\n\t\t}\n\t\twhile(--j)\n\t\t\trest[i]++;\n\t}\n\n\tres = max(res, solve(num-1, sum));\n\treturn res;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\trest[i] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint in;\n\t\t\tcin >> in;\n\t\t\trest[in]++;\n\t\t}\n\t\tcout << solve(9, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<vi,int> state;\n\nint n;\nvi a(9);\nmap<state,int> memo;\n\nint rec(vi v,int sum){\n  if(memo.find(state(v,sum))!=memo.end())return memo[state(v,sum)];\n\n  int res = 0;\n  for(int i=7;i>=0;i--){\n    if(v[i]){\n      if(sum+i==8){\n\tv[i]--;\n\tres = max(res,rec(v,0)+1);\n\tv[i]++;\n      }else if(sum+i<8){\n\tv[i]--;\n\tres = max(res,rec(v,sum+i));\n      }\n    }\n  }\n\n  return memo[state(v,sum)] = res;\n}\n\nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<9;i++)a[i] = 0;\n    int tmp;\n    for(int i=0;i<n;i++){\n      cin >> tmp; a[tmp-1]++;\n    }\n\n    int res = 0;\n    res = min(a[0],a[8]); a[0] -= res; a[8] -= res;\n\n    memo.clear();\n    cout << res+rec(a,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint a;\nvector<vvint> vv;\nvint tmp;\nmap<vint,int> ma;\nint cnt=0;\nvoid foo(int a,int b){\n\t// if(a>9) return;\n\tif(b==10){\n\t\tvv[a].PB(tmp);\n\t\t// cout<<cnt++<<endl;;\n\t\treturn;\n\t}\n\tif(b>10){\n\t\treturn;\n\t}\n\treep(i,1,10){\n\t\tif(b+i>10) break;\n\t\ttmp.PB(i);\n\t\tfoo(a+1,b+i);\n\t\ttmp.pop_back();\n\t}\n}\nint dfs(int y){\n\tif(ma.count(a)) return ma[a];\n\tif(y<2) return ma[a]=0;\n\tint ret=0;\n\treep(i,2,11){\n\t\trep(j,vv[i].size()){\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]--;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\trep(k,10){\n\t\t\t\tif(a[k]<0) f=false;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tret=max(ret,dfs(y-i)+1);\n\t\t\t}\n\t\t\trep(k,vv[i][j].size()){\n\t\t\t\ta[vv[i][j][k]]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ma[a]=ret;\n}\nvoid mainmain(){\n\tint n;\n\tvv=vector<vvint>(11);\n\tfoo(0,0);\n\trep(i,vv.size()){\n\t\trep(j,vv[i].size()){\n\t\t\tsort(ALL(vv[i][j]));\n\t\t}\n\t\tsort(ALL(vv[i]));\n\t\tvv[i].erase(unique(ALL(vv[i])),vv[i].end());\n\t}\n\t// return;\n\twhile(cin>>n,n){\n\t\tma.clear();\n\t\t// cout<<n<<endl;\n\t\tvint v(n);\n\t\trep(i,n) cin>>v[i];\n\t\ta=vint(10,0);\n\t\trep(i,n){\n\t\t\ta[v[i]]++;\n\t\t}\n\t\tint ans=dfs(n);\n\t\t// reep(i,2,11){\n\t\t\t// for(int j=vv[i].size()-1;j>=0;j--){\n\t\t\t\t// bool f=true;\n\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t// a[vv[i][j][k]]--;\n\t\t\t\t// }\n\t\t\t\t// rep(k,10){\n\t\t\t\t\t// if(a[k]<0) f=false;\n\t\t\t\t// }\n\t\t\t\t// if(f){\n\t\t\t\t\t// ans++;\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t\t// rep(k,vv[i][j].size()){\n\t\t\t\t\t\t// a[vv[i][j][k]]++;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\nset<vector<int> > mm;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tif( mm.count(s) ) return;\n\t\n\t//if( foo < 100000 ){\n\t\tmm.insert(s);\n\t//}\n\t\n\tfoo++;\n\t//if( 7500000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tmm.clear();\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef pair< char, char > Pi; // 2個\ntypedef pair< Pi, Pi > Pii; // 4個\ntypedef pair< Pii, Pii > Piii; // 8個\ntypedef pair< Piii, int > Piiii; // 9個\n \nint n;\nvector< char > barabara(10);\nmap< Piiii, char > dp;\n \n \nvector< vector< char > > mask;\n \nchar manzyu(vector< char >& mans)\n{\n  char ret = 0;\n  for(int i = 0; i < mask.size(); i++) {\n    if(mans[1] >= mask[i][1] && mans[2] >= mask[i][2] && mans[3] >= mask[i][3] && mans[4] >= mask[i][4] && mans[5] >= mask[i][5] && mans[6] >= mask[i][6] && mans[7] >= mask[i][7] && mans[8] >= mask[i][8] && mans[9] >= mask[i][9]) {\n      for(int j = 1; j < 10; j++) {\n        mans[j] -= mask[i][j];\n      }\n      ret = max(ret, (char)(manzyu(mans) + 1));\n      for(int j = 1; j < 10; j++) {\n        mans[j] += mask[i][j];\n      }\n    }\n  }\n  return(ret);\n}\n \n \n \nvoid isten(vector< char >& ret, int digit, int sum) {\n  if(digit <= 0 || sum > 10) {\n    return;\n  } else if(sum == 10) {\n    mask.push_back(ret);\n    return;\n  } else {\n    isten(ret, digit - 1, sum);\n    ret[digit]++;\n    isten(ret, digit, sum + digit);\n    ret[digit]--;\n  }\n}\n \nint main() {\n  vector< char > buff(10, 0);\n  isten(buff, 9, 0);\n \n  while(cin >> n, n) {\n    for(int i = 1; i < 10; i++) barabara[i] = 0;\n    dp.clear();\n    for(int i = 0; i < n; i++) {\n      int m;\n      cin >> m;\n      barabara[m]++;\n    }\n \n    int prad = 0;\n    for(int i = 1; i <= 4; i++) {\n      int cost = min(barabara[i], barabara[10 - i]);\n      prad += cost;\n      barabara[i] -= cost;\n      barabara[10 - i] -= cost;\n    }\n    prad += barabara[5] / 2;\n    barabara[5] -= barabara[5] / 2 * 2;\n     \n    cout << (int)manzyu(barabara) + prad << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<vector<int> > sum10;\nvector<int> as;\n\nvoid dfs(vector<int> v, int now, int sum) {\n  if (sum == 10) {\n    sum10.push_back(v);\n    return;\n  }\n  if (now == as.size()) return;\n  dfs(v,now+1,sum);\n  if (sum + as[now] <= 10) {\n    v.push_back(now);\n    dfs(v,now,sum+as[now]);\n  }\n}\n\nmap<vector<int> , int> mp[50];\n\nint solve(int now, vector<int> v) {\n  if (now == sum10.size()) return 0;\n  if (mp[now].count(v)) return mp[now][v];\n  int &r = mp[now][v];\n  // if (now == 20) {\n  //   FOR(it, v) {\n  //     cout << *it << \" \";\n  //   }\n  //   cout << endl;\n  //   cout << now << endl;\n  // }\n  int res = 0;\n  REP(i,100) {\n    bool dame = 0;\n    res = max(res, solve(now+1, v) + i);\n    FOR(it, sum10[now]) {\n      if (v[*it]-- == 0) dame = 1;\n    }\n    if(dame) break;\n  }\n  return r = res;\n}\n\nint a[10];\n\nint main() {\n  // REP(i,9) as.push_back(i+1);\n  // vector<int> t;\n  // dfs(t,0,0);\n  // FOR(it, sum10) {\n  //   FOR(jt, *it) cout << *jt << \" \";\n  //   cout << endl;\n  // }\n  int n;\n  while(cin>>n,n) {\n    int ans = 0;\n    memset(a,0,sizeof(a));\n    REP(i,n) {\n      int b;cin >> b;\n      if (b >= 10) {\n        if (b == 10) ans++;\n      } else {\n        a[b]++;\n      }\n    }\n    for (int i=1; i<=4; ++i) {\n      int j = 10-i;\n      int m = min(a[i], a[j]);\n      a[i] -= m;\n      a[j] -= m;\n      ans += m;\n    }\n    ans += a[5] / 2;\n    a[5] -= a[5]/2*2;\n    vector<int> v;\n    as.clear();\n    REP(i,10) if (a[i]) {\n      as.push_back(i);\n      v.push_back(a[i]);\n    }\n    sum10.clear();\n    vector<int> t;\n    dfs(t,0,0);\n    REP(i,sum10.size()) mp[i].clear();\n    ans += solve(0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > T;\nvoid init(int i, int s, vector<int> v)\n{\n\tif (s > 10) return;\n\telse if (i == 9){\n\t\tif (s == 10) T.push_back(v);\n\t\treturn;\n\t}\n\tfor (int j = 0; j <= 10; j++){\n\t\tv[i] = j;\n\t\tinit(i + 1, s + (i + 1) * j, v);\n\t}\n}\n\nint n;\nmap<vector<int>, int> dp[50];\n\nint dfs(int i, vector<int> v, int sum)\n{\n\t/*\n\tprintf(\"%d\", i);\n\tfor (int j = 0; j < 9; j++) printf(\" %d\", v[j]);\n\tputs(\"\");\n\t*/\n\t\n\tif (sum < 10) return dp[i][v] = 0;\n\t\n\tif (i == T.size()) return 0;\n\tif (dp[i].count(v)) return dp[i][v];\n\tint res = 0;\n\tfor (int j = 0, f = 1; f; j++){\n\t\tif (j + sum / 10 > res){\n\t\t\tres = max(res, j + dfs(i + 1, v, sum));\n\t\t}\n\t\tfor (int k = 0; k < 9; k++){\n\t\t\tv[k] -= T[i][k];\n\t\t\tif (v[k] < 0) f = 0;\n\t\t}\n\t\tsum -= 10;\n\t}\n\treturn dp[i][v] = res;\n}\n\nint main()\n{\n\tinit(0, 0, vector<int>(9));\n\t\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < 50; i++) dp[i].clear();\n\t\t\n\t\tvector<int> v(9);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tv[--a]++;\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint t = min(v[i], v[8 - i]);\n\t\t\tg += t;\n\t\t\tv[i] -= t;\n\t\t\tv[8 - i] -= t;\n\t\t}\n\t\tg += v[4] / 2;\n\t\tv[4] %= 2;\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 9; i++){\n\t\t\tsum += (i + 1) * v[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", g + dfs(0, v, sum));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 10000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tif( 99 < n ) continue;\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nint maximum;\n\nvoid recursive(int index,int array[10],int tmp_sum,int manjyu_num){\n\n\tint check = tmp_sum;\n\tfor(int i = 1; i <= 9; i++)check += i*array[i];\n\n\tif(manjyu_num+check/10 <= maximum)return;\n\n\tmaximum = max(maximum,manjyu_num);\n\n\tif(tmp_sum == 10){\n\t\trecursive(1,array,0,manjyu_num+1);\n\t\treturn;\n\t}\n\tif(index == 10 && tmp_sum != 10)return;\n\n\tfor(int num = 0; num <= array[index]; num++){\n\t\tif(tmp_sum+index*num > 10)return;\n\n\t\tint next_array[10];\n\t\tfor(int i = 1; i <= 9; i++)next_array[i] = array[i];\n\t\tnext_array[index] -= num;\n\t\trecursive(index+1,next_array,tmp_sum+index*num,manjyu_num);\n\t}\n}\n\nvoid func(){\n\n\tmaximum = 0;\n\n\tint input[10];\n\tfor(int i = 1; i <= 9; i++)input[i] = 0;\n\n\tint tmp;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d\",&tmp);\n\t\tinput[tmp]++;\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 1; i <= 4; i++){\n\t\ttmp = min(input[i],input[10-i]);\n\t\tans += tmp;\n\t\tinput[i] -= tmp;\n\t\tinput[10-i] -= tmp;\n\t}\n\n\tans += input[5]/2;\n\tinput[5] %= 2;\n\n\trecursive(1,input,0,0);\n\n\tprintf(\"%d\\n\",ans+maximum);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n// int N;\n// int MS[101];\n// vector<map<char,char> > howToGet;\n// map<map<char,char>,char> dp[43];\n// void dfs(const int kind,int wgt,map<char,char> v){\n//   if(kind==0){\n//     map<char,char> nv=v;\n//     dfs(kind+1,wgt,nv);\n//   }\n//   else if(wgt==0)howToGet.push_back(v);\n//   else if(kind==10)return;\n//   else{\n//     for(int i=0;i*kind<=10;i++){\n//       if(wgt-i*kind>=0){\n// \tmap<char,char> nv=v;\n// \tif(i>=1)nv[kind]=i;\n// \tdfs(kind+1,wgt-i*kind,nv);\n//       }\n//     }\n//   }\n// }\n\n// void dfs2(const int pos,const map<char,char> v,int cnt,int &maxVal,int preLast){\n//   if(pos==(int)howToGet.size())return;\n//   if(preLast/10+cnt<=maxVal)return;\n//   // 1セット分取れるか\n//   map<char,char> nv=v;\n//   bool ok=true;\n//   int sz=0;\n//   for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n//     if(nv.count(it->first)==0\n//        ||nv[it->first]-(it->second)<0){\n//       ok=false;\n//       break;\n//     }\n//     else{\n//       nv[it->first]-=it->second;\n//       sz+=it->second;\n//     }\n//   }\n//   // 1セット取れるならとる\n//   if(ok){\n//     maxVal=max(maxVal,cnt+1);\n//     dfs2(pos,nv,cnt+1,maxVal,preLast-sz);\n//   }\n//   // 取らずに次のセットへ\n//   dfs2(pos+1,v,cnt,maxVal,preLast);\n// }\n\n// void greedy(int &maxVal,map<char,char> v){\n//   for(int pos=0;pos<(int)howToGet.size();pos++){\n//     while(1){\n//       bool ok=true;\n//       for(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++){\n// \tif(v.count(it->first)==0||v[it->first]-(it->second)<0){\n// \t  ok=false;\n// \t  break;\n// \t}\n//       }\n//       if(ok){\n// \tfor(map<char,char>::iterator it=howToGet[pos].begin();it!=howToGet[pos].end();it++)\n// \t  v[it->first]-=it->second;\n// \tmaxVal++;\n//       }\n//       else\n// \tbreak;\n//     }\n//   }\n// }\n\n// int main(){\n//   dfs(0,10,map<char,char>());\n//   while(cin>>N&&N){\n//     map<char,char> cnts;\n//     int preLast=0;\n//     for(int i=0;i<N;i++)cin>>MS[i];\n//     for(int i=0;i<N;i++){\n//       cnts[MS[i]]++;\n//       preLast+=MS[i];\n//     }\n//     for(int i=0;i<43;i++)dp[i].clear();\n//     int maxVal=0;\n//     greedy(maxVal,cnts);\n//     // cout<<maxVal<<endl;\n//     // dfs2(0,cnts,0,maxVal,preLast);\n//     cout<<maxVal<<endl;\n//   }\n//   return 0;\n// }\n\nint N;\nint MS[101];\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp;\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(const vector<char> &v){\n  if(dp.count(v)!=0)return dp[v];\n  int res=0;\n  for(int pos=0;pos<(int)howToGet.size();pos++){\n    // 1セット分取れるか\n    vector<char> nv=v;\n    bool ok=true;\n    for(int j=1;j<(int)howToGet[pos].size();j++){\n      nv[j]-=howToGet[pos][j];\n      if(nv[j]<0){\n\tok=false;\n\tbreak;\n      }\n    }\n    // iセット取れるならとる\n    if(ok)res=max(res,dfs2(nv)+1);\n  }\n  return dp[v]=res;\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    int a=min(cnts[9],cnts[1]);\n    cnts[9]-=a;\n    cnts[1]-=a;\n    int res=dfs2(cnts)+a;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\ntypedef pair<ll, ll> P;\nll enc(int* s)\n{\n    ll res = 0;\n    for (int i = 0; i < 5; ++i)\n        res = (res << 8) | s[i];\n    return res;\n}\nP encode(int* s)\n{\n    return P(enc(s + 1), enc(s + 5));\n}\nll dec(int* s, ll d)\n{\n    for (int i = 4; i >= 0; --i, d >>= 8)\n        s[i] = d & 0xff;\n}\nvoid decode(int* s, const P& p)\n{\n    dec(s + 1, p.first);\n    dec(s + 5, p.second);\n}\n\n\nint n, a[128];\n \nint res, possi_max;\nint sack[11];\nset<P> memo[101];\nvoid dfs(int d)\n{\n    static const int M = 88;\n    if (res == possi_max || sack[10] + (n - d) <= res\n        || (d < M && memo[d].count(encode(sack))))\n        return;\n    else if (d == n)\n    {\n        res = sack[10];\n        return;\n    }\n    if (d < M)\n        memo[d].insert(encode(sack));\n\n    for (int i = 10 - a[d]; i >= 0; --i)\n    {\n        if (sack[i] > 0)\n        {\n            int j = a[d] + i;\n \n            --sack[i];\n            ++sack[j];\n \n            dfs(d + 1);\n \n            ++sack[i];\n            --sack[j];\n        }\n    }\n}\n\nint solve()\n{\n    sort(a, a + n, greater<int>());\n \n    for (int i = 0; i < 100; ++i)\n        memo[i].clear();\n\n    possi_max = accumulate(a, a + n, 0) / 10;\n    res = 0;\n    dfs(0);\n \n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n \n    sack[0] = 114514;\n    while (cin >> n, n)\n    {\n        input(a, n);\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[33*33*33*33][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    assert(i+base[0]*(j+base[1]*(k+base[2]*l)) < 33*33*33*33);\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d, %d\\n\", a, b, c, d, index, a+b+c+d);\n    // printf(\"[%d][%d][%d][%d]: %d\\n\",\n    //        i, j, k, l,\n    //        i+j*(at2(0)+1)+k*(at2(0)+at2(1)+2)+l*(at2(0)+at2(1)+at2(2)+3));\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", a, b, c, d, index, res);\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-7;\n\n#define EQ(d1,d2) ((EPS)<=((d2)-(d1))&&((d2)-(d1))<=(EPS))\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif (x == 0) a.push_back(d);\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\treturn ret/10;\n}\n\nvoid solve(int m[], int pre, int step)\n{\t\n\tif (res < step) {\n\t\tres = step;\n\t}\n\t\n\tif (step + ideal(m) <= res) {\n\t\treturn;\n\t}\n\t\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool ok = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[i][j];\n\t\t\t}\n\n\t\t\tsolve(m, i, step + 1);\n\n\t\t\t// Rollback\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] += parts[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void)\n{\n\t// int * (*x)(void *) = a;\n\t// RETURN TYPE, (*IDENTIFIER)(ARGUMENTS...);\n\t// test( (10, 20, 30) );\n\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = 0; j < s[i].size(); ++j) {\n\t\t\tparts[i][s[i][j] - 1]++;\n\t\t}\n\t}\n\n/*\n\tfor (int i = 0; i < NPAT; ++i){\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tcout << parts[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\n*/\n\n\twhile (true){\n\t\tint n;\n\t\tint m[9] = { 0, };\n\t\t\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tsolve(m,0,0);\n\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nmap<ull,int> memo;\n\nint dfs2(ull, int, int);\n\nint dfs1(ull s){\n\tif(s <= 0xff){\n\t\treturn s / 10;\n\t}\n\tif(memo.count(s)){\n\t\treturn memo[s];\n\t}\n\tint k;\n\tfor(k = 8; !(s >> ((k - 1) * 8)); --k);\n\n\tint a = dfs2(s - (1ull << ((k - 1) * 8)), 10 - k, k);\n\tint b = dfs1(s & ((1ull << ((k - 1) * 8)) - 1));\n\tint res = max(a, b);\n\n\tmemo[s] = res;\n\treturn res;\n}\n\nint dfs2(ull s, int t, int u){\n\tif(t != 9 && s >> ((t - 1) * 8) & 0xff){\n\t\treturn dfs1(s - (1ull << ((t - 1) * 8))) + 1;\n\t}\n\tif(t == 1){\n\t\treturn 0;\n\t}\n\tif(t == 2){\n\t\tif((s & 0xff) >= 2){\n\t\t\treturn dfs1(s - 2) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(t == 3){\n\t\tif(s & 0xff && s & 0xff00){\n\t\t\treturn dfs1(s - 0x101) + 1;\n\t\t}\n\t\tif((s & 0xff) >= 3){\n\t\t\treturn dfs1(s - 3) + 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint res = 0;\n\tfor(u = min(t, u); u >= 1; --u){\n\t\tif(s >> ((u - 1) * 8) & 0xff){\n\t\t\tint a = dfs2(s - (1ull << ((u - 1) * 8)), t - u, u);\n\t\t\tres = max(res, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, x;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint cnt[10] = {};\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &x);\n\t\t\t++cnt[x];\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tx = min(cnt[1], cnt[9]);\n\t\tcnt[1] -= x;\n\t\tcnt[9] -= x;\n\t\tans = x;\n\t\t\n\t\tull s = 0;\n\t\tfor(int i = 1; i <= 8; ++i){\n\t\t\ts |= (ull)cnt[i] << ((i - 1) * 8);\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tans += dfs1(s);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\n\nint n, a[128];\n\nint res;\nint sack[11];\nvoid dfs(int d)\n{\n\tif (sack[10] + (n - d) <= res)\n\t\treturn;\n\telse if (d == n)\n\t{\n\t\tres = sack[10];\n\t\treturn;\n\t}\n\n\tfor (int i = 10 - a[d]; i >= 0; --i)\n\t{\n\t\tif (sack[i] > 0)\n\t\t{\n\t\t\tint j = a[d] + i;\n\t\t\t--sack[i];\n\t\t\t++sack[j];\n\n\t\t\tdfs(d + 1);\n\n\t\t\t++sack[i];\n\t\t\t--sack[j];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tsack[0] = 114514;\n\twhile (cin >> n, n)\n\t{\n\t\tinput(a, n);\n\n\t\tsort(a, a + n, greater<int>());\n\n\t\tres = 0;\n\t\tdfs(0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint res;\n\nvoid solve(vi& hist,int i,int remain,int cur)\n{\n\tres=max(res,cur);\n\tif(i==10)\n\t\treturn;\n\t\n\tif(remain==0){\n\t\tremain=10;\n\t\tcur++;\n\t}\n\t\n\tsolve(hist,i+1,remain,cur);\n\tif(hist[i]>0 && remain>=i){\n\t\thist[i]--;\n\t\tsolve(hist,i,remain-i,cur);\n\t\thist[i]++;\n\t}\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvi hist(10);\n\t\trep(i,n){\n\t\t\tint m; scanf(\"%d\",&m);\n\t\t\thist[m]++;\n\t\t}\n\t\t\n\t\tint sum=hist[5]/2;\n\t\thist[5]%=2;\n\t\trepi(i,1,5)\n\t\t\twhile(hist[i] && hist[10-i]){\n\t\t\t\tsum++;\n\t\t\t\thist[i]--;\n\t\t\t\thist[10-i]--;\n\t\t\t}\n\t\t\n\t\tres=0;\n\t\tsolve(hist,1,10,0);\n\t\tprintf(\"%d\\n\",res+sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint manto[11];\n\nbool dfs(int No, int sum)\n{\n\tint x = manto[10];\n\n\n\tif(sum == 10){\n\t\treturn true;\n\t}\n\n\telse if(sum > 10)\n\t\treturn false;\n\t\n\tfor(int i = No; i > 0; i--){\n\t\tif(manto[i] > 0){\n\t\t\tmanto[i]--;\n\t\t\tif(!dfs(i,sum+i))\n\t\t\t\tmanto[i]++;\n\t\t\telse\n\t\t\t\tmanto[10]++;\n\n\t\t}\n\t}\n\n\n\n\tif(No == 9 && x < manto[10])\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n\n\nint main()\n{\n\twhile(cin >> N, N){\n\t\tint a;\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tmanto[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> a;\n\t\t\tmanto[a]++;\n\t\t}\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(i == 5){\n\t\t\t\tif(manto[i] >= 2){\n\t\t\t\t\twhile(manto[i] >= 2){\n\t\t\t\t\t\tmanto[i] -= 2;\n\t\t\t\t\t\tmanto[10]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\twhile(manto[i] > 0 && manto[10-i] > 0){\n\t\t\t\t\tmanto[i]--;\n\t\t\t\t\tmanto[10-i]--;\n\t\t\t\t\tmanto[10]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(dfs(9,0));\n\t\tcout << manto[10] << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef unsigned long long hash_t;\n\nstd::mt19937 RND;\nstd::uniform_int_distribution<hash_t> DST;\n#define random() (DST(RND))\n\nhash_t hash_table[10][101];\nstd::vector<std::vector<int>> T;\nstd::map<hash_t, int> dp;\n\nvoid dfs(int i, int s, std::vector<int> v)\n{\n\tif (s == 0){\n\t\tT.emplace_back(v);\n\t\treturn;\n\t}\n\tif (i > 9) return;\n\tif (i > s) return;\n\t\n\tv[i]++;\n\tdfs(i, s - i, v);\n\tv[i]--;\n\t\n\tdfs(i + 1, s, v);\n}\n\ninline hash_t getHash(const std::vector<int> &v)\n{\n\thash_t res = 0;\n\tfor (int i = 0; i < 10; i++){\n\t\tres ^= hash_table[i][v[i]];\n\t}\n\treturn res;\n}\n\nint calc(std::vector<int> &v, int pos = 0)\n{\n\tif (pos == T.size()) return 0;\n\thash_t hash = getHash(v);\n\tif (dp.count(hash)) return dp[hash];\n\t\n\tint res = calc(v, pos + 1);\n\tauto &table = T[pos];\n\t\n\tint k = 99;\n\tfor (int i = 0; i < table.size(); i++){\n\t\tif (table[i] == 0) continue;\n\t\tk = std::min(k, v[i] / table[i]);\n\t}\n\tfor (int i = 1; i <= k; i++){\n\t\tfor (int j = 0; j < table.size(); j++){\n\t\t\tv[j] -= table[j];\n\t\t}\n\t\tres = std::max(res, k + calc(v, pos + 1));\n\t}\n\tfor (int j = 0; j < table.size(); j++){\n\t\tv[j] += table[j] * k;\n\t}\n\t\n\treturn dp[hash] = res;\n}\n\nint main()\n{\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\thash_table[i][j] = random();\n\t\t}\n\t}\n\t\n\tdfs(1, 10, std::vector<int>(10, 0));\n\t\n\tint n;\n\twhile (std::cin >> n, n){\n\t\tstd::vector<int> v(10, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\tv[a]++;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", calc(v));\n\t\tdp.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)tens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n, int dep = 0){\n    if(n == tens.size())return dep;\n    int res = dfs(n + 1, dep);\n    int ok = 1;\n    for(int i = 1;i <= 9;i++){\n\tnum[i] -= tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n, dep + 1), res);\n    for(int i = 1;i <= 9;i++){\n\tnum[i] += tens[n][i];\n    }\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> Pr;\n\nint n;\nint v[10];\n\nvector<vector<Pr> > pat;\nvoid makepat(int i = 1, int x = 10, vector<Pr> vec = vector<Pr>()){\n\tif (x == 0) pat.push_back(vec);\n\tif (i > x) return;\n\tfor (; i <= 9; i++){\n\t\tif (v[i] <= 0) continue;\n\t\tif (i <= x){\n\t\t\tif (vec.size() && vec.back().first == i) vec.back().second++;\n\t\t\telse vec.push_back(Pr(i, 1));\n\t\t\tv[i]--;\n\t\t\tmakepat(i, x - i, vec);\n\t\t\tv[i]++;\n\t\t\tif (--vec.back().second == 0) vec.pop_back();\n\t\t}\n\t}\n}\n\nmap<vector<int>, int> dp;\nint calc(int pos){\n\tvector<int> st;\n\tfor (int i = 1; i <= 9; i++){\n\t\tst.push_back(v[i]);\n\t}\n\tif (dp.count(st)) return dp[st];\n\tif (pos == pat.size()) return 0;\n\t\n\tint res = 0;\n\tfor (; pos < pat.size(); pos++){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < pat[pos].size(); i++){\n\t\t\tPr &p = pat[pos][i];\n\t\t\tv[p.first] -= p.second;\n\t\t\tif (v[p.first] <= 0) f = false;\n\t\t}\n\t\tif (f){\n\t\t\tres = max(res, 1 + calc(pos));\n\t\t}\n\t\tfor (int i = 0; i < pat[pos].size(); i++){\n\t\t\tPr &p = pat[pos][i];\n\t\t\tv[p.first] += p.second;\n\t\t}\n\t}\n\t\n\treturn dp[st] = res;\n}\n\nvoid solve(){\n\tint res = 0;\n\tfor (int i = 1; i <= 4; i++){\n\t\tif (v[i] > 0 && v[10 - i] > 0){\n\t\t\tres++;\n\t\t\tv[i]--;\n\t\t\tv[10 - i]--;\n\t\t}\n\t}\n\twhile (v[5] >= 2){\n\t\tres++;\n\t\tv[5] -= 2;\n\t}\n\t\n\tpat.clear();\n\tmakepat();\n\tdp.clear();\n\tprintf(\"%d\\n\", res + calc(0));\n}\n\nint main()\n{\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint m;\n\t\t\tscanf(\"%d\", &m);\n\t\t\tv[m]++;\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\n\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        array<int, 11> cnt{};\n        for (int i = 0; i < n; ++i) {\n            int x; cin >> x;\n            cnt[x]++;\n        }\n        int ans = 0;\n        while(cnt[1] && cnt[9]) cnt[1]--, cnt[9]--, ans++;\n        while(cnt[2] && cnt[8]) cnt[2]--, cnt[8]--, ans++;\n        while(cnt[3] && cnt[7]) cnt[3]--, cnt[7]--, ans++;\n        while(cnt[4] && cnt[6]) cnt[4]--, cnt[6]--, ans++;\n        while(cnt[5] >= 2) cnt[5] -= 2, ans++;\n        vector<pair<int, int>> v;\n        for (int i = 1; i < 9; ++i) if(cnt[i]) v.emplace_back(cnt[i], i);\n        while(v.size() < 5) v.emplace_back(0, 0);\n        using A = array<char, 5>;\n        A x;\n        for (int i = 0; i < v.size(); ++i) x[i] = v[i].first;\n        vector<A> ok;\n        for (char i = 0; i <= v[0].first; ++i) {\n            for (char j = 0; j <= v[1].first; ++j) {\n                for (char k = 0; k <= v[2].first; ++k) {\n                    for (char l = 0; l <= v[3].first; ++l) {\n                        for (char m = 0; m <= v[4].first; ++m) {\n                            if(i*v[0].second+j*v[1].second+k*v[2].second+l*v[3].second+m*v[4].second == 10) ok.emplace_back(A{i, j, k, l, m});\n                        }\n                    }\n                }\n            }\n        }\n        map<A, int> dp;\n        auto dfs = [&](A x, int dep, auto &&f) -> int {\n            if(dp.count(x)) return dp[x];\n            int ret = dep;\n            for (int i = 0; i < ok.size(); ++i) {\n                A y;\n                for (int j = 0; j < 5; ++j) y[j] = x[j]-ok[i][j];\n                if(*min_element(y.begin(),y.end()) >= 0) ret = max(ret, f(y, dep+1, f));\n            }\n            return dp[x] = ret;\n        };\n        cout << dfs(x, ans, dfs) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[11], ans, total;\n\nint f1[5][2] = {\n\t{9,1},\n\t{8,2},\n\t{7,3},\n\t{6,4},\n\t{5,5}\n};\nint f2[8][3] = {\n\t{8,1,1},\n\t{7,2,1},\n\t{6,3,1},\n\t{6,2,2},\n\t{5,4,1},\n\t{5,3,2},\n\t{4,4,2},\n\t{4,3,3}\n};\nint f3[8][4] = {\n\t{7,1,1,1},\n\t{6,2,1,1},\n\t{5,3,1,1},\n\t{5,2,2,1},\n\t{4,4,1,1},\n\t{4,3,2,1},\n\t{4,2,2,2},\n\t{3,3,2,2}\n};\nint f4[7][5] = {\n\t{6,1,1,1,1},\n\t{5,2,1,1,1},\n\t{4,3,1,1,1},\n\t{4,2,2,1,1},\n\t{3,3,2,1,1},\n\t{3,2,2,2,1},\n\t{2,2,2,2,2},\n};\nint f5[5][6] = {\n\t{5,1,1,1,1,1},\n\t{4,2,1,1,1,1},\n\t{3,3,1,1,1,1},\n\t{3,2,2,1,1,1},\n\t{2,2,2,2,1,1},\n};\n\nvoid solve(int cnt, int sum){\n\tans = max( ans , cnt );\n\tif( total-sum < 10 ) return;\n\tif( (total - sum) / 10 + cnt < ans ) return;\n\t\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tbool flag = false;\n\t\ta[f1[i][0]]--;\n\t\ta[f1[i][1]]--;\n\t\tif( a[f1[i][0]] >= 0 && a[f1[i][1]] >= 0 ){\n\t\t\tflag = true;\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f1[i][0]]++;\n\t\ta[f1[i][1]]++;\n\t\tif( flag ) return;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\ta[f2[i][0]]--;\n\t\ta[f2[i][1]]--;\n\t\ta[f2[i][2]]--;\n\t\tif( a[f2[i][0]] >= 0 && a[f2[i][1]] >= 0 && a[f2[i][2]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f2[i][0]]++;\n\t\ta[f2[i][1]]++;\n\t\ta[f2[i][2]]++;\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\ta[f3[i][0]]--;\n\t\ta[f3[i][1]]--;\n\t\ta[f3[i][2]]--;\n\t\ta[f3[i][3]]--;\n\t\tif( a[f3[i][0]] >= 0 && a[f3[i][1]] >= 0 && a[f3[i][2]] >= 0 && a[f3[i][3]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f3[i][0]]++;\n\t\ta[f3[i][1]]++;\n\t\ta[f3[i][2]]++;\n\t\ta[f3[i][3]]++;\n\t}\n\tfor(int i=0 ; i < 7 ; i++ ){\n\t\ta[f4[i][0]]--;\n\t\ta[f4[i][1]]--;\n\t\ta[f4[i][2]]--;\n\t\ta[f4[i][3]]--;\n\t\ta[f4[i][4]]--;\n\t\tif( a[f4[i][0]] >= 0 && a[f4[i][1]] >= 0 && a[f4[i][2]] >= 0 && a[f4[i][3]] >= 0 && a[f4[i][4]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f4[i][0]]++;\n\t\ta[f4[i][1]]++;\n\t\ta[f4[i][2]]++;\n\t\ta[f4[i][3]]++;\n\t\ta[f4[i][4]]++;\n\t}\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\ta[f5[i][0]]--;\n\t\ta[f5[i][1]]--;\n\t\ta[f5[i][2]]--;\n\t\ta[f5[i][3]]--;\n\t\ta[f5[i][4]]--;\n\t\ta[f5[i][5]]--;\n\t\tif( a[f5[i][0]] >= 0 && a[f5[i][1]] >= 0 && a[f5[i][2]] >= 0 && a[f5[i][3]] >= 0 && a[f5[i][4]] >= 0 && a[f5[i][5]] >= 0 ){\n\t\t\tsolve(cnt+1,sum+10);\n\t\t}\n\t\ta[f5[i][0]]++;\n\t\ta[f5[i][1]]++;\n\t\ta[f5[i][2]]++;\n\t\ta[f5[i][3]]++;\n\t\ta[f5[i][4]]++;\n\t\ta[f5[i][5]]++;\n\t}\n\t\n\tif( a[4] >= 1 && a[1] >= 6 ){\n\t\ta[4] -= 1;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[4] += 1;\n\t\ta[1] += 6;\n\t}\n\tif( a[3] >= 1 && a[2] >= 1 && a[1] >= 5 ){\n\t\ta[3] -= 1;\n\t\ta[2] -= 1;\n\t\ta[1] -= 5;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[2] += 1;\n\t\ta[1] += 5;\n\t}\n\tif( a[2] >= 3 && a[1] >= 4 ){\n\t\ta[2] -= 3;\n\t\ta[1] -= 4;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 3;\n\t\ta[1] += 4;\n\t}\n\tif( a[3] >= 1 && a[1] >= 7 ){\n\t\ta[3] -= 1;\n\t\ta[1] -= 7;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[3] += 1;\n\t\ta[1] += 7;\n\t}\n\tif( a[2] >= 2 && a[1] >= 6 ){\n\t\ta[2] -= 2;\n\t\ta[1] -= 6;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2] += 2;\n\t\ta[1] += 6;\n\t}\n\tif( a[2] >= 1 && a[1] >= 8 ){\n\t\ta[2]--;\n\t\ta[1] -= 8;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[2]++;\n\t\ta[1] += 8;\n\t}\n\tif( a[1] >= 10 ){\n\t\ta[1] -= 10;\n\t\tsolve(cnt+1,sum+10);\n\t\ta[1] += 10;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\ttotal = 0;\n\t\tfor(int i=0 ; i < 10 ; i++ ){\n\t\t\ta[i] = 0;\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ttotal += e;\n\t\t\ta[e]++;\n\t\t}\n\t\tans = 0;\n\t\tsolve(0,0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint num[10];\n\nint getMax(int sum, int u)\n{\n\tint ans;\n\t\n\tif (u == 10){\n\t\treturn (0);\n\t}\n\t\n\tif (sum == 10){\n\t\treturn (1 + getMax(0, 1));\n\t}\n\t\n\tans = 0;\n\tfor (int i = u; i <= 9; i++){\n\t\tif (num[i] && sum + i <= 10){\n\t\t\tnum[i]--;\n\t\t\tans = max(ans, getMax(sum + i, u));\n\t\t\tnum[i]++;\n\t\t}\n\t}\n\t\n\treturn (max(ans, getMax(sum, u + 1)));\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tmemset(num, 0, sizeof(num));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\t\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(0, 1));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n\tint n;\n\tint hoge[10];\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n == 0) return 0;\n\t\tfill(hoge,hoge+10,0);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x; cin >> x;\n\t\t\tif(1<=x && x<=9) hoge[x]++;\n\t\t}\n\t\tint res = 0;\n\t\tint z;\n\t\tz = min(hoge[1],hoge[9]); res += z; hoge[1]-=z; hoge[9]-=z;\n\t\tz = min(hoge[2],hoge[8]); res += z; hoge[2]-=z; hoge[8]-=z;\n\t\tz = min(hoge[3],hoge[7]); res += z; hoge[3]-=z; hoge[7]-=z;\n\t\tz = min(hoge[4],hoge[6]); res += z; hoge[4]-=z; hoge[6]-=z;\n\t\tz = hoge[5]/2; res += z; hoge[5]-=2*z;\n\t\tz = min(hoge[1]/2,hoge[8]); res += z; hoge[1]-=z; hoge[1]-=z; hoge[8]-=z;\n\t\tz = min(min(hoge[1],hoge[2]),hoge[7]); res += z; hoge[1]-=z; hoge[2]-=z; hoge[7]-=z;\n\t\tz = min(min(hoge[1],hoge[3]),hoge[6]); res += z; hoge[1]-=z; hoge[3]-=z; hoge[6]-=z;\n\t\tz = min(min(hoge[1],hoge[4]),hoge[5]); res += z; hoge[1]-=z; hoge[4]-=z; hoge[5]-=z;\n\t\tz = min(hoge[2]/2,hoge[6]); res += z; hoge[2]-=z; hoge[2]-=z; hoge[6]-=z;\n\t\tz = min(min(hoge[2],hoge[3]),hoge[5]); res += z; hoge[2]-=z; hoge[3]-=z; hoge[5]-=z;\n\t\tz = min(hoge[2],hoge[4]/2); res += z; hoge[2]-=z; hoge[4]-=z; hoge[4]-=z;\n\t\tz = min(hoge[3]/2,hoge[4]); res += z; hoge[3]-=z; hoge[3]-=z; hoge[4]-=z;\n\t\tz = min(min(hoge[1],hoge[2]),min(hoge[3],hoge[4])); res += z;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint ans;\nset<vector<int> > ss;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    if(ss.find(v) != ss.end()) return;\n    ss.insert(v);\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i+i<=10;i++){\n        int j = 10 - i;\n        vector<int> v2 = v;\n        if(v2[i] > 0){\n            v2[i]--;\n            if(v2[j] > 0){\n                v2[j]--;\n                f = true;\n                dfs(v2,cnt+1);\n            }\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 1 && v[1] >= 8){\n        v[2] -= 1;\n        v[1] -= 8;\n        dfs(v,cnt+1);\n        return;\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        dfs(v,cnt+1);\n        return;\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        ss.clear();\n        vector<int> v(10,0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,cost,limit;\nmap<vector<int>,int> memo;\n\nint dfs(int cnt,int sum,vector<int> remain){\n  if( memo.find(remain) != memo.end() ) return memo[remain];\n  int maxcost = cnt;\n  REP(i,1,10){\n    if( remain[i] == 0 ) continue;\n    int nsum = sum + i;\n    if( nsum >  10 ) continue;\n    remain[i]--;\n    if( nsum == 10 ) {\n      maxcost = max(maxcost,dfs(cnt+1,0,remain));\n    } else {\n      maxcost = max(maxcost,dfs(cnt,nsum,remain));\n    }\n    remain[i]++;\n  }\n  return memo[remain] = maxcost;  \n}\n\n\nint main() {\n  while( cin >> n, n ) { \n    memo.clear();\n    vector<int> remain;\n    remain.resize(10);\n    cost = limit = 0;\n    int coef = 0,input;\n    rep(i,n) {\n      cin >> input;\n      if( input == 10 ) coef++;\n      if( input >= 10 ) continue;\n      remain[input]++;\n    }\n\n    REP(i,1,5) {\n      int tmp = min(remain[i],remain[10-i]);\n      coef += tmp;\n      remain[i] -= tmp, remain[10-i] -= tmp;\n    }\n    int tmp = remain[5] / 2;\n    coef += tmp, remain[5] -= tmp;\n\n    cout << coef + dfs(0,0,remain) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nmap<vector<int>,int> dp;\n\nint dfs(vector<int> buns,int sum,int comb_i,vector<vector<int> >& all_combinations){\n  if(comb_i >= all_combinations.size()) return sum;\n  if(dp.find(buns) != dp.end()) return dp[buns];\n\n  vector<int> prev = buns;\n  bool isok = true;\n  for(int weight = 1; weight <= 10; weight++){\n    int use_count = all_combinations[comb_i][weight];\n    buns[weight] -= use_count;\n    if(buns[weight] < 0){\n      isok = false;\n      break;\n    }\n  }\n\n  int res = 0;\n  if(isok){\n    res = max(sum + 1,dfs(buns,sum + 1,comb_i,all_combinations));\n  }\n  else{\n    buns = prev;\n    res = max(sum,dfs(buns,sum,comb_i + 1,all_combinations));\n  }\n\n  buns = prev;\n  return (dp[buns] = max(res,dp[buns]));\n}\n\nvoid make_combinations(int weight,int sum,vector<int>& current,vector<vector<int> >& all_combinations){\n  if(sum >= 10){\n    if(sum == 10) all_combinations.push_back(current);\n    return;\n  }\n  if(weight > 10) return;\n\n  for(int use_count = 0; use_count <= 10; use_count++){\n    current[weight] = use_count;\n    make_combinations(weight + 1,sum + weight * use_count,current,all_combinations);\n    current[weight] = 0;\n  }\n}\n\nint main(){\n  int total_buns;\n  \n  vector<vector<int> > all_combinations;\n  vector<int> current(11);\n  make_combinations(1,0,current,all_combinations);\n\n  while(~scanf(\"%d\",&total_buns)){\n    if(total_buns == 0) break;\n    dp.clear();\n    vector<int> buns(11);\n\n    for(int i = 0; i < total_buns; i++){\n      int weight;\n      scanf(\"%d\",&weight);\n      buns[weight]++;\n    }\n\n    int greedy_sum = 0;\n    for(int weight = 1; weight <= 10; weight++){\n      if(weight == 5){\n        int use_count = (buns[weight] / 2) * 2;\n        greedy_sum += use_count / 2;\n        buns[weight] -= use_count;\n      }\n      else{\n        int use_count = min(buns[weight],buns[10 - weight]);\n        greedy_sum += use_count;\n        buns[weight] -= use_count;\n        buns[10 - weight] -= use_count;\n      }\n    }\n\n    printf(\"%d\\n\",greedy_sum + dfs(buns,0,0,all_combinations));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint f[5];\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\n\nint getMax(vector<int> p)\n{\n\tint a;\n\tif (m.find(p) != m.end()){\n\t\treturn (m[p]);\n\t}\n\t\n\tint s;\n\ts = 0;\n\t\n\tfor (int i = 1; i <= 9; i++){\n\t\ts += i * p[i];\n\t}\n\t\n\tif (s < 10){\n\t\treturn (0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tvector<int> c = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\nbool ok[10];\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tif (ok[i]){\n\t\t\tt[i]++;\n\t\t\tmake(t, rem - i, rem - i);\n\t\t\tt[i]--;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tmemset(ok, false, sizeof(ok));\n\t\t\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\tif (num[i]) ok[i] = true;\n\t\t}\n\t\t\n\t\tmp.clear();\n\t\tmake(t, 9, 10);\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int a[205];\n        rep(i,n) cin >> a[i];\n        sort(a,a + n,greater<int>());\n\n        int ans = 0, f = true;\n        map<pair<int, int>, int> pre;\n        rep(i,n){\n            rep(j,n){\n                pre[make_pair(i,j)] = -1;\n            }\n        }\n\n        int num = 2;\n        while(f){\n            f = false;\n            bool dp[11][11] = {{0}};\n            dp[0][0] = true;\n            rep(i,n){\n                if(a[i] == 0) continue;\n                for(int k = num; k >= 0; k--){\n                    if(a[i] == 0) continue;\n                    for(int j = 10; j >= 0; j--){\n                        if(j - a[i] < 0) continue;\n                        if(not dp[j][k + 1] && dp[j - a[i]][k]){\n                            //cout << i << ' ' << j << endl;\n                            dp[j][k + 1] = true;\n                            pre[make_pair(j,k + 1)] = i;\n                            //cout << j << ' ' << k + 1 << ' ' << i << endl;\n                        }\n                    }\n                }\n            }\n            //cin >> n;\n            if(dp[10][num]){\n                f = true;\n                ans++;\n                int sum = 10, k = num;\n                while(sum != 0){\n                    int prev = pre[make_pair(sum,k)];\n                    //cout << prev.first << ' ' << prev.second << endl;\n                    sum -= a[prev];\n                    a[prev] = 0;\n                    k--;\n                    //show(sum)\n                }\n            }\n            if(not f && num < 10){\n                num++;\n                f = true;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nint dp[33*33*33*33][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){return at2(j) - at(i, j);}\n\ninline int& at4(int i, int j, int k, int l, int index){\n    assert(i+base[0]*(j+base[1]*(k+base[2]*l)) < 33*33*33*33);\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nint rec(int a, int b, int c, int d, int index){\n    // printf(\"%d, %d, %d, %d, %d, %d\\n\", a, b, c, d, index, a+b+c+d);\n    // printf(\"[%d][%d][%d][%d]: %d\\n\",\n    //        i, j, k, l,\n    //        i+j*(at2(0)+1)+k*(at2(0)+at2(1)+2)+l*(at2(0)+at2(1)+at2(2)+3));\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    int res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1);\n    }\n\n    // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", a, b, c, d, index, res);\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        int r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        int r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1);\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n}    "
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nmap<vector<int>, int> m;\nvector<vector<int> > mp;\nvector<int> c;\n\nint getMax(vector<int> &p, int sum)\n{\n\tint a;\n\tif (m.count(p) != 0){\n\t\treturn (m[p]);\n\t}\n\t\n\tif (sum < 10){\n\t\treturn (m[p] = 0);\n\t}\n\t\n\ta = 0;\n\tfor (int i = 0; i < (int)mp.size(); i++){\n\t\tc = p;\n\t\tbool flag;\n\t\tflag = true;\n\t\t\n\t\tfor (int j = 1; j <= 9; j++){\n\t\t\tc[j] -= mp[i][j];\n\t\t\tif (c[j] < 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == true){\n\t\t\ta = max(a, 1 + getMax(c, sum - 10));\n\t\t}\n\t}\n\t\n\treturn (m[p] = a);\n}\n\n\nvoid make(vector<int> t, int lim, int rem)\n{\n\tif (rem == 0){\n\t\tmp.push_back(t);\n\t\tm[t] = 1;\n\t\treturn;\n\t}\n\t\n\tfor (int i = lim; i >= 1; i--){\n\t\tt[i]++;\n\t\tmake(t, rem - i, rem - i);\n\t\tt[i]--;\n\t}\n\t\n\treturn;\n}\n\nint main(void)\n{\n\tint n;\n\tint ans;\n\tvector<int> num(10);\n\tvector<int> t(10, 0);\n\t\n\tmake(t, 9, 10);\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfill(num.begin(), num.end(), 0);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tnum[t]++;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\t\n\t\tfor (int i = 1; i <= 4; i++){\n\t\t\tint m = min(num[i], num[10 - i]);\n\t\t\tans += m;\n\t\t\tnum[i] -= m; num[10 - i] -= m;\n\t\t}\n\t\tans += num[5] / 2; num[5] %= 2;\n\t\t\n\t\tint s = 0;\n\t\tfor (int i = 1; i <= 9; i++){\n\t\t\ts += i * num[i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans + getMax(num, s));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar dp[1000000][CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 1000000){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n\n}\n\ninline int at5(int i, int j){\n    if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint MS[101];\nint lim;\nvector<vector<char> > howToGet;\nmap<vector<char>,char> dp[43];\nvoid dfs(int kind,int wgt,const vector<char> &v){\n  if(kind==0){\n    vector<char> nv=v;\n    nv.push_back(0);\n    dfs(kind+1,wgt,nv);\n  }\n  else if(wgt==0)howToGet.push_back(v);\n  else if(kind==10)return;\n  else{\n    for(int i=0;i*kind<=10;i++){\n      if(wgt-i*kind>=0){\n\tvector<char> nv=v;\n\tnv.push_back(i);\n\tdfs(kind+1,wgt-i*kind,nv);\n      }\n    }\n  }\n}\n\nint dfs2(int pos,const vector<char> &v){\n  if(pos==(int)howToGet.size())return 0;\n  else if(dp[pos].count(v)>0)return dp[pos][v];\n  int res=0;\n  // 1セット分取れるか\n  vector<char> nv=v;\n  bool ok=true;\n  for(int j=1;j<(int)howToGet[pos].size();j++){\n    nv[j]-=howToGet[pos][j];\n    if(nv[j]<0){\n      ok=false;\n      break;\n    }\n  }\n  // 1セット取れるならとる\n  if(ok)res=max(res,dfs2(pos,nv)+1);\n  // 取らずに次のセットへ\n  res=max(res,dfs2(pos+1,v));\n  if(lim<1000000){\n    lim++;\n    return dp[pos][v]=res;\n  }\n  else\n    return dp[pos][v];\n}\n\nint main(){\n  dfs(0,10,vector<char>());\n  while(cin>>N&&N){\n    lim=0;\n    vector<char> cnts;\n    for(int i=0;i<N;i++)cin>>MS[i];\n    for(int i=0;i<=10;i++)cnts.push_back(0);\n    for(int i=0;i<N;i++)cnts[MS[i]]++;\n    for(int i=0;i<43;i++)dp[i].clear();\n    int res=dfs2(0,cnts);\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nmap<wolf,int> dp;\nint solve(wolf a,int b){\n\tif((int)(dp.count(a)))return dp[a];\n\tint ret=0;\n\tfor(int i=b;i<36;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1 << 30)\nvector< vector<int> > tens;;\nvector<int> tmp(10);\nint n;\nint num[10];\nvoid tendfs(int num, int now, int sum = 0, int cnt = 0){\n    if(sum == 10){\n\tif(cnt > 2)\ttens.push_back(tmp);\n\treturn;\n    }\n    if(num > 10 - sum)return;\n    tmp[num]++;\n    tendfs(num, now, sum + num, cnt + 1);\n    tmp[num]--;\n    tendfs(num + 1, now, sum, cnt);\n}\n\nint dfs(int n, int dep = 0){\n    if(n == tens.size())return dep;\n    int res = dfs(n + 1, dep);\n    int p = INF;\n    int ok = 1;\n    int qq = 0;\n    for(int i = 1;i <= 10;i++){\n\tnum[i] -= tens[n][i];\n\tqq += tens[n][i];\n\tif(num[i] < 0)ok = 0;\n    }\n    if(ok)res = max(dfs(n, dep + 1), res);\n    for(int i = 1;i <= 10;i++){\n\tnum[i] += tens[n][i];\n    }\n    return res;\n}\nint x;\nint main(){\n    tendfs(1, 1);\n    while(cin >> n, n){\n\tint ans = 0;\n\tfill(num, num + 10, 0);\n\tfor(int i = 0;i < n;i++)cin >> x,num[x]++;\n\tfor(int i = 1;i < 5;i++){\n\t    int t = min(num[i], num[10 - i]);\n\t    num[i] -= t;\n\t    num[10 - i] -= t;\n\t    ans += t;\n\t}\n\tans += num[5] / 2;\n\tnum[5] %= 2;\n\tcout << ans + dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint t[10];\n\nint solve(int s = 10, int k = 9, int z = 999){\n\tint c = 0;\n\n\twhile( k && c < z ){\n\t\tint a;\n\t\tif( k != s - k ){\ta = min( t[k], t[s - k] );\t}\n\t\telse{\ta = t[k] / 2;\t}\n\n\t\tif( c + a >= z ){\n\t\t\tt[k] -= z - c;\n\t\t\tt[s - k] -= z - c;\n\t\t\treturn z;\n\t\t}\n\n\t\tc += a;\n\t\tt[k] -= a;\n\t\tif( k != s - k ){\n\t\t\tt[s - k] -= a;\n\t\t}\n\t\t\n\t\twhile( t[k] > 0 && c < z ){\n\t\t\t--t[k];\n\t\t\tif( solve( s - k, min(k, s - k - 1), 1) ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++t[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( c == z ){\n\t\t\treturn z;\n\t\t}\n\t\t\n\t\t--k;\n\t}\n\n\treturn c;\n}\n\nint main(){\n\tint n, m;\n\tfor( ; scanf(\"%d\", &n), n; ){\n\t\tfill(t, t + 10, 0);\n\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf(\"%d\", &m);\n\t\t\t++t[m];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve() );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N;\nmap< vector<int>, int > dp;\n\nint solve(vector<int>& vec, int sum = 0, int id = 1) {\n    int res = 0;\n    if(sum == 10) {\n        res++;\n        sum = 0;\n    }\n    if(dp.count(vec)) return dp[vec];\n\n    for(int i=id; i<=9; i++) {\n        if(vec[i] > 0) {\n            vec[i]--; sum += i;\n            res += solve(vec, sum, i);\n            vec[i]++; sum -= i;\n        }\n    }\n\n    if(sum == 0) dp[vec] = res;\n    return res;\n}\n\nsigned main() {\n    while(cin >> N, N) {\n        dp.clear();\n        vector<int> countManju(11);\n\n        for(int i=0; i<N; i++) {\n            int val; cin >> val;\n            countManju[val]++;\n        }\n        \n        int ans = 0;\n        for(int i=1; i<5; i++) {\n            int add = min(countManju[i], countManju[10 - i]);\n            ans += add;\n            countManju[i     ] -= add;\n            countManju[10 - i] -= add;\n        }\n        ans += countManju[5] / 2;\n        countManju[5] %= 2;\n\n        ans += solve(countManju);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > a;\nvoid manju(vector<int>& b, int prev, int sum, const vector<int>& x)\n{\n    if(sum > 10)\n        return;\n    if(sum == 10){\n        if(accumulate(b.begin(), b.end(), 0) > 2)\n            a.push_back(b);\n        return;\n    }\n\n    for(int i=prev; i<=9; ++i){\n        if(x[i] == 0)\n            continue;\n        ++ b[i];\n        sum += i;\n        manju(b, i, sum, x);\n        sum -= i;\n        -- b[i];\n    }\n}\n\nvector<map<vector<int>, int> > memo;\nint solve(const vector<int>& x, int k)\n{\n    if(k >= a.size())\n        return 0;\n\n    if(memo[k].find(x) != memo[k].end())\n        return memo[k][x];\n\n    int ret = solve(x, k+1);\n\n    vector<int> y = x;\n    bool ok = true;\n    for(int i=1; i<=9; ++i){\n        y[i] -= a[k][i];\n        if(y[i] < 0)\n            ok = false;\n    }\n    if(ok)\n        ret = max(ret, solve(y, k) + 1);\n\n    return memo[k][x] = ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> x(10, 0);\n        for(int i=0; i<n; ++i){\n            int y;\n            cin >> y;\n            if(x[10-y] > 0)\n                -- x[10-y];\n            else\n                ++ x[y];\n        }\n\n        a.clear();\n        vector<int> b(10, 0);\n        manju(b, 1, 0, x);\n\n        memo.assign(a.size(), map<vector<int>, int>());\n        cout << solve(x, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nint manto[100];\nint nowmax[100];\nbool flag[100];\n\nint search(int num, int ko)\t// 合計, 10個出来た個数\n{\n\n\tif(nowmax[num] > ko)\n\t\treturn nowmax[num];\n\tif(num > 10){\n\t\tif(nowmax[num] < ko)\n\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n\n\tif(num == 10){\n\t\tnum = 0;\n\t\tko++;\n\t}\n\tif(!find(flag,flag+N,true)){\n\t\tif(nowmax[num] < ko)\n\t\t\tnowmax[num] = ko;\n\t\treturn ko;\n\t}\n\n\tint ans = ko;\n\tfor(int i = 0; i < N; i++){\n\t\tif(flag[i]){\n\t\t\tif(nowmax[num] > ko){\n\t\t\t\tans = max(ans,nowmax[num]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag[i] = false;\n\t\t\tans = max(ans,search(num + manto[i], ko));\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void)\n{\n\n\twhile(cin >> N, N){\n\t\tM = N;\t//作業用\n\t\tfill(flag, flag+N, true);\n\t\tfill(nowmax,nowmax+N,0);\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tcin >> manto[i];\n\n\t\tint ans = search(0,0);\n\t\tprintf(\"%d\\n\", ans);\n\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nstruct Combination{\n    std::vector<int> comb;\n    int n;\n};\n\nstd::vector<int> v(10);\nstd::vector<Combination> C;\n\nstd::string to_string(std::vector<int> &v){\n    std::string s = \"\";\n    for(auto i : v){\n        s += std::to_string(i) + \", \";\n    }\n    return s;\n}\n\nbool compare(const Combination &lc, const Combination &rc){\n    return lc.n < rc.n;\n}\n\n// index以降からwの重さのパックをつくる\nvoid pack(int index, int w, int n){\n    if(w==0){\n        C.push_back({v, n});\n    }\n\n    for(int i=index;i<=w&&i<10;i++){\n        v[i]++;\n        pack(i, w-i, n+1);\n        v[i]--;\n    }\n}\n\nint main(){\n    pack(1, 10, 0);\n    std::sort(C.begin(), C.end(), compare);\n\n    // REP(i, C.size()){\n    //     for(auto n : C[i].comb){\n    //         printf(\"%d, \", n);\n    //     }\n    //     puts(\"\");\n    // }\n\n    int N, a[10];\n    while(std::cin >> N, N){\n        std::fill(a, a+10, 0);\n        REP(i, N){\n            int n;\n            std::cin >> n;\n\n            a[n]++;\n        }\n\n        int res = 0;\n        REP(i, C.size()){\n            std::vector<int> v = C[i].comb;\n            int n = INF;\n            FOR(j, 1, 10){\n                if(v[j] == 0){continue;}\n                n = std::min(n, a[j] / v[j]);\n            }\n            if(!n || n == INF){continue;}\n            res += n;\n            FOR(j, 1, 10){\n                a[j] -= v[j] * n;\n            }\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<vector<int> > sum10;\nvector<int> as;\n\nvoid dfs(vector<int> v, int now, int sum) {\n  if (sum == 10) {\n    sum10.push_back(v);\n    return;\n  }\n  if (now == as.size()) return;\n  dfs(v,now+1,sum);\n  if (sum + as[now] <= 10) {\n    v.push_back(now);\n    dfs(v,now,sum+as[now]);\n  }\n}\n\nmap<vector<int> , int> mp[50];\n\nint solve(int now, vector<int> v) {\n  if (now == sum10.size()) return 0;\n  if (mp[now].count(v)) return mp[now][v];\n\n  int a;\n  int &r = a;\n  if (now<sum10.size()-5) r = mp[now][v];\n  int res = 0;\n  REP(i,100) {\n    bool dame = 0;\n    res = max(res, solve(now+1, v) + i);\n    FOR(it, sum10[now]) {\n      if (v[*it]-- == 0) dame = 1;\n    }\n    if(dame) break;\n  }\n  if (now<sum10.size()-5) return r = res;\n  return res;\n}\n\nint a[10];\n\nint main() {\n  // REP(i,9) as.push_back(i+1);\n  // vector<int> t;\n  // dfs(t,0,0);\n  // FOR(it, sum10) {\n  //   FOR(jt, *it) cout << *jt << \" \";\n  //   cout << endl;\n  // }\n  int n;\n  while(cin>>n,n) {\n    int ans = 0;\n    memset(a,0,sizeof(a));\n    REP(i,n) {\n      int b;cin >> b;\n      if (b >= 10) {\n        if (b == 10) ans++;\n      } else {\n        a[b]++;\n      }\n    }\n    for (int i=1; i<=4; ++i) {\n      int j = 10-i;\n      int m = min(a[i], a[j]);\n      a[i] -= m;\n      a[j] -= m;\n      ans += m;\n    }\n    ans += a[5] / 2;\n    a[5] -= a[5]/2*2;\n    vector<int> v;\n    as.clear();\n    REP(i,10) if (a[i]) {\n      as.push_back(i);\n      v.push_back(a[i]);\n    }\n    sum10.clear();\n    vector<int> t;\n    dfs(t,0,0);\n    REP(i,sum10.size()) mp[i].clear();\n    ans += solve(0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint ans;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i<=5;i++){\n        if((i != 5 && v[i] >= 1 && v[10-i] >= 1) || (i == 5 && v[5] >= 2)){\n            vector<int> v2 = v;\n            v2[i]--;\n            v2[10-i]--;\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        if(n < m) break;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 2 && v[1] >= 7){\n        v[2] -= 2;\n        v[1] -= 7;\n        dfs(v,cnt+1);\n        return;\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        dfs(v,cnt+1);\n        return;\n    }\n}\n\n\nint main(){\n    int n;\n\twhile(cin >> n && n){\n        vector<int> v(10,0);\n\t\tans = 0;\n\t\tfor(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 500000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 < res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint ans;\nset<vector<int> > ss;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    ans = max(ans,cnt);\n\n    //2: a+b\n    for(int i=1;i+i<=10;i++){\n        int j = 10 - i;\n        vector<int> v2 = v;\n        if(v2[i] > 0){\n            v2[i]--;\n            if(v2[j] > 0){\n                v2[j]--;\n                if(ss.find(v2) != ss.end()) continue;\n                ss.insert(v2);\n                f = true;\n                dfs(v2,cnt+1);\n            }\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        if(ss.find(v2) != ss.end()) continue;\n                        ss.insert(v2);\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                if(ss.find(v2) != ss.end()) continue;\n                                ss.insert(v2);\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        if(ss.find(v2) != ss.end()) continue;\n                                        ss.insert(v2);\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                if(ss.find(v2) != ss.end()) continue;\n                                                ss.insert(v2);\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        if(ss.find(v2) != ss.end()) continue;\n                                                        ss.insert(v2);\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 1 && v[1] >= 8){\n        vector<int> v2 = v;\n        v2[2] -= 1;\n        v2[1] -= 8;\n        if(ss.find(v2) == ss.end()){\n            ss.insert(v2);\n            dfs(v2,cnt+1);\n            return;\n        }\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        if(ss.find(v) != ss.end()) return;\n        ss.insert(v);\n        dfs(v,cnt+1);\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        ss.clear();\n        vector<int> v(10,0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<stdio.h>\n#include<map>\nusing namespace std;\nstruct wolf{\n\tint t[9];\n\twolf(){}\n};\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<9;i++)if(a.t[i]<b.t[i])return true;\n\treturn false;\n}\nint v[9];\nint D[36][9]={\n{2,0,0,0,0,0,0,1,0},\n{1,1,0,0,0,0,1,0,0},\n{3,0,0,0,0,0,1,0,0},\n{1,0,1,0,0,1,0,0,0},\n{0,2,0,0,0,1,0,0,0},\n{2,1,0,0,0,1,0,0,0},\n{4,0,0,0,0,1,0,0,0},\n{1,0,0,1,1,0,0,0,0},\n{0,1,1,0,1,0,0,0,0},\n{2,0,1,0,1,0,0,0,0},\n{1,2,0,0,1,0,0,0,0},\n{3,1,0,0,1,0,0,0,0},\n{5,0,0,0,1,0,0,0,0},\n{0,1,0,2,0,0,0,0,0},\n{0,0,2,1,0,0,0,0,0},\n{2,0,0,2,0,0,0,0,0},\n{1,1,1,1,0,0,0,0,0},\n{0,3,0,1,0,0,0,0,0},\n{3,0,1,1,0,0,0,0,0},\n{2,2,0,1,0,0,0,0,0},\n{4,1,0,1,0,0,0,0,0},\n{6,0,0,1,0,0,0,0,0},\n{1,0,3,0,0,0,0,0,0},\n{0,2,2,0,0,0,0,0,0},\n{2,1,2,0,0,0,0,0,0},\n{4,0,2,0,0,0,0,0,0},\n{1,3,1,0,0,0,0,0,0},\n{3,2,1,0,0,0,0,0,0},\n{5,1,1,0,0,0,0,0,0},\n{7,0,1,0,0,0,0,0,0},\n{0,5,0,0,0,0,0,0,0},\n{2,4,0,0,0,0,0,0,0},\n{4,3,0,0,0,0,0,0,0},\n{6,2,0,0,0,0,0,0,0},\n{8,1,0,0,0,0,0,0,0},\n{10,0,0,0,0,0,0,0,0}\n};\nlong long conv(wolf a){\n\tlong long ret=0;\n\tfor(int i=0;i<9;i++){\n\t\tret*=128;\n\t\tret+=a.t[i];\n\t}\n\treturn ret;\n}\nmap<long long,int> dp;\nint solve(wolf a,int b){\n\tif((int)(dp.count(conv(a))))return dp[conv(a)];\n\tint ret=0;\n\tfor(int i=b;i>=0;i--){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(a.t[j]<D[i][j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int j=0;j<9;j++)a.t[j]-=D[i][j];\n\t\t\tret=max(ret,solve(a,i)+1);\n\t\t\tfor(int j=0;j<9;j++)a.t[j]+=D[i][j];\n\t\t}\n\t}\n\treturn dp[conv(a)]=ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tb--;\n\t\t\tv[b]++;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=5;i<9;i++){\n\t\t\tint V=min(v[i],v[8-i]);\n\t\t\tret+=V;\n\t\t\tv[i]-=V;\n\t\t\tv[8-i]-=V;\n\t\t}\n\t\tret+=v[4]/2;\n\t\tv[4]%=2;\n\t\twolf S;\n\t\tfor(int i=0;i<9;i++)S.t[i]=v[i];\n\t\tprintf(\"%d\\n\",ret+solve(S,35));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int CANDICATE_N = 36;\n// 最初の6個は5を含む\nint a[CANDICATE_N] = {65808, 69633, 65569, 65794, 65555, 65541, 277, 52, 4116, 516, 1048580, 291, 4102, 4355, 16777219, 66, 4130, 530, 1048594, 38, 8194, 268435458, 305, 263, 4369, 16777233, 769, 1048833, 24, 80, 4144, 544, 1048608, 10, 8208, 4608};\n\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nint N, manju[10];\nint rest[4], rest_b, base[4];\nchar (*dp)[CANDICATE_N];\n\n// i: a_index, j: rest_index\ninline int at(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(rest[j]-1)) & 0xf;\n}\n\n// i: rest_index\ninline int at2(int i){\n    // if(4 <= i || i < 0){puts(\"-1\"); exit(0);}\n    return manju[rest[i]];\n}\n\n// i: a_index, j: rest_index\ninline int at3(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return at2(j) - at(i, j);\n}\n\ninline char& at4(int i, int j, int k, int l, int index){\n    // if(i+base[0]*(j+base[1]*(k+base[2]*l)) >= 902394){puts(\"-1\"); exit(0);}\n    return dp[i+base[0]*(j+base[1]*(k+base[2]*l))][index];\n}\n\ninline int at5(int i, int j){\n    // if(CANDICATE_N <= i || i < 0 || 4 <= j && j < 0){puts(\"-1\"); exit(0);}\n    return a[i] >> (4*(j-1)) & 0xf;\n}\n\ninline bool can(int a, int b, int c, int d, int index){\n    FOR(i, 1, 9){\n        //printf(\"index=%d, i=%d (in can)\\n\", index, i);\n        if(i == 5){continue;}\n        if(!(rest_b >> i & 1) && at5(index, i) > 0){return false;}\n    }\n\n    if(at(index, 0) == 0 && at(index, 1) == 0 &&\n       at(index, 2) == 0 && at(index, 3) == 0){;return false;}\n\n    return a >= at(index, 0) &&\n        b >= at(index, 1) &&\n        c >= at(index, 2) &&\n        d >= at(index, 3);\n}\n\nchar rec(int a, int b, int c, int d, int index){\n    if(index == CANDICATE_N){return 0;}\n    if(a == 0 && b == 0 && c == 0 && d == 0){return 0;}\n    if(at4(a, b, c, d, index) != -1){return at4(a, b, c, d, index);}\n    \n    char res = rec(a, b, c, d, index+1);\n    if(can(a, b, c, d, index)){\n        res = std::max(res, static_cast<char>(rec(a-at(index, 0), b-at(index, 1), c-at(index, 2), d-at(index, 3), index)+1));\n    }\n\n    return at4(a, b, c, d, index) = res;\n}\n\nint main(){\n    dp = new char[902394][CANDICATE_N];\n\n    while(std::cin >> N, N){\n        memset(manju, 0, sizeof(manju));\n\n        REP(i, N){\n            int w;\n            std::cin >> w;\n\n            manju[w] += 1;\n        }\n\n        // FOR(i, 1, 10){printf(\"%d: %d\\n\", i, manju[i]);}\n\n        char r1 = 0;\n        FOR(i, 1, 5){\n            int mn = std::min(manju[i], manju[10-i]);\n            r1 += mn;\n            manju[i] -= mn; manju[10-i] -= mn;\n        }\n\n        r1 += manju[5] >> 1;\n        manju[5] &= 1;\n\n        {\n            int n = 0;\n            std::fill(rest, rest+4, 1);\n            rest_b = 0;\n            FOR(i, 1, 10){\n                if(i == 5 || i == 9){continue;}\n                if(manju[i] > 0){\n                    rest[n] = i;\n                    rest_b |= 1 << i;\n                    n += 1;\n                }\n            }\n\n            std::sort(rest, rest+4);\n\n            REP(i, 4){\n                for(int p : prime){if(manju[rest[i]] < p){base[i] = p; break;}}\n            }\n        }\n\n        memset(dp, -1, 902394*CANDICATE_N);\n\n        char r2 = rec(at2(0), at2(1), at2(2), at2(3), 6);\n        if(manju[5] == 1){\n            REP(i, 6){\n                if(can(at2(0), at2(1), at2(2), at2(3), i)){\n                    r2 = std::max(r2, static_cast<char>(rec(at3(i, 0), at3(i, 1), at3(i, 2), at3(i, 3), 6) + 1));\n                }\n            }\n        }\n\n        std::cout << (r1+r2) << std::endl;\n    }\n\n    delete[] dp;\n\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint m[10];\nvector<vector<int> > pattern;\nvoid rekkyo(int sum,int i){\n\tstatic vector<int> hoge(10);\n\tint res=0;\n\tif(sum==10){\n\t\tpattern.push_back(hoge);\n\t\treturn;\n\t}\n\tif(10<sum || i==10)return;\n\tfor(int j=0;sum+i*j<=10;j++){\n\t\thoge[i]=j;\n\t\trekkyo(sum+i*j,i+1);\n\t}\n\thoge[i]=0;\n\treturn;\n}\nbool ok(int num[10]){\n\tfor(int i=1;i<10;i++){\n\t\tif(m[i] < num[i])return false;\n\t}\n\treturn true;\n}\nint search(int i){\n\tint res=0,tmp;\n\tstatic int num[10];\n\tif(i==pattern.size())return 0;\n\tfor(int j=0;j<=50;j++){\n\t\tfor(int k=0;k<10;k++)num[k] += j*pattern[i][k];\n\t\tif(ok(num)){\n\t\t\ttmp = j+search(i+1);\n\t\t\tres = max(res,tmp);\n\t\t}\n\t\tfor(int k=0;k<10;k++)num[k] -= j*pattern[i][k];\n\t}\n\treturn res;\n}\nint main(){\n\tint n,t,ans;\n\trekkyo(0,1);\n\twhile(cin>>n&&n){\n\t\tans=0;\n\t\tfill(m,m+10,0);\n\t\twhile(n--){\n\t\t\tcin>>t;\n\t\t\tm[t]++;\n\t\t}\n\t\tcout<<search(0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint ans;\n\nset<vector<int> > ss;\n\nvoid dfs(vector<int> v, int cnt){\n    bool f = false;\n\n    ans = max(ans,cnt);\n    if(ss.find(v) != ss.end()) return;\n    ss.insert(v);\n\n    //2: a+b\n    for(int i=1;i<=5;i++){\n        if((i != 5 && v[i] >= 1 && v[10-i] >= 1) || (i == 5 && v[5] >= 2)){\n            vector<int> v2 = v;\n            v2[i]--;\n            v2[10-i]--;\n            f = true;\n            dfs(v2,cnt+1);\n        }\n    }\n    if(f) return;\n\n    //3: a+b+c\n    for(int i=1;i+i+i<=10;i++){\n        for(int j=i;i+j+j<=10;j++){\n            int k = 10 - i - j;\n            vector<int> v2 = v;\n            if(v2[i] > 0){\n                v2[i]--;\n                if(v2[j] > 0){\n                    v2[j]--;\n                    if(v2[k] > 0){\n                        v2[k]--;\n                        f = true;\n                        dfs(v2,cnt+1);\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //4: a+b+c+d\n    for(int i=1;i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k<=10;k++){\n                int l = 10 - i - j - k;\n                vector<int> v2 = v;\n                if(v2[i] > 0){\n                    v2[i]--;\n                    if(v2[j] > 0){\n                        v2[j]--;\n                        if(v2[k] > 0){\n                            v2[k]--;\n                            if(v2[l] > 0){\n                                v2[l]--;\n                                f = true;\n                                dfs(v2,cnt+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //5: a+b+c+d+e\n    for(int i=1;i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l<=10;l++){\n                    int m = 10 - i - j - k - l;\n                    vector<int> v2 = v;\n                    if(v2[i] > 0){\n                        v2[i]--;\n                        if(v2[j] > 0){\n                            v2[j]--;\n                            if(v2[k] > 0){\n                                v2[k]--;\n                                if(v2[l] > 0){\n                                    v2[l]--;\n                                    if(v2[m] > 0){\n                                        v2[m]--;\n                                        f = true;\n                                        dfs(v2,cnt+1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //6: a+b+c+d+e+f\n    for(int i=1;i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m<=10;m++){\n                        int n = 10 - i - j - k - l - m;\n                        if(n < m) break;\n                        vector<int> v2 = v;\n                        if(v2[i] > 0){\n                            v2[i]--;\n                            if(v2[j] > 0){\n                                v2[j]--;\n                                if(v2[k] > 0){\n                                    v2[k]--;\n                                    if(v2[l] > 0){\n                                        v2[l]--;\n                                        if(v2[m] > 0){\n                                            v2[m]--;\n                                            if(v2[n] > 0){\n                                                v2[n]--;\n                                                f = true;\n                                                dfs(v2,cnt+1);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //7: a+b+c+d+e+f+g\n    for(int i=1;i+i+i+i+i+i+i<=10;i++){\n        for(int j=i;i+j+j+j+j+j+j<=10;j++){\n            for(int k=j;i+j+k+k+k+k+k<=10;k++){\n                for(int l=k;i+j+k+l+l+l+l<=10;l++){\n                    for(int m=l;i+j+k+l+m+m+m<=10;m++){\n                        for(int n=m;i+j+k+l+m+n+n<=10;n++){\n                            int o = 10 - i - j - k - l - m - n;\n                            vector<int> v2 = v;\n                            if(v2[i] > 0){\n                                v2[i]--;\n                                if(v2[j] > 0){\n                                    v2[j]--;\n                                    if(v2[k] > 0){\n                                        v2[k]--;\n                                        if(v2[l] > 0){\n                                            v2[l]--;\n                                            if(v2[m] > 0){\n                                                v2[m]--;\n                                                if(v2[n] > 0){\n                                                    v2[n]--;\n                                                    if(v2[o] > 0){\n                                                        v2[o]--;\n                                                        f = true;\n                                                        dfs(v2,cnt+1);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(f) return;\n\n    //8: a+b+c+d+e+f+g+h\n    if(v[3] >= 1 && v[1] >= 7){\n        vector<int> v2 = v;\n        v2[3] -= 1;\n        v2[1] -= 7;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(v[2] >= 2 && v[1] >= 6){\n        vector<int> v2 = v;\n        v2[2] -= 2;\n        v2[1] -= 6;\n        f = true;\n        dfs(v2,cnt+1);\n    }\n    if(f) return;\n\n    //9: a+b+c+d+e+f+g+h+i\n    if(v[2] >= 2 && v[1] >= 7){\n        v[2] -= 2;\n        v[1] -= 7;\n        dfs(v,cnt+1);\n        return;\n    }\n\n    //10: a+b+c+d+e+f+g+h+i+j\n    if(v[1] >= 10){\n        v[1] -= 10;\n        dfs(v,cnt+1);\n        return;\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        ss.clear();\n        vector<int> v(10,0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            int a;\n            cin >> a;\n            v[a]++;\n        }\n\n        dfs(v,0);\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<vector<int> > sv;\n// vv[k] := 3個以上の合計が10になる饅頭の組合せ\nvector<vector<int> > vv;\n// v_sum[k] := vv[k]の合計\nint v_sum[40] = {0};\n// memo[k] := k 番目の組合せで饅頭が作れない\nbool memo[40];\n\n// v := 饅頭の集合, sum := v[0] + v[1] + ... + v[v.size()-1] (合計)\nvoid f(vector<int> v, int sum = 0){\n\tif( sum == 10 ){\n\t\tif( 3 <= v.size() ){ \n\t\t\tsort(v.begin(), v.end());\n\t\t\tsv.insert(v);\n\t\t}\n\t}else if( sum < 10 ){\n\t\tfor(int i = 9; i >= 1 ; i-- ){\n\t\t\tv.push_back(i);\n\t\t\tf(v, sum + i);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\n\n// 3個以上で10になる饅頭の組合せを事前に列挙しておく\nvoid init(){\n\tvector<int> v;\n\tf(v);\n\tfor(set<vector<int> >::iterator it = sv.begin() ; it != sv.end() ; ++it ){\n\t\tvv.push_back(*it);\n\t}\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < vv[i].size() ; j++ ){\n\t\t\tsum += vv[i][j];\n\t\t}\n\t\tv_sum[i] = sum;\n\t}\n}\n\n// v[k](k番目の合計が10になる組合せ)が使えるかどうかを返す\nbool check(int k, vector<int> s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] == 0 ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\ts[e]--;\n\t\t}\n\t}\n\treturn true;\n}\n\n// v[k](k番目の合計が10になる組合せ)を使う\nvoid used(int k, vector<int> &s){\n\tfor(int i = 0 ; i < vv[k].size() ; i++ ){\n\t\tint e = vv[k][i];\n\t\tif( s[e] ) s[e]--;\n\t}\n}\n\nint foo;\n\n// DFS\nvoid dfs(int &res, int cnt, int sum, vector<int> &s){\n\t// 解の更新\n\tres = max(res, cnt);\n\t\n\tfoo++;\n\tif( 800000 < foo ) return;\n\t\n\tif( sum < 10 ) return;\n\t// もう解が更新できない時点で探索打ち切る\n\tif( cnt + sum / 10 <= res ) return;\n\t\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t\n\t\tif( check(i, s) ){\n\t\t\tvector<int> s_ = s;\n\t\t\tused(i, s_);\n\t\t\tdfs(res, cnt + 1, sum - v_sum[i], s_);\n\t\t}\n\t}\n}\n\nint solve(vector<int> &s){\n\tfoo = 0;\n\tint sum = 0, res = 0;\n\tfor(int i = 0 ; i < vv.size() ; i++ ){\n\t\tif( !check(i, s) ){\n\t\t\tmemo[i] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 1 ; i <= 9 ; i++ ) sum += i * s[i];\n\tdfs(res, 0, sum, s);\n\treturn res;\n}\n\nint main(){\n\t// 3個以上で10になる饅頭の組合せを事前に列挙しておく\n\tinit();\n\t\n\tint n;\n\twhile( cin >> n, n ){\n\t\t\n\t\t// s[k] := 重さkの饅頭の個数\n\t\tvector<int> s(12, 0);\n\t\tfill(memo, memo + 40, false);\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\ts[e]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t// 2個で10になる組合せは貪欲に使う\n\t\tfor(int i = 1 ; i <= 4 ; i++ ){\n\t\t\tint j = 10 - i;\n\t\t\tint k = min(s[i], s[j]);\n\t\t\ts[i] -= k;\n\t\t\ts[j] -= k;\n\t\t\tans += k;\n\t\t}\n\t\tans += s[5]/2;\n\t\ts[5] %= 2;\n\t\t// 3個以上で10になる組合せを探索する\n\t\tans += solve(s);\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nvoid part(int x, vector<int> &d, vector<vector<int> > &a, int pre)\n{\n\tif ( x == 0 ) {\n\t\ta.push_back(d);\n\t}\n\t\n\tfor (int i = pre; i >= 1; --i) {\n\t\tif (x - i >= 0) {\n\t\t\td.push_back(i);\n\t\t\tpart(x - i, d, a, i);\n\t\t\td.pop_back();\n\t\t}\n\t}\n}\n\nconst int NPAT = 41;\nint res;\nint greedy;\nint parts[NPAT][9];\n\ninline int ideal(int m[])\n{\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < 9; ++i) {\n\t\tret += (i+1) * m[i];\n\t}\n\n\treturn ret / 10;\n}\n\nbool solve(int m[], int pre, int step, bool bgreedy)\n{\n\tif ( res < step ) {\n\t\tres = step;\n\t}\n\t\n\tif ( step + ideal(m) <= res ) {\n\t\treturn false;\n\t}\n\n\tif (!bgreedy) {\n\t\tif (step + ideal(m) <= greedy) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (int i = pre; i < NPAT; ++i) {\n\t\tbool packable = true;\n\t\t\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tif (m[j] < parts[ i ][ j ]) {\n\t\t\t\tpackable = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( packable ) {\n\t\t\t// Translate\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tm[j] -= parts[ i ][ j ];\n\t\t\t}\n\n\t\t\tif ( bgreedy ){\n\t\t\t\tif ( solve(m, i, step + 1, greedy) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsolve(m, i, step + 1, greedy);\n\t\t\t}\n\t\t\t\n\t\t\t// Rollback\n\t\t\tfor ( int j = 0; j < 9; ++j ) {\n\t\t\t\tm[j] += parts[ i ][ j ];\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\tvector<int> d;\n\tvector< vector<int> > s;\n\tpart(10, d, s, 9);\n\n\tfor (int sz = 2; sz < 22; ++sz){\n\t\tfor (int i = 0; i < s.size(); ++i){\n\t\t\tif ( s[i].size() == sz ){\n\t\t\t\tfor (int j = 0; j < s[i].size(); ++j){\n\t\t\t\t\tparts[i][s[i][j] - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tint m[9] = { 0, };\n\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[tmp - 1]++;\n\t\t}\n\n\t\tres = 0;\n\t\tgreedy = 0;\n\t\tsolve(m, 0, 0, true);\n\t\tgreedy = res;\n\t\tres = 0;\n\t\tsolve(m, 0, 0, false);\n\n\t\tif (res < greedy){\n\t\t\tres = greedy;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju { \n\tint k[10];\n};\nbool operator< (const Manju& m1, const Manju& m2) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (m1.k[i] < m2.k[i])return true; if (m1.k[i] > m2.k[i])return false;\n\t}\n\treturn false;\n}\nvector<Manju>dp[11][11], S;//dp[end][sum]\nmap<Manju, int>M;\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<pair<int, Manju>>Q; Q.push(make_pair(0, T)); M[T] = 1;\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front().second; int L = Q.front().first; Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\t\tfor (int i = L; i < S.size(); i++) {\n\t\t\tManju RR = R;\n\t\t\twhile (true) {\n\t\t\t\tbool OK = true;\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (S[i].k[j] > RR.k[j])OK = false;\n\t\t\t\t}\n\t\t\t\tif (OK == false)break;\n\t\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[i].k[j];\n\t\t\t\tif (M[RR] != 1) { Q.push(make_pair(i + 1, RR)); M[RR] = 1; }\n\t\t\t}\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; M.clear(); if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ynymxiaolongbao is a really pro!\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct Manju { int k[10]; };\nvector<Manju>dp[11][11], S;//dp[end][sum]\nvoid init() {\n\tManju MM; for (int i = 0; i < 10; i++)MM.k[i] = 0; dp[0][0].push_back(MM);\n\tfor (int i = 0; i < 9; i++) {\n\t\tfor (int j = 0; j <= 10; j++) {\n\t\t\tfor (int k = 0; k < dp[i][j].size(); k++) {\n\t\t\t\tfor (int l = 0; l <= 10; l++) {\n\t\t\t\t\tint SUM = j + l*(i + 1); Manju P = dp[i][j][k];\n\t\t\t\t\tif (SUM > 10)continue;\n\t\t\t\t\tP.k[i + 1] = l; dp[i + 1][SUM].push_back(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = dp[9][10];\n}\nint manju(Manju T) {\n\tint maxn = 0, sums = 0; for (int i = 0; i < 10; i++)sums += i*T.k[i];\n\tqueue<pair<int, Manju>>Q; Q.push(make_pair(0, T));\n\twhile (!Q.empty()) {\n\t\tManju R = Q.front().second; int L = Q.front().first; Q.pop();\n\t\tint C = sums; for (int j = 0; j < 10; j++)C -= R.k[j] * j;\n\t\tmaxn = max(maxn, C);\n\t\tfor (int i = L; i < S.size(); i++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (S[i].k[j]>R.k[j])OK = false;\n\t\t\t}\n\t\t\tif (OK == false)continue; Manju RR = R;\n\t\t\tfor (int j = 0; j < 10; j++)RR.k[j] -= S[i].k[j];\n\t\t\tQ.push(make_pair(i, RR));\n\t\t}\n\t}\n\treturn maxn / 10;\n}\nint main() {\n\tinit(); int n;\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; Manju A; for (int i = 0; i < 10; i++)A.k[i] = 0; int adv = 0;\n\t\tfor (int i = 0; i < n; i++) { int W; cin >> W; if (W >= 1 && W <= 9)A.k[W]++; if (W == 10)adv++; }\n\t\tcout << manju(A) + adv << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint a,b[10];\nint f(int i,int s,int j,int t,int k,int u,int l,int v){\n  if(i*s+j*t+k*u+l*v-10)printf(\"%d %d %d %d %d %d %d %d\\n\",i,s,j,t,k,u,l,v);\n  int min=MIN(b[i]/s,b[j]/t);\n  if(k)min=MIN(min,b[k]/u);\n  if(l)min=MIN(min,b[l]/v);\n  b[i]-=min*s;\n  b[j]-=min*t;\n  b[k]-=min*u;\n  b[l]-=min*v;\n  a+=min;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=a=0;i<10;i++)b[i]=0;\n    while(n--){\n    scanf(\"%d\",&i);\n      b[i]++;\n    }\n    a+=b[5]/2;\n    b[5]%=2;\n    f(9,1,1,1,0,0,0,0);\n    f(8,1,2,1,0,0,0,0);\n    f(8,1,1,2,0,0,0,0);\n    f(7,1,3,1,0,0,0,0);\n    f(7,1,2,1,1,1,0,0);\n    f(7,1,1,3,0,0,0,0);\n    f(5,1,3,1,2,1,0,0);\n    f(6,1,4,1,0,0,0,0);\n    f(6,1,3,1,1,1,0,0);\n    f(6,1,2,2,0,0,0,0);\n    f(5,1,4,1,1,1,0,0);\n    f(4,2,2,1,0,0,0,0);\n    f(4,1,3,2,0,0,0,0);\n    f(4,1,3,1,2,1,1,1);\n    f(4,1,3,1,1,3,0,0);\n    f(4,1,1,6,0,0,0,0);\n    f(3,3,1,1,0,0,0,0);\n    f(3,2,2,2,0,0,0,0);\n    f(3,2,2,1,1,2,0,0);\n    f(3,1,2,3,1,1,0,0);\n    f(3,1,2,2,1,3,0,0);\n    f(3,1,2,1,1,5,0,0);\n    f(3,1,1,7,0,0,0,0);\n    a+=b[2]*2+b[1]/10;\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[29][5][2] = {\n{{1,1},{4,1},{5,1}}, {{2,1},{3,1},{5,1}}, {{2,1},{4,2}}, {{3,2},{4,1}},\n{{1,2},{3,1},{5,1}}, {{1,2},{4,2}}, {{1,1},{2,2},{5,1}}, {{1,1},{2,1},{3,1},{4,1}},\n{{1,1},{3,3}}, {{2,3},{4,1}}, {{2,2},{3,2}}, {{1,3},{2,1},{5,1}}, {{1,3},{3,1},{4,1}},\n{{1,2},{2,2},{4,1}}, {{1,2},{2,1},{3,2}}, {{1,1},{2,3},{3,1}}, {{2,5}}, {{1,5},{5,1}},\n{{1,4},{2,1},{4,1}}, {{1,4},{3,2}}, {{1,3},{2,2},{3,1}}, {{1,2},{2,4}}, {{1,6},{4,1}},\n{{1,5},{2,1},{3,1}}, {{1,4},{2,3}}, {{1,7},{3,1}}, {{1,6},{2,2}}, {{1,8},{2,1}}, {{1,10}} };\n\n\nint take(int k)\n{\n\tint i, a, b;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) {\n\t\tb = pair[k][i][1];\n\t\tif (f[a] < b) return 0;\n\t}\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tfor (i = k; ans < sum/10 + tmp && i < 29; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1;\n\t\tf[9] = 0;\n#if 1\n\t\tif (f[8] > 0) {\n\t\t\tif (f[1] >= 2*f[8]) ans += f[8], f[1] -= 2*f[8];\n\t\t\telse if (f[1] & 1) ans += f[1]/2, f[1] = 1;\n\t\t\telse               ans += f[1]/2, f[1] = 0;\n\t\t\tf[8] = 0;\n\t\t}\n\t\tif (f[7] > 0) {\n\t\t\twhile (f[7] > 0 && f[1] > 0 && f[2] > 0) ans++, f[7]--, f[1]--, f[2]--;\n\t\t\twhile (f[7] > 0 && f[1] >= 3) ans++, f[7]--, f[1]-=3;\n\t\t\tf[7] = 0;\n\t\t}\n\t\tif (f[6] > 0) {\n\t\t\twhile (f[6] > 0 && f[1] >  0 && f[3] > 0) ans++, f[6]--, f[1]--, f[3]--;\n\t\t\twhile (f[6] > 0 && f[2] >= 2) ans++, f[6]--, f[2]-=2;\n\t\t\twhile (f[6] > 0 && f[1] >= 2 && f[2] > 0) ans++, f[6]--, f[1]-=2, f[2]--;\n\t\t\twhile (f[6] > 0 && f[1] >= 4) ans++, f[6]--, f[1]-=4;\n\t\t\tf[6] = 0;\n\t\t}\n#endif\n\t\tfor (sum = 0, i = 1; i <= 8; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint a,b[10];\nint f(int i,int s,int j,int t,int k,int u,int l,int v){\n  if(i*s+j*t+k*u+l*v-10)printf(\"%d %d %d %d %d %d %d %d\\n\",i,s,j,t,k,u,l,v);\n  int min=MIN(b[i]/s,b[j]/t);\n  if(k)min=MIN(min,b[k]/u);\n  if(l)min=MIN(min,b[l]/v);\n  b[i]-=min*s;\n  b[j]-=min*t;\n  b[k]-=min*u;\n  b[l]-=min*v;\n  a+=min;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=a=0;i<10;i++)b[i]=0;\n    while(n--){\n    scanf(\"%d\",&i);\n      b[i]++;\n    }\n    a+=b[5]/2;\n    b[5]%=2;\n    f(9,1,1,1,0,0,0,0);\n    f(8,1,2,1,0,0,0,0);\n    f(8,1,1,2,0,0,0,0);\n    f(7,1,3,1,0,0,0,0);\n    f(7,1,2,1,1,1,0,0);\n    f(7,1,1,3,0,0,0,0);\n    f(6,1,4,1,0,0,0,0);\n    f(6,1,3,1,1,1,0,0);\n    f(6,1,2,2,0,0,0,0);\n    f(6,1,2,1,1,2,0,0);\n    f(6,1,1,4,0,0,0,0);\n    f(5,1,4,1,1,1,0,0);\n    f(5,1,3,1,2,1,0,0);\n    f(5,1,3,1,1,2,0,0);\n    f(5,1,2,2,1,1,0,0);\n    f(5,1,2,1,1,3,0,0);\n    f(5,1,1,5,0,0,0,0);\n    f(4,2,2,1,0,0,0,0);\n    f(4,2,1,2,0,0,0,0);\n    f(4,1,3,2,0,0,0,0);\n    f(4,1,3,1,2,1,1,1);\n    f(4,1,3,1,1,3,0,0);\n    f(4,1,2,3,0,0,0,0);\n    f(4,1,2,2,1,2,0,0);\n    f(4,1,2,1,1,4,0,0);\n    f(4,1,1,6,0,0,0,0);\n    f(3,3,1,1,0,0,0,0);\n    f(3,2,2,2,0,0,0,0);\n    f(3,2,2,1,1,2,0,0);\n    f(3,1,2,3,1,1,0,0);\n    f(3,1,2,2,1,3,0,0);\n    f(3,1,2,1,1,5,0,0);\n    f(3,1,1,7,0,0,0,0);\n    a+=b[2]*2+b[1]/10;\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint a,b[10];\nint f(int i,int s,int j,int t,int k,int u,int l,int v){\n  if(i*s+j*t+k*u+l*v-10)printf(\"%d %d %d %d %d %d %d %d\\n\",i,s,j,t,k,u,l,v);\n  int min=MIN(b[i]/s,b[j]/t);\n  if(k)min=MIN(min,b[k]/u);\n  if(l)min=MIN(min,b[l]/v);\n  b[i]-=min*s;\n  b[j]-=min*t;\n  b[k]-=min*u;\n  b[l]-=min*v;\n  a+=min;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=a=0;i<10;i++)b[i]=0;\n    while(n--){\n    scanf(\"%d\",&i);\n      b[i]++;\n    }\n    a+=b[5]/2;\n    b[5]%=2;\n    f(9,1,1,1,0,0,0,0);\n    f(8,1,2,1,0,0,0,0);\n    f(8,1,1,2,0,0,0,0);\n    f(7,1,3,1,0,0,0,0);\n    f(7,1,2,1,1,1,0,0);\n    f(7,1,1,3,0,0,0,0);\n    f(5,1,3,1,2,1,0,0);\n    f(6,1,4,1,0,0,0,0);\n    f(6,1,3,1,1,1,0,0);\n    f(6,1,2,2,0,0,0,0);\n    f(5,1,4,1,1,1,0,0);\n    f(5,1,3,1,1,2,0,0);\n    f(5,1,2,2,1,1,0,0);\n    f(5,1,2,1,1,3,0,0);\n    f(5,1,1,5,0,0,0,0);\n    f(4,2,2,1,0,0,0,0);\n    f(4,1,3,2,0,0,0,0);\n    f(4,1,3,1,2,1,1,1);\n    f(4,1,3,1,1,3,0,0);\n    f(4,1,1,6,0,0,0,0);\n    f(3,3,1,1,0,0,0,0);\n    f(3,2,2,2,0,0,0,0);\n    f(3,2,2,1,1,2,0,0);\n    f(3,1,2,3,1,1,0,0);\n    f(3,1,2,2,1,3,0,0);\n    f(3,1,2,1,1,5,0,0);\n    f(3,1,1,7,0,0,0,0);\n    a+=b[2]*2+b[1]/10;\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint a,b[10];\nint f(int i,int s,int j,int t,int k,int u,int l,int v){\n  if(i*s+j*t+k*u+l*v-10)printf(\"%d %d %d %d %d %d %d %d\\n\",i,s,j,t,k,u,l,v);\n  int min=MIN(b[i]/s,b[j]/t);\n  if(k)min=MIN(min,b[k]/u);\n  if(l)min=MIN(min,b[l]/v);\n  b[i]-=min*s;\n  b[j]-=min*t;\n  b[k]-=min*u;\n  b[l]-=min*v;\n  a+=min;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=a=0;i<10;i++)b[i]=0;\n    while(n--){\n    scanf(\"%d\",&i);\n      b[i]++;\n    }\n    a+=b[5]/2;\n    b[5]%=2;\n    f(9,1,1,1,0,0,0,0);\n    f(8,1,2,1,0,0,0,0);\n    f(8,1,1,2,0,0,0,0);\n    f(7,1,3,1,0,0,0,0);\n    f(7,1,2,1,1,1,0,0);\n    f(7,1,1,3,0,0,0,0);\n    f(6,1,4,1,0,0,0,0);\n    f(6,1,3,1,1,1,0,0);\n    f(6,1,2,2,0,0,0,0);\n    f(6,1,2,1,1,2,0,0);\n    f(6,1,1,4,0,0,0,0);\n    f(5,1,4,1,1,1,0,0);\n    f(5,1,3,1,2,1,0,0);\n    f(5,1,3,1,1,2,0,0);\n    f(5,1,2,2,1,1,0,0);\n    f(5,1,2,1,1,3,0,0);\n    f(5,1,1,5,0,0,0,0);\n    f(4,2,2,1,0,0,0,0);\n    f(4,2,1,2,0,0,0,0);\n    f(4,1,3,2,0,0,0,0);\n    f(4,1,3,1,2,1,1,1);\n    f(4,1,3,1,1,3,0,0);\n    f(4,1,2,3,0,0,0,0);\n    f(4,1,2,2,1,2,0,0);\n    f(4,1,2,1,1,4,0,0);\n    f(4,1,1,6,0,0,0,0);\n    f(3,3,1,1,0,0,0,0);\n    f(3,2,2,2,0,0,0,0);\n    f(3,2,2,1,1,2,0,0);\n    f(3,1,2,3,1,1,0,0);\n    f(3,1,2,2,1,3,0,0);\n    f(3,1,2,1,1,5,0,0);\n    f(3,1,1,7,0,0,0,0);\n    a+=(b[2]*2+b[1])/10;\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[29][4][2] = {\n{{1,1},{4,1},{5,1}}, {{2,1},{3,1},{5,1}}, {{2,1},{4,2}}, {{3,2},{4,1}},\n{{1,2},{3,1},{5,1}}, {{1,2},{4,2}}, {{1,1},{2,2},{5,1}}, {{1,1},{2,1},{3,1},{4,1}},\n{{1,1},{3,3}}, {{2,3},{4,1}}, {{2,2},{3,2}}, {{1,3},{2,1},{5,1}}, {{1,3},{3,1},{4,1}},\n{{1,2},{2,2},{4,1}}, {{1,2},{2,1},{3,2}}, {{1,1},{2,3},{3,1}}, {{2,5}}, {{1,5},{5,1}},\n{{1,4},{2,1},{4,1}}, {{1,4},{3,2}}, {{1,3},{2,2},{3,1}}, {{1,2},{2,4}}, {{1,6},{4,1}},\n{{1,5},{2,1},{3,1}}, {{1,4},{2,3}}, {{1,7},{3,1}}, {{1,6},{2,2}}, {{1,8},{2,1}}, {{1,10}} };\n\nint take(int k)\n{\n\tint i, a, b;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) {\n\t\tb = pair[k][i][1];\n\t\tif (f[a] < b) return 0;\n\t}\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (sum >= 10) for (i = k; i < 29; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1;\n\t\tf[9] = 0;\n\t\tif (f[8] > 0) {\n\t\t\tif (f[1] >= 2*f[8]) ans += f[8], f[1] -= 2*f[8];\n\t\t\telse if (f[1] & 1) ans += f[1]/2, f[1] = 1;\n\t\t\telse               ans += f[1]/2, f[1] = 0;\n\t\t\tf[8] = 0;\n\t\t}\n\t\tif (f[7] > 0) {\n\t\t\twhile (f[7] > 0 && f[1] > 0 && f[2] > 0) ans++, f[7]--, f[1]--, f[2]--;\n\t\t\twhile (f[7] > 0 && f[1] >= 3) ans++, f[7]--, f[1]-=3;\n\t\t\tf[7] = 0;\n\t\t}\n\t\tif (f[6] > 0) {\n\t\t\twhile (f[6] > 0 && f[1] >  0 && f[3] > 0) ans++, f[6]--, f[1]--, f[3]--;\n\t\t\twhile (f[6] > 0 && f[2] >= 2) ans++, f[6]--, f[2]-=2;\n\t\t\twhile (f[6] > 0 && f[1] >= 2 && f[2] > 0) ans++, f[6]--, f[1]-=2, f[2]--;\n\t\t\twhile (f[6] > 0 && f[1] >= 4) ans++, f[6]--, f[1]-=4;\n\t\t\tf[6] = 0;\n\t\t}\n\t\tfor (sum = 0, i = 1; i <= 5; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[36][5][2] = {\n{{1,2},{8,1}}, {{1,1},{2,1},{7,1}}, {{1,1},{3,1},{6,1}}, {{1,1},{4,1},{5,1}}, {{2,2},{6,1}},       {{2,1},{3,1},{5,1}}, {{2,1},{4,2}}, {{3,2},{4,1}}, \n{{1,3},{7,1}}, {{1,2},{2,1},{6,1}}, {{1,2},{3,1},{5,1}}, {{1,2},{4,2}},       {{1,1},{2,2},{5,1}}, {{1,1},{2,1}, {3,1},{4,1}}, {{1,1},{3,3}}, {{2,3},{4,1}}, {{2,2},{3,2}}, \n{{1,4},{6,1}}, {{1,3},{2,1},{5,1}}, {{1,3},{3,1},{4,1}}, {{1,2},{2,2},{4,1}}, {{1,2},{2,1},{3,2}}, {{1,1},{2,3},{3,1}}, {{2,5}}, \n{{1,5},{5,1}}, {{1,4},{2,1},{4,1}}, {{1,4},{3,2}},       {{1,3},{2,2},{3,1}}, {{1,2},{2,4}}, \n{{1,6},{4,1}}, {{1,5},{2,1},{3,1}}, {{1,4},{2,3}}, \n{{1,7},{3,1}}, {{1,6},{2,2}}, \n{{1,8},{2,1}}, \n{{1,10}}};\n\nint take(int k)\n{\n\tint i, a, b;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) {\n\t\tb = pair[k][i][1];\n\t\tif (f[a] < b) return 0;\n\t}\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (sum >= 10) for (i = k; i < 36; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1;\n\t\tf[9] = 0;\n#if 0\n\t\tif (f[8] > 0) {\n\t\t\tif (f[1] >= 2*f[8]) ans += f[8], f[1] -= 2*f[8];\n\t\t\telse if (f[1] & 1) ans += f[1]/2, f[1] = 1;\n\t\t\telse               ans += f[1]/2, f[1] = 0;\n\t\t\tf[8] = 0;\n\t\t}\n\t\tif (f[7] > 0) {\n\t\t\twhile (f[7] > 0 && f[1] > 0 && f[2] > 0) ans++, f[7]--, f[1]--, f[2]--;\n\t\t\twhile (f[7] > 0 && f[1] >= 3) ans++, f[7]--, f[1]-=3;\n\t\t\tf[7] = 0;\n\t\t}\n\t\tif (f[6] > 0) {\n\t\t\twhile (f[6] > 0 && f[1] >  0 && f[3] > 0) ans++, f[6]--, f[1]--, f[3]--;\n\t\t\twhile (f[6] > 0 && f[2] >= 2) ans++, f[6]--, f[2]-=2;\n\t\t\twhile (f[6] > 0 && f[1] >= 2 && f[2] > 0) ans++, f[6]--, f[1]-=2, f[2]--;\n\t\t\twhile (f[6] > 0 && f[1] >= 4) ans++, f[6]--, f[1]-=4;\n\t\t\tf[6] = 0;\n\t\t}\n#endif\n\t\tfor (sum = 0, i = 1; i <= 8; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint a,b[10];\nint f(int i,int s,int j,int t,int k,int u,int l,int v){\n  if(i*s+j*t+k*u+l*v-10)printf(\"%d %d %d %d %d %d %d %d\\n\",i,s,j,t,k,u,l,v);\n  int min=MIN(b[i]/s,b[j]/t);\n  if(k)min=MIN(min,b[k]/u);\n  if(l)min=MIN(min,b[l]/v);\n  b[i]-=min*s;\n  b[j]-=min*t;\n  b[k]-=min*u;\n  b[l]-=min*v;\n  a+=min;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=a=0;i<10;i++)b[i]=0;\n    while(n--){\n    scanf(\"%d\",&i);\n      b[i]++;\n    }\n    a+=b[5]/2;\n    b[5]%=2;\n    f(9,1,1,1,0,0,0,0);\n    f(8,1,2,1,0,0,0,0);\n    f(8,1,1,2,0,0,0,0);\n    f(7,1,3,1,0,0,0,0);\n    f(7,1,2,1,1,1,0,0);\n    f(7,1,1,3,0,0,0,0);\n    f(6,1,4,1,0,0,0,0);\n    f(6,1,3,1,1,1,0,0);\n    f(6,1,2,2,0,0,0,0);\n    f(6,1,2,1,1,2,0,0);\n    f(6,1,1,4,0,0,0,0);\n    f(5,1,4,1,1,1,0,0);\n    f(5,1,3,1,2,1,0,0);\n    f(5,1,3,1,1,2,0,0);\n    f(5,1,2,2,1,1,0,0);\n    f(5,1,2,1,1,3,0,0);\n    f(5,1,1,5,0,0,0,0);\n    f(4,2,2,1,0,0,0,0);\n    f(4,1,3,2,0,0,0,0);\n    f(4,1,3,1,2,1,1,1);\n    f(4,1,3,1,1,3,0,0);\n    f(4,1,1,6,0,0,0,0);\n    f(3,3,1,1,0,0,0,0);\n    f(3,2,2,2,0,0,0,0);\n    f(3,2,2,1,1,2,0,0);\n    f(3,1,2,3,1,1,0,0);\n    f(3,1,2,2,1,3,0,0);\n    f(3,1,2,1,1,5,0,0);\n    f(3,1,1,7,0,0,0,0);\n    a+=b[2]*2+b[1]/10;\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[36][5][2] = {\n{{1,2},{8,1}}, {{1,1},{2,1},{7,1}}, {{1,1},{3,1},{6,1}}, {{1,1},{4,1},{5,1}}, {{2,2},{6,1}},       {{2,1},{3,1},{5,1}}, {{2,1},{4,2}}, {{3,2},{4,1}}, \n{{1,3},{7,1}}, {{1,2},{2,1},{6,1}}, {{1,2},{3,1},{5,1}}, {{1,2},{4,2}},       {{1,1},{2,2},{5,1}}, {{1,1},{2,1}, {3,1},{4,1}}, {{1,1},{3,3}}, {{2,3},{4,1}}, {{2,2},{3,2}}, \n{{1,4},{6,1}}, {{1,3},{2,1},{5,1}}, {{1,3},{3,1},{4,1}}, {{1,2},{2,2},{4,1}}, {{1,2},{2,1},{3,2}}, {{1,1},{2,3},{3,1}}, {{2,5}}, \n{{1,5},{5,1}}, {{1,4},{2,1},{4,1}}, {{1,4},{3,2}},       {{1,3},{2,2},{3,1}}, {{1,2},{2,4}}, \n{{1,6},{4,1}}, {{1,5},{2,1},{3,1}}, {{1,4},{2,3}}, \n{{1,7},{3,1}}, {{1,6},{2,2}}, \n{{1,8},{2,1}}, \n{{1,10}}};\n\nint take(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) if (f[a] < pair[k][i][1]) return 0;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\tfor (i = k; ans < sum/10 + tmp && i < 36; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1; f[9] = 0;\n\t\tfor (sum = 0, i = 1; i < 10; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[36][4][2] = {\n{{1, 2}, {8, 1}}, {{1,1}, {2,1}, {7,1}}, {{1,1}, {3,1}, {6,1}}, {{1,1}, {4,1}, {5,1}}, {{2,2}, {6,1}}, {{2,1}, {3,1}, {5,1}}, {{2,1}, {4,2}}, {{3,2}, {4,1}}, \n{{1,3}, {7,1}}, {{1,2}, {2,1}, {6,1}}, {{1,2}, {3,1}, {5,1}}, {{1,2}, {4,2}}, {{1,1}, {2,2}, {5,1}}, {{1,1}, {2,1}, {3,1}, {4,1}}, {{1,1}, {3,3}}, {{2,3}, {4,1}}, {{2,2}, {3,2}}, \n{{1,4}, {6,1}}, {{1,3}, {2,1}, {5,1}}, {{1,3}, {3,1}, {4,1}}, {{1,2}, {2,2}, {4,1}}, {{1,2}, {2,1}, {3,2}}, {{1,1}, {2,3}, {3,1}}, {{2,5}}, \n{{1,5}, {5,1}}, {{1,4}, {2,1}, {4,1}}, {{1,4}, {3,2}}, {{1,3}, {2,2}, {3,1}}, {{1,2}, {2,4}}, \n{{1,6}, {4,1}}, {{1,5}, {2,1}, {3,1}}, {{1,4}, {2,3}}, \n{{1,7}, {3,1}}, {{1,6}, {2,2}}, \n{{1,8}, {2,1}}, \n{{1,10}}};\n\nint take(int k)\n{\n\tint i, a, b;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) {\n\t\tb = pair[k][i][1];\n\t\tif (f[a] < b) return 0;\n\t}\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (sum >= 10) for (i = k; i < 36; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1;\n\t\tf[9] = 0;\n#if 0\n\t\tif (f[8] > 0) {\n\t\t\tif (f[1] >= 2*f[8]) ans += f[8], f[1] -= 2*f[8];\n\t\t\telse if (f[1] & 1) ans += f[1]/2, f[1] = 1;\n\t\t\telse               ans += f[1]/2, f[1] = 0;\n\t\t\tf[8] = 0;\n\t\t}\n\t\tif (f[7] > 0) {\n\t\t\twhile (f[7] > 0 && f[1] > 0 && f[2] > 0) ans++, f[7]--, f[1]--, f[2]--;\n\t\t\twhile (f[7] > 0 && f[1] >= 3) ans++, f[7]--, f[1]-=3;\n\t\t\tf[7] = 0;\n\t\t}\n\t\tif (f[6] > 0) {\n\t\t\twhile (f[6] > 0 && f[1] >  0 && f[3] > 0) ans++, f[6]--, f[1]--, f[3]--;\n\t\t\twhile (f[6] > 0 && f[2] >= 2) ans++, f[6]--, f[2]-=2;\n\t\t\twhile (f[6] > 0 && f[1] >= 2 && f[2] > 0) ans++, f[6]--, f[1]-=2, f[2]--;\n\t\t\twhile (f[6] > 0 && f[1] >= 4) ans++, f[6]--, f[1]-=4;\n\t\t\tf[6] = 0;\n\t\t}\n#endif\n\t\tfor (sum = 0, i = 1; i <= 8; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[36][5][2] = {\n{{1,2},{8,1}}, {{1,1},{2,1},{7,1}}, {{1,1},{3,1},{6,1}}, {{1,1},{4,1},{5,1}}, {{2,2},{6,1}},       {{2,1},{3,1},{5,1}}, {{2,1},{4,2}}, {{3,2},{4,1}}, \n{{1,3},{7,1}}, {{1,2},{2,1},{6,1}}, {{1,2},{3,1},{5,1}}, {{1,2},{4,2}},       {{1,1},{2,2},{5,1}}, {{1,1},{2,1}, {3,1},{4,1}}, {{1,1},{3,3}}, {{2,3},{4,1}}, {{2,2},{3,2}}, \n{{1,4},{6,1}}, {{1,3},{2,1},{5,1}}, {{1,3},{3,1},{4,1}}, {{1,2},{2,2},{4,1}}, {{1,2},{2,1},{3,2}}, {{1,1},{2,3},{3,1}}, {{2,5}}, \n{{1,5},{5,1}}, {{1,4},{2,1},{4,1}}, {{1,4},{3,2}},       {{1,3},{2,2},{3,1}}, {{1,2},{2,4}}, \n{{1,6},{4,1}}, {{1,5},{2,1},{3,1}}, {{1,4},{2,3}}, \n{{1,7},{3,1}}, {{1,6},{2,2}}, \n{{1,8},{2,1}}, \n{{1,10}}};\n\nint take(int k)\n{\n\tint i, a, b;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) {\n\t\tb = pair[k][i][1];\n\t\tif (f[a] < b) return 0;\n\t}\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tfor (i = k; ans < sum/10 + tmp && i < 36; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1;\n\t\tf[9] = 0;\n#if 0\n\t\tif (f[8] > 0) {\n\t\t\tif (f[1] >= 2*f[8]) ans += f[8], f[1] -= 2*f[8];\n\t\t\telse if (f[1] & 1) ans += f[1]/2, f[1] = 1;\n\t\t\telse               ans += f[1]/2, f[1] = 0;\n\t\t\tf[8] = 0;\n\t\t}\n\t\tif (f[7] > 0) {\n\t\t\twhile (f[7] > 0 && f[1] > 0 && f[2] > 0) ans++, f[7]--, f[1]--, f[2]--;\n\t\t\twhile (f[7] > 0 && f[1] >= 3) ans++, f[7]--, f[1]-=3;\n\t\t\tf[7] = 0;\n\t\t}\n\t\tif (f[6] > 0) {\n\t\t\twhile (f[6] > 0 && f[1] >  0 && f[3] > 0) ans++, f[6]--, f[1]--, f[3]--;\n\t\t\twhile (f[6] > 0 && f[2] >= 2) ans++, f[6]--, f[2]-=2;\n\t\t\twhile (f[6] > 0 && f[1] >= 2 && f[2] > 0) ans++, f[6]--, f[1]-=2, f[2]--;\n\t\t\twhile (f[6] > 0 && f[1] >= 4) ans++, f[6]--, f[1]-=4;\n\t\t\tf[6] = 0;\n\t\t}\n#endif\n\t\tfor (sum = 0, i = 1; i <= 8; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint a,b[10];\nint f(int i,int s,int j,int t,int k,int u,int l,int v){\n  if(i*s+j*t+k*u+l*v-10)printf(\"%d %d %d %d %d %d %d %d\\n\",i,s,j,t,k,u,l,v);\n  //printf(\"%d\\n\",s+t+u+v);\n  int min=MIN(b[i]/s,b[j]/t);\n  if(k)min=MIN(min,b[k]/u);\n  if(l)min=MIN(min,b[l]/v);\n  b[i]-=min*s;\n  b[j]-=min*t;\n  b[k]-=min*u;\n  b[l]-=min*v;\n  a+=min;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=a=0;i<10;i++)b[i]=0;\n    while(n--){\n    scanf(\"%d\",&i);\n      b[i]++;\n    }\n    a+=b[5]/2;\n    b[5]%=2;\n    f(9,1,1,1,0,0,0,0);\n    f(8,1,2,1,0,0,0,0);\n    f(7,1,3,1,0,0,0,0);\n    f(6,1,4,1,0,0,0,0);\n    \n    f(8,1,1,2,0,0,0,0);\n    f(7,1,2,1,1,1,0,0);\n    f(6,1,3,1,1,1,0,0);\n    f(6,1,2,2,0,0,0,0);\n    f(5,1,4,1,1,1,0,0);\n    f(5,1,3,1,2,1,0,0);\n    f(4,2,2,1,0,0,0,0);\n    f(4,1,3,2,0,0,0,0);\n    \n    f(7,1,1,3,0,0,0,0);\n    f(6,1,2,1,1,2,0,0);\n    f(5,1,3,1,1,2,0,0);\n    f(5,1,2,2,1,1,0,0);\n    f(4,2,1,2,0,0,0,0);\n    f(4,1,3,1,2,1,1,1);\n    f(4,1,2,3,0,0,0,0);\n    f(3,3,1,1,0,0,0,0);\n    f(3,2,2,2,0,0,0,0);\n    \n    f(6,1,1,4,0,0,0,0);\n    f(5,1,2,1,1,3,0,0);\n    f(4,1,3,1,1,3,0,0);\n    f(4,1,2,2,1,2,0,0);\n    f(3,2,2,1,1,2,0,0);\n    f(3,1,2,3,1,1,0,0);\n    \n    f(5,1,1,5,0,0,0,0);\n    f(4,1,2,1,1,4,0,0);\n    f(3,1,2,2,1,3,0,0);\n\n    f(4,1,1,6,0,0,0,0);\n    f(3,1,2,1,1,5,0,0);\n    \n    f(3,1,1,7,0,0,0,0);\n    a+=(b[2]*2+b[1])/10;//printf(\"\\n\");\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "// AOJ 0246: Bara-Bara Manju\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint f[10];\nint ans, sum, tmp;\n\nint pair[36][5][2] = {\n{{1,2},{8,1}}, {{1,1},{2,1},{7,1}}, {{1,1},{3,1},{6,1}}, {{1,1},{4,1},{5,1}}, {{2,2},{6,1}},       {{2,1},{3,1},{5,1}}, {{2,1},{4,2}}, {{3,2},{4,1}}, \n{{1,3},{7,1}}, {{1,2},{2,1},{6,1}}, {{1,2},{3,1},{5,1}}, {{1,2},{4,2}},       {{1,1},{2,2},{5,1}}, {{1,1},{2,1}, {3,1},{4,1}}, {{1,1},{3,3}}, {{2,3},{4,1}}, {{2,2},{3,2}}, \n{{1,4},{6,1}}, {{1,3},{2,1},{5,1}}, {{1,3},{3,1},{4,1}}, {{1,2},{2,2},{4,1}}, {{1,2},{2,1},{3,2}}, {{1,1},{2,3},{3,1}}, {{2,5}}, \n{{1,5},{5,1}}, {{1,4},{2,1},{4,1}}, {{1,4},{3,2}},       {{1,3},{2,2},{3,1}}, {{1,2},{2,4}}, \n{{1,6},{4,1}}, {{1,5},{2,1},{3,1}}, {{1,4},{2,3}}, \n{{1,7},{3,1}}, {{1,6},{2,2}}, \n{{1,8},{2,1}}, \n{{1,10}}};\n\nint take(int k)\n{\n\tint i, a, b;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) {\n\t\tb = pair[k][i][1];\n\t\tif (f[a] < b) return 0;\n\t}\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] -= pair[k][i][1];\n\tsum -= 10; tmp++;\n\treturn 1;\n}\n\nvoid back(int k)\n{\n\tint i, a;\n\tfor (i = 0; (a = pair[k][i][0]) > 0; i++) f[a] += pair[k][i][1];\n\tsum += 10; tmp--;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tfor (i = k; ans < sum/10 + tmp && i < 36; i++) if (take(i)) rec(i), back(i);\n\tif (tmp > ans) ans = tmp;\n}\n\nint main()\n{\n\tint n, i, k;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\twhile (n-- > 0) scanf(\"%d\", &k), f[k]++;\n\t\tfor (ans = 0, i = 9; i >= 6; i--) {\n\t\t\tk = f[i]; if (f[10-i] < k) k = f[10-i];\n\t\t\tans += k, f[i] -= k, f[10-i] -= k;\n\t\t}\n\t\tans += f[5]/2, f[5] &= 1;\n\n\t\tf[9] = 0;\n\t\tif (f[8] > 0) {\n\t\t\tif (f[1] >= 2*f[8]) ans += f[8], f[1] -= 2*f[8];\n\t\t\telse if (f[1] & 1) ans += f[1]/2, f[1] = 1;\n\t\t\telse               ans += f[1]/2, f[1] = 0;\n\t\t\tf[8] = 0;\n\t\t}\n#if 0\n\t\tif (f[7] > 0) {\n\t\t\twhile (f[7] > 0 && f[1] > 0 && f[2] > 0) ans++, f[7]--, f[1]--, f[2]--;\n\t\t\twhile (f[7] > 0 && f[1] >= 3) ans++, f[7]--, f[1]-=3;\n\t\t\tf[7] = 0;\n\t\t}\n\t\tif (f[6] > 0) {\n\t\t\twhile (f[6] > 0 && f[1] >  0 && f[3] > 0) ans++, f[6]--, f[1]--, f[3]--;\n\t\t\twhile (f[6] > 0 && f[2] >= 2) ans++, f[6]--, f[2]-=2;\n\t\t\twhile (f[6] > 0 && f[1] >= 2 && f[2] > 0) ans++, f[6]--, f[1]-=2, f[2]--;\n\t\t\twhile (f[6] > 0 && f[1] >= 4) ans++, f[6]--, f[1]-=4;\n\t\t\tf[6] = 0;\n\t\t}\n#endif\n\t\tfor (sum = 0, i = 1; i <= 8; i++) sum += i*f[i];\n\t\ttmp = ans;\n\t\trec(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//HashSet<ArrayList<Integer>> hash = new HashSet<ArrayList<Integer>>();\n\t\t\t//pre(0, 9, new ArrayList<Integer>(), hash);\n\t\t\t//System.out.println(hash);\n\t\t\t\n\t\t\tArrayList<Integer> array = new ArrayList<Integer>(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tarray.add(sc.nextInt());\n\t\t\t}\n\t\t\tCollections.sort(array, Collections.reverseOrder());\n\t\t\t//System.out.println(array);\n\t\t\t\n\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\n\t\t\tint count = 0;\n\t\t\twhile(true){\n\t\t\t\tint cur = 0;\n\t\t\t\tboolean update = false;\n\t\t\t\tlist.clear();\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\t\t\tif(cur == 10){\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(cur + array.get(i) <= 10){\n\t\t\t\t\t\tcur += array.get(i);\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur == 10){\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tfor(int i : list){\n\t\t\t\t\tSystem.out.print(array.get(i) + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t\tif(!update){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\tarray.remove((int) list.pollLast());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n\t\tint res = b[5] / 2;\n\t\tb[5] %= 2;\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tint m = Math.min(b[i], b[10 - i]);\n\t\t\tb[i] -= m;\n\t\t\tb[10 - i] -= m;\n\t\t\tres += m;\n\t\t}\n\t\tpatternList = new java.util.ArrayList<int[][]>();\n\t\tmake(b);\n\t\tmd = 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 10; i++) sum += i * b[i];\n\t\tsearch(b, 0, 0, sum);\n\t\tSystem.out.println(res + md);\n\t}\n\t}\n\tint md;\n\tvoid search(int[] b, int depth, int ten, int sum) {\n\t\tif (depth == patternList.size()) {\n\t\t\tif (md < ten) {\n\t\t\t\tmd = ten;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (ten + sum / 10 <= md) return;\n\t\tint[][] p = patternList.get(depth);\n\t\tint[] org = b.clone();\n\t\tfor (int i = 0; ; i++) {\n\t\t\tsearch(b, depth + 1, ten + i, sum - i * 10);\n\t\t\tboolean ok = true;\n\t\t\tfor (int[] k : p) {\n\t\t\t\tb[k[0]] -= k[1];\n\t\t\t\tif (b[k[0]] < 0) ok = false;\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) b[i] = org[i];\n\t}\n\n\tList<int[][]> patternList;\n\tvoid make(int[] b) {\n\t\tint[] pattern = new int[10];\n\t\tdfs(b, pattern, 0, 0);\n\t}\n\n\tvoid dfs(int[] b, int[] pattern, int depth, int sum) {\n\t\tif (sum == 10) {\n\t\t\tif (depth > 2) {\n\t\t\t\tint[] hist = new int[10];\n\t\t\t\tfor (int i = 0; i < depth; i++) {\n\t\t\t\t\thist[pattern[i]]++;\n\t\t\t\t}\n\t\t\t\tint nz = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) nz++;\n\t\t\t\tint[][] k = new int[nz][2];\n\t\t\t\tint sz = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) {\n\t\t\t\t\tk[sz][0] = i;\n\t\t\t\t\tk[sz][1] = hist[i];\n\t\t\t\t\tsz++;\n\t\t\t\t}\n\t\t\t\tpatternList.add(k);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = (depth == 0) ? 1 : pattern[depth-1];\n\n\t\tfor (int i = s; i <= 9; i++) if (b[i] > 0 && sum + i <= 10) {\n\t\t\tpattern[depth] = i;\n\t\t\tdfs(b, pattern, depth + 1, sum + i);\n\t\t\tpattern[depth] = 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tint res, num, ID;\n\tint[][] div;\n\tint[] c, u;\n\t\n\tvoid f(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=1;i<10;i++)div[ID][i] = u[i];\n\t\t\tID++;\n\t\t\treturn;\n\t\t}\n\t\tif(k<=0)return;\n\t\tfor(int use=0;use*k<=rest;use++){\n\t\t\tu[k] = use;\n\t\t\tf(k-1, rest-use*k);\n\t\t\tu[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid dfs(int k, int num, int sum){\n//\t\tif(res<num)System.out.println(num+\" Time:\"+(System.currentTimeMillis()-S));\n\t\tres = Math.max(res, num);\n\t\tif(k==ID || num+sum/10 <= res)return;\n\t\tint t = 1000;\n\t\tfor(int i=1;i<10;i++)if(div[k][i]>0)t = Math.min(t, c[i]/div[k][i]);\n\t\tfor(int use=0;use<=t;use++){\n\t\t\tfor(int i=1;i<10;i++)c[i]-=use*div[k][i];\n//\t\t\tSystem.out.println(\"K:\"+k+\" Use:\"+use);\n\t\t\tdfs(k+1, num+use, sum-use*10);\n\t\t\tfor(int i=1;i<10;i++)c[i]+=use*div[k][i];\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdiv = new int[50][11];\n\t\tu = new int[11];\n\t\tf(9, 10);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tS = System.currentTimeMillis();\n\t\t\tc = new int[11];\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tc[x]++;\n\t\t\t\tsum+=x;\n\t\t\t}\n//\t\t\tint g = c[5]/2;\n//\t\t\tsum-=g*10;\n//\t\t\tc[5]%=2;\n//\t\t\tfor(int i=6;i<10;i++){\n//\t\t\t\tint t = Math.min(c[i], c[10-i]);\n//\t\t\t\tsum-=10*t;\n//\t\t\t\tg+=t;\n//\t\t\t\tc[i]-=t;\n//\t\t\t\tc[10-i]-=t;\n//\t\t\t}\n\t\t\tres = 0;\n\t\t\tdfs(0, 0, sum);\n\t\t\tSystem.out.println(res);\n//\t\t\tSystem.out.println(System.currentTimeMillis()-S);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tint res, num, ID;\n\tint[][] div;\n\tint[] c, u;\n\t\n\tvoid f(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=1;i<10;i++)div[ID][i] = u[i];\n\t\t\tID++;\n\t\t\treturn;\n\t\t}\n\t\tif(k<=0)return;\n\t\tfor(int use=0;use*k<=rest;use++){\n\t\t\tu[k] = use;\n\t\t\tf(k-1, rest-use*k);\n\t\t\tu[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid dfs(int k, int num, int sum){\n\t\tres = Math.max(res, num);\n\t\tif(k==ID || num+sum/10 <= res)return;\n\t\tint t = 1000;\n\t\tfor(int i=1;i<10;i++)if(div[k][i]>0)t = Math.min(t, c[i]/div[k][i]);\n\t\tfor(int use=0;use<=t;use++){\n\t\t\tfor(int i=1;i<10;i++)c[i]-=use*div[k][i];\n\t\t\tdfs(k+1, num+use, sum-use*10);\n\t\t\tfor(int i=1;i<10;i++)c[i]+=use*div[k][i];\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdiv = new int[50][11];\n\t\tu = new int[11];\n\t\tf(9, 10);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[11];\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tc[x]++;\n\t\t\t\tsum+=x;\n\t\t\t}\n\t\t\tint g = c[5]/2;\n\t\t\tsum-=g*10;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<10;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tsum-=10*t;\n\t\t\t\tg+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tdfs(0, g, sum);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\t\n\tint nap[];\n\tint target = 10;\n\tint max_depth;\n\t\n\tvoid dfs(int g, int depth, int index){\n\t\tif(g==target){\n\t\t\tif(max_depth < depth){\n\t\t\t\tmax_depth = depth;\n\t\t\t}\n\t\t}\n\t\tfor(int i=index; i<nap.length; ++i){\n\t\t\tint tmp = nap[i];\n\t\t\tif(10<g+tmp){break;}\t//sortしたから\n\t\t\tdfs(g+tmp, depth+1, i+1);\n\t\t}\n\t}\n\t\n\tint solve(){\n\t\tdfs(0, 0, 0);\n\t\treturn max_depth;\n\t}\n\t\n\tvoid io(){\n\t\tjava.util.Scanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tif(n==0){ break; }\n\t\t\tnap = new int[n];\n\t\t\tmax_depth=0;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tnap[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(nap);\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[10];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, a, 0);\n\t\t\tSystem.out.println(sum + ans);\n\t\t}\n\n\t}\n\n\tint ans;\n\n\tprivate void dfs(int i, int sum, int[] a, int now) {\n\t\tint rem = sum;\n\t\tfor (int j = 1; j < 10; j++)\n\t\t\trem += a[j] * j;\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, a, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i >= 10)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, a, now);\n\t\tif (a[i] > 0 && sum + i <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(i, sum + i, a, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final int SUM_W = 10;\n\n  // inner classes\n\n  // global variables\n\n  static int[] manju;\n\n  // subroutines\n\n  static ArrayList<int[]> pack_manju(int k, int w, int[] mj) {\n    if (k >= 9) {\n      ArrayList<int[]> list = new ArrayList<int[]>();\n      if (w == 0) {\n        list.add(mj.clone());\n        return list;\n      }\n      return list;\n    }\n\n    ArrayList<int[]> mjs = new ArrayList<int[]>();\n    int mjk = manju[k];\n\n    for (int i = 0; i <= mjk; i++) {\n      int w0 = w - (k + 1) * i;\n      if (w0 >= 0) {\n        mj[k] = i;\n        ArrayList<int[]> mjs0 = pack_manju(k + 1, w0, mj);\n        mjs.addAll(mjs0);\n      }\n    }\n\n    return mjs;\n  }\n\n  static int max_count_pack(int k, int[] mj, ArrayList<int[]> mjs) {\n    if (k >= mjs.size()) return 1;\n\n    int mc0 = max_count_pack(k + 1, mj, mjs);\n\n    int[] mj0 = new int[9];\n\n    for (int i = 0; i < 9; i++) {\n      mj0[i] = mj[i] + mjs.get(k)[i];\n      if (mj0[i] > manju[i]) return mc0;\n    }\n\n    int mc1 = 1 + max_count_pack(k + 1, mj0, mjs);\n\n    return (mc0 > mc1) ? mc0 : mc1;\n  }\n\n  // main\n\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n    manju = new int[9];\n\n    for (;;) {\n      int n = sc.nextInt();\n      if (n == 0) break;\n\n      for (int i = 0; i < 9; i++) manju[i] = 0;\n\n      for (int i = 0; i < n; i++) {\n        String nstr = sc.next();\n        manju[Integer.parseInt(nstr) - 1]++;\n      }\n\n      int mc = 0;\n\n      for (int i = 0; i < 4; i++) {\n        int m = (manju[i] < manju[8 - i]) ? manju[i] : manju[8 - i];\n        manju[i] -= m;\n        manju[8 - i] -= m;\n        mc += m;\n      }\n\n      int m = manju[4] / 2;\n      manju[4] -= 2 * m;\n      mc += m;\n\n      ArrayList<int[]> mjs = pack_manju(0, SUM_W, new int[9]);\n\n      int[] mj = new int[9];\n      Arrays.fill(mj, 0);\n\n      mc += max_count_pack(0, mj, mjs) - 1;\n      System.out.println(mc);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static LinkedList<Integer> dps(int num, int selected, int[] weight){\n\t\tif(num > 10){\n\t\t\treturn null;\n\t\t}else if(num == 10){\n\t\t\treturn new LinkedList<Integer>();\n\t\t}\n\t\t\n\t\tfor(int i = selected; i >= 0; i--){\n\t\t\tif(weight[i] == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tweight[i]--;\n\t\t\tLinkedList<Integer> tmp = dps(num + i, i, weight);\n\t\t\tweight[i]++;\n\t\t\t\n\t\t\tif(tmp != null){\n\t\t\t\ttmp.add(i);\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tLinkedList<Integer> ret = dps(0, 10, weights);\n\t\t\t\t\n\t\t\t\tif(ret == null){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tcount++;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i : ret){\n\t\t\t\t\t\tweights[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int dps(int num, int selected, int[] weight){\n\t\tif(num > 10){\n\t\t\treturn 0;\n\t\t}else if(num == 10){\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\t\n\t\tfor(int i = selected; i >= 0; i--){\n\t\t\tif(weight[i] == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tweight[i]--;\n\t\t\tint tmp = dps(num + i, i, weight);\n\t\t\t\n\t\t\tif(tmp > 0){\n\t\t\t\tret += tmp;\n\t\t\t}else{\n\t\t\t\tweight[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dps(0, 10, weights));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n\t\tint res = b[5] / 2;\n\t\tb[5] %= 2;\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tint m = Math.min(b[i], b[10 - i]);\n\t\t\tb[i] -= m;\n\t\t\tb[10 - i] -= m;\n\t\t\tres += m;\n\t\t}\n\t\tpatternList = new java.util.ArrayList<int[][]>();\n\t\tmake(b);\n\t\tmd = 0;\n\t\tsearch(b, 0, 0);\n\t\tSystem.out.println(res + md);\n\t}\n\t}\n\tint md;\n\tvoid search(int[] b, int d, int s) {\n\t\tif (d >= md) {\n\t\t\tmd = d;\n\t\t}\n\t\tfor (int i = s; i < patternList.size(); i++) {\n\t\t\tint[][] p = patternList.get(i);\n\t\t\tboolean ok = true;\n\t\t\tfor (int[] k : p) {\n\t\t\t\tb[k[0]] -= k[1];\n\t\t\t\tif (b[k[0]] < 0) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tsearch(b, d + 1, i);\n\t\t\t}\n\t\t\tfor (int[] k : p) {\n\t\t\t\tb[k[0]] += k[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tList<int[][]> patternList;\n\tvoid make(int[] b) {\n\t\tint[] pattern = new int[10];\n\t\tdfs(b, pattern, 0, 0);\n\t}\n\n\tvoid dfs(int[] b, int[] pattern, int depth, int sum) {\n\t\tif (sum == 10) {\n\t\t\tif (depth > 2) {\n\t\t\t\tint[] hist = new int[10];\n\t\t\t\tfor (int i = 0; i < depth; i++) {\n\t\t\t\t\thist[pattern[i]]++;\n\t\t\t\t}\n\t\t\t\tint nz = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) nz++;\n\t\t\t\tint[][] k = new int[nz][2];\n\t\t\t\tint p = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) {\n\t\t\t\t\tk[p][0] = i;\n\t\t\t\t\tk[p][1] = hist[i];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tpatternList.add(k);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = (depth == 0) ? 1 : pattern[depth-1];\n\n\t\tfor (int i = s; i <= 9; i++) if (b[i] > 0 && sum + i <= 10) {\n\t\t\tpattern[depth] = i;\n\t\t\tdfs(b, pattern, depth + 1, sum + i);\n\t\t\tpattern[depth] = 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tMap<Long, Byte> mem;\n\t\n\tint[][] f1 = {{1,0,2,1,3,5},{0,1,0,2,4},{0,1,3},{0,2}};\n\tint[][] f2 = {{0,1,0,2,1,0},{0,0,2,1,0},{0,1,0},{1,0}};\n\tint[][] f3 = {{0,1,1,0,0,0},{0,1,0,0,0},{1,0,0},{0,0}};\n\tint[][] f4 = {{1,0,0,0,0,0},{1,0,0,0,0},{0,0,0},{0,0}};\n\t\n\tint cnt;\n\tint res, num;\n\tint[] c;\n\t\n\tlong P = 101;\n\tlong trans(int c1, int c2, int c3, int c4){\n\t\treturn c1*P*P*P + c2*P*P + c3*P + c4;\n\t}\n\t\n\tvoid f(int k){\n\t\tif(k==9)return;\n\t\tcnt++;\n\t\tint n = f1[k-5].length;\n\t\tfor(int i=0;i<n;i++)for(int u=0;u<=c[k];u++){\n\t\t\tint n1 = f1[k-5][i]*u, n2 = f2[k-5][i]*u, n3 = f3[k-5][i]*u, n4 = f4[k-5][i]*u;\n\t\t\tif(n1<=c[1] && n2<=c[2] && n3 <= c[3] && n4 <= c[4]){\n\t\t\t\tc[1]-=n1; c[2]-=n2; c[3]-=n3; c[4]-=n4;\n\t\t\t\tres = Math.max(res, num + mem.get(trans(c[1], c[2], c[3], c[4])) + u);\n\t\t\t\tf(k+1);\n\t\t\t\tc[1]+=n1; c[2]+=n2; c[3]+=n3; c[4]+=n4;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tlong T = System.currentTimeMillis();\n\t\tmem = new TreeMap<Long, Byte>();\n\t\tint[] n1 = {0, 2, 1, 3, 4, 6, 1, 0, 2, 4, 1, 3, 5, 7, 0, 2, 4, 6, 8, 10};\n\t\tint[] n2 = {1, 0, 1, 0, 1, 0, 0, 2, 1, 0, 3, 2, 1, 0, 5, 4, 3, 2, 1, 0};\n\t\tint[] n3 = {0, 0, 1, 1, 0, 0, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0};\n\t\tint[] n4 = {2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tfor(int c1=0;c1<=100;c1++){\n\t\t\tfor(int c2=0;c1+c2<=100;c2++){\n\t\t\t\tfor(int c3=0;c1+c2+c3<=100;c3++){\n\t\t\t\t\tfor(int c4=0;c1+c2+c3+c4<=100;c4++){\n\t\t\t\t\t\tlong key = trans(c1, c2, c3, c4);\n\t\t\t\t\t\tbyte max = 0;\n\t\t\t\t\t\tfor(int k=0;k<20;k++){\n\t\t\t\t\t\t\tif(c1>=n1[k] && c2>=n2[k] && c3>=n3[k] && c4>=n4[k]){\n\t\t\t\t\t\t\t\tlong K = trans(c1-n1[k], c2-n2[k], c3-n3[k], c4-n4[k]);\n\t\t\t\t\t\t\t\tmax = (byte) Math.max(max, 1+mem.get(K));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmem.put(key, max);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(mem.size());\n//\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tT = System.currentTimeMillis();\n\t\t\tc = new int[11];\n\t\t\tfor(int i=0;i<n;i++)c[sc.nextInt()]++;\n\t\t\tnum = c[5]/2;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<10;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tnum+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tcnt = 0;\n\t\t\tf(5);\n//\t\t\tSystem.out.println(\"CNT:\"+cnt);\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint[] list = new int[n];\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tlist[i] = sc.nextInt();\n\t\t\t\tsum += list[i];\n\t\t\t}\n\t\t\tArrays.sort(list);\n\t\t\tint[] count = new int[10];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tcount[list[i]]++;\n\t\t\t}\n\t\t\tint ans = dfs(0,0,count,sum);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int dfs(int a, int b, int[] c,int d) {\n\t\tif(a + d < 10) return b;\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < c.length; i++) {\n\t\t\tif(c[i] != 0) {\n\t\t\t\tc[i]--;\n\t\t\t\tif(a + i == 10) {\n\t\t\t\t\tret = Math.max(ret, dfs(0,b+1,c,d-i));\n\t\t\t\t}\n\t\t\t\telse if(a + i < 10) {\n\t\t\t\t\tret = Math.max(ret, dfs(a+i,b,c,d-i));\n\t\t\t\t}\n\t\t\t\tc[i]++;\n\t\t\t}\n\t\t}\n\t\treturn Math.max(b, ret);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tint res, num, ID;\n\tint[][] div;\n\tint[] c, u;\n\t\n\tvoid f(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=1;i<10;i++)div[ID][i] = u[i];\n\t\t\tID++;\n\t\t\treturn;\n\t\t}\n\t\tif(k<=0)return;\n\t\tfor(int use=0;use*k<=rest;use++){\n\t\t\tu[k] = use;\n\t\t\tf(k-1, rest-use*k);\n\t\t\tu[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid dfs(int k, int num){\n\t\tres = Math.max(res, num);\n\t\tif(k==ID)return;\n\t\tint t = 1000;\n\t\tfor(int i=1;i<10;i++)if(div[k][i]>0)t = Math.min(t, c[i]/div[k][i]);\n\t\tfor(int use=0;use<=t;use++){\n\t\t\tfor(int i=1;i<10;i++)c[i]-=use*div[k][i];\n\t\t\tdfs(k+1, num+use);\n\t\t\tfor(int i=1;i<10;i++)c[i]+=use*div[k][i];\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdiv = new int[50][11];\n\t\tu = new int[11];\n\t\tf(9, 10);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[11];\n\t\t\tfor(int i=0;i<n;i++)c[sc.nextInt()]++;\n\t\t\tint g = c[5]/2;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<10;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tg+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tdfs(0, g);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n\t\tint res = b[5] / 2;\n\t\tb[5] %= 2;\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tint m = Math.min(b[i], b[10 - i]);\n\t\t\tb[i] -= m;\n\t\t\tb[10 - i] -= m;\n\t\t\tres += m;\n\t\t}\n\t\tpatternList = new java.util.ArrayList<int[][]>();\n\t\tmake(b);\n\t\tmd = 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 10; i++) sum += i * b[i];\n\t\tsearch(b, 0, 0, sum);\n\t\tSystem.out.println(res + md);\n\t}\n\t}\n\tint md;\n\tvoid search(int[] b, int depth, int ten, int sum) {\n\t\tif (depth == patternList.size()) {\n\t\t\tif (md < ten) {\n\t\t\t\tmd = ten;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n//\t\tif (ten + sum / 10 <= md) return;\n\t\tint[][] p = patternList.get(depth);\n\t\tint[] org = b.clone();\n\t\tfor (int i = 0; ; i++) {\n\t\t\tsearch(b, depth + 1, ten + i, sum - i * 10);\n\t\t\tboolean ok = true;\n\t\t\tfor (int[] k : p) {\n\t\t\t\tb[k[0]] -= k[1];\n\t\t\t\tif (b[k[0]] < 0) ok = false;\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) b[i] = org[i];\n\t}\n\n\tList<int[][]> patternList;\n\tvoid make(int[] b) {\n\t\tint[] pattern = new int[10];\n\t\tdfs(b, pattern, 0, 0);\n\t}\n\n\tvoid dfs(int[] b, int[] pattern, int depth, int sum) {\n\t\tif (sum == 10) {\n\t\t\tif (depth > 2) {\n\t\t\t\tint[] hist = new int[10];\n\t\t\t\tfor (int i = 0; i < depth; i++) {\n\t\t\t\t\thist[pattern[i]]++;\n\t\t\t\t}\n\t\t\t\tint nz = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) nz++;\n\t\t\t\tint[][] k = new int[nz][2];\n\t\t\t\tint sz = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) {\n\t\t\t\t\tk[sz][0] = i;\n\t\t\t\t\tk[sz][1] = hist[i];\n\t\t\t\t\tsz++;\n\t\t\t\t}\n\t\t\t\tpatternList.add(k);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = (depth == 0) ? 1 : pattern[depth-1];\n\n\t\tfor (int i = s; i <= 9; i++) if (b[i] > 0 && sum + i <= 10) {\n\t\t\tpattern[depth] = i;\n\t\t\tdfs(b, pattern, depth + 1, sum + i);\n\t\t\tpattern[depth] = 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int man[];\n    static int ans;\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws java.io.IOException {\n        // TODO 自動生成されたメソッド・スタブ\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            man = new int[11];\n            for (int i = 0; i < n; i++) {\n                man[sc.nextInt()]++;\n            }\n            ans = 0;\n            solve(10);\n            System.out.println(ans);\n        }\n    }\n\n    public static boolean solve(int n) {\n        if (man[n] != 0) {\n            man[n]--;\n            ans++;\n            return true;\n        } else {\n            for (int i = 1; i < n; i++) {\n                if (man[i] != 0) {\n                    man[i]--;\n                    if (!solve(n - i))\n                        man[i]++;\n//                    else{\n//                     System.out.println(\"n:\"+n);\n//                     System.out.println(\"i:\"+i);\n                    //}\n                }\n            }\n        }\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tbyte[][][][] dp = new byte[101][101][101][101];\n\t\n\tint[][] f1 = {{1,0,2,1,3,5},{0,1,0,2,4},{0,1,3},{0,2}};\n\tint[][] f2 = {{0,1,0,2,1,0},{0,0,2,1,0},{0,1,0},{1,0}};\n\tint[][] f3 = {{0,1,1,0,0,0},{0,1,0,0,0},{1,0,0},{0,0}};\n\tint[][] f4 = {{1,0,0,0,0,0},{1,0,0,0,0},{0,0,0},{0,0}};\n\t\n\tint res, num;\n\tint[] c;\n\t\n\tvoid f(int k){\n\t\tif(k==9)return;\n\t\tint n = f1[k-5].length;\n\t\tfor(int i=0;i<n;i++)for(int u=0;u<=c[k];u++){\n\t\t\tint n1 = f1[k-5][i]*u, n2 = f2[k-5][i]*u, n3 = f3[k-5][i]*u, n4 = f4[k-5][i]*u;\n\t\t\tif(n1<=c[1] && n2<=c[2] && n3 <= c[3] && n4 <= c[4]){\n\t\t\t\tc[1]-=n1; c[2]-=n2; c[3]-=n3; c[4]-=n4;\n\t\t\t\tres = Math.max(res, num + dp[c[1]][c[2]][c[3]][c[4]] + u);\n\t\t\t\tf(k+1);\n\t\t\t\tc[1]+=n1; c[2]+=n2; c[3]+=n3; c[4]+=n4;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] n1 = {0, 2, 1, 3, 4, 6, 1, 0, 2, 4, 1, 3, 5, 7, 0, 2, 4, 6, 8, 10};\n\t\tint[] n2 = {1, 0, 1, 0, 1, 0, 0, 2, 1, 0, 3, 2, 1, 0, 5, 4, 3, 2, 1, 0};\n\t\tint[] n3 = {0, 0, 1, 1, 0, 0, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0};\n\t\tint[] n4 = {2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tfor(int c1=0;c1<=100;c1++){\n\t\t\tfor(int c2=0;c1+c2<=100;c2++){\n\t\t\t\tfor(int c3=0;c1+c2+c3<=100;c3++){\n\t\t\t\t\tfor(int c4=0;c1+c2+c3+c4<=100;c4++){\n\t\t\t\t\t\tfor(int k=0;k<20;k++){\n\t\t\t\t\t\t\tif(c1>=n1[k] && c2>=n2[k] && c3>=n3[k] && c4>=n4[k]){\n\t\t\t\t\t\t\t\tdp[c1][c2][c3][c4] = (byte) Math.max(dp[c1][c2][c3][c4], dp[c1-n1[k]][c2-n2[k]][c3-n3[k]][c4-n4[k]]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[11];\n\t\t\tfor(int i=0;i<n;i++)c[sc.nextInt()]++;\n\t\t\tnum = c[5]/2;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<10;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tnum+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tf(5);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\tpublic static int def_max = 0;\n\t\n\tpublic static int dps(int selected, int[] weight, int sum){\n\t\tint max = 0;\n\t\t\n\t\tif(sum / 10 - def_max <= 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i = selected; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t\tsum -= cost;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(weight[j] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(i, weight, sum) + 1);\n\t\t\t\tdef_max = Math.max(max, def_max);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t\tsum += cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdef_max = 0;\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1; i < weights.length; i++){\n\t\t\t\tsum += weights[i] * i;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(0, weights, sum));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tint res, num, ID;\n\tint[][] div;\n\tint[] c, u;\n//\tlong S;\n\t\n\tvoid f(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=1;i<10;i++)div[ID][i] = u[i];\n\t\t\tID++;\n\t\t\treturn;\n\t\t}\n\t\tif(k<=0)return;\n\t\tfor(int use=0;use*k<=rest;use++){\n\t\t\tu[k] = use;\n\t\t\tf(k-1, rest-use*k);\n\t\t\tu[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid dfs(int k, int num, int sum){\n//\t\tif(res<num)System.out.println(num+\" Time:\"+(System.currentTimeMillis()-S));\n\t\tres = Math.max(res, num);\n\t\tif(k==ID || num+sum/10 <= res)return;\n\t\tint t = 1000;\n\t\tfor(int i=1;i<10;i++)if(div[k][i]>0)t = Math.min(t, c[i]/div[k][i]);\n\t\tfor(int use=0;use<=t;use++){\n\t\t\tfor(int i=1;i<10;i++)c[i]-=use*div[k][i];\n//\t\t\tSystem.out.println(\"K:\"+k+\" Use:\"+use);\n\t\t\tdfs(k+1, num+use, sum-use*10);\n\t\t\tfor(int i=1;i<10;i++)c[i]+=use*div[k][i];\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdiv = new int[50][11];\n\t\tu = new int[11];\n\t\tf(9, 10);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tS = System.currentTimeMillis();\n\t\t\tc = new int[11];\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tc[x]++;\n\t\t\t\tsum+=x;\n\t\t\t}\n\t\t\tint g = c[5]/2;\n\t\t\tsum-=g*10;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<10;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tsum-=10*t;\n\t\t\t\tg+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tdfs(0, g, sum);\n\t\t\tSystem.out.println(res);\n//\t\t\tSystem.out.println(System.currentTimeMillis()-S);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n\t\tres = b[5] / 2;\n\t\tb[5] %= 2;\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tint m = Math.min(b[i], b[10 - i]);\n\t\t\tb[i] -= m;\n\t\t\tb[10 - i] -= m;\n\t\t\tres += m;\n\t\t}\n\t\tfor (;;) {\n\t\t\ttry {\n\t\t\t\tdfs(b, 9, 0);\n\t\t\t} catch (ProgramException e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t}\n\tint res;\n\n\tvoid dfs(int[] b, int s, int cur) throws ProgramException {\n\t\tif (cur == 10) {\n\t\t\tres++;\n\t\t\tthrow new ProgramException();\n\t\t}\n\t\tfor (int i = s; i >= 1; i--) {\n\t\t\tif (b[i] > 0 && cur + i <= 10) {\n\t\t\t\tb[i]--;\n\t\t\t\tdfs(b, i, cur + i);\n\t\t\t\tb[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass ProgramException extends Exception {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[10];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\t\t\tif(a[1]<2)\n\t\t\t\ta[8] =0;\n\t\t\ta[9] = 0;\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, a, 0);\n\t\t\tSystem.out.println(sum + ans);\n\t\t}\n\n\t}\n\n\tint ans;\n\n\tprivate void dfs(int i, int sum, int[] a, int now) {\n\t\tint rem = sum;\n\t\tint max = 0;\n\t\tfor (int j = 1; j < 10; j++) {\n\t\t\trem += a[j] * j;\n\t\t\tif(a[j]!=0)\n\t\t\t\tmax=j;\n\t\t}\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, a, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i > max)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, a, now);\n\t\tif (a[i] > 0 && sum + i <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(i, sum + i, a, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\tpublic static int def_max = 0;\n\t\n\tpublic static int dps(int selected, int[] weight, int sum){\n\t\tint max = 0;\n\t\t\n\t\tif(sum / 10 - def_max < 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i = selected; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t\tsum -= cost;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(weight[j] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(i, weight, sum) + 1);\n\t\t\t\tdef_max = Math.max(max, def_max);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t\tsum += cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdef_max = 0;\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1; i < weights.length; i++){\n\t\t\t\tsum += weights[i] * i;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(0, weights, sum));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\n\tint[] c, u;\n\tint res;\n\t\n\tboolean f(int x, int rest){\n\t\tif(rest<0)return false;\n\t\tif(rest==0)return true;\n\t\tfor(int i=x;i>0;i--)if(c[i]-u[i]>0){\n\t\t\tu[i]++;\n\t\t\tif(f(i, rest-i))return true;\n\t\t\tu[i]--;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[11];\n\t\t\tfor(int i=0;i<n;i++)c[sc.nextInt()]++;\n\t\t\tres = c[5]/2;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<=9;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tres+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tu = new int[11];\n\t\t\tfor(int i=9;i>0;i--)if(c[i]>0){\n\t\t\t\tArrays.fill(u, 0);\n\t\t\t\tu[i]++;\n\t\t\t\tif(f(i, 10-i)){\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(int j=1;j<=9;j++)c[j]-=u[i];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[10];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\t\t\tans = -1;\n\t\t\tdfs(1, 0, a, 0);\n\t\t\tSystem.out.println(sum + ans);\n\t\t}\n\n\t}\n\n\tint ans;\n\n\tprivate void dfs(int i, int sum, int[] a, int now) {\n\t\tint rem = sum;\n\t\tfor (int j = 1; j < 10; j++)\n\t\t\trem += a[j] * j;\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, a, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i >= 10)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, a, now);\n\t\tif (a[i] > 0 && sum + i <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(i, sum + i, a, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[10];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, a, 0);\n\t\t\tSystem.out.println(sum + ans);\n\t\t}\n\n\t}\n\n\tint ans;\n\n\tprivate void dfs(int i, int sum, int[] a, int now) {\n\t\tint rem = sum;\n\t\tint max = 0;\n\t\tfor (int j = 1; j < 10; j++) {\n\t\t\trem += a[j] * j;\n\t\t\tif(a[j]!=0)\n\t\t\t\tmax=j;\n\t\t}\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, a, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i > max)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, a, now);\n\t\tif (a[i] > 0 && sum + i <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(i, sum + i, a, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[10];\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, 0);\n\t\t\tSystem.out.println(sum + ans);\n\n\t\t}\n\t}\n\n\tprivate void dfs(int i, int sum, int now) {\n\t\tint rem = sum;\n\t\tfor (int j = 1; j < 10; j++)\n\t\t\trem += a[j] * j;\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i == 10)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, now);\n\t\tif (a[i] > 0 && a[i] + sum <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(i, sum + i, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n\n\tint ans;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\n\tint[] c, u;\n\tint res;\n\t\n\tboolean f(int x, int rest){\n\t\tif(rest<0)return false;\n\t\tif(rest==0)return true;\n\t\tfor(int i=x;i>0;i--)if(c[i]-u[i]>0){\n\t\t\tu[i]++;\n\t\t\tif(f(i, rest-i))return true;\n\t\t\tu[i]--;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[11];\n\t\t\tfor(int i=0;i<n;i++)c[sc.nextInt()]++;\n\t\t\tres = c[5]/2;\n\t\t\tc[5]%=2;\n\t\t\tfor(int i=6;i<=9;i++){\n\t\t\t\tint t = Math.min(c[i], c[10-i]);\n\t\t\t\tres+=t;\n\t\t\t\tc[i]-=t;\n\t\t\t\tc[10-i]-=t;\n\t\t\t}\n\t\t\tu = new int[11];\n\t\t\tfor(int i=9;i>0;i--)if(c[i]>0){\n\t\t\t\tArrays.fill(u, 0);\n//\t\t\t\tSystem.out.println(\"I:\"+i+\" \"+c[i]);\n//\t\t\t\tdebug(c);\n\t\t\t\tu[i]++;\n\t\t\t\tif(f(10-i, 10-i)){\n\t\t\t\t\tres++;\n//\t\t\t\t\tdebug(u);\n\t\t\t\t\tfor(int j=1;j<=9;j++)c[j]-=u[j];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\t//public static int def_max = 0;\n\t\n\tpublic static long bit_trans(int[] weight){\n\t\tlong bit = 0;\n\t\t\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tbit <<= 5;\n\t\t\tbit |= weight[i];\n\t\t}\n\t\t\n\t\treturn bit;\n\t}\n\t\n\tpublic static int dps(int[] weight, Map<Long, Integer> memo, int sum){\n\t\tlong bit = bit_trans(weight);\n\t\t\n\t\tif(memo.containsKey(bit)){\n\t\t\treturn memo.get(bit);\n\t\t}\n\t\t\n\t\tint max = 0;\n\t\tfor(int i = 0; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t\tsum -= cost;\n\t\t\t\t\n\t\t\t\tif(weight[cost] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(weight, memo, sum) + 1);\n\t\t\t\t//def_max = Math.max(max, def_max);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t\tsum += cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.put(bit, max);\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//def_max = 0;\n\t\t\t\n\t\t\tint[] weights = new int[10];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1; i < weights.length; i++){\n\t\t\t\tsum += weights[i] * i;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(weights, map, sum));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n\t\tint res = b[5] / 2;\n\t\tb[5] %= 2;\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tint m = Math.min(b[i], b[10 - i]);\n\t\t\tb[i] -= m;\n\t\t\tb[10 - i] -= m;\n\t\t\tres += m;\n\t\t}\n\t\tpatternList = new java.util.ArrayList<int[]>();\n\t\tmake(b);\n\n\t\tmd = 0;\n\t\tsearch(b, 0, 0);\n\t\tSystem.out.println(res + md);\n\t}\n\t}\n\tint md;\n\tvoid search(int[] b, int d, int s) {\n\t\tif (d >= md) {\n\t\t\tmd = d;\n\t\t}\n\t\tfor (int i = s; i < patternList.size(); i++) {\n\t\t\tint[] p = patternList.get(i);\n\t\t\tboolean ok = true;\n\t\t\tfor (int x : p) {\n\t\t\t\t--b[x];\n\t\t\t\tif (b[x] < 0) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tsearch(b, d + 1, i);\n\t\t\t}\n\t\t\tfor (int x : p) ++b[x];\n\t\t}\n\t}\n\n\tList<int[]> patternList;\n\tvoid make(int[] b) {\n\t\tint[] pattern = new int[10];\n\t\tdfs(b, pattern, 0, 0);\n\t}\n\n\tvoid dfs(int[] b, int[] pattern, int depth, int sum) {\n\t\tif (sum == 10) {\n\t\t\tpatternList.add(Arrays.copyOf(pattern, depth));\n\t\t\treturn;\n\t\t}\n\t\tint s = (depth == 0) ? 1 : pattern[depth-1];\n\n\t\tfor (int i = s; i <= 9; i++) if (b[i] > 0 && sum + i <= 10) {\n\t\t\tpattern[depth] = i;\n\t\t\tdfs(b, pattern, depth + 1, sum + i);\n\t\t\tpattern[depth] = 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Take{\n\t\tint cur,pos;\n\t\tLinkedList<Integer> list;\n\t\t\n\t\tpublic Take(int cur, int pos, LinkedList<Integer> list) {\n\t\t\tsuper();\n\t\t\tthis.cur = cur;\n\t\t\tthis.pos = pos;\n\t\t\tthis.list = list;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> array = new ArrayList<Integer>(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tarray.add(sc.nextInt());\n\t\t\t}\n\t\t\tCollections.sort(array, Collections.reverseOrder());\n\t\t\t//System.out.println(array);\n\t\t\t\n\t\t\tLinkedList<Take> list = new LinkedList<Take>();\n\t\t\t\n\t\t\n\t\t\tint count = 0;\n\t\t\twhile(true){\n\t\t\t\tint cur = 0;\n\t\t\t\tboolean update = false;\n\t\t\t\tlist.clear();\n\t\t\t\t\n\t\t\t\tlist.add(new Take(0,0, new LinkedList<Integer>()));\n\t\t\t\tTake ans = null;\n\t\t\t\t\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\tTake take = list.poll();\n\t\t\t\t\t\n\t\t\t\t\tif(take.cur == 10){\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tans = take;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(take.pos + 1 <= array.size()){\n\t\t\t\t\t\tif(take.cur + array.get(take.pos) <= 10){\n\t\t\t\t\t\t\tLinkedList<Integer> tmp =  new LinkedList<Integer>(take.list);\n\t\t\t\t\t\t\ttmp.add(take.pos);\n\t\t\t\t\t\t\tlist.add(new Take(take.cur + array.get(take.pos), take.pos + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(new Take(take.cur, take.pos + 1, new LinkedList<Integer>(take.list)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!update){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(array);\n\t\t\t\tfor(int i : list){\n\t\t\t\t\tSystem.out.print(array.get(i) + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\twhile(!ans.list.isEmpty()){\n\t\t\t\t\tarray.remove((int) ans.list.pollLast());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\n\tint[] c, u, limit, tmp;\n\tint res;\n\t\n\tboolean f(int x, int rest){\n\t\tif(rest<0)return false;\n\t\tif(rest==0)return true;\n\t\tfor(int i=Math.min(x, rest);i>0;i--)if(c[i]-u[i]>0){\n\t\t\tu[i]++;\n\t\t\tint nx = rest-i;\n\t\t\tif(rest==10 && i>=5)nx--;\n\t\t\tif(f(i, nx))return true;\n\t\t\tu[i]--;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tint greedy(){\n\t\tArrays.fill(u, 0);\n\t\tint ret = 0;\n\t\twhile(f(9, 10)){\n\t\t\tfor(int i=1;i<=9;i++)c[i]-=u[i];\n\t\t\tArrays.fill(u, 0);\n\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid dfs(int k, int sum){\n\t\tif(k==10){\n\t\t\tfor(int i=1;i<=9;i++)tmp[i]=c[i];\n//\t\t\tdebug(c);\n\t\t\tint g = greedy();\n//\t\t\tSystem.out.println(\"SUM:\"+sum+\" G:\"+g);\n//\t\t\tdebug(c);\n\t\t\tres = Math.max(res, sum+g);\n\t\t\tfor(int i=1;i<=9;i++)c[i]=tmp[i];\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=limit[k];i>=0;i--){\n\t\t\tc[k]-=i;\n\t\t\tc[10-k]-=i;\n\t\t\tdfs(k+1, sum+i);\n\t\t\tc[k]+=i;\n\t\t\tc[10-k]+=i;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[11];\n\t\t\tlimit = new int[11];\n\t\t\tu = new int[11];\n\t\t\ttmp = new int[11];\n\t\t\tfor(int i=0;i<n;i++)c[sc.nextInt()]++;\n//\t\t\tdebug(c);\n//\t\t\tSystem.out.println(greedy());\n\t\t\tlimit[5] = c[5]/2;\n\t\t\tfor(int i=6;i<=9;i++)limit[i] = Math.min(c[i], c[10-i]);\n\t\t\tdfs(5, 0);\n//\t\t\tdebug(c);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[10];\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, 0);\n\t\t\tSystem.out.println(sum + ans);\n\n\t\t}\n\t}\n\n\tprivate void dfs(int i, int sum, int now) {\n\t\tint rem = sum;\n\t\tfor (int j = 1; j < 10; j++)\n\t\t\trem += a[j] * j;\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i == 10)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, now);\n\t\tif (a[i] > 0 && i + sum <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(1, sum + i, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n\n\tint ans;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n//\t\tres = b[5] / 2;\n//\t\tb[5] %= 2;\n//\t\tfor (int i = 1; i <= 4; i++) {\n//\t\t\tint m = Math.min(b[i], b[10 - i]);\n//\t\t\tb[i] -= m;\n//\t\t\tb[10 - i] -= m;\n//\t\t\tres += m;\n//\t\t}\n\t\tres = 0;\n\t\tfor (;;) {\n\t\t\ttry {\n\t\t\t\tdfs(b, 9, 0);\n\t\t\t} catch (ProgramException e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t}\n\tint res;\n\n\tvoid dfs(int[] b, int s, int cur) throws ProgramException {\n\t\tif (cur == 10) {\n\t\t\tres++;\n\t\t\tthrow new ProgramException();\n\t\t}\n\t\tfor (int i = s; i >= 1; i--) {\n\t\t\tif (b[i] > 0 && cur + i <= 10) {\n\t\t\t\tb[i]--;\n\t\t\t\tdfs(b, i, cur + i);\n\t\t\t\tb[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass ProgramException extends Exception {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3,1},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\tpublic static int dps(int selected, int[] weight){\n\t\tint max = 0;\n\t\t\n\t\tfor(int i = selected; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(weight[j] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(i, weight) + 1);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(0, weights));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bara-Bara Manju\npublic class Main{\n\t\n\tint res, num, ID;\n\tint[][] div;\n\tint[] c, u;\n//\tlong S;\n\t\n\tvoid f(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=1;i<10;i++)div[ID][i] = u[i];\n\t\t\tID++;\n\t\t\treturn;\n\t\t}\n\t\tif(k<=0)return;\n\t\tfor(int use=0;use*k<=rest;use++){\n\t\t\tu[k] = use;\n\t\t\tf(k-1, rest-use*k);\n\t\t\tu[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid dfs(int k, int num, int sum){\n//\t\tif(res<num)System.out.println(num+\" Time:\"+(System.currentTimeMillis()-S));\n\t\tres = Math.max(res, num);\n\t\tif(k==ID || num+sum/10 <= res)return;\n\t\tint t = 1000;\n\t\tfor(int i=1;i<10;i++)if(div[k][i]>0)t = Math.min(t, c[i]/div[k][i]);\n\t\tfor(int use=0;use<=t;use++){\n\t\t\tfor(int i=1;i<10;i++)c[i]-=use*div[k][i];\n//\t\t\tSystem.out.println(\"K:\"+k+\" Use:\"+use);\n\t\t\tdfs(k+1, num+use, sum-use*10);\n\t\t\tfor(int i=1;i<10;i++)c[i]+=use*div[k][i];\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdiv = new int[50][11];\n\t\tu = new int[11];\n\t\tf(9, 10);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tS = System.currentTimeMillis();\n\t\t\tc = new int[11];\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tc[x]++;\n\t\t\t\tsum+=x;\n\t\t\t}\n//\t\t\tint g = c[5]/2;\n//\t\t\tsum-=g*10;\n//\t\t\tc[5]%=2;\n//\t\t\tfor(int i=6;i<10;i++){\n//\t\t\t\tint t = Math.min(c[i], c[10-i]);\n//\t\t\t\tsum-=10*t;\n//\t\t\t\tg+=t;\n//\t\t\t\tc[i]-=t;\n//\t\t\t\tc[10-i]-=t;\n//\t\t\t}\n//\t\t\tres = 0;\n\t\t\tdfs(0, 0, sum);\n\t\t\tSystem.out.println(res);\n//\t\t\tSystem.out.println(System.currentTimeMillis()-S);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[10];\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, 0);\n\t\t\tSystem.out.println(sum + ans);\n\n\t\t}\n\t}\n\n\tprivate void dfs(int i, int sum, int now) {\n\t\tint rem = sum;\n\t\tfor (int j = 1; j < 10; j++)\n\t\t\trem += a[j] * j;\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i == 10)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, now);\n\t\tif (a[i] > 0 && a[i] + sum <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(1, sum + i, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n\n\tint ans;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[10];\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\ta[b]++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\tint c = Math.min(a[i], a[10 - i]);\n\t\t\t\tsum += c;\n\t\t\t\ta[i] -= c;\n\t\t\t\ta[10 - i] -= c;\n\t\t\t}\n\t\t\tsum += a[5] / 2;\n\t\t\ta[5] %= 2;\n\n\t\t\tans = 0;\n\t\t\tdfs(1, 0, 0);\n\t\t\tSystem.out.println(sum + ans);\n\n\t\t}\n\t}\n\n\tprivate void dfs(int i, int sum, int now) {\n\t\tint rem = sum;\n\t\tfor (int j = 1; j < 10; j++)\n\t\t\trem += a[j] * j;\n\t\tif (now + rem / 10 <= ans)\n\t\t\treturn;\n\t\tans = Math.max(ans, now);\n\t\tif (sum == 10) {\n\t\t\tdfs(1, 0, now + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (i == 10)\n\t\t\treturn;\n\t\tdfs(i + 1, sum, now);\n\t\tif (a[i] > 0 && i + sum <= 10) {\n\t\t\ta[i]--;\n\t\t\tdfs(i, sum + i, now);\n\t\t\ta[i]++;\n\t\t}\n\t}\n\n\tint ans;\n\tint[] a;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\tpublic static int dps(int selected, int[] weight){\n\t\tint max = 0;\n\t\t\n\t\tfor(int i = selected; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(weight[j] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(i, weight) + 1);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(0, weights));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\tpublic static int def_max = 0;\n\t\n\tpublic static int dps(int selected, int[] weight, int sum){\n\t\tint max = 0;\n\t\t\n\t\tif(sum / 10 - def_max <= 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i = selected; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t\tsum -= cost;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(weight[j] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(i, weight, sum) + 1);\n\t\t\t\tdef_max = Math.max(max, def_max);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t\tsum += cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] weights = new int[11];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1; i < weights.length; i++){\n\t\t\t\tsum += weights[i] * i;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(0, weights, sum));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\tfor (;;) {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint[] b = new int[10];\n\t\tfor (int x : a) b[x]++;\n\t\tint res = b[5] / 2;\n\t\tb[5] %= 2;\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tint m = Math.min(b[i], b[10 - i]);\n\t\t\tb[i] -= m;\n\t\t\tb[10 - i] -= m;\n\t\t\tres += m;\n\t\t}\n\t\tpatternList = new java.util.ArrayList<int[][]>();\n\t\tmake(b);\n\t\tmd = 0;\n\t\tsearch(b, 0, 0);\n\t\tSystem.out.println(res + md);\n\t}\n\t}\n\tint md;\n\tvoid search(int[] b, int d, int s) {\n\t\tif (d >= md) {\n\t\t\tmd = d;\n\t\t}\n\t\tfor (int i = s; i < patternList.size(); i++) {\n\t\t\tint[][] p = patternList.get(i);\n\t\t\tboolean ok = true;\n\t\t\tfor (int[] k : p) {\n\t\t\t\tb[k[0]] -= k[1];\n\t\t\t\tif (b[k[0]] < 0) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tsearch(b, d + 1, i);\n\t\t\t}\n\t\t\tfor (int[] k : p) {\n\t\t\t\tb[k[0]] += k[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tList<int[][]> patternList;\n\tvoid make(int[] b) {\n\t\tint[] pattern = new int[10];\n\t\tdfs(b, pattern, 0, 0);\n\t}\n\n\tvoid dfs(int[] b, int[] pattern, int depth, int sum) {\n\t\tif (sum == 10) {\n\t\t\tint[] hist = new int[10];\n\t\t\tfor (int i = 0; i < depth; i++) {\n\t\t\t\thist[pattern[i]]++;\n\t\t\t}\n\t\t\tint nz = 0;\n\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) nz++;\n\t\t\tif (nz > 2) {\n\t\t\t\tint[][] k = new int[nz][2];\n\t\t\t\tint p = 0;\n\t\t\t\tfor (int i = 0; i < hist.length; i++) if (hist[i] > 0) {\n\t\t\t\t\tk[p][0] = i;\n\t\t\t\t\tk[p][1] = hist[i];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tpatternList.add(k);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = (depth == 0) ? 1 : pattern[depth-1];\n\n\t\tfor (int i = s; i <= 9; i++) if (b[i] > 0 && sum + i <= 10) {\n\t\t\tpattern[depth] = i;\n\t\t\tdfs(b, pattern, depth + 1, sum + i);\n\t\t\tpattern[depth] = 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\t\n\tint nap[];\n\tint target = 10;\n\tint max_depth;\n\t\n\tvoid dfs(int g, int depth){\n\t\tif(g==target){\n\t\t\tif(max_depth < depth){\n\t\t\t\tmax_depth = depth;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<nap.length; ++i){\n\t\t\tif(0<nap[i]){\t//とったやつは-1にwriteしている\n\t\t\t\tint tmp = nap[i];\n\t\t\t\tif(10<g+tmp){break;}\t//sortしたから\n\t\t\t\tnap[i] = -1;\n\t\t\t\tdfs(g+tmp, depth+1);\n\t\t\t\tnap[i] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint solve(){\n\t\tdfs(0, 0);\n\t\treturn max_depth;\n\t}\n\t\n\tvoid io(){\n\t\tjava.util.Scanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tif(n==0){ break; }\n\t\t\tnap = new int[n];\n\t\t\tmax_depth=0;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tnap[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(nap);\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] col = \n\t\t{\n\t\t\t{1,1,1,1,1,1,1,1,1,1},\n\t\t\t{2,1,1,1,1,1,1,1,1},\n\t\t\t{2,2,1,1,1,1,1,1},\n\t\t\t{2,2,2,1,1,1,1},\n\t\t\t{2,2,2,2,1,1},\n\t\t\t{2,2,2,2,2},\n\t\t\t{3,1,1,1,1,1,1,1},\n\t\t\t{3,2,1,1,1,1,1},\n\t\t\t{3,2,2,1,1,1},\n\t\t\t{3,2,2,2,1},\n\t\t\t{3,3,1,1,1,1},\n\t\t\t{3,3,2,1,1},\n\t\t\t{3,3,2,2},\n\t\t\t{3,3,3,1},\n\t\t\t{4,1,1,1,1,1,1},\n\t\t\t{4,2,1,1,1,1},\n\t\t\t{4,2,2,1,1},\n\t\t\t{4,2,2,2},\n\t\t\t{4,3,1,1,1},\n\t\t\t{4,3,2,1},\n\t\t\t{4,3,3},\n\t\t\t{4,4,1,1},\n\t\t\t{4,4,2},\n\t\t\t{5,1,1,1,1,1},\n\t\t\t{5,2,1,1,1},\n\t\t\t{5,2,2,1},\n\t\t\t{5,3,1,1},\n\t\t\t{5,3,2},\n\t\t\t{5,4,1},\n\t\t\t{6,1,1,1,1},\n\t\t\t{6,2,1,1},\n\t\t\t{6,2,2},\n\t\t\t{6,3,1},\n\t\t\t{7,1,1,1},\n\t\t\t{7,2,1},\n\t\t\t{8,1,1}\n\t\t};\n\t\n\t//public static int def_max = 0;\n\t\n\tpublic static long bit_trans(int[] weight){\n\t\tlong bit = 0;\n\t\t\n\t\tfor(int i = 1; i < 10; i++){\n\t\t\tbit <<= 7;\n\t\t\tbit |= weight[i];\n\t\t}\n\t\t\n\t\treturn bit;\n\t}\n\t\n\tpublic static int dps(int[] weight, Map<Long, Integer> memo, int sum){\n\t\tlong bit = bit_trans(weight);\n\t\t\n\t\tif(memo.containsKey(bit)){\n\t\t\treturn memo.get(bit);\n\t\t}\n\t\t\n\t\tint max = 0;\n\t\tfor(int i = 0; i < col.length; i++){\n\t\t\tboolean ok = true;\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]--;\n\t\t\t\tsum -= cost;\n\t\t\t\t\n\t\t\t\tif(weight[cost] < 0){\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tmax = Math.max(max, dps(weight, memo, sum) + 1);\n\t\t\t\t//def_max = Math.max(max, def_max);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cost : col[i]){\n\t\t\t\tweight[cost]++;\n\t\t\t\tsum += cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.put(bit, max);\n\t\t\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//def_max = 0;\n\t\t\t\n\t\t\tint[] weights = new int[10];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tweights[sc.nextInt()]++;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tcount += weights[5] / 2;\n\t\t\tweights[5] %= 2;\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\tint min = Math.min(weights[5 + i], weights[5 - i]);\n\t\t\t\t\n\t\t\t\tcount += min;\n\t\t\t\tweights[5 + i] -= min;\n\t\t\t\tweights[5 - i] -= min;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1; i < weights.length; i++){\n\t\t\t\tsum += weights[i] * i;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(weights));\n\t\t\tSystem.out.println(count + dps(weights, map, sum));\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tint nap[];\n\tint target = 10;\n\tTreeSet<int[]> set;\n\tHashMap<Integer, Integer> map;\n\t\n\t/**\n\t * setの初期化をします。\n\t */\n\tvoid hoge(){\n\t\tset=new TreeSet<int[]>(new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] is1, int[] is2) {\n\t\t\t\t// ひかく\n\t\t\t\tif(is1.length == is2.length){\n\t\t\t\t\tfor(int i=0; i<is1.length; ++i){\n\t\t\t\t\t\tif(is1[i] > is2[i]){\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}else if(is1[i] < is2[i]){\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(is1.length > is2.length){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tvoid dfs(int g, int depth, int index, ArrayList<Integer> v){\n\t\tif(g==target){\n\t\t\tif(!map.containsKey(depth)){\n\t\t\t\tmap.put(depth, 0);\n\t\t\t}\n\t\t\tint[] list = new int[v.size()];\n\t\t\tfor(int i=0; i<v.size(); ++i){\n\t\t\t\tlist[i] = v.get(i);\n\t\t\t}\n\t\t\tif(set.add(list)){\n\t\t\t\tmap.put(depth, map.get(depth)+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=index; i<nap.length; ++i){\n\t\t\tint tmp = nap[i];\n\t\t\tif(10<g+tmp){break;}\t//sortしたから\n\t\t\tv.add(tmp);\n\t\t\tdfs(g+tmp, depth+1, i+1, v);\n\t\t\tv.remove(v.size()-1);\n\t\t}\n\t}\n\t\n\tint solve(){\n\t\tmap = new HashMap<Integer, Integer>();\n\t\tdfs(0, 0, 0, new ArrayList<Integer>());\n\t\tint max = 0;\n\t\tint count=0;\n\t\tfor(int i=0; count<map.size(); ++i){\n\t\t\tif(map.containsKey(i)){\n\t\t\t\t++count;\n\t\t\t\tint size = map.get(i);\n\t\t\t\tif(max < size){\n\t\t\t\t\tmax = size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\t\n\tvoid io(){\n\t\tjava.util.Scanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tif(n==0){ break; }\n\t\t\tnap = new int[n];\n\t\t\thoge();\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tnap[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(nap);\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0246\n{\n    class Program\n    {\n\n        static public int[] buns;\n        static int res;\n        static private List<int[]> ptn = new List<int[]>();\n\n        static void Main(string[] args)\n        {\n            MakePtn(new List<long>(), 0);\n            List<string> input = new List<string>();\n            input = new List<string>();\n\n            while (true)\n            {\n\n                int n = RInt();\n                if (n == 0) break;\n                int[] vs = RArInt();\n\n                res = 0;\n                buns = new int[10];\n                for (int i = 0; i < vs.Length; i++) buns[vs[i]]++;\n\n                res += GetTwoPairs();\n                res += GetOtherPairs(buns, new Dictionary<ulong, int>());\n                Console.WriteLine(res);\n            }\n        }\n\n        private static void MakePtn(List<long> vs, long sum)\n        {\n            if (sum == 10)\n            {\n                int[] cnts = new int[10];\n                for (int i = 0; i < vs.Count(); i++)\n                {\n                    cnts[vs[i]]++;\n                }\n                ptn.Add(cnts);\n            }\n            else\n            {\n                long s = vs.Count == 0 ? 1 : vs.Last();\n                for (long i = s; i + sum < 10; i++)\n                {\n                    List<long> tn = new List<long>(vs); tn.Add(i);\n                    MakePtn(new List<long>(tn), sum + i);\n                }\n            }\n        }\n\n        private static int GetTwoPairs()\n        {\n            int res = 0, cnt = 0;\n            for (int i = 1; i < buns.Length / 2; i++)\n            {\n                cnt = Math.Min(buns[i], buns[buns.Length - i]);\n                res += cnt;\n                buns[i] -= cnt;\n                buns[buns.Length - i] -= cnt;\n            }\n            res += buns[buns.Length / 2] / 2;\n            buns[buns.Length / 2] = buns[buns.Length / 2] % 2;\n            return res;\n        }\n\n        private static int GetOtherPairs(int[] rems, Dictionary<ulong, int> memo)\n        {\n            ulong bitRems = ChangeIArrToBit(rems);\n            if (memo.ContainsKey(bitRems)) return memo[bitRems];\n\n            int cnt = 0;\n            for (int i = 0; i < ptn.Count(); i++)\n            {\n                int[] newRems = new int[rems.Length];\n                Array.Copy(rems, newRems, rems.Length);\n                if (RemoveRems(newRems, ptn[i]))\n                {\n                    cnt = Math.Max(cnt, 1 + GetOtherPairs(newRems, memo));\n                }\n            }\n            memo.Add(bitRems, cnt);\n            return cnt;\n        }\n\n        private static bool RemoveRems(int[] rems, int[] ptn)\n        {\n            for (int i = 0; i < ptn.Length; i++)\n            {\n                rems[i] -= ptn[i];\n                if (rems[i] < 0) return false;\n            }\n            return true;\n        }\n\n        private static ulong ChangeIArrToBit(int[] cnts)\n        {\n            ulong res = 0;\n            for (int i = 0; i < cnts.Length; i++)\n            {\n                res |= (ulong)cnts[i] << (i * 7);\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0246\n{\n    class Program\n    {\n\n        static public int[] buns;\n        static int res;\n        static private List<int[]> ptn = new List<int[]>();\n\n        static void Main(string[] args)\n        {\n            MakePtn(new List<long>(), 0);\n            List<string> input = new List<string>();\n            input = new List<string>();\n\n            while (true)\n            {\n\n                int n = RInt();\n                if (n == 0) break;\n                int[] vs = RArInt();\n\n                res = 0;\n                buns = new int[10];\n                for (int i = 0; i < vs.Length; i++) buns[vs[i]]++;\n\n                res += GetTwoPairs();\n                res += GetOtherPairs(buns, buns.Select((x, i) => i * buns[i]).Sum(), new Dictionary<ulong, int>());\n                Console.WriteLine(res);\n            }\n        }\n\n        private static void MakePtn(List<long> vs, long sum)\n        {\n            if (sum == 10)\n            {\n                int[] cnts = new int[10];\n                for (int i = 0; i < vs.Count(); i++)\n                {\n                    cnts[vs[i]]++;\n                }\n                ptn.Add(cnts);\n            }\n            else\n            {\n                long s = vs.Count == 0 ? 1 : vs.Last();\n                for (long i = s; i + sum <= 10; i++)\n                {\n                    if (i == 10) continue;\n                    List<long> tn = new List<long>(vs); tn.Add(i);\n                    MakePtn(new List<long>(tn), sum + i);\n                }\n            }\n        }\n\n        private static int GetTwoPairs()\n        {\n            int res = 0, cnt = 0;\n            for (int i = 1; i < buns.Length / 2; i++)\n            {\n                cnt = Math.Min(buns[i], buns[buns.Length - i]);\n                res += cnt;\n                buns[i] -= cnt;\n                buns[buns.Length - i] -= cnt;\n            }\n            res += buns[buns.Length / 2] / 2;\n            buns[buns.Length / 2] = buns[buns.Length / 2] % 2;\n            return res;\n        }\n\n        private static int GetOtherPairs(int[] rems, int sum, Dictionary<ulong, int> memo)\n        {\n            ulong bitRems = ChangeIArrToBit(rems);\n            if (memo.ContainsKey(bitRems)) return memo[bitRems];\n\n            int cnt = 0;\n            for (int i = 0; i < ptn.Count(); i++)\n            {\n                int[] newRems = new int[rems.Length];\n                Array.Copy(rems, newRems, rems.Length);\n                if (RemoveRems(newRems, ptn[i]))\n                {\n                    cnt = Math.Max(cnt, 1 + GetOtherPairs(newRems, sum - 10, memo));\n                }\n            }\n            memo.Add(bitRems, cnt);\n            return cnt;\n        }\n\n        private static bool RemoveRems(int[] rems, int[] ptn)\n        {\n            for (int i = 0; i < ptn.Length; i++)\n            {\n                rems[i] -= ptn[i];\n                if (rems[i] < 0) return false;\n            }\n            return true;\n        }\n\n        private static ulong ChangeIArrToBit(int[] cnts)\n        {\n            ulong res = 0;\n            for (int i = 0; i < cnts.Length; i++)\n            {\n                res |= (ulong)cnts[i] << (i * 7);\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0246\n{\n    class Program\n    {\n\n        static public int[] buns;\n        static int res;\n        static private List<int[]> ptn = new List<int[]>();\n\n        static void Main(string[] args)\n        {\n            MakePtn(new List<long>(), 0);\n            List<string> input = new List<string>();\n            input = new List<string>();\n\n            while (true)\n            {\n\n                int n = RInt();\n                if (n == 0) break;\n                int[] vs = RArInt();\n\n                res = 0;\n                buns = new int[10];\n                for (int i = 0; i < vs.Length; i++) buns[vs[i]]++;\n\n                res += GetTwoPairs();\n                res += GetOtherPairs(buns, buns.Select((x, i) => i * buns[i]).Sum(), new Dictionary<ulong, int>());\n                Console.WriteLine(res);\n            }\n        }\n\n        private static void MakePtn(List<long> vs, long sum)\n        {\n            if (sum == 10)\n            {\n                int[] cnts = new int[10];\n                for (int i = 0; i < vs.Count(); i++)\n                {\n                    cnts[vs[i]]++;\n                }\n                ptn.Add(cnts);\n            }\n            else\n            {\n                long s = vs.Count == 0 ? 1 : vs.Last();\n                for (long i = s; i + sum <= 10; i++)\n                {\n                    if (i == 10) continue;\n                    List<long> tn = new List<long>(vs); tn.Add(i);\n                    MakePtn(new List<long>(tn), sum + i);\n                }\n            }\n        }\n\n        private static int GetTwoPairs()\n        {\n            int res = 0, cnt = 0;\n            for (int i = 1; i < buns.Length / 2; i++)\n            {\n                cnt = Math.Min(buns[i], buns[buns.Length - i]);\n                res += cnt;\n                buns[i] -= cnt;\n                buns[buns.Length - i] -= cnt;\n            }\n            res += buns[buns.Length / 2] / 2;\n            buns[buns.Length / 2] = buns[buns.Length / 2] % 2;\n            return res;\n        }\n\n        private static int GetOtherPairs(int[] rems, int sum, Dictionary<ulong, int> memo)\n        {\n            ulong bitRems = ChangeIArrToBit(rems);\n            if (memo.ContainsKey(bitRems)) return memo[bitRems];\n\n            int cnt = 0;\n            for (int i = 0; i < ptn.Count(); i++)\n            {\n                int[] newRems = new int[rems.Length];\n                Array.Copy(rems, newRems, rems.Length);\n                if (RemoveRems(newRems, ptn[i]))\n                {\n                    cnt = Math.Max(cnt, 1 + GetOtherPairs(newRems, sum - 10, memo));\n                }\n            }\n            memo.Add(bitRems, cnt);\n            return cnt;\n        }\n\n        private static bool RemoveRems(int[] rems, int[] ptn)\n        {\n            for (int i = 0; i < ptn.Length; i++)\n            {\n                rems[i] -= ptn[i];\n                if (rems[i] < 0) return false;\n            }\n            return true;\n        }\n\n        private static ulong ChangeIArrToBit(int[] cnts)\n        {\n            ulong res = 0;\n            for (int i = 0; i < cnts.Length; i++)\n            {\n                res |= (ulong)cnts[i] << (i * 7);\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0246\n{\n    class Program\n    {\n\n        static public int[] buns;\n        static private List<int[]> ptn = new List<int[]>();\n\n        static void Main(string[] args)\n        {\n            MakePtn(new List<long>(), 0);\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n                int[] vs = RArInt();\n            \n                buns = new int[10];\n                for (int i = 0; i < vs.Length; i++) buns[vs[i]]++;\n\n                int res = 0;\n                res += GetTwoPairs();\n                res += GetOtherPairs(buns, new Dictionary<ulong, int>());\n                Console.WriteLine(res);\n            }\n        }\n\n        private static void MakePtn(List<long> vs, long sum)\n        {\n            if (sum == 10)\n            {\n                int[] cnts = new int[10];\n                for (int i = 0; i < vs.Count(); i++) cnts[vs[i]]++;\n                ptn.Add(cnts);\n            }\n            else\n            {\n                long s = vs.Count == 0 ? 1 : vs.Last();\n                for (long i = s; i + sum <= 10; i++)\n                {\n                    if (i == 10) continue;\n                    List<long> tn = new List<long>(vs); tn.Add(i);\n                    MakePtn(new List<long>(tn), sum + i);\n                }\n            }\n        }\n\n        private static int GetTwoPairs()\n        {\n            int res = 0, cnt = 0;\n            for (int i = 1; i < buns.Length / 2; i++)\n            {\n                cnt = Math.Min(buns[i], buns[buns.Length - i]);\n                res += cnt;\n                buns[i] -= cnt;\n                buns[buns.Length - i] -= cnt;\n            }\n            res += buns[buns.Length / 2] / 2;\n            buns[buns.Length / 2] = buns[buns.Length / 2] % 2;\n            return res;\n        }\n\n        private static int GetOtherPairs(int[] rems, Dictionary<ulong, int> memo)\n        {\n            ulong bitRems = ChangeIArrToBit(rems);\n            if (memo.ContainsKey(bitRems)) return memo[bitRems];\n\n            int cnt = 0;\n            for (int i = 0; i < ptn.Count(); i++)\n            {\n                int[] newRems = new int[rems.Length];\n                Array.Copy(rems, newRems, rems.Length);\n                if (RemoveRems(newRems, ptn[i]))\n                {\n                    cnt = Math.Max(cnt, 1 + GetOtherPairs(newRems, memo));\n                }\n            }\n            memo.Add(bitRems, cnt);\n            return cnt;\n        }\n\n        private static bool RemoveRems(int[] rems, int[] ptn)\n        {\n            for (int i = 0; i < ptn.Length; i++)\n            {\n                rems[i] -= ptn[i];\n                if (rems[i] < 0) return false;\n            }\n            return true;\n        }\n\n        private static ulong ChangeIArrToBit(int[] cnts)\n        {\n            ulong res = 0;\n            for (int i = 0; i < cnts.Length; i++)\n            {\n                res |= (ulong)cnts[i] << (i * 7);\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0246\n{\n    class Program\n    {\n\n        static public int[] buns;\n        static private List<int[]> ptn = new List<int[]>();\n\n        static void Main(string[] args)\n        {\n            MakePtn(new List<long>(), 0);\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n                int[] vs = RArInt();\n            \n                buns = new int[10];\n                for (int i = 0; i < vs.Length; i++) buns[vs[i]]++;\n\n                int res = 0;\n                res += GetTwoPairs();\n                res += GetOtherGroups(buns, new Dictionary<ulong, int>());\n                Console.WriteLine(res);\n            }\n        }\n\n        private static void MakePtn(List<long> vs, long sum)\n        {\n            if (sum == 10)\n            {\n                int[] cnts = new int[10];\n                for (int i = 0; i < vs.Count(); i++) cnts[vs[i]]++;\n                ptn.Add(cnts);\n            }\n            else\n            {\n                long s = vs.Count == 0 ? 1 : vs.Last();\n                for (long i = s; i + sum <= 10; i++)\n                {\n                    if (i == 10) continue;\n                    List<long> tn = new List<long>(vs); tn.Add(i);\n                    MakePtn(new List<long>(tn), sum + i);\n                }\n            }\n        }\n\n        private static int GetTwoPairs()\n        {\n            int res = 0, cnt = 0;\n            for (int i = 1; i < buns.Length / 2; i++)\n            {\n                cnt = Math.Min(buns[i], buns[buns.Length - i]);\n                res += cnt;\n                buns[i] -= cnt;\n                buns[buns.Length - i] -= cnt;\n            }\n            res += buns[buns.Length / 2] / 2;\n            buns[buns.Length / 2] = buns[buns.Length / 2] % 2;\n            return res;\n        }\n\n        private static int GetOtherGroups(int[] rems, Dictionary<ulong, int> memo)\n        {\n            ulong bitRems = ChangeIArrToBit(rems);\n            if (memo.ContainsKey(bitRems)) return memo[bitRems];\n\n            int cnt = 0;\n            for (int i = 0; i < ptn.Count(); i++)\n            {\n                int[] newRems = new int[rems.Length];\n                Array.Copy(rems, newRems, rems.Length);\n                if (RemoveRems(newRems, ptn[i]))\n                {\n                    cnt = Math.Max(cnt, 1 + GetOtherGroups(newRems, memo));\n                }\n            }\n            memo.Add(bitRems, cnt);\n            return cnt;\n        }\n\n        private static bool RemoveRems(int[] rems, int[] ptn)\n        {\n            for (int i = 0; i < ptn.Length; i++)\n            {\n                rems[i] -= ptn[i];\n                if (rems[i] < 0) return false;\n            }\n            return true;\n        }\n\n        private static ulong ChangeIArrToBit(int[] cnts)\n        {\n            ulong res = 0;\n            for (int i = 0; i < cnts.Length; i++)\n            {\n                res |= (ulong)cnts[i] << (i * 7);\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nM=10\nwhile 0<n=gets.to_i\na=gets.split.map &:to_i\nh=Hash.new 0\na.each{|e|h[e]+=1}\np a.count{|e|\n\tnext if h[e]==0\n\th[e]-=1\n\tM.downto(1){|i|(h[i]-=1;e+=i)while h[i]>0&&e+i<=M}\n}\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nM=9\nwhile 0<n=gets.to_i\na=gets.split.map &:to_i\nh=Hash.new 0\na.each{|e|h[e]+=1}\np a.count{|e|\n\tnext if h[e]==0\n\th[e]-=1\n\tM.downto(1){|i|(h[i]-=1;e+=i)while h[i]>0&&e+i<=M}\n}\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nSUM_W = 10\n\n### subroutines\n\ndef count_manju(k, w, bits)\n  if k >= $n\n    return ($cmcache[0][bits] = (w == 0) ? 1 + count_manju(0, SUM_W, bits) : 0)\n  end\n\n  return $cmcache[w][bits] if ! $cmcache[w][bits].nil?\n\n  max_count = count_manju(k + 1, w, bits)\n\n  mj = $manju[k]\n  b = (1 << k)\n\n  if w >= mj && (bits & b) == 0\n    c = count_manju(k + 1, w - mj, bits | b)\n    max_count = c if max_count < c\n  end\n\n  $cmcache[w][bits] = max_count\nend\n\n### main\n\nwhile true\n  $n = gets.strip.to_i\n  break if $n == 0\n\n  $manju = gets.strip.split(' ').map{|s| s.to_i }\n  #p $manju\n\n  $cmcache = (SUM_W + 1).times.map{{}}\n\n  c = count_manju(0, SUM_W, 0)\n  puts c\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nSUM_W = 10\n\n### subroutines\n\ndef pack_manju(k, w, mj)\n  if k >= 9\n    return (w == 0 ? [mj.clone] : [])\n  end\n\n  mjs = []\n  mjk = $manju[k]\n\n  for i in (0..mjk)\n    w0 = w - (k + 1) * i\n    if w0 >= 0\n      mj[k] = i\n      mjs0 = pack_manju(k + 1, w0, mj)\n      mjs += mjs0\n    end\n  end\n\n  mjs\nend\n\ndef max_count_pack(k, mj, mjs)\n  return 1 if k >= mjs.length\n\n  mc0 = max_count_pack(k + 1, mj, mjs)\n\n  mj0 = []\n  for i in (0..8)\n    mj0[i] = mj[i] + mjs[k][i]\n    if mj0[i] > $manju[i]\n      return mc0\n    end\n  end\n\n  mc1 = 1 + max_count_pack(k + 1, mj0, mjs)\n\n  (mc0 > mc1) ? mc0 : mc1\nend\n\n### main\n\nwhile true\n  $n = gets.strip.to_i\n  break if $n == 0\n\n  $manju = 9.times.map{0}\n\n  gets.strip.split(' ').map{|s| $manju[s.to_i - 1] += 1}\n  #p $manju\n  #p $manju.inject(1){|s, m| s * m}\n\n  mc = 0\n\n  for i in (0..3)\n    m = [$manju[i], $manju[8 - i]].min\n    $manju[i] -= m\n    $manju[8 - i] -= m\n    mc += m\n  end\n\n  m = $manju[4] / 2\n  $manju[4] -= 2 * m\n  mc += m\n\n  #p $manju\n  #p $manju.select{|m| m > 0}.inject(1){|s, m| s * m}\n  #p mc\n\n  mjs = pack_manju(0, SUM_W, [])\n  #p mjs\n  #p mjs.length\n\n  mc += max_count_pack(0, [0] * 9, mjs) - 1\n  puts mc\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nSUM_W = 10\n\n### subroutines\n\ndef count_manju(w, manju)\n  if w == 0\n    return ($cmcache[0][manju] = 1 + count_manju(SUM_W, manju))\n  end\n\n  return $cmcache[w][manju] if ! $cmcache[w][manju].nil?\n\n  max_count = 0\n  n = manju.length\n\n  for k in (0...n)\n    mj = manju[k]\n\n    if w >= mj\n      manju0 = manju.clone\n      manju0.delete_at k\n      c = count_manju(w - mj, manju0)\n      max_count = c if max_count < c\n    end\n  end\n\n  $cmcache[w][manju] = max_count\nend\n\n### main\n\nwhile true\n  $n = gets.strip.to_i\n  break if $n == 0\n\n  manju = gets.strip.split(' ').map{|s| s.to_i }.sort\n  #p manju\n\n  $cmcache = (SUM_W + 1).times.map{{}}\n\n  c = count_manju(SUM_W, manju)\n  puts c\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nSUM_W = 10\n\n### subroutines\n\ndef pack_manju(k, w, mj)\n  if k >= 9\n    return (w == 0 ? [mj.clone] : [])\n  end\n\n  mjs = []\n  mjk = $manju[k]\n\n  for i in (0..mjk)\n    w0 = w - (k + 1) * i\n    if w0 >= 0\n      mj[k] = i\n      mjs0 = pack_manju(k + 1, w0, mj)\n      mjs += mjs0\n    end\n  end\n\n  mjs\nend\n\ndef max_count_pack(k, mj, mjs)\n  return 1 if k >= mjs.length\n\n  mc0 = max_count_pack(k + 1, mj, mjs)\n\n  mj0 = []\n  for i in (0..8)\n    mj0[i] = mj[i] + mjs[k][i]\n    if mj0[i] > $manju[i]\n      return mc0\n    end\n  end\n\n  mc1 = 1 + max_count_pack(k + 1, mj0, mjs)\n\n  (mc0 > mc1) ? mc0 : mc1\nend\n\n### main\n\nwhile true\n  $n = gets.strip.to_i\n  break if $n == 0\n\n  $manju = 9.times.map{0}\n\n  gets.strip.split(' ').map{|s| $manju[s.to_i - 1] += 1}\n  #p $manju\n  #p $manju.inject(1){|s, m| s * m}\n\n  mc = 0\n\n  for i in (0..3)\n    m = [$manju[i], $manju[8 - i]].min\n    $manju[i] -= m\n    $manju[8 - i] -= m\n    mc += m\n  end\n\n  m = $manju[4] / 2\n  $manju[4] -= 2 * m\n  mc += m\n\n  #p $manju\n  #p $manju.select{|m| m > 0}.inject(1){|s, m| s * m}\n  #p mc\n\n  mjs = pack_manju(0, SUM_W, [])\n  #p mjs\n  #p mjs.length\n\n  mc += max_count_pack(0, [0] * 9, mjs) - 1\n  puts mc\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nint n;\nint[10] m;\nbool[ int[10] ] set;\nint[10][] list;\n\nint[10] use;\nint make(int num, int idx, int sum){\n\tif(idx==0){\n\t\tif(num==0 && sum==0){\n\t\t\tset[ use ] = true;\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(idx<0){\n\t\treturn 0;\n\t}\n\tif(sum<0){\n\t\treturn 0;\n\t}\n\t\n\tint cnt;\n\tforeach(i; (m[idx]+1).iota){\n\t\tuse[idx] = i;\n\t\tcnt += make(num-i, idx-1, sum-idx*i);\n\t\tuse[idx] = 0;\n\t}\n\t\n\treturn cnt;\n}\n\nT sum(T)(in T[] l ...){\n\tT s;\n\tforeach(v; l){\n\t\ts += v;\n\t}\n\treturn s;\n}\n\nT kvsum(T)(in T[] l ...){\n\tT s;\n\tforeach(k, v; l){\n\t\ts += k*v;\n\t}\n\treturn s;\n}\n\nbool isN(T)(T[] l ...){\n\tforeach( v; l ){\n\t\tif( v < 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid ksumsort(ref int[10][] a, int left, int right){\n\tif( left < right ){\n\t\tint i = left, j = right;\n\t\tint p = a[ ( left + right ) / 2 ].sum;\n\t\t\n\t\twhile(true){\n\t\t\twhile( a[i].sum < p ) ++i;\n\t\t\twhile( a[j].sum > p ) --j;\n\t\t\tif(i >= j) break;\n\t\t\t\n\t\t\tint[10u] tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tksumsort( a, left, i - 1 );\n\t\tksumsort( a, j + 1, right);\n\t}\n}\n\nint maxist;\n//int done[ int[10] ];\ndebug(1){\nint calling;\nint all_calling;\n}\n\nint search(int cnt, int fence){\n\tdebug(1){ ++all_calling; }\n\tif( fence >= cast(int)list.length ){\n\t\treturn cnt;\n\t}\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\t/+\n\tif( maxist > cnt + cast(int)(now.sum/2. + 0.5) ){\n\t\treturn 0;\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[fence].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n//\tforeach(v; list){\n\tfor(int i = fence; i < list.length; ++i){\n\t\tm[] -= list[i][];\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, search( cnt + 1, i ) );\n\t\t\tmaxist = max( maxist, max_ );\n\t\t}\n\t\t\n\t\tm[] += list[i][];\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nTuple!(int, int) pre_search(){\n\tint cnt;\n\tint idx;\n\t\n\tfor(; idx < cast(int)list.length && list[idx].sum == 2; ++idx){\n\t\tint[10] ope = list[idx];\n\t\tint min_ = int.max;\n\t\tfor(int i=0; i<10; ++i){\n\t\t\tif(ope[i]){\n\t\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t\t}\n\t\t}\n\t\tcnt += min_;\n\t\tm[] -= ope[]*min_;\n\t}\n\t\n\treturn Tuple!(int, int)(cnt, idx);\n}\n\nint make_(){\n\tint cnt;\n\tforeach( i; iota( 2, m.sum + 1 ) ){\n\t\tcnt += make(i, 9, 10);\n\t}\n\treturn cnt;\n}\n\nvoid main(){\n\twhile(true){\n\t\tn.next;\n\t\tif(n==0) break;\n\t\tm = m.init;\n\t\tset = set.init;\n//\t\tdone = done.init;\n\t\tmaxist = 0;\n\t\t\n\t\tforeach(i; n.iota){\n\t\t\t++m[next!int()];\n\t\t}\n\t\t\n\t\tmake_();\n\t\t\n\t\tlist = set.keys;\n\t\tksumsort( list, 0, cast(int)list.length - 1 );\n\t\t\n\t\tdebug(1){\n\t\t\twriteln(list.length);\n\t\t\tforeach(v; list){\n\t\t\t\twriteln('\\t', v.sum, \" : \", v);\n\t\t\t}\n\t\t\twriteln(\"...\", m.sum, \" : \", m);\n\t\t}\n\t\t\n\t\tdebug(1){ calling = all_calling = 0; }\n\t\tTuple!(int, int) p = pre_search();\n\t\tdebug(1){ dbg( p, m ); }\n\t\tsearch( p[0], p[1] ).writeln;\n//\t\tsearch( 0, 0 ).writeln;\n\t\tdebug(1){\n\t\t\twritefln(\"...%d/%d\", calling, all_calling);\n\t\t}\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nint n;\nint[10] m;\nbool[ int[10] ] set;\nint[10][] list;\n\nint[10] use;\nint make(int num, int idx, int sum){\n\tif(idx==0){\n\t\tif(num==0 && sum==0){\n\t\t\tset[ use ] = true;\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(idx<0){\n\t\treturn 0;\n\t}\n\tif(sum<0){\n\t\treturn 0;\n\t}\n\t\n\tint cnt;\n\tforeach(i; (m[idx]+1).iota){\n\t\tuse[idx] = i;\n\t\tcnt += make(num-i, idx-1, sum-idx*i);\n\t\tuse[idx] = 0;\n\t}\n\t\n\treturn cnt;\n}\n\nT sum(T)(in T[] l ...){\n\tT s;\n\tforeach(v; l){\n\t\ts += v;\n\t}\n\treturn s;\n}\n\nT kvsum(T)(in T[] l ...){\n\tT s;\n\tforeach(k, v; l){\n\t\ts += k*v;\n\t}\n\treturn s;\n}\n\nbool isN(T)(T[] l ...){\n\tforeach( v; l ){\n\t\tif( v < 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid ksumsort(ref int[10][] a, int left, int right){\n\tif( left < right ){\n\t\tint i = left, j = right;\n\t\tint p = a[ ( left + right ) / 2 ].sum;\n\t\t\n\t\twhile(true){\n\t\t\twhile( a[i].sum < p ) ++i;\n\t\t\twhile( a[j].sum > p ) --j;\n\t\t\tif(i >= j) break;\n\t\t\t\n\t\t\tint[10u] tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tksumsort( a, left, i - 1 );\n\t\tksumsort( a, j + 1, right);\n\t}\n}\n\nint maxist;\n//int done[ int[10] ];\nint done[ int ];\ndebug(1){\nint calling;\nint all_calling;\n}\n\nint search(int cnt, int fence){\n\tdebug(1){ ++all_calling; }\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\t/+\n\tif( maxist > cnt + cast(int)(now.sum/2. + 0.5) ){\n\t\treturn 0;\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[fence].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n//\tforeach(v; list){\n\tfor(int i = fence; i < list.length; ++i){\n\t\tm[] -= list[i][];\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, search( cnt + 1, i ) );\n\t\t\tmaxist = max( maxist, max_ );\n\t\t}\n\t\t\n\t\tm[] += list[i][];\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nint s2(int cnt, int idx, int v){\n\tdebug(1){ ++all_calling; }\n\tif(idx == list.length){\n\t\treturn cnt;\n\t}\n\tif( v in done ){\n\t\treturn cnt + done[ v ];\n\t}\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[idx].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\tif( maxist >= cnt + v/10 ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\t\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n\tint[10] ope = list[idx][];\n\tint min_ = int.max;\n\tfor(int i=0; i<10; ++i){\n\t\tif(ope[i]){\n\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t}\n\t}\n\tfor(int i = min_; 0 <= i; --i){\n\t\tm[] -= ope[]*i;\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, s2( cnt + i, idx + 1, v - 10*i ) );\n\t\t}\n\t\t\n\t\tm[] += ope[]*i;\n\t}\n\t\n\tdone[ v ] = max_ - cnt;\n\treturn max_;\n}\n\nint make_(){\n\tint cnt;\n\tforeach( i; iota( 2, m.sum + 1 ) ){\n\t\tcnt += make(i, 9, 10);\n\t}\n\treturn cnt;\n}\n\nvoid main(){\n\twhile(true){\n\t\tn.next;\n\t\tif(n==0) break;\n\t\tm = m.init;\n\t\tset = set.init;\n\t\tdone = done.init;\n\t\tmaxist = 0;\n\t\t\n\t\tforeach(i; n.iota){\n\t\t\t++m[next!int()];\n\t\t}\n\t\t\n\t\tmake_();\n\t\t\n\t\tlist = set.keys;\n\t\tksumsort( list, 0, cast(int)list.length - 1 );\n\t\t\n\t\tdebug(1){\n\t\t\twriteln(list.length);\n\t\t\tforeach(v; list){\n\t\t\t\twriteln('\\t', v.sum, \" : \", v);\n\t\t\t}\n\t\t\twriteln(\"...\", m.sum, \" : \", m);\n\t\t}\n\t\t\n\t\tdebug(1){ calling = all_calling = 0; }\n\t\ts2( 0, 0, m.kvsum ).writeln;\n//\t\tsearch( 0, 0 ).writeln;\n\t\tdebug(1){\n\t\t\twritefln(\"...%d/%d\", calling, all_calling);\n\t\t}\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nint n;\nint[10] m;\nbool[ int[10] ] set;\nint[10][] list;\n\nint[10] use;\nint make(int num, int idx, int sum){\n\tif(idx==0){\n\t\tif(num==0 && sum==0){\n\t\t\tset[ use ] = true;\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(idx<0){\n\t\treturn 0;\n\t}\n\tif(sum<0){\n\t\treturn 0;\n\t}\n\t\n\tint cnt;\n\tforeach(i; (m[idx]+1).iota){\n\t\tuse[idx] = i;\n\t\tcnt += make(num-i, idx-1, sum-idx*i);\n\t\tuse[idx] = 0;\n\t}\n\t\n\treturn cnt;\n}\n\nT sum(T)(in T[] l ...){\n\tT s;\n\tforeach(v; l){\n\t\ts += v;\n\t}\n\treturn s;\n}\n\nT kvsum(T)(in T[] l ...){\n\tT s;\n\tforeach(k, v; l){\n\t\ts += k*v;\n\t}\n\treturn s;\n}\n\nbool isN(T)(T[] l ...){\n\tforeach( v; l ){\n\t\tif( v < 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid ksumsort(ref int[10][] a, int left, int right){\n\tif( left < right ){\n\t\tint i = left, j = right;\n\t\tint p = a[ ( left + right ) / 2 ].sum;\n\t\t\n\t\twhile(true){\n\t\t\twhile( a[i].sum < p ) ++i;\n\t\t\twhile( a[j].sum > p ) --j;\n\t\t\tif(i >= j) break;\n\t\t\t\n\t\t\tint[10u] tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tksumsort( a, left, i - 1 );\n\t\tksumsort( a, j + 1, right);\n\t}\n}\n\nint maxist;\n//int done[ int[10] ];\ndebug(1){\nint calling;\nint all_calling;\n}\n\nint search(int cnt, int fence){\n\tdebug(1){ ++all_calling; }\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\t/+\n\tif( maxist > cnt + cast(int)(now.sum/2. + 0.5) ){\n\t\treturn 0;\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[fence].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n//\tforeach(v; list){\n\tfor(int i = fence; i < list.length; ++i){\n\t\tm[] -= list[i][];\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, search( cnt + 1, i ) );\n\t\t\tmaxist = max( maxist, max_ );\n\t\t}\n\t\t\n\t\tm[] += list[i][];\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nTuple!(int, int) pre_search(){\n\tint cnt;\n\tint idx;\n\t\n\twhile( list[idx].sum == 2 ){\n\t\tint[10] ope = list[idx];\n\t\tint min_ = int.max;\n\t\tfor(int i=0; i<10; ++i){\n\t\t\tif(ope[i]){\n\t\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t\t}\n\t\t}\n\t\tcnt += min_;\n\t\tm[] -= ope[]*min_;\n\t\t\n\t\t++idx;\n\t}\n\t\n\treturn Tuple!(int, int)(cnt, idx);\n}\n\nint make_(){\n\tint cnt;\n\tforeach( i; iota( 2, m.sum + 1 ) ){\n\t\tcnt += make(i, 9, 10);\n\t}\n\treturn cnt;\n}\n\nvoid main(){\n\twhile(true){\n\t\tn.next;\n\t\tif(n==0) break;\n\t\tm = m.init;\n\t\tset = set.init;\n//\t\tdone = done.init;\n\t\tmaxist = 0;\n\t\t\n\t\tforeach(i; n.iota){\n\t\t\t++m[next!int()];\n\t\t}\n\t\t\n\t\tmake_();\n\t\t\n\t\tlist = set.keys;\n\t\tksumsort( list, 0, cast(int)list.length - 1 );\n\t\t\n\t\tdebug(1){\n\t\t\twriteln(list.length);\n\t\t\tforeach(v; list){\n\t\t\t\twriteln('\\t', v.sum, \" : \", v);\n\t\t\t}\n\t\t\twriteln(\"...\", m.sum, \" : \", m);\n\t\t}\n\t\t\n\t\tdebug(1){ calling = all_calling = 0; }\n\t\tTuple!(int, int) p = pre_search();\n\t\tsearch( p[0], p[1] ).writeln;\n//\t\tsearch( 0, 0 ).writeln;\n\t\tdebug(1){\n\t\t\twritefln(\"...%d/%d\", calling, all_calling);\n\t\t}\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nint n;\nint[10] m;\nbool[ int[10] ] set;\nint[10][] list;\n\nint[10] use;\nint make(int num, int idx, int sum){\n\tif(idx==0){\n\t\tif(num==0 && sum==0){\n\t\t\tset[ use ] = true;\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(idx<0){\n\t\treturn 0;\n\t}\n\tif(sum<0){\n\t\treturn 0;\n\t}\n\t\n\tint cnt;\n\tforeach(i; (m[idx]+1).iota){\n\t\tuse[idx] = i;\n\t\tcnt += make(num-i, idx-1, sum-idx*i);\n\t\tuse[idx] = 0;\n\t}\n\t\n\treturn cnt;\n}\n\nT sum(T)(in T[] l ...){\n\tT s;\n\tforeach(v; l){\n\t\ts += v;\n\t}\n\treturn s;\n}\n\nT kvsum(T)(in T[] l ...){\n\tT s;\n\tforeach(k, v; l){\n\t\ts += k*v;\n\t}\n\treturn s;\n}\n\nbool isN(T)(T[] l ...){\n\tforeach( v; l ){\n\t\tif( v < 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid ksumsort(ref int[10][] a, int left, int right){\n\tif( left < right ){\n\t\tint i = left, j = right;\n\t\tint p = a[ ( left + right ) / 2 ].sum;\n\t\t\n\t\twhile(true){\n\t\t\twhile( a[i].sum < p ) ++i;\n\t\t\twhile( a[j].sum > p ) --j;\n\t\t\tif(i >= j) break;\n\t\t\t\n\t\t\tint[10u] tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tksumsort( a, left, i - 1 );\n\t\tksumsort( a, j + 1, right);\n\t}\n}\n\nint maxist;\n//int done[ int[10] ];\ndebug(1){\nint calling;\nint all_calling;\n}\n\nint search(int cnt, int fence){\n\tdebug(1){ ++all_calling; }\n\tif( fence >= cast(int)list.length ){\n\t\treturn cnt;\n\t}\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\t/+\n\tif( maxist > cnt + cast(int)(now.sum/2. + 0.5) ){\n\t\treturn 0;\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[fence].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n//\tforeach(v; list){\n\tfor(int i = fence; i < list.length; ++i){\n\t\tm[] -= list[i][];\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, search( cnt + 1, i ) );\n\t\t\tmaxist = max( maxist, max_ );\n\t\t}\n\t\t\n\t\tm[] += list[i][];\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nTuple!(int, int) pre_search(int fence=2){\n\tint cnt;\n\tint idx;\n\t\n\twhile(idx < cast(int)list.length && list[idx].sum<fence) ++idx;\n\tfor(; idx < cast(int)list.length && list[idx].sum == fence; ++idx){\n\t\tint[10] ope = list[idx];\n\t\tint min_ = int.max;\n\t\tfor(int i=0; i<10; ++i){\n\t\t\tif(ope[i]){\n\t\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t\t}\n\t\t}\n\t\tcnt += min_;\n\t\tm[] -= ope[]*min_;\n\t}\n\t\n\treturn Tuple!(int, int)(cnt, idx);\n}\n\nint s2(int cnt, int idx, int v){\n\tdebug(1){ ++all_calling; }\n\tif(idx == list.length){\n\t\treturn cnt;\n\t}\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[idx].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\tif( maxist >= cnt + v/10 ){\n\t\treturn 0;\n\t}\n\n\tdebug(1){ ++calling; }\n\t\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n \n\tint[10] ope = list[idx][];\n\tint min_ = int.max;\n\tfor(int i=0; i<10; ++i){\n\t\tif(ope[i]){\n\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t}\n\t}\n\tfor(int i = min_; 0 <= i; --i){\n\t\tm[] -= ope[]*i;\n\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, s2( cnt + i, idx + 1, v - 10*i ) );\n\t\t}\n\t\n\t\tm[] += ope[]*i;\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nint make_(){\n\tint cnt;\n\tforeach( i; iota( 2, m.sum + 1 ) ){\n\t\tcnt += make(i, 9, 10);\n\t}\n\treturn cnt;\n}\n\nvoid main(){\n\twhile(true){\n\t\tn.next;\n\t\tif(n==0) break;\n\t\tm = m.init;\n\t\tset = set.init;\n//\t\tdone = done.init;\n\t\tmaxist = 0;\n\t\t\n\t\tforeach(i; n.iota){\n\t\t\t++m[next!int()];\n\t\t}\n\t\t\n\t\tmake_();\n\t\t\n\t\tlist = set.keys;\n\t\tksumsort( list, 0, cast(int)list.length - 1 );\n\t\t\n\t\tdebug(1){\n\t\t\twriteln(list.length);\n\t\t\tforeach(v; list){\n\t\t\t\twriteln('\\t', v.sum, \" : \", v);\n\t\t\t}\n\t\t\twriteln(\"...\", m.sum, \" : \", m);\n\t\t}\n\t\t\n\t\tTuple!(int, int) p = pre_search();\n\t\tdebug(1){ dbg( p, m ); }\n\t\tdebug(1){ calling = all_calling = 0; }\n//\t\tsearch( p[0], p[1] ).writeln;\n\t\ts2( p[0], p[1], m.kvsum ).writeln;\n////\t\tsearch( 0, 0 ).writeln;\n\t\tdebug(1){\n\t\t\twritefln(\"...%d/%d\", calling, all_calling);\n\t\t}\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nint n;\nint[10] m;\nbool[ int[10] ] set;\nint[10][] list;\n\nint[10] use;\nint make(int num, int idx, int sum){\n\tif(idx==0){\n\t\tif(num==0 && sum==0){\n\t\t\tset[ use ] = true;\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(idx<0){\n\t\treturn 0;\n\t}\n\tif(sum<0){\n\t\treturn 0;\n\t}\n\t\n\tint cnt;\n\tforeach(i; (m[idx]+1).iota){\n\t\tuse[idx] = i;\n\t\tcnt += make(num-i, idx-1, sum-idx*i);\n\t\tuse[idx] = 0;\n\t}\n\t\n\treturn cnt;\n}\n\nT sum(T)(in T[] l ...){\n\tT s;\n\tforeach(v; l){\n\t\ts += v;\n\t}\n\treturn s;\n}\n\nT kvsum(T)(in T[] l ...){\n\tT s;\n\tforeach(k, v; l){\n\t\ts += k*v;\n\t}\n\treturn s;\n}\n\nbool isN(T)(T[] l ...){\n\tforeach( v; l ){\n\t\tif( v < 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid ksumsort(ref int[10][] a, int left, int right){\n\tif( left < right ){\n\t\tint i = left, j = right;\n\t\tint p = a[ ( left + right ) / 2 ].sum;\n\t\t\n\t\twhile(true){\n\t\t\twhile( a[i].sum < p ) ++i;\n\t\t\twhile( a[j].sum > p ) --j;\n\t\t\tif(i >= j) break;\n\t\t\t\n\t\t\tint[10u] tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tksumsort( a, left, i - 1 );\n\t\tksumsort( a, j + 1, right);\n\t}\n}\n\nint maxist;\n//int done[ int[10] ];\ndebug(1){\nint calling;\nint all_calling;\n}\n\nint search(int cnt, int fence){\n\tdebug(1){ ++all_calling; }\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\t/+\n\tif( maxist > cnt + cast(int)(now.sum/2. + 0.5) ){\n\t\treturn 0;\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[fence].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n//\tforeach(v; list){\n\tfor(int i = fence; i < list.length; ++i){\n\t\tm[] -= list[i][];\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, search( cnt + 1, i ) );\n\t\t\tmaxist = max( maxist, max_ );\n\t\t}\n\t\t\n\t\tm[] += list[i][];\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nint s2(int cnt, int idx, int v){\n\tdebug(1){ ++all_calling; }\n\tif(idx == list.length){\n\t\treturn cnt;\n\t}\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[idx].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\tif( maxist >= cnt + v/10 ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\t\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n\tint[10] ope = list[idx][];\n\tint min_ = int.max;\n\tfor(int i=0; i<10; ++i){\n\t\tif(ope[i]){\n\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t}\n\t}\n\tfor(int i = min_; 0 <= i; --i){\n\t\tm[] -= ope[]*i;\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, s2( cnt + i, idx + 1, v - 10*i ) );\n\t\t}\n\t\t\n\t\tm[] += ope[]*i;\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nint make_(){\n\tint cnt;\n\tforeach( i; iota( 2, m.sum + 1 ) ){\n\t\tcnt += make(i, 9, 10);\n\t}\n\treturn cnt;\n}\n\nvoid main(){\n\twhile(true){\n\t\tn.next;\n\t\tif(n==0) break;\n\t\tm = m.init;\n\t\tset = set.init;\n//\t\tdone = done.init;\n\t\tmaxist = 0;\n\t\t\n\t\tforeach(i; n.iota){\n\t\t\t++m[next!int()];\n\t\t}\n\t\t\n\t\tmake_();\n\t\t\n\t\tlist = set.keys;\n\t\tksumsort( list, 0, cast(int)list.length - 1 );\n\t\t\n\t\tdebug(1){\n\t\t\twriteln(list.length);\n\t\t\tforeach(v; list){\n\t\t\t\twriteln('\\t', v.sum, \" : \", v);\n\t\t\t}\n\t\t\twriteln(\"...\", m.sum, \" : \", m);\n\t\t}\n\t\t\n\t\tdebug(1){ calling = all_calling = 0; }\n\t\ts2( 0, 0, m.kvsum ).writeln;\n//\t\tsearch( 0, 0 ).writeln;\n\t\tdebug(1){\n\t\t\twritefln(\"...%d/%d\", calling, all_calling);\n\t\t}\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nint n;\nint[10] m;\nbool[ int[10] ] set;\nint[10][] list;\n\nint[10] use;\nint make(int num, int idx, int sum){\n\tif(idx==0){\n\t\tif(num==0 && sum==0){\n\t\t\tset[ use ] = true;\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(idx<0){\n\t\treturn 0;\n\t}\n\tif(sum<0){\n\t\treturn 0;\n\t}\n\t\n\tint cnt;\n\tforeach(i; (m[idx]+1).iota){\n\t\tuse[idx] = i;\n\t\tcnt += make(num-i, idx-1, sum-idx*i);\n\t\tuse[idx] = 0;\n\t}\n\t\n\treturn cnt;\n}\n\nT sum(T)(in T[] l ...){\n\tT s;\n\tforeach(v; l){\n\t\ts += v;\n\t}\n\treturn s;\n}\n\nT kvsum(T)(in T[] l ...){\n\tT s;\n\tforeach(k, v; l){\n\t\ts += k*v;\n\t}\n\treturn s;\n}\n\nbool isN(T)(T[] l ...){\n\tforeach( v; l ){\n\t\tif( v < 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid ksumsort(ref int[10][] a, int left, int right){\n\tif( left < right ){\n\t\tint i = left, j = right;\n\t\tint p = a[ ( left + right ) / 2 ].sum;\n\t\t\n\t\twhile(true){\n\t\t\twhile( a[i].sum < p ) ++i;\n\t\t\twhile( a[j].sum > p ) --j;\n\t\t\tif(i >= j) break;\n\t\t\t\n\t\t\tint[10u] tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tksumsort( a, left, i - 1 );\n\t\tksumsort( a, j + 1, right);\n\t}\n}\n\nint maxist;\n//int done[ int[10] ];\ndebug(1){\nint calling;\nint all_calling;\n}\n\nint search(int cnt, int fence){\n\tdebug(1){ ++all_calling; }\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\t/+\n\tif( maxist > cnt + cast(int)(now.sum/2. + 0.5) ){\n\t\treturn 0;\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[fence].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n//\tforeach(v; list){\n\tfor(int i = fence; i < list.length; ++i){\n\t\tm[] -= list[i][];\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, search( cnt + 1, i ) );\n\t\t\tmaxist = max( maxist, max_ );\n\t\t}\n\t\t\n\t\tm[] += list[i][];\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nint s2(int cnt, int idx, int v){\n\tdebug(1){ ++all_calling; }\n\tif(idx == list.length){\n\t\treturn cnt;\n\t}\n\t/+\n\tif( m in done ){\n\t\treturn cnt + done[ m ];\n\t}\n\t+/\n\tif( maxist >= cnt + cast(int)(m.sum/cast(double)(list[idx].sum) + 0.5) ){\n\t\treturn 0;\n\t}\n\tif( maxist >= cnt + v/10 ){\n\t\treturn 0;\n\t}\n\t\n\tdebug(1){ ++calling; }\n\t\n\tint max_ = cnt;\n\tmaxist = max( maxist, max_ );\n\n\tint[10] ope = list[idx][];\n\tint min_ = int.max;\n\tfor(int i=0; i<10; ++i){\n\t\tif(ope[i]){\n\t\t\tmin_ = min( min_, m[i] / ope[i] );\n\t\t}\n\t}\n\tfor(int i = min_; 0 <= i; --i){\n\t\tm[] -= ope[]*i;\n\t\t\n\t\tif( m.isN ){\n\t\t\tmax_ = max( max_, s2( cnt + i, idx + 1, v - 10*i ) );\n\t\t}\n\t\t\n\t\tm[] += ope[]*i;\n\t}\n\t\n//\tdone[ m ] = max_ - cnt;\n\treturn max_;\n}\n\nint make_(){\n\tint cnt;\n\tforeach( i; iota( 2, m.sum + 1 ) ){\n\t\tcnt += make(i, 9, 10);\n\t}\n\treturn cnt;\n}\n\nvoid main(){\n\twhile(true){\n\t\tn.next;\n\t\tif(n==0) break;\n\t\tm = m.init;\n\t\tset = set.init;\n//\t\tdone = done.init;\n\t\tmaxist = 0;\n\t\t\n\t\tforeach(i; n.iota){\n\t\t\t++m[next!int()];\n\t\t}\n\t\t\n\t\tmake_();\n\t\t\n\t\tlist = set.keys;\n\t\tksumsort( list, 0, list.length - 1 );\n\t\t\n\t\tdebug(1){\n\t\t\twriteln(list.length);\n\t\t\tforeach(v; list){\n\t\t\t\twriteln('\\t', v.sum, \" : \", v);\n\t\t\t}\n\t\t\twriteln(\"...\", m.sum, \" : \", m);\n\t\t}\n\t\t\n\t\tdebug(1){ calling = all_calling = 0; }\n\t\ts2( 0, 0, m.kvsum ).writeln;\n//\t\tsearch( 0, 0 ).writeln;\n\t\tdebug(1){\n\t\t\twritefln(\"...%d/%d\", calling, all_calling);\n\t\t}\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\n\ndef main():\n  def make_num(target, counter):\n    if target == 0:\n      return True\n    for i in range(target, 0, -1):\n      if counter[i] > 0:\n        counter[i] -= 1\n        flag = make_num(target - i, counter)\n        if flag:\n          return True\n        else:\n          counter[i] += 1\n    return False\n  \n  while True:\n    n = int(input())\n    if n == 0:\n      break\n    counter = Counter(map(int, input().split()))\n    ans = 0\n    for max_num in range(9, 0, -1):\n      target = 10 - max_num\n      delete_num = counter[max_num]\n      while delete_num:\n        counter[max_num] -= 1\n        if make_num(target, counter):\n          delete_num -= 1\n          ans += 1\n        else:\n          counter[max_num] += 1\n          break\n    print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\n\ndef main():\n  def make_num(target, counter):\n    if target == 0:\n      return True\n    for i in range(target, 0, -1):\n      if counter[i] > 0:\n        counter[i] -= 1\n        flag = make_num(target - i, counter)\n        if flag:\n          return True\n        else:\n          counter[i] += 1\n    return False\n  \n  while True:\n    n = int(input())\n    if n == 0:\n      break\n    counter = Counter(map(int, input().split()))\n    ans = 0\n    for max_num in range(9, 0, -1):\n      target = 10 - max_num\n      delete_num = counter[max_num]\n      while delete_num:\n        counter[max_num] -= 1\n        if make_num(target, counter):\n          delete_num -= 1\n          ans += 1\n        else:\n          counter[max_num] += 1\n          break\n    print(ans)\nmain()\n\n"
  }
]