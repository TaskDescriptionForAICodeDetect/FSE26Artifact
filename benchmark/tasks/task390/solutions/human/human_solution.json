[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> H, W;\nstring Area[4];\n\nint d[1<<16];\n\nint main(){\n    cin >> N;\n    H.resize(N); W.resize(N);\n    for(int i=0; i<N; i++)\n        cin >> H[i] >> W[i];\n    \n    vector<set<int>> edges(N);\n    for(int k=0; k<N; k++){\n        for(int h=-4; h<=4; h++){\n            for(int w=-4; w<=4; w++){\n                int t = 0;\n                for(int i=0; i<H[k]; i++){\n                    for(int j=0; j<W[k]; j++){\n                        int nh = h+i;\n                        int nw = w+j;\n                        if(0<=nh && nh<4 && 0<=nw && nw<4){\n                            t |= 1<<(4*nh + nw);\n                        }\n                    }\n                }\n                edges[k].insert(t);\n            }\n        }\n    }\n    \n    int RGB[3] = {};\n    for(int i=0; i<4; i++){\n        cin >> Area[i];\n        for(int j=0; j<4; j++){\n            if(Area[i][j] == 'R')\n                RGB[0] |= (1<<(4*i + j));\n            if(Area[i][j] == 'G')\n                RGB[1] |= (1<<(4*i + j));\n            if(Area[i][j] == 'B')\n                RGB[2] |= (1<<(4*i + j));\n        }\n    }\n    \n    queue<int> que;\n    memset(d, -1, sizeof(d));\n    d[0] = 0;\n    que.push(0);\n    \n    while(!que.empty()){\n        auto x = que.front(); que.pop();\n        \n        for(int i=0; i<N; i++){\n            for(auto v: edges[i]){\n                for(int j=0; j<3; j++){\n                    int y = x;\n                    for(int k=0; k<3; k++){\n                        if(j == k){\n                            y |= RGB[k] & v;\n                        }else{\n                            y &= ~(RGB[k] & v);\n                        }\n                    }\n                    if (d[y] < 0){\n                        que.push(y);\n                        d[y] = d[x] + 1;\n                        if(y == (RGB[0] | RGB[1] | RGB[2])){\n                            cout << d[y] << endl;\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint i,j,n,m,K,a;cin>>n;\n\tvector<pair<int,int>>sta(n);\n\tfor(i=0;i<n;i++){cin>>sta[i].fir>>sta[i].sec;}\n\tstatic int dis[65536];\n\tfor(int bi=0;bi<(1<<16);bi++){dis[bi]=99999;}\n\t\n\tvector<int>sp;\n\tfor(j=0;j<n;j++){\n\t\tint h=sta[j].fir,w=sta[j].sec;\n\t\tfor(int y=-h+1;y<=3;y++){\n\t\t\tfor(int x=-w+1;x<=3;x++){\n\t\t\t\tint aaa=0;\n\t\t\t\tfor(int ny=y;ny<y+h;ny++){\n\t\t\t\t\tfor(int nx=x;nx<x+w;nx++){\n\t\t\t\t\t\tif(ny<0||nx<0||ny>=4||nx>=4){continue;}\n\t\t\t\t\t\taaa|=(1<<(ny*4+nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsp.pub(aaa);\n\t\t\t}\n\t\t}\n\t}\n\tSO(sp);\n\tsp.erase(unique(sp.begin(),sp.end()),sp.end());\n\tstring kan[4];cin>>kan[0]>>kan[1]>>kan[2]>>kan[3];\n\tint R=0,B=0,G=0;\n\tfor(int y=0;y<4;y++){\n\t\tfor(int x=0;x<4;x++){\n\t\t\tif(kan[y][x]=='R'){R+=1<<(y*4+x);}\n\t\t\tif(kan[y][x]=='B'){B+=1<<(y*4+x);}\n\t\t\tif(kan[y][x]=='G'){G+=1<<(y*4+x);}\n\t\t}\n\t}\n\tdis[0]=0;\n\tqueue<int>que;que.push(0);\n\t\n\tint full=65535;\n\twhile(que.size()){\n\t\tint now=que.front();que.pop();\n\t\tint time=dis[now];\n\t\t//cerr<<pta<<\" \"<<time<<endl;\n\t\tfor(int pta:sp){\n\t\t\t//ptaが押すパターン\n\t\t\ta=(now&(~pta))|(R&pta);\n\t\t\tif(mineq(dis[a],time+1)){que.push(a);}\n\t\t\ta=(now&(~pta))|(G&pta);\n\t\t\tif(mineq(dis[a],time+1)){que.push(a);}\n\t\t\ta=(now&(~pta))|(B&pta);\n\t\t\tif(mineq(dis[a],time+1)){que.push(a);}\n\t\t}\n\t}\n\tcout<<dis[65535]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nchar color[3]={'R','G','B'};\n\nvoid mark(int cost,int S,int stamp){\n  \n  for(int y=0;y<M+h[stamp];y++){\n\n    for(int x=0;x<M+w[stamp];x++){\n      \n      for(int k=0;k<3;k++){\n\t\n\tint nS=S;\n\t    \n\tfor(int i=0;i<h[stamp];i++){\n\t\n\t  for(int j=0;j<w[stamp];j++){\n\n\t    int ny=y-i, nx=x-j;\n\t\n\t    if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t    int p=ny*M+nx;\n\t  \n\t    if(s[ny][nx]==color[k]) nS|=(1<<p);\n\t    else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t  }\n    \n\t}\n      \n\tif(d[nS]>cost+1){\n\t  d[nS]=cost+1;\n\t  q.push(P(cost+1,nS));\n\t}\n\t\n      }\n    }\n\n      \n  \n  }\n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int k=0;k<n;k++) mark(cost,S,k);\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=cost;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nchar col[] = {'R', 'G', 'B'};\nstring board[4];\nint n, d[1<<16], h[20], w[20];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  REP(i, n) cin >> h[i] >> w[i];\n  REP(i, 4) cin >> board[i];\n\n  REP(i, 1<<16) d[i] = INF;\n  d[0] = 0;\n  queue<int> que;\n  que.push(0);\n\n  while(que.size()) {\n    int bit = que.front(); que.pop();\n    // cout << bit << endl;\n    if(bit == (1LL<<16)-1) break;\n    REP(i, n) FOR(y, -h[i]+1, 4) FOR(x, -w[i]+1, 4) REP(c, 3) {\n      int n_bit = bit;\n      FOR(ny, max(0LL, y), min(y+h[i],4LL)) FOR(nx, max(0LL, x), min(x+w[i],4LL)) {\n        if(board[ny][nx] == col[c]) n_bit |= 1<<(ny*4+nx);\n        else n_bit &= ~(1<<(ny*4+nx));\n      }\n      // cout << bitset<16>(n_bit) << endl;\n      if(d[n_bit] == INF) {\n        d[n_bit] = d[bit] + 1;\n        que.push(n_bit);\n      }\n    }\n  }\n\n  if(d[(1LL<<16)-1] == INF) cout << -1 << endl;\n  else cout << d[(1LL<<16)-1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tif(j+h[i] < 3 || k+w[i] < 3) continue;\n\t\t\t\t\t//{\n\t\t\t\t\t\tint l = -1;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0){\n\t\t\t\t\t\t\t\t\tl = brd[j+hh][k+ww];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l == -1) continue;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n\n      int ny=y-i, nx=x-j;\n      \n      if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  ny+=k, nx+=l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    \t\n    for(int idx=0;idx<N;idx++){\n\t\n      if(S&(1<<idx)) continue;\n\t\n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint H[20], W[20];\nstring S[5];\nint field[5][5];\nint dist[1 << 17];\nbool chmin(int &a, int b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint f(int nowbit, int stamp, int h, int w, int color) {\n    int ans = nowbit;\n    for(int dh = 0; dh < H[stamp]; dh++) {\n        int newh = h + dh;\n        if(newh < 0 || newh > 3) continue;\n        for(int dw = 0; dw < W[stamp]; dw++) {\n            int neww = w + dw;\n            if(neww < 0 || neww > 3) continue;\n            int grid = newh * 4 + neww;\n            if(field[newh][neww] == color) ans |= (1 << grid);\n            else ans &= ~(1 << grid);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n    for(int h = 0; h <= 3; h++) cin >> S[h];\n    for(int h = 0; h < 4; h++) {\n        for(int w = 0; w < 4; w++) {\n            if(S[h][w] == 'R') field[h][w] = 0;\n            if(S[h][w] == 'G') field[h][w] = 1;\n            if(S[h][w] == 'B') field[h][w] = 2;\n        }\n    }\n    for(int i = 0; i < (1 << 16); i++) dist[i] = INF;\n    dist[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()) {\n        int nowbit = que.front();\n        //cerr << nowbit << \" \" << dist[nowbit] << endl;\n        //if(dist[nowbit] > 3) break;\n        que.pop();\n        for(int stamp = 0; stamp < N; stamp++) {\n            for(int h = -3; h <= 3; h++) {\n                for(int w = -3; w <= 3; w++) {\n                    for(int color = 0; color <= 2; color++) {\n                        int newbit = f(nowbit, stamp, h, w, color);\n                        if(chmin(dist[newbit], dist[nowbit] + 1)) que.push(newbit);\n                    }\n                }\n            }\n        }\n    }\n    cout << dist[(1 << 16) - 1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\nbool rect[4][4][4][4];\n\nconst int V = 1 << 16;\nset<int> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tif(dist[G[u][i]] < inf) continue;\n\t\t\tdist[G[u][i]] = dist[u] + 1;\n\t\t\tQ.push(G[u][i]);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\trect[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < N; j++){\n\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\trect[max(x, 0)][min(x+W[j],4)-1][max(y, 0)][min(y+H[j],4)-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tnext = i;\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tfor(int q = 0; q < 4; q++){\n\t\t\t\t\tfor(int r = 0; r < 4; r++){\n\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\tif(!rect[p][q][r][s]) continue;\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tfor(int dx = p; dx <= q; dx++){\n\t\t\t\t\t\t\t\tfor(int dy = r; dy <= s; dy++){\n\t\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tG[i].insert(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int INF = (1e9);\nint main(){\n  int N;\n  const int M = (1<<16);\n  cin >> N;\n  vector<int> DP(M,INF);\n  DP[0] = 0;\n  string color = \"RGB\";\n  vector<int> H(N), W(N);\n  for(int i = 0; i < N; ++i){\n    cin >> H[i] >> W[i];\n  }\n  string C[4];\n  for(int i = 0; i < 4; ++i) cin >> C[i];\n\n  int AND[5][5][7][7][3], OR[5][5][7][7][3];\n  for(int j = 0; j < N; ++j){\n    for(int k = 0; k < 3; ++k){\n      for(int l = 1-H[j]; l < 4; ++l){\n        for(int m = 1-W[j]; m < 4; ++m){\n          int a = M-1, o = 0;\n          for(int h = max(-l,0); h < H[j]; ++h){\n            for(int w = max(-m,0); w < W[j]; ++w){\n              int x = l+h, y = m+w;\n              if(x > 3 || y > 3 || x < 0 || y < 0) continue;\n              if(C[x][y] == color[k]) o |= (1<<(4*x+y));\n              else a &= ~(1<<(4*x+y));\n            }\n          }\n          AND[H[j]][W[j]][l+3][m+3][k] = a;\n          OR[H[j]][W[j]][l+3][m+3][k] = o;\n        }\n      }\n    }\n  }\n  priority_queue< pair<int,int> > wait;\n  wait.emplace(0,0);\n  while(!wait.empty()){\n    int c = -wait.top().first, i = wait.top().second;\n    wait.pop();\n    if(DP[i] < c) continue;\n    DP[i] = c;\n    if(i == M-1) break;\n    for(int j = 0; j < N; ++j){\n      for(int k = 0; k < 3; ++k){\n        for(int l = 1-H[j]; l < 4; ++l){\n          for(int m = 1-W[j]; m < 4; ++m){\n            int i_ = i;\n            i_ &= AND[H[j]][W[j]][l+3][m+3][k];\n            i_ |= OR[H[j]][W[j]][l+3][m+3][k];\n            if(DP[i_] <= DP[i]+1) continue;\n            DP[i_] = DP[i]+1;\n            wait.emplace(-c-1,i_);\n          }\n        }\n      }\n    }\n  }\n  cout << DP[M-1] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\nusing namespace std;\nint N;\nint H[16],W[16];\nint ne[16][7][7] = {};\nint ok[16][7][7][3] = {};\nint dist[1<<16] = {};\nchar C[7][7];\n\nbool in(int x,int y){\n    return 3<=x && x<=6 && 3<=y && y<=6;\n}\n\nint to_line(int x,int y){\n    return 4*(x-3)+(y-3);\n}\n\nint main(){\n   cin >> N;\n   for(int i=0;i<N;i++) cin >> H[i] >> W[i];\n   for(int i=3;i<7;i++){\n      for(int j=3;j<7;j++){\n         cin >> C[i][j];\n      }    \n   }\n   for(int i=0;i<7;i++){\n      for(int j=0;j<7;j++){\n         for(int k=0;k<N;k++){\n            ne[k][i][j] = -1;\n            for(int l=0;l<3;l++) ok[k][i][j][l] = 0;\n            int T = (1<<16)-1;\n            for(int r=0;r<H[k];r++){\n               for(int c=0;c<W[k];c++){\n                  if(in(i+r,j+c)){\n                     T ^= (1<<to_line(i+r,j+c));\n                     if(C[i+r][j+c]=='R'){ok[k][i][j][1] ^= (1<<to_line(i+r,j+c)); ok[k][i][j][2] ^= (1<<to_line(i+r,j+c));}\n                     if(C[i+r][j+c]=='B'){ok[k][i][j][0] ^= (1<<to_line(i+r,j+c)); ok[k][i][j][2] ^= (1<<to_line(i+r,j+c));}\n                     if(C[i+r][j+c]=='G'){ok[k][i][j][1] ^= (1<<to_line(i+r,j+c)); ok[k][i][j][0] ^= (1<<to_line(i+r,j+c));}\n                  }\n               }\n            }\n            ne[k][i][j] = T;\n         }\n      }\n   }\n   for(int i=0;i<(1<<16);i++) dist[i] = -1;\n   dist[(1<<16)-1] = 0;\n   queue<int> Q;\n   Q.push((1<<16)-1);\n   while(!Q.empty()){\n      int S = Q.front(); Q.pop();\n      for(int i=0;i<7;i++){\n         for(int j=0;j<7;j++){\n            for(int k=0;k<N;k++){\n               for(int l=0;l<3;l++){\n                  if((ne[k][i][j]==(1<<16)-1) || (S & ok[k][i][j][l])!=0) continue;\n                  int T = (S & ne[k][i][j]);\n                  if(dist[T]==-1){\n                     dist[T] = dist[S]+1;\n                     Q.push(T);\n                  }\n               }\n            }\n         }\n      }\n   }\n   cout << dist[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\n#define M 4\nusing namespace std;\n\nint n,h[N],w[N];\nstring s[M];\n\nbool dp[N+1][(1<<N)];\n\nvoid mark(int cnt,int S,int idx,int stamp){\n  \n  int y=idx/4,x=idx%4;\n  \n  for(int i=0;i<h[stamp];i++){\n\n    for(int j=0;j<w[stamp];j++){\n\n      int nS=S,f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(S&(1<<p)) f=1;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<nS)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(!f) dp[cnt+1][nS]=true;\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  dp[0][0]=true;\n\n  int ans=N;\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<(1<<N);j++){\n      \n      if(!dp[i][j]) continue;\n      \n      if(j==(1<<N)-1) ans=min(ans,i);\n      \n      for(int y=0;y<M;y++){\n\tfor(int x=0;x<M;x++){\n\t  \n\t  int idx=y*M+x;\n\t  \n\t  if(j&(1<<idx)) continue;\n\t  \n\t  for(int k=0;k<n;k++) mark(i,j,idx,k);\n\t  \n\t}\n      }\n      \n      \n    }\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a, b; vector<int> x, y; string tmp;\n\nmap<unsigned, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tunsigned finish = 0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tswitch (tmp[j])\n\t\t\t{\n\t\t\tcase 'R': finish += (1 << (i * 8 + j * 2)) * 1; break;\n\t\t\tcase 'G': finish += (1 << (i * 8 + j * 2)) * 2; break;\n\t\t\tcase 'B': finish += (1 << (i * 8 + j * 2)) * 3; break;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<unsigned, int> > que;\n\n\tque.push(make_pair(0, 0)); D[0] = true;\n\n\twhile (true)\n\t{\n\t\tunsigned M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (finish == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 1; c < 4; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tint bit = 1 << (l * 8 + m * 2);\n\n\t\t\t\t\t\t\t\tM2 -= M2 / bit % 4;\n\t\t\t\t\t\t\t\tM2 += bit * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nvoid printbin(int n){\n\tfor(int i=0; i<16; i++){\n\t\tcout << (n%2==0? 0: 1);\n\t\tn /= 2;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> h(n),w(n);\n\tfor(int i=0; i<n; i++) cin >> h[i] >> w[i];\n\tvector<vector<char> > c(4, vector<char>(4));\n\tfor(int i=0; i<4; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\t\n\tvector<int> dp(1<<16, inf);\n\tdp[0] = 0;\n\tfor(int i=0; i<(1<<16); i++){\n\t\tif(dp[i] == inf) continue;\n\t\tfor(int s=0; s<n; s++){\n\t\t\tfor(int y=1-h[s]; y<=2+h[s]; y++){\n\t\t\t\tfor(int x=1-w[s]; x<=2+w[s]; x++){\n\t\t\t\t\tchar color = 0;\n\t\t\t\t\tint newidx = i;\n\t\t\t\t\tfor(int j=0; j<h[s]; j++){\n\t\t\t\t\t\tfor(int k=0; k<w[s]; k++){\n\t\t\t\t\t\t\tint ny=y+j, nx=x+k;\n\t\t\t\t\t\t\tif(ny<0 || 4<=ny || nx<0 || 4<=nx) continue;\n\t\t\t\t\t\t\tif((i & 1<<(4*ny +nx)) != 0) continue;\n\t\t\t\t\t\t\tif(color!=0 && color!=c[ny][nx]){\n\t\t\t\t\t\t\t\tcolor = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolor = c[ny][nx];\n\t\t\t\t\t\t\tnewidx |= 1<<(4*ny +nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(color != 0){\n\t\t\t\t\t\tdp[newidx] = min(dp[newidx], dp[i]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16) -1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  bool used[1<<16];\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=-h[i]+1;j<4;j++){\n\tfor(int k=-w[i]+1;k<4;k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nint N,C[4][4];\npii stamp[16];\n\ninline int stp(int x,int y,int px,int py,int c,int S){\n  for(int i = max(0,py) ; i < min(py+y,4) ; i++){\n    for(int j = max(0,px) ; j < min(px+x,4) ; j++){\n      int b = i*4+j;\n      if(C[i][j] == c){\n        if((S >> b) & 1) continue;\n        S |= (1<<b);\n      }else{\n        if((S >> b) & 1){\n          S -= (1<<b);\n        }\n      }\n    }\n  }\n  return S;\n}\n\nint solve(){\n  queue<int> Q;\n  Q.push(0);\n  int dist[1<<16];\n  fill(dist,dist+(1<<16),INF);\n  dist[0] = 0;\n\n  while(!Q.empty()){\n    int S = Q.front(); Q.pop();\n    if(S == (1<<16)-1){\n      return dist[S];\n    }\n    for(int i = 0 ; i < N ; i++){\n      pii p = stamp[i];\n      int x = p.second, y = p.first;\n      for(int j = 0 ; j < 3 ; j++){\n        for(int px = -x+1 ; px < 4 ; px++){\n          for(int py = -y+1 ; py < 4 ; py++){\n            int nS = stp(x,y,px,py,j,S);\n            if(dist[S]+1 < dist[nS]){\n              dist[nS] = dist[S] + 1;\n              Q.push(nS);\n            }\n          }\n        } \n      }\n    }\n  }\n  return -1;\n}\n\nint change(char ch){\n  if(ch == 'R') return 0;\n  if(ch == 'B') return 1;\n  return 2;\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> stamp[i].first >> stamp[i].second;\n  }\n  char in;\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      cin >> in;\n      C[i][j] = change(in);\n    }    \n  }\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF 100\n\nint N;\nint H[16], W[16];\nstring C[4];\n\nstring color = \"RGB\";\n\nint solve()\n{\n\tqueue<int> que;\n\n\tque.push(0);\n\t\n\tint dist[1 << 16];\n\trep(i, 0, 1 << 16) dist[i] = INF;\n\tdist[0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint state = que.front(); que.pop();\n\n\t\tif (state == (1 << 16) - 1) return dist[state];\n\n\t\trep(i, 0, N) rep(j, 0, 3)\n\t\t{\n\t\t\trep(sy, -(H[i] - 1), 4) rep(sx, -(W[i] - 1), 4)\n\t\t\t{\n\t\t\t\tint tx = sx + W[i] - 1;\n\t\t\t\tint ty = sy + H[i] - 1;\n\n\t\t\t\tint nstate = 0;\n\t\t\t\trep(y, 0, 4) rep(x, 0, 4)\n\t\t\t\t{\n\t\t\t\t\tint f = 0;\n\n\t\t\t\t\tif ((sx <= x && x <= tx) && (sy <= y && y <= ty))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (C[y][x] == color[j])\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tf = (state >> (15 - (y * 4 + x))) & 0x01;\n\t\t\t\t\t}\n\n\t\t\t\t\tnstate = (nstate << 1) + f;\n\t\t\t\t}\n\n\t\t\t\tint nturn = dist[state] + 1;\n\t\t\t\tif (nturn < dist[nstate])\n\t\t\t\t{\n\t\t\t\t\tdist[nstate] = nturn;\n\t\t\t\t\tque.push(nstate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N)\n\t{\n\t\trep(i, 0, N) cin >> H[i] >> W[i];\n\t\trep(i, 0, 4) cin >> C[i];\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\nconst char color_list[] = {'R', 'G', 'B'};\n\nint stamp(int status, const pair<int, int>& stamp, int pos_h, int pos_w, char color, const vector<char>& c){\n  int up = max(pos_h, 0);\n  int down = min(stamp.first + pos_h, 4);\n  int left = max(pos_w, 0);\n  int right = min(stamp.second + pos_w, 4);\n\n  int stamp_bit = 0;\n  for(int i = up; i < down; i++)\n    for(int j = left; j < right; j++)\n      stamp_bit |= 1 << ((i * 4) + j);\n\n  for(int i = 0; i < 16; i++){\n    if((stamp_bit & (1 << i)) != 0){\n      if(color == c[i]){ status |= (1 << i); }\n      else{ status &= ~(1 << i); }\n    }\n  }\n\n  return status;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n\n  int h, w;\n  vector<pair<int, int> > stamps;\n  for(int i = 0; i < n; i++){\n    cin >> h >> w;\n    stamps.push_back(make_pair(h, w));\n  }\n  vector<char> c(16);\n  for(int i = 0; i < 16; i++){ cin >> c[i]; }\n\n  \n  int ans = INF;\n  const int goal = (1 << 16) - 1;\n\n  // ???????????????\n  vector<bool> used(1 << 16, false);\n  queue<pair<int, int> > wait;\n  wait.push(make_pair(0, 0));\n  used[0] = true;\n  while(!wait.empty()){\n    int cost = wait.front().first;\n    int status = wait.front().second;\n    wait.pop();\n\n    if(status == goal){\n      ans = cost;\n      break;\n    }\n\n    for(int i = 0; i < n; i++){\n      for(int z = 0; z < 3; z++){\n        for(int x = -3; x < 4; x++){\n          for(int y = -3; y < 4; y++){\n            int next_status = stamp(status, stamps[i], x, y, color_list[z], c);\n            if(!used[next_status]){\n              used[next_status] = true;\n              wait.push(make_pair(cost + 1, next_status));\n            }    \n          }\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\nvoid Min(int &a,int b){a=min(a,b);}\nint Idx(int y,int x){return y*4+x;}\n\nint nsta(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\nint mem[1<<16],used[1<<16];\nint dfs(int sta){\n  if(sta==(1<<16)-1)return 0;\n  if(used[sta]++) return mem[sta];\n  mem[sta]=INF;\n  int res=INF;\n  for(int i=0;i<3;i++)\n    for(int a=0;a<16;a++)\n      for(int b=0;b<16;b++)\n\tif(can[a][b]){\n\t  data yx=(data){a/4,a%4};\n\t  data YX=(data){b/4,b%4};\n\t  int t=nsta(sta,yx,YX,RGB[i]);\n\t  if(sta>t) continue;\n\t  res=min(res,1+dfs(nsta(sta,yx,YX,RGB[i]))); \n\t}\n  \n  return mem[sta]=res;\n}\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint dist[1 << 16];\nint N;\nint W[16], H[16];\nchar goal[4][4];\n\n\nint main(){\n\n  cin >> N;\n  REP(i, N) cin >> H[i] >> W[i];\n  REP(i, 4)REP(j, 4){\n    cin >> goal[i][j];\n    if(goal[i][j] == 'R') goal[i][j] = 0;\n    if(goal[i][j] == 'G') goal[i][j] = 1;\n    if(goal[i][j] == 'B') goal[i][j] = 2;\n  }\n\n  \n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, 0));\n  fill(dist, dist + (1 << 16), INF);\n  dist[0] = 0;\n  \n  while(!que.empty()){\n    int cost = que.top().first;\n    int mask = que.top().second;\n    que.pop();\n    if(cost > dist[mask]) continue;\n\n    if(mask == 0xFFFF){\n      cout << cost << endl;\n      return 0;\n    }\n    \n    \n    REP(i, N){\n      for(int h1 = -H[i] + 1; h1 < 4; h1++){\n        for(int w1 = -W[i] + 1; w1 < 4; w1++){\n          int h2 = h1 + H[i];\n          int w2 = w1 + W[i];\n          int nmaskc[3] = {0,0,0};\n          \n          int nmaskn = 0;\n          \n          REP(r, 4)REP(c, 4){\n            if(h1 <= r && r < h2 && w1 <= c && c < w2){\n              nmaskc[goal[r][c]] |= 1 << (r * 4 + c);\n            }else{\n              nmaskn |= mask & (1 << (r * 4 + c));\n            }\n          }\n\n          REP(color, 3){\n            int nmask = nmaskc[color] | nmaskn;\n            if(dist[nmask] > cost + 1){\n              dist[nmask] = cost + 1;\n              que.push(P(cost + 1, nmask));\n            }\n          }\n        }\n      }\n    }\n  }\n  assert(false);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tif(j+h[i] < 3 || k+w[i] < 3) continue;\n\t\t\t\t\t//{\n\t\t\t\t\t\tint l = -1;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(brd[j+hh][k+ww] != 0){\n\t\t\t\t\t\t\t\t\tl = brd[j+hh][k+ww];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l == -1) continue;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\trep(stp,N){\n\t  REP(y,0-H[stp]+1,4+H[stp]-1){\n\t    REP(x,0-W[stp]+1,4+W[stp]-1){\n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nset<P1> Range;\n\nvoid init(){\n\n  for(int idx=0;idx<N;idx++){\n    int y=idx/M, x=idx%M;\n    \n    for(int stamp=0;stamp<n;stamp++){\n      \n      for(int i=0;i<h[stamp];i++){\n    \n\tfor(int j=0;j<w[stamp];j++){\n\n\t  int miny=M,maxy=0,minx=M,maxx=0;\n\t  \n\t  for(int k=0;k<h[stamp];k++){\n\t\n\t    for(int l=0;l<w[stamp];l++){\n\t      \n\t      int ny=y-i+k, nx=x-j+l;\n\t      \n\t      if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t      \n\t      miny=min(miny,ny);\n\n\t      maxy=max(maxy,ny);\n\t      \n\t      minx=min(minx,nx);\n\n\t      maxx=max(maxx,nx);\n\t      \n\t    }\n\t    \n\t  }\n\n\t  Range.insert(P1(P(miny,maxy),P(minx,maxx)));\n\t  \n\t}\n\n      }\n\n    }\n    \n  }\n\n  \n}\n\nchar c[3]={'R','G','B'};\n\nvoid mark(int cost,int S){\n  \n  auto ite=Range.begin();\n  \n  while(ite!=Range.end()){\n\n    P1 t=(*ite);\n    \n    for(int k=0;k<3;k++){\n      \n      int nS=S;\n    \n      for(int i=t.first.first;i<=t.first.second;i++){\n\tfor(int j=t.second.first;j<=t.second.second;j++){\n\t  \n\t  int p=i*M+j;\n\t\n\t  if(s[i][j]==c[k]) nS|=(1<<p);\n\t  else nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\t\n\td[nS]=cost+1;\n\n\tq.push(P(cost+1,nS));\n\t\n      }\n      \n    }\n\n    ite++;\n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    mark(cost,S);\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  init();\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nint H[16], W[16];\nchar C[4][4];\nint c[4][4];\n\nstring clr = \"RGB\";\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N;\n  rep(i, N) cin >> H[i] >> W[i];\n\n  rep(i, 4) rep(j, 4) cin >> C[i][j], c[i][j] = clr.find(C[i][j]);\n\n  int d[1<<16];\n  memset(d, -1, sizeof(d));\n  d[0] = 0;\n  queue<int> que;\n  que.push(0);\n  while(!que.empty()) {\n    int bit = que.front(); que.pop();\n    if(bit == (1<<16)-1) break;\n    rep(i, 3) rep(j, N) {\n      reps(k, -H[j]+1, 4) reps(l, -W[j]+1, 4) {\n\tint nbit = bit;\n\treps(y, max(k, 0LL), min(k+H[j], 4LL)) {\n\t  reps(x, max(l, 0LL), min(l+W[j], 4LL)) {\n\t    int mask = 1<<(y*4+x);\n\t    if(c[y][x] == i && !((bit >> (y*4+x)) & 1) ||\n\t       c[y][x] != i && (bit >> (y*4+x)) & 1) {\n\t      nbit ^= mask;\n\t    }\n\t  }\n\t}\n\tif(d[nbit] == -1) {\n\t  d[nbit] = d[bit] + 1;\n\t  que.push(nbit);\n\t}\n      }\n    }\n  }\n\n  cout << d[(1<<16)-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  //cout<<G.size()<<endl;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        r(kk,4)tmp[kk]=t[kk];\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            tmp[i][j]=ccol[col];\n          }\n        }\n        int tp=0;\n        r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n        if(!dp[tp]){\n          dp[tp]=1;\n          q.push(P(tp,p.second+1));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <stack>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n\tconst char COLOR[] = \"RGB\";\n\tint N;\n\tcin >> N;\n\tvector<pii> stamps(N);\n\tfor(int i = 0; i < N; ++i){ cin >> stamps[i].first >> stamps[i].second; }\n\tstring goal;\n\tfor(int i = 0; i < 4; ++i){\n\t\tstring line;\n\t\tcin >> line;\n\t\tgoal += line;\n\t}\n\tset<string> maskset;\n\tfor(int i = 0; i < N; ++i){\n\t\tfor(int y = 1 - stamps[i].first; y < 4; ++y){\n\t\t\tfor(int x = 1 - stamps[i].second; x < 4; ++x){\n\t\t\t\tstring mask = \"................\";\n\t\t\t\tfor(int j = 0; j < stamps[i].first; ++j){\n\t\t\t\t\tif(y + j < 0){ continue; }\n\t\t\t\t\tif(y + j >= 4){ break; }\n\t\t\t\t\tfor(int k = 0; k < stamps[i].second; ++k){\n\t\t\t\t\t\tif(x + k < 0){ continue; }\n\t\t\t\t\t\tif(x + k >= 4){ break; }\n\t\t\t\t\t\tmask[(y + j) * 4 + (x + k)] = '-';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaskset.insert(mask);\n\t\t\t}\n\t\t}\n\t}\n\tvector<string> masks;\n\tmasks.reserve(maskset.size());\n\tfor(set<string>::iterator it = maskset.begin(); it != maskset.end(); ++it){\n\t\tmasks.push_back(*it);\n\t}\n\tset<string> passed_front;\n\tstack<string> q0, q1;\n\tstack<string> *cur_front = &q0, *next_front = &q1;\n\tcur_front->push(goal);\n\tpassed_front.insert(goal);\n\tint answer = 0;\n\twhile(true){\n\t\twhile(!cur_front->empty()){\n\t\t\tstring &s = cur_front->top();\n\t\t\tstring z;\n\t\t\tfor(vector<string>::iterator it = masks.begin(); it != masks.end(); ++it){\n\t\t\t\tz = s;\n\t\t\t\tchar c = '.';\n\t\t\t\tfor(int i = 0; i < 16; ++i){\n\t\t\t\t\tif((*it)[i] == '.' || s[i] == '.'){ continue; }\n\t\t\t\t\tif(c == '.'){\n\t\t\t\t\t\tc = s[i];\n\t\t\t\t\t}else if(c != s[i]){\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c == '.'){ continue; }\n\t\t\t\tfor(int i = 0; i < 16; ++i){\n\t\t\t\t\tif((*it)[i] != '.'){ z[i] = '.'; }\n\t\t\t\t}\n\t\t\t\tif(passed_front.find(z) == passed_front.end()){\n\t\t\t\t\tif(z == \"................\"){\n\t\t\t\t\t\tcout << answer + 1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tpassed_front.insert(z);\n\t\t\t\t\tnext_front->push(z);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_front->pop();\n\t\t}\n\t\tswap(cur_front, next_front);\n\t\t++answer;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\n\nint w[16];\nint h[16];\nint a[4][4];\n\nint memo[1<<16];\n\nint main(){\n\tfor(int i = 0 ; i < (1<<16) ; i++) memo[i] = -1;\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tcin >> w[i];\n\t\tcin >> h[i];\n\t}\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif( c == 'R') a[i][j] = 0;\n\t\t\tif( c == 'G') a[i][j] = 1;\n\t\t\tif( c == 'B') a[i][j] = 2;\n\t\t}\n\t\t\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int c = 0 ; c < 3 ; c++){\n\t\t\tfor(int j = -4 ; j < 4 ; j++){\n\t\t\t\tfor(int k = -4 ; k < 4 ; k++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tfor(int l = 0 ; l < h[i] ; l++){\n\t\t\t\t\t\tfor(int m = 0 ; m < w[i] ; m++){\n\t\t\t\t\t\t\tint tx = j + l;\n\t\t\t\t\t\t\tint ty = k + m;\n\t\t\t\t\t\t\tif( tx < 0 || tx >= 4 || ty >= 4 || ty < 0 ) continue;\n\t\t\t\t\t\t\tmask |= 1 << (ty * 4 + tx);\n\t\t\t\t\t\t\tres  |= ( a[ty][tx] == c ) << (ty * 4 + tx );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmem.push_back(res);\n\t\t\t\t\tmas.push_back(mask);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> Q;\n\t\n\tQ.push(0);\n\twhile(Q.size()){\n\t\tint q = Q.front(); Q.pop();\n\t\tfor(int i = 0 ; i < mas.size() ; i++){\n\t\t\tint next = q & ~mas[i];\n\t\t\tnext |= mem[i];\n\t\t\tif( memo[next] == -1){\n\t\t\t\tmemo[next] = memo[q]+1;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tcout << memo[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){int f=0;\n        r(kk,4)tmp[kk]=t[kk];\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            if(tmp[i][j]==s[i][j]&&s[i][j]!=ccol[col])f++;\n            tmp[i][j]=ccol[col];\n          }\n        }if(f)continue;\n        int tp=0;\n        r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n        if(!dp[tp]){\n          dp[tp]=1;\n          q.push(P(tp,p.second+1));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4];\n\t\t\telse F[i / 4][i % 4] = 0;\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = 1 - (int)x[i].first; j <= 3; j++) {\n\t\t\t\tfor (int k = 1 - (int)x[i].second; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint G = 0;\n\t\t\t\t\t\tfor (int l = max(-j, 0); l < min(4 - j, x[i].first); l++) {\n\t\t\t\t\t\t\tfor (int m = max(-k, 0); m < min(4 - k, x[i].second); m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m, cl = cx * 4 + cy;\n\t\t\t\t\t\t\t\tif (F[cx][cy] >= 1 && col[cx][cy] != o) { G -= (1 << cl); }\n\t\t\t\t\t\t\t\telse if (F[cx][cy] == 0 && col[cx][cy] == o) { G += (1 << cl); }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = G;\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\t  REP(y,-5,9){\n\t    REP(x,-5,9){\n\t      rep(stp,N){\n\t  \n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[1<<16];\nint N;\nint h[16],w[16];\nstring s[4];\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>h[i]>>w[i];\n\t}\n\tfor(int i=0;i<4;i++)cin>>s[i];\n\tfor(int i=0;i<1<<16;i++)dp[i]=114514;\n\tdp[(1<<16)-1]=0;\n\tfor(int i=1<<16;i--;)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tfor(int x=-3;x<4;x++)for(int y=-3;y<4;y++)\n\t\t\t{\n\t\t\t\tchar c=0;\n\t\t\t\tint take=0;\n\t\t\t\tfor(int I=0;I<h[j];I++)for(int J=0;J<w[j];J++)\n\t\t\t\t{\n\t\t\t\t\tif(x+I<0||x+I>=4||y+J<0||y+J>=4)continue;\n\t\t\t\t\tint now=(x+I)*4+y+J;\n\t\t\t\t\ttake|=1<<now;\n\t\t\t\t\tif(i>>now&1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(c==0)c=s[x+I][y+J];\n\t\t\t\t\t\telse if(c!=s[x+I][y+J])c=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c>1)\n\t\t\t\t{\n\t\t\t\t\tdp[i&~take]=min(dp[i&~take],dp[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n// #define mod 1000000007\n\nint c[4][4];\n\nint paint(int nowstate, int i, int j, int k, int l, int nowc)\n{\n\tint result = nowstate;\n\tfor(int s = i; s <= k; s++){\n\t\tfor(int t = j; t <= l; t++){\n\t\t\tif(c[s][t] == nowc) result |= (1 << (4 * s + t));\n\t\t\telse result &= ~(1 << (4 * s + t));\n\t\t}\n\t}\n\treturn result;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint canpaint[4][4][4][4] = {};\n\t// canpaint[i][j][k][l] : 右下が(i, j), 左上が(k, l)となるような範囲を塗れるスタンプがあるか否か\n\tfor(int p = 0; p < n; p++){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfor(int i = -h + 1; i < 4; i++){\n\t\t\tfor(int j = -w + 1; j < 4; j++){\n\t\t\t\tcanpaint[max(i, 0)][max(j, 0)][min(i + h - 1, 3)][min(j + w - 1, 3)] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tchar tmp;\n\t\t\tcin >> tmp;\n\t\t\tif(tmp == 'R') c[i][j] = 0;\n\t\t\telse if(tmp == 'G') c[i][j] = 1;\n\t\t\telse c[i][j] = 2;\n\t\t}\n\t}\n\tvector<int> result((1 << 16), -1);\n\tqueue<int> qu;\n\tresult[0] = 0;\n\tqu.push(0);\n\twhile(!qu.empty()){\n\t\tint p = qu.front();\n\t\t// cout << p << endl;\n\t\tqu.pop();\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tfor(int k = i; k < 4; k++){\n\t\t\t\t\tfor(int l = j; l < 4; l++){\n\t\t\t\t\t\tif(!canpaint[i][j][k][l]) continue;\n\t\t\t\t\t\tfor(int nowc = 0; nowc < 3; nowc++){\n\t\t\t\t\t\t\tint next = paint(p, i, j, k, l, nowc);\n\t\t\t\t\t\t\tif(result[next] < 0){\n\t\t\t\t\t\t\t\tresult[next] = result[p] + 1;\n\t\t\t\t\t\t\t\tqu.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result[(1 << 16) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;if(p.second==20)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,v.size()){\n      int y=v[k].first;\n      int x=v[k].second;\n      for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n          for(int col=0;col<3;col++){\n            r(kk,4)tmp[kk]=t[kk];\n            //if(p.second==0)r(kk,4)cout<<tmp[kk]<<endl;\n            for(int i1=i,c1=0;c1<y;c1++,i1++){\n              for(int j1=j,c2=0;c2<x;c2++,j1++){\n                if(0<=i1&&i1<4&&0<=j1&&j1<4)tmp[i1][j1]=ccol[col];\n              }\n            }\n            int tp=0;\n            //if(p.second==2)r(kk,4)cout<<tmp[kk]<<endl;\n            r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n            //cout<<p.second<<' '<<(__builtin_popcount(tp))<<endl;\n            if(!dp[tp]){\n              dp[tp]=1;\n              q.push(P(tp,p.second+1));\n            }\n          }\n        }\n      }\n    }\n    r(k,v.size()){\n      int y=v[k].first;\n      int x=v[k].second;\n      for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n          for(int col=0;col<3;col++){\n            r(kk,4)tmp[kk]=t[kk];\n            //if(p.second==0)r(kk,4)cout<<tmp[kk]<<endl;\n            for(int i1=i,c1=0;c1<y;c1++,i1--){\n              for(int j1=j,c2=0;c2<x;c2++,j1--){\n                if(0<=i1&&i1<4&&0<=j1&&j1<4)tmp[i1][j1]=ccol[col];\n              }\n            }\n            int tp=0;\n            //if(p.second==2)r(kk,4)cout<<tmp[kk]<<endl;\n            r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n            //cout<<p.second<<' '<<(__builtin_popcount(tp))<<endl;\n            if(!dp[tp]){\n              dp[tp]=1;\n              q.push(P(tp,p.second+1));\n            }\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16],used[1<<16];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\n\nll compute_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll num = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') num = 1;\n      if(stage[y][x] == 'G') num = 2;\n      if(stage[y][x] == 'B') num = 3;\n      res += num;\n      res *= base;\n      base *= 5LL;\n    }\n  }\n  return res;\n}\n\nll generate_clear_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      res += 0;\n      res *= base;\n      base *= 5LL;\n    }\n  }\n  return res;\n\n}\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\nvoid dfs(int count){\n  ll hash = compute_hash();\n\n  if(dp.find(hash) != dp.end() \n     && dp[hash] <= count) return;\n  dp[hash] = count;\n\n  for(int ly=0;ly<4;ly++){\n    for(int lx=0;lx<4;lx++){\n      for(int ry=ly;ry<4;ry++){\n        for(int rx=lx;rx<4;rx++){\n          //corner\n          if((lx == 0 && ly == 0)\n             || (lx == 0 && ly == 3)\n             || (rx == 3 && ry == 3)\n             || (rx == 3 && ry == 0)){\n            if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                char tmp[4][4];\n                memcpy(tmp,stage,sizeof(char)*4*4);\n                erase(ly,lx,ry,rx);\n                dfs(count+1);\n                memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //left or right\n          else if(lx == 0 || rx == 3){\n            if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //top or bottom\n          else if(ly == 0 || ry == 3){\n            if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //center\n          else {\n            if(has_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n        if(flag) corner_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n        if(flag) corner_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    dfs(0);\n    ll hash = generate_clear_hash();\n    printf(\"%d\\n\",dp[hash]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\n#define M 4\nusing namespace std;\n\nint n,h[N],w[N];\nstring s[M];\n\nbool dp[N+1][(1<<N)];\n\nvoid mark(int cnt,int S,int idx,int stamp){\n  \n  int y=idx/4,x=idx%4;\n  \n  for(int i=0;i<h[stamp];i++){\n\n    for(int j=0;j<w[stamp];j++){\n\n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<nS)) nS=nS&~(1<<p);\n\n\t}\n      }\n      \n      dp[cnt+1][nS]=true;\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  dp[0][0]=true;\n\n  int ans=N;\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<(1<<N);j++){\n      \n      if(!dp[i][j]) continue;\n      \n      if(j==(1<<N)-1) ans=min(ans,i);\n      \n      for(int y=0;y<M;y++){\n\tfor(int x=0;x<M;x++){\n\t  \n\t  int idx=y*M+x;\n\n\t  if(j&(1<<idx)) continue;\n\t  \n\t  for(int k=0;k<n;k++) mark(i,j,idx,k);\n\t  \n\t}\n      }\n      \n      \n    }\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[17][1<<16];\nint main(){\n  int n,h[16],w[16];\n  char r[3]={'R','G','B'};\n  string c[4];\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>h[i]>>w[i];\n  for(int i=0;i<4;i++)cin>>c[i];\n  dp[0][0]=1;\n  for(int j=0;j<16;j++)\n    for(int i=0;i<1<<16;i++)\n      if(dp[j][i])\n\tfor(int k=0;k<n;k++)\n\t  for(int cl=0;cl<3;cl++)\n\t    for(int y=-h[k]+1;y<4;y++)\n\t      for(int x=-w[k]+1;x<4;x++){\n\t\tint ni=i;\n\t\tfor(int l=max(0,y);l<min(4,y+h[k]);l++)\n\t\t  for(int m=max(0,x);m<min(4,x+w[k]);m++){\n\t\t    int xx=l*4+m;\n\t\t    if(c[l][m]==r[cl])ni|=(1<<xx);\n\t\t    else if(ni&(1<<xx))ni-=(1<<xx);\n\t\t  }\n\t    dp[j+1][ni]=1;\n\t    if(ni==(1<<16)-1){cout<<j+1<<endl;return 0;}\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\t  REP(y,-4,8){\n\t    REP(x,-4,8){\n\t      rep(stp,N){\n\t  \n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/02 20:16:19\n//=================================\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<int, int>;\n    vector<P> s(N);\n    for (int i = 0, H, W; i < N; i++) { cin >> H >> W, s[i] = {H, W}; }\n    vector<vector<int>> f(4, vector<int>(4, 0));\n    map<char, int> mp;\n    mp['R'] = 1, mp['G'] = 2, mp['B'] = 3;\n    for (int i = 0; i < 4; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 4; j++) { f[i][j] = mp[s[j]]; }\n    }\n    vector<int> memo(1 << 16, -1);\n    auto dfs = [&](auto&& self, const int hash, const vector<vector<int>>& f) -> int {\n        if (hash == 0) { return 0; }\n        if (memo[hash] != -1) { return memo[hash]; }\n        int ans = 30;\n        for (int i = 0; i < N; i++) {\n            const int H = s[i].first, W = s[i].second;\n            for (int h = 1 - H; h < 4; h++) {\n                for (int w = 1 - W; w < 4; w++) {\n                    const int hinf = max(h, 0), winf = max(w, 0);\n                    const int hsup = min(h + H, 4), wsup = min(w + W, 4);\n                    int ch = -1;\n                    bool ok = true;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            if (f[i][j] != 0) {\n                                if (ch != -1 and ch != f[i][j]) { ok = false; }\n                                ch = f[i][j];\n                            }\n                        }\n                    }\n                    if (not ok or ch == -1) { continue; }\n                    auto newf = f;\n                    int h = hash;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            newf[i][j] = 0;\n                            h &= ~(1 << (4 * i + j));\n                        }\n                    }\n                    const int sub = self(self, h, newf) + 1;\n                    ans = min(ans, sub);\n                }\n            }\n        }\n        return memo[hash] = ans;\n    };\n    const int ans = dfs(dfs, (1 << 16) - 1, f);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    bool flag[4][4][5][5][3];\n    fill_n((bool*)flag,4*4*5*5*3,false);\n    rep(y1,0,4) rep(x1,0,4) rep(y2,y1+1,5) rep(x2,x1+1,5) rep(y,y1,y2) rep(x,x1,x2) flag[y1][x1][y2][x2][c[y][x]]=true;\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    vector<int> cost(1<<16,inf);\n    queue<int> que;\n    cost[0]=0;\n    que.push(0);\n    while(!que.empty()){\n        auto state=que.front();\n        que.pop();\n        if(state==(1<<16)-1){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-h[i]+1,4) rep(x,-w[i]+1,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            rep(j,0,3){\n                if(!flag[y1][x1][y2][x2][j]) continue;\n                auto next_state=state;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j) next_state|=1<<(4*y_+x_);\n                    else next_state&=~(1<<(4*y_+x_));\n                }\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(next_state);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int INF=12345678;\nconst int N=1<<16;\n\nint dp[N];\nint AND[16][3][7][7];\nint OR[16][3][7][7]={};\n\nint solve()\n{\n    int n;\n    cin >>n;\n    vector<int> h(n),w(n);\n    rep(i,n) cin >>h[i] >>w[i];\n\n    int c[4][4];\n    rep(i,4)\n    {\n        string s;\n        cin >>s;\n        rep(j,4)\n        {\n            if(s[j]=='R') c[i][j]=0;\n            else if(s[j]=='G') c[i][j]=1;\n            else c[i][j]=2;\n        }\n    }\n\n    #define IN(x,y) (0<=x && x<4 && 0<=y && y<4)\n    rep(i,n)rep(col,3)for(int x=-3; x<=3; ++x)for(int y=-3; y<=3; ++y)\n    {\n        AND[i][col][x+3][y+3] = N-1;\n\n        rep(dy,h[i])rep(dx,w[i])\n        {\n            int nx=x+dx, ny=y+dy;\n            if(IN(nx,ny))\n            {\n                int shift = ny*4+nx;\n                AND[i][col][x+3][y+3] -= 1<<shift;\n                if(col == c[ny][nx]) OR[i][col][x+3][y+3] += 1<<shift;\n            }\n        }\n    }\n\n    fill(dp,dp+N,INF);\n    dp[0]=0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty())\n    {\n        int mask = que.front();\n        que.pop();\n        rep(i,n)rep(col,3)for(int x=-3; x<=3; ++x)for(int y=-3; y<=3; ++y)\n        {\n            int nmask = (mask&AND[i][col][x+3][y+3])|OR[i][col][x+3][y+3];\n\n            if(dp[nmask] > dp[mask]+1)\n            {\n                que.push(nmask);\n                dp[nmask] = dp[mask]+1;\n\n                if(nmask == N-1) return dp[nmask];\n            }\n        }\n    }\n\n    assert(false);\n}\n\nint main()\n{\n    printf(\"%d\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef int ll;\n\nll N, H[16], W[16];\nchar S[4][4];\nconst char Z[] = \"RGB\";\nll dp[1 << 16];\n\nint main(void) {\n  scanf(\"%d\", &N);\n  REP(i, 0, N) scanf(\"%d %d\", H + i, W + i);\n  REP(i, 0, 4) scanf(\"%s\", S[i]);\n\n  REP(i, 0, 1 << 16) dp[i] = -1;\n  dp[0] = 0;\n  queue<ll> q;\n  q.push(0);\n  while(q.size()) {\n    if(dp[(1 << 16) - 1] != -1) break;\n    ll s = q.front(); q.pop();\n    REP(i, 0, N) {\n      REP(py, -H[i] + 1, 4) REP(px, -W[i] + 1, 4) REP(c, 0, 3) {\n        ll n = s;\n        REP(y, max(py, 0), min(py + H[i], 4)) REP(x, max(px, 0), min(px + W[i], 4)) {\n          if(S[y][x] == Z[c]) n = n | (1 << (y * 4 + x));\n          else n = n & (~(1 << (y * 4 + x)));\n        }\n        if(dp[n] == -1) {\n          dp[n] = dp[s] + 1;\n          q.push(n);\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", dp[(1 << 16) - 1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nstruct P {\n    int cost;\n    uint16_t bit;\n};\n\nchar colorchar[] = {'R', 'G', 'B'};\nchar G[1<<16];\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pii> stamp(N);\n    REP(i, N) {\n        cin >> stamp[i].second >> stamp[i].first;\n    }\n    vvc field(4, vc(4));\n    REP(y, 4) REP(x, 4) {\n        cin >> field[y][x];\n    }\n\n    fill_n((char *)G, 1<<16, -1);\n    uint16_t goal = (1<<16)-1;\n\n    queue<uint16_t> que;\n    G[0] = 0;\n    que.push(0);\n    while (!que.empty()) {\n        uint16_t p = que.front(); que.pop();\n        if (p == goal) {\n            printf(\"%d\\n\", G[p]);\n            break;\n        }\n        REP(i, N) {\n            FOR(ly, -stamp[i].second+1, 4) FOR(lx, -stamp[i].first+1, 4) {\n                int rx = lx + stamp[i].first, ry = ly + stamp[i].second;\n                uint16_t bit[3] = {p, p, p};\n                FOR(sy, ly, ry) FOR(sx, lx, rx) {\n                    if (0 <= sx && sx < 4 && 0 <= sy && sy < 4) {\n                        REP(j, 3) {\n                            int k = 4*sy+sx;\n                            if (field[sy][sx] == colorchar[j]) {\n                                bit[j] |= 1<<k;\n                            } else {\n                                bit[j] &= ~(1<<k);\n                            }\n                        }\n                    }\n                }\n                REP(j, 3) {\n                    if (G[bit[j]] == -1) {\n                        G[bit[j]] = G[p]+1;\n                        que.push(bit[j]);\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nvector<int> mask1,mask2;\n\nvector< vector<char> > goal(4,vector<char>(4));\n\nint w[20],h[20];\n\nint gen(int s,int x,int y){\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask1.push_back(a);\n\t\tmask2.push_back(b);\n\t}\n}\nint f(int init){\n\tQ[size++] = init;\n\tmemo[init] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,mask1.size()){\n\t\t\tint bit = (q & ~mask1[i]) | mask2[i];\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[i][j] = c;\n\t}\n\t\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\n\t\n\tcout << f(0) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint n;\nint h[20],w[20];\nconst int H=4,W=4;\nint ans=16;\n\nset<string> used;\n\nvoid dfs(string s,int cnt){\n    bool ok=true;\n    rep(i,H)rep(j,W){\n        if(s[H*i+j]!='*')ok=false;\n    }\n    if(ok){\n        ans = min(ans,cnt);\n        return ;\n    }\n    if(used.count(s))return;\n    used.insert(s);\n    if(cnt>=ans)return;\n    rep(i,n){\n        REP(j,-H,H)REP(k,-W,W){\n            set<char> st;\n            rep(l,h[i])rep(m,w[i]){\n                if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W&&s[(j+l)*H+k+m]!='*'){\n                    st.insert(s[(j+l)*H+k+m]);\n                }\n            }\n            if(st.size()!=1)continue;\n            string ns=s;\n            rep(l,h[i])rep(m,w[i]){\n                if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W){\n                    ns[(j+l)*H+k+m]='*';\n                }\n            }\n            dfs(ns,cnt+1);\n        }\n    }\n}\n\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>h[i]>>w[i];\n    }\n    string s;\n    rep(i,4){\n        string t;\n        cin>>t;\n        s+=t;\n    }\n    dfs(s,0);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,v=1<<16;\n  cin>>n;\n  int h[n],w[n],dp[v],used[v];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(int i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=v-1-(1<<(y*4+x));\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[v-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[16],w[16];\nchar t[16];\nvector<P> G;\nmap<P,bool> used;\nstring str=\"RGB\";\n\nint d[(1<<16)];\n\nint solve(){\n  queue<int> Q;\n  for(int i=0;i<(1<<16);i++)d[i]=-1;\n  d[0]=0;\n  Q.push(0);\n  \n  while(!Q.empty()){\n    int S=Q.front();Q.pop();\n    if(S==(1<<16)-1)return d[S];\n    \n    for(int i=0;i<(int)G.size();i++){\n      int ay=G[i].first/5;\n      int ax=G[i].first%5;\n      int by=G[i].second/5;\n      int bx=G[i].second%5;\n      //cout<<ay<<' '<<ax<<' '<<by<<' '<<bx<<endl;\n      for(int j=0;j<3;j++){\n        char ch=str[j];\n        int next=S;\n        for(int y=ay;y<by;y++){\n          for(int x=ax;x<bx;x++){\n            int z=y*4+x;\n            next|=(1<<z);\n            if(t[z]!=ch)next-=(1<<z);\n          }\n        }\n        if(d[next]==-1){\n          d[next]=d[S]+1;\n          Q.push(next);\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nvoid add(int h,int w){\n  P p;\n  for(int i=-h+1;i<4;i++){\n    for(int j=-w+1;j<4;j++){\n      int ay=max(i,0);\n      int ax=max(j,0);\n      int by=min(i+h,4);\n      int bx=min(j+w,4);\n      p.first=ay*5+ax;\n      p.second=by*5+bx;\n      if(used[p])continue;\n      used[p]=true;\n      G.push_back(p);\n    }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h[i]>>w[i];\n    add(h[i],w[i]);\n  }\n\n  for(int i=0;i<16;i++)cin>>t[i];\n  sort(G.begin(),G.end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<char> vc;\ntypedef vector<vc> Pic;\n\nconst char color[] = {'R', 'G', 'B'};\n\nbool canDelete(Pic& pic, pair<int, int> s, int y, int x, char c){\n\tbool f = false;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tif(pic[i][j] == c) f = true;\n\t\t\tif(pic[i][j] != c and pic[i][j] != '.') return false;\n\t\t}\n\t}\n\treturn f;\n}\nvoid output(Pic pic){\n\tfor(auto i : pic){\n\t\tfor(auto j : i) cout << j;\n\t\tcout << endl;\n\t}\n}\n\nPic getPicDeletedColor(Pic& pic, pair<int, int> s, int y, int x){\n\tPic res = pic;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tres[i][j] = '.';\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstruct P{\n\tint cnt;\n\tPic pic;\n\tP(int cnt, Pic pic) : cnt(cnt), pic(pic) {}\n\tbool operator < ( const P &right ) const {\n\t\treturn cnt < right.cnt;\n\t}\n\tbool operator > ( const P &right ) const {\n\t\treturn cnt > right.cnt;\n\t}\n};\n\nvoid bfs(vector<pair<int, int>>& stamps, Pic& pic){\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.emplace(0, pic);\n\n\tmap<Pic, int> dis;\n\n\tPic endPic(4, vc(4,'.'));\n\n\twhile(not q.empty()){\n\t\tP tmp = q.top(); q.pop();\n\n\t\tPic p = tmp.pic;\n\t\tint cnt = tmp.cnt;\n\n\t\tif(dis.count(p)) continue;\n\t\tdis[p] = cnt;\n\n\t\tif(endPic == p){\n\t\t\tcout << cnt << endl;\n\t\t\treturn;\n\t\t}\n\n\n\t\trep(c,3){\n\t\t\trep(i,stamps.size()){\n\t\t\t\trange(y, 1 - stamps[i].first, 4){\n\t\t\t\t\trange(x, 1 - stamps[i].second, 4){\n\t\t\t\t\t\tif(canDelete(p, stamps[i], y, x, color[c])){\n\t\t\t\t\t\t\t\t//output(getPicDeletedColor(pic, stamps[i], y, x));\n\t\t\t\t\t\t\tq.emplace(cnt + 1, getPicDeletedColor(p, stamps[i], y, x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> stamps(n);\n\trep(i,n){\n\t\tcin >> stamps[i].first >> stamps[i].second;\n\t}\n\n\tPic pic(4, vc(4));\n\trep(i,4) rep(j,4) cin >> pic[i][j];\n\n\tbfs(stamps, pic);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <queue>\n#define INF 100\nusing namespace std;\n\nint n;\nint h[17],w[17];\nint dp[1<<16];\nint fie[4][4];\nbool ok[4][4][4][4];\n\nint bfs(int s){\n\tqueue<int> que;\n\tfor(int i=0;i<1<<16;i++){\n\t\tdp[i]=INF;\n\t}\n\tque.push(s);\n\tdp[s]=0;\n\twhile(que.size()){\n\t\tint bit=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int k=i+1;k<=4;k++){\n\t\t\t\t\tfor(int l=j+1;l<=4;l++){\n\t\t\t\t\t\tif(!ok[i][j][k][l])continue;\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tint nbit=bit;\n\t\t\t\t\t\t\tfor(int x=i;x<k;x++){\n\t\t\t\t\t\t\t\tfor(int y=j;y<l;y++){\n\t\t\t\t\t\t\t\t\tint nshift=y*4+x;\n\t\t\t\t\t\t\t\t\tif((nbit>>nshift & 1) && fie[x][y]!=c)nbit-=(1<<nshift);\n\t\t\t\t\t\t\t\t\tif(!(nbit>>nshift & 1) && fie[x][y]==c)nbit+=(1<<nshift);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(dp[nbit]==INF){\n\t\t\t\t\t\t\t\tdp[nbit]=dp[bit]+1;\n\t\t\t\t\t\t\t\tque.push(nbit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[(1<<16)-1];\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tmemset(ok,false,sizeof(ok));\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&h[i],&w[i]);\n\t\tfor(int j=-3;j<4;j++){\n\t\t\tfor(int k=-3;k<4;k++){\n\t\t\t\tint lx=max(0,j);\n\t\t\t\tint ly=max(0,k);\n\t\t\t\tint rx=min(4,j+w[i]);\n\t\t\t\tint ry=min(4,k+h[i]);\n\t\t\t\tif(lx>=rx || ly>=ry)continue;\n\t\t\t\tok[lx][ly][rx][ry]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(str[j]=='R')fie[j][i]=0;\n\t\t\tif(str[j]=='G')fie[j][i]=1;\n\t\t\tif(str[j]=='B')fie[j][i]=2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs(0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst string str = \"RGB\";\n\nint n, a, b; vector<int> x, y; vector<string> M;\n\nmap<vector<string>, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tM.resize(4);\n\n\tfor (int i = 0; i < 4; i++) cin >> M[i];\n\n\tqueue<pair<vector<string>, int> > que;\n\n\tque.push(make_pair(vector<string>({ \"WWWW\", \"WWWW\", \"WWWW\", \"WWWW\" }), 0)); D[M] = 0;\n\n\twhile (true)\n\t{\n\t\tvector<string> M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (M == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < 3; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<string> M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tM2[l][m] = str[c];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\nll compute_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') type = 1;\n      if(stage[y][x] == 'G') type = 2;\n      if(stage[y][x] == 'B') type = 3;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n  return res;\n}\n\nvoid hash2stage(ll hash){\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = hash % 4LL;\n      if(type == 0) stage[y][x] = '.';\n      if(type == 1) stage[y][x] = 'R';\n      if(type == 2) stage[y][x] = 'G';\n      if(type == 3) stage[y][x] = 'B';\n      hash /= 4LL;\n    }\n  }\n}\n\nll compute_clear_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n\n  return res;\n}\n\nvoid print_stage(){\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\n\nclass State {\npublic:\n  ll _hash;\n  int _cost;\n  \n  State(ll hash,int cost) : _hash(hash), _cost(cost) {}\n  bool operator<(const State& s) const {\n    return _cost < s._cost;\n  }\n  bool operator>(const State& s) const {\n    return _cost > s._cost;\n  }\n};\n\nint bfs(){\n\n  priority_queue<State,vector<State>, greater<State> > que;\n  ll init = compute_hash();\n  ll goal = compute_clear_hash();\n  que.push(State(init,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s._hash == goal) return s._cost;\n    hash2stage(s._hash);\n\n    for(int ly=0;ly<4;ly++){\n      for(int lx=0;lx<4;lx++){\n        for(int ry=ly;ry<4;ry++){\n          for(int rx=lx;rx<4;rx++){\n            //corner\n            if((lx == 0 && ly == 0)\n               || (lx == 0 && ly == 3)\n               || (rx == 3 && ry == 3)\n               || (rx == 3 && ry == 0)){\n              if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //left or right\n            else if(lx == 0 || rx == 3){\n              if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //top or bottom\n            else if(ly == 0 || ry == 3){\n              if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //center\n            else {\n              if(has_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1) continue;\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return INF;\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\nusing pii = pair<int,int>;\n\nint table[4][4];\n\nbool inside(int a, int b){\n\treturn 0<=a&&a<4&&0<=b&&b<4;\n}\n\nint calc(vector<vector<int>> vv){\n\tint state = 0;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tif(vv[i][j]){\n\t\t\t\tstate += 1<<(i*4+j);\n\t\t\t}\n\t\t}\n\t}\n\treturn state;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\trep(k,3){\n\t\t\t\tif(t == \"RGB\"[k]){\n\t\t\t\t\ttable[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dp(1<<16,1e9);\n\tdp[0] = 0;\n\trep(i,1<<16){\n\t\tif(dp[i]>1e8) continue;\n\t\tvector<vector<int>> vv(4,vector<int>(4));\n\t\trep(j,16){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tvv[j/4][j%4] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto x: v){\n\t\t\trep(_k,4){\n\t\t\t\trep(_l,4){\n\t\t\t\t\tint k = _k;\n\t\t\t\t\tint l = _l;\n\t\t\t\t\trep(color, 3){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\tif(inside(k+kk,l+ll)&&table[k+kk][l+ll]!=color&&vv[k+kk][l+ll]==0) ok=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\t// auto tmp = vv;\n\t\t\t\t\t\t\tint tmp = i;\n\t\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\t\tif(inside(k+kk,l+ll)&&vv[k+kk][l+ll]==0){\n\t\t\t\t\t\t\t\t\t\ttmp += 1<<((k+kk)*4+l+ll);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[tmp] = min(dp[tmp], dp[i]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trep(color, 3){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\tif(inside(k-kk,l-ll)&&table[k-kk][l-ll]!=color&&vv[k-kk][l-ll]==0) ok=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\t// auto tmp = vv;\n\t\t\t\t\t\t\tint tmp = i;\n\t\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\t\tif(inside(k-kk,l-ll)&&vv[k-kk][l-ll]==0){\n\t\t\t\t\t\t\t\t\t\ttmp += 1<<((k-kk)*4+l-ll);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[tmp] = min(dp[tmp], dp[i]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[8][8];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 4; i < 8; i++) for(int j = 4; j < 8; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[8][8];\n\t\trep(i,8) rep(j,8) b[i][j] = 0;\n\t\tfor(int i = 4; i < 8; i++) for(int j = 4; j < 8; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,8){\n\t\t\t\trep(k,8){\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 8) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 8) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 7; hh >= 4; hh--){\n\t\t\t\t\t\t\tfor(int ww = 7; ww >= 4; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      //      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nint N,C[4][4];\npii stamp[16];\n\nbool inField(int x,int y){\n  return 0 <= x && x < 4 && 0 <= y && y < 4;\n}\n\nint stp(int x,int y,int px,int py,int c,int S){\n  for(int i = py ; i < py+y ; i++){\n    for(int j = px ; j < px+x ; j++){\n      if(!inField(j,i)) continue;\n      int b = i*4+j;\n      if(C[i][j] == c){\n        if((S >> b) & 1) continue;\n        S |= (1<<b);\n      }else{\n        if((S >> b) & 1){\n          S -= (1<<b);\n        }\n      }\n    }\n  }\n  return S;\n}\n\nint solve(){\n  queue<int> Q;\n  Q.push(0);\n  int dist[1<<16];\n  fill(dist,dist+(1<<16),INF);\n  dist[0] = 0;\n\n  while(!Q.empty()){\n    int S = Q.front(); Q.pop();\n    if(S == (1<<16)-1){\n      return dist[S];\n    }\n    for(int i = 0 ; i < N ; i++){\n      pii p = stamp[i];\n      int x = p.second,y = p.first;\n      for(int j = 0 ; j < 3 ; j++){\n        for(int px = -x+1 ; px < 4+x-1 ; px++){\n          for(int py = -y+1 ; py < 4+y-1 ; py++){\n            int nS = stp(x,y,px,py,j,S);\n            if(dist[S]+1 < dist[nS]){\n              dist[nS] = dist[S] + 1;\n              Q.push(nS);\n            }\n          }\n        } \n      }\n    }\n  }\n  return -1;\n}\n\nint change(char ch){\n  if(ch == 'R') return 0;\n  if(ch == 'B') return 1;\n  return 2;\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> stamp[i].first >> stamp[i].second;\n  }\n  char in;\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      cin >> in;\n      C[i][j] = change(in);\n    }    \n  }\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\ntemplate<typename T>\nvector<vector<T>> keisann(const vector<vector<T>>l, const vector<vector<T>>r) {\n\tvector<vector<T>>ans(l.size(), vector<T>(r[0].size()));\n\tassert(l[0].size() == r.size());\n\tfor (unsigned int h = 0; h < l.size(); ++h) {\n\t\tfor (unsigned int i = 0; i < r.size(); ++i) {\n\t\t\tfor (unsigned int w = 0; w < r[0].size(); ++w) {\n\n\t\t\t\tans[h][w] += l[h][i] * r[i][w];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\ntemplate<typename T>\nvector<vector<T>>powgyou(vector<vector<T>>a, const long long int n) {\n\tassert(a.size() == a[0].size());\n\tif (!n) {\n\t\tvector<vector<T>>e(a.size(), vector<T>(a[0].size()));\n\t\tfor (unsigned int i = 0; i < a.size(); ++i) {\n\t\t\te[i][i] = 1;\n\t\t}\n\t\treturn e;\n\t}\n\tif (n == 1)return a;\n\telse {\n\t\tvector<vector<T>>ans(a.size(), vector<T>(a[0].size(), 0));\n\t\tans = powgyou(a, n / 2);\n\t\tans = keisann(ans, ans);\n\t\tif (n % 2) {\n\t\t\tans = keisann(ans, a);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 2147483647;\nconst long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\t\t\t\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\nok = true;\nbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, 0));\n\t\t\t}\n\t\t}\n\t}\n\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nmap<long long int, int>soinnsuu(long long int a) {\n\tmap<long long int, int>ans;\n\tfor (long long i = 2; i*i <= a; ++i) {\n\t\twhile (a%i == 0) {\n\t\t\tans[i]++;\n\t\t\ta /= i;\n\t\t}\n\t}\n\tif (a != 1)ans[a]++;\n\n\n\treturn ans;\n}\n\nbool isso(long long int a) {\n\tif (a == 1)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif (!(a%i)) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t}\n\t}\n\treturn true;\n}\n\n\nstruct vert {\n\tint deg;\n\tint s;\n\tint id;\n\tvert(int a, int b, int c) {\n\t\tdeg = a;\n\t\ts = b;\n\t\tid = c;\n\t}\n};\n\n\n#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\nclass Compare {\npublic:\n\tbool operator()(const pair<int, int>&l, const pair<int, int>&r) {\n\t\treturn l.second > r.second;\n\t}\n};\nvector<pair<int, int>>stamps;\nint dp[1 << 16];\nvector<vector<int>>puz(4, vector<int>(4));;\n\nint getans(const bitset<16>bt) {\n\tif (dp[bt.to_ulong()] >= 0)return dp[bt.to_ulong()];\n\telse {\n\t\tif (bt.count() == 16)return dp[bt.to_ulong()] = 0;\n\t\telse {\n\n\t\t\tint ans = 16 - bt.count();\n\t\t\tfor (int i = 0; i < stamps.size(); ++i) {\n\t\t\t\tint h = stamps[i].first;\n\t\t\t\tint w = stamps[i].second;\n\t\t\t\tfor (int l = 1-w; l < 4; ++l) {\n\t\t\t\t\tfor (int u = 1-h; u < 4; ++u) {\n\t\t\t\t\t\tfor (int c = 0; c < 3; ++c) {\n\n\t\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\t\tfor (int x = max(0,l); x < l + w; ++x) {\n\t\t\t\t\t\t\t\tif (x >= 4)break;\n\t\t\t\t\t\t\t\tfor (int y = max(0,u); y < u + h; ++y) {\n\t\t\t\t\t\t\t\t\tif (y >= 4)break;\n\t\t\t\t\t\t\t\t\tif (bt[y * 4 + x] || puz[y][x] == c) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\t\tgoto a;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\t\t\tbitset<16>copybt(bt);\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tfor (int x = max(0, l); x < l + w; ++x) {\n\t\t\t\t\t\t\t\t\tif (x >= 4)break;\n\t\t\t\t\t\t\t\t\tfor (int y = max(0, u); y < u + h; ++y) {\n\t\t\t\t\t\t\t\t\t\tif (y >= 4)break;\n\t\t\t\t\t\t\t\t\t\tif (!copybt[y * 4 + x]) {\n\t\t\t\t\t\t\t\t\t\t\tcopybt[y * 4 + x] = true;\n\t\t\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\t\t\tans = min(ans, 1+getans(copybt));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\ta:int n;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[bt.to_ulong()] = ans;\n\t\t}\n\t}\n}\n\nint main() {\n\tmemset(dp, -1, sizeof(dp));\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint h, w; cin >> h >> w;\n\t\tstamps.push_back(make_pair(h, w));\n\t}\n\tfor (int i = 0; i < 4; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tif (st[j] == 'R')puz[i][j] = 0;\n\t\t\telse if (st[j] == 'B')puz[i][j] = 1;\n\t\t\telse puz[i][j] = 2;\n\t\t}\n\t}\n\tint ans = getans(bitset<16>(0));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\n\nint Idx(int y,int x){return y*4+x;}\nint getBit(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\n\nint bfs(){\n  vector<int>D(1<<16,INF);\n  queue<int> Q;\n  Q.push(0);\n  D[0]=0;\n  while(!Q.empty()){\n    int bit=Q.front();Q.pop();\n    if(bit==(1<<16)-1)break;\n    for(int i=0;i<3;i++)\n      for(int a=0;a<16;a++)\n\tfor(int b=0;b<16;b++)\n\t  if(can[a][b]){\n\t    data yx=(data){a/4,a%4};\n\t    data YX=(data){b/4,b%4};\n\t    int nbit=getBit(bit,yx,YX,RGB[i]);\n\t    if(D[nbit]==INF)Q.push(nbit),D[nbit]=D[bit]+1;\n\t  }\n  }\n  return D[(1<<16)-1];\n}\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct State{\n\tint lx, ly, rx, ry;\n\tState(int lx_, int ly_, int rx_, int ry_){\n\t\tlx = lx_; ly = ly_; rx = rx_; ry = ry_;\n\t}\n};\n\nconst int INF = 1e+8;\nbool stamp[4][4][4][4] = {0};\nvector<State> v;\nvector<int> S;\nchar C[4][4];\nint d[1<<16];\nchar color[3] = {'R','G','B'};\n\n\nvoid init(){\n\tfor(int ly=0 ; ly < 4 ; ly++ ){\n\t\tfor(int lx=0 ; lx < 4 ; lx++ ){\n\t\t\tfor(int ry=0 ; ry < 4 ; ry++ ){\n\t\t\t\tfor(int rx=0 ; rx < 4 ; rx++ ){\n\t\t\t\t\tstamp[ly][lx][ry][rx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid check_stamp(int w, int h){\n\tfor(int dy = -3 ; dy <= 3 ; dy++ ){\n\t\tfor(int dx = -3 ; dx <= 3 ; dx++ ){\n\t\t\tint lx=4, ly=4, rx=-1, ry=-1;\n\t\t\tfor(int y = dy ; y < dy + h ; y++ ){\n\t\t\t\tfor(int x = dx ; x < dx + w ; x++ ){\n\t\t\t\t\tif( x < 0 || y < 0 || 4 <= x || 4 <= y ) continue;\n\t\t\t\t\tlx = min(lx, x);\n\t\t\t\t\tly = min(ly, y);\n\t\t\t\t\trx = max(rx, x);\n\t\t\t\t\try = max(ry, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( lx < 0 || 4 <= lx || ly < 0 || 4 <= ly ) continue;\n\t\t\tif( rx < 0 || 4 <= rx || ry < 0 || 4 <= ry ) continue;\n\t\t\tstamp[ly][lx][ry][rx] = true;\n\t\t}\n\t}\n}\n\n// ティツ可イ c テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲテ」ツ?ョbitテ・ツ按療」ツつ津ィツソツ氾」ツ??\nint to_bit(char ch){\n\tint res = 0;\n\tfor(int y=0 ; y < 4 ; y++ ){\n\t\tfor(int x=0 ; x < 4 ; x++ ){\n\t\t\tif( C[y][x] == ch ){\n\t\t\t\tres = (res << 1) | 1;\n\t\t\t}else{\n\t\t\t\tres = res << 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve(){\n\tfor(int i=0 ; i < (1<<16) ; i++ ){\n\t\td[i] = INF;\n\t}\n\td[0] = 0;\n\tqueue<int> q;\n\tq.push( 0 );\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint bits = q.front();\n\t\tint cost = d[bits];\n\t\tq.pop();\n\t\t\n\t\tif( bits == (1<<16)-1 ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0 ; i < S.size() ; i++ ){\n\t\t\tfor(int j=0 ; j < 3 ; j++ ){\n\t\t\t\tint mask = to_bit(color[j]);\n\t\t\t\tint next = bits ^ (mask & S[i]);\n\t\t\t\tif( d[next] == INF ){\n\t\t\t\t\td[next] = cost + 1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid make_stamp(){\n\t// テ」ツつケテ」ツつソテ」ツδウテ」ツδ療」ツ?ョテ・ツ。ツ療」ツつ甘ヲツ鳴ケテ」ツ?ョテ」ツδ?」ツつァテ」ツδε」ツつッ (テ・ツ、ツ堙」ツ?湘」ツ?ヲテ」ツつ?00テゥツ?堙」ツつ?\n\tfor(int ly=0 ; ly < 4 ; ly++ ){\n\t\tfor(int lx=0 ; lx < 4 ; lx++ ){\n\t\t\tfor(int ry = ly ; ry < 4 ; ry++ ){\n\t\t\t\tfor(int rx = lx ; rx < 4 ; rx++ ){\n\t\t\t\t\tif( stamp[ly][lx][ry][rx] ){\n\t\t\t\t\t\tif( lx < 0 || 4 <= lx || ly < 0 || 4 <= ly ) continue;\n\t\t\t\t\t\tif( rx < 0 || 4 <= rx || ry < 0 || 4 <= ry ) continue;\n\t\t\t\t\t\tv.push_back( State(lx,ly,rx,ry) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// bit テ・ツ按療」ツ?ォテァツ崢エテ」ツ?療」ツ?ヲテ」ツ?甘」ツ??\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint bits = 0;\n\t\tfor(int y=0 ; y < 4 ; y++ ){\n\t\t\tfor(int x=0 ; x < 4 ; x++ ){\n\t\t\t\tif( v[i].ly <= y && y <= v[i].ry && v[i].lx <= x && x <= v[i].rx ){\n\t\t\t\t\tbits = (bits << 1) + 1;\n\t\t\t\t}else{\n\t\t\t\t\tbits = bits << 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tS.push_back( bits );\n\t}\n}\n\nint main(){\n\tinit();\n\t\n\tint N;\n\tcin >> N;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tcheck_stamp(w, h);\n\t}\n\tfor(int y=0 ; y < 4 ; y++ ){\n\t\tcin >> C[y];\n\t}\n\tmake_stamp();\n\t\n\tint ans = solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint N;\nint H[20],W[20];\nstring S[5];\nint can[5][5][5][5];\nint bit[5][5][5][5][5];\nint fil[5][5][5][5];\nstring ord = \"RGB\";\nint dis[POW(16)+10];\n\nint calc(int x) {\n  if (IN(x,0,3)) return x;\n  if (x < 0) return 0;\n  return 3;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> N;\n  REP(i,N) cin >> H[i] >> W[i];\n  REP(i,4) cin >> S[i];\n  REP(k,N) {\n    for (int y = -3; y <= 3; y++) {\n      for (int x = -3; x <= 3; x++) {\n        int L = calc(x);\n        int R = calc(x+W[k]-1);\n        int U = calc(y);\n        int D = calc(y+H[k]-1);\n        can[U][L][D][R] = 1;\n        REP(c,3) {\n          int tmp = 0;\n          REP(i,H[k]) REP(j,W[k]) {\n            if (IN(y+i,0,3) && IN(x+j,0,3)) {\n              if (S[y+i][x+j] == ord[c]) {\n                tmp |= POW((y+i)*4+(x+j));\n              }\n            }\n          }\n          bit[U][L][D][R][c] = tmp;\n        }\n      }\n    }\n  }\n  REP(i,4) REP(j,4) FOR(k,i,4) FOR(l,j,4) {\n    REP(x,16) {\n      int add = 0;\n      if (x < i*4) add = 1;\n      else if (x >= (k+1)*4) add = 1;\n      else if (x%4 < j) add = 1;\n      else if (x%4 > l) add = 1;\n      if (add) fil[i][j][k][l] |= POW(x);\n    }\n  }\n  MINF(dis);\n  dis[0] = 0;\n  queue<int> que;\n  que.emplace(0);\n  while (!que.empty()) {\n    int mask = que.front(); que.pop();\n    REP(i,4) REP(j,4) FOR(k,i,4) FOR(l,j,4) if (can[i][j][k][l]) {\n      REP(c,3) {\n        int nmask = (mask & fil[i][j][k][l]) | bit[i][j][k][l][c];\n        if (dis[nmask] == INF) {\n          dis[nmask] = dis[mask] + 1;\n          que.emplace(nmask);\n        }\n      }\n    }\n  }\n  cout << dis[POW(16)-1] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[17][1<<16];\nint main(){\n  int n,h[16],w[16];\n  char r[3]={'R','G','B'};\n  string c[4];\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>h[i]>>w[i];\n  for(int i=0;i<4;i++)cin>>c[i];\n  dp[0][0]=1;\n  for(int j=0;j<16;j++)\n    for(int i=0;i<1<<16;i++)\n      if(dp[j][i])\n\tfor(int k=0;k<n;k++)\n\t  for(int cl=0;cl<3;cl++)\n\t    for(int y=-h[k]+1;y<4;y++)\n\t      for(int x=-w[k]+1;x<4;x++){\n\t\tint ni=i;\n\t\tfor(int l=max(0,y);l<min(4,y+h[k]);l++)\n\t\t  for(int m=max(0,x);m<min(4,x+w[k]);m++){\n\t\t    int xx=l*4+m;\n\t\t    if(c[l][m]==r[cl])ni|=(1<<xx);\n\t\t    else if(ni&(1<<xx))ni-=(1<<xx);\n\t\t  }\n\t    dp[j+1][ni]=1;\n\t    if(ni==(1<<16)-1){cout<<j+1<<endl;return 0;}\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint n;\nstring s[4];\nint h[20],w[20];\nint dp[1<<16];\n\npriority_queue<pa,vector<pa>,greater<pa>> pq;   \n\n   signed main(){\ncin>>n;\n   \tfor(int i=0;i<n;i++)cin>>h[i]>>w[i];\n   \tfor(int i=0;i<(1<<16);i++)dp[i]=-1;\n   \tfor(int i=0;i<4;i++)cin>>s[i];\n   \tstring ss=\"RBG\";\n   \t\n   \tpq.push(mp(0,0));\n   \twhile(pq.size()>0){\n   \t\tpa z=pq.top();\n   \t\tpq.pop();\n   \t\tif(dp[z.second]>=0) continue;\n   \t\tdp[z.second]=z.first;\n   \t\tif(z.second+1==(1<<16)){\n   \t\tcout<<z.first<<endl;\n   \t\t\treturn 0;\n   \t\t}\n   \t//\tif(z.first==1)\tcout<<bitset<16>(z.second)<<\" \"<<z.first <<endl;\n   \t\tfor(int k=0;k<n;k++){\n   \t\t\tfor(auto c:ss)for(int i=1-h[k];i<4;i++)for(int j=1-w[k];j<4;j++){\n   \t\t\t\tint bit=z.second;\n   \t\t\t\tfor(int x=max(i,0ll);x<min(i+h[k],4ll);x++)for(int y=max(j,0ll);y<min(j+w[k],4ll);y++){\n   \t\t\t\t\tif(s[x][y]==c) bit=bit|(1<<((y)*4+x));\n   \t\t\t\t\telse if(bit&((1<<((y)*4+x)))) bit -= (1<<((y)*4+x));\n   \t\t\t\t}\n   \t\t\t\tif(dp[bit]<0)\tpq.push(mp(z.first+1,bit));\n   \t\t\t}\n   \t\t}\n   \t}\n   \t\n   \t\n   \tcout<<dp[(1<<16)-1]<<endl;\n   \t\n   \t\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\nint H[20], W[20];\nint dp[1 << 16];\nvector<string> board;\nconst string alph = \"RGB\";\n\nint solve() {\n    queue<int> q; q.push(0);\n    while(!q.empty()) {\n        int bit = q.front(); q.pop();\n        if(bit == (1 << 16) - 1) return dp[bit];\n        // i ????????????????????????????????? (j, k) ?????????????????? s ??§??????\n        rep(i,0,N) rep(j,-H[i]+1,4) rep(k,-W[i]+1,4) rep(s,0,3) {\n            int nbit = bit;\n            rep(x, max(j,0LL), min(j+H[i],4LL)) rep(y, max(k,0LL), min(k+W[i],4LL)) {\n                int idx = x * 4 + y;\n                if(board[x][y] == alph[s]) nbit |= (1 << idx);\n                else if(nbit >> idx & 1) nbit ^= (1 << idx);\n            }\n            if(dp[nbit] < 0) {\n                dp[nbit] = dp[bit] + 1;\n                q.push(nbit);\n            }\n        }\n    }\n    return 0;\n}\n\nsigned main() {\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n\n    cin >> N;\n    rep(i,0,N) cin >> H[i] >> W[i];\n    rep(i,0,4) {\n        string s; cin >> s;\n        board.push_back(s);\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,v=1<<16,i,j,k,l,a,b,x,y,z,bit,d;\n  cin>>n;\n  int h[n],w[n],dp[v],used[v];\n  for(i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(i=0;i<n;i++)\n      for(j=-h[i]+1;j<4;j++)\n\tfor(k=-w[i]+1;k<4;k++)\n\t  for(l=0;l<3;l++){\n\t    for(z=bit,a=max(0,-j);a<min(h[i],4-j);a++)\n\t      for(b=max(0,-k);b<min(w[i],4-k);b++){\n\t\ty=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=v-1-(1<<(y*4+x));\n\t      }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[v-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a, b; vector<int> x, y; string tmp;\n\nmap<unsigned, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tunsigned finish = 0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tswitch (tmp[j])\n\t\t\t{\n\t\t\tcase 'R': finish += (1 << (i * 8 + j * 2)) * 1; break;\n\t\t\tcase 'G': finish += (1 << (i * 8 + j * 2)) * 2; break;\n\t\t\tcase 'B': finish += (1 << (i * 8 + j * 2)) * 3; break;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<unsigned, int> > que;\n\n\tque.push(make_pair(0, 0)); D[0] = true;\n\n\twhile (true)\n\t{\n\t\tunsigned M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (finish == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < 3; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tM2 -= (M2 / (1 << (l * 8 + m * 2))) % 4;\n\t\t\t\t\t\t\t\tM2 += (1 << (l * 8 + m * 2));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define fi first\n#define se second\nusing pii = pair<int,int>;\n\nint table[4][4];\n\nbool inside(int a, int b){\n\treturn 0<=a&&a<4&&0<=b&&b<4;\n}\n\nint calc(vector<vector<int>> vv){\n\tint state = 0;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tif(vv[i][j]){\n\t\t\t\tstate += 1<<(i*4+j);\n\t\t\t}\n\t\t}\n\t}\n\treturn state;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\tvector<pair<pii,pii>> w;\n\tint dx[] = {1,1,-1,-1};\n\tint dy[] = {1,-1,1,-1};\n\trep(i,4){\n\t\trep(j,4){\n\t\t\trep(k,n){\n\t\t\t\trep(l,4){\n\t\t\t\t\tpii lu(i,j);\n\t\t\t\t\tpii rd(max(0,min(i+dx[l]*(v[k].fi-1), 3)), max(0,min(j+dy[l]*(v[k].se-1), 3)));\n\t\t\t\t\tw.push_back(minmax(lu,rd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\tsort(w.begin(), w.end());\n\tw.erase(unique(w.begin(), w.end()), w.end());\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\trep(k,3){\n\t\t\t\tif(t == \"RGB\"[k]){\n\t\t\t\t\ttable[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dp(1<<16,1e9);\n\tdp[0] = 0;\n\trep(i,1<<16){\n\t\tif(dp[i]>1e8) continue;\n\t\tvector<vector<int>> vv(4,vector<int>(4));\n\t\trep(j,16){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tvv[j/4][j%4] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto x: w){\n\t\t\tbool ok = true;\n\t\t\tint color = -1;\n\t\t\treep(k,x.fi.fi, x.se.fi+1){\n\t\t\t\treep(l,x.fi.se, x.se.se+1){\n\t\t\t\t\tif(vv[k][l]==0){\n\t\t\t\t\t\tif(color == -1) color = table[k][l];\n\t\t\t\t\t\telse if(color != table[k][l]) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\t// auto tmp = vv;\n\t\t\t\tint tmp = i;\n\t\t\t\treep(k,x.fi.fi, x.se.fi+1){\n\t\t\t\t\treep(l,x.fi.se, x.se.se+1){\n\t\t\t\t\t\tif(vv[k][l]==0){\n\t\t\t\t\t\t\ttmp += 1<<((k)*4+l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[tmp] = min(dp[tmp], dp[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint N, X[16], Y[16]; string M[4], start[4];\n\n\tconst string color = \"RGB\";\n\n\tcin >> N;\n\n\tfor (int i = 0; i < N; i++) { cin >> X[i] >> Y[i]; }\n\n\tfor (int i = 0; i < 4; i++) { cin >> M[i]; }\n\n\tqueue<string> que[4];\n\n\tqueue<int> turn; turn.push(0);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tque[i].push(\"WWWW\");\n\t}\n\n\twhile (!que[0].empty())\n\t{\n\t\tstring S[4]; int turn1 = turn.front(); turn.pop();\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tS[i] = que[i].front(); que[i].pop();\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < 3; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring S2[4];\n\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tS2[m] = S[m];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int m = i; m < min(i + Y[k], 4); m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int n = j; n < min(j + X[k], 4); n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tS2[m][n] = color[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool ok = true;\n\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (S2[m] != M[m])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ok == true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout << turn1 + 1 << endl; goto Exit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque[m].push(S2[m]);\n\n\t\t\t\t\t\t\tturn.push(turn1 + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar Color[3] = {'R', 'G', 'B'};\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> h(n);\n    vector<int> w(n);\n    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];\n    string C;\n    for(int i = 0; i < 4; i++){\n        string tmp; cin >> tmp;\n        C = C + tmp;\n    }\n\n    queue<pair<int, int> > que;                  //cost bit(一致していたら1そうでなければ0)\n    set<int> st;\n    st.insert(0);\n    que.push({0, 0});\n\n    while(!que.empty()){\n        int bit = que.front().second;\n        int cost = que.front().first;\n        cout << cost << \" \" << bitset<16>(bit) << endl;\n        \n        que.pop();\n\n        if(bit == (1 << 16) - 1){\n            cout << cost << endl;\n            break;\n        }\n\n        for(int ii = 0; ii < n; ii++){\n\n            for(char color : Color){\n                \n                //cout << i << \" \" << color << endl;\n                for(int si = -h[ii] + 1; si <= 3; si++){\n                    for(int sj = -w[ii] + 1; sj <= 3; sj++){\n                        \n                        int gi = si + h[ii] - 1;\n                        int gj = sj + w[ii] - 1;\n                        if(gi < 0 || gj < 0) continue;\n\n                        if(gi >= 4) gi = 3;\n                        if(gj >= 4) gj = 3; \n                        //cout << si << \" \" << gi << \" \" << sj << \" \" << gj << \" \" << endl;\n                        //assert(si <= gi);\n                        int next = bit;\n                        for(int i = si; i <= gi; i++){\n                            for(int j = sj; j <= gj; j++){\n\n                                if(0 <= i && i < 4 && 0 <= j && j < 4){\n                                    int idx = i * 4 + j;\n                                    if(C[idx] == color) next = next | (1 << idx);\n                                    else next = next & ~(1 << idx);\n                                }\n                            }\n\n                        }\n\n                        if(st.find(next) == st.end()){\n                            //cout << \"ok\" << endl;\n                            st.insert(next);\n                            que.push({cost + 1, next});\n\n                            //cout << \"push \" << cost + 1 << \" \" << bitset<16>(next) << endl;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)],A[N];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=A[p];\n\t  else if(nS&A[p]) nS=nS&~A[p];\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n\n  for(int i=0;i<N;i++) A[i]=(1<<i);\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\nll compute_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') type = 1;\n      if(stage[y][x] == 'G') type = 2;\n      if(stage[y][x] == 'B') type = 3;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n  return res;\n}\n\nvoid hash2stage(ll hash){\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = hash % 4LL;\n      if(type == 0) stage[y][x] = '.';\n      if(type == 1) stage[y][x] = 'R';\n      if(type == 2) stage[y][x] = 'G';\n      if(type == 3) stage[y][x] = 'B';\n      hash /= 4LL;\n    }\n  }\n}\n\nll compute_clear_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n\n  return res;\n}\n\nvoid print_stage(){\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\n\nclass State {\npublic:\n  ll _hash;\n  int _cost;\n  \n  State(ll hash,int cost) : _hash(hash), _cost(cost) {}\n  bool operator<(const State& s) const {\n    return _cost < s._cost;\n  }\n  bool operator>(const State& s) const {\n    return _cost > s._cost;\n  }\n};\n\nint bfs(){\n\n  priority_queue<State,vector<State>, greater<State> > que;\n  ll init = compute_hash();\n  ll goal = compute_clear_hash();\n  que.push(State(init,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s._hash == goal) return s._cost;\n    hash2stage(s._hash);\n\n    for(int ly=0;ly<4;ly++){\n      for(int lx=0;lx<4;lx++){\n        for(int ry=ly;ry<4;ry++){\n          for(int rx=lx;rx<4;rx++){\n            //corner\n            if((lx == 0 && ly == 0)\n               || (lx == 0 && ly == 3)\n               || (rx == 3 && ry == 3)\n               || (rx == 3 && ry == 0)){\n              if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //left or right\n            else if(lx == 0 || rx == 3){\n              if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //top or bottom\n            else if(ly == 0 || ry == 3){\n              if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //center\n            else {\n              if(has_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return INF;\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\n\nvoid Min(int &a,int b){a=min(a,b);}\nint Idx(int y,int x){return y*4+x;}\n\nint nbit(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\n\nint DP(){\n  vector<int>dp(1<<16,INF);\n  dp[0]=0;\n  for(int bit=0;bit<(1<<16);bit++){\n\n    for(int i=0;i<3;i++)\n      for(int a=0;a<16;a++)\n\tfor(int b=0;b<16;b++)\n\t  if(can[a][b]){\n\t    data yx=(data){a/4,a%4};\n\t    data YX=(data){b/4,b%4};\n\t    Min(dp[nbit(bit,yx,YX,RGB[i])],dp[bit]+1);\n\t  }\n  }\n  return dp[(1<<16)-1];\n}\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvi dp(1<<16,inf);\nvp w;\nint main(){\n\tint n;\n\tcin>>n;\n\tvp in(n);\n\trep(i,n)cin>>in[i].first>>in[i].second;\n\tvs s(4);\n\trep(i,4)cin>>s[i];\n\tchar c[3]={'R','G','B'};\n\trep(i,n)loop(j,-4,4)loop(k,-4,4)rep(l,3){\n\t\tint t=0,tt=0;\n\t\trep(x,in[i].first)rep(y,in[i].second)if(0<=j+x&&0<=k+y&&j+x<4&&k+y<4){\n\t\t\ttt|=1<<((j+x)*4+k+y);\n\t\t\tif(s[j+x][k+y]==c[l])\n\t\t\t\tt|=1<<((j+x)*4+k+y);\n\t\t}\n\t\tw.pb({tt,t});\n//\t\tcout<<bitset<16>(t)<<\" \"<<bitset<16>(tt)<<endl;\n\t}\n\tdp[0]=0;\n\tqueue<pii>que;\n\tque.push({0,0});\n\twhile(que.size()){\n\t\tpii q=que.front();\n\t\tint a=q.first;\n\t\tque.pop();\n\t\tif(dp[a]<q.second)continue;\n\t\trep(i,w.size()){\n\t\t\tint t=(a&(~w[i].first))|w[i].second;\n\t\t\tif(dp[t]>dp[a]+1){\n\t\t\t\tdp[t]=dp[a]+1;\n\t\t\t\tque.push({t,dp[t]});\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst char of[] = \"RGB\";\n\nint N, H[20], W[20];\nchar f[4][4];\nint Qi, Qn, Q[65536], dp[65536];\nint m, mask[1000], chg[256][4];\n\nint main() {\n    scanf(\"%d\", &N);\n    rep(i, N) scanf(\"%d%d\", H+i, W+i);\n    rep(i, 4) rep(j, 4) scanf(\" %c\", f[i]+j);\n    rep(k, N) for(int i=-3; i<4; i++) for(int j=-3; j<4; j++) {\n        int b = 0;\n        const int xmx = i+H[k], ymx=j+W[k];\n        for(int x=max(i, 0); x<xmx; x++) {\n            for(int y=max(j, 0); y<ymx; y++) {\n                b |= 1<<(x*4+y);\n            }\n        }\n        mask[m++] = b;\n    }\n    sort(mask, mask+m);\n    m = unique(mask, mask+m)-mask;\n    rep(i, m) rep(x, 4) rep(y, 4) if(mask[i]&(1<<(x*4+y))) {\n        rep(k, 3) if(f[x][y]==of[k]) chg[i][k] |= 1<<(x*4+y);\n    }\n    rep(i, m) mask[i] = ~mask[i];\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    Q[Qn++] = 0;\n    while(Qi<Qn && dp[65535]==-1) {\n        const int cur = Q[Qi++];\n        rep(i, m) rep(k, 3) {\n            const int nxt = (cur&mask[i]) | chg[i][k];\n            if(dp[nxt]==-1) {\n                dp[nxt] = dp[cur]+1;\n                Q[Qn++] = nxt;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[65535]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nset<int> stamp;\nvector<int> tar(3);\nset<int> exist;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tREP(l, h + 3)\n\t\t\tREP(m, w + 3) {\n\t\t\tint add = 0;\n\t\t\tREP(k, h)\n\t\t\t\tREP(j, w) {\n\t\t\t\tint y = l - h + 1 + k;\n\t\t\t\tint x = m - w + 1 + j;\n\t\t\t\tif (0 <= y&&y <= 3 && 0 <= x&&x <= 3) {\n\t\t\t\t\tadd |= 1 << (y * 4 + x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstamp.insert(add);\n\t\t}\n\t}\n\tREP(i, 4) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j, 4) {\n\t\t\tif (s[j] == 'R')\n\t\t\t\ttar[0] |= 1 << (i * 4 + j);\n\t\t\tif (s[j] == 'G')\n\t\t\t\ttar[1] |= 1 << (i * 4 + j);\n\t\t\tif (s[j] == 'B')\n\t\t\t\ttar[2] |= 1 << (i * 4 + j);\n\t\t}\n\t}\n\texist.insert(0);\n\tqueue<pii> Q;\n\tQ.push({ 0,0 });\n\tint ans = 17;\n\twhile (!Q.empty()) {\n\t\tpii state = Q.front();\n\t\tQ.pop();\n\t\tif (state.first == (1 << 16) - 1) {\n\t\t\tans = min(ans, state.second);\n\t\t\tbreak;\n\t\t}\n\t\tfor (auto x : stamp) {\n\t\t\tREP(w, 3) {\n\t\t\t\tint copy = state.first;\n\t\t\t\tcopy = copy&(((1 << 16) - 1) - x);\n\t\t\t\tcopy |= x&tar[w];\n\t\t\t\tif (exist.find(copy) == exist.end()) {\n\t\t\t\t\texist.insert(copy);\n\t\t\t\t\tQ.push({ copy, state.second + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2297&lang=jp\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint N;\nvector<vector<int>> st;\nvector<pii> rec;\nint b1[16][3][55];\nint b2[16][3][55];\n\nvoid stamp_stete_check() {\n\tfor (int n = 0; n < N;n++) {\n\t\tcout << \"[\" << rec[n].first << \",\" << rec[n].second << \"]\" << endl;\n\t\tfor (int i = 0; i < st[n].size();i++) {\n\t\t\tfor (int j = 0; j < 16;j++) {\n\t\t\t\tif (j % 4 == 0) cout << endl;\n\t\t\t\tif (st[n][i] & (1 << j)) {\n\t\t\t\t\tcout << \"o\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"x\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tcin >> N;\n\trec.resize(N);\n\tst.resize(N);\n\tfor (int n = 0; n < N;n++) {\n\t\tint H, W; cin >> H >> W;\n\t\trec[n] = { H,W };\n\t\tfor (int i = -3; i < 4;i++) {\n\t\t\tfor (int j = -3; j < 4;j++) {\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int h = max(0,i); h < min(4, i + H);h++) {\n\t\t\t\t\tfor (int w = max(0,j); w < min(4, j + W);w++) {\n\t\t\t\t\t\ts += (1 << (4 * h + w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s == 0)continue;\n\t\t\t\tst[n].push_back(s);\n\t\t\t}\n\t\t}\n\t}\n\n\t// stamp_stete_check();\n\n\t/* Classification */\n\tvector<int> m(16);\n\tfor (int i = 0; i < 16;i++) {\n\t\tchar c; cin >> c;\n\t\tif (c == 'R') m[i] = 0;\n\t\telse if (c == 'G') m[i] = 1;\n\t\telse m[i] = 2;\n\t}\n\n\t/* Preprocessing */\n\tfor (int n = 0; n < N;n++) {\n\t\tfor (int c = 0; c < 3;c++) {\n\t\t\tfor (int i = 0; i < st[n].size();i++) {\n\t\t\t\tint B1, B2; B1 = B2 = 0;\n\t\t\t\tfor (int b = 0; b < 16;b++) {\n\t\t\t\t\tif (~st[n][i] & (1 << b)) continue;\n\t\t\t\t\tif (c == m[b]) {\n\t\t\t\t\t\tB1 += (1 << b);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tB2 += (1 << b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb1[n][c][i] = B1;\n\t\t\t\tb2[n][c][i] = B2;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* initialize */\n\tvector<int> memo(1 << 16, -1);\n\tqueue<int> q;\n\tq.push(0);\n\tmemo[0] = 0;\n\n\t/* bfs */\n\twhile (!q.empty()) {\n\t\tint n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 16;i++) {\n\t\t\tif (n & (1 << i))continue;\n\t\t\tint v = m[i];\n\t\t\tfor (int j = 0; j < N;j++) {\n\t\t\t\tfor (int k = 0; k < st[j].size(); k++) {\n\t\t\t\t\tif (~st[j][k] & (1 << i)) continue;\t\n\t\t\t\t\tint next = n;\n\n\t\t\t\t\tnext = next | b1[j][v][k];\n\t\t\t\t\tnext = next & ~b2[j][v][k];\n\n\t\t\t\t\tif (memo[next] != -1)continue;\n\t\t\t\t\tmemo[next] = memo[n] + 1;\n\t\t\t\t\tif (next == ((1 << 16) - 1)) {\n\t\t\t\t\t\tcout << memo[next] << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row1,int arg_row2,int arg_col1,int arg_col2){\n\t\trow1 = arg_row1;\n\t\trow2 = arg_row2;\n\t\tcol1 = arg_col1;\n\t\tcol2 = arg_col2;\n\t}\n\tint row1,row2,col1,col2;\n};\n\nstruct Data{\n\tbool table[4][4];\n\tint count;\n};\n\nbool can_stamp[4][4][4][4];\nbool check[65536];\nint POW[17];\n\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < POW[16]; i++)check[i] = false;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++)can_stamp[a][b][c][d] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint height,width;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&height,&width);\n\n\t\tfor(int row2 = 0; row2 <= 3; row2++){\n\t\t\tint row1 = max(0,row2-height+1);\n\n\t\t\tfor(int col2 = 0; col2 <= 3; col2++){\n\t\t\t\tint col1 = max(0,col2-width+1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\n\t\t\tfor(int col1 = 0; col1 <= 3; col1++){\n\t\t\t\tint col2 = min(3,col1+width-1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int row1 = 0; row1 <= 3; row1++){\n\t\t\tint row2 = min(3,row1+height-1);\n\n\t\t\tfor(int col2 = 0; col2 <= 3; col2++){\n\t\t\t\tint col1 = max(0,col2-width+1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\n\t\t\tfor(int col1 = 0; col1 <= 3; col1++){\n\t\t\t\tint col2 = min(3,col1+width-1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Info> V;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(can_stamp[a][b][c][d]){\n\t\t\t\t\t\tV.push_back(Info(a,b,c,d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tchar ans_table[4][5];\n\tfor(int row = 0; row < 4; row++){\n\t\tscanf(\"%s\",ans_table[row]);\n\t}\n\n\tData first;\n\tfirst.count = 0;\n\tfor(int row = 0; row < 4; row++){\n\t\tfor(int col = 0; col < 4; col++)first.table[row][col] = false;\n\t}\n\tcheck[0] = true;\n\n\tqueue<Data> Q;\n\tQ.push(first);\n\n\tbool FLG;\n\tchar base[4][4],work[4][4];\n\n\tint index,tmp_code;\n\n\tchar colors[3] = {'R','G','B'};\n\n\twhile(!Q.empty()){\n\n\t\tFLG = true;\n\t\tfor(int row = 0; row < 4; row++){\n\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\tif(Q.front().table[row][col] == false){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbase[row][col] = '@';\n\t\t\t\t}else{\n\t\t\t\t\tbase[row][col] = ans_table[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"%d\\n\",Q.front().count);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\n\t\t\tfor(int paint = 0; paint < 3; paint++){\n\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\twork[row][col] = base[row][col];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int row = V[i].row1; row <= V[i].row2; row++){\n\t\t\t\t\tfor(int col = V[i].col1; col <= V[i].col2; col++){\n\t\t\t\t\t\twork[row][col] = colors[paint];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tindex = 0,tmp_code = 0;\n\t\t\t\tData next_data;\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\tif(work[row][col] == ans_table[row][col]){\n\t\t\t\t\t\t\ttmp_code += POW[index];\n\t\t\t\t\t\t\tnext_data.table[row][col] = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_data.table[row][col] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(check[tmp_code])continue;\n\n\t\t\t\tcheck[tmp_code] = true;\n\t\t\t\tnext_data.count = Q.front().count+1;\n\t\t\t\tQ.push(next_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  memset(dp,-1,sizeof(dp));\n  int a[4][4];\n  r(i,4)r(j,4)a[i][j]=(i*4+j);\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=0;\n  queue<int>q;\n  q.push(0);\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  q.push(0);\n  r(i,4)for(int j=3;j>=0;j--)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  for(int i=3;i>=0;i--)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());int rs=0;\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    int xx=p;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<dp[p]<<endl;\n      return 0;\n    }\n    int xp=0;\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)xp|=(1<<a[i][j]);\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        int tp=xp;\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            if(ccol[col]==s[i][j])tp|=(1<<a[i][j]);\n            else if((tp>>a[i][j])&1)tp-=(1<<a[i][j]);\n          }\n        }\n        if(dp[tp]==-1){rs++;\n          dp[tp]=dp[xx]+1;\n          q.push(tp);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4];\n\t\t\telse F[i / 4][i % 4] = 0;\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = -2; j <= 3; j++) {\n\t\t\t\tfor (int k = -2; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint L[4][4]; for (int l = 0; l < 16; l++)L[l >> 2][l & 3] = F[l >> 2][l & 3];\n\t\t\t\t\t\tfor (int l = 0; l < x[i].first; l++) {\n\t\t\t\t\t\t\tfor (int m = 0; m < x[i].second; m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m;\n\t\t\t\t\t\t\t\tif (cx < 0 || cy < 0 || cx >= 4 || cy >= 4)continue;\n\t\t\t\t\t\t\t\tif (L[cx][cy] >= 1 && col[cx][cy] != o) { L[cx][cy] = 0; }\n\t\t\t\t\t\t\t\telse if (L[cx][cy] == 0 && col[cx][cy] == o) { L[cx][cy] = o; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = 0;\n\t\t\t\t\t\tfor (int l = 0; l < 16; l++) { if (L[l >> 2][l & 3] >= 1)bits += (1 << l); }\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint n;\nint x[16], y[16];\nbool used[1 << 16];\nint ans[1 << 16];\nchar t[4][4];\nint dfs(int s) {\n\tif (s == 0)return 0;\n\tif (used[s])return ans[s];\n\tused[s] = true;\n\tint mp[4][4] = {};\n\trep(j, 16) {\n\t\tif (s&(1 << j)) {\n\t\t\tmp[j / 4][j % 4] = 1;\n\t\t}\n\t}\n\tint ret = mod;\n\trep(i, 16) {\n\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\tfor (int k = -3; k <= 3; k++) {\n\n\t\t\t\tint cs = s;\n\t\t\t\tchar u = '?'; bool valid = true;\n\t\t\t\tfor (int l1 = j; l1 < j + x[i]; l1++) {\n\t\t\t\t\tif (l1 < 0 || l1 >= 4)continue;\n\t\t\t\t\tfor (int l2 = k; l2 < k + y[i]; l2++) {\n\t\t\t\t\t\tif (l2 < 0 || l2 >= 4)continue;\n\t\t\t\t\t\tif (!mp[l1][l2])continue;\n\t\t\t\t\t\tif (u == '?')u = t[l1][l2];\n\t\t\t\t\t\telse if (u != t[l1][l2])valid = false;\n\t\t\t\t\t\tint z = l1 * 4 + l2;\n\t\t\t\t\t\tcs ^= (1<<z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!valid)continue;\n\t\t\t\tif (s == cs)continue;\n\t\t\t\tret = min(ret, dfs(cs));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans[s] = ret + 1;\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, 4) {\n\t\trep(j, 4) {\n\t\t\tcin >> t[i][j];\n\t\t}\n\t}\n\tcout << dfs(65535) << endl;\n\t//cout << ans[65535] << endl;\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing pii=pair<int,int>;\nusing ppp=pair<pii,pii>;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> h(n),w(n);\n    for(int i=0;i<n;i++){\n        cin>>h[i]>>w[i];\n    }\n    vector<string> c(4);\n    for(int i=0;i<4;i++) cin>>c[i];\n    vector<vector<int>> tar(4,vector<int>(4));\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(c[i][j]=='R') tar[i][j]=0;\n            if(c[i][j]=='G') tar[i][j]=1;\n            if(c[i][j]=='B') tar[i][j]=2;\n        }\n    }\n    set<ppp> s;\n    for(int k=0;k<n;k++){\n        for(int i=-3;i<4;i++){\n            for(int j=-3;j<4;j++){\n                int u=max(i,0);\n                int b=min(4,i+h[k]);\n                int l=max(j,0);\n                int r=min(4,j+w[k]);\n                if(u!=b && l!=r) s.insert(ppp(pii(u,b),pii(l,r)));\n            }\n        }\n    }\n\n    vector<ppp> stamp(s.begin(),s.end());\n    const int INF=1e8;\n    vector<int> d(1<<16,INF);\n    d[0]=0;\n\n    queue<int> que;\n    que.push(0);\n\n    while(!que.empty()){\n        int st=que.front(); que.pop();\n        for(int k=0;k<stamp.size();k++){\n            int u=stamp[k].first.first,b=stamp[k].first.second;\n            int l=stamp[k].second.first,r=stamp[k].second.second;\n            for(int c=0;c<3;c++){\n                int to=st;\n                for(int i=u;i<b;i++){\n                    for(int j=l;j<r;j++){\n                        int pos=i*4+j;\n                        if(tar[i][j]!=c){\n                            to&=(~(1<<pos));\n                        }\n                        else{\n                            to|=(1<<pos);\n                        }\n                    }\n                }\n                if(d[st]+1<d[to]){\n                    d[to]=d[st]+1;\n                    que.push(to);\n                }\n            }\n        }\n    }\n    cout<<d[(1<<16)-1]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint i,j,n,m,K;cin>>n;\n\tvector<pair<int,int>>sta(n);\n\tfor(i=0;i<n;i++){cin>>sta[i].fir>>sta[i].sec;}\n\tstatic int dis[65536];\n\tfor(int bi=0;bi<(1<<16);bi++){dis[bi]=99999;}\n\tdis[0]=0;\n\tqueue<int>que;que.push(0);\n\tstring kan[4];cin>>kan[0]>>kan[1]>>kan[2]>>kan[3];\n\tstring RBG=\"RBG\";\n\twhile(que.size()){\n\t\tint pta=que.front();que.pop();\n\t\tint time=dis[pta];\n\t\t//cerr<<pta<<\" \"<<time<<endl;\n\t\tfor(char c:RBG){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tint h=sta[j].fir,w=sta[j].sec;\n\t\t\t\tfor(int y=-h+1;y<=3;y++){\n\t\t\t\t\tfor(int x=-w+1;x<=3;x++){\n\t\t\t\t\t\tint aaa=pta;\n\t\t\t\t\t\tfor(int ny=y;ny<y+h;ny++){\n\t\t\t\t\t\t\tfor(int nx=x;nx<x+w;nx++){\n\t\t\t\t\t\t\t\tif(ny<0||nx<0||ny>=4||nx>=4){continue;}\n\t\t\t\t\t\t\t\taaa|=(1<<(ny*4+nx));\n\t\t\t\t\t\t\t\tif(kan[ny][nx]!=c){aaa-=(1<<(ny*4+nx));}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(mineq(dis[aaa],time+1)){que.push(aaa);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dis[65535]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\nint N;\nvector<int> H, W;\n//vector<vector<bool>> st(4, vector<bool>(4)); //can put kukei\nbool st[4][4][4][4]; // (sh, sw) ~ (th, tw)を押せるかどうか\nvector<string> C(4);\n//string C[4];\nvi dp(1 << 16, -1);\n\nint conv(int h, int w) {\n    return 4 * h + w;\n}\n\nvoid print_state(int n) {\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cout << (n >> (conv(i, j)) & 1);\n        }\n        cout << endl;\n    }\n    cout << \"----------\" << endl;\n}\n\nint rec(int mask) {\n//    print_state(mask);\n    if (mask == (1 << 16) - 1) {\n        return 0;\n    }\n\n    int &ret = dp[mask];\n    if (ret != -1) return ret;\n\n    ret = INF;\n\n    FOR(sh, 0, 4) {\n        FOR(sw, 0, 4) {\n            FOR(th, sh, 4) {\n                FOR(tw, sw, 4) {\n                    int nmask = mask;\n                    set<char> set;\n                    if (st[sh][sw][th][tw]) {\n                        FOR(s, sh, th + 1) {\n                            FOR(w, sw, tw + 1) {\n                                if (!(mask >> conv(s, w) & 1)) {\n                                    nmask |= 1 << (conv(s, w));\n                                    set.insert(C[s][w]);\n                                }\n                            }\n                        }\n                    }\n                    if (set.size() == 1 && nmask != mask) {\n                        int tmp = rec(nmask) + 1;\n                        chmin(ret, tmp);\n                    }\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\n\nvoid solve() {\n    cin >> N;\n    REP(i, N) {\n        int h, w;\n        cin >> h >> w;\n        H.push_back(h);\n        W.push_back(w);\n\n    }\n\n//    C.resize(4);\n    REP(i, 4) {\n        cin >> C[i];\n    }\n//    cout << C << endl;\n\n    for (int sh = -3; sh <= 3; ++sh) {\n        for (int sw = -3; sw <= 3; ++sw) {\n//            if (sh == 2 && sw == 2) {\n//                int ushi = 13;\n//            }\n            for (int i = 0; i < N; ++i) {\n                int th = sh + H[i] - 1;\n                int tw = sw + W[i] - 1;\n\n                int sh2 = max(0, sh);\n                int sw2 = max(0, sw);\n                int th2 = min(th, 3);\n                int tw2 = min(tw, 3);\n                if (th2 < 0 || tw2 < 0) continue;\n\n//                cout << make_pair(P(sh2, sw2), P(th2, tw2)) << endl;\n\n                st[sh2][sw2][th2][tw2] = true;\n            }\n        }\n    }\n\n    int ans = rec(0);\n    cout << ans << endl;\n\n\n}\n\n\nint main() {\n//    cin.tie(0);\n//    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\n\tint ny=y-i+k;\n\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(__builtin_popcount(S)>__builtin_popcount(nS)) continue;\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int g,h,i,j,k,l,m;\n  int n;\n  cin>>n;\n  int y[16],x[16];\n  for(i=0;i<n;++i)\n    cin>>y[i]>>x[i];\n  int a[4][4];\n  for(i=0;i<4;++i){\n    for(j=0;j<4;++j){\n      char s;\n      cin>>s;\n      if(0){\n      }else if(s=='R'){\n\ta[i][j]=1;\n      }else if(s=='G'){\n\ta[i][j]=2;\n      }else if(s=='B'){\n\ta[i][j]=3;\n\n      }\n    }\n  }\n  vector<pair<int,int> > b;\n  b.reserve(300);\n  for(i=0;i<4;++i){\n    for(j=0;j<4;++j){\n      for(k=i;k<4;++k){\n\tfor(l=j;l<4;++l){\n\t  for(m=0;m<n;++m){\n\t    if(0){\n\t    }else if((i==0||k==3)&&(j==0||l==3)){\n\t      if(k-i+1<=y[m]&&l-j+1<=x[m])\n\t\tbreak;\n\t    }else if(i==0||k==3){\n\t      if(k-i+1<=y[m]&&l-j+1==x[m])\n\t\tbreak;\n\t    }else if(j==0||l==3){\n\t      if(k-i+1==y[m]&&l-j+1<=x[m])\n\t\tbreak;\n\t    }else{\n\t      if(k-i+1==y[m]&&l-j+1==x[m])\n\t\tbreak;\n\t    }\n\t  }\n\t  if(m==n)\n\t    continue;\n\t  for(m=0;m<3;++m){\n\t    int p=0,q=0,r=0;\n\t    for(g=0;g<4;++g){\n\t      for(h=0;h<4;++h){\n\t\tif(i<=g&&g<=k&&j<=h&&h<=l){\n\t\t  p|=1;\n\t\t  if(a[g][h]==m+1){\n\t\t    q|=1;\n\t\t    r=-1;\n\t\t  }\n\t\t}\n\t\tif(g!=3||h!=3){\n\t\t  p<<=1;\n\t\t  q<<=1;\n\t\t}\n\t      }\n\t    }\n\t    if(!r)\n\t      continue;\n\t    p=~p;\n\t    b.push_back(make_pair(p,q));\n\t  }\n\t}\n      }\n    }\n  }\n  bool c[1<<16]={};\n  c[0]=true;\n  queue<pair<int,int> > d;\n  d.push(make_pair(0,0));\n  while(!d.empty()){\n    int p,q;\n    p=d.front().first;\n    q=d.front().second;\n    if(p==(~(-1<<16)))\n      break;\n    d.pop();\n    for(i=0;i<(int)b.size();++i){\n      int r=(p&b[i].first)|b[i].second;\n      if(c[r])\n\tcontinue;\n      c[r]=true;\n      d.push(make_pair(r,q+1));\n    }\n  }\n  cout<<d.front().second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nint n, h, w;\n\nint main()\n{\n\tcin >> n;\n\tvector<pii> v;\n\tREP(i, n)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\tv.emplace_back(a, b);\n\t}\n\tint fld[4][4];\n\tREP(i, 4)REP(j, 4)\n\t{\n\t\tchar c; cin >> c;\n\t\tif (c == 'R') fld[i][j] = 0;\n\t\telse if (c == 'G') fld[i][j] = 1;\n\t\telse fld[i][j] = 2;\n\t}\n\tvi d(1 << 16, INF);\n\td[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint t = que.front(); que.pop();\n\t\tif (t == (1 << 16) - 1)\n\t\t{\n\t\t\tcout << d[t] << endl;\n\t\t\tbreak;\n\t\t}\n\t\tREP(i, n)REP(j, 3)\n\t\t{\n\t\t\tint h = v[i].first, w = v[i].second;\n\t\t\tFOR(u, 1 - h, 4)FOR(l, 1 - w, 4)\n\t\t\t{\n\t\t\t\tint tmp = t;\n\t\t\t\tREP(dx, h)REP(dy, w)\n\t\t\t\t{\n\t\t\t\t\tint x = u + dx, y = l + dy;\n\t\t\t\t\tif (!valid(x, y, 4, 4)) continue;\n\t\t\t\t\tif (fld[x][y] == j)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp |= (1 << (x * 4 + y));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((tmp >> (x * 4 + y)) & 1) tmp ^= (1 << (x * 4 + y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d[tmp] == INF)\n\t\t\t\t{\n\t\t\t\t\td[tmp] = d[t] + 1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nmap< vector< vector<char> > , int> done;\nvector< vector<char> > goal(7,vector<char>(7));\nvector< vector<char> > good(8,vector<char>(8,0)) ;\n\nint w[20],h[20];\nint f(vector< vector<char> > &c){\n\tqueue< vector< vector<char> > > Q;\n\tQ.push(c);\n\tdone[c] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector< vector<char> > &q = Q.front(); Q.pop();\n\t\tint cost = done[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(x,7)rep(y,7){\n\t\t\trep(i,n){\n\t\t\t\trep(color,3){\n\t\t\t\t\tif( x < 3 || y < 3 || goal[y][x] == color){\n\t\t\t\t\t\tvector< vector<char> > t = c;\n\t\t\t\t\t\trep(j,h[i]){\n\t\t\t\t\t\t\trep(k,w[i]){\n\t\t\t\t\t\t\t\tint tx = x+k;\n\t\t\t\t\t\t\t\tint ty = y+j;\n\t\t\t\t\t\t\t\tif(tx >= 7 || ty >= 7 || tx < 3 || ty < 3 )continue;\n\t\t\t\t\t\t\t\tif(color == goal[ty][tx])t[ty][tx] = 1;\n\t\t\t\t\t\t\t\telse t[ty][tx] = 0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(done.find(t) == done.end()){\n\t\t\t\t\t\t\tdone[t] = cost + 1;\n\t\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tvector< vector<char> > init(8,vector<char>(8,0)) ;\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[3+i][3+j] = c;\n\t}\n\trep(i,4)rep(j,4) good[i+3][j+3] = 1;\n\t\n\tcout << f(0,init) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int col[4][4];\n    vector<int> h(n);\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> h[i] >> w[i];\n    }\n    for (int i = 0; i < 4; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 4; ++j) {\n            if (s[j] == 'R') col[i][j] = 0;\n            if (s[j] == 'G') col[i][j] = 1;\n            if (s[j] == 'B') col[i][j] = 2;\n        }\n    }\n    int match[4][5][4][5][3] = {};\n    int mask[4][5][4][5] = {};\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            for (int k = i + 1; k < 5; ++k) {\n                for (int l = j + 1; l < 5; ++l) {\n                    for (int r = i; r < k; ++r) {\n                        for (int s = j; s < l; ++s) {\n                            mask[i][j][k][l] |= 1 << r * 4 + s;\n                            match[i][j][k][l][col[r][s]] |= 1 << r * 4 + s;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int dp[1 << 16];\n    fill(dp, dp + (1 << 16), 32);\n    queue<int> q;\n    dp[0] = 0;\n    q.push(0);\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 1 - h[i]; j < 4; ++j) {\n                int m1 = max(j, 0), m3 = min(j + h[i], 4);\n                for (int k = 1 - w[i]; k < 4; ++k) {\n                    int m2 = max(k, 0), m4 = min(k + w[i], 4);\n                    for (int c = 0; c < 3; ++c) {\n                        int t = (p & ~mask[m1][m2][m3][m4]) | match[m1][m2][m3][m4][c];\n                        if (dp[t] > dp[p] + 1) {\n                            dp[t] = dp[p] + 1;\n                            if (t == (1 << 16) - 1)\n                            {\n                                cout << dp[t] << \"\\n\";\n                                return 0;\n                            }\n                            q.push(t);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> H(N), W(N);\n  REP(i, 0, N) cin >> H[i] >> W[i];\n  char S[4][4];\n  REP(i, 0, 4) REP(j, 0, 4) cin >> S[i][j];\n\n  vector<ll> dp(1LL << 16, -1);\n  queue<ll> q;\n  q.push(0);\n  dp[0] = 0;\n  while(q.size()) {\n    ll s = q.front();\n    q.pop();\n\n    REP(i, 0, N) {\n      REP(py, -H[i] + 1, 4) REP(px, -W[i] + 1, 4) REP(c, 0, 3) {\n        ll n = s;\n        REP(y, max(py, 0LL), min(py + H[i], 4LL)) REP(x, max(px, 0LL), min(px + W[i], 4LL)) {\n          const string Z = \"RGB\";\n          if(S[y][x] == Z[c]) n = n | (1LL << (y * 4 + x));\n          else n = ~(~n | (1LL << (y * 4 + x)));\n        }\n        if(dp[n] == -1) {\n          dp[n] = dp[s] + 1;\n          q.push(n);\n          if(n == (1LL << 16) - 1) {\n            cout << dp[(1LL << 16) - 1] << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\nbool rect[4][4][4][4];\n\nconst int V = 1 << 16;\nvector<int> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tif(dist[G[u][i]] < inf) continue;\n\t\t\tdist[G[u][i]] = dist[u] + 1;\n\t\t\tQ.push(G[u][i]);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\trect[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < N; j++){\n\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\trect[max(x, 0)][min(x+W[j],4)-1][max(y, 0)][min(y+H[j],4)-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tnext = i;\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tfor(int q = 0; q < 4; q++){\n\t\t\t\t\tfor(int r = 0; r < 4; r++){\n\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\tif(!rect[p][q][r][s]) continue;\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tfor(int dx = p; dx <= q; dx++){\n\t\t\t\t\t\t\t\tfor(int dy = r; dy <= s; dy++){\n\t\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tG[i].push_back(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint H[20], W[20];\nstring S[5];\nint field[5][5];\nint dist[1 << 17];\nbool chmin(int &a, int b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint f(int nowbit, int stamp, int h, int w, int color) {\n    int ans = nowbit;\n    for(int dh = 0; dh < H[stamp]; dh++) {\n        int newh = h + dh;\n        if(newh < 0 || newh > 3) continue;\n        for(int dw = 0; dw < W[stamp]; dw++) {\n            int neww = w + dw;\n            if(neww < 0 || neww > 3) continue;\n            int grid = newh * 4 + neww;\n            if(field[newh][neww] == color) ans |= (1 << grid);\n            else ans &= ~(1 << grid);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n    for(int h = 0; h <= 3; h++) cin >> S[h];\n    for(int h = 0; h < 4; h++) {\n        for(int w = 0; w < 4; w++) {\n            if(S[h][w] == 'R') field[h][w] = 0;\n            if(S[h][w] == 'G') field[h][w] = 1;\n            if(S[h][w] == 'B') field[h][w] = 2;\n        }\n    }\n    for(int i = 0; i < (1 << 16); i++) dist[i] = INF;\n    dist[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()) {\n        int nowbit = que.front();\n        //cerr << nowbit << \" \" << dist[nowbit] << endl;\n        //if(dist[nowbit] > 3) break;\n        if(dist[(1 << 16) - 1] != INF) break;\n        que.pop();\n        for(int stamp = 0; stamp < N; stamp++) {\n            for(int h = 1 - H[stamp]; h <= 3; h++) {\n                for(int w = 1 - W[stamp]; w <= 3; w++) {\n                    for(int color = 0; color <= 2; color++) {\n                        int newbit = f(nowbit, stamp, h, w, color);\n                        if(chmin(dist[newbit], dist[nowbit] + 1)) que.push(newbit);\n                    }\n                }\n            }\n        }\n    }\n    cout << dist[(1 << 16) - 1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nmap< vector< vector<char> > , int> done;\nvector< vector<char> > goal(7,vector<char>(7));\nvector< vector<char> > good(8,vector<char>(8,0)) ;\n\nint w[20],h[20];\nint f(vector< vector<char> > &c){\n\tqueue< vector< vector<char> > > Q;\n\tQ.push(c);\n\tdone[c] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector< vector<char> > &q = Q.front(); Q.pop();\n\t\tint cost = done[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(x,7)rep(y,7){\n\t\t\trep(i,n){\n\t\t\t\trep(color,3){\n\t\t\t\t\tif( x < 3 || y < 3 || goal[y][x] == color){\n\t\t\t\t\t\tvector< vector<char> > t = c;\n\t\t\t\t\t\trep(j,h[i]){\n\t\t\t\t\t\t\trep(k,w[i]){\n\t\t\t\t\t\t\t\tint tx = x+k;\n\t\t\t\t\t\t\t\tint ty = y+j;\n\t\t\t\t\t\t\t\tif(tx >= 7 || ty >= 7 || tx < 3 || ty < 3 )continue;\n\t\t\t\t\t\t\t\tif(color == goal[ty][tx])t[ty][tx] = 1;\n\t\t\t\t\t\t\t\telse t[ty][tx] = 0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(done.find(t) == done.end()){\n\t\t\t\t\t\t\tdone[t] = cost + 1;\n\t\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tvector< vector<char> > init(8,vector<char>(8,0)) ;\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[3+i][3+j] = c;\n\t}\n\trep(i,4)rep(j,4) good[i+3][j+3] = 1;\n\t\n\tcout << f(0,init) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 4;\nconst int inf = (1<<20);\nbool edge[N][N][N][N];\nint cost[(1<<16)];\nchar m[N][N+1];\n\nint encode(bool in[4][4]){\n  int ret=0;\n  rep(i,4){\n    rep(j,4){\n      if (in[i][j])ret|=((1<<(j+i*4)));\n    }\n  }\n  return ret;\n}\n\nvoid decode(bool in[4][4],int now){\n  rep(i,4){\n    rep(j,4){\n      in[i][j]=now%2==1;\n      now/=2;\n    }\n  }\n}\n\nint fill(int t,int b,int l,int r,bool st[4][4],char color){\n  bool cpy[4][4];\n  rep(i,4)rep(j,4)cpy[i][j]=st[i][j];\n  for(int i=t;i<=b;i++){\n    for(int j=l;j<=r;j++){\n      if (color == m[i][j])cpy[i][j]=true;\n      else cpy[i][j]=false;\n    }\n  }\n  return encode(cpy);\n}\n\nstring color=\"RGB\";\nint solve(){\n  bool st[4][4];\n  rep(i,(1<<16))cost[i]=inf;\n  queue<int> Q;\n  Q.push(0);\n  cost[0]=0;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    if (now == (1<<16)-1)return cost[now];\n    decode(st,now);\n    rep(i,4){\n      REP(ii,i,4){\n\trep(j,4){\n\t  REP(jj,j,4){\n\t    if (!edge[i][ii][j][jj])continue;\n\t    rep(l,4){\n\t      int next=fill(i,ii,j,jj,st,color[l]);\n\t      if (cost[next] == inf){\n\t\tcost[next]=cost[now]+1;\n\t\tQ.push(next);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n  }\n  return -1;\n}\n\nvoid makePattern(int h,int w){\n  for(int i=-3;i < 4;i++){//top\n    if (i+h <= 0)continue;\n    for(int j=-3;j < 4;j++){//left\n      if (j+w <= 0)continue;\n      int l=max(0,j),r=min(3,j+w-1),t=max(0,i),b=min(3,i+h-1);\n      edge[t][b][l][r]=true;\n      /*\n      cout << i <<\" \" << j <<\" \" << w <<\" \" << h <<\" can push \" << l <<\" - \" << t <<\" : \" << r <<\" - \"<< b << endl;\n      rep(ii,4){\n\trep(jj,4){\n\t  if (t <= ii && ii <= b && l <= jj && jj <= r)cout << \"1\";\n\t  else cout <<\"0\";\n\t}\n\tcout << endl;\n      }\n      cout << endl;\n      */\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n){\n    rep(i,4)rep(j,4)rep(k,4)rep(l,4)edge[i][j][k][l]=false;\n    rep(i,n){\n      int w,h;\n      cin>>w>>h;\n      makePattern(w,h);\n    }\n    rep(i,4)cin>>m[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> H, W;\nstring Area[4];\n\nint d[1<<16];\n\nint main(){\n    cin >> N;\n    H.resize(N); W.resize(N);\n    for(int i=0; i<N; i++)\n        cin >> H[i] >> W[i];\n    \n    vector<set<int>> edges(N);\n    for(int k=0; k<N; k++){\n        for(int h=-4; h<=4; h++){\n            for(int w=-4; w<=4; w++){\n                int t = 0;\n                for(int i=0; i<H[k]; i++){\n                    for(int j=0; j<W[k]; j++){\n                        int nh = h+i;\n                        int nw = w+j;\n                        if(0<=nh && nh<4 && 0<=nw && nw<4){\n                            t |= 1<<(4*nh + nw);\n                        }\n                    }\n                }\n                edges[k].insert(t);\n            }\n        }\n    }\n    \n    int RGB[3] = {};\n    for(int i=0; i<4; i++){\n        cin >> Area[i];\n        for(int j=0; j<4; j++){\n            if(Area[i][j] == 'R')\n                RGB[0] |= (1<<(4*i + j));\n            if(Area[i][j] == 'G')\n                RGB[1] |= (1<<(4*i + j));\n            if(Area[i][j] == 'B')\n                RGB[2] |= (1<<(4*i + j));\n        }\n    }\n    \n    queue<int> que;\n    memset(d, -1, sizeof(d));\n    d[0] = 0;\n    que.push(0);\n    \n    while(!que.empty()){\n        auto x = que.front(); que.pop();\n        \n        for(int i=0; i<N; i++){\n            for(auto v: edges[i]){\n                for(int j=0; j<3; j++){\n                    int y = x;\n                    for(int k=0; k<3; k++){\n                        if(j == k){\n                            y |= RGB[k] & v;\n                        }else{\n                            y &= ~(RGB[k] & v);\n                        }\n                    }\n                    if (d[y] < 0){\n                        que.push(y);\n                        d[y] = d[x] + 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << d[RGB[0] | RGB[1] | RGB[2]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n \nint main(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    for(int i=0; i<n; i++) cin >> h[i] >> w[i];\n    char c[4][4];\n    for(int i=0; i<4; i++){\n        for(int j=0; j<4; j++){\n            cin >> c[i][j];\n        }\n    }\n     \n    vector<int> dp(1<<16, inf);\n    dp[0] = 0;\n    for(int i=0; i<(1<<16); i++){\n        if(dp[i] == inf) continue;\n        for(int s=0; s<n; s++){\n            for(int y=1-h[s]; y<=3; y++){\n                for(int x=1-w[s]; x<=3; x++){\n                    char color = 0;\n                    int newidx = i;\n                    int sy=max(y,0), sx=max(x,0);\n                    int gy=min(y+h[s],4), gx=min(x+w[s],4);\n                    for(int j=sy; j<gy; j++){\n                        for(int k=sx; k<gx; k++){\n                            if((i & 1<<(4*j +k)) != 0) continue;\n                            if(color!=0 && color!=c[j][k]){\n                                color = 0;\n                                j = gy;\n                                break;//j,k\n                            }\n                            color = c[j][k];\n                            newidx |= 1<<(4*j +k);\n                        }\n                    }\n                    if(color != 0){\n                        dp[newidx] = min(dp[newidx], dp[i]+1);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[(1<<16) -1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\n\nint w[16];\nint h[16];\nint a[4][4];\n\nint memo[1<<16];\n\nint main(){\n\tfor(int i = 0 ; i < (1<<16) ; i++) memo[i] = -1;\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tcin >> w[i];\n\t\tcin >> h[i];\n\t}\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif( c == 'R') a[i][j] = 0;\n\t\t\tif( c == 'G') a[i][j] = 1;\n\t\t\tif( c == 'B') a[i][j] = 2;\n\t\t}\n\t\t\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int c = 0 ; c < 3 ; c++){\n\t\t\tfor(int j = -4 ; j < 4 ; j++){\n\t\t\t\tfor(int k = -4 ; k < 4 ; k++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tfor(int l = 0 ; l < h[i] ; l++){\n\t\t\t\t\t\tfor(int m = 0 ; m < w[i] ; m++){\n\t\t\t\t\t\t\tint tx = j + l;\n\t\t\t\t\t\t\tint ty = k + m;\n\t\t\t\t\t\t\tif( tx < 0 || tx >= 4 || ty >= 4 || ty < 0 ) continue;\n\t\t\t\t\t\t\tmask |= 1 << (ty * 4 + tx);\n\t\t\t\t\t\t\tres  |= ( a[ty][tx] == c ) << (ty * 4 + tx );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmem.push_back(res);\n\t\t\t\t\tmas.push_back(mask);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> Q;\n\t\n\tQ.push(0);\n\twhile(Q.size()){\n\t\tint q = Q.front(); Q.pop();\n\t\tfor(int i = 0 ; i < mas.size() ; i++){\n\t\t\tint next = q & ~mas[i];\n\t\t\tnext |= mem[i];\n\t\t\tif( memo[next] == -1){\n\t\t\t\tmemo[next] = memo[q]+1;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tcout << memo[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<set>\n\nusing namespace std;\n\nint main(){\n  int N;\n  cin>>N;\n  set<int> s;\n  for(int i=0;i<N;i++){\n    int H,W;\n    cin>>H>>W;\n    for(int i=0;i<7;i++){\n      for(int j=0;j<7;j++){\n\tbool f[10][10]={};\n\tfor(int k=0;k<H;k++){\n\t  for(int l=0;l<W;l++){\n\t    f[i+k][j+l]=true;\n\t  }\n\t}\n\tint b=0;\n\tfor(int k=0;k<4;k++){\n\t  for(int j=0;j<4;j++){\n\t    b|=f[k+3][j+3]<<k*4+j;\n\t  }\n\t}\n\ts.insert(b);\n      }\n    }\n  }\n  char C[4][5];\n  for(int i=0;i<4;i++){\n    cin>>C[i];\n  }\n  int cb[3]={};\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      for(int k=0;k<3;k++){\n\tcb[k]|=(C[i][j]==\"RGB\"[k])<<i*4+j;\n      }\n    }\n  }\n  queue<pair<int,int> > que;\n  bool p[1<<16]={};\n  que.push({0,(1<<16)-1});\n  for(;;){\n    auto cs=que.front();\n    if(cs.second==0)break;\n    que.pop();\n    if(p[cs.second]++)continue;\n    for(auto e:s){\n      int c=0;\n      for(int i=0;i<3;i++){\n\tc+=(cb[i]&cs.second&e)>0;\n      }\n      if(c==1){\n\tque.push({cs.first+1,cs.second&~e});\n      }\n    }\n  }\n  cout<<que.front().first<<endl;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\nconst int INF=100000000;\n\n// eXªwè³ê½FÉÈéÜÅÌÅ¬X^vñ\nint dp[1<<16];\nchar field[5][5];\nvector<pair<int,int> > stumps;\nint n;\n\nchar color[]={'R','G','B'};\n\nint dfs(int s){\n    if(s==0)\n        return 0;\n    if(dp[s]!=INF)\n        return dp[s];\n    int cnt=INF;\n    // TCYÒÁ½è ¤êðIñÅX^vðßµÄ¢­\n    for(int k = 0; k < stumps.size(); k++){\n        int h=stumps[k].first;\n        int w=stumps[k].second;\n        // ¶ãÌÀWðè\n        for(int i = -h+1; i < 4; i++){\n            for(int j = -w+1; j < 4; j++){\n                int ns=s;\n                bool first=false;\n                bool b=false;\n                char cc=0;\n                // Iñ¾ÍÍªS¯¶FÅ é©Ç¤©ð`FbN·é\n                for(int k = i; k<min(i+h,4); k++){\n                    for(int l = j; l < min(j+w,4); l++){\n                        if(!(k>=0&&l>=0&&k<4&&l<4))\n                            continue;\n                        // hçêÄ¢éêÌÝl¶·é\n                        if((s>>(k*4+l))&1){\n                            if(!first){\n                                cc=field[k][l];\n                                first=true;\n                            }\n                            else{\n                                if(field[k][l]==cc){\n                                    //ok\n                                }\n                                else{\n                                    b=true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(b)\n                        break;\n                }\n                // SðÅ«éê,hèÂÔµððµÄAÄA\n                if(!b&&first){\n                    for(int k = i; k<min(i+h,4); k++){\n                        for(int l = j; l < min(j+w,4); l++){\n                            if(!(k>=0&&l>=0&&k<4&&l<4))\n                                continue;\n                            ns&=~(1<<(k*4+l));\n                        }\n                    }\n                    cnt=min(cnt,dfs(ns)+1);\n                }\n            }\n        }\n    }\n    return dp[s]=cnt;\n}\n\nvoid solve(){\n    fill(dp,dp+(1<<16),INF);\n    cin>>n;\n    int h,w;\n    for(int i = 0; i < n; i++){\n        cin>>h>>w;\n        stumps.push_back(make_pair(h,w));\n    }\n    for(int i = 0; i < 4; i++)\n        for(int j = 0; j < 4; j++)\n            cin>>field[i][j];\n    cout<<dfs((1<<16)-1)<<endl;\n}\nint main(){\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 20;\nint memo[1<<16];\nint mask[3];\n\ninline int color2idx(char c) {\n    if(c == 'R') return 0;\n    if(c == 'G') return 1;\n    if(c == 'B') return 2;\n    return -1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int N;\n    cin >> N;\n    vector<int> stamps;\n    for(int i = 0; i < N; ++i) {\n        int h, w;\n        cin >> h >> w;\n        for(int py = -h+1; py < 4; ++py) {\n            for(int px = -w+1; px < 4; ++px) {\n                int stamp = 0;\n                for(int dy = 0; dy < h; ++dy) {\n                    for(int dx = 0; dx < w; ++dx) {\n                        const int x = px+dx;\n                        const int y = py+dy;\n                        if(0 <= x && x < 4 && 0 <= y && y < 4) {\n                            stamp |= 1<<(y*4+x);\n                        }\n                    }\n                }\n                stamps.push_back(stamp);\n            }\n        }\n    }\n    for(int y = 0; y < 4; ++y) {\n        for(int x = 0; x < 4; ++x) {\n            char c;\n            cin >> c;\n            mask[color2idx(c)] |= 1<<(y*4+x);\n        }\n    }\n    queue<pair<int,int> > q;\n    q.push(make_pair(0, 0));\n    fill_n(memo, 1<<16, INF);\n    int ans = INF;\n    while(!q.empty()) {\n        const int turn = q.front().first;\n        const int state = q.front().second;\n        q.pop();\n\n        if(memo[state] < turn) continue;\n        memo[state] = turn;\n        if(state == (1<<16)-1) {\n            ans = turn;\n            break;\n        }\n\n        for(vector<int>::const_iterator it = stamps.begin(); it != stamps.end(); ++it) {\n            for(int color = 0; color < 3; ++color) {\n                int next_state = state;\n                for(int mc = 0; mc < 3; ++mc) {\n                    if(color == mc) {\n                        next_state |= *it & mask[mc];\n                    } else {\n                        next_state &= ~(*it & mask[mc]);\n                    }\n                }\n                if(memo[next_state] > turn+1) {\n                    memo[next_state] = turn+1;\n                    q.push(make_pair(turn+1, next_state));\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<char> vc;\ntypedef vector<vc> Pic;\ntypedef vector<vector<bool>> Bit;\n\nconst char color[] = {'R', 'G', 'B'};\n\nbool canDelete(Pic& pic, Bit& b, pair<int, int> s, int y, int x, char c){\n\tbool f = false;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tif(not b[i][j]) f = true;\n\t\t\tif(pic[i][j] != c and not b[i][j]) return false;\n\t\t}\n\t}\n\treturn f;\n}\nvoid output(Bit b){\n\tfor(auto i : b){\n\t\tfor(auto j : i) cout << j;\n\t\tcout << endl;\n\t}\n}\n\nBit getPicDeletedColor(Bit& b, pair<int, int> s, int y, int x){\n\tBit res = b;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tres[i][j] = 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint btoi(Bit& bit){\n\tint res = 0, k = 1;\n\tfor(int i = 3; i >= 0; i--){\n\t\tfor(int j = 3; j >= 0; j--){\n\t\t\tif(bit[i][j]) res += k;\n\t\t\tk*=2;\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct P{\n\tint cnt;\n\tBit bit;\n\tP(int cnt, Bit bit) : cnt(cnt), bit(bit) {}\n\tbool operator < ( const P &right ) const {\n\t\treturn cnt < right.cnt;\n\t}\n\tbool operator > ( const P &right ) const {\n\t\treturn cnt > right.cnt;\n\t}\n};\n\nvoid bfs(vector<pair<int, int>>& stamps, Pic& pic){\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.emplace(0, Bit(4, vector<bool>(4,0)));\n\n\tvector<int> dis(1 << 16, 1e9);\n\n\twhile(not q.empty()){\n\t\tP tmp = q.top(); q.pop();\n\n\t\tBit b = tmp.bit;\n\t\tint cnt = tmp.cnt;\n\n\n\t\tif(dis.at(btoi(b)) != 1e9) continue;\n\t\tdis[btoi(b)] = cnt;\n\n\t\tif((1 << 16) - 1 == btoi(b)){\n\t\t\tcout << cnt << endl;\n\t\t\treturn;\n\t\t}\n\n\t\trep(c,3){\n\t\t\trep(i,stamps.size()){\n\t\t\t\trange(y, 1 - stamps[i].first, 4){\n\t\t\t\t\trange(x, 1 - stamps[i].second, 4){\n\t\t\t\t\t\tif(canDelete(pic, b, stamps[i], y, x, color[c])){\n\t\t\t\t\t\t\tq.emplace(cnt + 1, getPicDeletedColor(b, stamps[i], y, x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> stamps(n);\n\trep(i,n){\n\t\tcin >> stamps[i].first >> stamps[i].second;\n\t}\n\n\tPic pic(4, vc(4));\n\trep(i,4) rep(j,4) cin >> pic[i][j];\n\n\tbfs(stamps, pic);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define f first\n#define s second\n#define mp make_pair\n\n\nusing namespace std;\n\nint h[20];\nint w[20];\nint n;\nchar dist[10][10];\n\nint memo[1<<16];\nconst int bad = 1000000;\n\nint mask[16][8][8];\nint smemo[16][8][8][3];\n\nconst char *color = \"RGB\";\n\nint depth = 0;\nint ans   = bad;\n\nvoid genmemo(){\n  REP(k,n){\n    int hh = h[k];\n    int ww = w[k];\n    REP(cc, 3){\n      char col = color[cc];\n      for(int y = -hh + 1; y < 4; y++){\n\tfor(int x = -ww + 1; x < 4; x++){\n\t  int next = 0;\n\t  int msk  = 0;\n\t  REP(i,hh) REP(j,ww){\n\t    int yy = i + y;\n\t    int xx = j + x;\n\n\t    if(yy < 0) continue;\n\t    if(xx < 0) continue;\n\t    if(yy > 3) continue;\n\t    if(xx > 3) continue;\n\n\t    if(dist[yy][xx] == col){\n\t      next |= (1 << (yy * 4 + xx));\n\t    }\n\t    msk |= (1 << (yy * 4 + xx));\n\t  }\n\n\t  mask[k][y+4][x+4] = msk;\n\t  smemo[k][y+4][x+4][cc] = next;\n\t}\n      }\n    }\n  }\n\n}\n\nint solve(int now){\n  if(now == (1 << 16) - 1)\n    return 0;\n  if(memo[now]) return memo[now];\n  memo[now] = bad;\n\n  int ret = bad;\n  // int cnt = __builtin_popcount(now);\n\n  REP(k,n){\n    int hh = h[k];\n    int ww = w[k];\n    REP(cc, 3){\n      for(int y = -hh + 1; y < 4; y++){\n\tfor(int x = -ww + 1; x < 4; x++){\n\t  int next = (now & (~mask[k][y+4][x+4])) | smemo[k][y+4][x+4][cc];\n\t  if(now != next && smemo[k][y+4][x+4][cc])\n\t    ret = min(ret, 1 + solve(next));\n\t}\n      }\n    }\n  }\n\n  return memo[now] = ret;\n}\n\nint main(){\n  scanf(\"%d\", &n);\n  REP(i,n) scanf(\"%d%d\", h+i, w+i);\n  REP(i,4) scanf(\"%s\", dist[i]);\n  genmemo();\n\n  typedef pair<int,int> data;\n  queue<int> q;\n  memset(memo, -1, sizeof(memo));\n\n  memo[0] = 0;\n  q.push(0);\n\n  while(q.size()){\n    int now = q.front();\n    int kai = memo[now];\n    q.pop();\n\n\n    if(now == (1 << 16) - 1){\n      printf(\"%d\\n\", kai);\n      break;\n    }\n\n    REP(k,n){\n      int hh = h[k];\n      int ww = w[k];\n      REP(cc, 3){\n\tfor(int y = -hh + 1; y < 4; y++){\n\t  for(int x = -ww + 1; x < 4; x++){\n\t    int next = (now & (~mask[k][y+4][x+4])) | smemo[k][y+4][x+4][cc];\n\t    if(now != next && smemo[k][y+4][x+4][cc] && memo[next] == -1){\n\t      memo[next] = kai + 1;\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\nll compute_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') type = 1;\n      if(stage[y][x] == 'G') type = 2;\n      if(stage[y][x] == 'B') type = 3;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n  return res;\n}\n\nvoid hash2stage(ll hash){\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = hash % 4LL;\n      if(type == 0) stage[y][x] = '.';\n      if(type == 1) stage[y][x] = 'R';\n      if(type == 2) stage[y][x] = 'G';\n      if(type == 3) stage[y][x] = 'B';\n      hash /= 4LL;\n    }\n  }\n}\n\nll compute_clear_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n\n  return res;\n}\n\nvoid print_stage(){\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\n\nclass State {\npublic:\n  ll _hash;\n  int _cost;\n  \n  State(ll hash,int cost) : _hash(hash), _cost(cost) {}\n  bool operator<(const State& s) const {\n    return _cost < s._cost;\n  }\n  bool operator>(const State& s) const {\n    return _cost > s._cost;\n  }\n};\n\nint bfs(){\n\n  priority_queue<State,vector<State>, greater<State> > que;\n  ll init = compute_hash();\n  ll goal = compute_clear_hash();\n  que.push(State(init,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s._hash == goal) return s._cost;\n    hash2stage(s._hash);\n\n    for(int ly=0;ly<4;ly++){\n      for(int lx=0;lx<4;lx++){\n        for(int ry=ly;ry<4;ry++){\n          for(int rx=lx;rx<4;rx++){\n            //corner\n            if((lx == 0 && ly == 0)\n               || (lx == 0 && ly == 3)\n               || (rx == 3 && ry == 3)\n               || (rx == 3 && ry == 0)){\n              if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //left or right\n            else if(lx == 0 || rx == 3){\n              if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //top or bottom\n            else if(ly == 0 || ry == 3){\n              if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //center\n            else {\n              if(has_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1) continue;\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return INF;\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint h[16], w[16];\nint c[16];\n\nint main()\n{\n\tint cv[256];\n\tfor (int i = 0; i < 3; i++){\n\t\tcv[\"RGB\"[i]] = i + 1;\n\t}\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> h[i] >> w[i];\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tfor (int j = 0; j < 4; j++){\n\t\t\tchar d;\n\t\t\tcin >> d;\n\t\t\tc[i * 4 + j] = cv[d];\n\t\t}\n\t}\n\t\n\tvector<pair<int, int>> v;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int col = 1; col <= 3; col++){\n\t\t\tfor (int bx = -3; bx < 4; bx++){\n\t\t\t\tfor (int by = -3; by < 4; by++){\n\t\t\t\t\tint mask = (1 << 16) - 1, bit = 0;\n\t\t\t\t\tfor (int x = bx; x < bx + h[i]; x++){\n\t\t\t\t\t\tfor (int y = by; y < by + w[i]; y++){\n\t\t\t\t\t\t\tif (x < 0 || x >= 4 || y < 0 || y >= 4) continue;\n\t\t\t\t\t\t\tmask &= ~(1 << (x * 4 + y));\n\t\t\t\t\t\t\tbit |= (int(c[x * 4 + y] == col)) << (x * 4 + y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.emplace_back(mask, bit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(begin(v), end(v));\n\tv.erase(unique(begin(v), end(v)), end(v));\n\t\n\tvector<int> dist(1 << 16, -1);\n\tqueue<int> q;\n\tdist[0] = 0;\n\tq.push(0);\n\twhile (q.size()){\n\t\tint cur = q.front(); q.pop();\n\t\tfor (int i = 0; i < v.size(); i++){\n\t\t\tint x = (cur & v[i].first) | v[i].second;\n\t\t\tif (dist[x] == -1){\n\t\t\t\tdist[x] = dist[cur] + 1;\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dist[(1 << 16) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint dist[1 << 16];\nint N;\nint W[16], H[16];\nchar goal[4][4];\n\n\nint main(){\n\n  cin >> N;\n  REP(i, N) cin >> H[i] >> W[i];\n  REP(i, 4)REP(j, 4){\n    cin >> goal[i][j];\n    if(goal[i][j] == 'R') goal[i][j] = 0;\n    if(goal[i][j] == 'G') goal[i][j] = 1;\n    if(goal[i][j] == 'B') goal[i][j] = 2;\n  }\n\n  \n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, 0));\n  fill(dist, dist + (1 << 16), INF);\n  dist[0] = 0;\n  \n  while(!que.empty()){\n    int cost = que.top().first;\n    int mask = que.top().second;\n    que.pop();\n    if(cost > dist[mask]) continue;\n\n    if(mask == 0xFFFF){\n      cout << cost << endl;\n      return 0;\n    }\n    \n    \n    REP(i, N){\n      for(int h1 = -H[i] + 1; h1 < 4; h1++){\n        for(int w1 = -W[i] + 1; w1 < 4; w1++){\n          int h2 = h1 + H[i];\n          int w2 = w1 + W[i];\n          REP(color, 3){\n            int nmask = 0;\n            REP(r, 4)REP(c, 4){\n              if(h1 <= r && r < h2 && w1 <= c && c < w2){\n                nmask |= (color == goal[r][c]) << (r * 4 + c);\n              }else{\n                nmask |= mask & (1 << (r * 4 + c));\n              }\n            }\n            \n            if(dist[nmask] > cost + 1){\n              dist[nmask] = cost + 1;\n              que.push(P(cost + 1, nmask));\n            }\n          }\n        }\n      }\n    }\n  }\n  assert(false);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint h[16],w[16];\nint dist[1<<16];\nchar ba[4][4];\nint ok[1<<16];\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i,n) cin >> h[i] >> w[i];\n  REP(i,4) REP(j,4) cin >> ba[i][j];\n  int num = 0;\n  set<int> masks;\n  REP(i,n) {\n    for (int y1=-h[i]+1; y1<4; ++y1) {\n      for (int x1=-w[i]+1; x1<4; ++x1) {\n        int mask = 0;\n        for (int y=y1; y<y1+h[i]; ++y) {\n          for (int x=x1; x<x1+w[i]; ++x) {\n            if (y>=0&&y<4&&x>=0&&x<4) mask |= 1<<(y*4+x);\n          }\n        }\n        masks.insert(mask);\n      }\n    }\n  }\n\n  // FOR(it, masks) {\n  //   int S = *it;\n  //   REP(y,4) {\n  //     REP(x,4)\n  //       cout << (S>>(y*4+x)&1);\n  //     cout << endl;\n  //   }\n  //   cout << endl;\n  // }\n  REP(S,1<<16) {\n    set<char> st;\n    REP(y,4) {\n      REP(x,4) {\n        if (S>>(y*4+x)&1) {\n          st.insert(ba[y][x]);\n        }\n      }\n    }\n    ok[S] = (st.size() <= 1);\n    // if (ok[S]) {\n    //   REP(y,4) {\n    //     REP(x,4)\n    //       cout << (S>>(y*4+x)&1);\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n  }\n  queue<int> Q;\n  Q.push((1<<16)-1);\n  memset(dist,-1,sizeof(dist));\n  dist[(1<<16)-1] = 0;\n  while(!Q.empty()) {\n    int S = Q.front(); Q.pop();\n    if (S == 0) break;\n    FOR(it, masks) {\n      int t[3]={};\n      if (ok[*it & S]) {\n        int T = S & ~*it;\n        if (dist[T] == -1) {\n          dist[T] = dist[S] + 1;\n          Q.push(T);\n        }\n      }\n    }\n  }\n  cout << dist[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nvoid sbit(int &n, int i) {\n    n |= (1<<i);\n}\n\nint cbit(int n, int i) {\n    return n & (1<<i);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<pair<int, int> > brush;\n    vector<int> pats;\n    for(int i = 0; i < N; ++i) {\n        int h, w;\n        cin >> h >> w;\n        brush.push_back(make_pair(h, w));\n\n        for(int bx = -4; bx <= 3; ++bx) {\n            for(int by = -4; by <= 3; ++by) {\n                int mask = 0;\n                for(int x = 0; x < 4; ++x) {\n                    for(int y = 0; y < 4; ++y) {\n                        if(bx <= x && x < bx+w && by <= y && y < by+h) sbit(mask, y*4+x);\n                    }\n                }\n                if(mask != 0) pats.push_back(mask);\n            }\n        }\n    }\n\n    vector<string> correct(4);\n    for(int i = 0; i < 4; ++i) {\n        cin >> correct[i];\n    }\n\n    int cmask[3] = {};\n    {\n        string cstr = \"RGB\";\n        for(int i = 0; i < 3; ++i) {\n            for(int y = 0; y < 4; ++y) {\n                for(int x = 0; x < 4; ++x) {\n                    if(correct[y][x] == cstr[i]) sbit(cmask[i], y*4+x);\n                }\n            }\n        }\n    }\n\n    vector<int> memo(1<<16, INT_MAX);\n    queue<pair<int, int> > q;\n\n    int ans = 0;\n    memo[0] = 0;\n    q.push(make_pair(0, 0));\n    while(!q.empty()) {\n        int cost = q.front().first;\n        int pat = q.front().second;\n        q.pop();\n\n        if(pat == 0xffff) {\n            ans = cost;\n            break;\n        }\n\n        //if(memo[pat] <= cost) continue;\n        //memo[pat] = cost;\n\n        for(int i = 0; i < 3; ++i) {\n            for(int j = 0; j < pats.size(); ++j) {\n                int mask = pats[j] & cmask[i];\n                int next = pat;\n                next &= ~pats[j];\n                next |= mask;\n                if(memo[next] == INT_MAX) {\n                    memo[next] = cost+1;\n                    q.push(make_pair(cost+1, next));\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\nint H[20], W[20];\nint dp[1 << 16];\nvector<string> board;\nconst string alph = \"RGB\";\n\nint solve() {\n    queue<int> q; q.push(0);\n    while(!q.empty()) {\n        int bit = q.front(); q.pop();\n        if(bit == (1 << 16) - 1) return dp[bit];\n        // i ????????????????????????????????? (j, k) ?????????????????? s ??§??????\n        rep(i,0,N) rep(j,-4,4) rep(k,-4,4) rep(s,0,3) {\n            int nbit = bit;\n            rep(x,0,H[i]) rep(y,0,W[i]) {\n                if(j+x < 0 || j+x >= 4 || k+y < 0 || k+y >= 4) continue;\n                int idx = (j+x) * 4 + k+y;\n                if(board[j+x][k+y] == alph[s]) nbit |= (1 << idx);\n                else if(nbit >> idx & 1) nbit ^= (1 << idx);\n            }\n            if(dp[nbit] < 0) {\n                dp[nbit] = dp[bit] + 1;\n                q.push(nbit);\n            }\n        }\n    }\n    return 0;\n}\n\nsigned main() {\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n\n    cin >> N;\n    rep(i,0,N) cin >> H[i] >> W[i];\n    rep(i,0,4) {\n        string s; cin >> s;\n        board.push_back(s);\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,v=1<<16;\n  cin>>n;\n  int h[n],w[n],dp[v],used[v];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(int i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=v-1-(1<<(y*4+x));\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[v-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[8][8];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 4; i < 8; i++) for(int j = 4; j < 8; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tbool debug = (q==512+64);\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[8][8];\n\t\trep(i,8) rep(j,8) b[i][j] = 0;\n\t\tfor(int i = 4; i < 8; i++) for(int j = 4; j < 8; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,8){\n\t\t\t\tif(j+h[i] > 8) break;\n\t\t\t\trep(k,8){\n\t\t\t\t\tif(k+w[i] > 8) break;\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 7; hh >= 4; hh--){\n\t\t\t\t\t\t\tfor(int ww = 7; ww >= 4; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    vector<int> cost(1<<16,inf);\n    queue<bitset<16>> que;\n    cost[0]=0;\n    que.push(bitset<16>(0));\n    while(!que.empty()){\n        auto bs=que.front();\n        que.pop();\n        int state=encode(bs);\n        if(bs.all()){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-h[i]+1,4) rep(x,-w[i]+1,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            rep(j,0,3){\n                auto next_bs=bs;\n                bool ok=false;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j){\n                        next_bs.set(4*y_+x_);\n                        ok=true;\n                    }else next_bs.reset(4*y_+x_);\n                }\n                if(!ok) continue;\n                int next_state=encode(next_bs);\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(next_bs);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\nvector<int> item[25];\n\n\nint w[16];\nint h[16];\n\nchar memo[2][1<<25];\nchar dfs(int init){\n\n\tchar *a = memo[0] , *b = memo[1];\n\t\n\tfor(int j = 0 ; j < (1<<25) ; j++)\n\t\ta[j] = 32;\n\t\n\ta[init] = 0;\n\t\n\tfor(int i = 0 ; i < 5 * 5 ; i++){\n\t\tfor(int j = 0 ; j < (1<<25) ; j++) b[j] = a[j];\n\t\tfor(int j = 0 ; j < (1<<25) ; j++){\n\t\t\tif( a[j] == 32 ) continue;\n\t\t\tfor(int k = 0 ; k < item[i].size() ; k++)\n\t\t\t\tb[j^item[i][k]] = min(b[j^item[i][k]],(char)(a[j]+1));\n\t\t}\n\t\tswap(a,b);\n\t}\n\t\n}\t\n\nint main(){\n\t\n\tfor(int w = 1 ; w <= 5 ; w++){\n\t\tfor(int h = 1 ; h <= 5 ; h++){\n\t\t\tfor(int i = 0 ; i <= 5 - h ; i++){\n\t\t\t\tfor(int j = 0 ; j <= 5 - w ; j++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tfor(int k = 0 ; k < h ; k++)\n\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++)\n\t\t\t\t\t\t\tmask |= (1<<((i+k)*5+j+l));\n\t\t\t\t\t//cout << init << \" \" << mask << endl;\n\t\t\t\t\titem[i*5+j].push_back(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\twhile(cin >> N && N){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint c = 0;\n\t\t\t\tcin >> c;\n\t\t\t\tinit |= (c<<(i*5+j));\n\t\t\t}\n\t\t}\n\t\tint x = memo[0][init];\n\t\tfor(int i = 0 ; i < x ; i++) cout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\ntypedef pair<int,int> P;\n\nint n;\nint h[16],w[16];\nbool closed[1<<16];\nchar t[10][10],ch[]=\"RGB\";\n\nvoid show(int bit){\n  rep(i,16){\n    if(bit & (1<<i)){\n      cout<<1;\n    }\n    else{\n      cout<<0;\n    }\n  }\n  cout<<endl;\n}\n\nvoid solve(){\n  queue<P> open;\n  memset(closed,0,sizeof(closed));\n  open.push(P(0,0));\n  closed[0] = true;\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n\n    if(p.second == (1<<16)-1){\n      printf(\"%d\\n\",p.first);\n      return;\n    }\n\n    rep(k,n){\n      rep(color,3){\n        REP(si,-h[k]+1,4){\n          REP(sj,-w[k]+1,4){\n            int bit = p.second;\n\n            REP(i,si,si+h[k]){\n              REP(j,sj,sj+w[k]){\n                if(i < 0 || j < 0 || 4 <= i || 4 <= j) continue;\n\n                int tmpBit = (1<<(i*4+j));\n                if(t[i][j] == ch[color]){\n                  bit |= tmpBit;\n                }\n                else{\n                  bit -= (bit & tmpBit);\n                }\n              }\n            }\n\n            if(!closed[bit]){\n              closed[bit] = true;\n              open.push(P(p.first+1,bit));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"-1\\n\");\n}\n\nint main(void){\n  while(scanf(\"%d\",&n) != EOF){\n    rep(i,n){\n      scanf(\"%d%d\",&h[i],&w[i]);\n    }\n\n    rep(i,4){\n      scanf(\"%s\",t[i]);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int N = 16;\nconst int W = 4;\nconst int INF = 1000000007;\nconst int BITMAX = (1<<(W*W));\n\nint n;\nint sh[N];\nint sw[N];\n\nvector<string> color;\n\n\nvoid input(){\n\tcin>>n;\n\trep(i,n)cin>>sh[i]>>sw[i];\n\t\n\trep(i,W){\n\t\tstring str;\n\t\tcin>>str;\n\t\tcolor.pb(str);\n\t}\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool printbit(int state){\n\trep(i,W*W)printf(\"%d\",(state&(1<<i))>0 ? 1:0);\n}\n\nclass Board{\n\tpublic:\n\tchar masu[W][W];\n\tBoard(int state){\n\t\trep(i,W){\n\t\t\trep(j,W){\n\t\t\t\tint num = i*W+j;\n\t\t\t\tif(hasbit(state, num)){\n\t\t\t\t\tmasu[i][j] = '?';\n\t\t\t\t}else{\n\t\t\t\t\tmasu[i][j] = color[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool canput(int index,int x,int y){\n\t\tint r=0,g=0,b=0;\n\t\trep(i,sh[index]){\n\t\t\trep(j,sw[index]){\n\t\t\t\tint nx = x+j;\n\t\t\t\tint ny = y+i;\n\t\t\t\t\n\t\t\t\tif(nx<0 || ny<0 || nx>=W || ny>=W)continue;\n\t\t\t\t\n\t\t\t\tif(masu[ny][nx]=='R')r++;\n\t\t\t\tif(masu[ny][nx]=='G')g++;\n\t\t\t\tif(masu[ny][nx]=='B')b++;\n\t\t\t}\n\t\t}\n\t\tif(r>0 && g==0 && b==0)return true;\n\t\tif(r==0 && g>0 && b==0)return true;\n\t\tif(r==0 && g==0 && b>0)return true;\n\t\treturn false;\n\t}\n\t\n\tvoid put(int index,int x,int y){\n\t\trep(i,sh[index]){\n\t\t\trep(j,sw[index]){\n\t\t\t\tint nx = x+j;\n\t\t\t\tint ny = y+i;\n\t\t\t\t\n\t\t\t\tif(nx<0 || ny<0 || nx>=W || ny>=W)continue;\n\t\t\t\tmasu[ny][nx] = '?';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getState(){\n\t\tint state = 0;\n\t\trep(i,W){\n\t\t\trep(j,W){\n\t\t\t\tint num = i*W+j;\n\t\t\t\tif(masu[i][j]=='?'){\n\t\t\t\t\tstate += (1<<num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state;\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"----------------------------\\n\");\n\t\trep(i,W){\n\t\t\trep(j,W){\n\t\t\t\tprintf(\"%c \",masu[i][j]);\n\t\t\t}puts(\"\");\n\t\t}\n\t}\n};\n\nint memo[BITMAX];\n\nint saiki(int state){\n\tif(state == (1<<(W*W))-1)return 0;\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tBoard b = Board(state);\n\tint ret = INF;\n\t\n\trep(i,n){\n\t\treps(y, 1-sh[i], W){\n\t\t\treps(x, 1-sw[i], W){\n\t\t\t\tif(b.canput(i, x, y)){\n\t\t\t\t\tBoard copy = b;\n\t\t\t\t\tcopy.put(i, x, y);\n\t\t\t\t\t/*\n\t\t\t\t\tif(state==0){\n\t\t\t\t\t\tprintbit(b.getState());printf(\"  x=%d  y=%d stte=\",x,y);printbit(copy.getState());puts(\"\");\n\t\t\t\t\t}*/\n\t\t\t\t\t\n\t\t\t\t\tret = min(ret, saiki(copy.getState())+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t//printbit(b.getState());cout<<\" \"<<ret<<endl;\n\t\n\treturn memo[state] = ret;\n}\n\nvoid solve(){\n\trep(i,BITMAX)memo[i]=-1;\n\t\n\tint ans = saiki(0);\n\tcout<<ans<<endl;\n}\n\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstring s[4];\nint x[16],y[16];\nint d[1<<16];\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N) cin>>x[i]>>y[i];\n\trep(i,4) cin>>s[i];\n\trep(i,1<<16) d[i]=1e9;\n\td[0]=0;\n\trep(i,1<<16){\n\t\tbool p[4][4]={};\n\t\trep(j,4) rep(k,4) p[j][k]=(i>>(j*4+k))&1;\n\t\trep(j,N){\n\t\t\tfor(int a=-3;a<=3;a++) for(int b=-3;b<=3;b++){\n\t\t\t\tchar c='W';\n\t\t\t\tbool can=1;\n\t\t\t\tint ni=i;\n\t\t\t\trep(X,x[j]) rep(Y,y[j]){\n\t\t\t\t\tif(X+a<0||X+a>=4||Y+b<0||Y+b>=4) continue;\n\t\t\t\t\tif(!p[X+a][Y+b]){\n\t\t\t\t\t\tni|=1<<((X+a)*4+Y+b);\n\t\t\t\t\t\tif(c=='W') c=s[X+a][Y+b];\n\t\t\t\t\t\telse if(c!=s[X+a][Y+b]){\n\t\t\t\t\t\t\tcan=0;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdone:\n\t\t\t\tif(can) chmin(d[ni],d[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<d[65535]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n;\nvi h, w;\n\nbool valid(int i, int j, int k, const vvi& c){\n    vi cnt(4);\n    rep2(ii, max(0ll, i - h[k] + 1), min(i + 1, 4ll)) {\n        rep2(jj, max(0ll, j - w[k] + 1), min(j + 1, 4ll)) {\n            cnt[c[ii][jj]]++;\n        }\n    }\n    int cnt_positive = (int)(cnt[1] > 0) + (int)(cnt[2] > 0) + (int)(cnt[3] > 0);\n    return cnt_positive == 1;\n}\n\nvvi stamp(int i, int j, int k, const vvi& c) {\n    vvi d = c;\n    rep2(ii, max(0ll, i - h[k] + 1), min(i + 1, 4ll)) {\n        rep2(jj, max(0ll, j - w[k] + 1), min(j + 1, 4ll)) {\n            d[ii][jj] = 0;\n        }\n    }\n    return d;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n;\n    h.resize(n); w.resize(n);\n    rep(i, n) cin >> h[i] >> w[i];\n    vvi cleared(4, vi(4));\n    vvi c(4, vi(4));\n    rep(i, 4) rep(j, 4) {\n        char x;\n        cin >> x;\n        if (x == 'R') c[i][j] = 1;\n        if (x == 'G') c[i][j] = 2;\n        if (x == 'B') c[i][j] = 3;\n    }\n\n    // if (valid(1, 2, 1, c)) {\n    //     c = stamp(1, 2, 1, c);\n    //     printVV(c);\n    // }\n    // if (valid(2, 1, 1, c)) {\n    //     c = stamp(2, 1, 1, c);\n    //     printVV(c);\n    // }\n    // if (valid(3, 3, 0, c)) {\n    //     c = stamp(3, 3, 0, c);\n    //     printVV(c);\n    // }\n    //\n    // if (c == cleared) {\n    //     output(\"cleared!\");\n    // }\n\n    set<vvi> visited;\n    queue<pair<vvi, int>> que;\n    que.emplace(c, 0);\n    visited.emplace(c);\n    while (!que.empty()) {\n        vvi d;\n        int t;\n        tie(d, t) = que.front(); que.pop();\n        // output(\"t =\", t);\n        // printVV(d);\n        rep(k, n) {\n            rep(i, 7) {\n                rep(j, 7) {\n                    if (valid(i, j, k, d)) {\n                        vvi e = stamp(i, j, k, d);\n                        if (visited.count(e)) continue;\n                        if (e == cleared) {\n                            cout << t + 1 << endl;\n                            return 0;\n                        }\n                        que.emplace(e, t + 1);\n                        visited.emplace(e);\n                    }\n                }\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  const string cols = \"RGB\";\n\n  int N; cin >> N;\n  vector<pair<int, int>> vs(N);\n  rep(i, N) {\n    cin >> vs[i].first >> vs[i].second;\n  }\n\n  vector<string> G(4);\n  rep(i, 4) cin >> G[i];\n\n  int dist[1<<16];\n  minus(dist);\n  dist[0] = 0;\n\n  queue<int> q;\n  q.push(0);\n\n  while(!q.empty()) {\n    if(~dist[(1<<16)-1]) break;\n\n    int curr = q.front(); q.pop();\n\n    for(auto hw: vs) {\n      int h = hw.first, w = hw.second;\n\n      for(auto col: cols)\n      REP(i, -h + 1, 4) REP(j, -w + 1, 4) {\n        int next = curr;\n        REP(y, i, min(i + h, 4)) REP(x, j, min(j + w, 4)) {\n          if(G[y][x] == col) next |= 1<<(y * 4 + x);\n          else next &= ~(1<<(y * 4 + x));\n        }\n        if(dist[next] < 0) {\n          dist[next] = dist[curr] + 1;\n          q.push(next);\n        }\n      }\n    }\n  }\n\n  cout << dist[(1<<16)-1] << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\nvoid Min(int &a,int b){a=min(a,b);}\nint Idx(int y,int x){return y*4+x;}\n\nint nsta(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\nint mem[1<<16],used[1<<16];\nint dfs(int sta){\n  if(sta==(1<<16)-1)return 0;\n  if(used[sta]++) return mem[sta];\n  mem[sta]=INF;\n  int res=INF;\n  for(int i=0;i<3;i++)\n    for(int a=0;a<16;a++)\n      for(int b=0;b<16;b++){\n\tif(can[a][b]){\n\t  data yx=(data){a/4,a%4};\n\t  data YX=(data){b/4,b%4};\n\t  res=min(res,1+dfs(nsta(sta,yx,YX,RGB[i]))); \n\t}\n      }\n  return mem[sta]=res;\n}\n\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  \n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4];\n\t\t\telse F[i / 4][i % 4] = 0;\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = 1 - (int)x[i].first; j <= 3; j++) {\n\t\t\t\tfor (int k = 1 - (int)x[i].second; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint L[4][4]; for (int l = 0; l < 16; l++)L[l >> 2][l & 3] = F[l >> 2][l & 3];\n\t\t\t\t\t\tfor (int l = 0; l < x[i].first; l++) {\n\t\t\t\t\t\t\tfor (int m = 0; m < x[i].second; m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m;\n\t\t\t\t\t\t\t\tif (cx < 0 || cy < 0 || cx >= 4 || cy >= 4)continue;\n\t\t\t\t\t\t\t\tif (L[cx][cy] >= 1 && col[cx][cy] != o) { L[cx][cy] = 0; }\n\t\t\t\t\t\t\t\telse if (L[cx][cy] == 0 && col[cx][cy] == o) { L[cx][cy] = o; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = 0;\n\t\t\t\t\t\tfor (int l = 0; l < 16; l++) { if (L[l >> 2][l & 3] >= 1)bits += (1 << l); }\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\nbool rect[4][4][4][4];\n\nconst int V = 1 << 16;\nset<unsigned short> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tif(dist[G[u][i]] < inf) continue;\n\t\t\tdist[G[u][i]] = dist[u] + 1;\n\t\t\tQ.push(G[u][i]);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\trect[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < N; j++){\n\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\trect[max(x, 0)][min(x+W[j],4)-1][max(y, 0)][min(y+H[j],4)-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tnext = i;\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tfor(int q = 0; q < 4; q++){\n\t\t\t\t\tfor(int r = 0; r < 4; r++){\n\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\tif(!rect[p][q][r][s]) continue;\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tfor(int dx = p; dx <= q; dx++){\n\t\t\t\t\t\t\t\tfor(int dy = r; dy <= s; dy++){\n\t\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tG[i].insert(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int N, H[16], W[16];\n  string S[4];\n  const string temp = \"RGB\";\n  int bit[16][8][8][3] = {{{{}}}};\n  int change[16][8][8][3] = {{{{}}}};\n  int v[1 << 16];\n  fill_n(v, 1 << 16, INF);\n  queue< int > que;\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> H[i] >> W[i];\n  }\n  for(int i = 0; i < 4; i++) {\n    cin >> S[i];\n    for(int j = 0; j < 4; j++) {\n      S[i][j] = temp.find(S[i][j]);\n    }\n  }\n\n  for(int k = 0; k < N; k++) {\n    for(int i = -3; i < 4; i++) {\n      for(int j = -3; j < 4; j++) {\n        for(int z = 0; z < 3; z++) {\n          auto &tugi = bit[k][i + 3][j + 3][z];\n          auto &kaee = change[k][i + 3][j + 3][z];\n          for(int l = 0; l < H[k]; l++) {\n            if(i + l < 0 || i + l >= 4) continue;\n            for(int n = 0; n < W[k]; n++) {\n              if(j + n < 0 || j + n >= 4) continue;\n              int y = i + l, x = j + n;\n              tugi |= (S[y][x] == z) << (y * 4 + x);\n              kaee |= 1 << (y * 4 + x);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  que.emplace(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front();\n    que.pop();\n    if(p == (1 << 16) - 1) {\n      cout << v[p] << endl;\n      break;\n    }\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < 8; i++) {\n        for(int j = 0; j < 8; j++) {\n          for(int z = 0; z < 3; z++) {\n            if(bit[k][i][j][z] == 0) continue;\n            int s = p & ~change[k][i][j][z] | bit[k][i][j][z];\n            if(v[s] > v[p] + 1) {\n              v[s] = v[p] + 1;\n              que.emplace(s);\n            }\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\nconst int INF=100000000;\n\n// eXªwè³ê½FÉÈéÜÅÌÅ¬X^vñ\nint dp[1<<16];\nchar field[5][5];\nvector<pair<int,int> > stumps;\nint n;\nchar color[]={'R','G','B'};\n\nint dfs(int s){\n    if(s==0)\n        return 0;\n    if(dp[s]!=INF)\n        return dp[s];\n    int cnt=INF;\n    // TCYÒÁ½è ¤êðIñÅX^vðßµÄ¢­\n    for(int k = 0; k < stumps.size(); k++){\n        int h=stumps[k].first;\n        int w=stumps[k].second;\n        // ¶ãÌÀWðè\n        for(int i = -h+1; i < 4; i++){\n            for(int j = -w+1; j < 4; j++){\n                int ns=s;\n                bool first=false;\n                bool b=false;\n                char cc=0;\n                // Iñ¾ÍÍªS¯¶FÅ é©Ç¤©ð`FbN·é\n                for(int k = i; k<min(i+h,4); k++){\n                    for(int l = j; l < min(j+w,4); l++){\n                        if(!(k>=0&&l>=0&&k<4&&l<4))\n                            continue;\n                        // hçêÄ¢éêÌÝl¶·é\n                        if((s>>(k*4+l))&1){\n                            if(!first){\n                                cc=field[k][l];\n                                first=true;\n                            }\n                            else{\n                                if(field[k][l]!=cc){\n                                    b=true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(b)\n                        break;\n                }\n                // SðÅ«éê,hèÂÔµððµÄAÄA\n                if(!b&&first){\n                    for(int k = i; k<min(i+h,4); k++){\n                        for(int l = j; l < min(j+w,4); l++){\n                            if(!(k>=0&&l>=0&&k<4&&l<4))\n                                continue;\n                            ns&=~(1<<(k*4+l));\n                        }\n                    }\n                    cnt=min(cnt,dfs(ns)+1);\n                }\n            }\n        }\n    }\n    return dp[s]=cnt;\n}\n\nvoid solve(){\n    fill(dp,dp+(1<<16),INF);\n    cin>>n;\n    int h,w;\n    for(int i = 0; i < n; i++){\n        cin>>h>>w;\n        stumps.push_back(make_pair(h,w));\n    }\n    for(int i = 0; i < 4; i++)\n        for(int j = 0; j < 4; j++)\n            cin>>field[i][j];\n    cout<<dfs((1<<16)-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<int> H(n), W(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> H[i] >> W[i];\n    }\n    vector<string> s(4); cin >> s;\n\n    vector<int> dist(1<<16, numeric_limits<int>::max());\n    dist[0] = 0;\n    queue<pair<int,int>> que;\n    que.emplace(0,0);\n\n    while (!que.empty()) {\n        int bit, cost;\n        tie(bit, cost) = que.front();\n        que.pop();\n\n        for (int i = 0; i < n; ++i) {\n            int h = H[i], w = W[i];\n            for (char color : {'R', 'G', 'B'}) {\n                for (int y = 1-h; y < 4; ++y) {\n                    for (int x = 1-w; x < 4; ++x) {\n                        int tmp = bit;\n                        for (int a = max(y,0); a < min(y+h,4); ++a) {\n                            for (int b = max(x,0); b < min(x+w,4); ++b) {\n                                if (s[a][b] == color) {\n                                    tmp |= 1<<(a*4+b);\n                                } else {\n                                    tmp &= ~(1<<(a*4+b));\n                                }\n                            }\n                        }\n                        if (tmp == (1<<16)-1) {\n                            cout << cost+1 << endl;\n                            return 0;\n                        }\n                        if (chmin(dist[tmp], cost+1)) {\n                            que.emplace(tmp, cost+1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n \nconst int MAXN = 16;\nconst int H = 4;\nconst int W = 4;\nconst char C[3] = {'R','G','B'};\nconst int INF = 1<<28;\n \nint n;\nchar goal[H][W];\nint h[MAXN], w[MAXN];\nbool vis[1<<(W*H)];\n \ninline int getId(const int &x, const int &y) {\n  return x + y * W;\n}\n \nint stamp(int state, int x, int y, int w, int h, char c) {\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      int nx = x + j;\n      int ny = y + i;\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      int id = getId(nx,ny);\n      state = (state & ~(1<<id));\n      if(goal[ny][nx] == c) state |= (1<<id);\n    }\n  }\n  return state;\n}\n \nint bfs() {\n  queue<int> que;\n  int vis[1<<(W*H)];\n  que.push(0);\n  fill(vis,vis+(1<<(W*H)), INF);\n  vis[0] = 0;\n  while(!que.empty()) {\n    int s = que.front();\n    que.pop();\n    for(int k = 0; k < n; ++k) {\n      for(int m = 0; m < 3; ++m) {\n    for(int x = 1-w[k]; x < W; ++x) {\n      for(int y = 1-h[k]; y < H; ++y) {\n        int ns = stamp(s,x,y,w[k],h[k],C[m]);\n        if(vis[ns] != INF) continue;\n        vis[ns] = vis[s] + 1;\n        que.push(ns);\n        if(ns == (1<<(W*H))-1) return vis[ns];\n      }\n    }\n      }\n    }\n  }\n  return INF;\n}\n \nint main() {\n  while(cin >> n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> h[i] >> w[i];\n    }\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n    cin >> goal[i][j];\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<int> h,w;\n\nvector<vector<int>> fie(4,vector<int>(4));\n\nvector<int> dist(1 << 16,-1);\n\nint main(){\n\tcin >> n;\n\th.resize(n);\n\tw.resize(n);\n\trep(i,0,n - 1) cin >> h[i] >> w[i];\n\trep(i,0,3)rep(j,0,3){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') fie[i][j] = 0;\n\t\tif(c == 'G') fie[i][j] = 1;\n\t\tif(c == 'B') fie[i][j] = 2;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\tdist[0] = 0;\n\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tif(v == (1 << 16) - 1)\n\t\t{\n\t\t\tcout << dist[v] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(c,0,2) rep(s,0,n - 1){\n\t\t\trep(i,-3,3) rep(j,-3,3){\n\t\t\t\tint u = v;\n\t\t\t\trep(x,max(i,0),min(i + h[s] - 1,3)) rep(y,max(j,0),min(j + w[s] - 1,3)){\n\t\t\t\t\tint index = (x * 4 + y);\n\t\t\t\t\tif(u & (1 << index)){\n\t\t\t\t\t\tif(fie[x][y] != c) u ^= (1 << index);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(fie[x][y] == c) u ^= (1 << index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dist[u] == -1){\n\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MAX 16\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\nchar cc[4][4];\nstruct P{\n  char g[4][4];\n  int c,u;\n  P(){\n    rep(i,4)rep(j,4)g[i][j]='?';\n    c=0; u=0;\n  }\n  int enc(){\n    int ret=0;\n    rep(i,4)rep(j,4){\n      ret<<=1;\n      ret|=g[i][j]==cc[i][j];\n    }\n    return ret;\n  }\n};\nbool used[1<<16];\nint n;\nint h[MAX],w[MAX];\nint mask[16][3][10][10];\nconst string co=\"RGB\";\nint bfs()\n{\n  queue<P> q;\n  q.push(P());\n  {\n    rep(ii,n){\n      P p=q.front();\n      rep(k,3){\n        REP(i,1-h[ii],4)REP(j,1-w[ii],4){\n          P t=p;\n          rep(y,h[ii])rep(x,w[ii]){\n            if(i+y<0||i+y>3||j+x<0||j+x>3)continue;\n            t.g[i+y][j+x]=co[k];\n          }\n          int enc=t.enc();\n          mask[ii][k][i+4][j+4]=enc;\n        }\n      }\n    }\n  }\n  while(!q.empty()){\n    P p=q.front(); q.pop();\n    if(p.u==(1<<16)-1)return p.c;\n    p.c++;\n    rep(ii,n){\n      rep(k,3){\n        REP(i,1-h[ii],4)REP(j,1-w[ii],4){\n          P t=p;\n          /*\n          rep(y,h[ii])rep(x,w[ii]){\n            if(i+y<0||i+y>3||j+x<0||j+x>3)continue;\n            t.g[i+y][j+x]=co[k];\n          }\n            */\n          t.u^=mask[ii][k][i+4][j+4];\n          int enc=t.u;\n          if(used[enc])continue;\n          used[enc]=true;\n          q.push(t);\n        }\n      }\n    }\n  }\n  return -1;\n}\nint main(void)\n{\n  scanf(\"%d\",&n);\n  rep(i,n)scanf(\"%d%d\",h+i,w+i);\n  rep(i,4)rep(j,4)scanf(\" %c\",cc[i]+j);\n  printf(\"%d\\n\",bfs());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tset<int> stamp;\n\tfor(int i=0; i<n; ++i){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfor(int j=-3; j<4; ++j){\n\t\t\tfor(int k=-3; k<4; ++k){\n\t\t\t\tbitset<16> bs;\n\t\t\t\tfor(int y=j; y<j+h; ++y){\n\t\t\t\t\tfor(int x=k; x<k+w; ++x){\n\t\t\t\t\t\tif(0 <= y && y <4 && 0 <= x && x < 4)\n\t\t\t\t\t\t\tbs[y*4+x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bs.any())\n\t\t\t\t\tstamp.insert(bs.to_ulong());\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<bitset<16> > color(3);\n\tfor(int i=0; i<16; ++i){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R')\n\t\t\tcolor[0][i] = true;\n\t\telse if(c == 'G')\n\t\t\tcolor[1][i] = true;\n\t\telse\n\t\t\tcolor[2][i] = true;\n\t}\n\n\tvector<int> memo(1<<16, -1);\n\tqueue<int> q;\n\tmemo[0] = 0;\n\tq.push(0);\n\tfor(;;){\n\t\tbitset<16> bs = q.front();\n\t\tq.pop();\n\n\t\tset<int>::iterator it;\n\t\tfor(it=stamp.begin(); it!=stamp.end(); ++it){\n\t\t\tfor(int i=0; i<3; ++i){\n\t\t\t\tbitset<16> bs2 = color[i] & bitset<16>(*it);\n\t\t\t\tif(bs2.none())\n\t\t\t\t\tcontinue;\n\t\t\t\tbs2 |= bs & ~bitset<16>(*it);\n\t\t\t\tif(memo[bs2.to_ulong()] == -1){\n\t\t\t\t\tmemo[bs2.to_ulong()] = memo[bs.to_ulong()] + 1;\n\t\t\t\t\tq.push(bs2.to_ulong());\n\t\t\t\t\tif(bs2.all()){\n\t\t\t\t\t\tcout << memo[bs2.to_ulong()] << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a, b; vector<int> x, y; string tmp;\n\nmap<unsigned, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tunsigned finish = 0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tswitch (tmp[j])\n\t\t\t{\n\t\t\tcase 'R': finish += (1 << (i * 8 + j * 2)) * 3;\n\t\t\tcase 'G': finish += (1 << (i * 8 + j * 2)) * 3;\n\t\t\tcase 'B': finish += (1 << (i * 8 + j * 2)) * 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<unsigned, int> > que;\n\n\tque.push(make_pair(0, 0)); D[0] = true;\n\n\twhile (true)\n\t{\n\t\tunsigned M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (finish == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < 3; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tM2 -= (M2 / (1 << (l * 8 + m * 2))) % 4;\n\t\t\t\t\t\t\t\tM2 += (1 << (l * 8 + m * 2));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/02 20:16:19\n//=================================\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<int, int>;\n    vector<P> s(N);\n    for (int i = 0, H, W; i < N; i++) { cin >> H >> W, s[i] = {H, W}; }\n    vector<vector<int>> f(4, vector<int>(4, 0));\n    map<char, int> mp;\n    mp['R'] = 1, mp['G'] = 2, mp['B'] = 3;\n    for (int i = 0; i < 4; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 4; j++) { f[i][j] = mp[s[j]]; }\n    }\n    vector<int> memo(1 << 16, -1);\n    auto dfs = [&](auto&& self, const int hash) -> int {\n        if (hash == 0) { return 0; }\n        if (memo[hash] != -1) { return memo[hash]; }\n        int ans = 30;\n        for (int i = 0; i < N; i++) {\n            const int H = s[i].first, W = s[i].second;\n            for (int h = 1 - H; h < 4; h++) {\n                for (int w = 1 - W; w < 4; w++) {\n                    const int hinf = max(h, 0), winf = max(w, 0);\n                    const int hsup = min(h + H, 4), wsup = min(w + W, 4);\n                    int ch = -1;\n                    bool ok = true;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            if (hash & (1 << (4 * i + j))) {\n                                if (ch != -1 and ch != f[i][j]) { ok = false; }\n                                ch = f[i][j];\n                            }\n                        }\n                    }\n                    if (not ok or ch == -1) { continue; }\n                    int h = hash;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) { h &= ~(1 << (4 * i + j)); }\n                    }\n                    const int sub = self(self, h) + 1;\n                    ans = min(ans, sub);\n                }\n            }\n        }\n        return memo[hash] = ans;\n    };\n    const int ans = dfs(dfs, (1 << 16) - 1);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<char> vc;\ntypedef vector<vc> Pic;\n\nclass Bit{\n\tint bit;\n\tpublic:\n\tBit() : bit(0) { }\n\tbool at(int i, int j){\n\t\treturn ( bit >> (i * 4 + j) ) & 1;\n\t}\n\tvoid set(int i, int j){\n\t\tbit |= 1 << (i * 4 + j);\n\t}\n\tint get(){\n\t\treturn bit;\n\t}\n};\n\nconst char color[] = {'R', 'G', 'B'};\n\nbool canDelete(Pic& pic, Bit& b, pair<int, int> s, int y, int x, char c){\n\tbool f = false;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tif(not b.at(i,j)) f = true;\n\t\t\tif(pic[i][j] != c and not b.at(i,j)) return false;\n\t\t}\n\t}\n\treturn f;\n}\nvoid output(Bit b){\n}\n\nBit getUpdatedBit(Bit& b, pair<int, int> s, int y, int x){\n\tBit res = b;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tres.set(i,j);\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct P{\n\tint cnt;\n\tBit bit;\n\tP(int cnt, Bit bit) : cnt(cnt), bit(bit) {}\n\tbool operator < ( const P &right ) const {\n\t\treturn cnt < right.cnt;\n\t}\n\tbool operator > ( const P &right ) const {\n\t\treturn cnt > right.cnt;\n\t}\n};\n\nvoid bfs(vector<pair<int, int>>& stamps, Pic& pic){\n\t//priority_queue<P, vector<P>, greater<P>> q;\n\tqueue<P> q;\n\tq.emplace(0, Bit());\n\n\tvector<int> dis(1 << 16, 1e9);\n\tdis[0] = 0;\n\n\twhile(not q.empty()){\n\t\tP tmp = q.front(); q.pop();\n\n\t\tBit b = tmp.bit;\n\t\tint cnt = tmp.cnt;\n\n\n\t\t//if(dis.at(b.get()) <= cnt) continue;\n\t\t//dis[b.get()] = cnt;\n\n\t\tif((1 << 16) - 1 == b.get()){\n\t\t\tcout << cnt << endl;\n\t\t\treturn;\n\t\t}\n\n\t\trep(c,3){\n\t\t\trep(i,stamps.size()){\n\t\t\t\trange(y, 1 - stamps[i].first, 4){\n\t\t\t\t\trange(x, 1 - stamps[i].second, 4){\n\t\t\t\t\t\tif(canDelete(pic, b, stamps[i], y, x, color[c])){\n\t\t\t\t\t\t\tBit tmp = getUpdatedBit(b, stamps[i], y, x);\n\t\t\t\t\t\t\tif(dis.at(tmp.get()) > cnt + 1){\n\t\t\t\t\t\t\t\tdis[tmp.get()] = cnt + 1;\n\t\t\t\t\t\t\t\tq.emplace(cnt + 1, getUpdatedBit(b, stamps[i], y, x));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> stamps(n);\n\trep(i,n){\n\t\tcin >> stamps[i].first >> stamps[i].second;\n\t}\n\n\tPic pic(4, vc(4));\n\trep(i,4) rep(j,4) cin >> pic[i][j];\n\n\tbfs(stamps, pic);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int N = 16;\nconst int W = 4;\nconst int INF = 1000000007;\nconst int BITMAX = (1<<(W*W));\n\nint n;\nint sh[N];\nint sw[N];\n\nvector<string> color;\n\n\nvoid input(){\n\tcin>>n;\n\trep(i,n)cin>>sh[i]>>sw[i];\n\t\n\trep(i,W){\n\t\tstring str;\n\t\tcin>>str;\n\t\tcolor.pb(str);\n\t}\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool printbit(int state){\n\trep(i,W*W)printf(\"%d\",(state&(1<<i))>0 ? 1:0);\n}\n\nclass Board{\n\tpublic:\n\tint state;\n\tBoard(int state):state(state){}\n\t\n\tchar getMasuChar(int x,int y){\n\t\tint num = y*W + x;\n\t\tif((state&(1<<num))>0)return '?';\n\t\treturn color[y][x];\n\t}\n\t\n\tbool canput(int index,int x,int y){\n\t\tint r=0,g=0,b=0;\n\t\trep(i,sh[index]){\n\t\t\trep(j,sw[index]){\n\t\t\t\tint nx = x+j;\n\t\t\t\tint ny = y+i;\n\t\t\t\t\n\t\t\t\tif(nx<0 || ny<0 || nx>=W || ny>=W)continue;\n\t\t\t\t\n\t\t\t\tchar c = getMasuChar(nx, ny);\n\t\t\t\tif(c=='R')r++;\n\t\t\t\tif(c=='G')g++;\n\t\t\t\tif(c=='B')b++;\n\t\t\t}\n\t\t}\n\t\tif(r>0 && g==0 && b==0)return true;\n\t\tif(r==0 && g>0 && b==0)return true;\n\t\tif(r==0 && g==0 && b>0)return true;\n\t\treturn false;\n\t}\n\t\n\tvoid put(int index,int x,int y){\n\t\trep(i,sh[index]){\n\t\t\trep(j,sw[index]){\n\t\t\t\tint nx = x+j;\n\t\t\t\tint ny = y+i;\n\t\t\t\t\n\t\t\t\tif(nx<0 || ny<0 || nx>=W || ny>=W)continue;\n\t\t\t\t\n\t\t\t\tint num = ny*W + nx;\n\t\t\t\tstate |= (1<<num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getState(){\n\t\treturn state;\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"----------------------------\\n\");\n\t\trep(i,W){\n\t\t\trep(j,W){\n\t\t\t\tprintf(\"%c \",getMasuChar(i,j));\n\t\t\t}puts(\"\");\n\t\t}\n\t}\n};\n\nint memo[BITMAX];\n\nint saiki(int state){\n\tif(state == (1<<(W*W))-1)return 0;\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tBoard b = Board(state);\n\tint ret = INF;\n\t\n\trep(i,n){\n\t\treps(y, 1-sh[i], W){\n\t\t\treps(x, 1-sw[i], W){\n\t\t\t\tif(b.canput(i, x, y)){\n\t\t\t\t\tBoard copy = b;\n\t\t\t\t\tcopy.put(i, x, y);\n\t\t\t\t\t\n\t\t\t\t\tret = min(ret, saiki(copy.getState())+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn memo[state] = ret;\n}\n\nvoid solve(){\n\trep(i,BITMAX)memo[i]=-1;\n\t\n\tint ans = saiki(0);\n\tcout<<ans<<endl;\n}\n\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\nusing namespace std;\n\nset<int> stamp;\nvector<int> memo(1<<16, -1);\nvector<bitset<16> > color(3);\n\nint solve(bitset<16> bs, int depth)\n{\n\tif(bs.all())\n\t\treturn 0;\n\tif(memo[bs.to_ulong()] != -1)\n\t\treturn memo[bs.to_ulong()];\n\tif(depth > 16)\n\t\treturn INT_MAX / 2;\n\n\tmemo[bs.to_ulong()] = INT_MAX / 2;\n\n\tint ret = INT_MAX / 2;\n\tset<int>::iterator it;\n\tfor(it=stamp.begin(); it!=stamp.end(); ++it){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tif((bitset<16>(*it) & color[i]).none())\n\t\t\t\tcontinue;\n\t\t\tbitset<16> bs2 = bs & ~bitset<16>(*it);\n\t\t\tbs2 |= bitset<16>(*it) & color[i];\n\t\t\tret = min(ret, 1 + solve(bs2, depth+1));\n\t\t}\n\t}\n\n\treturn memo[bs.to_ulong()] = ret;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfor(int j=-3; j<4; ++j){\n\t\t\tfor(int k=-3; k<4; ++k){\n\t\t\t\tbitset<16> bs;\n\t\t\t\tfor(int y=j; y<j+h; ++y){\n\t\t\t\t\tfor(int x=k; x<k+w; ++x){\n\t\t\t\t\t\tif(0 <= y && y <4 && 0 <= x && x < 4)\n\t\t\t\t\t\t\tbs[y*4+x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bs.any())\n\t\t\t\t\tstamp.insert(bs.to_ulong());\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<16; ++i){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R')\n\t\t\tcolor[0][i] = true;\n\t\telse if(c == 'G')\n\t\t\tcolor[1][i] = true;\n\t\telse\n\t\t\tcolor[2][i] = true;\n\t}\n\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint n;\nint h[20],w[20];\nconst int H=4,W=4;\nint ans=16;\n\nset<string> used;\n\nvoid dfs(string s,int cnt){\n\n    if(used.count(s))return;\n    used.insert(s);\n    if(cnt>=ans)return;\n    bool ok=true;\n    rep(i,H)rep(j,W){\n        if(s[H*i+j]!='*')ok=false;\n    }\n    if(ok){\n        ans = min(ans,cnt);\n        return ;\n    }\n    rep(i,n){\n        REP(j,-H,H)REP(k,-W,W){\n            set<char> st;\n            rep(l,h[i])rep(m,w[i]){\n                if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W&&s[(j+l)*H+k+m]!='*'){\n                    st.insert(s[(j+l)*4+k+m]);\n                }\n            }\n            if(st.size()!=1)continue;\n            string ns=s;\n            rep(l,h[i])rep(m,w[i]){\n                if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W){\n                    ns[(j+l)+k+m]='*';\n                }\n            }\n            dfs(ns,cnt+1);\n        }\n    }\n}\n\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>h[i]>>w[i];\n    }\n    string s;\n    rep(i,4){\n        string t;\n        cin>>t;\n        s+=t;\n    }\n    dfs(s,0);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\nconst char color_list[] = {'R', 'G', 'B'};\n\nint stamp(int status, const pair<int, int>& stamp, int pos_h, int pos_w, char color, const vector<char>& c){\n  int up = max(pos_h, 0);\n  int down = min(stamp.first + pos_h, 4);\n  int left = max(pos_w, 0);\n  int right = min(stamp.second + pos_w, 4);\n\n  int stamp_bit = 0;\n  for(int i = up; i < down; i++)\n    for(int j = left; j < right; j++)\n      stamp_bit |= 1 << ((i * 4) + j);\n\n  for(int i = 0; i < 16; i++){\n    if((stamp_bit & (1 << i)) != 0){\n      if(color == c[i]){ status |= (1 << i); }\n      else{ status &= ~(1 << i); }\n    }\n  }\n\n  return status;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n\n  int h, w;\n  vector<pair<int, int> > stamps;\n  for(int i = 0; i < n; i++){\n    cin >> h >> w;\n    stamps.push_back(make_pair(h, w));\n  }\n  vector<char> c(16);\n  for(int i = 0; i < 16; i++){ cin >> c[i]; }\n\n  \n  int ans = INF;\n  const int goal = (1 << 16) - 1;\n\n  // テ・ツケツ?・ツ?ェテ・ツ?暗」ツ?凖」ツつ?\n  vector<bool> used(1 << 16, false);\n  queue<pair<int, int> > wait;\n  wait.push(make_pair(0, 0));\n  used[0] = true;\n  while(!wait.empty()){\n    int cost = wait.front().first;\n    int status = wait.front().second;\n    wait.pop();\n\n    if(status == goal){\n      ans = cost;\n      break;\n    }\n\n    for(int i = 0; i < n; i++){\n      for(int z = 0; z < 3; z++){\n        for(int x = 1 - stamps[i].first; x < 4; x++){\n          for(int y = 1 - stamps[i].second; y < 4; y++){\n            int next_status = stamp(status, stamps[i], x, y, color_list[z], c);\n            if(!used[next_status]){\n              used[next_status] = true;\n              wait.push(make_pair(cost + 1, next_status));\n            }    \n          }\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 角を使えばどんな状況でも最悪16回で描ける\n// 16マスそれぞれを正しい色で塗られている/塗られていないの2進数で表せば状態の数は2^16通り\n// でBFS\n\nint n, h[16], w[16], d[1<<16], s[4][4];\nstring S[4];\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4) {\n\t\tcin >> S[i];\n\t\trep(j,4) {\n\t\t\tif (S[i][j]=='R') s[i][j] = 0;\n\t\t\telse if (S[i][j]=='G') s[i][j] = 1;\n\t\t\telse s[i][j] = 2;\n\t\t}\n\t}\n\trep(i,1<<16) d[i] = inf;\n\td[0] = 0;\n\t\n\t\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint b = q.front(); q.pop();\n\t\tif (__builtin_popcount(b)==16) continue;\n\t\trep(i,n) rep(c,3) reps(x,-3,4) reps(y,-3,4) {\n\t\t\tint bb = b;\n\t\t\treps(xx,max(x,0),min(x+h[i],4)) reps(yy,max(y,0),min(y+w[i],4)) {\n\t\t\t\tif (s[xx][yy]==c) bb |= (1<<(xx*4+yy));\n\t\t\t\telse bb ^= (bb&1<<(xx*4+yy));\n\t\t\t}\n\t\t\tif (d[bb]>d[b]+1) d[bb] = d[b]+1, q.push(bb);\n\t\t}\n\t}\n\tcout << d[(1<<16)-1] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nint h[10],w[10];\nchar t[16];\nvector<P> G;\nmap<P,bool> used;\nstring str=\"RGB\";\n\nint d[(1<<16)];\n\nint solve(){\n  queue<int> Q;\n  for(int i=0;i<(1<<16);i++)d[i]=-1;\n  d[0]=0;\n  Q.push(0);\n  \n  while(!Q.empty()){\n    int S=Q.front();Q.pop();\n    if(S==(1<<16)-1)return d[S];\n    \n    for(int i=0;i<(int)G.size();i++){\n      int ay=G[i].first/5;\n      int ax=G[i].first%5;\n      int by=G[i].second/5;\n      int bx=G[i].second%5;  \n      for(int j=0;j<3;j++){\n        char ch=str[j];\n        int next=S;\n        for(int y=ay;y<by;y++){\n          for(int x=ax;x<bx;x++){\n            int z=y*4+x;\n            next|=(1<<z);\n            if(t[z]!=ch)next-=(1<<z);\n          }\n        }\n        if(d[next]==-1){\n          d[next]=d[S]+1;\n          Q.push(next);\n        }\n      }\n    }\n\n  }\n  assert(0);\n  return -1;\n}\n\nvoid add(int h,int w){\n  P p;\n  for(int i=-h+1;i<4;i++){\n    for(int j=-w+1;j<4;j++){\n      int ay=max(i,0);\n      int ax=max(j,0);\n      int by=min(i+h,4);\n      int bx=min(j+w,4);\n      p.first=ay*5+ax;\n      p.second=by*5+bx;\n      if(used[p])continue;\n      used[p]=true;\n      G.push_back(p);\n    }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h[i]>>w[i];\n    add(h[i],w[i]);\n  }\n\n  for(int i=0;i<16;i++)cin>>t[i];\n  \n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=1<<16,INF=1<<30;\nvector<int> A,B;\nint dis[MAX];\n\nvoid BFS(){\n    queue<int> Q;\n    Q.push(0);\n    \n    while(!Q.empty()){\n        int u=Q.front();Q.pop();\n        \n        for(int i=0;i<si(A);i++){\n            int v=u;\n            v&=A[i];\n            v|=B[i];\n            if(chmin(dis[v],dis[u]+1)){\n                Q.push(v);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    dis[0]=0;\n    for(int i=1;i<(1<<16);i++) dis[i]=INF;\n    \n    set<int> SE;\n    for(int i=0;i<N;i++){\n        int h,w;cin>>h>>w;\n        for(int uh=-3;uh<=3;uh++){\n            for(int uw=-3;uw<=3;uw++){\n                int nuru=0;\n                for(int dh=0;dh<h;dh++){\n                    for(int dw=0;dw<w;dw++){\n                        int toh=uh+dh,tow=uw+dw;\n                        if(toh<0||toh>=4||tow<0||tow>=4) continue;\n                        nuru|=(1<<(toh*4+tow));\n                    }\n                }\n                SE.insert(nuru);\n            }\n        }\n    }\n    \n    vector<string> S(4);\n    for(int i=0;i<4;i++) cin>>S[i];\n    \n    string T=\"RGB\";\n    \n    for(int a:SE){\n        for(int k=0;k<3;k++){\n            int x=(1<<16)-1;\n            x^=a;\n            A.push_back(x);\n            \n            x=0;\n            \n            for(int i=0;i<4;i++){\n                for(int j=0;j<4;j++){\n                    if(!(a&(1<<(i*4+j)))) continue;\n                    if(T[k]!=S[i][j]) continue;\n                    x|=1<<(i*4+j);\n                }\n            }\n            \n            B.push_back(x);\n        }\n    }\n    \n    BFS();\n    \n    cout<<dis[(1<<16)-1]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> stamp;\n    constexpr char color[] = {'R', 'G', 'B'};\n    vector<int> h(N), w(N);\n    for(int i=0; i<N; ++i) {\n        cin >> h[i] >> w[i];\n    }\n\n    string g;\n    for(int i=0; i<16; ++i) {\n        char c;\n        cin >> c;\n        g += c;\n    }\n\n    for(int i=0; i<N; ++i) {\n        for(int y=-h[i]+1; y<4; ++y) {\n            for(int x=-w[i]+1; x<4; ++x) {\n                for(int c=0; c<3; ++c) {\n                    int flag1 = (1 << 16) - 1;\n                    int flag2 = 0;\n                    for(int k=0; k<h[i]; ++k) {\n                        for(int l=0; l<w[i]; ++l) {\n                            int yy = (y+k)*4, xx = x+l;\n                            if(yy < 0 && 16 <= yy || xx < 0 || 4 <= xx || 16 <= yy+xx) {\n                                continue;\n                            }\n                            if(color[c] == g[yy+xx]) {\n                                flag2 |= (1 << (yy+xx));\n                            } else {\n                                flag1 &= ~(1 << (yy+xx));\n                            }\n                        }\n                    }\n                    stamp.push_back(make_pair(flag1, flag2));\n                }\n            }\n        }\n    }\n    sort(stamp.begin(), stamp.end());\n    stamp.erase(unique(stamp.begin(), stamp.end()), stamp.end());\n\n    queue<int> que;\n    vector<int> dp(1 << 16, INF);\n    dp[0] = 0;\n    que.push(0);\n    while(!que.empty()) {\n        int now = que.front();\n        que.pop();\n        for(auto& s : stamp) {\n            int next = (now & s.first) | s.second;\n            if(dp[next] == INF) {\n                dp[next] = dp[now] + 1;\n                que.push(next);\n            }\n        }\n    }\n    cout << dp[(1 << 16) - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\nstring s[M];\nint d[(1<<N)];\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M,x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<nS)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n\n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n\n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n\n  d[0]=0;\n\n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    int cost=t.first, S=t.second;\n\n    if(S==(1<<N)-1) return cost;\n\n    for(int y=0;y<M;y++){\n\n      for(int x=0;x<M;x++){\n\n\tint idx=y*M+x;\n\n\tif(S&(1<<idx)) continue;\n\n\tfor(int k=0;k<n;k++) mark(cost,S,idx,k);\n\n      }\n      \n    }\n    \n  }\n\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  cout<<bfs()<<endl;    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n],hi=0,wi=0;\n  for(int i=0;i<n;i++){\n    cin>>h[i]>>w[i];\n    if(h[i]>h[hi]) hi=i;\n    if(w[i]>w[wi]) wi=i;\n  }\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  bool used[1<<16];\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<4-h[i];j++){\n\tfor(int k=0;k<4-w[i];k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=0;a<h[i];a++){\n\t      for(int b=0;b<w[i];b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(y<0||y>=4||x<0||x>=4) continue;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n\t}\n      }\n    }\n    for(int j=-3;j<4;j++){\n      for(int k=-3;k<4;k++){\n\tfor(int l=0;l<3;l++){\n\t  int z=bit;\n\t  for(int a=0;a<h[hi];a++){\n\t    for(int b=0;b<w[hi];b++){\n\t      int y=j+a,x=k+b;\n\t      if(y<0||y>=4||x<0||x>=4) continue;\n\t      if(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t      else z&=(1<<16)-(1<<(y*4+x))-1;\n\t    }\n\t  }\n\t  if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t}\n      }\n    }\n    for(int j=-3;j<4;j++){\n      for(int k=-3;k<4;k++){\n\tfor(int l=0;l<3;l++){\n\t  int z=bit;\n\t  for(int a=0;a<h[wi];a++){\n\t    for(int b=0;b<w[wi];b++){\n\t      int y=j+a,x=k+b;\n\t      if(y<0||y>=4||x<0||x>=4) continue;\n\t      if(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t      else z&=(1<<16)-(1<<(y*4+x))-1;\n\t    }\n\t  }\n\t  if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n;\nint h[22],w[22];\nint cm[3];\nint dp[1<<16];\nvector<int> mask;\n\nint dfs(int S){\n  if(dp[S]!=-1)return dp[S];\n  if(S==(1<<16)-1)return 0;\n  int res=INF,preres=INF;\n  for(int msk : mask){\n    rep(c,3){\n      int cov=cm[c]&msk;\n      int del=~(msk^cov);\n      int nS=(S&del)|cov;\n      if(bcnt(nS)>bcnt(S))minch(res,dfs(nS)+1);\n    }\n  }\n  return dp[S]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  rep(i,n)cin>>h[i]>>w[i];\n  rep(i,4){\n    string s;\n    cin>>s;\n    rep(j,4){\n      if(s[j]=='R')cm[0]|=1<<(i*4+j);\n      if(s[j]=='G')cm[1]|=1<<(i*4+j);\n      if(s[j]=='B')cm[2]|=1<<(i*4+j);\n    }\n  }\n\n  rep(k,n){\n    repl(i,-h[k]+1,4)repl(j,-w[k]+1,4){\n      int m=0;\n      repl(ni,i,i+h[k])repl(nj,j,j+w[k]){\n        if(ni>=0&&ni<4&&nj>=0&&nj<4)m|=1<<(ni*4+nj);\n      }\n      mask.pb(m);\n    }\n  }\n  sort(all(mask)); uni(mask);\n\n  rep(S,1<<16)dp[S]=-1;\n  cout<<dfs(0)<<endl;\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<char> vc;\ntypedef vector<vc> Pic;\n\nconst char color[] = {'R', 'G', 'B'};\n\nbool canDelete(Pic& pic, pair<int, int> s, int y, int x, char c){\n\tbool f = false;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tif(pic[i][j] == c) f = true;\n\t\t\tif(pic[i][j] != c and pic[i][j] != '.') return false;\n\t\t}\n\t}\n\treturn f;\n}\nvoid output(Pic pic){\n\tfor(auto i : pic){\n\t\tfor(auto j : i) cout << j;\n\t\tcout << endl;\n\t}\n}\n\nPic getPicDeletedColor(Pic& pic, pair<int, int> s, int y, int x){\n\tPic res = pic;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tres[i][j] = '.';\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstruct P{\n\tint cnt;\n\tPic pic;\n\tP(int cnt, Pic pic) : cnt(cnt), pic(pic) {}\n\tbool operator < ( const P &right ) const {\n\t\treturn cnt < right.cnt;\n\t}\n\tbool operator > ( const P &right ) const {\n\t\treturn cnt > right.cnt;\n\t}\n};\n\nvoid bfs(vector<pair<int, int>>& stamps, Pic& pic){\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.emplace(0, pic);\n\n\tmap<Pic, int> dis;\n\n\tPic endPic(4, vc(4,'.'));\n\n\twhile(not q.empty()){\n\t\tP tmp = q.top(); q.pop();\n\n\t\tPic p = tmp.pic;\n\t\tint cnt = tmp.cnt;\n\n\t\tif(cnt >= 20 or dis.count(p)) continue;\n\t\tdis[p] = cnt;\n\n\t\tif(endPic == p){\n\t\t\tcout << cnt << endl;\n\t\t\treturn;\n\t\t}\n\n\n\t\trep(c,3){\n\t\t\trep(i,stamps.size()){\n\t\t\t\trange(y, 1 - stamps[i].first, 4){\n\t\t\t\t\trange(x, 1 - stamps[i].second, 4){\n\t\t\t\t\t\tif(canDelete(p, stamps[i], y, x, color[c])){\n\t\t\t\t\t\t\t\t//output(getPicDeletedColor(pic, stamps[i], y, x));\n\t\t\t\t\t\t\tq.emplace(cnt + 1, getPicDeletedColor(p, stamps[i], y, x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> stamps(n);\n\trep(i,n){\n\t\tcin >> stamps[i].first >> stamps[i].second;\n\t}\n\n\tPic pic(4, vc(4));\n\trep(i,4) rep(j,4) cin >> pic[i][j];\n\n\tbfs(stamps, pic);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nint w[20];\nint h[20];\nchar field[20][20];\nint ok[4][4][4][4];\nbool visit[1 << 16];\n\nint main() {\n  while (scanf(\"%d\", &n) > 0) {\n    MEMSET(ok, false);\n    REP(i, n) {\n      scanf(\"%d %d\", &h[i], &w[i]);\n    }\n    REP(y, 4) {\n      scanf(\"%s\", field[y]);\n    }\n    FOREQ(x, -3, 3) {\n      FOREQ(y, -3, 3) {\n        REP(i, n) {\n          int lx = max(0, x);\n          int rx = max(0, min(3, x + w[i] - 1));\n          int ly = max(0, y);\n          int ry = max(0, min(3, y + h[i] - 1));\n          ok[lx][ly][rx][ry] = 1;\n        }\n      }\n    }\n\n    MEMSET(visit, false);\n    int mapto[3] = { 'R', 'G', 'B' };\n    visit[0] = true;\n    queue<pair<int, int> > que;\n    que.push(make_pair(0, 0));\n    while (!que.empty()) {\n      const int state = que.front().first;\n      const int cost = que.front().second;\n      que.pop();\n      if (state == (1 << 16) - 1) {\n        printf(\"%d\\n\", cost);\n      }\n      REP(lx, 4) REP(rx, 4) REP(ly, 4) REP(ry, 4) {\n        if (!ok[lx][ly][rx][ry]) { continue; }\n        REP(c, 3) {\n          int ncost = cost + 1;\n          int nstate = state;\n          FOREQ(x, lx, rx) FOREQ(y, ly, ry) {\n            if (field[y][x] == mapto[c]) {\n              nstate |= 1 << (y * 4 + x);\n            } else {\n              nstate &= ~(1 << (y * 4 + x));\n            }\n          }\n          if (visit[nstate]) { continue; }\n          visit[nstate] = true;\n          que.push(make_pair(nstate, ncost));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7], sum[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\trep(i,7) rep(j,7) sum[i][j] = brd[i][j];\n\t\trep(i,7) for(int j = 1; j < 7; j++) sum[i][j] += sum[i][j-1];\n\t\tfor(int i = 1; i < 7; i++) rep(j,7) sum[i][j] += sum[i-1][j];\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tint J = min(j+h[i],7), K = min(k+w[i],7);\n\t\t\t\t\tif(sum[J][K] == 0) continue;\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,bool> dp;\nll compute_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') type = 1;\n      if(stage[y][x] == 'G') type = 2;\n      if(stage[y][x] == 'B') type = 3;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n  return res;\n}\n\nvoid hash2stage(ll hash){\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = hash % 4LL;\n      if(type == 0) stage[y][x] = '.';\n      if(type == 1) stage[y][x] = 'R';\n      if(type == 2) stage[y][x] = 'G';\n      if(type == 3) stage[y][x] = 'B';\n      hash /= 4LL;\n    }\n  }\n}\n\nll compute_clear_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n\n  return res;\n}\n\nvoid print_stage(){\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\n\nclass State {\npublic:\n  ll _hash;\n  int _cost;\n  \n  State(ll hash,int cost) : _hash(hash), _cost(cost) {}\n  bool operator<(const State& s) const {\n    return _cost < s._cost;\n  }\n  bool operator>(const State& s) const {\n    return _cost > s._cost;\n  }\n};\n\nint bfs(){\n\n  priority_queue<State,vector<State>, greater<State> > que;\n  ll init = compute_hash();\n  ll goal = compute_clear_hash();\n  que.push(State(init,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    dp[s._hash] = true;\n    if(s._hash == goal) return s._cost;\n    hash2stage(s._hash);\n\n    for(int ly=0;ly<4;ly++){\n      for(int lx=0;lx<4;lx++){\n        for(int ry=ly;ry<4;ry++){\n          for(int rx=lx;rx<4;rx++){\n            //corner\n            if((lx == 0 && ly == 0)\n               || (lx == 0 && ly == 3)\n               || (rx == 3 && ry == 3)\n               || (rx == 3 && ry == 0)){\n              if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end()) continue;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //left or right\n            else if(lx == 0 || rx == 3){\n              if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end()) continue;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //top or bottom\n            else if(ly == 0 || ry == 3){\n              if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end()) continue;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //center\n            else {\n              if(has_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end()) continue;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return INF;\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\nusing namespace std;\n\nset<int> stamp;\nvector<int> memo(1<<16, -1);\nvector<bitset<16> > color(3);\n\nint solve(bitset<16> bs, int depth)\n{\n\tif(bs.all())\n\t\treturn 0;\n\tif(memo[bs.to_ulong()] != -1)\n\t\treturn memo[bs.to_ulong()];\n\tif(depth > 16)\n\t\treturn INT_MAX / 2;\n\n\tmemo[bs.to_ulong()] = INT_MAX / 2;\n\n\tint ret = INT_MAX / 2;\n\tset<int>::iterator it;\n\tfor(it=stamp.begin(); it!=stamp.end(); ++it){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tif((bitset<16>(*it) & color[i]).none())\n\t\t\t\tcontinue;\n\t\t\tbitset<16> bs2 = bs & ~bitset<16>(*it);\n\t\t\tbs2 |= bitset<16>(*it) & color[i];\n\t\t\tret = min(ret, 1 + solve(bs2, depth+1));\n\t\t}\n\t}\n\n\treturn memo[bs.to_ulong()] = ret;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfor(int j=-3; j<4; ++j){\n\t\t\tfor(int k=-3; k<4; ++k){\n\t\t\t\tbitset<16> bs;\n\t\t\t\tfor(int y=j; y<j+h; ++y){\n\t\t\t\t\tfor(int x=k; x<k+w; ++x){\n\t\t\t\t\t\tif(0 <= y && y <4 && 0 <= x && x < 4)\n\t\t\t\t\t\t\tbs[y*4+x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bs.any())\n\t\t\t\t\tstamp.insert(bs.to_ulong());\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<16; ++i){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R')\n\t\t\tcolor[0][i] = true;\n\t\telse if(c == 'G')\n\t\t\tcolor[1][i] = true;\n\t\telse\n\t\t\tcolor[2][i] = true;\n\t}\n\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> W[i] >> H[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\t  REP(y,-5,9){\n\t    REP(x,-5,9){\n\t      rep(stp,N){\n\t  \n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      if(c == 'X')continue;\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=-3;j<4;j++){\n\tfor(int k=-3;k<4;k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=0;a<h[i];a++){\n\t      for(int b=0;b<w[i];b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(y<0||y>=4||x<0||x>=4) continue;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0) q.push(P(z,d+1));\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, bd[1<<16];\nint H[16], W[16];\nVS orig(4);\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i,N) cin >> H[i] >> W[i];\n  REP(i,4) cin >> orig[i];\n\n  vector<PII> trans[16];\n  REP(i,N){\n\tfor(int y=-H[i]+1;y<4;++y){\n\t  for(int x=-W[i]+1;x<4;++x){\n\t\tfor(int k=0;k<3;++k){\n\t\t  int tmp1 = 0, tmp2 = (1<<16)-1;\n\t\t  char c = \"RGB\"[k];\n\t\t  for(int dy=0;dy<H[i];++dy){\n\t\t\tint ty = y + dy;\n\t\t\tif(ty < 0 || 4 <= ty) continue;\n\t\t\tfor(int dx=0;dx<W[i];++dx){\n\t\t\t  int tx = x + dx;\n\t\t\t  if(tx < 0 || 4 <= tx) continue;\n\t\t\t  if(c == orig[ty][tx])\n\t\t\t\ttmp1 |= (1 << (ty*4+tx));\n\t\t\t  else\n\t\t\t\ttmp2 &= ~(1 << (ty*4+tx));\n\t\t\t}\n\t\t  }\n\t\t  trans[i].PB(MP(tmp1,tmp2));\n\t\t}\n\t  }\n\t}\n  }\n\n  \n  priority_queue<PII, vector<PII>, greater<PII>> pq;\n  fill(bd, bd+(1<<16), 1000);\n  bd[0] = 0;\n  pq.push(MP(0,0));\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint ct = pii.first;\n\tint state = pii.second;\n\tif(ct > bd[state]) continue;\n\n\tREP(i,16){\n\t  for(PII& pii: trans[i]){\n\t\tint tmp = state;\n\t\ttmp |= pii.first;\n\t\ttmp &= pii.second;\n\t\tif(bd[tmp] > ct+1){\n\t\t  bd[tmp] = ct + 1;\n\t\t  pq.push(MP(bd[tmp], tmp));\n\t\t}\n\t  }\n\t}\n  }\n  \n\n  cout << bd[(1<<16)-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\nint H[20], W[20];\nint dp[1 << 16];\nvector<string> board;\nconst string alph = \"RGB\";\n\nint solve() {\n    queue<int> q; q.push(0);\n    while(!q.empty()) {\n        int bit = q.front(); q.pop();\n        if(bit == (1 << 16) - 1) return dp[bit];\n        // i テァツ閉ェテァツ崢ョテ」ツ?ョテ」ツつケテ」ツつソテ」ツδウテ」ツδ療」ツ?ョテ・ツキツヲテ、ツクツ甘」ツつ?(j, k) テ」ツ?ォテ・ツ青暗」ツつ湘」ツ?崚」ツ?ヲティツ可イ s テ」ツ?ァテヲツ環シテ」ツ??\n        rep(i,0,N) rep(j,-H[i]+1,4) rep(k,-W[i]+1,4) rep(s,0,3) {\n            int nbit = bit;\n            rep(x, max(j,0LL), min(j+H[i],4LL)) rep(y, max(k,0LL), min(k+W[i],4LL)) {\n                int idx = x * 4 + y;\n                if(board[x][y] == alph[s]) nbit |= (1 << idx);\n                else if(nbit >> idx & 1) nbit ^= (1 << idx);\n            }\n            if(dp[nbit] < 0) {\n                dp[nbit] = dp[bit] + 1;\n                q.push(nbit);\n            }\n        }\n    }\n    return 0;\n}\n\nsigned main() {\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n\n    cin >> N;\n    rep(i,0,N) cin >> H[i] >> W[i];\n    rep(i,0,4) {\n        string s; cin >> s;\n        board.push_back(s);\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    vector<int> cost(1<<16,inf);\n    queue<bitset<16>> que;\n    cost[0]=0;\n    que.push(bitset<16>(0));\n    while(!que.empty()){\n        auto bs=que.front();\n        que.pop();\n        int state=encode(bs);\n        if(bs.all()){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-3,4) rep(x,-3,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            if(y2<=0 or x2<=0) continue;\n            rep(j,0,3){\n                auto next_bs=bs;\n                bool ok=false;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j){\n                        next_bs.set(4*y_+x_);\n                        ok=true;\n                    }else next_bs.reset(4*y_+x_);\n                }\n                if(!ok) continue;\n                int next_state=encode(next_bs);\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(next_bs);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,v.size()){\n      int y=v[k].first;\n      int x=v[k].second;\n      for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n          for(int col=0;col<3;col++){\n            r(kk,4)tmp[kk]=t[kk];\n            //if(p.second==0)r(kk,4)cout<<tmp[kk]<<endl;\n            for(int i1=i,c1=0;c1<y;c1++,i1++){\n              for(int j1=j,c2=0;c2<x;c2++,j1++){\n                if(0<=i1&&i1<4&&0<=j1&&j1<4)tmp[i1][j1]=ccol[col];\n              }\n            }\n            int tp=0;\n            //if(p.second==2)r(kk,4)cout<<tmp[kk]<<endl;\n            r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n            //cout<<p.second<<' '<<(__builtin_popcount(tp))<<endl;\n            if(!dp[tp]){\n              dp[tp]=1;\n              q.push(P(tp,p.second+1));\n            }\n          }\n        }\n      }\n    }\n    r(k,v.size()){\n      int y=v[k].first;\n      int x=v[k].second;\n      for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n          for(int col=0;col<3;col++){\n            r(kk,4)tmp[kk]=t[kk];\n            //if(p.second==0)r(kk,4)cout<<tmp[kk]<<endl;\n            for(int i1=i,c1=0;c1<y;c1++,i1--){\n              for(int j1=j,c2=0;c2<x;c2++,j1--){\n                if(0<=i1&&i1<4&&0<=j1&&j1<4)tmp[i1][j1]=ccol[col];\n              }\n            }\n            int tp=0;\n            //if(p.second==2)r(kk,4)cout<<tmp[kk]<<endl;\n            r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n            //cout<<p.second<<' '<<(__builtin_popcount(tp))<<endl;\n            if(!dp[tp]){\n              dp[tp]=1;\n              q.push(P(tp,p.second+1));\n            }\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> H(N), W(N);\n  REP(i, 0, N) cin >> H[i] >> W[i];\n  char S[4][4];\n  REP(i, 0, 4) REP(j, 0, 4) cin >> S[i][j];\n\n  vector<ll> dp(1LL << 16, -1);\n  queue<ll> q;\n  q.push(0);\n  dp[0] = 0;\n  while(q.size()) {\n    ll s = q.front(); q.pop();\n    REP(i, 0, N) {\n      REP(py, -H[i] + 1, 4) REP(px, -W[i] + 1, 4) REP(c, 0, 3) {\n        ll n = s;\n        REP(y, max(py, 0LL), min(py + H[i], 4LL)) REP(x, max(px, 0LL), min(px + W[i], 4LL)) {\n          const string Z = \"RGB\";\n          if(S[y][x] == Z[c]) n = n | (1LL << (y * 4 + x));\n          else n = ~(~n | (1LL << (y * 4 + x)));\n        }\n        if(dp[n] == -1) {\n          dp[n] = dp[s] + 1;\n          q.push(n);\n          if(n == (1LL << 16) - 1) {\n            cout << dp[(1LL << 16) - 1] << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\nconst char color_list[] = {'R', 'G', 'B'};\n\nint stamp(int status, const pair<int, int>& stamp, int pos_h, int pos_w, char color, const vector<char>& c){\n  int up = max(pos_h, 0);\n  int down = min(stamp.first + pos_h, 4);\n  int left = max(pos_w, 0);\n  int right = min(stamp.second + pos_w, 4);\n\n  int stamp_bit = 0;\n  for(int i = up; i < down; i++)\n    for(int j = left; j < right; j++)\n      stamp_bit |= 1 << ((i * 4) + j);\n\n  for(int i = 0; i < 16; i++){\n    if((stamp_bit & (1 << i)) != 0){\n      if(color == c[i]){ status |= (1 << i); }\n      else{ status &= ~(1 << i); }\n    }\n  }\n\n  return status;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n\n  int h, w;\n  vector<pair<int, int> > stamps;\n  for(int i = 0; i < n; i++){\n    cin >> h >> w;\n    stamps.push_back(make_pair(h, w));\n  }\n  vector<char> c(16);\n  for(int i = 0; i < 16; i++){ cin >> c[i]; }\n\n  \n  int ans = INF;\n  const int goal = (1 << 16) - 1;\n\n  // テ・ツケツ?・ツ?ェテ・ツ?暗」ツ?凖」ツつ?\n  vector<bool> used(1 << 16, false);\n  queue<pair<int, int> > wait;\n  wait.push(make_pair(0, 0));\n  used[0] = true;\n  while(!wait.empty()){\n    int cost = wait.front().first;\n    int status = wait.front().second;\n    wait.pop();\n\n    if(status == goal){\n      ans = cost;\n      break;\n    }\n\n    for(int i = 0; i < n; i++){\n      for(int z = 0; z < 3; z++){\n        for(int x = -3; x < 4; x++){\n          for(int y = -3; y < 4; y++){\n            int next_status = stamp(status, stamps[i], x, y, color_list[z], c);\n            if(!used[next_status]){\n              used[next_status] = true;\n              wait.push(make_pair(cost + 1, next_status));\n            }    \n          }\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst char of[] = \"RGB\";\n\nint N, H[20], W[20];\nchar f[4][4];\nint Qi, Qn, Q[65536], dp[65536];\nint m, mask[2048], chg[256][4];\n\nint main() {\n    scanf(\"%d\", &N);\n    rep(i, N) scanf(\"%d%d\", H+i, W+i);\n    rep(i, 4) rep(j, 4) scanf(\" %c\", f[i]+j);\n    memset(dp, -1, sizeof(dp));\n    rep(k, N) {\n        for(int i=-4; i<4; i++) for(int j=-4; j<4; j++) {\n            int b = 0;\n            rep(x, 4) rep(y, 4) if(i<=x && x<i+H[k] && j<=y && y<j+W[k]) {\n                b |= 1<<(x*4+y);\n            }\n            mask[m++] = b;\n        }\n    }\n    sort(mask, mask+m);\n    m = unique(mask, mask+m)-mask;\n    rep(i, m) rep(x, 4) rep(y, 4) if(mask[i]&(1<<(x*4+y))) {\n        rep(k, 3) if(f[x][y]==of[k]) chg[i][k] |= 1<<(x*4+y);\n    }\n    dp[0] = 0;\n    Q[Qn++] = 0;\n    while(Qi<Qn && dp[65535]==-1) {\n        const int cur = Q[Qi++];\n        rep(i, m) rep(k, 3) {\n            const int nxt = (cur&~mask[i]) | chg[i][k];\n            if(dp[nxt]==-1) {\n                dp[nxt] = dp[cur]+1;\n                Q[Qn++] = nxt;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[65535]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\n\tint ny=y-i+k;\n\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=n-1;k>=0;k--) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\n\nvoid Min(int &a,int b){a=min(a,b);}\nint Idx(int y,int x){return y*4+x;}\n\nint nbit(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\n\nint DP(){\n  vector<int>dp(1<<16,INF);\n  for(int bit=0;bit<(1<<16);bit++){\n\n    for(int i=0;i<3;i++)\n      for(int a=0;a<16;a++)\n\tfor(int b=0;b<16;b++)\n\t  if(can[a][b]){\n\t    data yx=(data){a/4,a%4};\n\t    data YX=(data){b/4,b%4};\n\t    Min(dp[nbit(bit,yx,YX,RGB[i])],dp[bit]+1);\n\t  }\n  }\n  return dp[(1<<16)-1];\n}\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<char> vc;\ntypedef vector<vc> Pic;\n\nclass Bit{\n\tint bit;\n\tpublic:\n\tBit() : bit(0) { }\n\tbool at(int i, int j){\n\t\treturn ( bit >> (i * 4 + j) ) & 1;\n\t}\n\tvoid set(int i, int j){\n\t\tbit |= 1 << (i * 4 + j);\n\t}\n\tint get(){\n\t\treturn bit;\n\t}\n};\n\nconst char color[] = {'R', 'G', 'B'};\n\nbool canDelete(Pic& pic, Bit& b, pair<int, int> s, int y, int x, char c){\n\tbool f = false;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tif(not b.at(i,j)) f = true;\n\t\t\tif(pic[i][j] != c and not b.at(i,j)) return false;\n\t\t}\n\t}\n\treturn f;\n}\nvoid output(Bit b){\n}\n\nBit getUpdatedBit(Bit& b, pair<int, int> s, int y, int x){\n\tBit res = b;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tres.set(i,j);\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct P{\n\tint cnt;\n\tBit bit;\n\tP(int cnt, Bit bit) : cnt(cnt), bit(bit) {}\n\tbool operator < ( const P &right ) const {\n\t\treturn cnt < right.cnt;\n\t}\n\tbool operator > ( const P &right ) const {\n\t\treturn cnt > right.cnt;\n\t}\n};\n\nvoid bfs(vector<pair<int, int>>& stamps, Pic& pic){\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\t//queue<P> q;\n\tq.emplace(0, Bit());\n\n\tvector<int> dis(1 << 16, 1e9);\n\tdis[0] = 0;\n\n\twhile(not q.empty()){\n\t\tP tmp = q.top(); q.pop();\n\n\t\tBit b = tmp.bit;\n\t\tint cnt = tmp.cnt;\n\n\n\t\t//if(dis.at(b.get()) <= cnt) continue;\n\t\t//dis[b.get()] = cnt;\n\n\t\tif((1 << 16) - 1 == b.get()){\n\t\t\tcout << cnt << endl;\n\t\t\treturn;\n\t\t}\n\n\t\trep(c,3){\n\t\t\trep(i,stamps.size()){\n\t\t\t\trange(y, 1 - stamps[i].first, 4){\n\t\t\t\t\trange(x, 1 - stamps[i].second, 4){\n\t\t\t\t\t\tif(canDelete(pic, b, stamps[i], y, x, color[c])){\n\t\t\t\t\t\t\tBit tmp = getUpdatedBit(b, stamps[i], y, x);\n\t\t\t\t\t\t\tif(dis.at(tmp.get()) > cnt + 1){\n\t\t\t\t\t\t\t\tdis[tmp.get()] = cnt + 1;\n\t\t\t\t\t\t\t\tq.emplace(cnt + 1, getUpdatedBit(b, stamps[i], y, x));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> stamps(n);\n\trep(i,n){\n\t\tcin >> stamps[i].first >> stamps[i].second;\n\t}\n\n\tPic pic(4, vc(4));\n\trep(i,4) rep(j,4) cin >> pic[i][j];\n\n\tbfs(stamps, pic);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define FOR_SUBSET(b, a) for(int b = a; b != 0; b = (b-1)&a)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\nconst int MAX = 20;\nconst int INF = 1<<29;\n\nint dp[1<<17];\nint n;\nint a[MAX], b[MAX];\n\nchar field[4][4];\nchar color[3] = {'R', 'G', 'B'};\n\nint ind(int i, int j) {\n    return i*4+j;\n}\n\nvoid debug(int bit) {\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cout << ((bit & (1<<ind(i,j))) != 0);\n        }\n        cout << endl;\n    }\n    cout << \" : \" << dp[bit] << endl << endl;\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> n) {\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i] >> b[i];\n        }\n        for (int i = 0; i < 4; ++i) \n            for (int j = 0; j < 4; ++j)\n                cin >> field[i][j];\n        \n        for (int bit = 0; bit < (1<<16); ++bit) dp[bit] = INF;\n        dp[0] = 0;\n        \n        for (int bit = 0; bit < (1<<16); ++bit) {\n            \n            //debug(bit);\n            \n            for (int id = 0; id < n; ++id) {\n                int from1 = 1 - a[id], from2 = 1-b[id];\n                for (int i = from1; i < 4; ++i) {\n                    for (int j = from2; j < 4; ++j) {\n                        for (int col = 0; col < 3; ++col) {\n                            char c = color[col];\n                            bool ok = true;\n                            int addbit = 0;\n                            for (int k = max(0, i); k < min(4, i+a[id]); ++k) {\n                                for (int l = max(0, j); l < min(4, j+b[id]); ++l) {\n                                    if ((bit & (1<<ind(k,l))) && field[k][l] != c) ok = false;\n                                    if (!(bit & (1<<ind(k,l))) && field[k][l] == c) addbit += 1<<ind(k,l);\n                                }\n                            }\n                            if (ok) {\n                                FOR_SUBSET(subbit, addbit) {\n                                    int nbit = bit | subbit;\n                                    dp[nbit] = min(dp[nbit], dp[bit]+1);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << dp[(1<<16)-1] << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<char> vc;\ntypedef vector<vc> Pic;\n\nconst char color[] = {'R', 'G', 'B'};\n\nbool canDelete(Pic& pic, pair<int, int> s, int y, int x, char c){\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tif(pic[i][j] != c and pic[i][j] != '.') return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid output(Pic pic){\n\tfor(auto i : pic){\n\t\tfor(auto j : i) cout << j;\n\t\tcout << endl;\n\t}\n}\n\nPic getPicDeletedColor(Pic& pic, pair<int, int> s, int y, int x){\n\tPic res = pic;\n\trange(i,y,y + s.first){\n\t\trange(j,x,x + s.second){\n\t\t\tif(i < 0 or j < 0 or i >= 4 or j >= 4) continue;\n\t\t\tres[i][j] = '.';\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstruct P{\n\tint cnt;\n\tPic pic;\n\tP(int cnt, Pic pic) : cnt(cnt), pic(pic) {}\n\tbool operator < ( const P &right ) const {\n\t\treturn cnt < right.cnt;\n\t}\n\tbool operator > ( const P &right ) const {\n\t\treturn cnt > right.cnt;\n\t}\n};\n\nvoid bfs(vector<pair<int, int>>& stamps, Pic& pic){\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.emplace(0, pic);\n\n\tmap<Pic, int> dis;\n\n\tPic endPic(4, vc(4,'.'));\n\n\twhile(not q.empty()){\n\t\tP tmp = q.top(); q.pop();\n\n\t\tPic p = tmp.pic;\n\t\tint cnt = tmp.cnt;\n\n\t\tif(dis.count(p)) continue;\n\t\tdis[p] = cnt;\n\n\t\tif(endPic == p){\n\t\t\tcout << cnt << endl;\n\t\t\treturn;\n\t\t}\n\n\n\t\trep(c,3){\n\t\t\trep(i,stamps.size()){\n\t\t\t\trange(y, 1 - stamps[i].first, 4){\n\t\t\t\t\trange(x, 1 - stamps[i].second, 4){\n\t\t\t\t\t\tif(canDelete(p, stamps[i], y, x, color[c])){\n\t\t\t\t\t\t\t\t//output(getPicDeletedColor(pic, stamps[i], y, x));\n\t\t\t\t\t\t\tq.emplace(cnt + 1, getPicDeletedColor(p, stamps[i], y, x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> stamps(n);\n\trep(i,n){\n\t\tcin >> stamps[i].first >> stamps[i].second;\n\t}\n\n\tPic pic(4, vc(4));\n\trep(i,4) rep(j,4) cin >> pic[i][j];\n\n\tbfs(stamps, pic);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = numeric_limits<int>::max()/2;\n\nint n;\nvector<P> stmp;\nvector<vector<int>> col(4,vector<int>(4));\n\nint solve(){\n    vector<int> dis(1<<16,INF);\n    vector<vector<int>> pic(4,vector<int>(4));\n    queue<int> q;\n    dis[0]=0;\n    q.push(0);\n    while(!q.empty()){\n        int prev=q.front();q.pop();\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=2;j++){\n                // stamp[i] with color_j\n                int h=stmp[i].first,w=stmp[i].second;\n                for(int sx=1-h;sx<4;sx++){\n                    for(int sy=1-w;sy<4;sy++){\n                        \n                        for(int ni=0;ni<4;ni++)for(int nj=0;nj<4;nj++){\n                            int num=15-4*ni-nj; pic[ni][nj]=(prev>> num)&1;\n                        }\n\n                        for(int ni=0;ni<h;ni++){\n                            for(int nj=0;nj<w;nj++){\n                                int nx=sx+ni,ny=sy+nj;\n                                if(nx<0 || 4<=nx || ny<0 || 4<=ny) continue;\n                                \n                                if(col[nx][ny]==j) pic[nx][ny]=1;\n                                else pic[nx][ny]=0; \n                            }\n                        }\n                        int next=0;\n                        for(int ni=0;ni<4;ni++)for(int nj=0;nj<4;nj++){\n                            if(pic[ni][nj]==0) continue;\n                            int num=15-4*ni-nj; next |= (1<<num);\n                        }\n                        if(dis[next]!=INF) continue;\n                        dis[next]=dis[prev]+1;\n                        if(next==((1<<16)-1)) return dis[next];\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int h,w;cin>>h>>w;\n        stmp.push_back(P(h,w));\n    }\n    for(int i=0;i<4;i++){\n        string s;cin>>s;\n        for(int j=0;j<4;j++){\n            if(s[j]=='R') col[i][j]=0;\n            else if(s[j]=='G') col[i][j]=1;\n            else col[i][j] = 2;\n        }\n    }\n    cout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int N;\n  cin >> N;\n  vector<int> H(N), W(N);\n  for (int i = 0; i < N; i++){\n    cin >> H[i] >> W[i];\n  }\n  vector<vector<char>> C(4, vector<char>(4));\n  for (int i = 0; i < 4; i++){\n    for (int j = 0; j < 4; j++){\n      cin >> C[i][j];\n    }\n  }\n  string S = \"RGB\";\n  set<pair<int, int>> st;\n  for (int i = 0; i < N; i++){\n    for (int j = 1 - H[i]; j < 4; j++){\n      for (int k = 1 - W[i]; k < 4; k++){\n        for (int l = 0; l < 3; l++){\n          int add = 0;\n          int sub = 0;\n          for (int m = 0; m < H[i]; m++){\n            for (int n = 0; n < W[i]; n++){\n              int y = j + m;\n              int x = k + n;\n              if (0 <= y && y < 4 && 0 <= x && x < 4){\n                if (C[y][x] == S[l]){\n                  add |= 1 << (y * 4 + x);\n                } else {\n                  sub |= 1 << (y * 4 + x);\n                }\n              }\n            }\n          }\n          st.insert(make_pair(add, sub));\n        }\n      }\n    }\n  }\n  vector<int> d(65536, -1);\n  d[0] = 0;\n  queue<int> Q;\n  Q.push(0);\n  while (!Q.empty()){\n    int c = Q.front();\n    Q.pop();\n    for (auto P : st){\n      int c2 = c & ~P.second | P.first;\n      if (d[c2] == -1){\n        d[c2] = d[c] + 1;\n        Q.push(c2);\n      }\n    }\n  }\n  cout << d[65535] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nmap< vector< vector<char> > , int> done[50];\nvector< vector<char> > goal(7,vector<char>(7));\n\nint w[20],h[20];\nint f(int pos , vector< vector<char> > &c){\n\tif(pos == 49){\n\t\trep(i,4)rep(j,4){\n\t\t\tif(c[i+3][j+3] == 0) return 999999;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(done[pos].find(c) != done[pos].end()) return done[pos][c];\n\tint x = pos % 7;\n\tint y = pos / 7;\n\tint ans = 999999;\n\tif(x < 3 || y < 3 || c[y][x])ans = f(pos+1,c);\n\n\trep(i,n){\n\t\trep(color,3){\n\t\t\tif( x < 3 || y < 3 || goal[y][x] == color){\n\t\t\t\tvector< vector<char> > t = c;\n\t\t\t\trep(j,h[i]){\n\t\t\t\t\trep(k,w[i]){\n\t\t\t\t\t\tint tx = x+k;\n\t\t\t\t\t\tint ty = y+j;\n\t\t\t\t\t\tif(tx >= 7 || ty >= 7 || tx < 3 || ty < 3 )continue;\n\t\t\t\t\t\tif(color == goal[ty][tx])t[ty][tx] = 1;\n\t\t\t\t\t\telse t[ty][tx] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = min(f(pos+1,t)+1,ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn done[pos][c] = ans;\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tvector< vector<char> > init(7,vector<char>(7,0));\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[3+i][3+j] = c;\n\t}\n\tcout << f(0,init) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi hs(n),ws(n);\n\t\trep(i,n) cin>>hs[i]>>ws[i];\n\t\tvs grid(4);\n\t\trep(i,4) cin>>grid[i];\n\t\t\n\t\tqueue<pii> q;\n\t\tq.emplace(0,0);\n\t\tvi vis(1<<16);\n\t\twhile(q.size()){\n\t\t\tint bit,turn; tie(bit,turn)=q.front(); q.pop();\n\t\t\tif(bit==(1<<16)-1){\n\t\t\t\tcout<<turn<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[bit]) continue;\n\t\t\tvis[bit]=1;\n\t\t\t\n\t\t\trep(k,n){\n\t\t\t\trepi(i0,-hs[k]+1,4) repi(j0,-ws[k]+1,4){\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tchar color='?';\n\t\t\t\t\tint mask=0;\n\t\t\t\t\trep(i,hs[k]) rep(j,ws[k]){\n\t\t\t\t\t\tif(i0+i<0 || 4<=i0+i || j0+j<0 || 4<=j0+j) continue;\n\t\t\t\t\t\tmask|=1<<(i0+i)*4+(j0+j);\n\t\t\t\t\t\tif(bit>>(i0+i)*4+(j0+j)&1) continue;\n\t\t\t\t\t\tif(color=='?') color=grid[i0+i][j0+j];\n\t\t\t\t\t\tif(grid[i0+i][j0+j]!=color) ok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) q.emplace(bit|mask,turn+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nmap< vector< vector<char> > , int> done;\nvector< vector<char> > goal(7,vector<char>(7));\nvector< vector<char> > good(8,vector<char>(8,0)) ;\n\nint w[20],h[20];\nint f(vector< vector<char> > &c){\n\tqueue< vector< vector<char> > > Q;\n\tQ.push(c);\n\tdone[c] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector< vector<char> > &q = Q.front(); Q.pop();\n\t\tint cost = done[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(x,7)rep(y,7){\n\t\t\trep(i,n){\n\t\t\t\trep(color,3){\n\t\t\t\t\tif( x < 3 || y < 3 || goal[y][x] == color){\n\t\t\t\t\t\tvector< vector<char> > t = c;\n\t\t\t\t\t\trep(j,h[i]){\n\t\t\t\t\t\t\trep(k,w[i]){\n\t\t\t\t\t\t\t\tint tx = x+k;\n\t\t\t\t\t\t\t\tint ty = y+j;\n\t\t\t\t\t\t\t\tif(tx >= 7 || ty >= 7 || tx < 3 || ty < 3 )continue;\n\t\t\t\t\t\t\t\tif(color == goal[ty][tx])t[ty][tx] = 1;\n\t\t\t\t\t\t\t\telse t[ty][tx] = 0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(done.find(t) == done.end()){\n\t\t\t\t\t\t\tdone[t] = cost + 1;\n\t\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tvector< vector<char> > init(8,vector<char>(8,0)) ;\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[3+i][3+j] = c;\n\t}\n\trep(i,4)rep(j,4) good[i+3][j+3] = 1;\n\t\n\tcout << f(0,init) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct rect {\n  int x1,y1;\n  int x2,y2;\n};\nconst bool operator<(const rect &a, const rect &b) {\n  return a.x1!=b.x1?a.x1<b.x1:a.y1!=b.y1?a.y1<b.y1 :\n    a.x2!=b.x2?a.x2<b.x2:a.y2<b.y2;\n}\n\nbool visited[1<<16];\n\nint main() {\n  int n;\n  cin >> n;\n  set<rect> se;\n\n  REP(i,n) {\n    int h, w;\n    cin >> h >> w;\n    for (int r=-3; r<=3; ++r) {\n      for (int c=-3; c<=3; ++c) {\n        int x1=4,y1=4,x2=0,y2=0;\n        for (int rr=max(0,r); rr<min(4,r+h); ++rr) {\n          for (int cc=max(0,c); cc<min(4,c+w); ++cc) {\n            x1 = min(x1, cc);\n            y1 = min(y1, rr);\n            x2 = max(x2, cc);\n            y2 = max(y2, rr);\n          }\n        }\n        if (x1!=4) {\n          se.insert((rect){x1,y1,x2,y2});\n        }\n      }\n    }\n  }\n  int ba[4][4];\n  REP(i,4) {\n    REP(j,4) {\n      char c;\n      cin >> c;\n      if (c=='R') ba[i][j] = 0;\n      else if (c=='G') ba[i][j] = 1;\n      else ba[i][j] = 2;\n    }\n  }\n\n  vector<int> correct;\n  vector<int> wrong;\n\n  FOR(it, se) {\n//    printf(\"(%d,%d) (%d,%d)\\n\", it->x1,it->y1,it->x2,it->y2);\n    int x1=it->x1,y1=it->y1,x2=it->x2,y2=it->y2;\n    REP(c, 3) {\n      int cor=0, wro=0;\n      for (int x=x1;x<=x2;++x) {\n        for (int y=y1;y<=y2;++y) {\n          if (ba[y][x] == c) cor |= 1<<(y*4+x);\n          else wro |= 1<<(y*4+x);\n        }\n      }\n      // if (x1==2&&y1==1&&x2==2&&y2==1) {\n      //   cout << cor << \" \" << wro << endl;\n      // }\n      correct.push_back(cor);\n      wrong.push_back(wro);\n    }\n  }\n  int m = correct.size();\n  typedef pair<int,int> pii;\n  queue<pii> Q;\n  Q.push(pii(0,0));\n  while(!Q.empty()) {\n    pii p = Q.front(); Q.pop();\n    int S = p.first, num = p.second;\n    if (visited[S]) continue;\n    // if (num == 1) {\n    //   stringstream ss;\n    //   ss << bitset<16>(S);\n    //   string s = ss.str();\n    //   if (s[6]=='1') {\n    //     REP(i,4) {\n    //       REP(j,4) {\n    //         cout << s[i*4+j];\n    //       }\n    //       cout << endl;\n    //     }\n    //     cout << endl;\n    //   }\n    // }\n      //cout << S << endl;\n    visited[S] = 1;\n    if (S==(1<<16)-1) {\n      cout << num << endl;\n      break;\n    }\n    REP(i, m) {\n      int s = S;\n      s |= correct[i];\n      s &= ~wrong[i];\n      if (!visited[s]) {\n        Q.push(pii(s, num+1));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nvector<int> mask1,mask2;\n\nvector< vector<char> > goal(4,vector<char>(4));\n\nint w[20],h[20];\n\ninline void gen(int s,int x,int y){\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask1.push_back(a);\n\t\tmask2.push_back(b);\n\t}\n}\nint f(int init){\n\tQ[size++] = init;\n\tmemo[init] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,mask1.size()){\n\t\t\tint bit = (q & ~mask1[i]) | mask2[i];\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[i][j] = c;\n\t}\n\t\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\n\t\n\tcout << f(0) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  bool used[1<<16];\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=-h[i]+1;j<h[i];j++){\n\tfor(int k=-w[i]+1;k<w[i];k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=0;a<h[i];a++){\n\t      for(int b=0;b<w[i];b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(y<0||y>=4||x<0||x>=4) continue;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000001;\n\nchar color[] = \"RGB\";\n\nint main() {\n  int n;\n  cin>>n;\n  vector<pair<int,int>> s;\n  REP(i,n) {\n    int h,w;\n    cin>>h>>w;\n    s.emplace_back(h,w);\n  }\n  string t;\n  REP(i,4) {\n    string s;\n    cin>>s;\n    t += s;\n  }\n  vector<int> dp(1<<16, INF);\n  dp[0] = 0;\n  REP(i,1<<16) {\n    REP(j,n) {\n      int h,w;\n      tie(h,w) = s[j];\n      FOR(y,-h+1,4)FOR(x,-w+1,4) {\n        int bits = 0;\n        REP(k,h)REP(l,w) {\n          int py = y + k;\n          int px = x + l;\n          if (px < 0 || px >=4 || py < 0 || py >= 4) continue;\n          int index = px + 4*py;\n          if ((i >> index) & 1) continue;\n          bits |= 1 << index;\n        }\n        if (bits == 0) continue;\n        REP(k,3) {\n          bool ok = true;\n          REP(l,16) {\n            if ((bits >> l) & 1) {\n              if (t[l] != color[k]) {\n                ok = false;\n                break;\n              }\n            }\n          }\n          if (ok) {\n            dp[i|bits] = min(dp[i|bits], dp[i] + 1);\n          }\n        }\n      }\n    }\n  }\n  cout << dp[(1<<16)-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  bool used[1<<16];\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=-h[i]+1;j<4;j++){\n\tfor(int k=-w[i]+1;k<4;k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=0;a<h[i];a++){\n\t      for(int b=0;b<w[i];b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(y<0||y>=4||x<0||x>=4) continue;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tif(j+h[i] < 3 || k+w[i] < 3) continue;\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<pair<int,int> > p;\n\tfor(int i=0;i<n;i++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tp.PB(MP(h,w));\n\t}\n\tvector<vector<vector<pair<int,int> > > >sp(n);\n\tfor(int qq=0;qq<n;qq++){\n\t\tfor(int i=-3;i<=3;i++){\n\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\tvector<pair<int,int> > z;\n\t\t\t\tfor(int x = 0;x<p[qq].first;x++){\n\t\t\t\t\tfor(int y=0;y<p[qq].second;y++){\n\t\t\t\t\t\tif(i+x>=0&&i+x<=3&&j+y>=0&&j+y<=3){\n\t\t\t\t\t\t\tz.PB(MP(i+x,j+y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(z.size()!=0)sp[qq].PB(z);\n\t\t\t}\n\t\t}\n\t}\n\t// for(int i=0;i<n;i++){\n\t// \tfor(int j=0;j<sp[i].size();j++){\n\t// \t\tfor(int k=0;k<sp[i][j].size();k++){\n\t// \t\t\tcout << sp[i][j][k].first << \" \" << sp[i][j][k].second << \" \";\n\t// \t\t}\n\t// \t\tcout << endl;\n\t// \t}\n\t// }\n\tstring s[4];\n\tfor(int i=0;i<4;i++){\n\t\tcin >> s[i];\n\t}\n\tint a[4][4];\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(s[i][j]=='R'){\n\t\t\t\ta[i][j] = 1;\n\t\t\t}else if(s[i][j]=='G'){\n\t\t\t\ta[i][j] = 2;\n\t\t\t}else{\n\t\t\t\ta[i][j] = 3;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > v(4,vector<int>(4));\n\tint ans=0;\n\tqueue<pair<vector<vector<int> >,int > >q;\n\tbool used[100010];\n\tused[0] = 1;\n\tq.push(MP(v,0));\n\twhile(!q.empty()){\n\t\tauto x = q.front();\n\t\tq.pop();\n\t\tauto f = x.first;\n\t\t// cout <<x.second << endl;\n\t\t// for(int i=0;i<4;i++){\n\t\t// \tfor(int j=0;j<4;j++){\n\t\t// \t\tcout << f[i][j] << \" \" ;\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\tint g = x.second;\n\t\tbool flag = 1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(f[i][j]==0){\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tans = g;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int qq=0;qq<n;qq++){\n\t\t\tfor(int c=1;c<4;c++){\n\t\t\t\tfor(int k = 0;k<sp[qq].size();k++){\n\t\t\t\t\tauto ss = f;\n\t\t\t\t\tauto w = sp[qq][k];\n\t\t\t\t\tfor(int i=0;i<w.size();i++){\n\t\t\t\t\t\tif(a[w[i].first][w[i].second]==c){\n\t\t\t\t\t\t\tss[w[i].first][w[i].second]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tss[w[i].first][w[i].second]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint s=0;\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint tmp = 1;\n\t\t\t\t\t\tfor(int ccc=0;ccc<4*i;ccc++){\n\t\t\t\t\t\t\ttmp*=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\t\tif(ss[i][j]==1){\n\t\t\t\t\t\t\t\ts+=tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp*=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(used[s]!=1){\n\t\t\t\t\t\tused[s]=1;\n\t\t\t\t\t\tq.push(MP(ss,g+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,v=1<<16;\n  cin>>n;\n  int h[n],w[n],dp[v],used[v];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(int i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=v-1-(1<<(y*4+x));\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[v-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint calc(int a,int b){\n\tint tmp = 1;\n\tfor(int ccc=0;ccc<4*a;ccc++){\n\t\ttmp*=2;\n\t}\n\tfor(int j=0;j<b;j++){\n\t\ttmp*=2;\n\t}\n\treturn tmp;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<pair<int,int> > p;\n\tfor(int i=0;i<n;i++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tp.PB(MP(h,w));\n\t}\n\tvector<vector<vector<pair<int,int> > > >sp(n);\n\tfor(int qq=0;qq<n;qq++){\n\t\tfor(int i=-3;i<=3;i++){\n\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\tvector<pair<int,int> > z;\n\t\t\t\tfor(int x = 0;x<p[qq].first;x++){\n\t\t\t\t\tfor(int y=0;y<p[qq].second;y++){\n\t\t\t\t\t\tif(i+x>=0&&i+x<=3&&j+y>=0&&j+y<=3){\n\t\t\t\t\t\t\tz.PB(MP(i+x,j+y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(z.size()!=0)sp[qq].PB(z);\n\t\t\t}\n\t\t}\n\t}\n\tstring s[4];\n\tfor(int i=0;i<4;i++){\n\t\tcin >> s[i];\n\t}\n\tint a[4][4];\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(s[i][j]=='R'){\n\t\t\t\ta[i][j] = 1;\n\t\t\t}else if(s[i][j]=='G'){\n\t\t\t\ta[i][j] = 2;\n\t\t\t}else{\n\t\t\t\ta[i][j] = 3;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tqueue<pair<int,int > >q;\n\tbool used[100010];\n\tused[0] = 1;\n\tq.push(MP(0,0));\n\twhile(!q.empty()){\n\t\tauto x = q.front();\n\t\tq.pop();\n\t\tauto f = x.first;\n\t\tint g = x.second;\n\t\tif(f==65535){\n\t\t\tans = g;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int qq=0;qq<n;qq++){\n\t\t\tfor(int c=1;c<4;c++){\n\t\t\t\tfor(int k = 0;k<sp[qq].size();k++){\n\t\t\t\t\tauto s = f;\n\t\t\t\t\tauto w = sp[qq][k];\n\t\t\t\t\tfor(int i=0;i<w.size();i++){\n\t\t\t\t\t\tif(a[w[i].first][w[i].second]==c){\n\t\t\t\t\t\t\ts |= calc(w[i].first,w[i].second);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(s&calc(w[i].first,w[i].second)==1){\n\t\t\t\t\t\t\t\ts -= calc(w[i].first,w[i].second);\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(used[s]!=1){\n\t\t\t\t\t\tused[s]=1;\n\t\t\t\t\t\tq.push(MP(s,g+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\nll compute_hash(){\n  ll res = 0;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll num = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') num = 1;\n      if(stage[y][x] == 'G') num = 2;\n      if(stage[y][x] == 'B') num = 3;\n      res += num;\n      res <<= 2LL;\n    }\n  }\n  return res;\n}\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\n\nmap<ll,int>::iterator it;\nvoid dfs(int count){\n  ll hash = compute_hash();\n\n  if((it = dp.find(hash)) != dp.end() \n     && it->second <= count) return;\n  dp[hash] = count;\n\n  for(int ly=0;ly<4;ly++){\n    for(int lx=0;lx<4;lx++){\n      for(int ry=ly;ry<4;ry++){\n        for(int rx=lx;rx<4;rx++){\n          //corner\n          if((lx == 0 && ly == 0)\n             || (lx == 0 && ly == 3)\n             || (rx == 3 && ry == 3)\n             || (rx == 3 && ry == 0)){\n            if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                char tmp[4][4];\n                memcpy(tmp,stage,sizeof(char)*4*4);\n                erase(ly,lx,ry,rx);\n                dfs(count+1);\n                memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //left or right\n          else if(lx == 0 || rx == 3){\n            if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //top or bottom\n          else if(ly == 0 || ry == 3){\n            if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //center\n          else {\n            if(has_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    dfs(0);\n    printf(\"%d\\n\",dp[0]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = 1'000'000'007;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<int> H(N), W(N);\n\trep(i, 0, N)cin >> H[i] >> W[i];\n\tint C[4][4];\n\tint goals[3] = {};\n\trep(i, 0, 4)rep(j, 0, 4) {\n\t\tchar c; cin >> c;\n\t\tif (c == 'R')\n\t\t\tC[i][j] = 0;\n\t\telse if (c == 'G')\n\t\t\tC[i][j] = 1;\n\t\telse\n\t\t\tC[i][j] = 2;\n\t\tgoals[C[i][j]] |= 1 << (i * 4 + j);\n\t}\n\tvector<int> stamps;\n\tauto inrange = [&](int i, int j) {return 0 <= i && i < 4 && 0 <= j && j < 4; };\n\trep(s, 0, N) {\n\t\trep(i, -3, 4)rep(j, -3, 4) {\n\t\t\tint mask = 0;\n\t\t\trep(ci, i, i + H[s])rep(cj, j, j + W[s]) {\n\t\t\t\tif (!inrange(ci, cj))continue;\n\t\t\t\tmask |= (1 << (ci * 4 + cj));\n\t\t\t}\n\t\t\tstamps.push_back(mask);\n\t\t}\n\t}\n\tqueue<int> q;\n\tq.push(0);\n\tconst int INF = 100;\n\tvector<int> dp(1 << 16, INF);\n\tdp[0] = 0;\n\tint fin = (1 << 16) - 1;\n\twhile (q.size()) {\n\t\tint now = q.front(); q.pop();\n\t\trep(c, 0, 3) {\n\t\t\tfor (auto stamp : stamps) {\n\t\t\t\tint next = (~stamp & now) | (goals[c] & stamp);\n\t\t\t\tif (dp[next] != INF)continue;\n\t\t\t\tdp[next] = dp[now] + 1;\n\t\t\t\tif (next == fin) {\n\t\t\t\t\tcout << dp[fin] << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        r(kk,4)tmp[kk]=t[kk];\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            tmp[i][j]=ccol[col];\n          }\n        }\n        int tp=0;\n        r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n        if(!dp[tp]){\n          dp[tp]=1;\n          q.push(P(tp,p.second+1));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nchar col[10][10];\nint h[16],w[16];\n\nvector<PI> ma;\nint memo[1<<16];\n\nint rec(int st){\n  if(st == (1<<16)-1) return 0;\n  if(memo[st] >= 0) return memo[st];\n  //cout << st << endl;\n  int& ret = memo[st] = 1000000;\n  for(int i = 0; i < (int)ma.size(); ++i){\n    int nst = (st & ~ma[i].first) | ma[i].second;\n    ret = min(ret, rec(nst) + 1);\n  }\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; ++i){\n    cin >> h[i] >> w[i];\n  }\n\n  for(int i = 0; i < 4; ++i)\n    for(int j = 0; j < 4; ++j)\n      cin >> col[i][j];\n\n  vector<pair<PI, PI> > box;\n  for(int lx = -3; lx < 4; ++lx)\n    for(int ty = -3; ty < 4; ++ty)\n      for(int i = 0; i < n; ++i){\n        if(lx+h[i]>0 && ty+w[i]>0)\n          box.push_back({{max(lx,0),max(0,ty)},\n                {min(lx+h[i],4),min(ty+w[i],4)}});\n      }\n  sort(box.begin(), box.end());\n  box.erase(unique(box.begin(), box.end()), box.end());\n  //cout << \"h\" << endl;\n  \n  for(int i = 0; i < (int)box.size(); ++i){\n    int lx = box[i].first.first;\n    int ly = box[i].first.second;\n    int ux = box[i].second.first;\n    int uy = box[i].second.second;\n    int mask = 0;\n    int rr = 0;\n    int gg = 0;\n    int bb = 0;\n    for(int cx = lx; cx < ux; ++cx)\n      for(int cy = ly; cy < uy; ++cy){\n        mask |= 1 << (cx*4 + cy);\n        (col[cx][cy]=='R'?rr:\n         col[cx][cy]=='G'?gg:\n         bb) |= 1 << (cx*4 + cy);\n      }\n    ma.push_back({mask,rr});\n    ma.push_back({mask,gg});\n    ma.push_back({mask,bb});\n  }\n  //cout << \"h\" << endl;\n\n  queue<int> q;\n  q.push(0);\n  for(int cc = 0;!q.empty();++cc){\n    queue<int> nq;\n    while(!q.empty()){\n      int cv = q.front();\n      q.pop();\n      if(memo[cv]) continue;\n      memo[cv] = 1;\n      if(cv == (1<<16) - 1){\n        cout << cc << endl;\n        return 0;\n      }\n      for(int i = 0; i < (int)ma.size(); ++i){\n        int nv = (cv & ~ma[i].first) | ma[i].second;\n        if(!memo[nv])\n          nq.push(nv);\n      }\n    }\n    q.swap(nq);\n  }\n  \n  memset(memo, -1, sizeof(memo));  \n  cout << rec(0) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<char>> c(4,vector<char>(16));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4) cin >> c[i][j];\n\n    int ans=inf;\n    vector<char> ord={'R','G','B'};\n    do{\n        int tmp=0;\n        vector<char> ng;\n        auto check=[&](int y1,int x1,int y2,int x2){\n            rep(y,y1,y2) rep(x,x1,x2) rep(i,0,ng.size()) if(c[y][x]==ng[i]) return false;\n            return true;\n        };\n        for(const char color:ord){\n            set<pair<pii,pii>> pps;\n            rep(i,0,n) rep(y,-3,4) rep(x,-3,4){\n                int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n                if(y2<=0 or x2<=0) continue;\n                if(!check(y1,x1,y2,x2)) continue;\n                bool ok=true;\n                for(auto it=pps.begin(); it!=pps.end(); ++it){\n                    const pii& p1=it->first,&p2=it->second;\n                    if(p1.first<=y1 and p1.second<=x1 and y2<=p2.first and x2<=p2.second){\n                        ok=false;\n                        break;\n                    }\n                    if(y1<=p1.first and x1<=p1.second and p2.first<=y2 and p2.second<=x2){\n                        ok=false;\n                        pps.erase(it);\n                        pps.insert(make_pair(pii(y1,x1),pii(y2,x2)));\n                        break;\n                    }\n                }\n                if(ok) pps.insert(make_pair(pii(y1,x1),pii(y2,x2)));\n            }\n            int mini_cnt=inf;\n            rep(i,0,1<<pps.size()){\n                int cnt=__builtin_popcount(i);\n                if(mini_cnt<=cnt) continue;\n                int idx=0;\n                vector<vector<bool>> done(4,vector<bool>(4,false));\n                for(auto it=pps.begin(); it!=pps.end(); ++it,++idx){\n                    if(((i>>idx)&1)!=1) continue;\n                    rep(y,it->first.first,it->second.first) rep(x,it->first.second,it->second.second) done[y][x]=true;\n                }\n                bool ok=true;\n                rep(y,0,4) rep(x,0,4) if(!done[y][x] and c[y][x]==color){\n                    ok=false;\n                    break;\n                }\n                if(ok) mini_cnt=min(mini_cnt,cnt);\n            }\n            tmp+=mini_cnt;\n            ng.push_back(color);\n        }\n        ans=min(ans,tmp);\n    }while(next_permutation(ord.begin(),ord.end()));\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,H[17],W[17];\nint c[5][5];\nint dist[1<<16];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N)cin>>H[i]>>W[i];\n\trep(i,4)rep(j,4){\n\t\tchar C;\n\t\tcin>>C;\n\t\tc[i][j] = C=='R' ? 0 : C=='G' ? 1 : 2;\n\t}\n\trep(i,1<<16)dist[i] = INF;\n\tdist[0] = 0;\n\tqueue<int> Q;\n\tQ.push(0);\n\twhile(sz(Q)){\n\t\tint mask = Q.front(); Q.pop();\n\t\tif(mask == (1<<16)-1){\n\t\t\treturn cout<<dist[mask]<<endl,0;\n\t\t}\n\t\trep(i,N){\n\t\t\trep2(y,-H[i]+1,4)rep2(x,-W[i]+1,4)rep(color,3){\n\t\t\t\tint nmask = mask;\n\t\t\t\trep(ii,H[i])rep(jj,W[i]){\n\t\t\t\t\tint Y = y+ii, X = x+jj;\n\t\t\t\t\tif(Y<0 || Y>=4 || X<0 || X>=4)continue;\n\t\t\t\t\tif(c[Y][X] == color) nmask |= 1<<Y*4+X;\n\t\t\t\t\telse nmask &= ~(1<<Y*4+X);\n\t\t\t\t}\n\t\t\t\tif(dist[nmask] > dist[mask] + 1){\n\t\t\t\t\tdist[nmask] = dist[mask] + 1;\n\t\t\t\t\tQ.push(nmask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int N;\n  cin >> N;\n  static bool drawable[4][4][4][4];\n  for (int i = 0; i < N; i++) {\n    int H, W;\n    cin >> H >> W;\n    for (int k = -H+1; k < 4; k++) {\n      for (int l = -W+1; l < 4; l++) {\n        drawable[max(0, k)][max(0, l)][min(3, k+H-1)][min(3, l+W-1)] = true;\n      }\n    }\n  }\n  vector<string> goal(4);\n  for (int i = 0; i < 4; i++) {\n    cin >> goal[i];\n  }\n\n  queue<int> q;\n  q.push(0);\n  static const int INF = 1000000;\n  vector<int> dist(1<<16, INF);\n  dist[0] = 0;\n  while (!q.empty()) {\n    const int n = q.front();\n    q.pop();\n    if (n == (1<<16)-1) {\n      break;\n    }\n    for (int i = 0; i < 4; i++) {\n      for (int j = 0; j < 4; j++) {\n        for (int k = i; k < 4; k++) {\n          for (int l = j; l < 4; l++) {\n            if (drawable[i][j][k][l]) {\n              for (int c = 0; c < 3; c++) {\n                static const char rgb[] = \"RGB\";\n                const char cc = rgb[c];\n                int next = n;\n                for (int x = i; x <= k; x++) {\n                  for (int y = j; y <= l; y++) {\n                    if (goal[x][y] == cc) {\n                      next |= 1 << (4*x+y);\n                    } else {\n                      next &= ~(1 << (4*x+y));\n                    }\n                  }\n                }\n                if (dist[n]+1 < dist[next]) {\n                  dist[next] = dist[n]+1;\n                  q.push(next);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << dist[(1<<16)-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\nusing pii = pair<int,int>;\n\nint table[4][4];\n\nbool inside(int a, int b){\n\treturn 0<=a&&a<4&&0<=b&&b<4;\n}\n\nint calc(vector<vector<int>> vv){\n\tint state = 0;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tif(vv[i][j]){\n\t\t\t\tstate += 1<<(i*4+j);\n\t\t\t}\n\t\t}\n\t}\n\treturn state;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\trep(k,3){\n\t\t\t\tif(t == \"RGB\"[k]){\n\t\t\t\t\ttable[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dp(1<<16,1e9);\n\tdp[0] = 0;\n\trep(i,1<<16){\n\t\tif(dp[i]>1e8) continue;\n\t\tvector<vector<int>> vv(4,vector<int>(4));\n\t\trep(j,16){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tvv[j/4][j%4] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto x: v){\n\t\t\trep(_k,7){\n\t\t\t\trep(_l,7){\n\t\t\t\t\tint k = _k-3;\n\t\t\t\t\tint l = _l-3;\n\t\t\t\t\trep(color, 3){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\tif(inside(k+kk,l+ll)&&table[k+kk][l+ll]!=color&&vv[k+kk][l+ll]==0) ok=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\t// auto tmp = vv;\n\t\t\t\t\t\t\tint tmp = i;\n\t\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\t\tif(inside(k+kk,l+ll)&&vv[k+kk][l+ll]==0){\n\t\t\t\t\t\t\t\t\t\ttmp += 1<<((k+kk)*4+l+ll);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[tmp] = min(dp[tmp], dp[i]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ninline int enc(int x, int y) { return x + y * 4; }\n\nint main() {\n    int N;\n    cin >> N;\n\n    set<int> paint;  // 選べる長方形領域\n    for (int i = 0; i < N; ++i) {\n        int H, W;\n        cin >> H >> W;\n\n        // 左下を軸に全探索\n        for (int lx = -3; lx <= 3; ++lx) {\n            for (int ly = -3; ly <= 3; ++ly) {\n                int pat = 0;\n                for (int dx = 0; dx < H; ++dx) {\n                    for (int dy = 0; dy < W; ++dy) {\n                        int x = lx + dx, y = ly + dy;\n                        if (x < 0 || 4 <= x || y < 0 || 4 <= y) continue;\n                        pat |= (1 << enc(x, y));\n                    }\n                }\n                paint.insert(pat);\n            }\n        }\n    }\n\n    vector<string> S(4);\n    for (auto& s : S) cin >> s;\n\n    // BFS\n    queue<int> que;\n    que.push((1 << 16) - 1);\n\n    vector<int> dist(1 << 16, INF);\n    dist[(1 << 16) - 1] = 0;\n\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        // 長方形領域と色を全探索\n        for (auto pat : paint) {\n            for (char c : string(\"RGB\")) {\n                int sv = v;\n                for (int x = 0; x < 4; ++x) {\n                    for (int y = 0; y < 4; ++y) {\n                        if ((pat >> enc(x, y)) & 1) {\n                            sv &= ~(1 << enc(x, y));\n                            sv |= (S[x][y] != c) << enc(x, y);\n                            // 一度bitを消してから、「同じか否か」で書き換える\n                            // 同じなら0とする\n                        }\n                    }\n                }\n\n                if (dist[sv] == INF) {\n                    dist[sv] = dist[v] + 1;\n                    que.push(sv);\n                }\n            }\n        }\n    }\n\n    cout << dist[0] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint h[16],w[16];\nint dist[1<<16];\nchar ba[4][4];\nint ok[1<<16];\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i,n) cin >> h[i] >> w[i];\n  REP(i,4) REP(j,4) cin >> ba[i][j];\n  int num = 0;\n  set<int> masks;\n  REP(i,n) {\n    for (int y1=-h[i]+1; y1<=4-h[i]; ++y1) {\n      for (int x1=-w[i]+1; x1<=4-w[i]; ++x1) {\n        int mask = 0;\n        for (int y=y1; y<y1+h[i]; ++y) {\n          for (int x=x1; x<x1+w[i]; ++x) {\n            if (y>=0&&y<4&&x>=0&&x<4) mask |= 1<<(y*4+x);\n          }\n        }\n        masks.insert(mask);\n      }\n    }\n  }\n  REP(S,1<<16) {\n    set<char> st;\n    REP(y,4) {\n      REP(x,4) {\n        if (S>>(y*4+x)&1) {\n          st.insert(ba[y][x]);\n        }\n      }\n    }\n    ok[S] = (st.size() <= 1);\n  }\n  queue<int> Q;\n  Q.push((1<<16)-1);\n  memset(dist,-1,sizeof(dist));\n  dist[(1<<16)-1] = 0;\n  while(!Q.empty()) {\n    int S = Q.front(); Q.pop();\n    if (S == 0) break;\n    FOR(it, masks) {\n      int t[3]={};\n      if (ok[*it & S]) {\n        int T = S & ~*it;\n        if (dist[T] == -1) {\n          dist[T] = dist[S] + 1;\n          Q.push(T);\n        }\n      }\n    }\n  }\n  cout << dist[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4];\n\t\t\telse F[i / 4][i % 4] = 0;\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = 1 - (int)x[i].first; j <= 3; j++) {\n\t\t\t\tfor (int k = 1 - (int)x[i].second; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint L[4][4]; for (int l = 0; l < 16; l++)L[l >> 2][l & 3] = F[l >> 2][l & 3];\n\t\t\t\t\t\tfor (int l = max(-j, 0); l < min(4 - j, x[i].first); l++) {\n\t\t\t\t\t\t\tfor (int m = max(-k, 0); m < min(4 - k, x[i].second); m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m;\n\t\t\t\t\t\t\t\tif (L[cx][cy] >= 1 && col[cx][cy] != o) { L[cx][cy] = 0; }\n\t\t\t\t\t\t\t\telse if (L[cx][cy] == 0 && col[cx][cy] == o) { L[cx][cy] = o; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = 0;\n\t\t\t\t\t\tfor (int l = 0; l < 16; l++) { if (L[l >> 2][l & 3] >= 1)bits += (1 << l); }\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 4;\nconst int inf = (1<<20);\nbool edge[N][N][N][N];\nint cost[(1<<16)];\nchar m[N][N+1];\n\nint encode(bool in[4][4]){\n  int ret=0;\n  rep(i,4){\n    rep(j,4){\n      if (in[i][j])ret|=((1<<(j+i*4)));\n    }\n  }\n  return ret;\n}\n\nvoid decode(bool in[4][4],int now){\n  rep(i,4){\n    rep(j,4){\n      in[i][j]=now%2==1;\n      now/=2;\n    }\n  }\n}\n\nint fill(int t,int b,int l,int r,bool st[4][4],char color){\n  bool cpy[4][4];\n  rep(i,4)rep(j,4)cpy[i][j]=st[i][j];\n  for(int i=t;i<=b;i++){\n    for(int j=l;j<=r;j++){\n      if (color == m[i][j])cpy[i][j]=true;\n      else cpy[i][j]=false;\n    }\n  }\n  return encode(cpy);\n}\n\nstring color=\"RGB\";\nint solve(){\n  bool st[4][4];\n  rep(i,(1<<16))cost[i]=inf;\n  queue<int> Q;\n  Q.push(0);\n  cost[0]=0;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    if (now == (1<<16)-1)return cost[now];\n    decode(st,now);\n    rep(i,4){\n      REP(ii,i,4){\n\trep(j,4){\n\t  REP(jj,j,4){\n\t    if (!edge[i][ii][j][jj])continue;\n\t    rep(l,4){\n\t      int next=fill(i,ii,j,jj,st,color[l]);\n\t      if (cost[next] == inf){\n\t\tcost[next]=cost[now]+1;\n\t\tQ.push(next);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n  }\n  return -1;\n}\n\nvoid makePattern(int h,int w){\n  for(int i=-3;i < 4;i++){//top\n    if (i+h <= 0)continue;\n    for(int j=-3;j < 4;j++){//left\n      if (j+w <= 0)continue;\n      int l=max(0,j),r=min(3,j+w-1),t=max(0,i),b=min(3,i+h-1);\n      edge[t][b][l][r]=true;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n){\n    rep(i,4)rep(j,4)rep(k,4)rep(l,4)edge[i][j][k][l]=false;\n    rep(i,n){\n      int w,h;\n      cin>>w>>h;\n      makePattern(w,h);\n    }\n    rep(i,4)cin>>m[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000001;\n\nchar color[] = \"RGB\";\n\nint main() {\n  int n;\n  cin>>n;\n  vector<pair<int,int>> s;\n  REP(i,n) {\n    int h,w;\n    cin>>h>>w;\n    s.emplace_back(h,w);\n  }\n  string t;\n  REP(i,4) {\n    string s;\n    cin>>s;\n    t += s;\n  }\n  vector<int> dp(1<<16, INF);\n  dp[0] = 0;\n  REP(i,1<<16) {\n    REP(j,n) {\n      int h,w;\n      tie(h,w) = s[j];\n      FOR(y,-h+1,3)FOR(x,-w+1,3) {\n        int bits = 0;\n        REP(k,h)REP(l,w) {\n          int py = y + k;\n          int px = x + l;\n          if (px < 0 || px >=4 || py < 0 || py >= 4) continue;\n          int index = px + 4*py;\n          if ((i >> index) & 1) continue;\n          bits |= 1 << index;\n        }\n        REP(k,3) {\n          bool ok = true;\n          REP(l,16) {\n            if ((bits >> l) & 1) {\n              if (t[l] != color[k]) {\n                ok = false;\n                break;\n              }\n            }\n          }\n          if (ok) {\n            dp[i|bits] = min(dp[i|bits], dp[i] + 1);\n          }\n        }\n      }\n    }\n  }\n  cout << dp[(1<<16)-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar Color[3] = {'R', 'G', 'B'};\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> h(n);\n    vector<int> w(n);\n    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];\n    string C;\n    for(int i = 0; i < 4; i++){\n        string tmp; cin >> tmp;\n        C = C + tmp;\n    }\n\n    queue<pair<int, int> > que;                  //cost bit(一致していたら1そうでなければ0)\n    \n    vector<bool> used((1 << 16), false);\n    used[0] = true;\n    que.push({0, 0});\n\n    while(!que.empty()){\n\n        int bit = que.front().second;\n        int cost = que.front().first;\n        //cout << cost << \" \" << str << endl;\n        que.pop();\n\n        if(bit == (1 << 16) - 1){\n            cout << cost << endl;\n            break;\n        }\n\n        for(int ii = 0; ii < n; ii++){\n\n            for(char color : Color){\n\n                //cout << i << \" \" << color << endl;\n                for(int si = -3; si <= 3; si++){\n                    for(int sj = -3; sj <= 3; sj++){\n                        int gi = si + h[ii] - 1;\n                        int gj = sj + w[ii] - 1;\n\n                        int next;\n                        next = bit;\n                        //cout << i << \" \" << si << \" \" << gi << \" \" << sj << \" \" << gj << \" \" << endl;\n                        for(int i = max(si, 0); i <= min(gi, 3); i++){\n                            for(int j = max(sj, 0); j <= min(gj, 3); j++){            \n                                int idx = i * 4 + j;\n                                if(C[idx] == color) next = next | (1 << idx);\n                                else next = next & ~(1 << idx);\n                            }\n                        }\n\n                        if(!used[next]){\n                            //cout << \"ok\" << endl;\n                            used[next] = true;\n                            que.push({cost + 1, next});\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a, b; vector<int> x, y; string tmp;\n\nmap<unsigned, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tunsigned finish = 0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tswitch (tmp[j])\n\t\t\t{\n\t\t\tcase 'R': finish += (1 << (i * 8 + j * 2)) * 1; break;\n\t\t\tcase 'G': finish += (1 << (i * 8 + j * 2)) * 2; break;\n\t\t\tcase 'B': finish += (1 << (i * 8 + j * 2)) * 3; break;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<unsigned, int> > que;\n\n\tque.push(make_pair(0, 0)); D[0] = true;\n\n\twhile (true)\n\t{\n\t\tunsigned M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (finish == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 1; c < 4; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tint bit = 1 << (l * 8 + m * 2);\n\n\t\t\t\t\t\t\t\tM2 -= M2 / bit % 4;\n\t\t\t\t\t\t\t\tM2 += bit * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi hs(n),ws(n);\n\t\trep(i,n) cin>>hs[i]>>ws[i];\n\t\tvs grid(4);\n\t\trep(i,4) cin>>grid[i];\n\t\t\n\t\tqueue<pii> q;\n\t\tq.emplace(0,0);\n\t\tvi vis(1<<16);\n\t\twhile(q.size()){\n\t\t\tint bit,turn; tie(bit,turn)=q.front(); q.pop();\n\t\t\tif(bit==(1<<16)-1){\n\t\t\t\tcout<<turn<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[bit]) continue;\n\t\t\tvis[bit]=1;\n\t\t\t\n\t\t\trep(k,n){\n\t\t\t\trepi(i0,-hs[k]+1,4) repi(j0,-ws[k]+1,4){\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tchar color='?';\n\t\t\t\t\tint mask=0;\n\t\t\t\t\trep(i,hs[k]) rep(j,ws[k]){\n\t\t\t\t\t\tif(i0+i<0 || 4<=i0+i || j0+j<0 || 4<=j0+j) continue;\n\t\t\t\t\t\tmask|=1<<(i0+i)*4+(j0+j);\n\t\t\t\t\t\tif(bit>>(i0+i)*4+(j0+j)&1) continue;\n\t\t\t\t\t\tif(color=='?') color=grid[i0+i][j0+j];\n\t\t\t\t\t\tif(grid[i0+i][j0+j]!=color) ok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok && !vis[bit|mask]) q.emplace(bit|mask,turn+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nint N,C[4][4];\npii stamp[16];\n\ninline int stp(int x,int y,int px,int py,int c,int S){\n  for(int i = py ; i < py+y ; i++){\n    if(i < 0 || i >= 4) continue;\n    for(int j = px ; j < px+x ; j++){\n      if(j < 0 || j >= 4) continue;\n      int b = i*4+j;\n      if(C[i][j] == c){\n        if((S >> b) & 1) continue;\n        S |= (1<<b);\n      }else{\n        if((S >> b) & 1){\n          S -= (1<<b);\n        }\n      }\n    }\n  }\n  return S;\n}\n\nint solve(){\n  queue<int> Q;\n  Q.push(0);\n  int dist[1<<16];\n  fill(dist,dist+(1<<16),INF);\n  dist[0] = 0;\n\n  while(!Q.empty()){\n    int S = Q.front(); Q.pop();\n    if(S == (1<<16)-1){\n      return dist[S];\n    }\n    for(int i = 0 ; i < N ; i++){\n      pii p = stamp[i];\n      int x = p.second,y = p.first;\n      for(int j = 0 ; j < 3 ; j++){\n        for(int px = -x+1 ; px < 4+x-1 ; px++){\n          for(int py = -y+1 ; py < 4+y-1 ; py++){\n            int nS = stp(x,y,px,py,j,S);\n            if(dist[S]+1 < dist[nS]){\n              dist[nS] = dist[S] + 1;\n              Q.push(nS);\n            }\n          }\n        } \n      }\n    }\n  }\n  return -1;\n}\n\nint change(char ch){\n  if(ch == 'R') return 0;\n  if(ch == 'B') return 1;\n  return 2;\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> stamp[i].first >> stamp[i].second;\n  }\n  char in;\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      cin >> in;\n      C[i][j] = change(in);\n    }    \n  }\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[17][1<<16];\nint main(){\n  int n,h[16],w[16];\n  char r[3]={'R','G','B'};\n  string c[4];\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>h[i]>>w[i];\n  for(int i=0;i<4;i++)cin>>c[i];\n\n  int a1[16][7][7],o1[16][3][7][7]={};\n  for(int i=0;i<n;i++)\n    for(int j=0;j<7;j++)for(int k=0;k<7;k++)a1[i][j][k]=(1<<16)-1;\n  \n  for(int k=0;k<n;k++)\n    for(int cl=0;cl<3;cl++)\n      for(int y=-h[k]+1;y<4;y++)\n\tfor(int x=-w[k]+1;x<4;x++){\n\t  for(int l=max(0,y);l<min(4,y+h[k]);l++)\n\t    for(int m=max(0,x);m<min(4,x+w[k]);m++){\n\t      int xx=l*4+m;\n\t      if(c[l][m]==r[cl])o1[k][cl][y+3][x+3]|=1<<xx;\n\t      if(!cl)a1[k][y+3][x+3]-=1<<xx;\n\t    }\n\t}\n  \n  dp[0][0]=1;\n  for(int j=0;j<16;j++)\n    for(int i=0;i<1<<16;i++)\n      if(dp[j][i])\n\tfor(int k=0;k<n;k++)\n\t  for(int cl=0;cl<3;cl++)\n\t    for(int y=-h[k]+1;y<4;y++)\n\t      for(int x=-w[k]+1;x<4;x++){\n\t\tint ni=(i&a1[k][y+3][x+3])|o1[k][cl][y+3][x+3];\n\t\tdp[j+1][ni]=1;\n\t\tif(ni==(1<<16)-1){cout<<j+1<<endl;return 0;}\n\t      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,v=1<<16,i,j,k,l,a,b,x,y,z,bit,d;\n  cin>>n;\n  int h[n],w[n],dp[v],used[v];\n  for(i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(i=0;i<n;i++)\n      for(j=-h[i]+1;j<4;j++)\n\tfor(k=-w[i]+1;k<4;k++)\n\t  for(l=0;l<3;l++){\n\t    for(z=bit,a=max(0,-j);a<min(h[i],4-j);a++)\n\t      for(b=max(0,-k);b<min(w[i],4-k);b++){\n\t\ty=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=v-1-(1<<(y*4+x));\n\t      }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[v-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S, f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(S&(1<<p)) f=1;\n\t\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(!f&&d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int y=0;y<M;y++){\n      \n      for(int x=0;x<M;x++){\n\t\n\tint idx=y*M+x;\n\t\n\tif(S&(1<<idx)) continue;\n\t\n\tfor(int k=0;k<n;k++) mark(cost,S,idx,k);\n\t\n      }\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define fi first\n#define se second\nusing pii = pair<int,int>;\n\nint table[4][4];\n\nbool inside(int a, int b){\n\treturn 0<=a&&a<4&&0<=b&&b<4;\n}\n\nint calc(vector<vector<int>> vv){\n\tint state = 0;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tif(vv[i][j]){\n\t\t\t\tstate += 1<<(i*4+j);\n\t\t\t}\n\t\t}\n\t}\n\treturn state;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\tvector<pair<pii,pii>> w;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\trep(k,n){\n\t\t\t\tpii lu(i,j);\n\t\t\t\tpii rd(min(i+v[k].fi-1, 3), min(j+v[k].se-1, 3));\n\t\t\t\tw.push_back(make_pair(lu, rd));\n\t\t\t\tlu = pii(max(i-v[k].fi+1, 0), max(j-v[k].se+1, 0));\n\t\t\t\trd = pii(i,j);\n\t\t\t\tw.push_back(make_pair(lu, rd));\n\t\t\t}\n\t\t}\n\t} \n\tsort(w.begin(), w.end());\n\tw.erase(unique(w.begin(), w.end()), w.end());\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\trep(k,3){\n\t\t\t\tif(t == \"RGB\"[k]){\n\t\t\t\t\ttable[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dp(1<<16,1e9);\n\tdp[0] = 0;\n\trep(i,1<<16){\n\t\tif(dp[i]>1e8) continue;\n\t\tvector<vector<int>> vv(4,vector<int>(4));\n\t\trep(j,16){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tvv[j/4][j%4] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto x: w){\n\t\t\tbool ok = true;\n\t\t\tint color = -1;\n\t\t\treep(k,x.fi.fi, x.se.fi+1){\n\t\t\t\treep(l,x.fi.se, x.se.se+1){\n\t\t\t\t\tif(vv[k][l]==0){\n\t\t\t\t\t\tif(color == -1) color = table[k][l];\n\t\t\t\t\t\telse if(color != table[k][l]) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\t// auto tmp = vv;\n\t\t\t\tint tmp = i;\n\t\t\t\treep(k,x.fi.fi, x.se.fi+1){\n\t\t\t\t\treep(l,x.fi.se, x.se.se+1){\n\t\t\t\t\t\tif(vv[k][l]==0){\n\t\t\t\t\t\t\ttmp += 1<<((k)*4+l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[tmp] = min(dp[tmp], dp[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nbool check(int x, int y) {return x>=0&&x<4&&y>=0&&y<4;}\n\nint main() {\n  int n;\n  cin >> n;\n  P a[n];\n  for(int i=0; i<n; i++) cin >> a[i].F >> a[i].S;\n  string s[4];\n  for(int i=0; i<4; i++) cin >> s[i];\n  int dp[1<<16];\n  fill(dp,dp+(1<<16),1<<29);\n  dp[0]=0;\n  for(int t=0; t<(1<<16); t++) {\n    for(int i=0; i<n; i++) {\n      for(int j=-3; j<4; j++) {\n        for(int k=-3; k<4; k++) {\n          set<char> se;\n          int r=0;\n          for(int jj=0; jj<a[i].F; jj++) {\n            for(int kk=0; kk<a[i].S; kk++) {\n              int x=j+jj,y=k+kk;\n              if(!check(x,y)) continue;\n              int z=x*4+y;\n              r|=1<<z;\n              if(t&(1<<z)) continue;\n              se.insert(s[x][y]);\n            }\n          }\n          if(se.size()==1) dp[t|r]=min(dp[t|r],dp[t]+1);\n        }\n      }\n    }\n  }\n  cout << dp[(1<<16)-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nstruct P {\n    int cost;\n    uint16_t bit;\n};\n\nchar colorchar[] = {'R', 'G', 'B'};\n\nstring goal;\n\nint correct_num(string& s) {\n    int n = 0;\n    REP(i, 16) {\n        if (s[i] == goal[i]) n++;\n    }\n    return n;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pii> stamp(N);\n    REP(i, N) {\n        cin >> stamp[i].first >> stamp[i].second;\n    }\n    vvc field(4, vc(4));\n    REP(y, 4) REP(x, 4) {\n        cin >> field[y][x];\n        goal += field[y][x];\n    }\n\n    set<uint16_t> G;\n\n    queue<P> que;\n    que.push({0, 0});\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        if (p.bit == (1<<16)-1) {\n            cout << p.cost << endl;\n            break;\n        }\n        REP(i, N) {\n            FOR(y, -3, 4) FOR(x, -3, 4) {\n                int sx = x + stamp[i].first, sy = y + stamp[i].second;\n                if (0 < sx || 0 < sy) {\n                    REP(j, 3) {\n                        uint16_t bit = p.bit;\n                        FOR(ssy, y, sy) FOR(ssx, x, sx) {\n                            if (0 <= ssx && ssx < 4 && 0 <= ssy && ssy < 4) {\n                                int k = 4*ssy+ssx;\n                                if (field[ssy][ssx] == colorchar[j]) {\n                                    bit |= 1<<k;\n                                } else {\n                                    bit &= ~(1<<k);\n                                }\n                            }\n                        }\n                        if (!EXIST(G, bit)) {\n                            G.insert(bit);\n                            que.push({p.cost+1, bit});\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\nconst int INF=100000000;\n\n// eXªwè³ê½FÉÈéÜÅÌÅ¬X^vñ\nint dp[1<<16];\nchar field[5][5];\nvector<pair<int,int> > stumps;\nint n;\n\nchar color[]={'R','G','B'};\n\nint dfs(int s){\n    if(s==((1<<16)-1))\n        return 0;\n    if(dp[s]!=INF)\n        return dp[s];\n    int cnt=INF;\n    int match=0;\n    for(int i = 0; i < 16; i++)\n        if((s>>i)&1) \n            match++;\n    // }b`·éêª¦éæ¤ÉµÄ¢­\n    for(int k = 0; k < stumps.size(); k++){\n        int h=stumps[k].first;\n        int w=stumps[k].second;\n        // ¶ãÌÀWðè\n        for(int i = -h+1; i < 4; i++){\n            for(int j = -w+1; j < 4; j++){\n                if(i==0&&j==0&&s==0){\n       //             cout<<endl;\n                }\n                int ns=s;\n                int mc=0;\n                bool first=false;\n                bool b=false;\n                char cc;\n                // »¤ÅÈ¯êÎhèÂÔµÄÄA\n                for(int k = i; k<min(i+h,4); k++){\n                    for(int l = j; l < min(j+w,4); l++){\n                        if(!(k>=0&&l>=0&&k<4&&l<4))\n                            continue;\n                        // JnÀWª0Å³¯êÎI¹\n                        if(!first){\n                            // Ü¾FªêvµÄ¢È¢\n                            if(!((s>>(k*4+l))&1)){\n                                ns|=(1<<(k*4+l));\n                                // FðÌæ\n                                cc=field[k][l];\n                            }\n                            else{\n                                b=true;\n                                break;\n                            }\n                            first=true;\n                        }\n                        else{\n                            //  éêÌFð²×é\n                            if((s>>(k*4+l))&1){\n                                // ¡ÌêÌFªêvµÄ¢È¯êÎ\n                                if(field[k][l]!=cc)\n                                    ns&=~(1<<(k*4+l));\n                            }\n                            else{\n                                // êvµÄ¢½ç\n                                if(field[k][l]==cc)\n                                    ns|=(1<<(k*4+l));\n                            }\n                        }\n                    }\n                    if(b)\n                        break;\n                }\n                if(b)\n                    continue;\n                //for(int k = 0; k < 16; k++)\n                //    if((ns>>k)&1)\n                //        mc++;\n                //if(mc<=match)\n                //    continue;\n                cnt=min(cnt,dfs(ns)+1);\n                if(cnt==0){\n                    return dp[s]=0;\n                }\n            }\n        }\n    }\n    return dp[s]=cnt;\n}\n\nvoid solve(){\n    fill(dp,dp+(1<<16),INF);\n    cin>>n;\n    for(int i = 0; i < n; i++){\n        int h,w;\n        cin>>h>>w;\n        stumps.push_back(make_pair(h,w));\n    }\n    for(int i = 0; i < 4; i++)\n        for(int j = 0; j < 4; j++)\n            cin>>field[i][j];\n    cout<<dfs(0)<<endl;\n}\n\nint main(){\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = numeric_limits<int>::max()/2;\n\nint n;\nvector<P> stmp;\nvector<vector<int>> col(4,vector<int>(4));\nvector<int> dis(1<<16,INF);\n\nint solve(){\n    queue<int> q;\n    dis[0]=0;\n    q.push(0);\n    while(!q.empty()){\n        int prev=q.front();q.pop();\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=2;j++){\n                // stamp[i] with color_j\n                int h=stmp[i].first,w=stmp[i].second;\n                for(int sx=1-h;sx<4;sx++){\n                    for(int sy=1-w;sy<4;sy++){\n\n                        int next=prev;\n                        for(int ni=max(0,-sx);ni<min(h,4-sx);ni++){\n                            for(int nj=max(0,-sy);nj<min(w,4-sy);nj++){\n                                int nx=sx+ni,ny=sy+nj;\n                                if(nx<0 || 4<=nx || ny<0 || 4<=ny) continue;\n                                int num=15-4*nx-ny;\n                                if(col[nx][ny]==j) next |= (1<< num);\n                                else next &= ~(1<<num); \n                            }\n                        }\n\n                        if(dis[next]!=INF) continue;\n                        dis[next]=dis[prev]+1;\n                        if(next==((1<<16)-1)) return dis[next];\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int h,w;cin>>h>>w;\n        stmp.push_back(P(h,w));\n    }\n    for(int i=0;i<4;i++){\n        string s;cin>>s;\n        for(int j=0;j<4;j++){\n            if(s[j]=='R') col[i][j]=0;\n            else if(s[j]=='G') col[i][j]=1;\n            else col[i][j] = 2;\n        }\n    }\n    cout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nmap< vector< vector<char> > , int> done[50];\nvector< vector<char> > goal(7,vector<char>(7));\n\nint w[20],h[20];\nint f(int pos , vector< vector<char> > &c){\n\tif(pos == 49){\n\t\trep(i,4)rep(j,4){\n\t\t\tif(c[i+3][j+3] == 0) return 999999;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(done[pos].find(c) != done[pos].end()) return done[pos][c];\n\tint x = pos % 7;\n\tint y = pos / 7;\n\tint ans = 999999;\n\tif(x < 3 || y < 3 || c[y][x])ans = f(pos+1,c);\n\n\trep(i,n){\n\t\trep(color,3){\n\t\t\tif( x < 3 || y < 3 || goal[y][x] == color){\n\t\t\t\tvector< vector<char> > t = c;\n\t\t\t\trep(j,h[i]){\n\t\t\t\t\trep(k,w[i]){\n\t\t\t\t\t\tint tx = x+k;\n\t\t\t\t\t\tint ty = y+j;\n\t\t\t\t\t\tif(tx >= 7 || ty >= 7 || tx < 3 || ty < 3 )continue;\n\t\t\t\t\t\tif(color == goal[ty][tx])t[ty][tx] = 1;\n\t\t\t\t\t\telse t[ty][tx] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = min(f(pos+1,t)+1,ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn done[pos][c] = ans;\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tvector< vector<char> > init(7,vector<char>(7,0));\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[3+i][3+j] = c;\n\t}\n\tcout << f(0,init);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\n\nll compute_hash(){\n  ll res = 0;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll num = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') num = 1;\n      if(stage[y][x] == 'G') num = 2;\n      if(stage[y][x] == 'B') num = 3;\n      res += num;\n      res <<= 2LL;\n    }\n  }\n  return res;\n}\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\nvoid dfs(int count){\n  ll hash = compute_hash();\n\n  if(dp.find(hash) != dp.end() \n     && dp[hash] <= count) return;\n  dp[hash] = count;\n\n  for(int ly=0;ly<4;ly++){\n    for(int lx=0;lx<4;lx++){\n      for(int ry=ly;ry<4;ry++){\n        for(int rx=lx;rx<4;rx++){\n          //corner\n          if((lx == 0 && ly == 0)\n             || (lx == 0 && ly == 3)\n             || (rx == 3 && ry == 3)\n             || (rx == 3 && ry == 0)){\n            if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                char tmp[4][4];\n                memcpy(tmp,stage,sizeof(char)*4*4);\n                erase(ly,lx,ry,rx);\n                dfs(count+1);\n                memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //left or right\n          else if(lx == 0 || rx == 3){\n            if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //top or bottom\n          else if(ly == 0 || ry == 3){\n            if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n\n          //center\n          else {\n            if(has_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  dfs(count+1);\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    dfs(0);\n    printf(\"%d\\n\",dp[0]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nmap< vector< vector<char> > , int> done;\nvector< vector<char> > goal(7,vector<char>(7));\nvector< vector<char> > good(8,vector<char>(8,0)) ;\n\nint w[20],h[20];\nint f(vector< vector<char> > &c){\n\tqueue< vector< vector<char> > > Q;\n\tQ.push(c);\n\tdone[c] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector< vector<char> > &q = Q.front(); Q.pop();\n\t\tint cost = done[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(x,7)rep(y,7){\n\t\t\trep(i,n){\n\t\t\t\trep(color,3){\n\t\t\t\t\tif( x < 3 || y < 3 || goal[y][x] == color){\n\t\t\t\t\t\tvector< vector<char> > t = c;\n\t\t\t\t\t\trep(j,h[i]){\n\t\t\t\t\t\t\trep(k,w[i]){\n\t\t\t\t\t\t\t\tint tx = x+k;\n\t\t\t\t\t\t\t\tint ty = y+j;\n\t\t\t\t\t\t\t\tif(tx >= 7 || ty >= 7 || tx < 3 || ty < 3 )continue;\n\t\t\t\t\t\t\t\tif(color == goal[ty][tx])t[ty][tx] = 1;\n\t\t\t\t\t\t\t\telse t[ty][tx] = 0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(done.find(t) == done.end()){\n\t\t\t\t\t\t\tdone[t] = cost + 1;\n\t\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tvector< vector<char> > init(8,vector<char>(8,0)) ;\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[3+i][3+j] = c;\n\t}\n\trep(i,4)rep(j,4) good[i+3][j+3] = 1;\n\t\n\tcout << f(0,init) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int &cost,int &S,int &idx,int &stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\n\tint ny=y-i+k;\n\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n    \n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a, b; vector<int> x, y; string tmp;\n\nmap<unsigned, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tunsigned finish = 0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tswitch (tmp[j])\n\t\t\t{\n\t\t\tcase 'R': finish += (1 << (i * 8 + j * 2));\n\t\t\tcase 'G': finish += (1 << (i * 8 + j * 2)) * 2;\n\t\t\tcase 'B': finish += (1 << (i * 8 + j * 2)) * 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<unsigned, int> > que;\n\n\tque.push(make_pair(0, 0)); D[0] = true;\n\n\twhile (true)\n\t{\n\t\tunsigned M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (finish == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < 3; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tM2 -= (M2 / (1 << (l * 8 + m * 2))) % 4;\n\t\t\t\t\t\t\t\tM2 += (1 << (l * 8 + m * 2));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF 100\n\nint N;\nint H[16], W[16];\nstring C[4];\n\nstring color = \"RGB\";\nint mask[16][16][16][16];\nint Cmask[3];\n\nvoid printState(int state)\n{\n\trep(y, 0, 4)\n\t{\n\t\trep(x, 0, 4)\n\t\t{\n\t\t\tint m = (state >> (15 - (y * 4 + x))) & 1;\n\t\t\tcout << m;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint solve()\n{\n\tqueue<int> que;\n\n\tque.push(0);\n\t\n\tint dist[1 << 16];\n\trep(i, 0, 1 << 16) dist[i] = INF;\n\tdist[0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint state = que.front(); que.pop();\n\n\t\tif (state == (1 << 16) - 1) return dist[state];\n\n\t\trep(i, 0, N) rep(j, 0, 3)\n\t\t{\n\t\t\trep(ssy, -(H[i] - 1), 4) rep(ssx, -(W[i] - 1), 4)\n\t\t\t{\n\t\t\t\tint ttx = ssx + W[i] - 1;\n\t\t\t\tint tty = ssy + H[i] - 1;\n\n\t\t\t\tint sx = max(ssx, 0);\n\t\t\t\tint sy = max(ssy, 0);\n\t\t\t\tint tx = min(ttx, 3);\n\t\t\t\tint ty = min(tty, 3);\n\n\t\t\t\t//cout << \"--------------\" << endl;\n\t\t\t\t//printState(state);\n\n\t\t\t\tint m = (~mask[sx][sy][tx][ty]) & ((1 << 16) - 1);\n\t\t\t\tint nstate = state & m;\n\t\t\t\tint mm = Cmask[j] & mask[sx][sy][tx][ty];\n\t\t\t\tnstate = nstate | mm;\n\n\t\t\t\tif (dist[nstate] == INF)\n\t\t\t\t{\n\t\t\t\t\tdist[nstate] = dist[state] + 1;\n\t\t\t\t\tque.push(nstate);\n\t\t\t\t}\n\n\t\t\t\t//cout << endl;\n\t\t\t\t//printState(nstate);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N)\n\t{\n\t\trep(i, 0, N) cin >> H[i] >> W[i];\n\t\trep(i, 0, 4) cin >> C[i];\n\n\t\trep(sx, 0, 4) rep(tx, sx, 4) rep(sy, 0, 4) rep(ty, sy, 4)\n\t\t{\n\t\t\tint m = 0;\n\n\t\t\trep(y, 0, 4) rep(x, 0, 4)\n\t\t\t{\n\t\t\t\tif ((sx <= x && x <= tx) && (sy <= y && y <= ty))\n\t\t\t\t\tm = (m << 1) + 1;\n\t\t\t\telse\n\t\t\t\t\tm = (m << 1);\n\t\t\t}\n\n\t\t\tmask[sx][sy][tx][ty] = m;\n\t\t}\n\n\t\trep(i, 0, 3)\n\t\t{\n\t\t\tint m = 0;\n\t\t\trep(y, 0, 4) rep(x, 0, 4)\n\t\t\t{\n\t\t\t\tif (C[y][x] == color[i])\n\t\t\t\t\tm = (m << 1) + 1;\n\t\t\t\telse\n\t\t\t\t\tm = m << 1;\n\t\t\t}\n\t\t\tCmask[i] = m;\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nstruct P {\n    int cost;\n    uint16_t bit;\n};\n\nchar colorchar[] = {'R', 'G', 'B'};\nchar G[1<<16];\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pii> stamp(N);\n    REP(i, N) {\n        cin >> stamp[i].second >> stamp[i].first;\n    }\n    vvc field(4, vc(4));\n    REP(y, 4) REP(x, 4) {\n        cin >> field[y][x];\n    }\n\n    uint16_t goal = (1<<16)-1;\n\n    queue<uint16_t> que;\n    G[0] = 0;\n    que.push(0);\n    while (!que.empty()) {\n        uint16_t p = que.front(); que.pop();\n        if (p == goal) {\n            printf(\"%d\\n\", G[p]);\n            break;\n        }\n        REP(i, N) {\n            FOR(ly, -stamp[i].second+1, 4) FOR(lx, -stamp[i].first+1, 4) {\n                int rx = lx + stamp[i].first, ry = ly + stamp[i].second;\n                uint16_t bit[3] = {p, p, p};\n                FOR(sy, ly, ry) FOR(sx, lx, rx) {\n                    if (0 <= sx && sx < 4 && 0 <= sy && sy < 4) {\n                        REP(j, 3) {\n                            int k = 4*sy+sx;\n                            if (field[sy][sx] == colorchar[j]) {\n                                bit[j] |= 1<<k;\n                            } else {\n                                bit[j] &= ~(1<<k);\n                            }\n                        }\n                    }\n                }\n                REP(j, 3) {\n                    if (!G[bit[j]]) {\n                        G[bit[j]] = G[p]+1;\n                        que.push(bit[j]);\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <complex>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dist[1 << 16];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tvector<int> h(n), w(n);\n\trep(i, n) cin >> h[i] >> w[i];\n\tvector<string> board(4);\n\trep(i, 4) cin >> board[i];\n\n\tset<P> x;\n\trep(i, n) rep(r, 8) rep(c, 8) for(char col: string(\"RGB\")){\n\t\tint mask = 0;\n\t\tint ok = 0;\n\n\t\tchar b[12][12] = {};\n\t\tfor (int j = r; j < r + h[i]; ++j){\n\t\t\tfor (int k = c; k < c + w[i]; ++k){\n\t\t\t\tb[j][k] = col;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 4; j < 8; ++j){\n\t\t\tfor (int k = 4; k < 8; ++k){\n\t\t\t\tif (!b[j][k]) continue;\n\t\t\t\tint y = 1 << ((j - 4) * 4 + k - 4);\n\t\t\t\tmask |= y;\n\t\t\t\tif (b[j][k] == board[j - 4][k - 4]) ok |= y;\n\t\t\t}\n\t\t}\n\t\tx.insert(MP(mask, ok));\n\t}\n\n\tqueue<int> q;\n\tq.push(0);\n\tMEMSET(dist, -1);\n\tdist[0] = 0;\n\twhile (!q.empty()){\n\t\tint s = q.front();\n\t\tq.pop();\n\n\t\tfor (auto p : x){\n\t\t\tint nxt = (s&~p.first) | p.second;\n\t\t\tif (dist[nxt] >= 0) continue;\n\t\t\tdist[nxt] = dist[s] + 1;\n\t\t\tif (nxt + 1 == (1 << 16)){\n\t\t\t\tcout << dist[nxt] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tq.push(nxt);\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\n\tint ny=y-i+k;\n\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,v=1<<16;\n  cin>>n;\n  int h[n],w[n],dp[v],used[v];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(int i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=v-1-(1<<(y*4+x));\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[v-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\n\nvoid Min(int &a,int b){a=min(a,b);}\nint Idx(int y,int x){return y*4+x;}\n\nint getBit(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\n\ntypedef pair<int,int> P;\nint DP(){\n  vector<int>D(1<<16,INF);\n  queue<int> Q;\n  Q.push(0);\n  D[0]=0;\n  while(!Q.empty()){\n    int bit=Q.front();Q.pop();\n    if(bit==(1<<16)-1)break;\n    for(int i=0;i<3;i++)\n      for(int a=0;a<16;a++)\n\tfor(int b=0;b<16;b++)\n\t  if(can[a][b]){\n\t    data yx=(data){a/4,a%4};\n\t    data YX=(data){b/4,b%4};\n\t    int nbit=getBit(bit,yx,YX,RGB[i]);\n\t    if(D[nbit]==INF)Q.push(nbit),D[nbit]=D[bit]+1;\n\t  }\n\n  }\n  return D[(1<<16)-1];\n}\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, bd[1<<16];\nint H[16], W[16];\nVS orig(4);\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i,N) cin >> H[i] >> W[i];\n  REP(i,4) cin >> orig[i];\n\n  priority_queue<PII, vector<PII>, greater<PII>> pq;\n  fill(bd, bd+(1<<16), 1000);\n  bd[0] = 0;\n  pq.push(MP(0,0));\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint ct = pii.first;\n\tint state = pii.second;\n\tif(ct > bd[state]) continue;\n\n\tREP(i,N){\n\t  for(int y=-H[i]+1;y<4;++y){\n\t\tfor(int x=-W[i]+1;x<4;++x){\n\t\t  int tmp = state;\n\t\t  char c = ' ';\n\t\t  for(int dy=0;dy<H[i];++dy){\n\t\t\tint ty = y + dy;\n\t\t\tif(ty < 0 || 4 <= ty) continue;\n\t\t\tfor(int dx=0;dx<W[i];++dx){\n\t\t\t  int tx = x + dx;\n\t\t\t  if(tx < 0 || 4 <= tx) continue;\n\t\t\t  if(c == ' ') c = orig[ty][tx];\n\t\t\t  if(c == orig[ty][tx])\n\t\t\t\ttmp = tmp | (1 << (ty*4+tx));\n\t\t\t  else\n\t\t\t\ttmp = tmp & ~(1 << (ty*4+tx));\n\t\t\t}\n\t\t  }\n\t\t  if(bd[tmp] > ct+1){\n\t\t\tbd[tmp] = ct + 1;\n\t\t\tpq.push(MP(bd[tmp], tmp));\n\t\t  }\n\t\t}\n\t  }\n\t}\n  }\n  \n\n  cout << bd[(1<<16)-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst int all=(1<<16)-1;\nint n,h[20],w[20];\nint memo[1<<16];\nchar board[4][4];\nchar cur[10][10];\n\nint rec(int mask){\n\tif(mask==all) return 0;\n\tint &ret=memo[mask];\n\tif(ret!=-1) return ret;\n\n\tret=1010;\n\t\n\trep(idx,n){\n\t\trep(si,10)rep(sj,10){\n\t\t\tconst int ti=si+h[idx],tj=sj+w[idx];\n\t\t\tif(ti<=3||7<=si) continue;\n\t\t\tif(tj<=3||7<=sj) continue;\n\n\t\t\tbool ok=true;\n\t\t\tchar tar=-1;\n            int nmask=mask;\n            rep(a,h[idx])rep(b,w[idx]){\n                const int ca=si+a,cb=sj+b;\n                if(ca<3||7<=ca) continue;\n                if(cb<3||7<=cb) continue;\n                if(cur[ca][cb]=='*') continue;\n \t\t\t\tif(tar==-1||tar==cur[ca][cb])\n \t\t\t\t\ttar=cur[ca][cb];\n \t\t\t\telse\n \t\t\t\t\tok=false; \n                nmask|=bit(4*(ca-3)+(cb-3));\n            }\n\n            if(ok&&nmask>mask){\n            \tif(memo[nmask]!=-1){\n            \t\tchmin(ret,rec(nmask)+1);\n            \t}else{\n        \t\t\tconst int change=nmask^mask;\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]='*';\n\t            \tchmin(ret,rec(nmask)+1);\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]=board[i][j];\n            \t}\n            }\n\t\t}\n\t\tif(ret==1) break;\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\n\trep(i,4) rep(j,4) cin >> board[i][j];\n\trep(i,10)rep(j,10) cur[i][j]='*';\n\trep(i,4)rep(j,4) cur[i+3][j+3]=board[i][j];\n\tclr(memo,-1);\n\tcout << rec(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\n\nvoid Min(int &a,int b){a=min(a,b);}\nint Idx(int y,int x){return y*4+x;}\n\nint nsta(int sta,data a,data b){\n  int res=sta;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++)\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(1<<Idx(i,j));\n  return res;\n}\n\nint dp[1<<16];\nvoid DP(){\n  for(int i=0;i<(1<<16);i++)dp[i]=INF;\n  dp[0]=0;\n  \n  for(int bit=0;bit<(1<<16);bit++)\n    for(int a=0;a<4;a++)\n      for(int b=0;b<4;b++)\n\tfor(int c=a;c<4;c++)\n\t  for(int d=b;d<4;d++)\n\t    if(can[Idx(a,b)][Idx(c,d)])\n\t      Min(dp[nsta(bit,(data){a,b},(data){c,d})],dp[bit]+1);\n}\n\n\nvoid mk_can(){\n  memset(can,0,sizeof(can));\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=0;y<7;y++)\n      for(int x=0;x<7;x++){\n\tint a=max(0,y-3),b=max(0,x-3);\n\tint Y=min(3,y+h-4);\n\tint X=min(3,x+w-4);\n\tif(X<0||Y<0)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint RGB[3];\nint get_mincost(int sta,int idx){\n  int res=INF;\n  for(int bit=0;bit<(1<<16);bit++){\n    if((RGB[idx]&bit)!=RGB[idx])continue;\n    if((sta&bit))continue;\n    res=min(res,dp[bit]);\n  }\n  return res;\n}\n\nint used[3];\nint dfs(int sta,int dep){\n  if(dep==3)return 0;\n  int res=INF;\n  for(int i=0;i<3;i++){\n    if(used[i])continue;\n    used[i]=1;\n    res=min(res,get_mincost(sta,i)+dfs(sta+RGB[i],dep+1));\n    used[i]=0;\n  }\n  return res; \n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n\n  RGB[0]=RGB[1]=RGB[2]=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      char ch;\n      cin>>ch;\n      RGB[0]=RGB[0]*2+(ch=='R');\n      RGB[1]=RGB[1]*2+(ch=='G');\n      RGB[2]=RGB[2]*2+(ch=='B');\n    }\n \n  mk_can();\n  DP();\n  cout<<dfs(0,0)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n#define bit(i,j) (1<<((i)<<2)+(j))\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tvector<int> stamp;\n\trep(i,n){\n\t\tint h,w; scanf(\"%d%d\",&h,&w);\n\t\tfor(int k=1-h;k<4;k++) for(int l=1-w;l<4;l++) for(int c=1;c<=3;c++) {\n\t\t\tint S=0;\n\t\t\tfor(int y=k;y<k+h;y++) for(int x=l;x<l+w;x++) {\n\t\t\t\tif(0<=y && y<4 && 0<=x && x<4) S|=bit(y,x);\n\t\t\t}\n\t\t\tstamp.push_back(S);\n\t\t}\n\t}\n\n\tsort(stamp.begin(),stamp.end());\n\tstamp.erase(unique(stamp.begin(),stamp.end()),stamp.end());\n\n\tint goal[4][4];\n\trep(i,4){\n\t\tchar s[5]; scanf(\"%s\",s);\n\t\trep(j,4){\n\t\t\tif(s[j]=='R') goal[i][j]=0;\n\t\t\tif(s[j]=='G') goal[i][j]=1;\n\t\t\tif(s[j]=='B') goal[i][j]=2;\n\t\t}\n\t}\n\n\tbool visited[1<<16];\n\trep(S,1<<16) visited[S]=(S==0);\n\n\tint ans;\n\tqueue< pair<int,int> > qu; qu.push(make_pair(0,0));\n\twhile(1){\n\t\tint S=qu.front().first;\n\t\tint cnt=qu.front().second; qu.pop();\n\n\t\tif(S==(1<<16)-1){ ans=cnt; break; }\n\n\t\trep(k,stamp.size()) rep(c,3) {\n\t\t\tint S2=S;\n\t\t\trep(i,4) rep(j,4) if(stamp[k]&bit(i,j)) {\n\t\t\t\tif(goal[i][j]==c) S2|=bit(i,j);\n\t\t\t\telse              S2&=~bit(i,j);\n\t\t\t}\n\t\t\tif(!visited[S2]){\n\t\t\t\tvisited[S2]=true;\n\t\t\t\tqu.push(make_pair(S2,cnt+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct area{\n  int bx, by, ex, ey;\n  area(int bx, int by, int ex, int ey) :\n    bx(bx), by(by), ex(ex), ey(ey) {}\n  bool operator < (const area& a) const {\n    if(bx != a.bx) return bx < a.bx;\n    if(by != a.by) return by < a.by;\n    if(ex != a.ex) return ex < a.ex;\n    return ey < a.ey;\n  }\n  bool contain(int x, int y){\n    return (bx <= x && x <= ex && by <= y && y <= ey);\n  }\n};\nvoid print(int S){\n  REP(y, 4){\n    REP(x, 4) cout<<(bool)(S & (1 << (y * 4 + x)))<<\" \";\n    cout<<endl;\n  }\n}\n\nint main(){\n  int N;\n  while(cin>>N){\n    set<area> cand_s;\n    REP(i, N){\n      int w, h; cin>>h>>w;\n      for(int x = -3; x < 3; x++){\n        for(int y = -3; y < 3; y++){\n          cand_s.insert(area(max(0, x), max(0, y), min(3, x + w - 1), min(3, y + h - 1)));\n        }\n      }\n    }\n    vector<area> cand(cand_s.begin(), cand_s.end());\n    int bitmap[100][4] = {};\n    char mapset[4] = \"RGB\";\n\n    int grid[4][4];\n    for(int y = 0; y < 4; y++){\n      string s; cin>>s;\n      for(int x = 0; x < 4; x++){\n        for(int c = 0; c < 3; c++){\n          if(s[x] == mapset[c]) grid[y][x] = c; \n        }\n      }\n    }\n    for(int i = 0; i < cand.size(); i++){\n      for(int y = 0; y < 4; y++){\n        for(int x = 0; x < 4; x++){\n          if(cand[i].contain(x, y)){\n            bitmap[i][3] |= (1 << (4 * y + x));\n            bitmap[i][grid[y][x]] |= (1 << (4 * y + x));\n          }\n        }\n      }\n    }\n    int dist[1<<16];\n    fill(dist, dist + (1<<16), INF);\n    dist[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()){\n      int S = que.front(); que.pop();\n      //printf(\"S:%d dist:%d\\n\", S, dist[S]);\n      //print(S);\n      //cout<<endl;\n      if(S == (1<<16) - 1) break;\n      for(int i = 0; i < cand.size(); i++){\n        for(int c = 0; c < 3; c++){\n          int nS = (S & ~bitmap[i][3]) | bitmap[i][c];\n          if(dist[nS] != INF) continue;\n          dist[nS] = dist[S] + 1;\n          que.push(nS);\n        }\n      }\n    }\n    cout<<dist[(1<<16) - 1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    bool flag[4][4][5][5][3];\n    fill_n((bool*)flag,4*4*5*5*3,false);\n    rep(y1,0,4) rep(x1,0,4) rep(y2,y1+1,5) rep(x2,x1+1,5) rep(y,y1,y2) rep(x,x1,x2) flag[y1][x1][y2][x2][c[y][x]]=true;\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    vector<int> cost(1<<16,inf);\n    queue<bitset<16>> que;\n    cost[0]=0;\n    que.push(bitset<16>(0));\n    while(!que.empty()){\n        auto bs=move(que.front());\n        que.pop();\n        int state=encode(bs);\n        if(bs.all()){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-h[i]+1,4) rep(x,-w[i]+1,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            rep(j,0,3){\n                if(!flag[y1][x1][y2][x2][j]) continue;\n                auto next_bs=bs;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j) next_bs.set(4*y_+x_);\n                    else next_bs.reset(4*y_+x_);\n                }\n                int next_state=encode(next_bs);\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(move(next_bs));\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S, f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\n\tint ny=y-i+k;\n\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(S&(1<<p)) f=1;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(!f&&d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct State{\n\tint lx, ly, rx, ry;\n\tState(int lx_, int ly_, int rx_, int ry_){\n\t\tlx = lx_; ly = ly_; rx = rx_; ry = ry_;\n\t}\n};\n\nconst int INF = 1e+8;\nbool stamp[4][4][4][4] = {0};\nvector<State> v;\nchar C[5][5];\nint d[1<<16];\nchar color[3] = {'R','G','B'};\n\n\nvoid init(){\n\tfor(int ly=0 ; ly < 4 ; ly++ ){\n\t\tfor(int lx=0 ; lx < 4 ; lx++ ){\n\t\t\tfor(int ry=0 ; ry < 4 ; ry++ ){\n\t\t\t\tfor(int rx=0 ; rx < 4 ; rx++ ){\n\t\t\t\t\tstamp[ly][lx][ry][rx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid check_stamp(int w, int h){\n\tfor(int dy = -3 ; dy <= 3 ; dy++ ){\n\t\tfor(int dx = -3 ; dx <= 3 ; dx++ ){\n\t\t\tint lx=4, ly=4, rx=-1, ry=-1;\n\t\t\tfor(int y = dy ; y < dy + h ; y++ ){\n\t\t\t\tfor(int x = dx ; x < dx + w ; x++ ){\n\t\t\t\t\tif( x < 0 || y < 0 || 4 <= x || 4 <= y ) continue;\n\t\t\t\t\tlx = min(lx, x);\n\t\t\t\t\tly = min(ly, y);\n\t\t\t\t\trx = max(rx, x);\n\t\t\t\t\try = max(ry, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( lx < 0 || 4 <= lx || ly < 0 || 4 <= ly ) continue;\n\t\t\tif( rx < 0 || 4 <= rx || ry < 0 || 4 <= ry ) continue;\n\t\t\tstamp[ly][lx][ry][rx] = true;\n\t\t}\n\t}\n}\n\nint solve(){\n\tfor(int i=0 ; i < (1<<16) ; i++ ){\n\t\td[i] = INF;\n\t}\n\td[0] = 0;\n\tqueue<int> q;\n\tq.push( 0 );\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint bits = q.front();\n\t\tint cost = d[bits];\n\t\tq.pop();\n\t\t\n\t\tif( bits == (1<<16)-1 ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=0 ; j < 3 ; j++ ){\n\t\t\t\tint next = bits;\n\t\t\t\tfor(int y=0 ; y < 4 ; y++ ){\n\t\t\t\t\tfor(int x=0 ; x < 4 ; x++ ){\n\t\t\t\t\t\tif( v[i].ly <= y && y <= v[i].ry && v[i].lx <= x && x <= v[i].rx ){\n\t\t\t\t\t\t\tif( next & (1<<(y*4+x)) ){ // テヲツュツ」テ」ツ?療」ツ??」ツ?ィテ」ツ?禿」ツつ催」ツ?ォティツ可イjテ」ツつ津・ツ。ツ療」ツつ?\n\t\t\t\t\t\t\t\tif( color[j] != C[y][x] ){ // 1 => 0\n\t\t\t\t\t\t\t\t\tnext = next & ~(1<<(y*4+x));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{ // テヲツュツ」テ」ツ?療」ツ?湘・ツ。ツ療」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?ィテ」ツ?禿」ツつ催」ツ?ォテ・ツ。ツ療」ツつ?\n\t\t\t\t\t\t\t\tif( color[j] == C[y][x] ){ // 0 => 1\n\t\t\t\t\t\t\t\t\tnext = next | (1<<(y*4+x));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( d[next] == INF ){\n\t\t\t\t\td[next] = cost + 1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid make_stamp(){\n\t// テ」ツつケテ」ツつソテ」ツδウテ」ツδ療」ツ?ョテ・ツ。ツ療」ツつ甘ヲツ鳴ケテ」ツ?ョテ」ツδ?」ツつァテ」ツδε」ツつッ (テ・ツ、ツ堙」ツ?湘」ツ?ヲテ」ツつ?00テゥツ?堙」ツつ?\n\tfor(int ly=0 ; ly < 4 ; ly++ ){\n\t\tfor(int lx=0 ; lx < 4 ; lx++ ){\n\t\t\tfor(int ry = ly ; ry < 4 ; ry++ ){\n\t\t\t\tfor(int rx = lx ; rx < 4 ; rx++ ){\n\t\t\t\t\tif( stamp[ly][lx][ry][rx] ){\n\t\t\t\t\t\tif( lx < 0 || 4 <= lx || ly < 0 || 4 <= ly ) continue;\n\t\t\t\t\t\tif( rx < 0 || 4 <= rx || ry < 0 || 4 <= ry ) continue;\n\t\t\t\t\t\tv.push_back( State(lx,ly,rx,ry) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\t\n\tint N;\n\tcin >> N;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tcheck_stamp(w, h);\n\t}\n\tfor(int y=0 ; y < 4 ; y++ ){\n\t\tcin >> C[y];\n\t}\n\tmake_stamp();\n\t\n\tint ans = solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\n\n\nvoid mark(int cost,int S,int stamp){\n\n  int color;\n  \n  for(int y=0;y<M+h[stamp];y++){\n\n    for(int x=0;x<M+w[stamp];x++){\n      \n      if(!(y<0||x<0||M<=y||M<=x))color=s[y][x];\n      \n      int nS=S;\n\t\n      for(int i=0;i<h[stamp];i++){\n\t\n\tfor(int j=0;j<w[stamp];j++){\n\n\t  int ny=y-i, nx=x-j;\n\t\n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==color) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n    \n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n\t\n\n    }\n\n      \n  \n  }\n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int k=0;k<n;k++) mark(cost,S,k);\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,H[17],W[17];\nint c[5][5];\nint dist[1<<16];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N)cin>>H[i]>>W[i];\n\trep(i,4)rep(j,4){\n\t\tchar C;\n\t\tcin>>C;\n\t\tc[i][j] = C=='R' ? 0 : C=='G' ? 1 : 2;\n\t}\n\trep(i,1<<16)dist[i] = INF;\n\tdist[0] = 0;\n\tqueue<int> Q;\n\tQ.push(0);\n\twhile(sz(Q)){\n\t\tint mask = Q.front(); Q.pop();\n\t\tif(mask == (1<<16)-1){\n\t\t\treturn cout<<dist[mask]<<endl,0;\n\t\t}\n\t\tint done[4][4][4][4][3] = {};\n\t\trep(i,N){\n\t\t\trep2(y,-H[i]+1,4)rep2(x,-W[i]+1,4)rep(color,3){\n\t\t\t\tint nmask = mask;\n\t\t\t\tint y0 = max(0, y);\n\t\t\t\tint x0 = max(0, x);\n\t\t\t\tint y1 = min(3, y+H[i]-1);\n\t\t\t\tint x1 = min(3, x+W[i]-1);\n\t\t\t\tif(done[y0][x0][y1][x1][color])continue;\n\t\t\t\tdone[y0][x0][y1][x1] = 1;\n\t\t\t\trep(ii,H[i])rep(jj,W[i]){\n\t\t\t\t\tint Y = y+ii, X = x+jj;\n\t\t\t\t\tif(Y<0 || Y>=4 || X<0 || X>=4)continue;\n\t\t\t\t\tif(c[Y][X] == color) nmask |= 1<<Y*4+X;\n\t\t\t\t\telse nmask &= ~(1<<Y*4+X);\n\t\t\t\t}\n\t\t\t\tif(dist[nmask] > dist[mask] + 1){\n\t\t\t\t\tdist[nmask] = dist[mask] + 1;\n\t\t\t\t\tQ.push(nmask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<> h(n), w(n); for (int i = 0; i < n; ++i) cin >> h[i] >> w[i];\n  V<string> s(4); for (auto&& e : s) cin >> e;\n  V<> d(1 << 16, -1);\n  queue<int> que;\n  d[0] = 0;\n  que.push(0);\n  while (!que.empty()) {\n    int bit = que.front(); que.pop();\n    if (bit == ~(~0 << 16)) return cout << d.back() << '\\n', 0;\n    for (int k = 0; k < n; ++k) {\n      for (int x = 1 - h[k]; x < 4; ++x) for (int y = 1 - w[k]; y < 4; ++y) {\n        int nbit = bit;\n        int r = 0, g = 0, b = 0;\n        for (int i = max(x, 0); i < min(x + h[k], 4); ++i) for (int j = max(y, 0); j < min(y + w[k], 4); ++j) {\n          if (bit >> i * 4 + j & 1) continue;\n          r += s[i][j] == 'R';\n          g += s[i][j] == 'G';\n          b += s[i][j] == 'B';\n          nbit |= 1 << i * 4 + j;\n        }\n        if (d[nbit] == -1 and r + g + b and max({r, g, b}) == r + g + b) {\n          d[nbit] = d[bit] + 1;\n          que.push(nbit);\n        }\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\n#define M 4\nusing namespace std;\n\nint n,h[N],w[N];\nstring s[M];\n\nbool dp[N+1][(1<<N)];\n\nvoid mark(int cnt,int S,int idx,int stamp){\n  \n  int y=idx/4,x=idx%4;\n  \n  for(int i=0;i<h[stamp];i++){\n\n    for(int j=0;j<w[stamp];j++){\n\n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<nS)) nS=nS&~(1<<p);\n\n\t}\n      }\n      \n      dp[cnt+1][nS]=true;\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  dp[0][0]=true;\n\n  int ans=N;\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<(1<<N);j++){\n      \n      if(!dp[i][j]) continue;\n      \n      if(j==(1<<N)-1) ans=min(ans,i);\n      \n      for(int y=0;y<M;y++){\n\tfor(int x=0;x<M;x++){\n\t  \n\t  int idx=y*M+x;\n\t  \n\t  if(j&(1<<idx)) continue;\n\t  \n\t  for(int k=0;k<n;k++) mark(i,j,idx,k);\n\t  \n\t}\n      }\n      \n      \n    }\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/02 20:16:19\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<int, int>;\n    vector<P> s(N);\n    for (int i = 0, H, W; i < N; i++) { cin >> H >> W, s[i] = {H, W}; }\n    vector<vector<int>> f(4, vector<int>(4, 0));\n    map<char, int> mp;\n    mp['R'] = 1, mp['G'] = 2, mp['B'] = 3;\n    for (int i = 0; i < 4; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 4; j++) { f[i][j] = mp[s[j]]; }\n    }\n    vector<int> memo(1 << 16, -1);\n    auto dfs = [&](auto&& self, const int hash, const vector<vector<int>>& f) -> int {\n        if (hash == 0) { return 0; }\n        if (memo[hash] != -1) { return memo[hash]; }\n        int ans = 30;\n        for (int i = 0; i < N; i++) {\n            const int H = s[i].first, W = s[i].second;\n            for (int h = 1 - H; h < 4; h++) {\n                for (int w = 1 - W; w < 4; w++) {\n                    const int hinf = max(h, 0), winf = max(w, 0);\n                    const int hsup = min(h + H, 4), wsup = min(w + W, 4);\n                    set<int> ch;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            if (f[i][j] != 0) { ch.insert(f[i][j]); }\n                        }\n                    }\n                    if (ch.size() != 1) { continue; }\n                    auto newf = f;\n                    int h = hash;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            newf[i][j] = 0;\n                            h &= ~(1 << (4 * i + j));\n                        }\n                    }\n                    const int sub = self(self, h, newf) + 1;\n                    ans = min(ans, sub);\n                }\n            }\n        }\n        return memo[hash] = ans;\n    };\n    const int ans = dfs(dfs, (1 << 16) - 1, f);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n;\nint h[22],w[22];\nint cm[3];\nint d[1<<16];\nvector<int> mask;\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  rep(i,n)cin>>h[i]>>w[i];\n  rep(i,4){\n    string s;\n    cin>>s;\n    rep(j,4){\n      if(s[j]=='R')cm[0]|=1<<(i*4+j);\n      if(s[j]=='G')cm[1]|=1<<(i*4+j);\n      if(s[j]=='B')cm[2]|=1<<(i*4+j);\n    }\n  }\n\n  rep(k,n){\n    repl(i,-h[k]+1,4)repl(j,-w[k]+1,4){\n      int m=0;\n      repl(ni,i,i+h[k])repl(nj,j,j+w[k]){\n        if(ni>=0&&ni<4&&nj>=0&&nj<4)m|=1<<(ni*4+nj);\n      }\n      mask.pb(m);\n    }\n  }\n  sort(all(mask)); uni(mask);\n\n  rep(S,1<<16)d[S]=-1;\n  \n  d[0]=0;\n  queue<int> que;\n  que.push(0);\n  while(que.size()){\n    int S=que.front(); que.pop();\n    if(S==(1<<16)-1){\n      cout<<d[S]<<endl;\n      break;\n    }\n    for(int msk : mask){\n      rep(c,3){\n        int cov=cm[c]&msk;\n        int del=~(msk^cov);\n        int nS=(S&del)|cov;\n        if(d[nS]==-1){\n          d[nS]=d[S]+1;\n          que.push(nS);\n        }\n      }\n    }\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\nusing namespace std;\nint N;\nint H[16],W[16];\nint ne[16][7][7] = {};\nint ok[16][7][7][3] = {};\nint dist[1<<16] = {};\nchar C[7][7];\n\nbool in(int x,int y){\n    return 3<=x && x<=6 && 3<=y && y<=6;\n}\n\nint to_line(int x,int y){\n    return 4*(x-3)+(y-3);\n}\n\nint main(){\n   cin >> N;\n   for(int i=0;i<N;i++) cin >> H[i] >> W[i];\n   for(int i=3;i<7;i++){\n      for(int j=3;j<7;j++){\n         cin >> C[i][j];\n      }    \n   }\n   for(int i=0;i<7;i++){\n      for(int j=0;j<7;j++){\n         for(int k=0;k<N;k++){\n            ne[k][i][j] = -1;\n            for(int l=0;l<3;l++) ok[k][i][j][l] = 0;\n            int T = (1<<16)-1;\n            for(int r=0;r<H[k];r++){\n               for(int c=0;c<W[k];c++){\n                  if(in(i+r,j+c)){\n                     T ^= (1<<to_line(i+r,j+c));\n                     if(C[i+r][j+c]=='R'){ok[k][i][j][1] ^= (1<<to_line(i+r,j+c)); ok[k][i][j][2] ^= (1<<to_line(i+r,j+c));}\n                     if(C[i+r][j+c]=='B'){ok[k][i][j][0] ^= (1<<to_line(i+r,j+c)); ok[k][i][j][2] ^= (1<<to_line(i+r,j+c));}\n                     if(C[i+r][j+c]=='G'){ok[k][i][j][1] ^= (1<<to_line(i+r,j+c)); ok[k][i][j][0] ^= (1<<to_line(i+r,j+c));}\n                  }\n               }\n            }\n            ne[k][i][j] = T;\n         }\n      }\n   }\n/*   for(int i=0;i<7;i++){\n      for(int j=0;j<7;j++) cerr << ne[0][i][j] << \" \";\n      cerr << endl;\n   }\n*/   for(int i=0;i<(1<<16);i++) dist[i] = -1;\n   dist[(1<<16)-1] = 0;\n   queue<int> Q;\n   Q.push((1<<16)-1);\n   while(!Q.empty()){\n      int S = Q.front(); Q.pop();\n      for(int i=0;i<7;i++){\n         for(int j=0;j<7;j++){\n            for(int k=0;k<N;k++){\n               for(int l=0;l<3;l++){\n                  if((ne[k][i][j]==(1<<16)-1) || (S & ok[k][i][j][l])!=0) continue;\n                  int T = (S & ne[k][i][j]);\n                  if(dist[T]==-1){\n                     dist[T] = dist[S]+1;\n                     Q.push(T);\n                  }\n               }\n            }\n         }\n      }\n   }\n   cout << dist[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint p[20];\nint q[20];\nchar str[5][5];\nint bfs[1<<16];\nchar col[5]=\"RGB\";\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t}\n\tfor(int i=0;i<4;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<(1<<16);i++)bfs[i]=-1;\n\tbfs[0]=0;\n\tqueue<int>Q;\n\tQ.push(0);\n\twhile(Q.size()){\n\t\tif(~bfs[(1<<16)-1])break;\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=-p[i]+1;j<4;j++){\n\t\t\t\tfor(int k=-q[i]+1;k<4;k++){\n\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\tint to=at;\n\t\t\t\t\t\tfor(int l=0;l<p[i];l++)for(int m=0;m<q[i];m++){\n\t\t\t\t\t\t\tif(j+l<0||k+m<0||j+l>3||k+m>3)continue;\n\t\t\t\t\t\t\tif(str[j+l][k+m]==col[c])to|=(1<<((j+l)*4+k+m));\n\t\t\t\t\t\t\telse to&=(~(1<<((j+l)*4+k+m)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!~bfs[to]){\n\t\t\t\t\t\t\tbfs[to]=bfs[at]+1;\n\t\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs[(1<<16)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar Color[3] = {'R', 'G', 'B'};\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> h(n);\n    vector<int> w(n);\n    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];\n    string C;\n    for(int i = 0; i < 4; i++){\n        string tmp; cin >> tmp;\n        C = C + tmp;\n    }\n\n    queue<pair<int, int> > que;                  //cost bit(一致していたら1そうでなければ0)\n    \n    vector<bool> used((1 << 16), false);\n    used[0] = true;\n    que.push({0, 0});\n\n    while(!que.empty()){\n\n        int bit = que.front().second;\n        int cost = que.front().first;\n        //cout << cost << \" \" << str << endl;\n        que.pop();\n\n        if(bit == (1 << 16) - 1){\n            cout << cost << endl;\n            break;\n        }\n\n        for(int ii = 0; ii < n; ii++){\n\n            for(char color : Color){\n\n                //cout << i << \" \" << color << endl;\n                for(int si = -3; si <= 3; si++){\n                    for(int sj = -3; sj <= 3; sj++){\n                        int gi = si + h[ii] - 1;\n                        int gj = sj + w[ii] - 1;\n\n                        int next;\n                        next = bit;\n                        //cout << i << \" \" << si << \" \" << gi << \" \" << sj << \" \" << gj << \" \" << endl;\n                        for(int i = max(si, 0); i <= min(gi, 3); i++){\n                            for(int j = max(sj, 0); j <= min(gj, 3); j++){            \n                                int idx = i * 4 + j;\n                                if(C[idx] == color) next = next | (1 << idx);\n                                else next = next & ~(1 << idx);\n                            }\n                        }\n\n                        if(!used[next]){\n                            //cout << \"ok\" << endl;\n                            used[next] = true;\n                            que.push({cost + 1, next});\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define len 4\n#define inf 1e9\nusing namespace std;\n\nstruct data {\n  int h, w;\n};\n\nlong long n;\nvector<long long> dp;\nvector<data> v;\nvector<string> c;\nvector<vector<int>> num;\n\nint calc(char x) {\n  if(x == 'R') return 0;\n  if(x == 'G') return 1;\n  return 2;\n}\nlong long solve(long long bit);\n\nint main() {\n  cin >> n;\n  v.resize(n);\n  for(int i = 0; i < n; ++i) cin >> v[i].h >> v[i].w;\n  c.resize(len);\n  for(int i = 0; i < len; ++i) cin >> c[i];\n  num.assign(len, vector<int>(len, 0));\n  for(int i = 0; i < len; ++i)\n    for(int j = 0; j < len; ++j) num[i][j] = calc(c[i][j]);\n  dp.assign(1 << (len * len), -1);\n  dp[(1 << (len * len)) - 1] = 0;\n  cout << solve(0) << endl;\n  return 0;\n}\n\nlong long solve(long long bit) {\n  if(dp[bit] != -1) return dp[bit];\n  long long res = inf;\n  for(int i = 0; i < n; ++i)\n    for(int col = 0; col < 3; ++col)\n      for(int x = -3; x < len; ++x)\n        for(int y = -3; y < len; ++y) {\n          long long nextbit = bit;\n          bool ch = 1;\n          if(x + v[i].h <= 0 || y + v[i].w <= 0) continue;\n          for(int j = 0; j < v[i].h; ++j)\n            if(ch && x + j < len)\n              for(int k = 0; k < v[i].w; ++k) {\n                if(y + k >= len) break;\n                if(x + j < 0 || y + k < 0) continue;\n                int id = (x + j) * len + y + k;\n                if(!(nextbit >> id & 1) &&\n                   col == num[x + j][y + k])\n                  nextbit += 1LL << id;\n                if(!(nextbit >> id & 1) &&\n                   col != num[x + j][y + k]) {\n                  ch = 0;\n                  break;\n                }\n              }\n          if(nextbit == bit || !ch) continue;\n          res = min(res, solve(nextbit));\n        }\n\n  return dp[bit] = res + 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<int> h,w;\n\nvector<vector<int>> fie(4,vector<int>(4));\n\nvector<int> dist(1 << 16,-1);\n\nint main(){\n\tcin >> n;\n\th.resize(n);\n\tw.resize(n);\n\trep(i,0,n - 1) cin >> h[i] >> w[i];\n\trep(i,0,3)rep(j,0,3){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') fie[i][j] = 0;\n\t\tif(c == 'G') fie[i][j] = 1;\n\t\tif(c == 'B') fie[i][j] = 2;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\tdist[0] = 0;\n\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tif(v == (1 << 16) - 1)\n\t\t{\n\t\t\tcout << dist[v] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(c,0,2) rep(s,0,n - 1){\n\t\t\trep(i,-h[s] + 1,3) rep(j,-w[s] + 1,3){\n\t\t\t\tint u = v;\n\t\t\t\trep(x,max(i,0),min(i + h[s] - 1,3)) rep(y,max(j,0),min(j + w[s] - 1,3)){\n\t\t\t\t\tint index = (x * 4 + y);\n\t\t\t\t\tif(u & (1 << index)){\n\t\t\t\t\t\tif(fie[x][y] != c) u ^= (1 << index);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(fie[x][y] == c) u ^= (1 << index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dist[u] == -1){\n\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  bool used[1<<16];\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=-3;j<4;j++){\n\tfor(int k=-3;k<4;k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=0;a<h[i];a++){\n\t      for(int b=0;b<w[i];b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(y<0||y>=4||x<0||x>=4) continue;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint n;\nint h[20],w[20];\nconst int H=4,W=4;\nint ans=16;\n\nset<string> used;\n\nint dfs(string s){\n    map<string,int> mp;\n    queue<string> que;\n    que.push(s);\n    while(que.size()){\n        s=que.front();que.pop();\n        rep(i,n){\n            REP(j,-H,H)REP(k,-W,W){\n                set<char> st;\n                rep(l,h[i])rep(m,w[i]){\n                    if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W&&s[(j+l)*H+k+m]!='*'){\n                        st.insert(s[(j+l)*H+k+m]);\n                    }\n                }\n                if(st.size()!=1)continue;\n                string ns=s;\n                rep(l,h[i])rep(m,w[i]){\n                    if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W){\n                        ns[(j+l)*H+k+m]='*';\n                    }\n                }\n                if(!mp.count(ns)){\n                    mp[ns]=mp[s]+1;\n                    que.push(ns);\n                }\n            }\n        }\n    }\n    return mp[\"****************\"];\n}\n\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>h[i]>>w[i];\n    }\n    string s;\n    rep(i,4){\n        string t;\n        cin>>t;\n        s+=t;\n    }\n    cout<<dfs(s)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> H(N), W(N);\n  REP(i, 0, N) cin >> H[i] >> W[i];\n  char S[4][4];\n  REP(i, 0, 4) REP(j, 0, 4) cin >> S[i][j];\n\n  vector<ll> dp(1LL << 16, -1);\n  queue<ll> q;\n  q.push(0);\n  dp[0] = 0;\n  while(q.size()) {\n    ll s = q.front();\n    q.pop();\n\n    if(s == (1LL << 16) - 1) break;\n\n    REP(i, 0, N) {\n      REP(py, -H[i] + 1, 4) REP(px, -W[i] + 1, 4) REP(c, 0, 3) {\n        ll n = s;\n        REP(y, max(py, 0LL), min(py + H[i], 4LL)) REP(x, max(px, 0LL), min(px + W[i], 4LL)) {\n          if(0 <= y && y < 4 && 0 <= x && x < 4) {\n            const string Z = \"RGB\";\n            if(S[y][x] == Z[c]) n = n | (1LL << (y * 4 + x));\n            else n = ~(~n | (1LL << (y * 4 + x)));\n          }\n        }\n        if(dp[n] == -1) {\n          dp[n] = dp[s] + 1;\n          q.push(n);\n        }\n      }\n    }\n  }\n  cout << dp[(1LL << 16) - 1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int N, H[16], W[16];\n  string S[4];\n  const string temp = \"RGB\";\n  int v[1 << 16];\n  fill_n(v, 1 << 16, INF);\n  queue< int > que;\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> H[i] >> W[i];\n  }\n  for(int i = 0; i < 4; i++) {\n    cin >> S[i];\n    for(int j = 0; j < 4; j++) {\n      S[i][j] = temp.find(S[i][j]);\n    }\n  }\n\n  que.emplace(0);\n  v[0] = 0;\n  while(!que.empty()) {\n    int p = que.front();\n    que.pop();\n    if(p == (1 << 16) - 1) {\n      cout << v[p] << endl;\n      break;\n    }\n    for(int i = -3; i < 4; i++) {\n      for(int j = -3; j < 4; j++) {\n        for(int z = 0; z < 3; z++) {\n          for(int k = 0; k < N; k++) {\n            int tugi = p;\n            for(int l = 0; l < H[k]; l++) {\n              if(i + l < 0 || i + l >= 4) continue;\n              for(int n = 0; n < W[k]; n++) {\n                if(j + n < 0 || j + n >= 4) continue;\n                int y = i + l, x = j + n;\n                if((tugi >> (y * 4 + x)) & 1)\n                  tugi &= ~(S[i + l][j + n] != z) << (y * 4 + x);\n                else\n                  tugi |= (S[i + l][j + n] == z) << (y * 4 + x);\n              }\n            }\n            if(v[tugi] > v[p] + 1) {\n              que.emplace(tugi);\n              v[tugi] = v[p] + 1;\n            }\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[8][8];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 4; i < 8; i++) for(int j = 4; j < 8; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[8][8];\n\t\trep(i,8) rep(j,8) b[i][j] = 0;\n\t\tfor(int i = 4; i < 8; i++) for(int j = 4; j < 8; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,8){\n\t\t\t\tif(j+h[i] > 8) break;\n\t\t\t\trep(k,8){\n\t\t\t\t\tif(k+w[i] > 8) break;\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 7; hh >= 4; hh--){\n\t\t\t\t\t\t\tfor(int ww = 7; ww >= 4; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst char of[] = \"RGB\";\n\nint N, H[20], W[20];\nchar f[4][4];\nint Qi, Qn, Q[65536], dp[65536];\nint m, mask[1000], chg[256][4];\n\nint main() {\n    scanf(\"%d\", &N);\n    rep(i, N) scanf(\"%d%d\", H+i, W+i);\n    rep(i, 4) rep(j, 4) scanf(\" %c\", f[i]+j);\n    rep(k, N) for(int i=-3; i<4; i++) for(int j=-3; j<4; j++) {\n        int b = 0;\n        const int xmx = min(i+H[k], 4), ymx=min(j+W[k], 4);\n        for(int x=max(i, 0); x<xmx; x++) {\n            for(int y=max(j, 0); y<ymx; y++) {\n                b |= 1<<(x*4+y);\n            }\n        }\n        mask[m++] = b;\n    }\n    sort(mask, mask+m);\n    m = unique(mask, mask+m)-mask;\n    rep(i, m) rep(x, 4) rep(y, 4) if(mask[i]&(1<<(x*4+y))) {\n        rep(k, 3) if(f[x][y]==of[k]) chg[i][k] |= 1<<(x*4+y);\n    }\n    rep(i, m) mask[i] = ~mask[i];\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    Q[Qn++] = 0;\n    while(Qi<Qn && dp[65535]==-1) {\n        const int cur = Q[Qi++];\n        rep(i, m) rep(k, 3) {\n            const int nxt = (cur&mask[i]) | chg[i][k];\n            if(dp[nxt]==-1) {\n                dp[nxt] = dp[cur]+1;\n                Q[Qn++] = nxt;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[65535]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                           //    #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint n;\nstring s[4];\nint h[20],w[20];\nint dp[1<<16];\n\npriority_queue<pa,vector<pa>,greater<pa>> pq;   \n\n   signed main(){\ncin>>n;\n   \tfor(int i=0;i<n;i++)cin>>h[i]>>w[i];\n   \tfor(int i=0;i<(1<<16);i++)dp[i]=-1;\n   \tfor(int i=0;i<4;i++)cin>>s[i];\n   \tstring ss=\"RBG\";\n   \t\n   \tpq.push(mp(0,0));\n   \twhile(pq.size()>0){\n   \t\tpa z=pq.top();\n   \t\tpq.pop();\n   \t\tif(dp[z.second]>=0) continue;\n   \t\tdp[z.second]=z.first;\n   \t\tif(z.second+1==(1<<16)){\n   \t\tcout<<z.first<<endl;\n   \t\t\treturn 0;\n   \t\t}\n   \t//\tif(z.first==1)\tcout<<bitset<16>(z.second)<<\" \"<<z.first <<endl;\n   \t\tfor(int k=0;k<n;k++){\n   \t\t\tfor(auto c:ss)for(int i=1-h[k];i<4;i++)for(int j=1-w[k];j<4;j++){\n   \t\t\t\tint bit=z.second;\n   \t\t\t\tfor(int x=max(i,0);x<min(i+h[k],4);x++)for(int y=max(j,0);y<min(j+w[k],4);y++){\n   \t\t\t\t\tif(s[x][y]==c) bit=bit|(1<<((y)*4+x));\n   \t\t\t\t\telse if(bit&((1<<((y)*4+x)))) bit -= (1<<((y)*4+x));\n   \t\t\t\t}\n   \t\t\t\tif(dp[bit]<0)\tpq.push(mp(z.first+1,bit));\n   \t\t\t}\n   \t\t}\n   \t}\n   \t\n   \t\n   \tcout<<dp[(1<<16)-1]<<endl;\n   \t\n   \t\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, h[16], w[16], col[3];\nchar in[4][5];\nbool v[1 << 16];\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> h[i] >> w[i];\n\trep(i, 4){\n\t\tcin >> in[i];\n\t\trep(j, 4) rep(k, 3){\n\t\t\tif(in[i][j] == \"RGB\"[k]) col[k] |= 1 << i * 4 + j;\n\t\t}\n\t}\n\t\n\tvi stamp;\n\trep(i, n) for(int j = -h[i] + 1; j < 5 - h[i]; j++) for(int k = -w[i] + 1; k < 5 - w[i]; k++){\n\t\tint tx = min(max(0, j), 3), TX = min(max(0, j + h[i] - 1), 3);\n\t\tint ty = min(max(0, k), 3), TY = min(max(0, k + w[i] - 1), 3);\n\t\t\n\t\tint bit = 0;\n\t\tfor(int l = tx; l <= TX; l++) for(int m = ty; m <= TY; m++)\n\t\tbit |= 1 << 4 * l + m;\n\t\tstamp.pb(bit);\n\t}\n\tsort(all(stamp));\n\tstamp.erase(unique(all(stamp)), stamp.end());\n\tint m = stamp.size();\n\t\n\tqueue<pi> q;\n\tq.push(mp(0, 0));\n\tv[0] = 1;\n\twhile(!q.empty()){\n\t\tint c = q.front().first, bit = q.front().second; q.pop();\n\t\t\n\t\trep(i, stamp.size()) rep(j, 3){\n\t\t\tint nxt = bit & ~stamp[i] | stamp[i] & col[j];\n\t\t\tif(v[nxt]) continue;\n\t\t\tv[nxt] = 1;\n\t\t\tif(nxt == (1 << 16) - 1){\n\t\t\t\tcout << c + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tq.push(mp(c + 1, nxt));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nvector< pair<int,int> > mask;\n\nvector< vector<char> > goal(4,vector<char>(4));\n\nint w[20],h[20];\n\ninline void gen(int s,int x,int y){\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(b)mask.push_back(make_pair(a,b));\n\t}\n}\nint f(int init){\n\tQ[size++] = init;\n\tmemo[init] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,mask.size()){\n\t\t\tint bit = (q & ~mask[i].first) | mask[i].second;\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[i][j] = c;\n\t}\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\tsort(mask.begin(),mask.end());\n\tmask.erase(unique(mask.begin(),mask.end()),mask.end());\n\t\n\tcout << f(0) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//???1:AC?????????\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row1,int arg_row2,int arg_col1,int arg_col2){\n\t\trow1 = arg_row1;\n\t\trow2 = arg_row2;\n\t\tcol1 = arg_col1;\n\t\tcol2 = arg_col2;\n\t}\n\tint row1,row2,col1,col2;\n};\n\nstruct Data{\n\tbool table[4][4];\n\tint count;\n};\n\nbool can_stamp[4][4][4][4];\nbool check[65536];\nint POW[17];\n\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < POW[16]; i++)check[i] = false;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++)can_stamp[a][b][c][d] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint height,width;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&height,&width);\n\n\t\tfor(int row2 = 0; row2 <= 3; row2++){\n\t\t\tint row1 = max(0,row2-height+1);\n\n\t\t\tfor(int col2 = 0; col2 <= 3; col2++){\n\t\t\t\tint col1 = max(0,col2-width+1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t\tfor(int col1 = 0; col1 <= 3; col1++){\n\t\t\t\tint col2 = min(3,col1+width-1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int row1 = 0; row1 <= 3; row1++){\n\t\t\tint row2 = min(3,row1+height-1);\n\n\t\t\tfor(int col2 = 0; col2 <= 3; col2++){\n\t\t\t\tint col1 = max(0,col2-width+1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\n\t\t\tfor(int col1 = 0; col1 <= 3; col1++){\n\t\t\t\tint col2 = min(3,col1+width-1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Info> V;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(can_stamp[a][b][c][d]){\n\t\t\t\t\t\tV.push_back(Info(a,b,c,d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tchar ans_table[4][5];\n\tfor(int row = 0; row < 4; row++){\n\t\tscanf(\"%s\",ans_table[row]);\n\t}\n\n\tData first;\n\tfirst.count = 0;\n\tfor(int row = 0; row < 4; row++){\n\t\tfor(int col = 0; col < 4; col++)first.table[row][col] = false;\n\t}\n\tcheck[0] = true;\n\n\tqueue<Data> Q;\n\tQ.push(first);\n\n\tbool FLG;\n\tchar base[4][4],work[4][4];\n\n\tint index,tmp_code;\n\n\tchar colors[3] = {'R','G','B'};\n\n\twhile(!Q.empty()){\n\n\t\tFLG = true;\n\t\tfor(int row = 0; row < 4; row++){\n\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\tif(Q.front().table[row][col] == false){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbase[row][col] = '@';\n\t\t\t\t}else{\n\t\t\t\t\tbase[row][col] = ans_table[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"%d\\n\",Q.front().count);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\n\t\t\tFLG = true;\n\t\t\tfor(int row = V[i].row1; row <= V[i].row2; row++){\n\t\t\t\tfor(int col = V[i].col1; col <= V[i].col2; col++){\n\t\t\t\t\tif(Q.front().table[row][col] == false){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\n\t\t\tif(FLG)continue;\n\n\t\t\tfor(int paint = 0; paint < 3; paint++){\n\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\twork[row][col] = base[row][col];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int row = V[i].row1; row <= V[i].row2; row++){\n\t\t\t\t\tfor(int col = V[i].col1; col <= V[i].col2; col++){\n\t\t\t\t\t\twork[row][col] = colors[paint];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tindex = 0,tmp_code = 0;\n\t\t\t\tData next_data;\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\tif(work[row][col] == ans_table[row][col]){\n\t\t\t\t\t\t\ttmp_code += POW[index];\n\t\t\t\t\t\t\tnext_data.table[row][col] = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_data.table[row][col] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(check[tmp_code])continue;\n\n\t\t\t\tcheck[tmp_code] = true;\n\t\t\t\tnext_data.count = Q.front().count+1;\n\t\t\t\tQ.push(next_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint p[20];\nint q[20];\nchar str[5][5];\nint bfs[1<<16];\nchar col[5]=\"RGB\";\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t}\n\tfor(int i=0;i<4;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<(1<<16);i++)bfs[i]=-1;\n\tbfs[0]=0;\n\tqueue<int>Q;\n\tQ.push(0);\n\twhile(Q.size()){\n\t\tif(~bfs[(1<<16)-1])break;\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=-p[i]+1;j<4;j++){\n\t\t\t\tfor(int k=-q[i]+1;k<4;k++){\n\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\tint to=at;\n\t\t\t\t\t\tfor(int l=max(0,-j);l<min(p[i],4-j);l++)for(int m=max(0,-k);m<min(q[i],4-k);m++){\n\t\t\t\t\t\t\t//if(j+l<0||k+m<0||j+l>3||k+m>3)continue;\n\t\t\t\t\t\t\tif(str[j+l][k+m]==col[c])to|=(1<<((j+l)*4+k+m));\n\t\t\t\t\t\t\telse to&=(~(1<<((j+l)*4+k+m)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!~bfs[to]){\n\t\t\t\t\t\t\tbfs[to]=bfs[at]+1;\n\t\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs[(1<<16)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n;\n  R n;\n  P a[n];\n  rep(i,n) cin >> a[i].F >> a[i].S;\n  string s[4];\n  rep(i,4) R s[i];\n  int dp[1<<16];\n  rep(i,1<<16) dp[i]=MAX;\n  dp[0]=0;\n  rep(t,1<<16) {\n    if(dp[t]==MAX) continue;\n    rep(k,n)REP(l,-a[k].F+1,4)REP(r,-a[k].S+1,4) {\n      int z=0,e=0;\n      REP(x,max(0,l),min(4,l+a[k].F)) {\n        REP(y,max(0,r),min(4,r+a[k].S)) {\n          z|=1<<(x*4+y);\n          if(!(t&(1<<x*4+y))) {\n            if(s[x][y]=='R') e|=1<<0;\n            if(s[x][y]=='G') e|=1<<1;\n            if(s[x][y]=='B') e|=1<<2;\n          }\n          if(!(e==0||e==1||e==2||e==4)) goto next;\n        }\n      }\n      if(e==1||e==2||e==4) dp[t|z]=min(dp[t|z],dp[t]+1);\n    next:;\n    }\n  }\n  pr(dp[(1<<16)-1]);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n\n#define int long long\nint dp[(1 << 16)];\nint color[4][4];\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> inputs;\n    REP(i, n) {\n        int a, b;\n        cin >> a >> b;\n        inputs.push_back(mp(a, b));\n    }\n    REP(i, 4) {\n        string s;\n        cin >> s;\n        REP(q, 4) {\n            if (s[q] == 'R') {\n                color[i][q] = 0;\n            }\n            else if (s[q] == 'B') {\n                color[i][q] = 1;\n            }\n            else if (s[q] == 'G') {\n                color[i][q] = 2;\n            }\n        }\n    }\n    REP(i, (1 << 16)) {\n        dp[i] = 1e9;\n    }\n    dp[0] = 0;\n    queue<int> next;\n    next.push(0);\n    vector<pair<int, int>> itring;\n    REP(q, inputs.size()) {\n        for (int j = -3; j < 4; ++j) {\n            for (int p = -3; p < 4; ++p) {\n                REP(t, 3) {\n                    int die = (1 << 16) - 1;\n                    int adding = 0;\n                    for (int x = j; x < j + inputs[q].first; ++x) {\n                        for (int y = p; y < p + inputs[q].second; ++y) {\n                            if (x >= 0 && x <= 3 && y >= 0 && y <= 3) {\n                                die -= (1 << (x * 4 + y));\n                                if (color[x][y] == t) {\n                                    adding += (1 << (x * 4 + y));\n                                }\n                            }\n                        }\n                    }\n                    itring.push_back(mp(die, adding));\n                }\n            }\n        }\n    }\n    while (next.empty() == false) {\n        int now = next.front();\n        next.pop();\n        for (auto x : itring) {\n            int hoge = (now & x.first) + x.second;\n            if (dp[hoge] == 1e9) {\n                dp[hoge] = dp[now] + 1;\n                next.push(hoge);\n            }\n        }\n    }\n    cout << dp[(1 << 16) - 1] << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RREP(i,x) for(int i=(x)-1;i>=0;i--)\n#define RFOR(i,c) for(auto i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint n;\nint c[10][10];\nint visit[1<<16];\nmain(){\n\tcin >> n;\n\tvector<pii> stamp(n);\n\tREP(i, n){\n\t\tcin >> stamp[i].first >> stamp[i].second;\n\t}\n\tREP(i, 4)REP(j, 4){\n\t\tchar ch;\n\t\tcin >> ch;\n\t\tif(ch == 'R') c[i][j] = 1;\n\t\tif(ch == 'G') c[i][j] = 2;\n\t\tif(ch == 'B') c[i][j] = 3;\n\t}\n\tqueue<int> q;\n\tq.push(0);\n\tREP(i, 1<<16) visit[i] = 30;\n\tvisit[0] = 0;\n\twhile(!q.empty()){\n\t\tint b = q.front();q.pop();\n\t\tif(b == (1<<16)-1) break;\n\t\tREP(i, n){\n\t\t\tint h = stamp[i].first;\n\t\t\tint w = stamp[i].second;\n\t\t\tfor(int sy=-h+1;sy<4;sy++)for(int sx=-w+1;sx<4;sx++){\n\t\t\t\tint col = -1;\n\t\t\t\tint bt = b;\n\t\t\t\tfor(int y=sy;y<sy+h;y++)for(int x=sx;x<sx+w;x++){\n\t\t\t\t\tif(bt==-1||x<0||y<0||4<=x||4<=y) continue;\n\t\t\t\t\tif(!((b >> (4*y+x))&1)){\n\t\t\t\t\t\tbt |= 1<<(4*y+x);\n\t\t\t\t\t\tif(col == -1) col = c[y][x];\n\t\t\t\t\t\telse if(col != c[y][x]) bt = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bt >= 0 && visit[bt] > visit[b]+1){\n\t\t\t\t\tvisit[bt] = visit[b]+1;\n\t\t\t\t\tq.push(bt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << visit[(1<<16)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar Color[3] = {'R', 'G', 'B'};\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> h(n);\n    vector<int> w(n);\n    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];\n    string C;\n    for(int i = 0; i < 4; i++){\n        string tmp; cin >> tmp;\n        C = C + tmp;\n    }\n\n    queue<pair<int, int> > que;                  //cost bit(一致していたら1そうでなければ0)\n    \n    vector<bool> used((1 << 16), false);\n    used[0] = true;\n    que.push({0, 0});\n\n    while(!que.empty()){\n\n        int bit = que.front().second;\n        int cost = que.front().first;\n        //cout << cost << \" \" << str << endl;\n        que.pop();\n\n        if(bit == (1 << 16) - 1){\n            cout << cost << endl;\n            break;\n        }\n\n        for(int ii = 0; ii < n; ii++){\n\n            for(char color : Color){\n\n                //cout << i << \" \" << color << endl;\n                for(int si = -3; si <= 3; si++){\n                    for(int sj = -3; sj <= 3; sj++){\n                        int gi = si + h[ii] - 1;\n                        int gj = sj + w[ii] - 1;\n\n                        int next;\n                        next = bit;\n                        //cout << i << \" \" << si << \" \" << gi << \" \" << sj << \" \" << gj << \" \" << endl;\n                        for(int i = max(si, 0); i <= min(gi, 3); i++){\n                            for(int j = max(sj, 0); j <= min(gj, 3); j++){            \n                                int idx = i * 4 + j;\n                                if(C[idx] == color) next = next | (1 << idx);\n                                else next = next & ~(1 << idx);\n                            }\n                        }\n\n                        if(!used[next]){\n                            //cout << \"ok\" << endl;\n                            used[next] = true;\n                            que.push({cost + 1, next});\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef array<string,4> data;\n\nmap<data,int> mp;\n\nvoid output(data a){\n    rep(i,4){\n        rep(j,4){\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    vector<pii> stamp;\n    int n;\n    cin>>n;\n    rep(i,n){\n        int h,w;\n        cin>>h>>w;\n        stamp.pb(pii(h,w));\n    }\n    \n    data vs;\n    rep(i,4)cin>>vs[i];\n    \n    \n    queue<data> que;\n    que.push(vs);\n    mp[vs] = 0;\n    \n    while(que.size()){\n        data q = que.front();\n        que.pop();\n        int dist = mp[q];\n        \n        for(const auto &stm:stamp){\n            int h,w;\n            tie(h,w) = stm;\n            for(int i=-h+1;i<4;i++){\n                for(int j=-w+1;j<4;j++){\n                    int r=0,g=0,b=0;\n                    for(int ii = i;ii<i+h;ii++){\n                        for(int jj = j;jj<j+w;jj++){\n                            if(ii<0 || 4<=ii || jj<0 || 4<=jj)continue;\n                            if( q[ii][jj]=='R' )r++;\n                            if( q[ii][jj]=='G' )g++;\n                            if( q[ii][jj]=='B' )b++;\n                        }\n                    }\n                    int res = (bool)r + (bool)(g) + (bool)(b);\n                    if(res==1){\n                        data tmp = q;;\n                        for(int ii = i;ii<i+h;ii++){\n                            for(int jj = j;jj<j+w;jj++){\n                                if(ii<0 || 4<=ii || jj<0 || 4<=jj)continue;\n                                tmp[ii][jj] = '*';\n                            }\n                        }\n                        if(mp.count(tmp)==0){\n                            int count = 0;\n                            rep(i,4)rep(j,4)if(tmp[i][j]=='*')count++;\n                            if(count==16){\n                                cout<<dist+1<<endl;\n                                return 0;\n                            }\n\n                            que.push(tmp);\n                            mp[tmp] = dist+1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar Color[3] = {'R', 'G', 'B'};\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> h(n);\n    vector<int> w(n);\n    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];\n    string C;\n    for(int i = 0; i < 4; i++){\n        string tmp; cin >> tmp;\n        C = C + tmp;\n    }\n\n    queue<pair<int, int> > que;                  //cost bit(一致していたら1そうでなければ0)\n    set<int> st;\n    st.insert(0);\n    que.push({0, 0});\n\n    while(!que.empty()){\n        int bit = que.front().second;\n        int cost = que.front().first;\n        //cout << cost << \" \" << bitset<16>(bit) << endl;\n        \n        que.pop();\n\n        if(bit == (1 << 16) - 1){\n            cout << cost << endl;\n            break;\n        }\n\n        for(int ii = 0; ii < n; ii++){\n\n            for(char color : Color){\n                \n                //cout << i << \" \" << color << endl;\n                for(int si = -h[ii] + 1; si <= 3; si++){\n                    for(int sj = -w[ii] + 1; sj <= 3; sj++){\n                        \n                        int gi = si + h[ii] - 1;\n                        int gj = sj + w[ii] - 1;\n                        if(gi < 0 || gj < 0) continue;\n\n                        if(gi >= 4) gi = 3;\n                        if(gj >= 4) gj = 3; \n                        //cout << si << \" \" << gi << \" \" << sj << \" \" << gj << \" \" << endl;\n                        //assert(si <= gi);\n                        int next = bit;\n                        for(int i = si; i <= gi; i++){\n                            for(int j = sj; j <= gj; j++){\n\n                                if(0 <= i && i < 4 && 0 <= j && j < 4){\n                                    int idx = i * 4 + j;\n                                    if(C[idx] == color) next = next | (1 << idx);\n                                    else next = next & ~(1 << idx);\n                                }\n                            }\n\n                        }\n\n                        if(st.find(next) == st.end()){\n                            //cout << \"ok\" << endl;\n                            st.insert(next);\n                            que.push({cost + 1, next});\n\n                            //cout << \"push \" << cost + 1 << \" \" << bitset<16>(next) << endl;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int MAXN = 16;\nconst int H = 4;\nconst int W = 4;\nconst char C[3] = {'R','G','B'};\nconst int INF = 1<<28;\n\nint n;\nchar goal[H][W];\nint h[MAXN], w[MAXN];\nbool vis[1<<(W*H)];\n\ninline int getId(const int &x, const int &y) {\n  return x + y * W;\n}\n\nint stamp(int state, int x, int y, int w, int h, char c) {\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      int nx = x + j;\n      int ny = y + i;\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      int id = getId(nx,ny);\n      state = (state & ~(1<<id));\n      if(goal[ny][nx] == c) state |= (1<<id);\n    }\n  }\n  return state;\n}\n\nint bfs() {\n  queue<int> que;\n  int vis[1<<(W*H)];\n  que.push(0);\n  fill(vis,vis+(1<<(W*H)), INF);\n  vis[0] = 0;\n  while(!que.empty()) {\n    int s = que.front();\n    que.pop();\n    for(int k = 0; k < n; ++k) {\n      for(int m = 0; m < 3; ++m) {\n\tfor(int x = 1-w[k]; x < W; ++x) {\n\t  for(int y = 1-h[k]; y < H; ++y) {\n\t    int ns = stamp(s,x,y,w[k],h[k],C[m]);\n\t    if(vis[ns] != INF) continue;\n\t    vis[ns] = vis[s] + 1;\n\t    que.push(ns);\n\t    if(ns == (1<<(W*H))-1) return vis[ns];\n\t  }\n\t}\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> n) { \n    for(int i = 0; i < n; ++i) {\n      cin >> h[i] >> w[i];\n    }\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> goal[i][j];\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 4;\nbool canp[N][N][N+1][N+1];\n\nint main(void){\n    int n; cin >> n;\n    vi hs(n), ws(n);\n    rep(i, n) cin >> hs[i] >> ws[i];\n\n    vector<string> field(N);\n    for(auto & e : field) cin >> e;\n\n    rep(i, n){\n        int h = hs[i], w = ws[i];\n\n        rep(y, N){\n            rep(x, N){\n                int lh = h;\n                if(y == 0 or y == 3) lh = 1;\n\n                int lw = w;\n                if(x == 0 or x == 3) lw = 1;\n\n                rep(hh, lh, h + 1){\n                    rep(ww, lw, w + 1){\n                        canp[y][x][min(hh, N - y)][min(ww, N - x)] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    assert(canp[0][0][1][1]);\n    assert(canp[3][3][1][1]);\n    assert(canp[0][3][1][1]);\n    assert(canp[3][0][1][1]);\n\n    queue<int> q;\n    q.push(0);\n    vi min_dist(1 << (N * N), inf);\n    min_dist[0] = 0;\n\n    string colors = {'R', 'G', 'B'};\n    while(q.size()){\n        int state = q.front(); q.pop();\n\n        rep(y, N){\n            rep(x, N){\n                rep(h, 1, N - y + 1){\n                    rep(w, 1, N - x + 1){\n                        if(not canp[y][x][h][w]) continue;\n\n                        for(auto & c : colors){\n                            int nstate = state;\n                            rep(yy, y, y + h){\n                                rep(xx, x, x + w){\n                                    if(field[yy][xx] == c){\n                                        nstate |= (1 << (yy * 4 + xx));\n                                    }\n                                    else {\n                                        nstate &= ~(1 << (yy * 4 + xx));\n                                    }\n                                }\n                            }\n                            if(chmin(min_dist[nstate], min_dist[state] + 1)){\n                                if(nstate == (1 << (N * N)) - 1){\n                                    cout << min_dist[nstate] << endl;\n                                    return 0;\n                                }\n                                q.push(nstate);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 角を使えばどんな状況でも最悪16回で描ける\n// 16マスそれぞれを正しい色で塗られている/塗られていないの2進数で表せば状態の数は2^16通り\n// でBFS\n\nint n, h[16], w[16], d[1<<16], s[4][4];\nstring S[4];\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4) {\n\t\tcin >> S[i];\n\t\trep(j,4) {\n\t\t\tif (S[i][j]=='R') s[i][j] = 0;\n\t\t\telse if (S[i][j]=='G') s[i][j] = 1;\n\t\t\telse s[i][j] = 2;\n\t\t}\n\t}\n\trep(i,1<<16) d[i] = inf;\n\td[0] = 0;\n\t\n\t\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint b = q.front(); q.pop();\n\t\tif (__builtin_popcount(b)==16) continue;\n\t\trep(i,n) rep(sw,2) {\n\t\t\trep(c,3) reps(x,-3,4) reps(y,-3,4) {\n\t\t\t\tint bb = b;\n\t\t\t\treps(xx,max(x,0),min(x+h[i],4)) reps(yy,max(y,0),min(y+w[i],4)) {\n\t\t\t\t\tif (s[xx][yy]==c) bb |= (1<<(xx*4+yy));\n\t\t\t\t\telse bb ^= (bb&1<<(xx*4+yy));\n\t\t\t\t}\n\t\t\t\tif (d[bb]>d[b]+1) d[bb] = d[b]+1, q.push(bb);\n\t\t\t}\n\t\t\tswap(h[i],w[i]);\n\t\t}\n\t}\n\tcout << d[(1<<16)-1] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,v.size()){\n      int y=v[k].first;\n      int x=v[k].second;\n      for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n          for(int col=0;col<3;col++){\n            r(kk,4)tmp[kk]=t[kk];\n            //if(p.second==0)r(kk,4)cout<<tmp[kk]<<endl;\n            for(int i1=i,c1=0;c1<y;c1++,i1++){\n              for(int j1=j,c2=0;c2<x;c2++,j1++){\n                if(0<=i1&&i1<4&&0<=j1&&j1<4)tmp[i1][j1]=ccol[col];\n              }\n            }\n            int tp=0;\n            //if(p.second==2)r(kk,4)cout<<tmp[kk]<<endl;\n            r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n            //cout<<p.second<<' '<<(__builtin_popcount(tp))<<endl;\n            if(!dp[tp]){\n              dp[tp]=1;\n              q.push(P(tp,p.second+1));\n            }\n          }\n        }\n      }\n    }\n    r(k,v.size()){\n      int y=v[k].first;\n      int x=v[k].second;\n      for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n          for(int col=0;col<3;col++){\n            r(kk,4)tmp[kk]=t[kk];\n            //if(p.second==0)r(kk,4)cout<<tmp[kk]<<endl;\n            for(int i1=i,c1=0;c1<y;c1++,i1--){\n              for(int j1=j,c2=0;c2<x;c2++,j1--){\n                if(0<=i1&&i1<4&&0<=j1&&j1<4)tmp[i1][j1]=ccol[col];\n              }\n            }\n            int tp=0;\n            //if(p.second==2)r(kk,4)cout<<tmp[kk]<<endl;\n            r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n            //cout<<p.second<<' '<<(__builtin_popcount(tp))<<endl;\n            if(!dp[tp]){\n              dp[tp]=1;\n              q.push(P(tp,p.second+1));\n            }\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) { if ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4]; else F[i / 4][i % 4] = 0; }\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = -2; j <= 3; j++) {\n\t\t\t\tfor (int k = -2; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint L[4][4]; for (int l = 0; l < 16; l++)L[l / 4][l % 4] = F[l / 4][l % 4];\n\t\t\t\t\t\tfor (int l = 0; l < x[i].first; l++) {\n\t\t\t\t\t\t\tfor (int m = 0; m < x[i].second; m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m;\n\t\t\t\t\t\t\t\tif (cx < 0 || cy < 0 || cx >= 4 || cy >= 4)continue;\n\t\t\t\t\t\t\t\tif (L[cx][cy] >= 1 && col[cx][cy] != o) { L[cx][cy] = 0; }\n\t\t\t\t\t\t\t\telse if (L[cx][cy] == 0 && col[cx][cy] == o) { L[cx][cy] = o; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = 0; for (int l = 0; l < 16; l++) { if (L[l / 4][l % 4] >= 1)bits += (1 << l); }\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct area{\n  int bx, by, ex, ey;\n  area(int bx, int by, int ex, int ey) :\n    bx(bx), by(by), ex(ex), ey(ey) {}\n  bool operator < (const area& a) const {\n    if(bx != a.bx) return bx < a.bx;\n    if(by != a.by) return by < a.by;\n    if(ex != a.ex) return ex < a.ex;\n    return ey < a.ey;\n  }\n  bool contain(int x, int y){\n    return (bx <= x && x <= ex && by <= y && y <= ey);\n  }\n  void print(){\n    printf(\"x: %d->%d y: %d->%d\\n\", bx, ex, by, ey);\n  }\n};\nvoid print(int S){\n  REP(y, 4){\n    REP(x, 4) cout<<(bool)(S & (1 << (y * 4 + x)))<<\" \";\n    cout<<endl;\n  }\n}\n\nint main(){\n  int N;\n  while(cin>>N){\n    set<area> cand_s;\n    REP(i, N){\n      int w, h; cin>>h>>w;\n      for(int x = -(w - 1); x < 4; x++){\n        for(int y = -(h - 1); y < 4; y++){\n          cand_s.insert(area(max(0, x), max(0, y), min(3, x + w - 1), min(3, y + h - 1)));\n        }\n      }\n    }\n    vector<area> cand(cand_s.begin(), cand_s.end());\n    int bitmap[100][4] = {};\n    char mapset[4] = \"RGB\";\n\n    int grid[4][4];\n    for(int y = 0; y < 4; y++){\n      string s; cin>>s;\n      for(int x = 0; x < 4; x++){\n        for(int c = 0; c < 3; c++){\n          if(s[x] == mapset[c]) grid[y][x] = c; \n        }\n      }\n    }\n    for(int i = 0; i < cand.size(); i++){\n      for(int y = 0; y < 4; y++){\n        for(int x = 0; x < 4; x++){\n          if(cand[i].contain(x, y)){\n            bitmap[i][3] |= (1 << (4 * y + x));\n            bitmap[i][grid[y][x]] |= (1 << (4 * y + x));\n          }\n        }\n      }\n    }\n    int dist[1<<16];\n    fill(dist, dist + (1<<16), INF);\n    dist[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()){\n      int S = que.front(); que.pop();\n      //printf(\"S:%d dist:%d\\n\", S, dist[S]);\n      //print(S);\n      //cout<<endl;\n      if(S == (1<<16) - 1) break;\n      for(int i = 0; i < cand.size(); i++){\n        for(int c = 0; c < 3; c++){\n          int nS = (S & ~bitmap[i][3]) | bitmap[i][c];\n          if(dist[nS] != INF) continue;\n          dist[nS] = dist[S] + 1;\n          que.push(nS);\n        }\n      }\n    }\n    cout<<dist[(1<<16) - 1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4];\n\t\t\telse F[i / 4][i % 4] = 0;\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = 1 - (int)x[i].second; j <= 3; j++) {\n\t\t\t\tfor (int k = 1 - (int)x[i].first; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint L[4][4]; for (int l = 0; l < 16; l++)L[l >> 2][l & 3] = F[l >> 2][l & 3];\n\t\t\t\t\t\tfor (int l = 0; l < x[i].first; l++) {\n\t\t\t\t\t\t\tfor (int m = 0; m < x[i].second; m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m;\n\t\t\t\t\t\t\t\tif (cx < 0 || cy < 0 || cx >= 4 || cy >= 4)continue;\n\t\t\t\t\t\t\t\tif (L[cx][cy] >= 1 && col[cx][cy] != o) { L[cx][cy] = 0; }\n\t\t\t\t\t\t\t\telse if (L[cx][cy] == 0 && col[cx][cy] == o) { L[cx][cy] = o; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = 0;\n\t\t\t\t\t\tfor (int l = 0; l < 16; l++) { if (L[l >> 2][l & 3] >= 1)bits += (1 << l); }\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef array<string,4> data;\n\nnamespace std {\n    template <>\n    class hash< array<string,4> > {\n    public:\n        size_t operator()(const array<string,4>& x) const{\n            return hash<string>()(x[0]) ^ hash<string>()(x[1]) ^ hash<string>()(x[2]) ^ hash<string>()(x[3]);\n        }\n    };\n}\n\nunordered_map<data,int> mp;\n\nint main(){\n    vector<pii> stamp;\n    int n;\n    cin>>n;\n    rep(i,n){\n        int h,w;\n        cin>>h>>w;\n        stamp.pb(pii(h,w));\n    }\n    \n    data vs;\n    rep(i,4)cin>>vs[i];\n    \n    \n    queue<data> que;\n    que.push(vs);\n    mp[vs] = 0;\n    \n    while(que.size()){\n        data q = que.front();\n        que.pop();\n        int dist = mp[q];\n        \n        for(const auto &stm:stamp){\n            int h,w;\n            tie(h,w) = stm;\n            for(int i=-h+1;i<4;i++){\n                for(int j=-w+1;j<4;j++){\n                    int r=0,g=0,b=0;\n                    for(int ii = i;ii<i+h;ii++){\n                        ii = max(ii,0);\n                        if(ii>=4)break;\n                        for(int jj = j;jj<j+w;jj++){\n                            jj = max(jj,0);\n                            if(jj>=4)break;\n                            \n                            if( q[ii][jj]=='R' )r++;\n                            if( q[ii][jj]=='G' )g++;\n                            if( q[ii][jj]=='B' )b++;\n                            if( (bool)r + (bool)(g) + (bool)(b)>=2 )goto end_loop;\n                        }\n                    }\n                end_loop:;\n                    if( (bool)r + (bool)(g) + (bool)(b)==1 ){\n                        data tmp = q;;\n                        for(int ii = i;ii<i+h;ii++){\n                            for(int jj = j;jj<j+w;jj++){\n                                if(ii<0 || 4<=ii || jj<0 || 4<=jj)continue;\n                                tmp[ii][jj] = '*';\n                            }\n                        }\n                        if(mp.count(tmp)==0){\n                            int count = 0;\n                            rep(i,4)rep(j,4)if(tmp[i][j]=='*')count++;\n                            if(count==16){\n                                cout<<dist+1<<endl;\n                                return 0;\n                            }\n\n                            que.push(tmp);\n                            mp[tmp] = dist+1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct Elm {\n  int d, bit;\n};\n\nbool operator<(const Elm &e1, const Elm &e2) {\n  return e1.d > e2.d;\n}\n\nint main() {\n  int n; cin >> n;\n  vector<int> vh(n), vw(n);\n  for(int i=0;i<n;++i) {\n    cin >> vh[i] >> vw[i];\n  }\n  vector<string> s(4);\n  for(int i=0;i<4;++i) {\n    cin >> s[i];\n  }\n  int h = 4, w = 4;\n\n  queue<Elm> que;\n  vector<int> d(1<<16, INF);\n  que.push({0, (1<<16)-1});\n  d[(1<<16)-1] = 0;\n  bool ok = false;\n  while(!que.empty()) {\n    if(ok) break;\n    auto now = que.front(); que.pop();\n    if(d[now.bit] < now.d) continue;\n    //cout << now.d << \":\" << bitset<16>(now.bit) << endl;\n    vector<bitset<4>> bs(4);\n    for(int i=0;i<4;++i) {\n      for(int j=0;j<4;++j) {\n        bs[i][j] = (now.bit>>(i*4+j))&1;\n      }\n    }\n\n    for(int i=0;i<n;++i) {\n      if(ok) break;\n      int h1 = -vh[i]+1, w1 = -vw[i]+1;\n      for(int j=h1;j<h;++j) {\n        if(ok) break;\n        for(int k=w1;k<w;++k) {\n          if(ok) break;\n          bool some = false, r = true, g = true, b = true;\n          vector<bitset<4>> nxt = bs;\n          for(int l=max(0, j);l<min(j+vh[i], h);++l) {\n            for(int m=max(0, k);m<min(k+vw[i], w);++m) {\n              if(!nxt[l][m]) continue;\n              nxt[l][m] = 0;\n              some = true;\n              r &= s[l][m] == 'R';\n              g &= s[l][m] == 'G';\n              b &= s[l][m] == 'B';\n            }\n          }\n          if(!some) continue;\n          if(r || g || b) {\n            int nxtbit = 0;\n            for(int l=0;l<4;++l) {\n              for(int m=0;m<4;++m) {\n                nxtbit ^= nxt[l][m]<<(l*4+m);\n              }\n            }\n            if(d[nxtbit] > now.d+1) {\n              d[nxtbit] = now.d+1;\n              que.push({d[nxtbit], nxtbit});\n              if(nxtbit == 0) ok = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  cout << d[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1e9\ntypedef pair<int,int> pii;\n \nint N,C[4][4];\npii stamp[16];\n \ninline int stp(int x,int y,int px,int py,int c,int S){\n    for(int i = max(0,py) ; i < min(py+y,4) ; i++){\n\tfor(int j = max(0,px) ; j < min(px+x,4) ; j++){\n\t    int b = i*4+j;\n\t    if(C[i][j] == c){\n\t\tif((S >> b) & 1) continue;\n\t\tS |= (1<<b);\n\t    }else{\n\t\tif((S >> b) & 1){\n\t\t    S -= (1<<b);\n\t\t}\n\t    }\n\t}\n    }\n    return S;\n}\n \nint solve(){\n    queue<int> Q;\n    Q.push(0);\n    int dist[1<<16];\n    fill(dist,dist+(1<<16),INF);\n    dist[0] = 0;\n \n    while(!Q.empty()){\n\tint S = Q.front(); Q.pop();\n\tif(S == (1<<16)-1){\n\t    return dist[S];\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t    pii p = stamp[i];\n\t    int x = p.second, y = p.first;\n\t    for(int j = 0 ; j < 3 ; j++){\n\t\tfor(int px = -x+1 ; px < 4 ; px++){\n\t\t    for(int py = -y+1 ; py < 4 ; py++){\n\t\t\tint nS = stp(x,y,px,py,j,S);\n\t\t\tif(dist[S]+1 < dist[nS]){\n\t\t\t    dist[nS] = dist[S] + 1;\n\t\t\t    Q.push(nS);\n\t\t\t}\n\t\t    }\n\t\t} \n\t    }\n\t}\n    }\n    return -1;\n}\n \nint change(char ch){\n    if(ch == 'R') return 0;\n    if(ch == 'B') return 1;\n    return 2;\n}\n \nint main(){\n    cin >> N;\n    for(int i = 0 ; i < N ; i++){\n\tcin >> stamp[i].first >> stamp[i].second;\n    }\n    char in;\n    for(int i = 0 ; i < 4 ; i++){\n\tfor(int j = 0 ; j < 4 ; j++){\n\t    cin >> in;\n\t    C[i][j] = change(in);\n\t}    \n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  int a[4][4];\n  r(i,4)r(j,4)a[i][j]=(i*4+j);\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=0;\n  queue<int>q;\n  q.push(0);\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());int rs=0;\n  G.erase(unique(G.begin(),G.end()),G.end());\n  memset(dp,-1,sizeof(dp));\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    int xx=p;\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    int xp=0;\n    r(i,4)r(j,4)if(t[i][j]==s[i][j])xp|=(1<<a[i][j]);\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        r(kk,4)tmp[kk]=t[kk];\n        int tp=xp;\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            tmp[i][j]=ccol[col];\n            if(tmp[i][j]==s[i][j])tp|=(1<<a[i][j]);\n            else if((tp>>a[i][j])&1)tp^=(1<<a[i][j]);\n          }\n        }\n        if(dp[tp]==-1){\n          if(tp==(1<<16)-1){\n            cout<<dp[p]+1<<endl;\n            return 0;\n          }\n          dp[tp]=dp[p]+1;\n          q.push(tp);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tif(j+h[i] < 3 || k+w[i] < 3) continue;\n\t\t\t\t\t//{\n\t\t\t\t\t\tint l = -1;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0){\n\t\t\t\t\t\t\t\t\tl = brd[j+hh][k+ww];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l == -1) continue;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t\tif(x == (1<<16)-1){\n\t\t\t\t\t\t\t\tqueue<int> emp;\n\t\t\t\t\t\t\t\tswap(que,emp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nconst int INF = (1LL<<30);\n\nchar col[] = {'R', 'G', 'B'};\nstring board[4];\nint n, d[1<<16], h[20], w[20];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  REP(i, n) cin >> h[i] >> w[i];\n  REP(i, 4) cin >> board[i];\n\n  REP(i, 1<<16) d[i] = INF;\n  d[0] = 0;\n  queue<int> que;\n  que.push(0);\n\n  while(que.size()) {\n    int bit = que.front(); que.pop();\n    if(bit == (1LL<<16)-1) break;\n    // i番目のはんこで左上を(y,x)で色をcとして押す\n    REP(i, n) FOR(y, -h[i]+1, 4) FOR(x, -w[i]+1, 4) REP(c, 3) {\n      int n_bit = bit;\n      FOR(ny, max(0LL, y), min(y+h[i],4LL)) FOR(nx, max(0LL, x), min(x+w[i],4LL)) {\n        // 押した結果同じ色なら1に、違う色なら0に\n        if(board[ny][nx] == col[c]) n_bit |= 1<<(ny*4+nx);\n        else n_bit &= ~(1<<(ny*4+nx));\n      }\n      if(d[n_bit] == INF) {\n        d[n_bit] = d[bit] + 1;\n        que.push(n_bit);\n      }\n    }\n  }\n\n  cout << d[(1LL<<16)-1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n;\nvi h, w;\nvvi c(4, vi(4));\n\nbool valid(int i, int j, int k, int state){\n    vi cnt(3);\n    rep2(ii, max(0ll, i - h[k] + 1), min(i + 1, 4ll)) {\n        rep2(jj, max(0ll, j - w[k] + 1), min(j + 1, 4ll)) {\n            if ((state >> (4*ii+jj)) & 1) cnt[c[ii][jj]]++;\n        }\n    }\n    int cnt_positive = (int)(cnt[0] > 0) + (int)(cnt[1] > 0) + (int)(cnt[2] > 0);\n    return cnt_positive == 1;\n}\n\nint stamp(int i, int j, int k, int state) {\n    rep2(ii, max(0ll, i - h[k] + 1), min(i + 1, 4ll)) {\n        rep2(jj, max(0ll, j - w[k] + 1), min(j + 1, 4ll)) {\n            state = (state & ((1 << 16) - 1 - (1 << (4*ii+jj))));\n        }\n    }\n    return state;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n;\n    h.resize(n); w.resize(n);\n    rep(i, n) cin >> h[i] >> w[i];\n    rep(i, 4) rep(j, 4) {\n        char x;\n        cin >> x;\n        if (x == 'R') c[i][j] = 0;\n        if (x == 'G') c[i][j] = 1;\n        if (x == 'B') c[i][j] = 2;\n    }\n\n    vi dp(1 << 16, inf);\n    dp[(1 << 16) - 1] = 0;\n    rrep(state, 1 << 16) {\n        // cerr << \"hey!\" << endl;\n        if (dp[state] == inf) continue;\n        rep(k, n) {\n            rep(i, 7) {\n                rep(j, 7) {\n                    // output(i, j, k, state);\n                    if (valid(i, j, k, state)) {\n                        int nstate = stamp(i, j, k, state);\n                        chmin(dp[nstate], dp[state] + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[0] << endl;\n\n/*\n    set<vvi> visited;\n    queue<pair<vvi, int>> que;\n    que.emplace(c, 0);\n    visited.emplace(c);\n    while (!que.empty()) {\n        vvi d;\n        int t;\n        tie(d, t) = que.front(); que.pop();\n        // output(\"t =\", t);\n        // printVV(d);\n        rep(k, n) {\n            rep(i, 7) {\n                rep(j, 7) {\n                    if (valid(i, j, k, d)) {\n                        vvi e = stamp(i, j, k, d);\n                        if (visited.count(e)) continue;\n                        if (e == cleared) {\n                            cout << t + 1 << endl;\n                            return 0;\n                        }\n                        que.emplace(e, t + 1);\n                        visited.emplace(e);\n                    }\n                }\n            }\n        }\n    }\n*/\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nchar col[10][10];\nint h[16],w[16];\n\nvector<PI> ma;\nint memo[1<<16];\n\nint rec(int st){\n  if(st == (1<<16)-1) return 0;\n  if(memo[st] >= 0) return memo[st];\n  //cout << st << endl;\n  int& ret = memo[st] = 1000000;\n  for(int i = 0; i < (int)ma.size(); ++i){\n    int nst = (st & ~ma[i].first) | ma[i].second;\n    ret = min(ret, rec(nst) + 1);\n  }\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; ++i){\n    cin >> h[i] >> w[i];\n  }\n\n  for(int i = 0; i < 4; ++i)\n    for(int j = 0; j < 4; ++j)\n      cin >> col[i][j];\n\n  vector<pair<PI, PI> > box;\n  for(int lx = -3; lx < 4; ++lx)\n    for(int ty = -3; ty < 4; ++ty)\n      for(int i = 0; i < n; ++i){\n        if(lx+h[i]>0 && ty+w[i]>0)\n          box.push_back({{max(lx,0),max(0,ty)},\n                {min(lx+h[i],4),min(ty+w[i],4)}});\n      }\n  sort(box.begin(), box.end());\n  box.erase(unique(box.begin(), box.end()), box.end());\n  //cout << \"h\" << endl;\n  \n  for(int i = 0; i < (int)box.size(); ++i){\n    int lx = box[i].first.first;\n    int ly = box[i].first.second;\n    int ux = box[i].second.first;\n    int uy = box[i].second.second;\n    int mask = 0;\n    int rr = 0;\n    int gg = 0;\n    int bb = 0;\n    for(int cx = lx; cx < ux; ++cx)\n      for(int cy = ly; cy < uy; ++cy){\n        mask |= 1 << (cx*4 + cy);\n        (col[cx][cy]=='R'?rr:\n         col[cx][cy]=='G'?gg:\n         bb) |= 1 << (cx*4 + cy);\n      }\n    ma.push_back({mask,rr});\n    ma.push_back({mask,gg});\n    ma.push_back({mask,bb});\n  }\n  //cout << \"h\" << endl;\n\n  queue<int> q;\n  q.push(0);\n  for(int cc = 0;!q.empty();++cc){\n    queue<int> nq;\n    while(!q.empty()){\n      int cv = q.front();\n      q.pop();\n      if(memo[cv]) continue;\n      memo[cv] = 1;\n      if(cv == (1<<16) - 1){\n        cout << cc << endl;\n        return 0;\n      }\n      for(int i = 0; i < (int)ma.size(); ++i){\n        int nv = (cv & ~ma[i].first) | ma[i].second;\n        if(!memo[nv])\n          nq.push(nv);\n      }\n    }\n    q.swap(nq);\n  }\n  \n  memset(memo, -1, sizeof(memo));  \n  cout << rec(0) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint dist[(1 << 16)];\nint s[4][4];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi h(n), w(n);\n    rep(i,n){\n        cin >> h[i] >> w[i];\n    }\n    rep(i,4){\n        string hoge;\n        cin >> hoge;\n        rep(j,4){\n            if(hoge[j] == 'R'){\n                s[i][j] = 0;\n            }else if(hoge[j] == 'G'){\n                s[i][j] = 1;\n            }else{\n                s[i][j] = 2;\n            }\n        }\n    }\n    rep(i,(1 << 16)){\n        dist[i] = INF;\n    }\n    dist[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        rep(i,3){\n            rep(j,n){\n                srep(k,-h[j]+1,4){\n                    srep(l,-w[j]+1,4){\n                        int nx = p;\n                        srep(t,max(k,0),min(k+h[j],4)){\n                            srep(u,max(l,0),min(l+w[j],4)){\n                                if((p >> (4*t+u))&1){\n                                    if(s[t][u] != i) nx -= (1 << (4*t+u));\n                                }else{\n                                    if(s[t][u] == i) nx += (1 << (4*t+u));\n                                }\n                            }\n                        }\n                        if(dist[nx] > dist[p] + 1){\n                            dist[nx] = dist[p] + 1;\n                            que.push(nx);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << dist[(1 << 16)-1] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) { if ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4]; else F[i / 4][i % 4] = 0; }\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 0; o < 4; o++) {\n\t\t\t\t\t\tint L[4][4]; for (int l = 0; l < 16; l++)L[l / 4][l % 4] = F[l / 4][l % 4];\n\t\t\t\t\t\tfor (int l = 0; l < x[i].first; l++) {\n\t\t\t\t\t\t\tfor (int m = 0; m < x[i].second; m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m;\n\t\t\t\t\t\t\t\tif (cx < 0 || cy < 0 || cx >= 4 || cy >= 4)continue;\n\t\t\t\t\t\t\t\tif (L[cx][cy] >= 1 && col[cx][cy] != o) { L[cx][cy] = 0; }\n\t\t\t\t\t\t\t\telse if (L[cx][cy] == 0 && col[cx][cy] == o) { L[cx][cy] = o; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = 0; for (int l = 0; l < 16; l++) { if (L[l / 4][l % 4] >= 1)bits += (1 << l); }\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,h[16],w[16],l=1<<16,dp[l],used[l];\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(int i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=l-1-(1<<(y*4+x));\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[l-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst int all=(1<<16)-1;\nint n,h[20],w[20];\nint memo[1<<16];\nchar board[4][4];\n\nint rec(int mask){\n\tif(mask==all) return 0;\n\tint &ret=memo[mask];\n\tif(ret!=-1) return ret;\n\n\tret=1010;\n\n\tchar cur[10][10];\n\trep(i,10)rep(j,10) cur[i][j]='*';\n\n\trep(i,4)rep(j,4){\n\t\tif(mask&bit(4*i+j)) continue;\n\t\tcur[i+3][j+3]=board[i][j];\n\t}\n\n\trep(idx,n){\n\t\trep(si,10)rep(sj,10){\n\t\t\tconst int ti=si+h[idx],tj=sj+w[idx];\n\t\t\tif(10<ti||10<tj) continue;\n\n\t\t\tset<char> s;\n\t\t\trep(a,h[idx])rep(b,w[idx]){\n\t\t\t\tif(cur[si+a][sj+b]=='*') continue;\n\t\t\t\ts.insert(cur[si+a][sj+b]);\n\t\t\t}\n\t\t\tif(s.size()!=1) continue;\n\n\t\t\tint nmask=mask;\n\t\t\trep(a,h[idx])rep(b,w[idx]){\n\t\t\t\tconst int ca=si+a,cb=sj+b;\n\t\t\t\tif(ca<3||7<=ca) continue;\n\t\t\t\tif(cb<3||7<=cb) continue;\n\t\t\t\tnmask|=bit(4*(ca-3)+(cb-3));\n\t\t\t}\n\n\t\t\tif(nmask>mask) chmin(ret,rec(nmask)+1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\n\trep(i,4) rep(j,4) cin >> board[i][j];\n\tclr(memo,-1);\n\tcout << rec(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S,f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(S&(1<<p)){\n\t    f=1;\n\t    break;  \n\t  }\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\tif(f)break;\n      }\n      \n      if(!f&&d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\ntypedef pair<int,int> P;\n\nint n;\nint h[16],w[16];\nint b[16][3][8][8],b2[16][3][8][8];\nbool closed[1<<16];\nchar t[10][10],ch[]=\"RGB\";\n\nvoid show(int bit){\n  rep(i,16){\n    if(bit & (1<<i)){\n      cout<<1;\n    }\n    else{\n      cout<<0;\n    }\n  }\n  cout<<endl;\n}\n\nvoid solve(){\n  queue<P> open;\n  memset(closed,0,sizeof(closed));\n  open.push(P(0,0));\n  closed[0] = true;\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n\n    if(p.second == (1<<16)-1){\n      printf(\"%d\\n\",p.first);\n      return;\n    }\n\n    rep(k,n){\n      rep(color,3){\n        REP(si,-h[k]+1,4){\n          REP(sj,-w[k]+1,4){\n            int bit = p.second;\n            bit |= b[k][color][si+4][sj+4];\n            bit -= (bit & b2[k][color][si+4][sj+4]);\n\n            if(!closed[bit]){\n              closed[bit] = true;\n              open.push(P(p.first+1,bit));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"-1\\n\");\n}\n\nint main(void){\n  while(scanf(\"%d\",&n) != EOF){\n    rep(i,n){\n      scanf(\"%d%d\",&h[i],&w[i]);\n    }\n\n    rep(i,4){\n      scanf(\"%s\",t[i]);\n    }\n\n    rep(k,n){\n      rep(color,3){\n        REP(si,-h[k]+1,4){\n          REP(sj,-w[k]+1,4){\n            int bit = 0;\n            int bit2 = 0;\n\n            REP(i,si,si+h[k]){\n              REP(j,sj,sj+w[k]){\n                if(i < 0 || j < 0 || 4 <= i || 4 <= j) continue;\n\n                int tmpBit = (1<<(i*4+j));\n                if(t[i][j] == ch[color]){\n                  bit |= tmpBit;\n                }\n                else{\n                  bit2 |= tmpBit;\n                }\n              }\n            }\n\n            b[k][color][si+4][sj+4] = bit;\n            b2[k][color][si+4][sj+4] = bit2;\n          }\n        }\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 角を使えばどんな状況でも最悪16回で描ける\n// 16マスそれぞれを正しい色で塗られている/塗られていないの2進数で表せば状態の数は2^16通り\n// でBFS\n\nint n, h[16], w[16], d[1<<16], s[4][4];\nstring S[4];\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4) {\n\t\tcin >> S[i];\n\t\trep(j,4) {\n\t\t\tif (S[i][j]=='R') s[i][j] = 0;\n\t\t\telse if (S[i][j]=='G') s[i][j] = 1;\n\t\t\telse s[i][j] = 2;\n\t\t}\n\t}\n\trep(i,1<<16) d[i] = inf;\n\td[0] = 0;\n\t\n\t\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint b = q.front(); q.pop();\n\t\tif (__builtin_popcount(b)==16) continue;\n\t\trep(i,n) rep(sw,2) {\n\t\t\trep(c,3) rep(x,4) rep(y,4) {\n\t\t\t\tint bb = b;\n\t\t\t\treps(xx,x,min(x+h[i],4)) reps(yy,y,min(y+w[i],4)) {\n\t\t\t\t\tif (s[xx][yy]==c) bb |= (1<<(xx*4+yy));\n\t\t\t\t\telse bb ^= (bb&1<<(xx*4+yy));\n\t\t\t\t}\n\t\t\t\tif (d[bb]>d[b]+1) d[bb] = d[b]+1, q.push(bb);\n\t\t\t}\n\t\t\tswap(h[i],w[i]);\n\t\t}\n\t}\n\tcout << d[(1<<16)-1] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N;\n  cin>>N;\n  int H[16],W[16];\n  for(int i=0;i<N;i++){\n    cin>>H[i]>>W[i];\n  }\n  int g[4][4];\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      char c;\n      cin>>c;\n      g[i][j]=\n\t(c=='R')?1:\n\t(c=='G')?2:3;\n    }\n  }\n  int dp[1<<16];\n  fill(begin(dp),end(dp),99);\n  dp[0]=0;\n  for(int i=0;i<1<<16;i++){\n    int cg[10][10]={};\n    for(int j=0;j<4;j++){\n      for(int k=0;k<4;k++){\n\tif(!(i>>j*4+k&1)){\n\t  cg[j+3][k+3]=g[j][k];\n\t}\n      }\n    }\n    for(int j=0;j<N;j++){\n      for(int k=0;k<7;k++){\n\tfor(int l=0;l<7;l++){\n\t  bool c[4]={};\n\t  int nb=i;\n\t  for(int m=0;m<H[j];m++){\n\t    for(int n=0;n<W[j];n++){\n\t      int y=k+m;\n\t      int x=l+n;\n\t      c[cg[y][x]]=true;\n\t      if(3<=y&&y<=6&&3<=x&&x<=6){\n\t\tnb|=1<<(y-3)*4+x-3;\n\t      }\n\t    }\n\t  }\n\t  if(c[1]+c[2]+c[3]==1){\n\t    dp[nb]=min(dp[nb],dp[i]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst string str = \"RGB\";\n\nint n, a, b; vector<int> x, y; vector<string> M;\n\nmap<vector<string>, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tM.resize(4);\n\n\tfor (int i = 0; i < 4; i++) cin >> M[i];\n\n\tqueue<pair<vector<string>, int> > que;\n\n\tque.push(make_pair(vector<string>({ \"WWWW\", \"WWWW\", \"WWWW\", \"WWWW\" }), 0)); D[M] = 0;\n\n\twhile (true)\n\t{\n\t\tvector<string> M1 = que.front().first; int dist = que.front().second;\n\n\t\tif (M == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < 3; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<string> M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tM2[l][m] = str[c];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2297&lang=jp\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint N;\nvector<vector<int>> st;\nvector<pii> rec;\n\nvoid stamp_stete_check() {\n\tfor (int n = 0; n < N;n++) {\n\t\tcout << \"[\" << rec[n].first << \",\" << rec[n].second << \"]\" << endl;\n\t\tfor (int i = 0; i < st[n].size();i++) {\n\t\t\tfor (int j = 0; j < 16;j++) {\n\t\t\t\tif (j % 4 == 0) cout << endl;\n\t\t\t\tif (st[n][i] & (1 << j)) {\n\t\t\t\t\tcout << \"o\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"x\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tcin >> N;\n\trec.resize(N);\n\tst.resize(N);\n\tfor (int n = 0; n < N;n++) {\n\t\tint H, W; cin >> H >> W;\n\t\trec[n] = { H,W };\n\t\tfor (int i = -3; i < 4;i++) {\n\t\t\tfor (int j = -3; j < 4;j++) {\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int h = max(0,i); h < min(4, i + H);h++) {\n\t\t\t\t\tfor (int w = max(0,j); w < min(4, j + W);w++) {\n\t\t\t\t\t\ts += (1 << (4 * h + w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s == 0)continue;\n\t\t\t\tst[n].push_back(s);\n\t\t\t}\n\t\t}\n\t}\n\n\t// stamp_stete_check();\n\n\t/* Classification */\n\tvector<int> m(16);\n\tfor (int i = 0; i < 16;i++) {\n\t\tchar c; cin >> c;\n\t\tif (c == 'R') m[i] = 0;\n\t\telse if (c == 'G') m[i] = 1;\n\t\telse m[i] = 2;\n\t}\n\n\t/* initialize */\n\tvector<int> memo(1 << 16, -1);\n\tqueue<int> q;\n\tq.push(0);\n\tmemo[0] = 0;\n\n\t/* bfs */\n\twhile (!q.empty()) {\n\t\tint n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 16;i++) {\n\t\t\tif (n & (1 << i))continue;\n\t\t\tint v = m[i];\n\t\t\tfor (int j = 0; j < N;j++) {\n\t\t\t\tfor (int k = 0; k < st[j].size(); k++) {\n\t\t\t\t\tif (~st[j][k] & (1 << i)) continue;\t\n\t\t\t\t\tint next = n;\n\t\t\t\t\tfor (int l = 0; l < 16;l++) {\n\t\t\t\t\t\tif (~st[j][k] & (1 << l)) continue;\n\t\t\t\t\t\tif (next & (1 << l)) {\n\t\t\t\t\t\t\tif (v == m[l]) continue;\n\t\t\t\t\t\t\tnext -= (1 << l);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (v != m[l]) continue;\n\t\t\t\t\t\t\tnext += (1 << l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (memo[next] != -1)continue;\n\t\t\t\t\tmemo[next] = memo[n] + 1;\n\t\t\t\t\tif (next == ((1 << 16) - 1)) {\n\t\t\t\t\t\tcout << memo[next] << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint t;\nbool ok[32][32];\nstring f[4];\nint dp[(1<<16)];\nint dfs(int mask){\n\tif(dp[mask] < 1e8) return dp[mask];\n\tif(mask == (1<<16)-1) return 0;\n\tfor(int i=-3;i<4;i++){\n\t\tfor(int ii=i;ii<7;ii++){\n\t\t\tfor(int j=-3;j<4;j++){\n\t\t\t\tfor(int jj=j;jj<7;jj++){\n\t\t\t\t\tif(!ok[ii-i+1][jj-j+1]) continue;\n\t\t\t\t\tint check = 0;\n\t\t\t\t\tint go = 0;\n\t\t\t\t\tfor(int a=i;a<=ii;a++) for(int b=j;b<=jj;b++){\n\t\t\t\t\t    if(0<=a&&a<4&&0<=b&&b<4);else continue;\n\t\t\t\t\t\tint c = a*4+b;\n\t\t\t\t\t\tif(((mask>>c) & 1) == 0){\n\t\t\t\t\t\t\tif(f[a][b] == 'R') check|=1,go+=(1<<c);\n\t\t\t\t\t\t\tif(f[a][b] == 'G') check|=2,go+=(1<<c);\n\t\t\t\t\t\t\tif(f[a][b] == 'B') check|=4,go+=(1<<c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(__builtin_popcount(check) == 1) dp[mask] = min(dp[mask],dfs(mask+go)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[mask];\n}\nint main(){\n\tcin>>t;\n\trep(i,t){\n\t\tint a,b; cin>>a>>b;\n\t\tok[a][b] = 1;\n\t}\n\trep(i,4) cin>>f[i];\n\tfill(dp,dp+(1<<16),INF);\n\tcout << dfs(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint p[20];\nint q[20];\nchar str[5][5];\nint bfs[1<<16];\nchar col[5]=\"RGB\";\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t}\n\tfor(int i=0;i<4;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<(1<<16);i++)bfs[i]=-1;\n\tbfs[0]=0;\n\tqueue<int>Q;\n\tQ.push(0);\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=-p[i]+1;j<4;j++){\n\t\t\t\tfor(int k=-q[i]+1;k<4;k++){\n\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\tint to=at;\n\t\t\t\t\t\tfor(int l=0;l<p[i];l++)for(int m=0;m<q[i];m++){\n\t\t\t\t\t\t\tif(j+l<0||k+m<0||j+l>3||k+m>3)continue;\n\t\t\t\t\t\t\tif(str[j+l][k+m]==col[c])to|=(1<<((j+l)*4+k+m));\n\t\t\t\t\t\t\telse to&=(~(1<<((j+l)*4+k+m)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!~bfs[to]){\n\t\t\t\t\t\t\tbfs[to]=bfs[at]+1;\n\t\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs[(1<<16)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<deque>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_LEN 16\n#define MAX_STATE (1<<16)\n\nusing namespace std;\ntypedef pair<int,int> ii;\n\nconst int DIFF = 3;\nint N,H[MAX_LEN],W[MAX_LEN];\nint bitmask[MAX_LEN][12][12][3][2]; // bitmask[type][y][x][color][bool] bool = false -> erase , true -> insert\nbool mincost[MAX_STATE];\nchar G[4][4];\nchar color[] = {'R','G','B'};\n\ninline void makeBitMask(){\n  REP(y,-3,8)REP(x,-3,8)rep(stamp,N)rep(c,3)rep(cy,H[stamp])rep(cx,W[stamp]){\n    int nx = x + cx;\n    int ny = y + cy;\n    if( !( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 ) )continue;\n    if( G[ny][nx] == color[c] )bitmask[stamp][y+DIFF][x+DIFF][c][true]  |= (1<<(nx+(ny*4)));\n    else                       bitmask[stamp][y+DIFF][x+DIFF][c][false] |= (1<<(nx+(ny*4)));\n  }\n}\n\ninline void compute(){\n  for(bool& i : mincost)i = false;\n  mincost[0] = true;\n  deque<ii> deq;\n  deq.push_back(ii(0,0));\n  while(!deq.empty()){\n    ii data = deq.front(); deq.pop_front();\n\n    if( data.first == (MAX_STATE-1) ){\n      cout << data.second << endl;\n      break;\n    }\n\n    rep(stamp,N)rep(col,3)REP(y,-3,8)REP(x,-3,8){\n      int state = ( data.first | bitmask[stamp][y+DIFF][x+DIFF][col][true] ) & (~bitmask[stamp][y+DIFF][x+DIFF][col][false]);\n      if(mincost[state])continue;\n      mincost[state] = true;\n      deq.push_back(ii(state,data.second+1));\n    }\n  }\n}\n\nint main(){\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(y,4)rep(x,4)cin >> G[y][x];\n  makeBitMask();\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  int a[4][4];\n  r(i,4)r(j,4)a[i][j]=(i*4+j);\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());int rs=0;\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    int xp=0;\n    r(i,4)r(j,4)if(t[i][j]==s[i][j])xp|=(1<<a[i][j]);\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        r(kk,4)tmp[kk]=t[kk];\n        int tp=xp;\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            tmp[i][j]=ccol[col];\n            if(tmp[i][j]==s[i][j])tp|=(1<<a[i][j]);\n            else if((tp>>a[i][j])&1)tp^=(1<<a[i][j]);\n          }\n        }\n        if(!dp[tp]){rs++;\n          dp[tp]=1;\n          q.push(P(tp,p.second+1));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint calc(int a,int b){\n\tint tmp = 1;\n\tfor(int ccc=0;ccc<4*a;ccc++){\n\t\ttmp*=2;\n\t}\n\tfor(int j=0;j<b;j++){\n\t\ttmp*=2;\n\t}\n\treturn tmp;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<pair<int,int> > p;\n\tfor(int i=0;i<n;i++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tp.PB(MP(h,w));\n\t}\n\tset<vector<pair<int,int> > >sp;\n\tfor(int qq=0;qq<n;qq++){\n\t\tfor(int i=-3;i<=3;i++){\n\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\tvector<pair<int,int> > z;\n\t\t\t\tfor(int x = 0;x<p[qq].first;x++){\n\t\t\t\t\tfor(int y=0;y<p[qq].second;y++){\n\t\t\t\t\t\tif(i+x>=0&&i+x<=3&&j+y>=0&&j+y<=3){\n\t\t\t\t\t\t\tz.PB(MP(i+x,j+y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(z.size()!=0)sp.insert(z);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << sp.size() << endl;\n\tstring s[4];\n\tfor(int i=0;i<4;i++){\n\t\tcin >> s[i];\n\t}\n\tint a[4][4];\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(s[i][j]=='R'){\n\t\t\t\ta[i][j] = 1;\n\t\t\t}else if(s[i][j]=='G'){\n\t\t\t\ta[i][j] = 2;\n\t\t\t}else{\n\t\t\t\ta[i][j] = 3;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tqueue<pair<int,int > >q;\n\tbool used[100010];\n\tused[0] = 1;\n\tq.push(MP(0,0));\n\tset<int> st;\n\tbool breakflag=0;\n\twhile(!q.empty()){\n\t\tauto x = q.front();\n\t\tq.pop();\n\t\tint f = x.first;\n\t\tint g = x.second;\n\t\tif(f==65535){\n\t\t\tans = g;\n\t\t\tbreak;\n\t\t}\n\t\t\tfor(auto w:sp){\n\t\t\t\tfor(int c=1;c<4;c++){\n\t\t\t\t\tint s = f;\n\t\t\t\t\tfor(int i=0;i<w.size();i++){\n\t\t\t\t\t\tif(a[w[i].first][w[i].second]==c){\n\t\t\t\t\t\t\ts |= calc(w[i].first,w[i].second);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif((s&calc(w[i].first,w[i].second))==calc(w[i].first,w[i].second)){\n\t\t\t\t\t\t\t\ts -= calc(w[i].first,w[i].second);\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s==65535){\n\t\t\t\t\t\tans = g+1;\n\t\t\t\t\t\tbreakflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(used[s]!=1){\n\t\t\t\t\t\t//cout << static_cast<bitset<16> > (f) << \" \" << static_cast<bitset<16> > (s) << endl;\n\t\t\t\t\t\tused[s]=1;\n\t\t\t\t\t\tq.push(MP(s,g+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(breakflag)break;\t\n\t\t\t}\n\t\t\tif(breakflag)break;\n\t\t\n\t\tif(breakflag)break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  const string cols = \"RGB\";\n\n  int N; cin >> N;\n  vector<pair<int, int>> vs(N);\n  rep(i, N) {\n    cin >> vs[i].first >> vs[i].second;\n  }\n\n  vector<string> G(4);\n  rep(i, 4) cin >> G[i];\n\n  static int dist[1<<16];\n  minus(dist);\n  dist[0] = 0;\n\n  queue<int> q;\n  q.push(0);\n\n  while(!q.empty()) {\n    if(~dist[(1<<16)-1]) break;\n\n    int curr = q.front(); q.pop();\n\n    for(auto hw: vs) {\n      int h = hw.first, w = hw.second;\n\n      for(auto col: cols)\n      REP(i, -h + 1, 4) REP(j, -w + 1, 4) {\n        int next = curr;\n        REP(y, i, min(i + h, 4)) REP(x, j, min(j + w, 4)) {\n          if(G[y][x] == col) next |= 1<<(y * 4 + x);\n          else next &= ~(1<<(y * 4 + x));\n        }\n        if(dist[next] < 0) {\n          dist[next] = dist[curr] + 1;\n          q.push(next);\n        }\n      }\n    }\n  }\n\n  cout << dist[(1<<16)-1] << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n    \n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n  vector<pair<int, int>> vs(N);\n  rep(i, N) {\n    cin >> vs[i].first >> vs[i].second;\n  }\n\n  vector<string> G(4);\n  rep(i, 4) cin >> G[i];\n\n  unordered_map<bitset<16>, int> dist;\n  queue<bitset<16>> q;\n\n  auto bs = bitset<16>();\n  q.emplace(bs);\n  dist[bs] = 0;\n\n  while(!q.empty()) {\n    const auto p = q.front(); q.pop();\n    const int cost = dist[p];\n\n    if(p.all()) {\n      cout << cost << endl;\n      break;\n    }\n\n    for(auto e: vs) {\n      int h = e.first, w = e.second;\n      rep(sy, 4) rep(sx, 4) {\n        auto np = p;\n        REP(i, sy, min(sy + h, 4)) REP(j, sx, min(sx + w, 4)) {\n          if(G[sy][sx] == G[i][j]) {\n            np.set(i * 4 + j);\n          }\n        }\n\n        if(dist.find(np) != dist.end())\n          continue;\n\n        dist[np] = cost + 1;\n        q.push(np);\n      }\n    }\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\t  REP(y,-10,10){\n\t    REP(x,-10,10){\n\t      rep(stp,N){\n\t  \n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      if(c == 'X')continue;\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\n\nconst int V = 1 << 16;\nvector<int> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tif(dist[G[u][i]] < inf) continue;\n\t\t\tdist[G[u][i]] = dist[u] + 1;\n\t\t\tQ.push(G[u][i]);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\t\n\t\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int dx = max(x, 0); dx < min(x+W[j], 4); dx++){\n\t\t\t\t\t\t\tfor(int dy = max(y, 0); dy < min(y+H[j], 4); dy++){\n\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tG[i].push_back(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n\n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int y=0;y<M;y++){\n      \n      for(int x=0;x<M;x++){\n\t\n\tint idx=y*M+x;\n\t\n\tif(S&(1<<idx)) continue;\n\t\n\tfor(int k=0;k<n;k++) mark(cost,S,idx,k);\n\t\n      }\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> h(n),w(n);\n\tfor(int i=0; i<n; i++) cin >> h[i] >> w[i];\n\tvector<vector<char> > c(4, vector<char>(4));\n\tfor(int i=0; i<4; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\t\n\tvector<int> dp(1<<16, inf);\n\tdp[0] = 0;\n\tfor(int i=0; i<(1<<16); i++){\n\t\tif(dp[i] == inf) continue;\n\t\tfor(int s=0; s<n; s++){\n\t\t\tfor(int y=1-h[s]; y<=2+h[s]; y++){\n\t\t\t\tfor(int x=1-w[s]; x<=2+w[s]; x++){\n\t\t\t\t\tchar color = 0;\n\t\t\t\t\tint newidx = i;\n\t\t\t\t\tfor(int j=0; j<h[s]; j++){\n\t\t\t\t\t\tfor(int k=0; k<w[s]; k++){\n\t\t\t\t\t\t\tint ny=y+j, nx=x+k;\n\t\t\t\t\t\t\tif(ny<0 || 4<=ny || nx<0 || 4<=nx) continue;\n\t\t\t\t\t\t\tif((i & 1<<(4*ny +nx)) != 0) continue;\n\t\t\t\t\t\t\tif(color!=0 && color!=c[ny][nx]){\n\t\t\t\t\t\t\t\tcolor = 0;\n\t\t\t\t\t\t\t\tj = h[s];\n\t\t\t\t\t\t\t\tbreak;//j,k\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolor = c[ny][nx];\n\t\t\t\t\t\t\tnewidx |= 1<<(4*ny +nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(color != 0){\n\t\t\t\t\t\tdp[newidx] = min(dp[newidx], dp[i]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16) -1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = numeric_limits<int>::max()/2;\n\nint n;\nvector<P> stmp;\nvector<vector<int>> col(4,vector<int>(4));\n\nint solve(){\n    vector<int> dis(1<<16,INF);\n    queue<int> q;\n    dis[0]=0;\n    q.push(0);\n    while(!q.empty()){\n        int prev=q.front();q.pop();\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=2;j++){\n                // stamp[i] with color_j\n                int h=stmp[i].first,w=stmp[i].second;\n                for(int sx=1-h;sx<4;sx++){\n                    for(int sy=1-w;sy<4;sy++){\n\n                        int next=prev;\n                        for(int ni=0;ni<h;ni++){\n                            for(int nj=0;nj<w;nj++){\n                                int nx=sx+ni,ny=sy+nj;\n                                if(nx<0 || 4<=nx || ny<0 || 4<=ny) continue;\n                                int num=15-4*nx-ny;\n                                if(col[nx][ny]==j) next |= (1<< num);\n                                else next &= ~(1<<num); \n                            }\n                        }\n\n                        if(dis[next]!=INF) continue;\n                        dis[next]=dis[prev]+1;\n                        if(next==((1<<16)-1)) return dis[next];\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int h,w;cin>>h>>w;\n        stmp.push_back(P(h,w));\n    }\n    for(int i=0;i<4;i++){\n        string s;cin>>s;\n        for(int j=0;j<4;j++){\n            if(s[j]=='R') col[i][j]=0;\n            else if(s[j]=='G') col[i][j]=1;\n            else col[i][j] = 2;\n        }\n    }\n    cout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N;\nint C[4][4];\nvector<pi>Stamp;\nint dist[1<<16];\n\nint f(int h, int w, int sx, int sy, int c, int S){\n  //  cout << h << \" \" << w << \" \" << sx << \" \" << sy << \" \" << c << \" \" << S << endl;\n  for(int i=max(sx, 0);i<min(sx+h, 4);i++){\n    for(int j=max(sy, 0);j<min(sy+w, 4);j++){\n      int pos = i*4+j;\n      if(C[i][j] == c){\n\tS |= 1<<pos;\n      }else{\n\tS &= ((1<<16)-1) - (1<<pos);\n      }\n    }\n  }\n  //  cout << h << \" \" << w << \" \" << sx << \" \" << sy << \" \" << c << \" \" << S << endl;  \n  return S;\n}\n\nint main()\n{\n  cin >> N;\n  Stamp.resize(N);\n  for(auto &stamp: Stamp) cin >> stamp.first >> stamp.second;\n  rep(i, 4){\n    string s;\n    cin >> s;\n    rep(j, 4){\n      if(s[j] == 'R')\n\tC[i][j] = 0;\n      if(s[j] == 'G')\n\tC[i][j] = 1;\n      if(s[j] == 'B')\n\tC[i][j] = 2;\n    }\n  }\n  fill(dist, dist+(1<<16), INF);\n  queue<pi>Q;\n  Q.push(pi(0, 0));\n  dist[0] = 0;\n  while(!Q.empty()){\n    pi p = Q.front(); Q.pop();\n    int state = p.second;\n    int cost = p.first;\n    //    cout << static_cast<bitset<16> >(state) << \" \" << cost << endl;\n    if(state == (1<<16) - 1){\n      cout << cost << endl;\n      break;\n    }    \n    if(dist[state] < cost) continue;\n    for(auto &stamp: Stamp){\n      int H = stamp.first, W = stamp.second;\n      for(int sx = -H+1; sx < 4; sx++){\n\tfor(int sy = -W+1; sy < 4; sy++){\n\t  for(int color=0;color<3;color++){\n\t    int next_state = f(H, W, sx, sy, color, state);\n\t    if(cost + 1 < dist[next_state]){\n\t      dist[next_state] = cost + 1;\n\t      Q.push(pi(dist[next_state], next_state));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <queue>\n#define INF 100\nusing namespace std;\n\nint n;\nint h[17],w[17];\nint dp[1<<16];\nint fie[4][4];\n\nint bfs(int s){\n\tqueue<int> que;\n\tfor(int i=0;i<1<<16;i++){\n\t\tdp[i]=INF;\n\t}\n\tque.push(s);\n\tdp[s]=0;\n\twhile(que.size()){\n\t\tint bit=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=-3;j<4;j++){\n\t\t\t\tfor(int k=-3;k<4;k++){\n\t\t\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\t\t\tint nbit=bit;\n\t\t\t\t\t\tfor(int x=max(j,0);x<min(4,j+w[i]);x++){\n\t\t\t\t\t\t\tfor(int y=max(k,0);y<min(4,k+h[i]);y++){\n\t\t\t\t\t\t\t\tint nshift=y*4+x;\n\t\t\t\t\t\t\t\tif((nbit>>nshift & 1) && fie[x][y]!=l)nbit-=(1<<nshift);\n\t\t\t\t\t\t\t\tif(!(nbit>>nshift & 1) && fie[x][y]==l)nbit+=(1<<nshift);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[nbit]==INF){\n\t\t\t\t\t\t\tdp[nbit]=dp[bit]+1;\n\t\t\t\t\t\t\tque.push(nbit);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[(1<<16)-1];\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&h[i],&w[i]);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(str[j]=='R')fie[j][i]=0;\n\t\t\tif(str[j]=='G')fie[j][i]=1;\n\t\t\tif(str[j]=='B')fie[j][i]=2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs(0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,ll> P2;\n\nint n,h[16],w[16],ty,tx;\nstring s[4];\nmap<ll,bool> memo;\nll ans,tmp;\nvector<ll> st;\n\ninline int color(ll a,ll b){\n  bool v[3];\n  for(int k=0;k<3;k++)v[k] = false;\n  for(int k=0;k<16;k++){\n    if( ((a>>(2*k))&3LL) && ((b>>(2*k))&3LL)){\n      v[((b>>(2*k))&3LL)-1] = true;\n    }\n  }\n  int cnt = 0;\n  for(int k=0;k<3;k++)if(v[k])cnt++;\n  return cnt;\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++)cin >> h[i] >> w[i];\n  for(int i=0;i<4;i++)cin >> s[i];\n\n  ans = 0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(s[i][j] == 'R')ans += 1LL<<(2*(i*4+j));\n      if(s[i][j] == 'G')ans += 2LL<<(2*(i*4+j));\n      if(s[i][j] == 'B')ans += 3LL<<(2*(i*4+j));\n    }\n\n  for(int i=0;i<n;i++){\n    for(int j=-h[i]+1;j<4;j++){\n      for(int k=-w[i]+1;k<4;k++){\n\ttmp = 0;\n\tfor(int y=0;y<h[i];y++){\n\t  for(int x=0;x<w[i];x++){\n\t    ty = y+j; tx = x+k;\n\t    if(ty<0 || tx<0 || 4<=ty || 4<=tx)continue;\n\t    tmp |= 1LL<<(2*(ty*4+tx));\n\t  }\n\t}\n\tst.push_back(tmp);\n      }\n    }\n  }\n  sort(st.begin(),st.end());\n  st.erase(unique(st.begin(),st.end()),st.end());\n\n  memo.clear();memo[0] = true;\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  q.push(P2(P(3,0),ans));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    \n    for(int i=0;i<st.size();i++){\n      tmp = p.sc;\n      if(color(st[i],tmp) == 1){\n\ttmp &= -1LL^(3LL*st[i]);\n\tif(tmp==0){\n\t  cout << p.fs.sc + 1 << endl;\n\t  return 0;\n\t}\n\tif(memo.find(tmp)==memo.end()){\n\t  memo[tmp] = true;\t  \n\t  q.push(P2(P(p.fs.sc+color((1LL<<32)-1,tmp)+1,p.fs.sc+1),tmp));\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/02 20:16:19\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<int, int>;\n    vector<P> s(N);\n    for (int i = 0, H, W; i < N; i++) { cin >> H >> W, s[i] = {H, W}; }\n    vector<vector<int>> f(4, vector<int>(4, 0));\n    map<char, int> mp;\n    mp['R'] = 1, mp['G'] = 2, mp['B'] = 3;\n    for (int i = 0; i < 4; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 4; j++) { f[i][j] = mp[s[j]]; }\n    }\n    vector<int> memo(1 << 16, -1);\n    auto dfs = [&](auto&& self, const int hash) -> int {\n        if (hash == 0) { return 0; }\n        if (memo[hash] != -1) { return memo[hash]; }\n        int ans = 16;\n        for (int i = 0; i < N; i++) {\n            const int H = s[i].first, W = s[i].second;\n            for (int h = 1 - H; h < 4; h++) {\n                for (int w = 1 - W; w < 4; w++) {\n                    const int hinf = max(h, 0), winf = max(w, 0);\n                    const int hsup = min(h + H, 4), wsup = min(w + W, 4);\n                    set<int> ch;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            if (hash & (1 << (4 * i + j))) { ch.insert(f[i][j]); }\n                        }\n                    }\n                    if (ch.size() != 1) { continue; }\n                    int h = hash;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) { h &= ~(1 << (4 * i + j)); }\n                    }\n                    const int sub = self(self, h) + 1;\n                    ans = min(ans, sub);\n                }\n            }\n        }\n        return memo[hash] = ans;\n    };\n    const int ans = dfs(dfs, (1 << 16) - 1);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\nusing namespace std;\nint dp[1 << 16], n; vector<pair<int, int>>x;\nint col[4][4]; queue<int>Q;\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++)dp[i] = 999999999; dp[0] = 0;\n\tcin >> n; for (int i = 0; i < n; i++) { int a, b; cin >> a >> b; x.push_back(make_pair(a, b)); }\n\tQ.push(0); for (int i = 0; i < 4; i++) { string V; cin >> V; for (int j = 0; j < 4; j++) { if (V[j] == 'R')col[i][j] = 1; if (V[j] == 'B')col[i][j] = 2; if (V[j] == 'G')col[i][j] = 3; } }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop(); int F[4][4];\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tif ((a1 / (1 << i)) % 2 == 1)F[i / 4][i % 4] = col[i / 4][i % 4];\n\t\t\telse F[i / 4][i % 4] = 0;\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = 1 - (int)x[i].first; j <= 3; j++) {\n\t\t\t\tfor (int k = 1 - (int)x[i].second; k <= 3; k++) {\n\t\t\t\t\tfor (int o = 1; o < 4; o++) {\n\t\t\t\t\t\tint G = a1;\n\t\t\t\t\t\tfor (int l = max(-j, 0); l < min(4 - j, x[i].first); l++) {\n\t\t\t\t\t\t\tfor (int m = max(-k, 0); m < min(4 - k, x[i].second); m++) {\n\t\t\t\t\t\t\t\tint cx = j + l, cy = k + m, cl = cx * 4 + cy;\n\t\t\t\t\t\t\t\tif (F[cx][cy] >= 1 && col[cx][cy] != o) { G -= (1 << cl); }\n\t\t\t\t\t\t\t\telse if (F[cx][cy] == 0 && col[cx][cy] == o) { G += (1 << cl); }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint bits = G;\n\t\t\t\t\t\tif (dp[bits] > dp[a1] + 1) { dp[bits] = dp[a1] + 1; Q.push(bits); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[65535] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[17][1<<16];\nint main(){\n  int n,h[16],w[16];\n  char r[3]={'R','G','B'};\n  string c[4];\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>h[i]>>w[i];\n  for(int i=0;i<4;i++)cin>>c[i];\n\n  int a1[16][7][7],o1[16][3][7][7]={};\n  for(int i=0;i<n;i++)\n    for(int j=0;j<7;j++)for(int k=0;k<7;k++)a1[i][j][k]=(1<<16)-1;\n  \n  for(int k=0;k<n;k++)\n    for(int cl=0;cl<3;cl++)\n      for(int y=-h[k]+1;y<4;y++)\n\tfor(int x=-w[k]+1;x<4;x++){\n\t  for(int l=max(0,y);l<min(4,y+h[k]);l++)\n\t    for(int m=max(0,x);m<min(4,x+w[k]);m++){\n\t      int xx=l*4+m;\n\t      if(c[l][m]==r[cl])o1[k][cl][y+3][x+3]|=1<<xx;\n\t      if(!cl)a1[k][y+3][x+3]-=1<<xx;\n\t    }\n\t}\n  \n  dp[0][0]=1;\n  for(int j=0;j<16;j++)\n    for(int i=0;i<1<<16;i++)\n      if(dp[j][i])\n\tfor(int k=0;k<n;k++)\n\t  for(int cl=0;cl<3;cl++)\n\t    for(int y=-h[k]+1;y<4;y++)\n\t      for(int x=-w[k]+1;x<4;x++){\n\t\tint ni=(i&a1[k][y+3][x+3])|o1[k][cl][y+3][x+3];\n\t\tdp[j+1][ni]=1;\n\t\tif(ni==(1<<16)-1){cout<<j+1<<endl;return 0;}\n\t      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    bool flag[4][4][5][5][3];\n    fill_n((bool*)flag,4*4*5*5*3,false);\n    rep(y1,0,4) rep(x1,0,4) rep(y2,y1+1,5) rep(x2,x1+1,5) rep(y,y1,y2) rep(x,x1,x2) flag[y1][x1][y2][x2][c[y][x]]=true;\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    vector<int> cost(1<<16,inf);\n    queue<bitset<16>> que;\n    cost[0]=0;\n    que.push(bitset<16>(0));\n    while(!que.empty()){\n        auto bs=que.front();\n        que.pop();\n        int state=encode(bs);\n        if(bs.all()){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-h[i]+1,4) rep(x,-w[i]+1,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            rep(j,0,3){\n                if(!flag[y1][x1][y2][x2][j]) continue;\n                auto next_bs=bs;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j) next_bs.set(4*y_+x_);\n                    else next_bs.reset(4*y_+x_);\n                }\n                int next_state=encode(next_bs);\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(next_bs);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\n#define M 4\nusing namespace std;\n\nint n,h[N],w[N];\nstring s[M];\n\nbool dp[N+1][(1<<N)];\n\nvoid mark(int cnt,int S,int idx,int stamp){\n  \n  int y=idx/M,x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S,f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(S&(1<<p)) f=1;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<nS)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(!f) dp[cnt+1][nS]=true;\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  dp[0][0]=true;\n\n  int ans=N;\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<(1<<N);j++){\n      \n      if(!dp[i][j]) continue;\n      \n      if(j==(1<<N)-1){\n\tans=i;\n\tbreak;\n      }\n      \n      for(int y=0;y<M;y++){\n\tfor(int x=0;x<M;x++){\n\t  \n\t  int idx=y*M+x;\n\t  \n\t  if(j&(1<<idx)) continue;\n\t  \n\t  for(int k=0;k<n;k++) mark(i,j,idx,k);\n\t  \n\t}\n      }\n      \n      \n    }\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  memset(dp,-1,sizeof(dp));\n  int a[4][4];\n  r(i,4)r(j,4)a[i][j]=(i*4+j);\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=0;\n  queue<int>q;\n  q.push(0);\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());int rs=0;\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    int xx=p;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<dp[p]<<endl;\n      return 0;\n    }\n    int xp=0;\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)xp|=(1<<a[i][j]);\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        int tp=xp;\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            if(ccol[col]==s[i][j])tp|=(1<<a[i][j]);\n            else if((tp>>a[i][j])&1)tp^=(1<<a[i][j]);\n          }\n        }\n        if(dp[tp]==-1){rs++;\n          dp[tp]=dp[xx]+1;\n          q.push(tp);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint n;\nint h[20],w[20];\nconst int H=4,W=4;\nint ans=16;\n\nset<string> used;\n\nint dfs(string s){\n    vector<int> dist(1<<16,inf);\n    dist[0]=0;\n    queue<int> que;\n    que.push(0);\n    while(que.size()){\n        int cur=que.front();que.pop();\n        rep(i,n){\n            REP(j,-h[i]+1,H)REP(k,-w[i]+1,W){;\n                int nxt=cur;\n                int mask=0;\n                rep(l,h[i])rep(m,w[i]){\n                    if(0<=j+l&&j+l<H&&0<=k+m&&k+m<W&&!(cur&(1<<((j+l)*H+k+m)))){\n                        nxt+=(1<<((j+l)*H+k+m));\n                        mask|=(s[(j+l)*H+k+m]=='R')*4;\n                        mask|=(s[(j+l)*H+k+m]=='G')*2;\n                        mask|=(s[(j+l)*H+k+m]=='B')*1;\n                    }\n                }\n                if(mask!=1&&mask!=2&&mask!=4)continue;\n                if(dist[nxt]==inf){\n                    dist[nxt]=dist[cur]+1;\n                    que.push(nxt);\n                }\n            }\n        }\n    }\n    return dist[65535];\n}\n\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>h[i]>>w[i];\n    }\n    string s;\n    rep(i,4){\n        string t;\n        cin>>t;\n        s+=t;\n    }\n    cout<<dfs(s)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,H[17],W[17];\nint c[5][5];\nint dist[1<<16];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N)cin>>H[i]>>W[i];\n\trep(i,4)rep(j,4){\n\t\tchar C;\n\t\tcin>>C;\n\t\tc[i][j] = C=='R' ? 0 : C=='G' ? 1 : 2;\n\t}\n\trep(i,1<<16)dist[i] = INF;\n\tdist[0] = 0;\n\tqueue<int> Q;\n\tQ.push(0);\n\twhile(sz(Q)){\n\t\tint mask = Q.front(); Q.pop();\n\t\tif(mask == (1<<16)-1){\n\t\t\treturn cout<<dist[mask]<<endl,0;\n\t\t}\n\t\tint done[4][4][4][4][3] = {};\n\t\trep(i,N){\n\t\t\trep2(y,-H[i]+1,4)rep2(x,-W[i]+1,4)rep(color,3){\n\t\t\t\tint nmask = mask;\n\t\t\t\tint y0 = max(0, y);\n\t\t\t\tint x0 = max(0, x);\n\t\t\t\tint y1 = min(3, y+H[i]-1);\n\t\t\t\tint x1 = min(3, x+W[i]-1);\n\t\t\t\tif(done[y0][x0][y1][x1][color])continue;\n\t\t\t\tdone[y0][x0][y1][x1][color] = 1;\n\t\t\t\trep(ii,H[i])rep(jj,W[i]){\n\t\t\t\t\tint Y = y+ii, X = x+jj;\n\t\t\t\t\tif(Y<0 || Y>=4 || X<0 || X>=4)continue;\n\t\t\t\t\tif(c[Y][X] == color) nmask |= 1<<Y*4+X;\n\t\t\t\t\telse nmask &= ~(1<<Y*4+X);\n\t\t\t\t}\n\t\t\t\tif(dist[nmask] > dist[mask] + 1){\n\t\t\t\t\tdist[nmask] = dist[mask] + 1;\n\t\t\t\t\tQ.push(nmask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                           //    #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint n;\nstring s[4];\nint h[20],w[20];\nint dp[1<<16];\n\nqueue<pa> pq;   \nvector<pa> ve;\n   signed main(){\ncin>>n;\n   \tfor(int i=0;i<n;i++)cin>>h[i]>>w[i];\n   \tfor(int i=0;i<(1<<16);i++)dp[i]=-1;\n   \tfor(int i=0;i<4;i++)cin>>s[i];\n   \tstring ss=\"RBG\";\n   \t\n   \t   \tfor(int k=0;k<n;k++){\n   \t\t\tfor(auto c:ss)for(int i=1-h[k];i<4;i++)for(int j=1-w[k];j<4;j++){\n   \t\t\t\tint bit1=0,bit2=0;\n   \t\t\t\tfor(int x=max(i,0);x<min(i+h[k],4);x++)for(int y=max(j,0);y<min(j+w[k],4);y++){\n   \t\t\t\t\tbit1 += (1<<((y)*4+x));\n   \t\t\t\t\tif(s[x][y]==c) bit2+=(1<<((y)*4+x));\n   \t\t\t\t\n   \t\t\t\t}\n   \t\t\t\tve.pb(mp(bit1,bit2));\n   \t\t\t}\n   \t\t}\n   \t\n   \t\n   \tpq.push(mp(0,0));\n   \twhile(pq.size()>0){\n   \t\tpa z=pq.front();\n   \t\tpq.pop();\n   \t\tif(dp[z.second]>=0) continue;\n   \t\tdp[z.second]=z.first;\n   \t\tif(z.second+1==(1<<16)){\n   \t\tcout<<z.first<<endl;\n   \t\t\treturn 0;\n   \t\t}\n   \t//\t\tcout<<bitset<16>(z.second)<<\" \"<<z.first <<endl;\n   \t\tfor (auto v:ve){\n   \t\t\tint bit=(1<<16)-1;\n   \t\t\tbit ^= v.first;\n   \t\t\tbit= bit&z.second;\n   \t\t\t\n   \t\t\tbit=bit+v.second;\n   \t\t\tif(dp[bit]<0) pq.push(mp(z.first+1,bit));\n   \t\t}\n   \t}\n   \t\n   \t\n   \tcout<<dp[(1<<16)-1]<<endl;\n   \t\n   \t\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, h[16], w[16], col[3];\nchar in[4][5];\nbool v[1 << 16];\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> h[i] >> w[i];\n\trep(i, 4){\n\t\tcin >> in[i];\n\t\trep(j, 4) rep(k, 3){\n\t\t\tif(in[i][j] == \"RGB\"[k]) col[k] |= 1 << i * 4 + j;\n\t\t}\n\t}\n\t\n\tvi stamp;\n\trep(i, n) for(int j = -h[i] + 1; j < 4; j++) for(int k = -w[i] + 1; k < 4; k++){\n\t\tint tx = min(max(0, j), 3), TX = min(max(0, j + h[i] - 1), 3);\n\t\tint ty = min(max(0, k), 3), TY = min(max(0, k + w[i] - 1), 3);\n\t\t\n\t\tint bit = 0;\n\t\tfor(int l = tx; l <= TX; l++) for(int m = ty; m <= TY; m++)\n\t\tbit |= 1 << 4 * l + m;\n\t\tstamp.pb(bit);\n\t}\n\tsort(all(stamp));\n\tstamp.erase(unique(all(stamp)), stamp.end());\n\tint m = stamp.size();\n\t\n\tqueue<pi> q;\n\tq.push(mp(0, 0));\n\tv[0] = 1;\n\twhile(!q.empty()){\n\t\tint c = q.front().first, bit = q.front().second; q.pop();\n\t\t\n\t\trep(i, stamp.size()) rep(j, 3){\n\t\t\tint nxt = bit & ~stamp[i] | stamp[i] & col[j];\n\t\t\tif(v[nxt]) continue;\n\t\t\tv[nxt] = 1;\n\t\t\tif(nxt == (1 << 16) - 1){\n\t\t\t\tcout << c + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tq.push(mp(c + 1, nxt));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\nbool rect[4][4][4][4];\n\nconst int V = 1 << 16;\nvector<unsigned short> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\t\n\t\tint next;\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tfor(int q = 0; q < 4; q++){\n\t\t\t\t\tfor(int r = 0; r < 4; r++){\n\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\tif(!rect[p][q][r][s]) continue;\n\t\t\t\t\t\t\tnext = u;\n\t\t\t\t\t\t\tfor(int dx = p; dx <= q; dx++){\n\t\t\t\t\t\t\t\tfor(int dy = r; dy <= s; dy++){\n\t\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(dist[next] < inf) continue;\n\t\t\t\t\t\t\tdist[next] = dist[u] + 1;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\trect[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < N; j++){\n\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\trect[max(x, 0)][min(x+W[j],4)-1][max(y, 0)][min(y+H[j],4)-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,l=1<<16;\n  cin>>n;\n  int h[n],w[n],dp[l],used[l];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4],c=\"RGB\";;\n  for(int i=0;i<4;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++)\n      for(int j=-h[i]+1;j<4;j++)\n\tfor(int k=-w[i]+1;k<4;k++)\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=max(0,-j);a<min(h[i],4-j);a++){\n\t      for(int b=max(0,-k);b<min(w[i],4-k);b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=l-1-(1<<(y*4+x));\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n  }\n  cout<<dp[l-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint calc(int a,int b){\n\tint tmp = 1;\n\tfor(int ccc=0;ccc<4*a;ccc++){\n\t\ttmp*=2;\n\t}\n\tfor(int j=0;j<b;j++){\n\t\ttmp*=2;\n\t}\n\treturn tmp;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<pair<int,int> > p;\n\tfor(int i=0;i<n;i++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tp.PB(MP(h,w));\n\t}\n\tvector<vector<vector<pair<int,int> > > >sp(n);\n\tfor(int qq=0;qq<n;qq++){\n\t\tfor(int i=-3;i<=3;i++){\n\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\tvector<pair<int,int> > z;\n\t\t\t\tfor(int x = 0;x<p[qq].first;x++){\n\t\t\t\t\tfor(int y=0;y<p[qq].second;y++){\n\t\t\t\t\t\tif(i+x>=0&&i+x<=3&&j+y>=0&&j+y<=3){\n\t\t\t\t\t\t\tz.PB(MP(i+x,j+y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(z.size()!=0)sp[qq].PB(z);\n\t\t\t}\n\t\t}\n\t}\n\tstring s[4];\n\tfor(int i=0;i<4;i++){\n\t\tcin >> s[i];\n\t}\n\tint a[4][4];\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(s[i][j]=='R'){\n\t\t\t\ta[i][j] = 1;\n\t\t\t}else if(s[i][j]=='G'){\n\t\t\t\ta[i][j] = 2;\n\t\t\t}else{\n\t\t\t\ta[i][j] = 3;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tqueue<pair<int,int > >q;\n\tbool used[100010];\n\tused[0] = 1;\n\tq.push(MP(0,0));\n\twhile(!q.empty()){\n\t\tauto x = q.front();\n\t\tq.pop();\n\t\tauto f = x.first;\n\t\tint g = x.second;\n\t\tif(f==65535){\n\t\t\tans = g;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int qq=0;qq<n;qq++){\n\t\t\tfor(int c=1;c<4;c++){\n\t\t\t\tfor(int k = 0;k<sp[qq].size();k++){\n\t\t\t\t\tauto s = f;\n\t\t\t\t\tauto w = sp[qq][k];\n\t\t\t\t\tfor(int i=0;i<w.size();i++){\n\t\t\t\t\t\tif(a[w[i].first][w[i].second]==c){\n\t\t\t\t\t\t\ts |= calc(w[i].first,w[i].second);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif((s&calc(w[i].first,w[i].second))==calc(w[i].first,w[i].second)){\n\t\t\t\t\t\t\t\ts -= calc(w[i].first,w[i].second);\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(used[s]!=1){\n\t\t\t\t\t\t//cout << static_cast<bitset<16> > (f) << \" \" << static_cast<bitset<16> > (s) << endl;\n\t\t\t\t\t\tused[s]=1;\n\t\t\t\t\t\tq.push(MP(s,g+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,H[17],W[17];\nint c[5][5];\nint dist[1<<16];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N)cin>>H[i]>>W[i];\n\trep(i,4)rep(j,4){\n\t\tchar C;\n\t\tcin>>C;\n\t\tc[i][j] = C=='R' ? 0 : C=='G' ? 1 : 2;\n\t}\n\trep(i,1<<16)dist[i] = INF;\n\tdist[0] = 0;\n\tqueue<int> Q;\n\tQ.push(0);\n\twhile(sz(Q)){\n\t\tint mask = Q.front(); Q.pop();\n\t\tif(mask == (1<<16)-1){\n\t\t\treturn cout<<dist[mask]<<endl,0;\n\t\t}\n\t\tint done[4][4][4][4] = {};\n\t\trep(i,N){\n\t\t\trep2(y,-H[i]+1,4)rep2(x,-W[i]+1,4)rep(color,3){\n\t\t\t\tint nmask = mask;\n\t\t\t\tint y0 = max(0, y);\n\t\t\t\tint x0 = max(0, x);\n\t\t\t\tint y1 = min(3, y+H[i]-1);\n\t\t\t\tint x1 = min(3, x+W[i]-1);\n\t\t\t\tif(done[y0][x0][y1][x1])continue;\n\t\t\t\tdone[y0][x0][y1][x1] = 1;\n\t\t\t\trep(ii,H[i])rep(jj,W[i]){\n\t\t\t\t\tint Y = y+ii, X = x+jj;\n\t\t\t\t\tif(Y<0 || Y>=4 || X<0 || X>=4)continue;\n\t\t\t\t\tif(c[Y][X] == color) nmask |= 1<<Y*4+X;\n\t\t\t\t\telse nmask &= ~(1<<Y*4+X);\n\t\t\t\t}\n\t\t\t\tif(dist[nmask] > dist[mask] + 1){\n\t\t\t\t\tdist[nmask] = dist[mask] + 1;\n\t\t\t\t\tQ.push(nmask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n;\nvi h, w;\nvvi c(4, vi(4));\n\nbool valid(int i, int j, int k, int state){\n    vi cnt(3);\n    rep2(ii, max(0ll, i - h[k] + 1), min(i + 1, 4ll)) {\n        rep2(jj, max(0ll, j - w[k] + 1), min(j + 1, 4ll)) {\n            if ((state >> (4*ii+jj)) & 1) cnt[c[ii][jj]]++;\n        }\n    }\n    int cnt_positive = (int)(cnt[0] > 0) + (int)(cnt[1] > 0) + (int)(cnt[2] > 0);\n    return cnt_positive == 1;\n}\n\nint stamp(int i, int j, int k, int state) {\n    rep2(ii, max(0ll, i - h[k] + 1), min(i + 1, 4ll)) {\n        rep2(jj, max(0ll, j - w[k] + 1), min(j + 1, 4ll)) {\n            state = (state & ((1 << 16) - 1 - (1 << (4*ii+jj))));\n        }\n    }\n    return state;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n;\n    h.resize(n); w.resize(n);\n    rep(i, n) cin >> h[i] >> w[i];\n    rep(i, 4) rep(j, 4) {\n        char x;\n        cin >> x;\n        if (x == 'R') c[i][j] = 0;\n        if (x == 'G') c[i][j] = 1;\n        if (x == 'B') c[i][j] = 2;\n    }\n\n    vi dp(1 << 16, inf);\n    dp[(1 << 16) - 1] = 0;\n    rrep(state, 1 << 16) {\n        // cerr << \"hey!\" << endl;\n        if (dp[state] == inf) continue;\n        rep(k, n) {\n            rep(i, 7) {\n                rep(j, 7) {\n                    // output(i, j, k, state);\n                    if (valid(i, j, k, state)) {\n                        int nstate = stamp(i, j, k, state);\n                        chmin(dp[nstate], dp[state] + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[0] << endl;\n\n/*\n    set<vvi> visited;\n    queue<pair<vvi, int>> que;\n    que.emplace(c, 0);\n    visited.emplace(c);\n    while (!que.empty()) {\n        vvi d;\n        int t;\n        tie(d, t) = que.front(); que.pop();\n        // output(\"t =\", t);\n        // printVV(d);\n        rep(k, n) {\n            rep(i, 7) {\n                rep(j, 7) {\n                    if (valid(i, j, k, d)) {\n                        vvi e = stamp(i, j, k, d);\n                        if (visited.count(e)) continue;\n                        if (e == cleared) {\n                            cout << t + 1 << endl;\n                            return 0;\n                        }\n                        que.emplace(e, t + 1);\n                        visited.emplace(e);\n                    }\n                }\n            }\n        }\n    }\n*/\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row1,int arg_row2,int arg_col1,int arg_col2){\n\t\trow1 = arg_row1;\n\t\trow2 = arg_row2;\n\t\tcol1 = arg_col1;\n\t\tcol2 = arg_col2;\n\t}\n\tint row1,row2,col1,col2;\n};\n\nstruct Data{\n\tbool table[4][4];\n\tint count;\n};\n\nbool can_stamp[4][4][4][4];\nbool check[65536];\nint POW[17];\n\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < POW[16]; i++)check[i] = false;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++)can_stamp[a][b][c][d] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint height,width;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&height,&width);\n\n\t\tfor(int row2 = 0; row2 <= 3; row2++){\n\t\t\tint row1 = max(0,row2-height+1);\n\n\t\t\tfor(int col2 = 0; col2 <= 3; col2++){\n\t\t\t\tint col1 = max(0,col2-width+1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t\tfor(int col1 = 0; col1 <= 3; col1++){\n\t\t\t\tint col2 = min(3,col1+width-1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int row1 = 0; row1 <= 3; row1++){\n\t\t\tint row2 = min(3,row1+height-1);\n\n\t\t\tfor(int col2 = 0; col2 <= 3; col2++){\n\t\t\t\tint col1 = max(0,col2-width+1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t\tfor(int col1 = 0; col1 <= 3; col1++){\n\t\t\t\tint col2 = min(3,col1+width-1);\n\t\t\t\tcan_stamp[row1][row2][col1][col2] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Info> V;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(can_stamp[a][b][c][d]){\n\t\t\t\t\t\tV.push_back(Info(a,b,c,d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tchar ans_table[4][5];\n\tfor(int row = 0; row < 4; row++){\n\t\tscanf(\"%s\",ans_table[row]);\n\t}\n\n\tData first;\n\tfirst.count = 0;\n\tfor(int row = 0; row < 4; row++){\n\t\tfor(int col = 0; col < 4; col++)first.table[row][col] = false;\n\t}\n\tcheck[0] = true;\n\n\tqueue<Data> Q;\n\tQ.push(first);\n\n\tbool FLG;\n\tchar base[4][4],work[4][4];\n\tbool not_color[3];\n\n\tint index,tmp_code;\n\n\tchar colors[3] = {'R','G','B'};\n\n\twhile(!Q.empty()){\n\n\t\tFLG = true;\n\t\tfor(int row = 0; row < 4; row++){\n\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\tif(Q.front().table[row][col] == false){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbase[row][col] = '@';\n\t\t\t\t}else{\n\t\t\t\t\tbase[row][col] = ans_table[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"%d\\n\",Q.front().count);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\n\t\t\tfor(int k = 0; k < 3; k++)not_color[k] = false;\n\n\t\t\tFLG = true;\n\t\t\tfor(int row = V[i].row1; row <= V[i].row2; row++){\n\t\t\t\tfor(int col = V[i].col1; col <= V[i].col2; col++){\n\t\t\t\t\tif(Q.front().table[row][col] == false){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tswitch(ans_table[row][col]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\tnot_color[0] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'G':\n\t\t\t\t\t\t\tnot_color[1] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\tnot_color[2] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)continue;\n\n\t\t\tfor(int paint = 0; paint < 3; paint++){\n\t\t\t\tif(not_color[paint] == false)continue;\n\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\twork[row][col] = base[row][col];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int row = V[i].row1; row <= V[i].row2; row++){\n\t\t\t\t\tfor(int col = V[i].col1; col <= V[i].col2; col++){\n\t\t\t\t\t\twork[row][col] = colors[paint];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tindex = 0,tmp_code = 0;\n\t\t\t\tData next_data;\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\tif(work[row][col] == ans_table[row][col]){\n\t\t\t\t\t\t\ttmp_code += POW[index];\n\t\t\t\t\t\t\tnext_data.table[row][col] = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_data.table[row][col] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(check[tmp_code])continue;\n\n\t\t\t\tcheck[tmp_code] = true;\n\t\t\t\tnext_data.count = Q.front().count+1;\n\t\t\t\tQ.push(next_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  const string cols = \"RGB\";\n\n  int N; cin >> N;\n  vector<pair<int, int>> vs(N);\n  rep(i, N) {\n    cin >> vs[i].first >> vs[i].second;\n  }\n\n  vector<string> G(4);\n  rep(i, 4) cin >> G[i];\n\n  static int dist[1<<16];\n  minus(dist);\n  dist[0] = 0;\n\n  queue<int> q;\n  q.push(0);\n\n  while(!q.empty()) {\n    if(~dist[(1<<16)-1]) break;\n\n    int curr = q.front(); q.pop();\n\n    for(auto hw: vs) {\n      int h = hw.first, w = hw.second;\n\n      for(auto col: cols)\n      REP(i, -h + 1, 4) REP(j, -w + 1, 4) {\n        int next = curr;\n        REP(y, max(0, i), min(i + h, 4)) REP(x, max(0, j), min(j + w, 4)) {\n          if(G[y][x] == col) next |= 1<<(y * 4 + x);\n          else next &= ~(1<<(y * 4 + x));\n        }\n        if(dist[next] < 0) {\n          dist[next] = dist[curr] + 1;\n          q.push(next);\n        }\n      }\n    }\n  }\n\n  cout << dist[(1<<16)-1] << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\nconstexpr int SIZE = 4;\nenum { R, G, B, NUM_COLORS };\n\nint bfs(const array<int, NUM_COLORS> &colors, const vector<int> &stamps) {\n\tconstexpr int ARRAY_SIZE = 1 << (SIZE * SIZE);\n\tconstexpr int goal = ARRAY_SIZE - 1;\n\n\tqueue<int> que;\n\tarray<int, ARRAY_SIZE> dist;\n\n\tque.push(0);\n\tdist.fill(INT_MAX);\n\tdist[0] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &s : stamps) {\n\t\t\tfor(const auto &c : colors) {\n\t\t\t\tconst int to = (v & ~s) | (c & s);\n\n\t\t\t\tif(dist[to] == INT_MAX) {\n\t\t\t\t\tif(to == goal) return dist[v] + 1;\n\t\t\t\t\tque.push(to);\n\t\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint convert[128];\n\tconvert[static_cast<int>('R')] = R;\n\tconvert[static_cast<int>('G')] = G;\n\tconvert[static_cast<int>('B')] = B;\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> stamps;\n\tstamps.reserve(n * (2 * SIZE - 1) * (2 * SIZE - 1));\n\n\trep(idx, n) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tREP(dx, -SIZE + 1, SIZE) {\n\t\t\tREP(dy, -SIZE + 1, SIZE) {\n\t\t\t\tint bit = 0;\n\n\t\t\t\trep(i, h) {\n\t\t\t\t\tconst int y = i + dy;\n\t\t\t\t\tif(y < 0 || y >= SIZE) continue;\n\n\t\t\t\t\trep(j, w) {\n\t\t\t\t\t\tconst int x = j + dx;\n\t\t\t\t\t\tif(x < 0 || x >= SIZE) continue;\n\n\t\t\t\t\t\tbit |= (1 << (y * SIZE + x));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstamps.emplace_back(bit);\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(ALL(stamps));\n\tstamps.erase(unique(ALL(stamps)), end(stamps));\n\n\tarray<int, NUM_COLORS> colors;\n\tcolors.fill(0);\n\n\trep(i, SIZE) {\n\t\tstring row;\n\t\tcin >> row;\n\n\t\trep(j, SIZE) {\n\t\t\tcolors[convert[static_cast<int>(row[j])]] |= (1 << (i * SIZE + j));\n\t\t}\n\t}\n\n\tcout << bfs(colors, stamps) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,ll> P2;\n\nint n,h[16],w[16],ty,tx;\nstring s[4];\nmap<ll,bool> memo;\nll ans,tmp;\nvector<ll> st;\nbool b[3];\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++)cin >> h[i] >> w[i];\n  for(int i=0;i<4;i++)cin >> s[i];\n\n  ans = 0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(s[i][j] == 'R')ans += 1LL<<(2*(i*4+j));\n      if(s[i][j] == 'G')ans += 2LL<<(2*(i*4+j));\n      if(s[i][j] == 'B')ans += 3LL<<(2*(i*4+j));\n    }\n\n  for(int i=0;i<n;i++){\n    for(int j=-h[i]+1;j<4;j++){\n      for(int k=-w[i]+1;k<4;k++){\n\ttmp = 0;\n\tfor(int y=0;y<h[i];y++){\n\t  for(int x=0;x<w[i];x++){\n\t    ty = y+j; tx = x+k;\n\t    if(ty<0 || tx<0 || 4<=ty || 4<=tx)continue;\n\t    tmp |= 1LL<<(2*(ty*4+tx));\n\t  }\n\t}\n\tst.push_back(tmp);\n      }\n    }\n  }\n  sort(st.begin(),st.end());\n  st.erase(unique(st.begin(),st.end()),st.end());\n\n  memo.clear();memo[0] = true;\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  q.push(P2(P(3,0),0));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    \n    for(int i=0;i<st.size();i++){\n      for(ll j=1;j<=3;j++){\n\ttmp = p.sc;\n\ttmp &= -1LL^(3LL*st[i]);\n\ttmp |= j*st[i];\n\n\n\tif(memo.find(tmp)==memo.end()){\n\t  memo[tmp] = true;\n\n\t  for(int k=0;k<3;k++)b[k] = false;\n\t  for(int k=0;k<16;k++){\n\t    if( ((tmp>>(2*k))&3LL) != ((ans>>(2*k))&3LL)){\n\t      b[((ans>>(2*k))&3LL)-1] = true;\n\t    }\n\t  }\n\t  int cnt = 0;\n\t  for(int k=0;k<3;k++)if(b[k])cnt++;\n\t  if(!cnt){\n\t    cout << p.fs.sc+1 << endl;\n\t    return 0;\n\t  }\n\t  \n\t  q.push(P2(P(p.fs.sc+cnt+1,p.fs.sc+1),tmp));\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nunsigned dist[1<<16];\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> pt;\n\tmemset(dist,-1,sizeof(dist));\n\tfor(int k=0;k<n;k++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tfor(int i=-h+1;i<4;i++){\n\t\t\tfor(int j=-w+1;j<4;j++){\n\t\t\t\tint u=0;\n\t\t\t\tfor(int p=0;p<4;p++){\n\t\t\t\t\tif(i<=p&&p<i+h){\n\t\t\t\t\t\tfor(int q=0;q<4;q++){\n\t\t\t\t\t\t\tif(j<=q&&q<j+w){\n\t\t\t\t\t\t\t\tu|=1<<(4*p+q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpt.push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tsort(pt.begin(),pt.end());\n\tpt.resize(unique(pt.begin(),pt.end())-pt.begin());\n\tint col[3]={0};\n\tfor(int i=0;i<4;i++){\n\t\tchar buf[5];\n\t\tcin >> buf;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint u=1<<(4*i+j);\n\t\t\tswitch(buf[j]){\n\t\t\t\tcase 'R':col[0]|=u;break;\n\t\t\t\tcase 'G':col[1]|=u;break;\n\t\t\t\tcase 'B':col[2]|=u;break;\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> mask;\n\tfor(int u:pt){\n\t\tfor(int c:col){\n\t\t\tif(u&c){\n\t\t\t\tmask.push_back(P(u&c,~u));\n\t\t\t}\n\t\t}\n\t}\n\tdist[0]=0;\n\tqueue<int> q;\n\tq.push(0);\n\twhile(q.size()){\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(auto m:mask){\n\t\t\tint v=(u&m.second)|m.first;\n\t\t\tif(dist[u]+1<dist[v]){\n\t\t\t\tdist[v]=dist[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    \t\n    for(int idx=0;idx<N;idx++){\n\t\n      if(S&(1<<idx)) continue;\n\t\n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\nbool rect[4][4][4][4];\n\nconst int V = 1 << 16;\nset<int> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(set<int>::iterator it = G[u].begin(); it != G[u].end(); it++){\n\t\t\tif(dist[*it] < inf) continue;\n\t\t\tdist[*it] = dist[u] + 1;\n\t\t\tQ.push(*it);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\trect[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < N; j++){\n\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\trect[max(x, 0)][min(x+W[j],4)-1][max(y, 0)][min(y+H[j],4)-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tnext = i;\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tfor(int q = 0; q < 4; q++){\n\t\t\t\t\tfor(int r = 0; r < 4; r++){\n\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\tif(!rect[p][q][r][s]) continue;\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tfor(int dx = p; dx <= q; dx++){\n\t\t\t\t\t\t\t\tfor(int dy = r; dy <= s; dy++){\n\t\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tG[i].insert(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());int rs=0;\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){int f=0,c1=0,c2=0;\n        r(kk,4)tmp[kk]=t[kk];\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            if(tmp[i][j]==s[i][j])c1++;\n            if(tmp[i][j]==s[i][j]&&s[i][j]!=ccol[col])f++;\n            tmp[i][j]=ccol[col];\n            if(tmp[i][j]==s[i][j])c2++;\n          }\n        }if(f||c1==c2)continue;\n        int tp=0;\n        r(i1,4)r(j1,4)if(s[i1][j1]==tmp[i1][j1])tp+=(1<<(i1*4+j1));\n        if(!dp[tp]){rs++;\n          dp[tp]=1;\n          q.push(P(tp,p.second+1));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int WIDTH = 4;\nconst int MAX_N = WIDTH * WIDTH;\n\ntypedef pair<int,int> mask; // (ツづ環づつスツ閉板閉ェツ、ツづつアツづーツ塗ツづゥツつゥ)\n\nint N;\nint hs[MAX_N], ws[MAX_N];\nchar goal[WIDTH][WIDTH + 1];\nint dist[1<<(WIDTH * WIDTH)];\nbool visited[1<<(WIDTH * WIDTH)];\n\nint solve(){\n\tvector<mask> masks;\n\n\tconst char colors[] = \"RGB\";\n\t//ツ前ツ渉按猟敖づ全ツづづ個マツスツクツづーツ仰づ淞づつィツつュ\n\tfor(int k=0; k<N; k++){\n\t\tfor(int col=0; col<3; col++){\n\t\t\tfor(int y=-4; y<4; y++){\n\t\t\t\tfor(int x=-4; x<4; x++){\n\t\t\t\t\tint correct = 0, remain = (1<<(WIDTH * WIDTH)) - 1;\n\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\t\t\tif(y <= i && i < y + hs[k] && x <= j && j < x + ws[k]){\n\t\t\t\t\t\t\t\tremain ^= 1 << (i * 4 + j);\n\t\t\t\t\t\t\t\tif(goal[i][j] == colors[col]){\n\t\t\t\t\t\t\t\t\tcorrect |= 1 << (i * 4 + j);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmasks.push_back( make_pair(correct, remain) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(masks.begin(), masks.end());\n\tmasks.erase(unique(masks.begin(), masks.end()), masks.end());\n\n\tvisited[0] = true;\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint tp = que.front(); que.pop();\n\n\t\tfor(int i=0; i<(int)masks.size(); i++){\n\t\t\tint next = masks[i].first | (masks[i].second & tp);\n\t\t\tif(!visited[next]){\n\t\t\t\tdist[next] = dist[tp] + 1;\n\t\t\t\tvisited[next] = true;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist[(1<<(WIDTH*WIDTH) ) - 1];\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%d%d \",hs+i, ws+i);\n\t}\n\tfor(int i=0; i<4; i++){\n\t\tscanf(\"%[^\\n]%*c\", goal[i]);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\n#define M 4\nusing namespace std;\n\nint n,h[N],w[N];\nstring s[M];\n\nbool dp[N+1][(1<<N)];\n\nvoid mark(int cnt,int S,int idx,int stamp){\n  \n  int y=idx/M,x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S,f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(S&(1<<p)) f=1;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(!f) dp[cnt+1][nS]=true;\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  dp[0][0]=true;\n\n  int ans=N;\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<(1<<N);j++){\n      \n      if(!dp[i][j]) continue;\n      \n      if(j==(1<<N)-1){\n\tans=i;\n\tbreak;\n      }\n      \n      for(int y=0;y<M;y++){\n\tfor(int x=0;x<M;x++){\n\t  \n\t  int idx=y*M+x;\n\t  \n\t  if(j&(1<<idx)) continue;\n\t  \n\t  for(int k=0;k<n;k++) mark(i,j,idx,k);\n\t  \n\t}\n      }\n      \n      \n    }\n    \n    if(ans!=N)break;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <iostream>\nusing namespace std;\nint bit_in[16][3][7][7], bit_out[16][3][7][7];\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; ++i) cin >> X[i] >> Y[i];\n\tvector<string> BV(4);\n\tcin >> BV[0] >> BV[1] >> BV[2] >> BV[3];\n\tstring B = BV[0] + BV[1] + BV[2] + BV[3];\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tchar c = (j == 0 ? 'R' : (j == 1 ? 'G' : 'B'));\n\t\t\tfor (int k = 0; k < 4 + X[i]; ++k) {\n\t\t\t\tfor (int l = 0; l < 4 + Y[i]; ++l) {\n\t\t\t\t\tfor (int p = 0; p < X[i]; ++p) {\n\t\t\t\t\t\tfor (int q = 0; q < Y[i]; ++q) {\n\t\t\t\t\t\t\tint tx = k - p, ty = l - q;\n\t\t\t\t\t\t\tif (0 <= tx && tx < 4 && 0 <= ty && ty < 4) {\n\t\t\t\t\t\t\t\tif (B[tx * 4 + ty] == c) bit_in[i][j][k][l] |= 1 << (tx * 4 + ty);\n\t\t\t\t\t\t\t\telse bit_out[i][j][k][l] |= 1 << (tx * 4 + ty);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> que; que.push(0);\n\tvector<int> dist(1 << 16, -1); dist[0] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tchar c = (j == 0 ? 'R' : (j == 1 ? 'G' : 'B'));\n\t\t\t\tfor (int k = 0; k < 4 + X[i]; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 4 + Y[i]; ++l) {\n\t\t\t\t\t\tint bit = u;\n\t\t\t\t\t\tbit |= bit_in[i][j][k][l];\n\t\t\t\t\t\tbit &= ~bit_out[i][j][k][l];\n\t\t\t\t\t\tif (dist[bit] == -1) {\n\t\t\t\t\t\t\tdist[bit] = dist[u] + 1;\n\t\t\t\t\t\t\tque.push(bit);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[(1 << 16) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\n\tint ny=y-i+k;\n\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    bool flag[4][4][5][5][3];\n    fill_n((bool*)flag,4*4*5*5*3,false);\n    rep(y1,0,4) rep(x1,0,4) rep(y2,y1+1,5) rep(x2,x1+1,5) rep(y,y1,y2) rep(x,x1,x2) flag[y1][x1][y2][x2][c[y][x]]=true;\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    vector<int> cost(1<<16,inf);\n    queue<bitset<16>> que;\n    cost[0]=0;\n    que.push(bitset<16>(0));\n    while(!que.empty()){\n        auto bs=que.front();\n        que.pop();\n        int state=encode(bs);\n        if(bs.all()){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-h[i]+1,4) rep(x,-w[i]+1,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            rep(j,0,3){\n                if(!flag[y1][x1][y2][x2]) continue;\n                auto next_bs=bs;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j) next_bs.set(4*y_+x_);\n                    else next_bs.reset(4*y_+x_);\n                }\n                int next_state=encode(next_bs);\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(next_bs);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\t  REP(y,-5,9){\n\t    REP(x,-5,9){\n\t      rep(stp,N){\n\t  \n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      if(c == 'X')continue;\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst int all=(1<<16)-1;\nint n,h[20],w[20];\nint memo[1<<16];\nchar board[4][4];\nchar cur[10][10];\n\nint rec(int mask){\n\tif(mask==all) return 0;\n\tint &ret=memo[mask];\n\tif(ret!=-1) return ret;\n\n\tret=1010;\n\t\n\trep(idx,n){\n\t\trep(si,10)rep(sj,10){\n\t\t\tconst int ti=si+h[idx],tj=sj+w[idx];\n\t\t\tif(ti<=3||7<=si) continue;\n\t\t\tif(tj<=3||7<=sj) continue;\n\n\t\t\tset<char> s;\n            int nmask=mask;\n            rep(a,h[idx])rep(b,w[idx]){\n                const int ca=si+a,cb=sj+b;\n                if(ca<3||7<=ca) continue;\n                if(cb<3||7<=cb) continue;\n                if(cur[ca][cb]=='*') continue;\n                s.insert(cur[ca][cb]);\n                nmask|=bit(4*(ca-3)+(cb-3));\n            }\n\n            if(s.size()==1&&nmask>mask){\n            \tif(memo[nmask]!=-1){\n            \t\tchmin(ret,rec(nmask)+1);\n            \t}else{\n        \t\t\tconst int change=nmask^mask;\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]='*';\n\t            \tchmin(ret,rec(nmask)+1);\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]=board[i][j];\n            \t}\n            }\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\n\trep(i,4) rep(j,4) cin >> board[i][j];\n\trep(i,10)rep(j,10) cur[i][j]='*';\n\trep(i,4)rep(j,4) cur[i+3][j+3]=board[i][j];\n\tclr(memo,-1);\n\tcout << rec(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    assert(cost<=16);\n    for(int idx=0;idx<N;idx++){\n\t\n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nvector< pair<int,int> > mask;\n\nvector< vector<char> > goal(4,vector<char>(4));\n\nint w[20],h[20];\n\ninline void gen(int s,int x,int y){\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask.push_back(make_pair(a,b));\n\t}\n}\nint f(int init){\n\tQ[size++] = init;\n\tmemo[init] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,mask.size()){\n\t\t\tint bit = (q & ~mask[i].first) | mask[i].second;\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[i][j] = c;\n\t}\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\tsort(mask.begin(),mask.end());\n\tmask.erase(unique(mask.begin(),mask.end()),mask.end());\n\t\n\tcout << f(0) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nstruct P {\n    int cost;\n    uint16_t bit;\n};\n\nchar colorchar[] = {'R', 'G', 'B'};\nbool G[1<<16];\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pii> stamp(N);\n    REP(i, N) {\n        cin >> stamp[i].second >> stamp[i].first;\n    }\n    vvc field(4, vc(4));\n    REP(y, 4) REP(x, 4) {\n        cin >> field[y][x];\n    }\n\n    uint16_t goal = (1<<16)-1;\n\n    queue<P> que;\n    G[0] = true;\n    que.push({0, 0});\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        if (p.bit == goal) {\n            cout << p.cost << endl;\n            break;\n        }\n        REP(i, N) {\n            FOR(ly, -stamp[i].second+1, 4) FOR(lx, -stamp[i].first+1, 4) {\n                int rx = lx + stamp[i].first, ry = ly + stamp[i].second;\n                REP(j, 3) {\n                    uint16_t bit = p.bit;\n                    FOR(sy, ly, ry) FOR(sx, lx, rx) {\n                        if (0 <= sx && sx < 4 && 0 <= sy && sy < 4) {\n                            int k = 4*sy+sx;\n                            if (field[sy][sx] == colorchar[j]) {\n                                bit |= 1<<k;\n                            } else {\n                                bit &= ~(1<<k);\n                            }\n                        }\n                    }\n                    if (!G[bit]) {\n                        G[bit] = true;\n                        que.push({p.cost+1, bit});\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint mp[1<<16];\n\nint main(){\n    rep(i,1<<16)mp[i] = -1;\n    vector<pii> stamp;\n    int n;\n    cin>>n;\n    rep(i,n){\n        int h,w;\n        cin>>h>>w;\n        stamp.pb(pii(h,w));\n    }\n    \n    vector<string> vs(4);\n    rep(i,4)cin>>vs[i];\n    \n    \n    queue<int> que;\n    que.push((1<<16)-1);\n    mp[(1<<16)-1] = 0;\n    \n    while(que.size()){\n        int q = que.front();\n        que.pop();\n        int dist = mp[q];\n        \n        for(const auto &stm:stamp){\n            int h,w;\n            tie(h,w) = stm;\n            for(int i=-h+1;i<4;i++){\n                for(int j=-w+1;j<4;j++){\n                    int r=0,g=0,b=0;\n                    for(int ii = i;ii<i+h;ii++){\n                        ii = max(ii,0);\n                        if(ii>=4)break;\n                        for(int jj = j;jj<j+w;jj++){\n                            jj = max(jj,0);\n                            if(jj>=4)break;\n                            \n                            if( (q>>(ii*4+jj))%2 && vs[ii][jj]=='R' )r++;\n                            if( (q>>(ii*4+jj))%2 && vs[ii][jj]=='G' )g++;\n                            if( (q>>(ii*4+jj))%2 && vs[ii][jj]=='B' )b++;\n                            if( (bool)r + (bool)(g) + (bool)(b)>=2 )goto end_loop;\n                        }\n                    }\n                end_loop:;\n                    if( (bool)r + (bool)(g) + (bool)(b)==1 ){\n                        int tmp = q;\n                        for(int ii = max(0,i);ii<min(4,i+h);ii++){\n                            for(int jj = max(0,j);jj<min(4,j+w);jj++){\n                                tmp &= ~(1<<(ii*4+jj));\n                            }\n                        }\n                        if(mp[tmp]==-1){\n                            int count = 0;\n                            rep(ii,4)rep(jj,4)if( (tmp>>(ii*4+jj))%2==0 )count++;\n                            if(count==16){\n                                cout<<dist+1<<endl;\n                                return 0;\n                            }\n                            \n                            que.push(tmp);\n                            mp[tmp] = dist+1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 17\n#define MAX_DP (1<<16)\n\nusing namespace std;\n\nint N;\nint H[MAX],W[MAX];\nchar G[4][4];\nint dp[MAX_DP];\n\nint main(){\n\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(i,4)rep(j,4)cin >> G[i][j];\n\n  rep(i,MAX_DP)dp[i] = IINF;\n  dp[0] = 0;\n\n  int mex = 0;\n  for(int state=0;state<MAX_DP;state++){\n    if(dp[state] == IINF)continue;\n\t  REP(y,-10,10){\n\t    REP(x,-10,10){\n\t      rep(stp,N){\n\t  \n\t      int add = 0;\n\t      int subtract = 0;\n\t      char c = 'X';\n\t      rep(cy,H[stp]){\n\t\trep(cx,W[stp]){\n\t\t  int nx = x + cx;\n\t\t  int ny = y + cy;\n\t\t  if(!( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 )) continue;\n\t\t  else{\n\t\t    if(c == 'X'){\n\t\t      c = G[ny][nx];\n\t\t    }\n\t\t  }\n\t\t  if(c == 'X')continue;\n\t\t  if(G[ny][nx] == c) add |= (1<<(nx+ny*4));\n\t\t  else subtract |= (1<<(nx+ny*4));\n\t\t}\n\t      }\n\t      if(c == 'X')continue;\n\t      assert(dp[state] != IINF);\n\t      dp[(state|add)&(~subtract)] = min(dp[(state|add)&(~subtract)],dp[state]+1);\n\t    }\n\t    \n\t  }\n\t}\n\t\n  }\n  assert(dp[MAX_DP-1]!=IINF);\n  cout << dp[MAX_DP-1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint h[20], w[20];\nint brd[7][7];\nint dp[(1<<16)];\n\nint main(){\n\trep(i,(1<<16)) dp[i] = INF;\n\tdp[0] = 0;\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R') brd[i][j] = 1;\n\t\tif(c == 'G') brd[i][j] = 2;\n\t\tif(c == 'B') brd[i][j] = 3;\n\t}\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tint Q = q;\n\t\tque.pop();\n\t\tint b[7][7];\n\t\trep(i,7) rep(j,7) b[i][j] = 0;\n\t\tfor(int i = 3; i < 7; i++) for(int j = 3; j < 7; j++){\n\t\t\tb[i][j] = (q&1);\n\t\t\tq >>= 1;\n\t\t}\n\t\tq = Q;\n\t\trep(i,n){\n\t\t\trep(j,7){\n\t\t\t\trep(k,7){\n\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(hh,h[i]){\n\t\t\t\t\t\t\tif(j+hh >= 7) continue;\n\t\t\t\t\t\t\trep(ww,w[i]){\n\t\t\t\t\t\t\t\tif(k+ww >= 7) continue;\n\t\t\t\t\t\t\t\tif(b[j+hh][k+ww] == 0 && brd[j+hh][k+ww] != 0 && brd[j+hh][k+ww] != l){\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ok) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok) continue;\n\t\t\t\t\t\tint x = 0;\n\t\t\t\t\t\tfor(int hh = 6; hh >= 3; hh--){\n\t\t\t\t\t\t\tfor(int ww = 6; ww >= 3; ww--){\n\t\t\t\t\t\t\t\tif(j <= hh && hh < j+h[i] && k <= ww && ww < k+w[i]){\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += 1;\n\t\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\t\tx *= 2;\n\t\t\t\t\t\t\t\t\tx += b[hh][ww];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[x] > dp[q]+1){\n\t\t\t\t\t\t\tdp[x] = dp[q]+1;\n\t\t\t\t\t\t\tque.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tset<int> stamp;\n\tfor(int i=0; i<n; ++i){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfor(int j=-3; j<4; ++j){\n\t\t\tfor(int k=-3; k<4; ++k){\n\t\t\t\tbitset<16> bs;\n\t\t\t\tfor(int y=j; y<j+h; ++y){\n\t\t\t\t\tfor(int x=k; x<k+w; ++x){\n\t\t\t\t\t\tif(0 <= y && y <4 && 0 <= x && x < 4)\n\t\t\t\t\t\t\tbs[y*4+x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bs.any())\n\t\t\t\t\tstamp.insert(bs.to_ulong());\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<bitset<16> > color(3);\n\tfor(int i=0; i<16; ++i){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif(c == 'R')\n\t\t\tcolor[0][i] = true;\n\t\telse if(c == 'G')\n\t\t\tcolor[1][i] = true;\n\t\telse\n\t\t\tcolor[2][i] = true;\n\t}\n\n\tvector<int> memo(1<<16, -1);\n\tqueue<int> q;\n\tmemo[0] = 0;\n\tq.push(0);\n\tfor(;;){\n\t\tbitset<16> bs = q.front();\n\t\tq.pop();\n\n\t\tset<int>::iterator it;\n\t\tfor(it=stamp.begin(); it!=stamp.end(); ++it){\n\t\t\tfor(int i=0; i<3; ++i){\n\t\t\t\tbitset<16> bs2 = color[i] & bitset<16>(*it);\n\t\t\t\tif(bs2.none())\n\t\t\t\t\tcontinue;\n\t\t\t\tbs2 |= bs & ~bitset<16>(*it);\n\t\t\t\tif(memo[bs2.to_ulong()] == -1){\n\t\t\t\t\tmemo[bs2.to_ulong()] = memo[bs.to_ulong()] + 1;\n\t\t\t\t\tq.push(bs2.to_ulong());\n\t\t\t\t\tif(bs2.all()){\n\t\t\t\t\t\tcout << memo[bs2.to_ulong()] << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n\nint main(){\n  int N;cin>>N;\n  vector<int> H(N),W(N);\n  rep(i,0,N)cin>>H[i]>>W[i];\n  int C[4][4];\n  int goals[3] = {};\n  rep(i,0,4)rep(j,0,4){\n    char c;cin>>c;\n    if(c=='R')\n      C[i][j]=0;\n    else if(c=='G')\n      C[i][j]=1;\n    else \n      C[i][j]=2;\n    goals[C[i][j]] |= 1 << (i * 4 + j);\n  }\n  vector<int> stamps;\n  auto inrange = [&](int i,int j) {return 0 <= i && i < 4 && 0 <= j && j < 4; };\n  rep(s,0,N){\n    rep(i,-3,4)rep(j,-3,4){\n      int mask = 0;\n      rep(ci,i,i+H[s])rep(cj,j,j+W[s]){\n        if(!inrange(ci,cj))continue;\n        mask |= (1 << (ci * 4 + cj));\n      }\n      stamps.push_back(mask);\n    }\n  }\n  queue<int> q;\n  q.push(0);\n  const int INF = 100;\n  vector<int> dp(1 << 16, INF);\n  dp[0] = 0;\n  while(q.size()) {\n    int now = q.front(); q.pop();\n    rep(c,0,3){\n    for(auto stamp : stamps){\n      int next = (~stamp & now) | (goals[c] & stamp);\n      if(dp[next] != INF)continue;\n      dp[next] = dp[now] + 1;\n      q.push(next);\n    }\n    }\n  }\n  \n  cout << dp[(1 << 16) - 1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/02 20:16:19\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<int, int>;\n    vector<P> s(N);\n    for (int i = 0, H, W; i < N; i++) { cin >> H >> W, s[i] = {H, W}; }\n    vector<vector<int>> f(4, vector<int>(4, 0));\n    map<char, int> mp;\n    mp['R'] = 1, mp['G'] = 2, mp['B'] = 3;\n    for (int i = 0; i < 4; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 4; j++) { f[i][j] = mp[s[j]]; }\n    }\n    auto hash = [](const vector<vector<int>>& f) -> int {\n        int ans = 0;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) { ans += ((int)(f[i][j] != 0) << (i * 4 + j)); }\n        }\n        return ans;\n    };\n    vector<int> memo(1 << 16, -1);\n    auto dfs = [&](auto&& self, const vector<vector<int>>& f) -> int {\n        const int h = hash(f);\n        if (h == 0) { return 0; }\n        if (memo[h] != -1) { return memo[h]; }\n        int ans = 30;\n        for (int i = 0; i < N; i++) {\n            const int H = s[i].first, W = s[i].second;\n            for (int h = 1 - H; h < 4; h++) {\n                for (int w = 1 - W; w < 4; w++) {\n                    const int hinf = max(h, 0), winf = max(w, 0);\n                    const int hsup = min(h + H, 4), wsup = min(w + W, 4);\n                    set<int> ch;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) {\n                            if (f[i][j] != 0) { ch.insert(f[i][j]); }\n                        }\n                    }\n                    if (ch.size() != 1) { continue; }\n                    auto newf = f;\n                    for (int i = hinf; i < hsup; i++) {\n                        for (int j = winf; j < wsup; j++) { newf[i][j] = 0; }\n                    }\n                    const int sub = self(self, newf) + 1;\n                    ans = min(ans, sub);\n                }\n            }\n        }\n        return memo[h] = ans;\n    };\n    const int ans = dfs(dfs, f);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint dist[(1 << 16)];\nint s[4][4];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi h(n), w(n);\n    rep(i,n){\n        cin >> h[i] >> w[i];\n    }\n    rep(i,4){\n        string hoge;\n        cin >> hoge;\n        rep(j,4){\n            if(hoge[j] == 'R'){\n                s[i][j] = 0;\n            }else if(hoge[j] == 'G'){\n                s[i][j] = 1;\n            }else{\n                s[i][j] = 2;\n            }\n        }\n    }\n    rep(i,(1 << 16)){\n        dist[i] = INF;\n    }\n    dist[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        rep(i,3){\n            rep(j,n){\n                srep(k,-h[j]+1,4){\n                    srep(l,-w[j]+1,4){\n                        int nx = p;\n                        srep(t,max(k,0),min(k+w[j],4)){\n                            srep(u,max(l,0),min(l+h[j],4)){\n                                if((p >> (4*t+u))&1){\n                                    if(s[t][u] != i) nx -= (1 << (4*t+u));\n                                }else{\n                                    if(s[t][u] == i) nx += (1 << (4*t+u));\n                                }\n                            }\n                        }\n                        if(dist[nx] > dist[p] + 1){\n                            dist[nx] = dist[p] + 1;\n                            que.push(nx);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << dist[(1 << 16)-1] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\ntemplate<typename T>\nvector<vector<T>> keisann(const vector<vector<T>>l, const vector<vector<T>>r) {\n\tvector<vector<T>>ans(l.size(), vector<T>(r[0].size()));\n\tassert(l[0].size() == r.size());\n\tfor (unsigned int h = 0; h < l.size(); ++h) {\n\t\tfor (unsigned int i = 0; i < r.size(); ++i) {\n\t\t\tfor (unsigned int w = 0; w < r[0].size(); ++w) {\n\n\t\t\t\tans[h][w] += l[h][i] * r[i][w];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\ntemplate<typename T>\nvector<vector<T>>powgyou(vector<vector<T>>a, const long long int n) {\n\tassert(a.size() == a[0].size());\n\tif (!n) {\n\t\tvector<vector<T>>e(a.size(), vector<T>(a[0].size()));\n\t\tfor (unsigned int i = 0; i < a.size(); ++i) {\n\t\t\te[i][i] = 1;\n\t\t}\n\t\treturn e;\n\t}\n\tif (n == 1)return a;\n\telse {\n\t\tvector<vector<T>>ans(a.size(), vector<T>(a[0].size(), 0));\n\t\tans = powgyou(a, n / 2);\n\t\tans = keisann(ans, ans);\n\t\tif (n % 2) {\n\t\t\tans = keisann(ans, a);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 2147483647;\nconst long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\t\t\t\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\nok = true;\nbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, 0));\n\t\t\t}\n\t\t}\n\t}\n\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nmap<long long int, int>soinnsuu(long long int a) {\n\tmap<long long int, int>ans;\n\tfor (long long i = 2; i*i <= a; ++i) {\n\t\twhile (a%i == 0) {\n\t\t\tans[i]++;\n\t\t\ta /= i;\n\t\t}\n\t}\n\tif (a != 1)ans[a]++;\n\n\n\treturn ans;\n}\n\nbool isso(long long int a) {\n\tif (a == 1)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif (!(a%i)) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t}\n\t}\n\treturn true;\n}\n\n\nstruct vert {\n\tint deg;\n\tint s;\n\tint id;\n\tvert(int a, int b, int c) {\n\t\tdeg = a;\n\t\ts = b;\n\t\tid = c;\n\t}\n};\n\n\n#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\nclass Compare {\npublic:\n\tbool operator()(const pair<int, int>&l, const pair<int, int>&r) {\n\t\treturn l.second > r.second;\n\t}\n};\nvector<pair<int, int>>stamps;\nint dp[1 << 16];\nvector<vector<int>>puz(4, vector<int>(4));;\n\nint getans(const bitset<16>bt) {\n\tif (dp[bt.to_ulong()] >= 0)return dp[bt.to_ulong()];\n\telse {\n\t\tif (bt.count() == 16)return dp[bt.to_ulong()] = 0;\n\t\telse {\n\n\t\t\tint ans = 16 - bt.count();\n\t\t\tfor (int i = 0; i < stamps.size(); ++i) {\n\t\t\t\tint h = stamps[i].first;\n\t\t\t\tint w = stamps[i].second;\n\t\t\t\tfor (int l = 1-w; l < 4; ++l) {\n\t\t\t\t\tfor (int u = 1-h; u < 4; ++u) {\n\t\t\t\t\t\tfor (int c = 0; c < 3; ++c) {\n\n\t\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\t\tfor (int x = l; x < l + w; ++x) {\n\t\t\t\t\t\t\t\tif (x < 0 || x >= 4)continue;\n\t\t\t\t\t\t\t\tfor (int y = u; y < u + h; ++y) {\n\t\t\t\t\t\t\t\t\tif (y < 0 || y >= 4)continue;\n\t\t\t\t\t\t\t\t\tif (bt[y * 4 + x] || puz[y][x] == c) {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\t\t\tbitset<16>copybt(bt);\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tfor (int x = l; x < l + w; ++x) {\n\t\t\t\t\t\t\t\t\tif (x < 0 || x >= 4)continue;\n\t\t\t\t\t\t\t\t\tfor (int y = u; y < u + h; ++y) {\n\t\t\t\t\t\t\t\t\t\tif (y < 0 || y >= 4)continue;\n\t\t\t\t\t\t\t\t\t\tif (!copybt[y * 4 + x]) {\n\t\t\t\t\t\t\t\t\t\t\tcopybt[y * 4 + x] = true;\n\t\t\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\t\t\tans = min(ans, 1+getans(copybt));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[bt.to_ulong()] = ans;\n\t\t}\n\t}\n}\n\nint main() {\n\tmemset(dp, -1, sizeof(dp));\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint h, w; cin >> h >> w;\n\t\tstamps.push_back(make_pair(h, w));\n\t}\n\tfor (int i = 0; i < 4; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tif (st[j] == 'R')puz[i][j] = 0;\n\t\t\telse if (st[j] == 'B')puz[i][j] = 1;\n\t\t\telse puz[i][j] = 2;\n\t\t}\n\t}\n\tint ans = getans(bitset<16>(0));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint N, X[16], Y[16]; string M[4], start[4];\n\n\tconst string color = \"RGB\";\n\n\tcin >> N;\n\n\tfor (int i = 0; i < N; i++) { cin >> X[i] >> Y[i]; }\n\n\tfor (int i = 0; i < 4; i++) { cin >> M[i]; }\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (X[i] > X[j] || (X[i] == X[j] && Y[i] > Y[j]))\n\t\t\t{\n\t\t\t\tswap(X[i], X[j]);\n\t\t\t\tswap(Y[i], Y[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<string> que[4];\n\n\tqueue<int> turn; turn.push(0);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tque[i].push(\"WWWW\");\n\t}\n\n\twhile (!que[0].empty())\n\t{\n\t\tstring S[4]; int turn1 = turn.front(); turn.pop();\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tS[i] = que[i].front(); que[i].pop();\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < 3; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring S2[4];\n\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tS2[m] = S[m];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int m = i; m < min(i + Y[k], 4); m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int n = j; n < min(j + X[k], 4); n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tS2[m][n] = color[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool ok = true;\n\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (S2[m] != M[m])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ok == true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout << turn1 + 1 << endl; goto Exit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tque[m].push(S2[m]);\n\n\t\t\t\t\t\t\tturn.push(turn1 + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nbool dp[1<<16];\nint n,a1,a2;\nvector<P>v;\nvector<PP>G;\nstring s[4],t[4],tmp[4];\nstring ccol=\"RGB\";\nint main(){\n  int a[4][4];\n  r(i,4)r(j,4)a[i][j]=(i*4+j);\n  cin>>n;\n  r(i,n){\n    cin>>a1>>a2;\n    v.push_back(P(a1,a2));\n  }\n  r(i,4)cin>>s[i],t[i]=s[i];\n  dp[0]=1;\n  queue<P>q;\n  q.push(P(0,0));\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y++){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x++){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  r(i,4)r(j,4)r(k,n){\n    P m1=P(4,4),m2=P(0,0);\n    for(int y=i,c1=0;c1<v[k].first;c1++,y--){\n      for(int x=j,c2=0;c2<v[k].second;c2++,x--){\n        if(0<=y&&y<4&&0<=x&&x<4){\n          m1=min(m1,P(y,x));\n          m2=max(m2,P(y,x));\n        }\n      }\n    }\n    G.push_back(PP(m1,m2));\n  }\n  sort(G.begin(),G.end());int rs=0;\n  G.erase(unique(G.begin(),G.end()),G.end());\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int xx=p.first;//if(p.second==15)return 0;\n    if(xx==(1<<16)-1){\n      cout<<p.second<<endl;\n      return 0;\n    }\n    r(i,4)r(j,4){\n      if((xx>>(i*4+j))&1)t[i][j]=s[i][j];\n      else t[i][j]='W';\n    }\n    r(k,G.size()){\n      int sy=G[k].first.first;\n      int sx=G[k].first.second;\n      int gy=G[k].second.first;\n      int gx=G[k].second.second;\n      for(int col=0;col<3;col++){\n        r(kk,4)tmp[kk]=t[kk];\n        int f=0;\n        for(int i=sy;i<=gy;i++){\n          for(int j=sx;j<=gx;j++){\n            if(tmp[i][j]==s[i][j]&&s[i][j]!=ccol[col])f++;\n            tmp[i][j]=ccol[col];\n          }\n        }if(f)continue;\n        int tp=0;\n        r(i,4)r(j,4)if(s[i][j]==tmp[i][j])tp+=(1<<a[i][j]);\n        if(!dp[tp]){rs++;\n          dp[tp]=1;\n          q.push(P(tp,p.second+1));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst int all=(1<<16)-1;\nint n,h[20],w[20];\nint memo[1<<16];\nchar board[4][4];\nchar cur[10][10];\n\nint rec(int mask){\n\tif(mask==all) return 0;\n\tint &ret=memo[mask];\n\tif(ret!=-1) return ret;\n\n\tret=1010;\n\t\n\trep(idx,n){\n\t\trep(si,10)rep(sj,10){\n\t\t\tconst int ti=si+h[idx],tj=sj+w[idx];\n\t\t\tif(ti<=3||7<=si) continue;\n\t\t\tif(tj<=3||7<=sj) continue;\n\n\t\t\tset<char> s;\n            rep(a,h[idx])rep(b,w[idx]){\n                if(cur[si+a][sj+b]=='*') continue;\n                s.insert(cur[si+a][sj+b]);\n            }\n            if(s.size()!=1) continue;\n \n            int nmask=mask;\n            rep(a,h[idx])rep(b,w[idx]){\n                const int ca=si+a,cb=sj+b;\n                if(ca<3||7<=ca) continue;\n                if(cb<3||7<=cb) continue;\n                nmask|=bit(4*(ca-3)+(cb-3));\n            }\n\n            if(nmask>mask){\n            \tif(memo[nmask]!=-1){\n            \t\tchmin(ret,rec(nmask)+1);\n            \t}else{\n        \t\t\tconst int change=nmask^mask;\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]='*';\n\t            \tchmin(ret,rec(nmask)+1);\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]=board[i][j];\n            \t}\n            }\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\n\trep(i,4) rep(j,4) cin >> board[i][j];\n\trep(i,10)rep(j,10) cur[i][j]='*';\n\trep(i,4)rep(j,4) cur[i+3][j+3]=board[i][j];\n\tclr(memo,-1);\n\tcout << rec(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n#include<iomanip>\n#include<vector>\n#include<deque>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_LEN 16\n#define MAX_STATE (1<<16)\n\nusing namespace std;\ntypedef pair<int,int> ii;\n\nconst int DIFF = 3;\nint N,H[MAX_LEN],W[MAX_LEN];\nint bitmask[MAX_LEN][12][12][3][2]; // bitmask[][][][i] i = false -> erase , true -> insert\nbool mincost[MAX_STATE];\nchar G[4][4];\nchar color[] = {'R','G','B'};\n\ninline void makeBitMask(){\n  REP(y,-3,8){\n    REP(x,-3,8){\n      rep(stamp,N){\n\trep(c,3){\n\t  rep(cy,H[stamp]){\n\t    rep(cx,W[stamp]){\n\t      int nx = x + cx;\n\t      int ny = y + cy;\n\t      if( !( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 ) )continue;\n\t      if( G[ny][nx] == color[c] )bitmask[stamp][y+DIFF][x+DIFF][c][true]  |= (1<<(nx+(ny*4)));\n\t      else                       bitmask[stamp][y+DIFF][x+DIFF][c][false] |= (1<<(nx+(ny*4)));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nvoid compute(){\n  for(bool& i : mincost)i = false;\n  mincost[0] = true;\n  deque<ii> deq;\n  deq.push_back(ii(0,0));\n  while(!deq.empty()){\n    ii data = deq.front(); deq.pop_front();\n\n    if( data.first == (MAX_STATE-1) ){\n      cout << data.second << endl;\n      break;\n    }\n\n    rep(stamp,N){\n      rep(col,3){\n\tREP(y,-3,8){\n\t  REP(x,-3,8){\n\t    int state = ( data.first | bitmask[stamp][y+DIFF][x+DIFF][col][true] ) & (~bitmask[stamp][y+DIFF][x+DIFF][col][false]);\n\t    if(mincost[state])continue;\n\t    mincost[state] = true;\n\t    deq.push_back(ii(state,data.second+1));\n\t  }\n\t}\n      }\n    }\n\n  }\n}\n\nint main(){\n  cin >> N;\n  rep(i,N)cin >> H[i] >> W[i];\n  rep(y,4)rep(x,4)cin >> G[y][x];\n\n  makeBitMask();\n\n  compute();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nchar stage[4][4];\nbool has_stamp[5][5];\nbool left_right_stamp[5][5];\nbool top_bottom_stamp[5][5];\nbool corner_stamp[5][5];\n\nmap<ll,int> dp;\nll compute_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0; //stage[y][x] eq '.'\n      if(stage[y][x] == 'R') type = 1;\n      if(stage[y][x] == 'G') type = 2;\n      if(stage[y][x] == 'B') type = 3;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n  return res;\n}\n\nvoid hash2stage(ll hash){\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = hash % 4LL;\n      if(type == 0) stage[y][x] = '.';\n      if(type == 1) stage[y][x] = 'R';\n      if(type == 2) stage[y][x] = 'G';\n      if(type == 3) stage[y][x] = 'B';\n      hash /= 4LL;\n    }\n  }\n}\n\nll compute_clear_hash(){\n  ll res = 0;\n  ll base = 1;\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      ll type = 0;\n      res += type * base;\n      base *= 4LL;\n    }\n  }\n\n  return res;\n}\n\nvoid print_stage(){\n  for(int y = 0; y < 4; y++){\n    for(int x = 0; x < 4; x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nbool is_clear(ll hash){\n  return (hash == 0);\n}\n\nbool can_erase(int ly,int lx,int ry,int rx){\n  int freq[256] = {};\n  int colors = 0;\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      if(stage[y][x] != '.' && \n         freq[stage[y][x]]++ == 0) colors++;\n      if(colors >= 2) return false;\n    }\n  }\n  return true;\n}\n\nvoid erase(int ly,int lx,int ry,int rx){\n  for(int y = ly; y <= ry; y++){\n    for(int x = lx; x <= rx; x++){\n      stage[y][x] = '.';\n    }\n  }\n}\n\n\nclass State {\npublic:\n  ll _hash;\n  int _cost;\n  \n  State(ll hash,int cost) : _hash(hash), _cost(cost) {}\n  bool operator<(const State& s) const {\n    return _cost < s._cost;\n  }\n  bool operator>(const State& s) const {\n    return _cost > s._cost;\n  }\n};\n\nint bfs(){\n\n  priority_queue<State,vector<State>, greater<State> > que;\n  ll init = compute_hash();\n  ll goal = compute_clear_hash();\n  que.push(State(init,0));\n  dp[init] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s._hash == goal) return s._cost;\n    hash2stage(s._hash);\n\n    for(int ly=0;ly<4;ly++){\n      for(int lx=0;lx<4;lx++){\n        for(int ry=ly;ry<4;ry++){\n          for(int rx=lx;rx<4;rx++){\n            //corner\n            if((lx == 0 && ly == 0)\n               || (lx == 0 && ly == 3)\n               || (lx == 3 && ly == 0)\n               || (lx == 3 && ly == 3)\n               || (rx == 0 && ry == 0)\n               || (rx == 0 && ry == 3)\n               || (rx == 3 && ry == 3)\n               || (rx == 3 && ry == 0)){\n              if(corner_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //left or right\n            if(lx == 0 || rx == 3){\n              if(left_right_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n\n                  dp[next] = s._cost + 1;\n\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //top or bottom\n            if(ly == 0 || ry == 3){\n              if(top_bottom_stamp[ry - ly + 1][rx - lx + 1]){\n                if(can_erase(ly,lx,ry,rx)){\n                  char tmp[4][4];\n                  memcpy(tmp,stage,sizeof(char)*4*4);\n                  erase(ly,lx,ry,rx);\n                  ll next = compute_hash();\n                  if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                    memcpy(stage,tmp,sizeof(char)*4*4);\n                    continue;\n                  }\n                  dp[next] = s._cost + 1;\n                  que.push(State(next,s._cost + 1));\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                }\n              }\n            }\n            \n            //center\n            if(has_stamp[ry - ly + 1][rx - lx + 1]){\n              if(can_erase(ly,lx,ry,rx)){\n                char tmp[4][4];\n                memcpy(tmp,stage,sizeof(char)*4*4);\n                erase(ly,lx,ry,rx);\n                ll next = compute_hash();\n                if(dp.find(next) != dp.end() && dp[next] <= s._cost + 1){\n                  memcpy(stage,tmp,sizeof(char)*4*4);\n                  continue;\n                }\n                dp[next] = s._cost + 1;\n                \n                que.push(State(next,s._cost + 1));\n                memcpy(stage,tmp,sizeof(char)*4*4);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return INF;\n}\n\nint main(){\n  int num_of_stamps;\n  while(~scanf(\"%d\",&num_of_stamps)){\n    memset(has_stamp,false,sizeof(has_stamp));\n    memset(top_bottom_stamp,false,sizeof(top_bottom_stamp));\n    memset(left_right_stamp,false,sizeof(left_right_stamp));\n    memset(corner_stamp,false,sizeof(corner_stamp));\n    dp.clear();\n\n    for(int stamp_i = 0; stamp_i < num_of_stamps; stamp_i++){\n      int H,W;\n      scanf(\"%d %d\",&H,&W);\n      has_stamp[H][W] = true;\n      for(int h = H; h >= 1; h--){\n        for(int w = W; w >= 1; w--){\n          corner_stamp[h][w] = true;\n        }\n      }\n    }\n\n    for(int h = 4; h >= 1; h--){\n      bool flag = false;\n      for(int w = 4; w >= 1; w--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) left_right_stamp[h][w] = true;\n      }\n    }\n\n    for(int w = 4; w >= 1; w--){\n      bool flag = false;\n      for(int h = 4; h >= 1; h--){\n        if(has_stamp[h][w]) flag = true;\n        if(flag) top_bottom_stamp[h][w] = true;\n      }\n    }\n    \n    for(int y = 0; y < 4; y++){\n      char line[8];\n      scanf(\"%s\",line);\n      for(int x = 0; x < 4; x++){\n        stage[y][x] = line[x];\n      }\n    }\n\n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nunsigned dist[1<<16];\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> pt;\n\tmemset(dist,-1,sizeof(dist));\n\tfor(int k=0;k<n;k++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tfor(int i=-h+1;i<4;i++){\n\t\t\tfor(int j=-w+1;j<4;j++){\n\t\t\t\tint u=0;\n\t\t\t\tfor(int p=0;p<4;p++){\n\t\t\t\t\tif(i<=p&&p<i+h){\n\t\t\t\t\t\tfor(int q=0;q<4;q++){\n\t\t\t\t\t\t\tif(j<=q&&q<j+w){\n\t\t\t\t\t\t\t\tu|=1<<(4*p+q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpt.push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tsort(pt.begin(),pt.end());\n\tpt.resize(unique(pt.begin(),pt.end())-pt.begin());\n\tint col[3]={0};\n\tfor(int i=0;i<4;i++){\n\t\tchar buf[5];\n\t\tcin >> buf;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint u=1<<(4*i+j);\n\t\t\tswitch(buf[j]){\n\t\t\t\tcase 'R':col[0]|=u;break;\n\t\t\t\tcase 'G':col[1]|=u;break;\n\t\t\t\tcase 'B':col[1]|=u;break;\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> mask;\n\tfor(int u:pt){\n\t\tfor(int c:col){\n\t\t\tif(u&c){\n\t\t\t\tmask.push_back(P(u&c,~u));\n\t\t\t}\n\t\t}\n\t}\n\tdist[0]=0;\n\tqueue<int> q;\n\tq.push(0);\n\twhile(q.size()){\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(auto m:mask){\n\t\t\tint v=(u&m.second)|m.first;\n\t\t\tif(dist[u]+1<dist[v]){\n\t\t\t\tdist[v]=dist[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[(1<<16)-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint n,H,W;\nint memo[65536];\nint visi[65536];\nvector<int> mask1,mask2;\n\nvector< vector<char> > goal(4,vector<char>(4));\n\nint w[20],h[20];\n\nint gen(int s,int x,int y){\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask1.push_back(a);\n\t\tmask2.push_back(b);\n\t}\n}\nint f(int init){\n\tqueue<int> Q;\n\tQ.push(init);\n\tmemo[init] = 0;\n\tint good = (1<<16)-1;\n\twhile(Q.size()){\n\t\tint q = Q.front(); Q.pop();\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,mask1.size()){\n\t\t\tint bit = (q & ~mask1[i]) | mask2[i];\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ.push(bit);\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\trep(i,4)rep(j,4){\n\t\tchar c;cin >> c;\n\t\tif(c=='R')c = 0;\n\t\tif(c=='G')c = 1;\n\t\tif(c=='B')c = 2;\n\t\tgoal[i][j] = c;\n\t}\n\t\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\n\t\n\tcout << f(0) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  cin>>n;\n  int h[n],w[n];\n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  string s[4];\n  for(int i=0;i<4;i++) cin>>s[i];\n  char c[4]=\"RGB\";\n  int dp[1<<16];\n  memset(dp,-1,sizeof(dp));\n  bool used[1<<16];\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    int bit=q.front().first,d=q.front().second;\n    q.pop();\n    if(~dp[bit]) continue;\n    dp[bit]=d;\n    for(int i=0;i<n;i++){\n      for(int j=-3;j<4;j++){\n\tfor(int k=-3;k<4;k++){\n\t  for(int l=0;l<3;l++){\n\t    int z=bit;\n\t    for(int a=0;a<h[i];a++){\n\t      for(int b=0;b<w[i];b++){\n\t\tint y=j+a,x=k+b;\n\t\tif(y<0||y>=4||x<0||x>=4) continue;\n\t\tif(s[y][x]==c[l]) z|=1<<(y*4+x);\n\t\telse z&=(1<<16)-(1<<(y*4+x))-1;\n\t      }\n\t    }\n\t    if(dp[z]<0&&!used[z]) q.push(P(z,d+1)),used[z]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[(1<<16)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a, b; vector<int> x, y; string tmp;\n\nmap<unsigned, bool> D;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a); y.push_back(a);\n\t\tscanf(\"%d\", &b); x.push_back(b);\n\t}\n\n\tunsigned finish = 0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tswitch (tmp[j])\n\t\t\t{\n\t\t\tcase 'R': finish += (1 << (i * 8 + j * 2)) * 1; break;\n\t\t\tcase 'G': finish += (1 << (i * 8 + j * 2)) * 2; break;\n\t\t\tcase 'B': finish += (1 << (i * 8 + j * 2)) * 3; break;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pair<unsigned, int> > que;\n\n\tque.push(make_pair(0, 0)); D[0] = true;\n\n\twhile (true)\n\t{\n\t\tunsigned M1 = que.front().first; int dist = que.front().second; que.pop();\n\n\t\tif (finish == M1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", dist); break;\n\t\t}\n\n\t\tint count_ = 0;\n\n\t\tfor (int i = 0; i < 32; i += 2)\n\t\t{\n\t\t\tint bit1 = finish / (1 << i) % 4;\n\t\t\tint bit2 = M1 / (1 << i) % 4;\n\n\t\t\tif (bit1 == bit2) count_++;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 1; c < 4; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned M2 = M1;\n\n\t\t\t\t\t\tfor (int l = j; l < j + y[i]; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == 4) break;\n\n\t\t\t\t\t\t\tfor (int m = k; m < k + x[i]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (m == 4) break;\n\n\t\t\t\t\t\t\t\tint bit = 1 << (l * 8 + m * 2);\n\n\t\t\t\t\t\t\t\tM2 -= M2 / bit % 4;\n\t\t\t\t\t\t\t\tM2 += bit * c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint count2 = 0;\n\n\t\t\t\t\t\tfor (int l = 0; l < 32; l += 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint bit1 = finish / (1 << i) % 4;\n\t\t\t\t\t\t\tint bit2 = M2 / (1 << i) % 4;\n\n\t\t\t\t\t\t\tif (bit1 == bit2) count2++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!D[M2] && count_ >= count2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[M2] = true;\n\n\t\t\t\t\t\t\tque.push(make_pair(M2, dist + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, h[N], w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tint ny=y-i+k;\n\t\n\tif(ny<0||M<=ny) continue;\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int nx=x-j+l;\n\t  \n\t  if(nx<0||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    for(int idx=0;idx<N;idx++){\n      \n      if(S&(1<<idx)) continue;\n      \n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nint N;\nint H[16], W[16];\nstring C[4];\n\nstring color = \"RGB\";\n\nint solve()\n{\n\tqueue<pair<int, int> > que;\n\n\tque.push(make_pair(0, 0));\n\t\n\tbool done[1 << 16];\n\trep(i, 0, 1 << 16) done[i] = false;\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.front(); que.pop();\n\n\t\tint state = q.first;\n\t\tint turn = q.second;\n\n\t\t/* printf(\"[%d]\\n\", turn);\n\t\trep(y, 0, 4)\n\t\t{\n\t\t\trep(x, 0, 4)\n\t\t\t{\n\t\t\t\tint i = (state >> (15 - (y * 4 + x))) & 0x01;\n\t\t\t\tcout << i;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t//*/\n\t\tif (state == (1 << 16) - 1) return turn;\n\n\t\tif (done[state]) continue;\n\t\tdone[state] = true;\n\n\t\trep(i, 0, N) rep(j, 0, 3)\n\t\t{\n\t\t\trep(sy, -(H[i] - 1), 4) rep(sx, -(W[i] - 1), 4)\n\t\t\t{\n\t\t\t\tint tx = sx + W[i] - 1;\n\t\t\t\tint ty = sy + H[i] - 1;\n\n\t\t\t\tint nstate = 0;\n\t\t\t\trep(y, 0, 4) rep(x, 0, 4)\n\t\t\t\t{\n\t\t\t\t\tint f = 0;\n\n\t\t\t\t\tif ((sx <= x && x <= tx) && (sy <= y && y <= ty))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (C[y][x] == color[j])\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tf = (state >> (15 - (y * 4 + x))) & 0x01;\n\t\t\t\t\t}\n\n\t\t\t\t\tnstate = (nstate << 1) + f;\n\t\t\t\t}\n\n\t\t\t\tif (!done[nstate]) que.push(make_pair(nstate, turn + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N)\n\t{\n\t\trep(i, 0, N) cin >> H[i] >> W[i];\n\t\trep(i, 0, 4) cin >> C[i];\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nll n;\nvector<pll> stp;\nvector<vector<char>> A(4,vector<char>(4));\n\nbool same(ll a,ll h,ll w,ll num){\n    char c=0;\n    for(ll i=max(h,0LL);i<4 && i-h<stp[num].F;i++){\n        for(ll t=max(w,0LL);t<4 && t-w<stp[num].S;t++){\n            if(a>>(i*4+t)&1){continue;}\n            if(c==0){\n                c=A[i][t];\n            }\n            else if(c!=A[i][t]){return false;}\n        }\n    }\n    return true;\n}\n\nll put(ll a,ll h,ll w,ll num){\n    for(ll i=max(h,0LL);i<4 && i-h<stp[num].F;i++){\n        for(ll t=max(w,0LL);t<4 && t-w<stp[num].S;t++){\n            a|=1LL<<(i*4+t);\n        }\n    }\n    return a;\n}\n\n\nint main(){\n    cin>>n;\n    stp.resize(n);\n    for(auto &i:stp){cin>>i.F>>i.S;}\n    for(auto &i:A){\n        for(auto &t:i){cin>>t;}\n    }\n    vector<ll> dp(1LL<<16,E);\n    queue<ll> Q;\n    dp[0]=0;\n    Q.push(0);\n    while(!Q.empty()){\n        ll W=Q.front();\n        Q.pop();\n        for(int i=0;i<n;i++){\n            for(int h=-3;h<4;h++){\n                for(int w=-3;w<4;w++){\n                    ll next=put(W,h,w,i);\n                    if(dp[next]==E && same(W,h,w,i)){\n                        if(next==(1LL<<16)-1){cout<<dp[W]+1<<endl; return 0;}\n                        dp[next]=dp[W]+1;\n                        Q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 4;\nbool canp[N][N][N+1][N+1];\n\nint main(void){\n    int n; cin >> n;\n    vi hs(n), ws(n);\n    rep(i, n) cin >> hs[i] >> ws[i];\n\n    vector<string> field(N);\n    for(auto & e : field) cin >> e;\n\n    rep(i, n){\n        int h = hs[i], w = ws[i];\n\n        rep(y, N){\n            rep(x, N){\n                canp[y][x][min(h, N - y)][min(w, N - x)] = true;\n\n                int lh = h;\n                if(y == 0) lh = 1;\n\n                int lw = w;\n                if(x == 0) lw = 1;\n\n                rep(hh, lh, h + 1){\n                    rep(ww, lw, w + 1){\n                        canp[y][x][hh][ww] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    queue<int> q;\n    q.push(0);\n    vi min_dist(1 << (N * N), inf);\n    min_dist[0] = 0;\n\n    string colors = {'R', 'G', 'B'};\n    while(q.size()){\n        int state = q.front(); q.pop();\n\n        rep(y, N){\n            rep(x, N){\n                rep(h, 1, N - y + 1){\n                    rep(w, 1, N - x + 1){\n                        if(not canp[y][x][h][w]) continue;\n\n                        for(auto & c : colors){\n                            int nstate = state;\n                            rep(yy, y, y + h){\n                                rep(xx, x, x + w){\n                                    if(field[yy][xx] == c){\n                                        nstate |= (1 << (yy * 4 + xx));\n                                    }\n                                    else {\n                                        nstate &= ~(1 << (yy * 4 + xx));\n                                    }\n                                }\n                            }\n                            if(chmin(min_dist[nstate], min_dist[state] + 1)){\n                                if(nstate == (1 << (N * N)) - 1){\n                                    cout << min_dist[nstate] << endl;\n                                    return 0;\n                                }\n                                q.push(nstate);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\nconst string Z = \"RGB\";\n\nstruct state { ll s, d; };\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> H(N), W(N);\n  REP(i, 0, N) cin >> H[i] >> W[i];\n  char S[4][4];\n  REP(i, 0, 4) REP(j, 0, 4) cin >> S[i][j];\n\n  vector<ll> dp(1LL << 16, -1);\n  queue<state> q;\n  q.push((state) { 0, 0 });\n  while(q.size()) {\n    ll s = q.front().s, d = q.front().d;\n    q.pop();\n\n    if(dp[s] >= 0) continue;\n    dp[s] = d;\n\n    if(s == (1LL << 16) - 1) break;\n\n    REP(i, 0, N) {\n      REP(py, -H[i] + 1, 4) REP(px, -W[i] + 1, 4) REP(c, 0, 3) {\n        ll n = s;\n        REP(y, py, py + H[i]) REP(x, px, px + W[i]) {\n          if(0 <= y && y < 4 && 0 <= x && x < 4) {\n            if(S[y][x] == Z[c]) n = n | (1LL << (y * 4 + x));\n            else n = ~(~n | (1LL << (y * 4 + x)));\n          }\n        }\n        if(dp[n] == -1) q.push((state) { n, d + 1 });\n      }\n    }\n  }\n  cout << dp[(1LL << 16) - 1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nint h[10],w[10];\nchar t[16];\nvector<P> G;\nmap<P,bool> used;\nstring str=\"RGB\";\n\nint d[(1<<16)];\n\nint solve(){\n  queue<int> Q;\n  for(int i=0;i<(1<<16);i++)d[i]=-1;\n  d[0]=0;\n  Q.push(0);\n  \n  while(!Q.empty()){\n    int S=Q.front();Q.pop();\n    if(S==(1<<16)-1)return d[S];\n    \n    for(int i=0;i<(int)G.size();i++){\n      int ay=G[i].first/5;\n      int ax=G[i].first%5;\n      int by=G[i].second/5;\n      int bx=G[i].second%5;  \n      for(int j=0;j<3;j++){\n        char ch=str[j];\n        int next=S;\n        for(int y=ay;y<by;y++){\n          for(int x=ax;x<bx;x++){\n            int z=y*4+x;\n            next|=(1<<z);\n            if(t[z]!=ch)next-=(1<<z);\n          }\n        }\n        if(d[next]==-1){\n          d[next]=d[S]+1;\n          Q.push(next);\n        }\n      }\n    }\n\n  }\n  return -1;\n}\n\nvoid add(int h,int w){\n  P p;\n  for(int i=-h+1;i<4;i++){\n    for(int j=-w+1;j<4;j++){\n      int ay=max(i,0);\n      int ax=max(j,0);\n      int by=min(i+h,4);\n      int bx=min(j+w,4);\n      p.first=ay*5+ax;\n      p.second=by*5+bx;\n      if(used[p])continue;\n      used[p]=true;\n      G.push_back(p);\n    }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h[i]>>w[i];\n    add(h[i],w[i]);\n  }\n\n  for(int i=0;i<16;i++)cin>>t[i];\n  \n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nint n, h, w;\n\nint main()\n{\n\tcin >> n;\n\tvector<pii> v;\n\tREP(i, n)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\tv.emplace_back(a, b);\n\t}\n\tint fld[4][4];\n\tREP(i, 4)REP(j, 4)\n\t{\n\t\tchar c; cin >> c;\n\t\tif (c == 'R') fld[i][j] = 0;\n\t\telse if (c == 'G') fld[i][j] = 1;\n\t\telse fld[i][j] = 2;\n\t}\n\tvi d(1 << 16, INF);\n\td[0] = 0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint t = que.front(); que.pop();\n\t\tif (t == (1 << 16) - 1)\n\t\t{\n\t\t\tcout << d[t] << endl;\n\t\t\tbreak;\n\t\t}\n\t\tREP(i, n)REP(j, 3)\n\t\t{\n\t\t\tint h = v[i].first, w = v[i].second;\n\t\t\tFOR(u, 1 - h, 4)FOR(l, 1 - w, 4)\n\t\t\t{\n\t\t\t\tint tmp = t;\n\t\t\t\tFOR(x, max(0, u), min(4, u + h))FOR(y, max(0, l), min(4, l + w ))\n\t\t\t\t{\n\t\t\t\t\tif (fld[x][y] == j)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp |= (1 << (x * 4 + y));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((tmp >> (x * 4 + y)) & 1) tmp ^= (1 << (x * 4 + y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d[tmp] == INF)\n\t\t\t\t{\n\t\t\t\t\td[tmp] = d[t] + 1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, bd[1<<16];\nint H[16], W[16];\nVS orig(4);\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i,N) cin >> H[i] >> W[i];\n  REP(i,4) cin >> orig[i];\n\n  priority_queue<PII, vector<PII>, greater<PII>> pq;\n  fill(bd, bd+(1<<16), 1000);\n  bd[0] = 0;\n  pq.push(MP(0,0));\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint ct = pii.first;\n\tint state = pii.second;\n\tif(ct > bd[state]) continue;\n\n\tREP(i,N){\n\t  for(int y=-H[i]+1;y<4;++y){\n\t\tfor(int x=-W[i]+1;x<4;++x){\n\t\t  for(int k=0;k<3;++k){\n\t\t\tchar c = \"RGB\"[k];\n\t\t\tint tmp = state;\n\t\t\tfor(int dy=0;dy<H[i];++dy){\n\t\t\t  int ty = y + dy;\n\t\t\t  if(ty < 0 || 4 <= ty) continue;\n\t\t\t  for(int dx=0;dx<W[i];++dx){\n\t\t\t\tint tx = x + dx;\n\t\t\t\tif(tx < 0 || 4 <= tx) continue;\n\t\t\t\t//\t\t\t  if(c == ' ') c = orig[ty][tx];\n\t\t\t\tif(c == orig[ty][tx])\n\t\t\t\t  tmp = tmp | (1 << (ty*4+tx));\n\t\t\t  else\n\t\t\t\ttmp = tmp & ~(1 << (ty*4+tx));\n\t\t\t  }\n\t\t\t}\n\t\t\tif(bd[tmp] > ct+1){\n\t\t\t  bd[tmp] = ct + 1;\n\t\t\t  pq.push(MP(bd[tmp], tmp));\n\t\t\t}\n\t\t  }\n\t\t}\n\t  }\n\t}\n  }\n  \n\n  cout << bd[(1<<16)-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nstruct P {\n    int cost;\n    uint16_t bit;\n};\n\nchar colorchar[] = {'R', 'G', 'B'};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pii> stamp(N);\n    REP(i, N) {\n        cin >> stamp[i].second >> stamp[i].first;\n    }\n    vvc field(4, vc(4));\n    REP(y, 4) REP(x, 4) {\n        cin >> field[y][x];\n    }\n\n    set<uint16_t> G;\n\n    queue<P> que;\n    que.push({0, 0});\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        if (p.bit == (1<<16)-1) {\n            cout << p.cost << endl;\n            break;\n        }\n        REP(i, N) {\n            FOR(ly, -stamp[i].second+1, 4) FOR(lx, -stamp[i].first+1, 4) {\n                int rx = lx + stamp[i].first, ry = ly + stamp[i].second;\n                REP(j, 3) {\n                    uint16_t bit = p.bit;\n                    FOR(sy, ly, ry) FOR(sx, lx, rx) {\n                        if (0 <= sx && sx < 4 && 0 <= sy && sy < 4) {\n                            int k = 4*sy+sx;\n                            if (field[sy][sx] == colorchar[j]) {\n                                bit |= 1<<k;\n                            } else {\n                                bit &= ~(1<<k);\n                            }\n                        }\n                    }\n                    if (!EXIST(G, bit)) {\n                        G.insert(bit);\n                        que.push({p.cost+1, bit});\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\n#define M 4\nusing namespace std;\n\nint n,h[N],w[N];\nstring s[M];\n\nbool dp[N+1][(1<<N)];\n\nvoid mark(int cnt,int S,int idx,int stamp){\n  \n  int y=idx/M,x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S,f=0;\n      \n      for(int k=0;k<h[stamp];k++){\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k,nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(S&(1<<p)) f=1;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<nS)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(!f) dp[cnt+1][nS]=true;\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n\n  dp[0][0]=true;\n\n  int ans=N;\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<(1<<N);j++){\n      \n      if(!dp[i][j]) continue;\n      \n      if(j==(1<<N)-1){\n\tans=i;\n\tbreak;\n      }\n      \n      for(int y=0;y<M;y++){\n\tfor(int x=0;x<M;x++){\n\t  \n\t  int idx=y*M+x;\n\t  \n\t  if(j&(1<<idx)) continue;\n\t  \n\t  for(int k=0;k<n;k++) mark(i,j,idx,k);\n\t  \n\t}\n      }\n      \n      \n    }\n    \n    if(ans!=N)break;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define M 4\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,h[N],w[N];\n\nstring s[M];\n\nint d[(1<<N)];\n\nqueue<P> q;\n\nvoid mark(int cost,int S,int idx,int stamp){\n  \n  int y=idx/M, x=idx%M;\n  \n  for(int i=0;i<h[stamp];i++){\n    \n    for(int j=0;j<w[stamp];j++){\n      \n      int nS=S;\n      \n      for(int k=0;k<h[stamp];k++){\n\t\n\tfor(int l=0;l<w[stamp];l++){\n\t  \n\t  int ny=y-i+k, nx=x-j+l;\n\t  \n\t  if(ny<0||nx<0||M<=ny||M<=nx) continue;\n\t  \n\t  int p=ny*M+nx;\n\t  \n\t  if(s[ny][nx]==s[y][x]) nS|=(1<<p);\n\t  else if(nS&(1<<p)) nS=nS&~(1<<p);\n\t  \n\t}\n      }\n      \n      if(d[nS]>cost+1){\n\td[nS]=cost+1;\n\tq.push(P(cost+1,nS));\n      }\n      \n    }\n    \n  }\n  \n}\n\nint bfs(){\n  \n  for(int i=0;i<(1<<N);i++) d[i]=INF;\n  \n  d[0]=0;\n  \n  q.push(P(0,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    int cost=t.first, S=t.second;\n    \n    if(S==(1<<N)-1) return cost;\n    \n    \t\n    for(int idx=0;idx<N;idx++){\n\t\n      if(S&(1<<idx)) continue;\n\t\n      for(int k=0;k<n;k++) mark(cost,S,idx,k);\n      \n    }\n\n    \n  }\n\n  return 0;\n}\n\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n  \n  for(int i=0;i<M;i++) cin>>s[i];\n  \n  cout<<bfs()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str,ABC=\"ABC\"; \n\nbool ans=0;\nbool check(string &a,int i){\n  if(i+3>str.size()) return 0;\n  return a[i]=='A'&&a[i+1]=='B'&&a[i+2]=='C';\n}\n\nvoid dfs(string sta){\n  if(sta==ABC)ans=1;\n  if(ans||sta.size()<=3)return;\n  \n  for(int i=0;i<3;i++){\n    string nx=\"\";\n    int j=0;\n    while(j<(int)sta.size())\n      if(check(sta,j))nx+=('A'+i),j+=3;\n      else nx+=sta[j++];\n    if(nx.size()==sta.size())break;\n    dfs(nx);\n  }\n}\n\nint main(){\n  cin>>str;\n  dfs(str);\n  cout<<(ans? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n;\nint h[16], w[16];\nint c[4][4];\nint dp[1 << 16];\n\nbool valid(int i, int j, int k, int state){\n    vi cnt(3);\n    rep2(ii, max(0, i - h[k] + 1), min(i + 1, 4)) {\n        rep2(jj, max(0, j - w[k] + 1), min(j + 1, 4)) {\n            if ((state >> (4*ii+jj)) & 1) cnt[c[ii][jj]]++;\n        }\n    }\n    int cnt_positive = (int)(cnt[0] > 0) + (int)(cnt[1] > 0) + (int)(cnt[2] > 0);\n    return cnt_positive == 1;\n}\n\nint stamp(int i, int j, int k, int state) {\n    rep2(ii, max(0, i - h[k] + 1), min(i + 1, 4)) {\n        rep2(jj, max(0, j - w[k] + 1), min(j + 1, 4)) {\n            state = (state & ((1 << 16) - 1 - (1 << (4*ii+jj))));\n        }\n    }\n    return state;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n;\n    rep(i, n) cin >> h[i] >> w[i];\n    rep(i, 4) rep(j, 4) {\n        char x;\n        cin >> x;\n        if (x == 'R') c[i][j] = 0;\n        if (x == 'G') c[i][j] = 1;\n        if (x == 'B') c[i][j] = 2;\n    }\n\n    fill(dp, dp + (1 << 16), inf);\n    queue<int> que;\n    int s = (1 << 16) - 1;\n    que.emplace(s);\n    dp[s] = 0;\n    while (!que.empty()) {\n        int state = que.front(); que.pop();\n        rep(k, n) {\n            rep(i, 7) {\n                rep(j, 7) {\n                    if (valid(i, j, k, state)) {\n                        int nstate = stamp(i, j, k, state);\n                        if (nstate == 0) {\n                            cout << dp[state] + 1 << endl;\n                            return 0;\n                        }\n                        if (dp[nstate] == inf) {\n                            dp[nstate] = dp[state] + 1;\n                            que.push(nstate);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\n\nconst int V = 1 << 16;\nvector<int> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tif(dist[G[u][i]] < inf) continue;\n\t\t\tdist[G[u][i]] = dist[u] + 1;\n\t\t\tQ.push(G[u][i]);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\t\n\t\t\tfor(int x = 0; x < 5 - W[j]; x++){\n\t\t\t\tfor(int y = 0; y < 5 - H[j]; y++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int dx = x; dx < x+W[j]; dx++){\n\t\t\t\t\t\t\tfor(int dy = y; dy < y+H[j]; dy++){\n\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\tG[i].push_back(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar Color[3] = {'R', 'G', 'B'};\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> h(n);\n    vector<int> w(n);\n    for(int i = 0; i < n; i++) cin >> h[i] >> w[i];\n    string C;\n    for(int i = 0; i < 4; i++){\n        string tmp; cin >> tmp;\n        C = C + tmp;\n    }\n\n    queue<pair<int, int> > que;                  //cost bit(一致していたら1そうでなければ0)\n    \n    vector<bool> used((1 << 16), false);\n    used[0] = true;\n    que.push({0, 0});\n\n    while(!que.empty()){\n\n        int bit = que.front().second;\n        int cost = que.front().first;\n        //cout << cost << \" \" << str << endl;\n        que.pop();\n\n        if(bit == (1 << 16) - 1){\n            cout << cost << endl;\n            break;\n        }\n\n        for(int ii = 0; ii < n; ii++){\n\n            for(char color : Color){\n\n                //cout << i << \" \" << color << endl;\n                for(int si = -3; si <= 3; si++){\n                    for(int sj = -3; sj <= 3; sj++){\n                        int gi = si + h[ii] - 1;\n                        int gj = sj + w[ii] - 1;\n\n                        int next;\n                        next = bit;\n                        //cout << i << \" \" << si << \" \" << gi << \" \" << sj << \" \" << gj << \" \" << endl;\n                        for(int i = si; i <= gi; i++){\n                            for(int j = sj; j <= gj; j++){\n\n                                if(0 <= i && i < 4 && 0 <= j && j < 4){\n                                    int idx = i * 4 + j;\n                                    if(C[idx] == color) next = next | (1 << idx);\n                                    else next = next & ~(1 << idx);\n                                }\n                            }\n                        }\n\n                        if(!used[next]){\n                            //cout << \"ok\" << endl;\n                            used[next] = true;\n                            que.push({cost + 1, next});\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\nstruct data{int y,x;};\nint n;\ndata stmp[16];\nbool can[16][16];\nstring mp[16];\nchar RGB[3]={'R','G','B'};\n\nint Idx(int y,int x){return y*4+x;}\nint getBit(int sta,data a,data b,char ch){\n  int res=0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++){\n      if(a.x<=j&&j<=b.x&&a.y<=i&&i<=b.y)res|=(mp[i][j]==ch)<<Idx(i,j);\n      else res|=(sta&(1<<Idx(i,j)));\n    }\n  return res;\n}\n\n\nint bfs(){\n  vector<int>D(1<<16,INF);\n  queue<int> Q;\n  Q.push(0);\n  D[0]=0;\n  while(!Q.empty()){\n    int bit=Q.front();Q.pop();\n    if(bit==(1<<16)-1)break;\n    for(int i=0;i<3;i++)\n      for(int a=0;a<16;a++)\n\tfor(int b=0;b<16;b++)\n\t  if(can[a][b]){\n\t    data yx=(data){a/4,a%4};\n\t    data YX=(data){b/4,b%4};\n\t    int nbit=getBit(bit,yx,YX,RGB[i]);\n\t    if(D[nbit]==INF)Q.push(nbit),D[nbit]=D[bit]+1;\n\t  }\n  }\n  return D[(1<<16)-1];\n}\n\nvoid mk_can(){\n  for(int i=0;i<n;i++){\n    int w=stmp[i].x,h=stmp[i].y;\n    for(int y=-3;y<4;y++)\n      for(int x=-3;x<4;x++){\n\tint a=max(0,y),b=max(0,x);\n\tint Y=min(3,y+h-1);\n\tint X=min(3,x+w-1);\n\tif(a>Y||b>X)continue;\n\tcan[Idx(a,b)][Idx(Y,X)]=1;\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>stmp[i].y>>stmp[i].x;\n  for(int i=0;i<4;i++)cin>>mp[i];\n  mk_can();\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int> h(n),w(n);\n    vector<vector<int>> c(4,vector<int>(4));\n    rep(i,0,n) cin >> h[i] >> w[i];\n    rep(i,0,4) rep(j,0,4){\n        char tmp;\n        cin >> tmp;\n        if(tmp=='R') c[i][j]=0;\n        if(tmp=='G') c[i][j]=1;\n        if(tmp=='B') c[i][j]=2;\n    }\n\n    auto encode=[](const bitset<16> &bs){\n        int res=0;\n        rep(i,0,16) if(bs[i]) res|=1<<i;\n        return res;\n    };\n\n    bitset<16> filled((1<<16)-1);\n    vector<int> cost(1<<16,inf);\n    queue<bitset<16>> que;\n    cost[0]=0;\n    que.push(bitset<16>(0));\n    while(!que.empty()){\n        auto bs=que.front();\n        que.pop();\n        int state=encode(bs);\n        if(bs==filled){\n            cout << cost[state] << endl;\n            return;\n        }\n        rep(i,0,n) rep(y,-3,4) rep(x,-3,4){\n            int y1=max(0,y),x1=max(0,x),y2=min(4,y+h[i]),x2=min(4,x+w[i]);\n            if(y2<=0 or x2<=0) continue;\n            rep(j,0,3){\n                auto next_bs=bs;\n                rep(y_,y1,y2) rep(x_,x1,x2){\n                    if(c[y_][x_]==j)  next_bs.set(4*y_+x_);\n                    else next_bs.reset(4*y_+x_);\n                }\n                int next_state=encode(next_bs);\n                if(cost[next_state]!=inf) continue;\n                cost[next_state]=cost[state]+1;\n                que.push(next_bs);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst int all=(1<<16)-1;\nint n,h[20],w[20];\nint memo[1<<16];\nchar board[4][4];\nchar cur[10][10];\n\nint rec(int mask){\n\tif(mask==all) return 0;\n\tint &ret=memo[mask];\n\tif(ret!=-1) return ret;\n\n\tret=1010;\n\t\n\trep(idx,n){\n\t\trep(si,10)rep(sj,10){\n\t\t\tconst int ti=si+h[idx],tj=sj+w[idx];\n\t\t\tif(10<ti||10<tj) continue;\n\n\t\t\tset<char> s;\n            rep(a,h[idx])rep(b,w[idx]){\n                if(cur[si+a][sj+b]=='*') continue;\n                s.insert(cur[si+a][sj+b]);\n            }\n            if(s.size()!=1) continue;\n \n            int nmask=mask;\n            rep(a,h[idx])rep(b,w[idx]){\n                const int ca=si+a,cb=sj+b;\n                if(ca<3||7<=ca) continue;\n                if(cb<3||7<=cb) continue;\n                nmask|=bit(4*(ca-3)+(cb-3));\n            }\n\n            if(nmask>mask){\n            \tif(memo[nmask]!=-1){\n            \t\tchmin(ret,rec(nmask)+1);\n            \t}else{\n        \t\t\tconst int change=nmask^mask;\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]='*';\n\t            \tchmin(ret,rec(nmask)+1);\n\t            \trep(i,4)rep(j,4) if(change&bit(4*i+j)) cur[i+3][j+3]=board[i][j];\n            \t}\n            }\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> h[i] >> w[i];\n\n\trep(i,4) rep(j,4) cin >> board[i][j];\n\trep(i,10)rep(j,10) cur[i][j]='*';\n\trep(i,4)rep(j,4) cur[i+3][j+3]=board[i][j];\n\tclr(memo,-1);\n\tcout << rec(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\nconst int INF=100000000;\n\n// eXªwè³ê½FÉÈéÜÅÌÅ¬X^vñ\nint dp[1<<16];\nchar field[5][5];\nvector<pair<int,int> > stumps;\nint n;\nchar color[]={'R','G','B'};\n\nint dfs(int s){\n    if(s==0)\n        return 0;\n    if(dp[s]!=INF)\n        return dp[s];\n    int cnt=INF;\n    // TCYÒÁ½è ¤êðIñÅX^vðßµÄ¢­\n    for(int k = 0; k < stumps.size(); k++){\n        int h=stumps[k].first;\n        int w=stumps[k].second;\n        // ¶ãÌÀWðè\n        for(int i = -h+1; i < 4; i++){\n            for(int j = -w+1; j < 4; j++){\n                int ns=s;\n                bool first=false;\n                bool b=false;\n                char cc=0;\n                // Iñ¾ÍÍªS¯¶FÅ é©Ç¤©ð`FbN·é\n                for(int k = i; k<min(i+h,4); k++){\n                    for(int l = j; l < min(j+w,4); l++){\n                        if(!(k>=0&&l>=0&&k<4&&l<4))\n                            continue;\n                        // hçêÄ¢éêÌÝl¶·é\n                        if((s>>(k*4+l))&1){\n                            if(!first){\n                                cc=field[k][l];\n                                first=true;\n                            }\n                            else{\n                                if(field[k][l]!=cc){\n                                    b=true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(b)\n                        break;\n                }\n                // SðÅ«éê,hèÂÔµððµÄAÄA\n                if(!b&&first){\n                    for(int k = i; k<min(i+h,4); k++){\n                        for(int l = j; l < min(j+w,4); l++){\n                            if(!(k>=0&&l>=0&&k<4&&l<4))\n                                continue;\n                            ns&=~(1<<(k*4+l));\n                        }\n                    }\n                    cnt=min(cnt,dfs(ns)+1);\n                }\n            }\n        }\n    }\n    return dp[s]=cnt;\n}\n\nvoid solve(){\n    fill(dp,dp+(1<<16),INF);\n    cin>>n;\n    int h,w;\n    for(int i = 0; i < n; i++){\n        cin>>h>>w;\n        stumps.push_back(make_pair(h,w));\n    }\n    for(int i = 0; i < 4; i++)\n        for(int j = 0; j < 4; j++)\n            cin>>field[i][j];\n    cout<<dfs((1<<16)-1)<<endl;\n}\nint main(){\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\n\nint N;\nint H[16], W[16];\nint C[4][4];\nbool rect[4][4][4][4];\n\nconst int V = 1 << 16;\nvector<unsigned short> G[V];\nint dist[V];\n\nvoid bfs()\n{\n\tqueue<int> Q;\n\t\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[0] = 0;\n\tQ.push(0);\n\t\n\tint u;\n\twhile(Q.size()){\n\t\tu = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tif(dist[G[u][i]] < inf) continue;\n\t\t\tdist[G[u][i]] = dist[u] + 1;\n\t\t\tQ.push(G[u][i]);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tint h, w;\n\tfor(int i = 0; i < N; i++) cin >> H[i] >> W[i];\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\trect[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < N; j++){\n\t\tfor(int x = 1 - W[j]; x < 4; x++){\n\t\t\tfor(int y = 1 - H[j]; y < 4; y++){\n\t\t\t\trect[max(x, 0)][min(x+W[j],4)-1][max(y, 0)][min(y+H[j],4)-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar c;\n\tfor(int y = 0; y < 4; y++){\n\t\tfor(int x = 0; x < 4; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'R') C[x][y] = 0;\n\t\t\tif(c == 'G') C[x][y] = 1;\n\t\t\tif(c == 'B') C[x][y] = 2;\n\t\t}\n\t}\n\t\n\tint next;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tnext = i;\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tfor(int q = 0; q < 4; q++){\n\t\t\t\t\tfor(int r = 0; r < 4; r++){\n\t\t\t\t\t\tfor(int s = 0; s < 4; s++){\n\t\t\t\t\t\t\tif(!rect[p][q][r][s]) continue;\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tfor(int dx = p; dx <= q; dx++){\n\t\t\t\t\t\t\t\tfor(int dy = r; dy <= s; dy++){\n\t\t\t\t\t\t\t\t\tif(C[dx][dy] == k) next |= (1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t\telse next &= ~(1 << (dy*4+dx));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tG[i].push_back(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\tcout << dist[V-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\nusing pii = pair<int,int>;\n\nint table[4][4];\n\nbool inside(int a, int b){\n\treturn 0<=a&&a<4&&0<=b&&b<4;\n}\n\nint calc(vector<vector<int>> vv){\n\tint state = 0;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tif(vv[i][j]){\n\t\t\t\tstate += 1<<(i*4+j);\n\t\t\t}\n\t\t}\n\t}\n\treturn state;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t}\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\trep(k,3){\n\t\t\t\tif(t == \"RGB\"[k]){\n\t\t\t\t\ttable[i][j] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dp(1<<16,1e9);\n\tdp[0] = 0;\n\trep(i,1<<16){\n\t\tif(dp[i]>1e8) continue;\n\t\tvector<vector<int>> vv(4,vector<int>(4));\n\t\trep(j,16){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tvv[j/4][j%4] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(auto x: v){\n\t\t\trep(_k,7){\n\t\t\t\trep(_l,7){\n\t\t\t\t\tint k = _k-3;\n\t\t\t\t\tint l = _l-3;\n\t\t\t\t\trep(color, 3){\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\tif(inside(k+kk,l+ll)&&table[k+kk][l+ll]!=color&&vv[k+kk][l+ll]==0) ok=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tauto tmp = vv;\n\t\t\t\t\t\t\trep(kk,x.fi){\n\t\t\t\t\t\t\t\trep(ll,x.se){\n\t\t\t\t\t\t\t\t\tif(inside(k+kk,l+ll)){\n\t\t\t\t\t\t\t\t\t\ttmp[k+kk][l+ll] = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint state = calc(tmp);\n\t\t\t\t\t\t\tdp[state] = min(dp[state], dp[i]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<16)-1]<<endl;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2297: Rectangular Stamps\n// 2017.12.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define LIM 65535\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\nint q[65540]; int top, end;\nchar enable[4][4][4][4];\nchar map[4][5];\nint dist[65540];\n\nint main()\n{\n\tint n, h, w, r, c, r2, c2, i, s, t, rr, cc;\n\tchar rgb[] = \"RGB\";\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &h, &w);\n\t\tfor (r = 1-h; r < 4; r++) for (c = 1-w; c < 4; c++)\n\t\t\tenable[MAX(0, r)][MAX(0, c)][MIN(3, r+h-1)][MIN(3, c+w-1)] = 1;\n\t}\n\n\tfor (r = 0; r < 4; r++) scanf(\"%s\", map[r]);\n\n\ttop = end = 0, q[end++] = 0;\n\tmemset(dist, 0x11, sizeof(dist));\n\tdist[0] = 0;\n\twhile (top < end) {\n\t\ts = q[top++];\n\t\tif (s == LIM) break;\n\t\t\n\t\tfor (r = 0; r < 4; r++) for (c = 0; c < 4; c++) {\n\t\t\tfor (r2 = r; r2 < 4; r2++) for (c2 = c; c2 < 4; c2++) if (enable[r][c][r2][c2]) {\n\t\t\t\t for (i = 0; i < 3; i++) {\n\t\t\t\t\tt = s;\n\t\t\t\t\tfor (rr = r; rr <= r2; rr++) for (cc = c; cc <= c2; cc++) {\n\t\t\t\t\t\tif (map[rr][cc] == rgb[i]) t |=   1 << ((rr << 2) + cc);\n\t\t\t\t\t\telse                       t &= ~(1 << ((rr << 2) + cc));\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[s] + 1 < dist[t]) dist[t] = dist[s]+1, q[end++] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dist[LIM]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nvoid f(int a){\n\tint i;\n\tfor(i=16;i--;)printf(\"%d\",(a>>i)%2);\n\tprintf(\"\\n\");\n}\nint n,m,i,j,k,l,x,y,p,r,t=0,h[20],w[20],q[1<<17],d[1<<17]={1};\nint main(){\n\tchar s[20],c[5]={\"RGB\"};\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d %d\",&h[i],&w[i]);\n\tfor(i=0;i<16;i++)scanf(\" %c\",&s[i]);\n\tq[t=0]=0;\n\tfor(r=1;r-t;t++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tfor(k=-h[i]+1;k<4;k++){\n\t\t\t\t\tfor(l=-w[i]+1;l<4;l++){\n\t\t\t\t\t\tm=q[t];\n\t\t\t\t\t\tfor(y=0;y<h[i];y++){\n\t\t\t\t\t\t\tfor(x=0;x<w[i];x++){\n\t\t\t\t\t\t\t\tif(k+y<0||3<k+y||l+x<0||3<l+x)continue;\n\t\t\t\t\t\t\t\tp=(k+y)*4+l+x;\n\t\t\t\t\t\t\t\tm|=1<<p;\n\t\t\t\t\t\t\t\tif(s[p]-c[j])m-=1<<p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}//f(m);\n\t\t\t\t\t\tif(d[m]==0)d[q[r++]=m]=d[q[t]]+1;\n\t\t\t\t\t}\n\t\t\t\t}//printf(\"\\n%d\\n\\n\",r);\n\t\t\t}\n\t\t}//printf(\"\\n\\n%d \",r);\n\t\t//f(q[t]);\n\t}\n\t//for(i=0;i<(1<<16);i++)printf(\"%d\\n\",d[i]);\n\tprintf(\"%d\\n\",d[(1<<16)-1]-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,i,j,k,l,x,y,p,r,t=0,h[20],w[20],q[1<<16],d[1<<16]={1};\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n\tchar s[20],c[5]={\"RGB\"};\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d %d\",&h[i],&w[i]);\n\tfor(i=0;i<16;i++)scanf(\" %c\",&s[i]);\n\tq[t=0]=0;\n\tfor(r=1;r-t;t++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tfor(k=-h[i]+1;k<4;k++){\n\t\t\t\t\tfor(l=-w[i]+1;l<4;l++){\n\t\t\t\t\t\tm=q[t];\n\t\t\t\t\t\tfor(y=MAX(0,k);y<MIN(4,k+h[i]);y++){\n\t\t\t\t\t\t\tfor(x=MAX(0,l);x<MIN(4,l+w[i]);x++){\n\t\t\t\t\t\t\t\t//if(k+y<0||3<k+y||l+x<0||3<l+x)continue;\n\t\t\t\t\t\t\t\tp=(y)*4+x;\n\t\t\t\t\t\t\t\tif(s[p]==c[j])m|= (1<<p);\n\t\t\t\t\t\t\t\telse          m&=~(1<<p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}//f(m);\n\t\t\t\t\t\tif(d[m]==0)d[q[r++]=m]=d[q[t]]+1;\n\t\t\t\t\t}\n\t\t\t\t}//printf(\"\\n%d\\n\\n\",r);\n\t\t\t}\n\t\t}//printf(\"\\n\\n%d \",r);\n\t\t//f(q[t]);\n\t}\n\t//for(i=0;i<(1<<16);i++)printf(\"%d\\n\",d[i]);\n\tprintf(\"%d\\n\",d[(1<<16)-1]-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define rep(i,n) for(int i = 0 ; i < n ; ++i)\n\nint n,H,W;\nchar c;\n\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nint A[10000],B[10000],sz=0;\nchar goal[5][5];\nint w[20],h[20];\n\ninline void gen(int s,int x,int y){\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(b){\n\t\t\tA[sz] = a;\n\t\t\tB[sz] = b;\n\t\t\t++sz;\n\t\t}\n\t}\n}\nint f(){\n\tQ[size++] = 0;\n\tmemo[0] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,sz){\n\t\t\tint bit = (q & ~A[i]) | B[i];\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n) scanf(\"%d%d\",h+i,w+i);\n\trep(i,4){\n\t\tscanf(\"%s\",goal[i]);\n\t\trep(j,4){\n\t\t\tif(goal[i][j]=='R')goal[i][j] = 0;\n\t\t\telse if(goal[i][j]=='G')goal[i][j] = 1;\n\t\t\telse if(goal[i][j]=='B')goal[i][j] = 2;\n\t\t}\n\t}\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f());\n\t\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define rep(i,n) for(i = 0 ; i < n ; ++i)\n\nint n,H,W;\nchar c;\n\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nint A[10000],B[10000],sz=0;\nchar goal[5][5];\nint w[20],h[20];\ninline void gen(int s,int x,int y){\n\tint i,j,k;\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(b){\n\t\t\tA[sz] = a;\n\t\t\tB[sz] = b;\n\t\t\t++sz;\n\t\t}\n\t}\n}\nint f(){\n\tint i,j,k;\n\tQ[size++] = 0;\n\tmemo[0] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,sz){\n\t\t\tint bit = (q & ~A[i]) | B[i];\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\trep(i,n) scanf(\"%d%d\",h+i,w+i);\n\trep(i,4){\n\t\tscanf(\"%s\",goal[i]);\n\t\trep(j,4){\n\t\t\tif(goal[i][j]=='R')goal[i][j] = 0;\n\t\t\telse if(goal[i][j]=='G')goal[i][j] = 1;\n\t\t\telse if(goal[i][j]=='B')goal[i][j] = 2;\n\t\t}\n\t}\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f());\n\t\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define rep(i,n) for(i = 0 ; i < n ; ++i)\n\nint n,H,W;\nchar c;\n\nint memo[65536];\nint visi[65536];\nint Q[65537];\nint head = 0 , size = 0;\nint A[10000],B[10000],sz=0;\nchar goal[5][5];\nint w[20],h[20];\ninline void gen(int s,int x,int y){\n\tint i,j,k;\n\trep(k,3){\n\t\tint a=0,b=0;\n\t\trep(i,h[s]){\n\t\t\trep(j,w[s]){\n\t\t\t\tint tx = x + j;\n\t\t\t\tint ty = y + i;\n\t\t\t\tif(tx >= 0 && tx < 4 && ty < 4 && ty >= 0){\n\t\t\t\t\t\ta |= 1<<(ty*4+tx);\n\t\t\t\t\t\tb |= (goal[ty][tx] == k)<<(ty*4+tx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(b){\n\t\t\tA[sz] = a;\n\t\t\tB[sz] = b;\n\t\t\t++sz;\n\t\t}\n\t}\n}\nint f(){\n\tint i,j,k;\n\tQ[size++] = 0;\n\tmemo[0] = 0;\n\tint good = (1<<16)-1;\n\twhile(head < size){\n\t\tint q = Q[head++];\n\t\tint cost = memo[q];\n\t\tif(good == q) return cost;\n\t\t\n\t\trep(i,sz){\n\t\t\tint bit = (q & ~A[i]) | B[i];\n\t\t\tif(!visi[bit]){\n\t\t\t\tvisi[bit] = 1;\n\t\t\t\tmemo[bit] = cost + 1;\n\t\t\t\tQ[size++] = bit;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\trep(i,n) scanf(\"%d%d\",h+i,w+i);\n\trep(i,4){\n\t\tscanf(\"%s\",goal[i]);\n\t\trep(j,4){\n\t\t\tif(goal[i][j]=='R')goal[i][j] = 0;\n\t\t\telse if(goal[i][j]=='G')goal[i][j] = 1;\n\t\t\telse if(goal[i][j]=='B')goal[i][j] = 2;\n\t\t}\n\t}\n\trep(k,n){\n\t\trep(i,7)rep(j,7){\n\t\t\tgen(k,i-3,j-3);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f());\n\treturn 0;\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  long encode(int[][] field) {\n    long sum = 0;\n    long shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Long> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      long v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(v)) {\n        continue;\n      }\n      set.add(v);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint nRs;\n\tR[] rs;\n\tint[][] map;\n\tint n=4;\n\n\tvoid run(){\n\t\tnRs=sc.nextInt();\n\t\trs=new R[nRs];\n\t\tfor(int i=0; i<nRs; i++){\n\t\t\tint h=sc.nextInt();\n\t\t\tint w=sc.nextInt();\n\t\t\trs[i]=new R(w, h);\n\t\t}\n\t\tmap=new int[n][n];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tswitch(s.charAt(i)){\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[j][i]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tmap[j][i]=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tmap[j][i]=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tLinkedList<State> que=new LinkedList<State>();\n\t\tboolean[] visited=new boolean[1<<(n*n)];\n\n\t\tint[] removed=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(removed, (1<<n)-1);\n\t\t}\n\n\t\tState s0=new State(0, removed);\n\t\tque.offer(s0);\n\t\tvisited[s0.hashCode()]=true;\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tState s=que.poll();\n\t\t\tfor(int k=0; k<nRs; k++){\n\t\t\t\tfor(int y=-n+1; y<n; y++){\n\t\t\t\t\tfor(int x=-n+1; x<n; x++){\n\t\t\t\t\t\tif(canStamp(x, y, rs[k].w, rs[k].h, s.removed)){\n\t\t\t\t\t\t\tState t=new State(s.step+1, s.removed);\n\t\t\t\t\t\t\tt.clear(x, y, rs[k].w, rs[k].h);\n\t\t\t\t\t\t\tif(!visited[t.hashCode()]){\n\t\t\t\t\t\t\t\tque.offer(t);\n\t\t\t\t\t\t\t\tvisited[t.hashCode()]=true;\n\t\t\t\t\t\t\t\tif(t.isCleared()){\n\t\t\t\t\t\t\t\t\tprintln(t.step+\"\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean canStamp(int x, int y, int w, int h, int[] removed){\n\t\tboolean same=true;\n\t\tint k=0;\n\t\tfor(int j=y; j<y+h; j++){\n\t\t\tfor(int i=x; i<x+w; i++){\n\t\t\t\tif(i>=0&&i<n&&j>=0&&j<n){\n\t\t\t\t\tif(((removed[j]>>i)&1)!=0){\n\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\tk=map[j][i];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tsame&=k==map[j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!same){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn same&&k!=0;\n\t}\n\n\tclass R{\n\t\tint w, h;\n\n\t\tR(int w, int h){\n\t\t\tthis.w=w;\n\t\t\tthis.h=h;\n\t\t}\n\t}\n\n\tclass State{\n\t\tint step;\n\t\tint[] removed=new int[n];\n\n\t\tState(int step, int[] rem){\n\t\t\tthis.step=step;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tremoved[i]=rem[i];\n\t\t\t}\n\t\t}\n\n\t\tvoid clear(int x, int y, int w, int h){\n\t\t\tfor(int j=y; j<y+h; j++){\n\t\t\t\tfor(int i=x; i<x+w; i++){\n\t\t\t\t\tif(i>=0&&i<n&&j>=0&&j<n){\n\t\t\t\t\t\tremoved[j]&=~(1<<i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean isCleared(){\n\t\t\tboolean ret=true;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tret&=removed[i]==0;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\tint hash=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\thash=hash*16+removed[i];\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n      if (++cnt % 10 == 0) {\n        System.gc();\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int diff(int ans, int field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int l = get(j, i, ans);\n        int r = get(j, i, field);\n        if (l != r) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 * 2 + x * 2)) & 0b11;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(0b11 << (y * 4 * 2 + x * 2));\n    f |= c << (y * 4 * 2 + x * 2);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (get(nx, ny, f) == c) {\n          continue;\n        }\n        if (get(nx, ny, ans) == get(nx, ny, f)) {\n          return 0;\n        }\n        f = next(nx, ny, c, f);\n        flag |= get(nx, ny, ans) == c;\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return f;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    int encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(encodedAns, 0);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, encodedAns);\n              if (enc == 0) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              next.diff = diff(encodedAns, enc);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int enc;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int diff(int ans, int field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int l = get(j, i, ans);\n        int r = get(j, i, field);\n        if (l != r) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n//        shift += 2;\n        ++shift;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n//        int v = (bits >> shift) & 0b11;\n        int v = (bits >> shift) & 0b1;\n        field[i][j] = v;\n//        shift += 2;\n        shift += 1;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  int get(int x, int y, int bits) {\n//    return (bits >> (y * 4 * 2 + x * 2)) & 0b11;\n    return (bits >> (y * 4 + x)) & 1;\n  }\n\n  int next(int x, int y, int c, int f) {\n//    f &= ~(0b11 << (y * 4 * 2 + x * 2));\n//    f |= c << (y * 4 * 2 + x * 2);\n//    return f;\n    f &= ~(1 << (y * 4 + x));\n    f |= c << (y * 4 + x);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int[][] ans) {\n//    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        int v = ans[ny][nx] == c ? 1 : 0;\n        f = next(nx, ny, v, f);\n//        flag |= get(nx, ny, ans) == c;\n      }\n    }\n//    if (!flag) {\n//      return 0;\n//    }\n    return f;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void debugField(int v) {\n    int[][] bf = decode(v);\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        System.err.print(bf[i][j]);\n      }\n      System.err.println();\n    }\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    int encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n//    atom.diff = diff(encodedAns, 0);\n    Queue<Board> queue = new LinkedList<>();\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n//      debug(board.cost, board.diff);\n//      debugField(board.enc);\n      if (board.enc == (1 << 16) - 1) {\n        min = Math.min(min, board.cost);\n//        debug(min);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, ans);\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  long encode(int[][] field) {\n    long sum = 0;\n    long shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Long> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      long v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(v)) {\n        continue;\n      }\n      set.add(v);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int diff(int ans, int field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int l = get(j, i, ans);\n        int r = get(j, i, field);\n        if (l != r) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 * 2 + x * 2)) & 0b11;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(0b11 << (y * 4 * 2 + x * 2));\n    f |= c << (y * 4 * 2 + x * 2);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (get(nx, ny, f) == c) {\n          continue;\n        }\n        if (get(nx, ny, ans) == get(nx, ny, f)) {\n          return 0;\n        }\n        f = next(nx, ny, c, f);\n        flag |= get(nx, ny, ans) == c;\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return f;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    int encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(encodedAns, 0);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.cost + a.diff));\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, encodedAns);\n              if (enc == 0) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              next.diff = diff(encodedAns, enc);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int enc;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 + x)) & 1;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(1 << (y * 4 + x));\n    f |= c << (y * 4 + x);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int[][] ans) {\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        int v = ans[ny][nx] == c ? 1 : 0;\n        f = next(nx, ny, v, f);\n      }\n    }\n    return f;\n  }\n\n  int[][][][][] mask;\n\n  void initMask(int n, int[] h, int[] w, int[][] ans) {\n    mask = new int[n][4][7][7][2];\n    for (int i = 0; i < n; ++i) {\n      for (int c = 1; c <= 3; ++c) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            int left = (1 << 16) - 1;\n            int right = 0;\n            for (int a = 0; a < h[i]; ++a) {\n              for (int b = 0; b < w[i]; ++b) {\n                int nx = b + x;\n                int ny = a + y;\n                if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n                  continue;\n                }\n                left &= ~(1 << (ny * 4 + nx));\n                int v = ans[ny][nx] == c ? 1 : 0;\n                right |= v << (ny * 4 + nx);\n              }\n            }\n            mask[i][c][x + 3][y + 3][0] = left;\n            mask[i][c][x + 3][y + 3][1] = right;\n          }\n        }\n      }\n    }\n  }\n\n  int apply(int index, int c, int x, int y, int f) {\n    f &= mask[index][c][x + 3][y + 3][0];\n    f |= mask[index][c][x + 3][y + 3][1];\n    return f;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    initMask(n, h, w, ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    Queue<Board> queue = new LinkedList<>();\n    queue.add(atom);\n    boolean[] done = new boolean[1 << 16];\n    done[0] = true;\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      if (board.enc == (1 << 16) - 1) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      for (int i = 0; i < n; ++i) {\n        for (int c = 1; c <= 3; ++c) {\n          for (int y = -3; y <= 3; ++y) {\n            for (int x = -3; x <= 3; ++x) {\n              int enc = apply(i, c, x, y, board.enc);\n              if (enc == board.enc) {\n                continue;\n              }\n              if (Integer.bitCount(enc) < Integer.bitCount(board.enc)) {\n                continue;\n              }\n              if (done[enc]) {\n                continue;\n              }\n              done[enc] = true;\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n///Rectangular Stamps\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] h = new int[n], w = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\th[i] = sc.nextInt(); w[i] = sc.nextInt();\n\t\t}\n\t\tint[][] a = new int[4][4];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<4;j++)a[i][j] = c[j]=='R'?0:c[j]=='G'?1:2;\n\t\t}\n\t\tint[] d = new int[1<<16];\n\t\tint INF = 1<<29;\n\t\tArrays.fill(d, INF);\n\t\td[65535] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(65535);\n\t\twhile(!q.isEmpty()){\n\t\t\tint S = q.poll();\n\t\t\tif(S==0){\n\t\t\t\tSystem.out.println(d[S]); break;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int i=-3;i<=3;i++)for(int j=-3;j<=3;j++){\n\t\t\t\t\tint cov = 0, app = 0;\n\t\t\t\t\tfor(int y=0;y<h[k];y++)for(int x=0;x<w[k];x++){\n\t\t\t\t\t\tif(0<=i+y&&i+y<4&&0<=j+x&&j+x<4){\n\t\t\t\t\t\t\tint p = (i+y)*4+j+x;\n\t\t\t\t\t\t\tif(((S>>p)&1)==0)continue;\n\t\t\t\t\t\t\tapp|=1<<a[i+y][j+x];\n\t\t\t\t\t\t\tcov+=1<<p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(app==1||app==2||app==4){\n\t\t\t\t\t\tint ns = S&~cov;\n\t\t\t\t\t\tif(d[ns]==INF){\n\t\t\t\t\t\t\td[ns] = d[S]+1; q.add(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int enc;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 + x)) & 1;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(1 << (y * 4 + x));\n    f |= c << (y * 4 + x);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int[][] ans) {\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        int v = ans[ny][nx] == c ? 1 : 0;\n        f = next(nx, ny, v, f);\n      }\n    }\n    return f;\n  }\n\n  int[][][][][] mask;\n\n  void initMask(int n, int[] h, int[] w, int[][] ans) {\n    mask = new int[n][4][7][7][2];\n    for (int i = 0; i < n; ++i) {\n      for (int c = 1; c <= 3; ++c) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            int left = (1 << 16) - 1;\n            int right = 0;\n            for (int a = 0; a < h[i]; ++a) {\n              for (int b = 0; b < w[i]; ++b) {\n                int nx = b + x;\n                int ny = a + y;\n                if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n                  continue;\n                }\n                left &= ~(1 << (ny * 4 + nx));\n                int v = ans[ny][nx] == c ? 1 : 0;\n                right |= v << (ny * 4 + nx);\n              }\n            }\n            mask[i][c][x + 3][y + 3][0] = left;\n            mask[i][c][x + 3][y + 3][1] = right;\n          }\n        }\n      }\n    }\n  }\n\n  int apply(int index, int c, int x, int y, int f) {\n    f &= mask[index][c][x + 3][y + 3][0];\n    f |= mask[index][c][x + 3][y + 3][1];\n    return f;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    initMask(n, h, w, ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    Queue<Board> queue = new LinkedList<>();\n    queue.add(atom);\n    boolean[] done = new boolean[1 << 16];\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      if (board.enc == (1 << 16) - 1) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (done[board.enc]) {\n        continue;\n      }\n      done[board.enc] = true;\n      for (int i = 0; i < n; ++i) {\n        for (int c = 1; c <= 3; ++c) {\n          for (int y = -3; y <= 3; ++y) {\n            for (int x = -3; x <= 3; ++x) {\n              int enc = apply(i, c, x, y, board.enc);\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  long encode(int[][] field) {\n    long sum = 0;\n    long shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Long> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      while (queue.size() > 0) {\n        queue.poll();\n      }\n      long v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(v)) {\n        continue;\n      }\n      set.add(v);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int enc;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 + x)) & 1;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(1 << (y * 4 + x));\n    f |= c << (y * 4 + x);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int[][] ans) {\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        int v = ans[ny][nx] == c ? 1 : 0;\n        f = next(nx, ny, v, f);\n      }\n    }\n    return f;\n  }\n\n  int[][][][][] mask;\n\n  void initMask(int n, int[] h, int[] w, int[][] ans) {\n    mask = new int[n][4][7][7][2];\n    for (int i = 0; i < n; ++i) {\n      for (int c = 1; c <= 3; ++c) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            int left = (1 << 16) - 1;\n            int right = 0;\n            for (int a = 0; a < h[i]; ++a) {\n              for (int b = 0; b < w[i]; ++b) {\n                int nx = b + x;\n                int ny = a + y;\n                if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n                  continue;\n                }\n                left &= ~(1 << (ny * 4 + nx));\n                int v = ans[ny][nx] == c ? 1 : 0;\n                right |= v << (ny * 4 + nx);\n              }\n            }\n            mask[i][c][x + 3][y + 3][0] = left;\n            mask[i][c][x + 3][y + 3][1] = right;\n          }\n        }\n      }\n    }\n  }\n\n  int apply(int index, int c, int x, int y, int f) {\n    f &= mask[index][c][x + 3][y + 3][0];\n    f |= mask[index][c][x + 3][y + 3][1];\n    return f;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    initMask(n, h, w, ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    Queue<Board> queue = new LinkedList<>();\n    queue.add(atom);\n    boolean[] done = new boolean[1 << 16];\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      if (board.enc == (1 << 16) - 1) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (done[board.enc]) {\n        continue;\n      }\n      done[board.enc] = true;\n      for (int i = 0; i < n; ++i) {\n        for (int c = 1; c <= 3; ++c) {\n          for (int y = -3; y <= 3; ++y) {\n            for (int x = -3; x <= 3; ++x) {\n              int enc = apply(i, c, x, y, board.enc);\n              if (enc == board.enc) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  long encode(int[][] field) {\n    long sum = 0;\n    long shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        flag |= true;\n        f[ny][nx] = c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    PriorityQueue<Board> queue = new PriorityQueue<>(Comparator.comparingInt(b -> b.diff));\n    queue.add(atom);\n    HashSet<Long> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      long v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(v)) {\n        continue;\n      }\n      set.add(v);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n      if (++cnt % 10000 == 0) {\n        System.gc();\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n      if (++cnt % 100000 == 0) {\n        System.gc();\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n      System.gc();\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(v)) {\n        continue;\n      }\n      set.add(v);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n      if (++cnt % 100 == 0) {\n        System.gc();\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int diff(int ans, int field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int l = get(j, i, ans);\n        int r = get(j, i, field);\n        if (l != r) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 * 2 + x * 2)) & 0b11;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(0b11 << (y * 4 * 2 + x * 2));\n    f |= c << (y * 4 * 2 + x * 2);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (get(nx, ny, f) == c) {\n          continue;\n        }\n        f = next(nx, ny, c, f);\n        flag |= get(nx, ny, ans) == c;\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return f;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void debugField(int v) {\n    int[][] bf = decode(v);\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        System.err.print(bf[i][j]);\n      }\n      System.err.println();\n    }\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    int encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(encodedAns, 0);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.cost));\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n//      debug(board.cost, board.diff);\n//      debugField(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n//        debug(min);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, encodedAns);\n              if (enc == 0) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              next.diff = diff(encodedAns, enc);\n              next.diffdiff = next.diff - board.diff;\n              if (next.diffdiff >= 0) {\n                continue;\n              }\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int diff(int ans, int field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int l = get(j, i, ans);\n        int r = get(j, i, field);\n        if (l != r) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 * 2 + x * 2)) & 0b11;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(0b11 << (y * 4 * 2 + x * 2));\n    f |= c << (y * 4 * 2 + x * 2);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (get(nx, ny, f) == c) {\n          continue;\n        }\n        if (get(nx, ny, ans) == get(nx, ny, f)) {\n          return 0;\n        }\n        f = next(nx, ny, c, f);\n        flag |= get(nx, ny, ans) == c;\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return f;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void debugField(int v) {\n    int[][] bf = decode(v);\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        System.err.print(bf[i][j]);\n      }\n      System.err.println();\n    }\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    int encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(encodedAns, 0);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.cost + a.diff));\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n//      debug(board.cost, board.diff);\n//      debugField(board.enc);\n//      ni();\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n//        debug(min);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, encodedAns);\n              if (enc == 0) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              next.diff = diff(encodedAns, enc);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  long encode(int[][] field) {\n    long sum = 0;\n    long shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    HashSet<Long> set = new HashSet<>();\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      ArrayList<Board> list = new ArrayList<>();\n      while (queue.size() > 0) {\n        Board b = queue.poll();\n        if (b.diff == board.diff) {\n          list.add(b);\n        }\n      }\n      queue.addAll(list);\n      long v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(v)) {\n        continue;\n      }\n      set.add(v);\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(ans, new int[4][4]);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(bf);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                field = null;\n                continue;\n              }\n              Board next = new Board();\n              next.enc = encode(field);\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n              field = null;\n            }\n          }\n        }\n      }\n      bf = null;\n      if (++cnt % 50000 == 0) {\n        System.gc();\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int enc;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 + x)) & 1;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(1 << (y * 4 + x));\n    f |= c << (y * 4 + x);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int[][] ans) {\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + j;\n        int ny = y + i;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        int v = ans[ny][nx] == c ? 1 : 0;\n        f = next(nx, ny, v, f);\n      }\n    }\n    return f;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    Queue<Board> queue = new LinkedList<>();\n    queue.add(atom);\n    boolean[] done = new boolean[1 << 16];\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      if (board.enc == (1 << 16) - 1) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      if (done[board.enc]) {\n        continue;\n      }\n      done[board.enc] = true;\n      for (int i = 0; i < n; ++i) {\n        for (int c = 1; c <= 3; ++c) {\n          for (int y = -3; y <= 3; ++y) {\n            for (int x = -3; x <= 3; ++x) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, ans);\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int enc;\n    int index;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int diff(int ans, int field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int l = get(j, i, ans);\n        int r = get(j, i, field);\n        if (l != r) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  int encode(int[][] field) {\n    int sum = 0;\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] decode(int bits) {\n    int[][] field = new int[4][4];\n    int shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        int v = (bits >> shift) & 0b11;\n        field[i][j] = v;\n        shift += 2;\n      }\n    }\n    return field;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  int get(int x, int y, int bits) {\n    return (bits >> (y * 4 * 2 + x * 2)) & 0b11;\n  }\n\n  int next(int x, int y, int c, int f) {\n    f &= ~(0b11 << (y * 4 * 2 + x * 2));\n    f |= c << (y * 4 * 2 + x * 2);\n    return f;\n  }\n\n  int apply(int h, int w, int c, int f, int x, int y, int ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (get(nx, ny, f) == c) {\n          continue;\n        }\n        if (get(nx, ny, ans) == get(nx, ny, f)) {\n          return 0;\n        }\n        f = next(nx, ny, c, f);\n        flag |= get(nx, ny, ans) == c;\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return f;\n  }\n\n  class Rect {\n    int h, w;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    ArrayList<Rect> list = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n      Rect r = new Rect();\n      r.h = h[i];\n      r.w = w[i];\n      list.add(r);\n    }\n    list.sort(Comparator.comparingInt((Rect r) -> r.h * r.w).reversed());\n    for (int i = 0; i < n; ++i) {\n      Rect r = list.get(i);\n      h[i] = r.h;\n      w[i] = r.w;\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    int encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.enc = 0;\n    atom.diff = diff(encodedAns, 0);\n    atom.diffdiff = 0;\n    atom.index = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      if (a.diffdiff != b.diffdiff) {\n        return a.diffdiff - b.diffdiff;\n      }\n      return -(a.index - b.index);\n    });\n    queue.add(atom);\n    HashSet<Integer> set = new HashSet<>();\n    int min = INF;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      int[][] bf = decode(board.enc);\n      if (encodedAns == board.enc) {\n        min = Math.min(min, board.cost);\n        if (++cnt >= 10) {\n          break;\n        }\n      }\n      if (set.contains(board.enc)) {\n        continue;\n      }\n      set.add(board.enc);\n      for (int i = board.index; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int enc = apply(h[i], w[i], c, board.enc, x, y, encodedAns);\n              if (enc == 0) {\n                continue;\n              }\n              Board next = new Board();\n              next.enc = enc;\n              next.cost = board.cost + 1;\n              next.diff = diff(encodedAns, enc);\n              next.diffdiff = next.diff - board.diff;\n              next.index = i;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Board {\n    int cost;\n    int diff;\n    int diffdiff;\n    int[][] field;\n  }\n\n  int diff(int[][] ans, int[][] field) {\n    int cnt = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (ans[i][j] != field[i][j]) {\n          ++cnt;\n        }\n      }\n    }\n    return cnt;\n  }\n\n  long encode(int[][] field) {\n    long sum = 0;\n    long shift = 0;\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        sum |= (long) field[i][j] << shift;\n        shift += 2;\n      }\n    }\n    return sum;\n  }\n\n  int[][] copy(int[][] f) {\n    int[][] g = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        g[i][j] = f[i][j];\n      }\n    }\n    return g;\n  }\n\n  boolean apply(int h, int w, int c, int[][] f, int x, int y, int[][] ans) {\n    boolean flag = false;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int nx = x + i;\n        int ny = y + j;\n        if (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) {\n          continue;\n        }\n        if (f[ny][nx] == c) {\n          continue;\n        }\n        if (ans[ny][nx] == f[ny][nx]) {\n          return false;\n        }\n        f[ny][nx] = c;\n        flag |= ans[ny][nx] == c;\n      }\n    }\n    return flag;\n  }\n\n  void run() {\n    int n = ni();\n    int[] h = new int[n];\n    int[] w = new int[n];\n    for (int i = 0; i < n; ++i) {\n      h[i] = ni();\n      w[i] = ni();\n    }\n    int[] map = new int[256];\n    map['R'] = 1;\n    map['G'] = 2;\n    map['B'] = 3;\n    int[][] ans = new int[4][4];\n    for (int i = 0; i < 4; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 4; ++j) {\n        ans[i][j] = map[str.charAt(j)];\n      }\n    }\n    long encodedAns = encode(ans);\n    Board atom = new Board();\n    atom.cost = 0;\n    atom.field = new int[4][4];\n    atom.diff = diff(ans, atom.field);\n    atom.diffdiff = 0;\n    PriorityQueue<Board> queue = new PriorityQueue<>((a, b) -> {\n      if (a.diff != b.diff) {\n        return a.diff - b.diff;\n      }\n      return a.diffdiff - b.diffdiff;\n    });\n    queue.add(atom);\n    int min = INF;\n    while (queue.size() > 0) {\n      Board board = queue.poll();\n      long v = encode(board.field);\n      if (encodedAns == v) {\n        min = Math.min(min, board.cost);\n        break;\n      }\n      for (int i = 0; i < n; ++i) {\n        for (int y = -3; y <= 3; ++y) {\n          for (int x = -3; x <= 3; ++x) {\n            for (int c = 1; c <= 3; ++c) {\n              int[][] field = copy(board.field);\n              boolean flag = apply(h[i], w[i], c, field, x, y, ans);\n              if (!flag) {\n                continue;\n              }\n              Board next = new Board();\n              next.field = field;\n              next.cost = board.cost + 1;\n              next.diff = diff(ans, field);\n              next.diffdiff = next.diff - board.diff;\n              queue.add(next);\n            }\n          }\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct STAMP {\n    int H, W;\n}\n\nint N;\nSTAMP[] S;\nstring[] F;\nint[] masks;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    S = new STAMP[N];\n    foreach (i; 0 .. N) {\n        int h, w; scanf(\"%d %d\\n\", &h, &w);\n        S[i] = STAMP(h, w);\n    }\n    F = new string[4];\n    foreach (i; 0 .. 4) {\n        F[i] = readln.chomp;\n    }\n\n    masks.destroy;\n    foreach (s; S) {\n        for (int y = -3; y < 4; y++) {\n            for (int x = -3; x < 4; x++) {\n                int sy = max(0, y),\n                    gy = min(y + s.H, 4);\n                int sx = max(0, x),\n                    gx = min(x + s.W, 4);\n                int mask = 0;\n                for (int i = sy; i < gy; i++) {\n                    for (int j = sx; j < gx; j++) {\n                        mask |= 1 << (i * 4 + j);\n                    }\n                }\n                masks ~= mask;\n            }\n        }\n    }\n    masks = masks.sort.uniq.array;\n}\n\nvoid solve() {\n    int init = 0;\n    bool[int] used;\n    used[init] = true;\n    struct P {\n        int state, dist;\n        string toString() const {\n            return format(\"P(%016b, %d)\", state, dist);\n        }\n    }\n    DList!P Q;\n    Q.insert(P(init, 0));\n    while (!Q.empty) {\n        auto cur = Q.front; Q.removeFront;\n        //writeln(cur);\n        foreach (c; \"RGB\") {\n            foreach (mask; masks) {\n                int next = cur.state;\n                foreach (int i; 0 .. 16) {\n                    if (!(mask & (1 << i))) continue;\n                    int y = i / 4,\n                        x = i % 4;\n                    if (c == F[y][x]) {\n                        next |= (1 << i);\n                    } else {\n                        next &= ~(1 << i);\n                    }\n                }\n                if (next == (1 << 16) - 1) {\n                    writeln(cur.dist + 1);\n                    return;\n                }\n                if (next in used) continue;\n                Q.insert(P(next, cur.dist + 1));\n                used[next] = true;\n            }\n        }\n    }\n    assert(false);\n}\n\nvoid main() {\n    input;\n    solve;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN = int(input())\nH = W = 4\nS = 1 << 16\nP = [list(map(int, input().split())) for i in range(N)]\nC = [input() for i in range(H)]\nI = \"RGB\".index\nps = set()\nfor i in range(N):\n    h, w = P[i]\n    for y in range(1-h, H):\n        py = max(0, y); sh = min(H, y+h) - py\n        for x in range(1-w, W):\n            px = max(0, x); sw = min(W, x+w) - px\n            ps.add((px, py, sw, sh))\nL = len(ps)\nM = [0]*L; V = [None]*L\nfor l, (x, y, w, h) in enumerate(ps):\n    s = S-1; b = 0\n    v = [0]*3\n    for i in range(h):\n        for j in range(w):\n            k = 1 << ((y+i)*W + x+j)\n            s ^= k\n            c = I(C[y+i][x+j])\n            v[c] |= k\n    M[l] = s\n    V[l] = v\n\nU = [-1]*S\nque = deque([0])\nU[0] = 0\nwhile que:\n    state = que.popleft()\n    d = U[state]\n    for i in range(L):\n        n_state = state & M[i]\n        for v in V[i]:\n            if not v:\n                continue\n            if U[n_state | v] != -1:\n                continue\n            U[n_state | v] = d+1\n            que.append(n_state | v)\nprint(U[S-1])\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [LI() for _ in range(n)]\n        b = []\n        for _ in range(4):\n            b += [c for c in S()]\n        s = set()\n        ms = 2**16 - 1\n        ii = [2**i for i in range(16)]\n        for h, w in a:\n            for i in range(-h+1, 4):\n                for j in range(-w+1, 4):\n                    mask = ms\n                    for k in range(max(0, i), min(4, i+h)):\n                        for l in range(max(0, j), min(4, j+w)):\n                            mask -= ii[k*4+l]\n                    s.add(mask)\n        ta = []\n        for mask in s:\n            for c in 'RGB':\n                t = 0\n                for i in range(16):\n                    if ii[i] & mask:\n                        continue\n                    if b[i] == c:\n                        t += ii[i]\n                if t > 0:\n                    ta.append((mask, t))\n\n        v = collections.defaultdict(bool)\n        q = set([0])\n        r = 0\n        while q:\n            r += 1\n            nq = set()\n            for c in q:\n                v[c] = True\n            for c in q:\n                for mask, t in ta:\n                    n = (c & mask) + t\n                    if v[n]:\n                        continue\n                    if n == ms:\n                        return r\n                    nq.add(n)\n            q = nq\n\n        return -1\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from sys import stdin\n    from itertools import combinations\n    file_input = stdin\n    \n    N = int(file_input.readline())\n    hw = [tuple(map(int, file_input.readline().split())) for i in range(N)]\n    goal = (line.rstrip() for line in file_input)\n    goal = ''.join(goal)\n    \n    R = 0\n    G = 0\n    B = 0\n    b = 1\n    for c in goal[:]:\n        if c == 'R':\n            R += b\n        elif c == 'G':\n            G += b\n        else:\n            B += b\n        b <<= 1\n    c_m = (R, G, B) # color mask\n    g_m = (1 << 16) - 1 # goal mask\n    \n    stamps = []\n    for r1, r2 in combinations(range(5), 2):\n        rw = r2 - r1\n        for c1, c2 in combinations(range(5), 2):\n            cw = c2 - c1\n            for h, w in hw:\n                if (rw == h and cw == w) or \\\n                ((r1 == 0 or r2 == 4) and rw < h and cw == w) or \\\n                ((c1 == 0 or c2 == 4) and cw < w and rw == h) or \\\n                ((r1 == 0 or r2 == 4) and (c1 == 0 or c2 == 4) and \\\n                 rw < h and cw < w):\n                    m = 1\n                    for i in range(cw - 1):\n                        m <<= 1\n                        m += 1\n                    m <<= c1\n                    r_m = m\n                    for i in range(rw - 1):\n                        m <<= 4\n                        m += r_m\n                    m <<= (r1 * 4)\n                    for c in c_m:\n                        s = c & m\n                        if s:\n                            stamps.append((m ^ g_m, s))\n                    break\n    \n    picture = [0]\n    generated_picture = [False] * (2 ** 16)\n    generated_picture[0] = True\n    step = 0\n    while True:\n        t_picture = picture[:]\n        picture = []\n        step += 1\n        for p in t_picture:\n            for m, s in stamps:\n                n_p = p & m | s\n                if generated_picture[n_p]:\n                    continue\n                if n_p == g_m:\n                    return step\n                generated_picture[n_p] = True\n                picture.append(n_p)\n\nprint(solve())\n"
  }
]