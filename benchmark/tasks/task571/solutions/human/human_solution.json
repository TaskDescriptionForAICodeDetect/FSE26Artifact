[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def main(args:Array[String]) = {\n    val hw = readLine.split(\" \").map(_.toInt)\n    val fld = (for(i<-0 until hw(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }).toArray\n    val rc = readLine.split(\" \").map(_.toInt)\n    val pattern = (for(i<-0 until rc(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }).toArray\n    val b = new ArrayBuffer[Array[Int]]\n\n    for(i<-0 to (hw(0)-rc(0))) {\n      for(j<-0 to (hw(1)-rc(1))) {\n        var m = true\n        var k = 0\n        var l = 0\n        while(m && k<rc(0)) {\n          if(fld(i+k)(j+l) != pattern(k)(l)) m = false\n          if(l==rc(1)-1) { k+=1;l=0 }\n          else l += 1\n        }\n        if(m) b+= Array(i,j)\n      }\n    }\n    println{\n      b.sortWith((x,y)=>if(x(0)<y(0)) true else if(x(0)==y(0) && x(1)<y(1)) true else false)\n        .map(_.mkString(\" \")).mkString(\"\\n\")\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def main(args:Array[String]) = {\n    val hw = readLine.split(\" \").map(_.toInt)\n    val fld = (for(i<-0 until hw(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }).toArray\n    val rc = readLine.split(\" \").map(_.toInt)\n    val pattern = (for(i<-0 until rc(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }).toArray\n    val b = new ArrayBuffer[Array[Int]]\n\n    for(i<-0 to (hw(0)-rc(0))) {\n      for(j<-0 to (hw(1)-rc(1))) {\n        var m = true\n        var k = 0\n        var l = 0\n        while(m && k<rc(0)) {\n          if(fld(i+k)(j+l) != pattern(k)(l)) m = false\n          if(l==rc(1)-1) { k+=1;l=0 }\n          else l += 1\n        }\n        if(m) b+= Array(i,j)\n      }\n    }\n    println(b.map(_.mkString(\" \")).mkString(\"\\n\"))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def main(args:Array[String]) = {\n    val hw = readLine.split(\" \").map(_.toInt)\n    val fld = for(i<-0 until hw(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }\n    val rc = readLine.split(\" \").map(_.toInt)\n    val pattern = for(i<-0 until hw(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }\n    val b = new ArrayBuffer[Array[Int]]\n\n    for(i<-0 to (hw(0)-rc(0))) {\n      for(j<-0 to (hw(1)-rc(1))) {\n        var m = true\n        var k = 0\n        var l = 0\n        while(m && k<rc(0)) {\n          if(fld(i+k)(j+l) != pattern(k)(l)) m = false\n          if(l==rc(1)-1) { k+=1;l=0 }\n          else l += 1\n        }\n        if(m) b+= Array(i,j)\n      }\n    }\n    println(b.map(_.mkString(\" \")).mkString(\"\\n\"))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def main(args:Array[String]) = {\n    val hw = readLine.split(\" \").map(_.toInt)\n    val fld = (for(i<-0 until hw(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }).toArray\n    val rc = readLine.split(\" \").map(_.toInt)\n    val pattern = (for(i<-0 until rc(0)) yield {\n      readLine.trim.map(_.asDigit)\n    }).toArray\n    val b = new ArrayBuffer[Array[Int]]\n\n    for(i<-0 to (hw(0)-rc(0))) {\n      for(j<-0 to (hw(1)-rc(1))) {\n        var m = true\n        var k = 0\n        var l = 0\n        while(m && k<rc(0)) {\n          if(fld(i+k)(j+l) != pattern(k)(l)) m = false\n          if(l==rc(1)-1) { k+=1;l=0 }\n          else l += 1\n        }\n        if(m) b+= Array(i,j)\n      }\n    }\n    if(b.length>0)\n      println{\n        b.sortWith((x,y)=>if(x(0)<y(0)) true else if(x(0)==y(0) && x(1)<y(1)) true else false)\n          .map(_.mkString(\" \")).mkString(\"\\n\")\n      }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[1000][1000];\n\tlong long has_P[100][100];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + has_P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"%d %d\\n\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W, R, C;\n\n\tcin >> H >> W;\n\n\tvector<string> p1(H);\n\n\tfor (int i = 0; i < H; i++) { cin >> p1[i]; }\n\n\tcin >> R >> C;\n\n\tvector<string> p2(R);\n\n\tfor (int i = 0; i < R; i++) { cin >> p2[i]; }\n\n\tfor (int i = 0; i <= H - R; i++)\n\t{\n\t\tfor (int j = 0; j <= W - C; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < R; k++)\n\t\t\t{\n\t\t\t\tif (p1[i + k].substr(j, C) != p2[k])\n\t\t\t\t{\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << i << ' ' << j << endl;\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n     \n     \nusing namespace std;\n     \nstruct AhoCorasick {\n     \n  static const int ALPHABET_SIZE = 62, root=0;\n     \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n       \n  int N; // num of node\n     \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n     \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n     \n  vector<Node> nodes;\n     \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n     \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] == -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n     \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n     \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n     \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n     \n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n       \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n     \n  const int til = T[0].size();\n       \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n     \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n     \nint main(void){\n  int h,w,r,c;\n       \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n     \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    int minn = 1001, mini;\n    for (int i = 0; i < r; i++) {\n        int count[62] = { 0 }, maxn = 0;\n        for (int j = 0; j < c; j++) {\n            if ('0' <= f2[i][j] && f2[i][j] <= '9') {\n                count[f2[i][j] - '0']++;\n            }\n            if ('A' <= f2[i][j] && f2[i][j] <= 'Z') {\n                count[f2[i][j] - 55]++;\n            }\n            if ('a' <= f2[i][j] && f2[i][j] <= 'z') {\n                count[f2[i][j] - 61]++;\n            }\n        }\n        for (int j = 0; j < 62; j++) {\n            maxn = max(maxn, count[j]);\n        }\n        if (minn > maxn) {\n            minn = maxn;\n            mini = i;\n        }\n    }\n    mini = 1;\n    \n    for (int i = mini; i <= h - r + mini; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[mini]) {\n                bool success = true;\n                for (int k = mini - 1; k >= 0; k--) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n                for (int k = mini + 1; k < r; k++) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i - mini << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 47;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(const vector<string> &T, const vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  int current_power = 1;\n\n  ull hash_pmminus1, hash_pm;\n  if (m == 1) {\n    hash_pmminus1 = 1;\n    hash_pm = PRIME;\n  } else {\n    ull hash_pmminus1 = PRIME;\n    for (; current_power < m - 1; current_power <<= 1)\n      hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n    for (; current_power < m - 1; ++current_power)\n      hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n    ull hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n  }\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash =\n          (segment_hash - (hash_pmminus1 * ValueOf(T[i][j - 1]) % MODULUS)) %\n          MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash =\n          (text_hash - ((hash_ppowermtimes[n - 1]) * H[i - 1][j] % MODULUS)) %\n          MODULUS;                                 // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS; // shift up\n      text_hash += H[i + n - 1][j];                // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tif (R == 1) printf(\"%d %d\\n\", i, j);\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%d %d\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\nconst int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\ntypedef pair<int, int> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<int> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\nstruct RollingHash {\n    ll H, W;\n    const ll B1, B2, M;\n    vector<vector<ll>> h;\n    vector<ll> pow1, pow2;\n\n    RollingHash(vector<string> &str) : B1(1009), B2(1007), M(1000000009) {\n        H = str.size(), W = str[0].size();\n        h.assign(H + 1, vector<ll>(W + 1, 0));\n        pow1.assign(H + 1, 1);\n        pow2.assign(W + 1, 1);\n\n        rep(i, H)pow1[i + 1] = pow1[i] * B1 % M;\n        rep(i, W)pow2[i + 1] = pow2[i] * B2 % M;\n\n        rep(y, H)\n            rep(x, W) {\n                h[y + 1][x + 1] = (h[y][x + 1] * B1 % M + h[y + 1][x] * B2 % M\n                                   + (M - h[y][x] * B1 % M * B2 % M) + str[y][x]) % M;\n            }\n    }\n\n    ll hash(int x1, int y1, int x2, int y2) {\n        return (h[y2][x2]\n                + (M - h[y1][x2] * pow1[y2 - y1] % M)\n                + (M - h[y2][x1] * pow2[x2 - x1] % M)\n                + (h[y1][x1] * pow1[y2 - y1] % M * pow2[x2 - x1] % M)) % M;\n    }\n};\n\nint main() {\n\n    int h, w;\n    cin >> h >> w;\n\n    vector<string> s_list(h);\n    rep(i, h) cin >> s_list[i];\n\n    int r, c;\n    cin >> r >> c;\n    vector<string> t_list(r);\n    rep(i, r) cin >> t_list[i];\n\n    vector<vector<vector<int>>> z(h, vector<vector<int>>(r));\n\n\n    RollingHash rs(s_list), pt(t_list);\n    ll target = pt.hash(0, 0, c, r);\n    for (int y = r; y < h + 1; y++)\n        for (int x = c; x < w + 1; x++) {\n            if (rs.hash(x - c, y - r, x, y) == target) {\n                cout << y - r << \" \" << x - c << endl;\n            }\n        }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\nchar s[MAX][MAX];\nchar a[MAX][MAX];\nint h,w,r,c;\n\nvector<pair<int,int>> match2d()\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash;\n\tull tmpa[MAX]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmpa[i]=tmpa[i]*B1+a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tahash=ahash*B2+tmpa[i];\n\t}\n\t\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d();\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(int i=0;i<m.size();i++)\n\t{\n\t\tcout<<m[i].first<<\" \"<<m[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 100007;\n\n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n\n    for (int i = 0; i < n ; ++i) {\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q];\n        }\n    }\n\n    ull t2 = 1;\n    for (int i = 0; i < P ; ++i)  t2 *= B2;\n\n    for (int j = 0; j + Q <= m  ; ++j) {\n        ull e = 0;\n        for (int i = 0; i < P ; ++i)e = e * B2 + tmp[i][j];\n        for (int i = 0; i + P <= n ; ++i) {\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i + P][j];\n        }\n    }\n}\n\nvoid solve(){\n    compute_hash(pattern,P,Q);\n    ull res = hash[0][0];\n    compute_hash(field,N,M);\n    for (int i = 0; i <= N ; ++i) {\n        for (int j = 0; j <= M ; ++j) {\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for (int i = 0; i < N ; ++i) {\n        for (int j = 0; j < M ; ++j) {\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for (int i = 0; i < P ; i++) {\n        for (int j = 0; j < Q; ++j) {\n            cin >> pattern[i][j];\n        }\n    }\n        if(N < P && M < Q) return 0;\n        solve();\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_C\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n\tint H, W, R, C;\n\tvector<string> T, P;\n\tstring str;\n\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++){\n\t\tcin>>str;\n\t\tT.push_back(str);\n\t}\n\n\tcin>>R>>C;\n\tfor(int i=0;i<R;i++){\n\t\tcin>>str;\n\t\tP.push_back(str);\n\t}\n\n\tif((H>=R) && (W>=C)){\n\t\tfor(int i=0;i<=H-R;i++){\n\t\t\tfor(int j=0;j<=W-C;j++){\n\t\t\t\tif(T[i].substr(j, C) == P[0]){\n\t\t\t\t\tif(R == 1){\n\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k=i+1;k<i+R;k++){\n\t\t\t\t\t\t\tif(T[k].substr(j, C) == P[k-i]){\n\t\t\t\t\t\t\t\tif(k == R+i-1)\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull B1 = (ull)1e9 + 7;\nconst ull B2 = (ull)1e9 + 9;\nint H, W, R, C;\nvector<string> s, p;\nvector< vector<ull> > HASH[2];\n\nvector< vector<ull> > compute_hash(vector<string> &s, int h, int w, int r, int c) {\n  vector< vector<ull> > res(h, vector<ull>(w, 0)), tmp = res;\n  ull t1 = 1, t2 = 1;\n  for (int i = 0; i < c; i++) t1 *= B1;\n  for (int i = 0; i < h; i++) {\n    ull e = 0;\n    for (int j = 0; j < c; j++) e = e * B1 + s[i][j];\n    for (int j = 0; j + c <= w; j++) {\n      tmp[i][j] = e;\n      if (j + c >= w) continue;\n      e = e * B1 + s[i][j + c] - s[i][j] * t1;\n    }\n  }\n  for (int i = 0; i < r; i++) t2 *= B2;\n  for (int j = 0; j < w; j++) {\n    ull e = 0;\n    for (int i = 0; i < r; i++) e = e * B2 + tmp[i][j];\n    for (int i = 0; i + r <= h; i++) {\n      res[i][j] = e;\n      if (i + r >= h) continue;\n      e = e * B2 + tmp[i + r][j] - tmp[i][j] * t2;\n    }\n  }\n  return res;\n}\n\nint main(void) {\n  cin >> H >> W;\n  s.resize(H);\n  for (int i = 0; i < H; i++) {\n    cin >> s[i];\n  }\n  cin >> R >> C;\n  p.resize(R);\n  for (int i = 0; i < R; i++) {\n    cin >> p[i];\n  }\n\n  if (R <= H && C <= W) {\n    HASH[0] = compute_hash(s, H, W, R, C);\n    HASH[1] = compute_hash(p, R, C, R, C);\n    \n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        if (HASH[0][i][j] != HASH[1][0][0]) continue;\n        cout << i << \" \" << j << endl;\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct RollingHash2D {\n    typedef unsigned long long ull;\n\n    struct RollingHash {\n        typedef unsigned long long ull;\n        string S;\n        ull B;\n        int len;\n        vector<ull> hash, p;\n\n        RollingHash() {}\n\n        RollingHash(string S_, ull B_ = 1000000007LL) :\n                S(S_), B(B_), len(S.length()), hash(len + 1), p(len + 1) {\n            hash[0] = 0;\n            p[0] = 1;\n            for (int i = 0; i < len; i++) {\n                hash[i + 1] = hash[i] * B + S[i];\n                p[i + 1] = p[i] * B;\n            }\n        }\n\n        //S[l,r)\n        ull find(int l, int r) {\n            return hash[r] - hash[l] * p[r - l];\n        }\n    };\n\n    vector<string> S;\n    int h, w, r, c;\n    ull B;\n    vector<ull> p;\n    vector<vector<ull> > hash;\n    vector<RollingHash> rh;\n\n    RollingHash2D() {}\n\n    RollingHash2D(vector<string> S_, int r_, int c_, ull B_ = 1000000009LL) :\n            S(S_), h(S_.size()), w(S_[0].size()), r(r_), c(c_), B(B_),\n            p(h + 1), hash(h + 1, vector<ull>(w - c + 1, 0)), rh(h) {\n        for (int i = 0; i < h; i++) rh[i] = RollingHash(S[i]);\n        p[0] = 1;\n        for (int i = 0; i < h; i++) p[i + 1] = p[i] * B;\n        for (int j = 0; j < w - c + 1; j++) {\n            hash[0][j] = 0;\n            for (int i = 0; i < h; i++)\n                hash[i + 1][j] = hash[i][j] * B + rh[i].find(j, j + c);\n        }\n    }\n\n    //[i,i+r) * [j,j+c)\n    ull find(int i, int j) {\n        return hash[i + r][j] - hash[i][j] * p[r];\n    }\n};\n\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for (int i = 0; i < h; i++) {\n        cin >> s[i];\n    }\n\n    int r, c;\n    cin >> r >> c;\n    vector<string> t(r);\n    for (int i = 0; i < r; i++) {\n        cin >> t[i];\n    }\n\n    RollingHash2D srh(s, r, c);\n    RollingHash2D trh(t, r, c);\n\n    for (int i = 0; i < h - r + 1; i++) {\n        for (int j = 0; j < w - c + 1; j++) {\n            if (srh.find(i, j) == trh.find(0, 0)) cout << i << \" \" << j << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define B (1000000007ULL)\nusing namespace std;\ntypedef unsigned long long ull;\n\nint h, w, r, c;\nchar t[1000][1001], p[1000][1001];\null th[1000][1000], ph[1000];\nint st[1001];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>h>>w;\n    cin.ignore();\n    for(int i=0; i<h; i++)\n        cin.getline(t[i], 1001);\n    cin>>r>>c;\n    cin.ignore();\n    for(int i=0; i<r; i++)\n        cin.getline(p[i], 1001);\n\n    for(int i=0; i<r; i++){\n        for(int j=0; j<c; j++){\n            ph[i]=ph[i]*B+p[i][j];\n        }\n    }\n    ull bn=B;\n    for(int i=1; i<c; i++) bn*=B;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<c; j++) th[i][0]=th[i][0]*B+t[i][j];\n        for(int j=0; j<w-c; j++) th[i][j+1]=th[i][j]*B-t[i][j]*bn+t[i][j+c];\n    }\n    for(int y=0; y<=h-r; y++){\n        for(int x=0; x<=w-c; x++){\n            int i;\n            for(i=0; i<r&&th[y+i][x]==ph[i]; i++);\n            if(i==r) cout<<y<<' '<<x<<'\\n';\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <typename T>\nclass Mylist\n{\npublic:\n\tvector<T> data;\n\tint R;\n\tint C;\n\tint ndim;\n\n\t//コンストラクタ\n\tMylist() {};\n\n\tMylist(int size, T init) :data(size, init), R(1), C(size) {}\n\n\tMylist(int R_, int C_, T init) :data(R_*C_, init), R(R_), C(C_) {}\n\n\tT &at(int ri, int ci)\n\t{\n\t\t//if (ri < 0) ri = R + ri;\n\t\t//if (ci < 0) ci = C + ci;\n\n\t\treturn *(data.begin() + ci + ri * C);\n\t}\n\n\tMylist slice(int rs, int cs, int re, int ce)\n\t{\n\t\tif (rs < 0) rs = R + rs;\n\t\tif (re < 0) re = R + re;\n\t\tif (cs < 0) cs = C + cs;\n\t\tif (ce < 0) ce = C + ce;\n\n\t\tMylist dist(re - rs + 1, ce - cs + 1, 0);\n\t\tfor (int ri = 0; ri < dist.R; ri++) {\n\t\t\tfor (int ci = 0; ci < dist.C; ci++) {\n\t\t\t\tdist.at(ri, ci) = this->at(rs + ri, cs + ci);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tbool operator==(const Mylist &b)\n\t{\n\t\treturn data == b.data;\n\t}\n\n\tbool operator!=(const Mylist &b)\n\t{\n\t\treturn data != b.data;\n\t}\n\n\n};\n\nclass Puzzle\n{\npublic:\n\n\tMylist<char> B;\n\tMylist<char> P;\n\tbool same_flag;\n\tbool same_pat;\n\n\tvoid input()\n\t{\n\t\tint r, c;\n\t\tstring buf;\n\n\t\tcin >> r >> c;\n\t\tB = Mylist<char>(r, c, '_');\n\n\t\tfor (int ri = 0; ri < r; ri++) {\n\t\t\tcin >> buf;\n\t\t\tfor (int ci = 0; ci < c; ci++) {\n\t\t\t\tB.at(ri, ci) = buf[ci];\n\t\t\t}\n\t\t}\n\n\t\tcin >> r >> c;\n\t\tP = Mylist<char>(r, c, '_');\n\n\t\tfor (int ri = 0; ri < r; ri++) {\n\t\t\tcin >> buf;\n\t\t\tfor (int ci = 0; ci < c; ci++) {\n\t\t\t\tP.at(ri, ci) = buf[ci];\n\t\t\t}\n\t\t}\n\n\t\t//same_flag = false;\n\t\t//same_pat = false;\n\t\tsame_flag = is_all_same();\n\t\tsame_pat = is_same_pattern();\n\t}\n\n\tbool is_all_same() \n\t{\n\t\tchar s = P.at(0,0);\n\t\tfor (int ri = 0; ri < P.R; ri++) {\n\t\t\tfor (int ci = 0; ci < P.C; ci++) {\n\t\t\t\tif (P.at(ri, ci) != s) return false;\n\t\t\t}\n\t\t}\n\n\t\ts = B.at(0, 0);\n\t\tfor (int ri = 0; ri < B.R; ri++) {\n\t\t\tfor (int ci = 0; ci < B.C; ci++) {\n\t\t\t\tif (B.at(ri, ci) != s) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool is_same_pattern()\n\t{\n\t\tint size = 2;\n\t\tif (B.R < size || B.C < size || P.R < size || P.C < size) return false;\n\n\t\tMylist<char> pat_2_2 = B.slice(0, 0, size -1 , size -1);\n\n\t\tfor (int ri = 0; ri <= B.R - size; ri += size) {\n\t\t\tfor (int ci = 0; ci <= B.C - size; ci += size) {\n\t\t\t\tMylist<char> part = B.slice(ri, ci, ri + size - 1, ci + size - 1);\n\t\t\t\tif (part != pat_2_2) return false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int ri = 0; ri <= P.R - size; ri += size) {\n\t\t\tfor (int ci = 0; ci <= P.C - size; ci += size) {\n\t\t\t\tMylist<char> part = P.slice(ri, ci, ri + size - 1, ci + size - 1);\n\t\t\t\tif (part != pat_2_2) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvoid play()\n\t{\n\t\tif (B.R < P.R || B.C < P.C) return;\n\n\t\tfor (int ri = 0; ri <= B.R - P.R; ri++) {\n\t\t\tfor (int ci = 0; ci <= B.C - P.C; ci++) {\n\n\t\t\t\tif (same_flag || same_pat) {\n\t\t\t\t\tif (B.at(ri, ci) == P.at(0, 0)) {\n\t\t\t\t\t\tprintf(\"%d %d\\n\", ri, ci);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\tif (B.at(ri\t\t\t, ci          ) != P.at( 0    , 0      )) continue;\n\t\t\t\t\tif (B.at(ri + P.R-1 , ci          ) != P.at(P.R -1, 0      )) continue;\n\t\t\t\t\tif (B.at(ri         , ci + P.C -1 ) != P.at( 0    , P.C -1 )) continue;\n\t\t\t\t\tif (B.at(ri + P.R-1 , ci + P.C -1 ) != P.at(P.R -1, P.C -1 )) continue;\n\t\t\t\t\t\n\t\t\t\t\tint flag = 1;\n\t\t\t\t\tfor (int rri = 0; rri < P.R; rri++) {\n\t\t\t\t\t\tfor (int cci = 0; cci < P.C; cci++) {\n\t\t\t\t\t\t\tif (B.at(ri + rri, ci + cci) != P.at(rri, cci)) {\n\t\t\t\t\t\t\t//if (B.data[(ri + rri) * B.C + ci + cci] != P.data[rri * P.C +  cci]) {\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag == 0) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag == 1) {\n\t\t\t\t\t\tprintf(\"%d %d\\n\", ri, ci);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n};\n\n\nint main()\n{\n\tPuzzle puz;\n\n\tpuz.input();\n\tpuz.play();\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int H, W, r, c, f1[1000][1000], f2[1000][1000];\n    char ch;\n\n    cin >> H >> W;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> ch;\n            f1[i][j] = ch - '0';\n        }\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        for(int j = 0; j < c; j++) {\n            cin >> ch;\n            f2[i][j] = ch - '0';\n        }\n    }\n    \n    for (int i = 0; i < H; i++) {\n        if (i + r > H) {\n            break;\n        }\n        for (int j = 0; j < W; j++) {\n            if (j + c > W) {\n                break;\n            }\n            bool success = true;\n            for (int k = 0; k < r; k++) {\n                for (int l = 0; l < c; l++) {\n                    if (f1[i + k][j + l] != f2[k][l]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n            }\n            if (success == true) {\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    int minn = 1001, mini;\n    for (int i = 0; i < r; i++) {\n        int count[62] = { 0 }, maxn = 0;\n        for (int j = 0; j < c; j++) {\n            if ('0' <= f2[i][j] && f2[i][j] <= '9') {\n                count[f2[i][j] - '0']++;\n            }\n            if ('A' <= f2[i][j] && f2[i][j] <= 'Z') {\n                count[f2[i][j] - 55]++;\n            }\n            if ('a' <= f2[i][j] && f2[i][j] <= 'z') {\n                count[f2[i][j] - 61]++;\n            }\n        }\n        for (int j = 0; j < 62; j++) {\n            maxn = max(maxn, count[j]);\n        }\n        if (minn > maxn) {\n            minn = maxn;\n            mini = i;\n        }\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[mini]) {\n                bool success = true;\n                for (int k = mini - 1; k >= 0; k--) {\n                    if (f1[i - (mini - k)].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n                for (int k = mini + 1; k < r; k++) {\n                    if (f1[i + (k - mini)].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A=9999973,B=950527;\n\nint H,W;\nchar T[1005][1005];\null t[1005][1005];\nint h,w;\nchar U[1005][1005];\n\n\nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n\n  ull target=0;  \n  for(int i=0;i<h;i++){\n    ull key=0;\n    for(int j=0;j<w;j++){\n      key=key*B+U[i][j];\n    }\n    target=target*A+key;\n  }\n\n  ull C=1;\n  for(int i=0;i<w;i++)C*=B;\n  \n  for(int i=0;i<H;i++){\n    ull key=0;\n    for(int j=0;j<W;j++){\n      key=key*B+T[i][j];\n      if(j-w>=0)key-=T[i][j-w]*C;\n      t[i][j]=key;\n    }\n  }\n  \n  C=1;\n  for(int i=0;i<h;i++)C*=A;\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(i)t[i][j]+=t[i-1][j]*A;\n      if(i-h>=0)t[i][j]-=t[i-h][j]*C;\n      if(t[i][j]==target){\n        if(i-h+1>=0&&j-w+1>=0)\n          printf(\"%d %d\\n\",i-h+1,j-w+1);\n      }\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main()\n{\n  int h,w; cin >> h >> w;\n  vector<vector<int> > a(h,vector<int>(w,0));\n  REP(i,h)\n  {\n    string s; cin >> s;\n    REP(j,w) a[i][j] = s[j]-'0';\n  }\n  int r,c; cin >> r >> c;\n  vector<vector<int> > b(r,vector<int>(c,0));\n  REP(i,r)\n  {\n    string s; cin >> s;\n    REP(j,c) b[i][j] = s[j]-'0';\n  }\n  REP(i,h-r+1) REP(j,w-c+1)\n  {\n    bool f = true;\n    REP(k,r) REP(l,c) if(a[i+k][j+l]!=b[k][l])\n    {\n      f = false;\n      break;\n    }\n    if(f) cout << i << \" \" << j << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash2D{\n  struct RollingHash{\n    string S;\n    ull B;\n    vector<ull> hash,p;\n    int len;\n    RollingHash(){}\n    RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n    void init(){\n      len=S.length();\n      hash.resize(len+1);\n      p.resize(len+1);\n      hash[0]=0;p[0]=1;\n      for(int i=0;i<len;i++){\n\thash[i+1]=hash[i]*B+S[i];\n\tp[i+1]=p[i]*B;\n      }\n    }\n  //S[l,r)\n    ull find(int l,int r){\n      return hash[r]-hash[l]*p[r-l];\n    }\n  };\n  vector<string> S;\n  vector<RollingHash> rh;\n  vector<vector<ull> > hash;\n  vector<ull> p;\n  int h,w,r,c;\n  ull B;\n  RollingHash2D(){}\n  RollingHash2D(vector<string> S,int r,int c,ull B=1000000009LL):S(S),r(r),c(c),B(B){init();};\n  void init(){\n    h=S.size();\n    w=S[0].size();\n    hash.resize(h+1,vector<ull>(w-c+1,0));\n    rh.resize(h);\n    for(int i=0;i<h;i++) rh[i]=RollingHash(S[i]);\n    p.resize(h+1);\n    p[0]=1;\n    for(int i=0;i<h;i++) p[i+1]=p[i]*B;\n    for(int j=0;j<w-c+1;j++){\n      hash[0][j]=0;\t\t    \n      for(int i=0;i<h;i++)\n\thash[i+1][j]=hash[i][j]*B+rh[i].find(j,j+c);\n    }\n  }\n  //S[l,r)\n  ull find(int i,int j){\n    return hash[i+r][j]-hash[i][j]*p[r];\n  }\n};\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(int i=0;i<h;i++) cin>>s[i];\n  int r,c;\n  cin>>r>>c;\n  vector<string> t(r);\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash2D srh(s,r,c);\n  RollingHash2D trh(t,r,c);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      if(srh.find(i,j)==trh.find(0,0)) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1125899906842624LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W; char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '0') { x[i][j] = 0; }\n\t\t\tif (c == '1') { x[i][j] = 1; }\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '0') { y[i][j] = 0; }\n\t\t\tif (c == '1') { y[i][j] = 1; }\n\t\t\tsum *= 2; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 2; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 50) {\n\t\t\t\tlong long c1 = MOD - ((1LL << (M - 1))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 2;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T;\n    char P[1000];\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n\n    long long hash[1000][1000];\n    long long s;\n\n    for(i = 0; i < R; i++){\n        s = 0;\n        scanf(\"%s\", P);\n        for(j = 0; j < C; j++){\n            s = (s * A + P[j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * A + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\tdelete [] T; delete [] P;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst ULL B[] = { 999999937ULL,1000000007ULL, };\n\nconst int MAX_SIZE = 1000;\n\nint h, w, r, c;\n\nchar field[MAX_SIZE][MAX_SIZE];//検索対象\nchar patterns[MAX_SIZE][MAX_SIZE];//検索パターン\n\nULL Hash[MAX_SIZE][MAX_SIZE], tmp[MAX_SIZE][MAX_SIZE];\n\n//aのP*Qの部分に関するハッシュを計算\nvoid compute_hash(char a[MAX_SIZE][MAX_SIZE], int n, int m) {\n\tULL t0 = 1;//B0のQ乗\n\tfor (int j = 0; j < c; j++) t0 *= B[0];\n\n\t//行方向にハッシュ値を計算\n\tfor (int i = 0; i < n; i++) {\n\t\tULL e = 0;\n\t\tfor (int j = 0; j < c; j++)e = e*B[0] + a[i][j];\n\n\t\tfor (int j = 0; j + c <= m; j++) {\n\t\t\ttmp[i][j] = e;\n\t\t\tif (j + c < m)e = e*B[0] - t0*a[i][j] + a[i][j + c];\n\t\t}\n\t}\n\n\tULL t2 = 1;//B2のp乗\n\tfor (int i = 0; i < r; i++)t2 *= B[2];\n\n\t//列方向にハッシュ値を計算\n\tfor (int j = 0; j + c <= m; j++) {\n\t\tULL e = 0;\n\t\tfor (int i = 0; i < r; i++)e = e*B[2] + tmp[i][j];\n\n\t\tfor (int i = 0; i + r <= n; i++) {\n\t\t\tHash[i][j] = e;\n\t\t\tif (i + r < n)e = e*B[2] - t2*tmp[i][j] + tmp[i + r][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> h >> w;\n\tREP(i, h)REP(j, w)cin >> field[i][j];\n\tcin >> r >> c;\n\tREP(i, r)REP(j, c)cin >> patterns[i][j];\n\tcompute_hash(patterns, r, c);\n\tULL HashP = Hash[0][0];\n\t\n\tcompute_hash(field, h, w);\n\tfor (int i = 0; i + r <= h; i++) {\n\t\tfor (int j = 0; j + c <= w; j++) {\n\t\t\tif (HashP == Hash[i][j]) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define HashConst 128\n#define HashMax 128456903\n\nlong long int powerdiv(long long int a, int b){\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tif (b == 2) return a*a % HashMax;\n\tif (b % 2 == 0) {\n\t\tlong long int dum = powerdiv(a, b/2);\n\t\treturn dum * dum % HashMax;\n\t}\n\tif (b % 2 != 0) {\n\t\tlong long int dum = powerdiv(a, (b - 1)/2);\n\t\treturn (dum * dum % HashMax) * a % HashMax;\n\t}\n\treturn 0;\n}\n\nlong long int modP(long long int a){\n\tlong long int res = a % HashMax;\n\tif (res < 0) return res + HashMax;\n\treturn res;\n}\n\nvoid RabinKarp(vector< vector<char> > T, vector< vector<char> > P, int H, int W, int R, int C){\n\t\n\tif (H < R || W < C) return;\n\n\tlong long int hashconst1 = powerdiv(HashConst, R * C - C);\n\tlong long int hashconst2 = powerdiv(HashConst, C);\n\tlong long int hashconst3 = powerdiv(HashConst, C - 1);\n\n\tlong long int P_Hash = 0;\n\tfor (int i = 0; i < R; i++){\n\t\tfor (int j = 0; j < C; j++){\n\t\t\tP_Hash = modP(P_Hash * HashConst + P[i][j]);\n\t\t}\n\t}\n\n\tlong long int T_Hash_Top = 0;\n\n\tfor (int i = 0; i < R; i++){\n\t\tfor (int j = 0; j < C; j++){\n\t\t\tT_Hash_Top = modP(T_Hash_Top * HashConst + T[i][j]);\n\t\t}\n\t}\n\n\tlong long int T_Hash = T_Hash_Top;\n\n\tfor (int i = 0; i < H - R + 1; i++){\n\t\tfor (int j = 0; j < W - C + 1; j++){\n\t\t\tlong long int minusdif = 0;\n\t\t\tlong long int plusdif = 0;\n\t\t\tif (j == 0){\n\t\t\t\tif (i != 0){\n\t\t\t\t\tfor (int k = 0; k < C; k++){\n\t\t\t\t\t\tminusdif = modP(minusdif * HashConst + T[i - 1][k]);\n\t\t\t\t\t\tplusdif = modP(plusdif * HashConst + T[i + R - 1][k]);\n\t\t\t\t\t}\n\t\t\t\t\tT_Hash = modP((T_Hash_Top - modP(minusdif * hashconst1)) * hashconst2 + plusdif);\n\t\t\t\t\tT_Hash_Top = T_Hash;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor (int k = 0; k < R; k++){\n\t\t\t\t\tminusdif = modP(minusdif * hashconst2 + T[i + k][j - 1]);\n\t\t\t\t\tplusdif = modP(plusdif * hashconst2 + T[i + k][j + C - 1]);\n\t\t\t\t}\n\t\t\t\tT_Hash = modP((T_Hash - modP(minusdif * hashconst3)) * HashConst + plusdif);\n\t\t\t}\n\t\t\tif (T_Hash == P_Hash) cout << i << \" \" << j << endl;\n\t\t\t//cout <<T_Hash<<endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tint H, W, R, C;\n\t\n\tcin >> H >> W;\n\tvector< vector<char> > Field(H, vector<char>(W, 0));\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tscanf(\" %c\", &Field[i][j]);\n\t\t}\n\t}\n\tcin >> R >> C;\n\tvector< vector<char> > Pattern(R, vector<char>(C, 0));\n\tfor (int i = 0; i < R; i++){\n\t\tfor (int j = 0; j < C; j++){\n\t\t\tscanf(\" %c\", &Pattern[i][j]);\n\t\t}\n\t}\n\t\n\tRabinKarp(Field, Pattern, H, W, R, C);\n\t\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\nchar s[MAX][MAX];\nchar a[MAX][MAX];\nint h,w,r,c;\n\nvector<pair<int,int>> match2d()\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash;\n\tull tmpa[MAX]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmpa[i]=tmpa[i]*B1+a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tahash=ahash*B2+tmpa[i];\n\t}\n\t\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d();\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(int i=0;i<m.size();i++)\n\t{\n\t\tcout<<m[i].first<<\" \"<<m[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash2D{\n  struct RollingHash{\n    string S;\n    ull B;\n    vector<ull> hash,p;\n    int len;\n    RollingHash(){}\n    RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n    void init(){\n      len=S.length();\n      hash.resize(len+1);\n      p.resize(len+1);\n      hash[0]=0;p[0]=1;\n      for(int i=0;i<len;i++){\n\thash[i+1]=hash[i]*B+S[i];\n\tp[i+1]=p[i]*B;\n      }\n    }\n  //S[l,r)\n    ull find(int l,int r){\n      return hash[r]-hash[l]*p[r-l];\n    }\n  };\n  vector<string> S;\n  vector<RollingHash> rh;\n  vector<vector<ull> > hash;\n  vector<ull> p;\n  int h,w,r,c;\n  ull B;\n  RollingHash2D(){}\n  RollingHash2D(vector<string> S,int r,int c,ull B=1000000009LL):S(S),r(r),c(c),B(B){init();};\n  void init(){\n    h=S.size();\n    w=S[0].size();\n    hash.resize(h+1,vector<ull>(w-c+1,0));\n    rh.resize(h);\n    for(int i=0;i<h;i++) rh[i]=RollingHash(S[i]);\n    p.resize(h+1);\n    p[0]=1;\n    for(int i=0;i<h;i++) p[i+1]=p[i]*B;\n    for(int j=0;j<w-c+1;j++){\n      hash[0][j]=0;\t\t    \n      for(int i=0;i<h;i++)\n\thash[i+1][j]=hash[i][j]*B+rh[i].find(j,j+c);\n    }\n  }\n  //S[l,r)\n  ull find(int i,int j){\n    return hash[i+r][j]-hash[i][j]*p[r];\n  }\n};\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(int i=0;i<h;i++) cin>>s[i];\n  int r,c;\n  cin>>r>>c;\n  vector<string> t(r);\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash2D srh(s,r,c);\n  RollingHash2D trh(t,r,c);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      if(srh.find(i,j)==trh.find(0,0)) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\n// 行方向の和を保持する配列 ( 配列の要素No.から, 検索パターンの文字数分の和を格納する )\nlong ary_SumHW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズは, ary_HW[]より小さくなる\n\n// 行方向の和を保持する配列 ( 検索パターン側は, 行ごとの和のみで良い )\nlong ary_SumRC[MAX_ROW];\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        ary_SumRC[i] = 0;\n\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n\n            // 行ごとの和を求める\n            ary_SumRC[i] += ary_RC[i][j];\n        }\n    }\n\n    // ***************\n    // 各行の和を求める\n    // ***************\n    for(int i = 0; i < H; i++)\n    {\n        // 残りの要素が C 以下なら計算不要\n        for(int j = 0; j < W - C + 1; j++)\n        {\n            if( j == 0 )\n            {\n                ary_SumHW[i][j] = 0;\n\n                for(int k = 0; k < C; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_SumHW[i][j] += ary_HW[i][k];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, C個先の値を足しておく\n                ary_SumHW[i][j] = ary_SumHW[i][j - 1] - ary_HW[i][j - 1] + ary_HW[i][j + C - 1];\n            }\n        }\n    }\n\n    // パターン検索を実施する\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // // 行方向の和を確認\n            if( ary_SumHW[hPos][wPos] == ary_SumRC[0] )\n            {\n                bool searchGo = true;\n\n                // 全行の和を確認\n                for(int i = 1; i < R; i++)\n                {\n                    if( ary_SumHW[hPos + i][wPos] != ary_SumRC[i] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == true )\n                {\n                    // 文字パターンの検索を実施する\n                    patternMatching(hPos, wPos);\n                }\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の箇所が見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_T 10\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 100000007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i <= N ; i++){\n        for(int j = 0 ; j <= M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long hira;\nint ho,res,ha,rus;\nstring ryo[1000],sawa[1000];\nhira x=1,y=1,AB[1000][1000],CIS[1000][1000],EF[1000],IS=0;\n \nint main(){\n  cin>>ho>>res;\n  for(int i=0;i<ho;i++)cin>>ryo[i];\n  cin>>ha>>rus;\n  for(int i=0;i<ha;i++)cin>>sawa[i];\n   \n  for(int i=0;i<rus;i++)x*=131;\n  for(int i=0;i<ha;i++)y*=2000;\n   \n  for(int i=0;i<ha;i++)\n    for(int j=0;j<rus;j++)\n      EF[i]=EF[i]*131+sawa[i][j];\n   \n  for(int i=0;i<ha;i++)IS=IS*2000+EF[i];\n   \n  for(int i=0;i<ho;i++){\n    AB[i][0]=ryo[i][0];\n    for(int j=1;j<rus;j++)AB[i][j]=AB[i][j-1]*131+ryo[i][j];\n    for(int j=rus;j<res;j++)\n      AB[i][j]=AB[i][j-1]*131-x*ryo[i][j-rus]+ryo[i][j];\n  }\n   \n  for(int j=rus-1;j<res;j++){\n    CIS[0][j]=AB[0][j];\n    for(int i=1;i<ha;i++)CIS[i][j]=CIS[i-1][j]*2000+AB[i][j];\n    for(int i=ha;i<ho;i++){\n      CIS[i][j]=CIS[i-1][j]*2000-y*AB[i-ha][j]+AB[i][j];\n    }\n  }\n  for(int i=0;i<ho;i++){\n    for(int j=0;j<res;j++){\n      if(CIS[i][j]==IS){\n    printf(\"%d %d\\n\",i-ha+1  , j-rus+1);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<string>\n\n#define MAX 1000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint H,W,R,C;\nchar field[MAX][MAX]; //????´¢????±?\nchar pattern[MAX][MAX]; //????????????\n\null hashh[MAX][MAX],temp[MAX][MAX];\null target;\n\n//a???R*C?????¨??????hash????¨????\nvoid compute_hash(char a[MAX][MAX], int n, int m){\n\tconst ull B1=9973;\n\tconst ull B2=100000007;\n\t\n\tull t1=1;//B1???C???\n\tfor(int i=0;i<C;i++) t1*=B1;\n\t//????????????hash????¨????\n\tfor(int i=0;i<n;i++){\n\t\tull e=0;\n\t\tfor(int j=0;j<C;j++) e=e*B1+a[i][j];\n\t\tfor(int j=0;C+j<=m;j++){\n\t\t\ttemp[i][j]=e;\n\t\t\te=e*B1-t1*a[i][j]+a[i][j+C];\n\t\t}\n\t}\n\tull t2=1;//B2???R???\n\tfor(int i=0;i<R;i++) t2*=B2;\n\tfor(int j=0;j+C<=m;j++){\n\t\tull e=0;\n\t\tfor(int i=0;i<R;i++) e=e*B2+temp[i][j];\n\t\tfor(int i=0;i+R<=n;i++){\n\t\t\thashh[i][j]=e;\n\t\t\te=e*B2-t2*temp[i][j]+temp[i+R][j];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcompute_hash(pattern,R,C);//pattern???hash???????±???????\n\ttarget=hashh[0][0];\n\tcompute_hash(field,H,W);//field???hash???????±???????\n\t//target??¨?????´??????hash??????search\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(target==hashh[i][j])\n\t\t\tprintf(\"%d %d\\n\",i,j);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&H,&W);\n\tcin.ignore();\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%c\",&field[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tscanf(\"%d %d\",&R,&C);\n\tcin.ignore();\n\tfor(int i=0;i<R;i++){\n\t\tfor(int j=0;j<C;j++){\n\t\t\tscanf(\"%c\",&pattern[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tif(H>=R&&W>=C)\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[1000][1000];\n\tlong long has_P[300][300];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + has_P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"%d %d\\n\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD=1e9+7;\nconst long long BASE1=0x234567, BASE2=0x3456795;\n\nlong long modpow(long long b, long long e, long long p=MOD) {\n    /* Exponentiation by squaring */\n    // returns n == b**e (mod p)\n    long long n=1, a=b%p;\n    while (e) {\n        if (e & 1)\n            (n *= a) %= p;\n\n        (a *= a) %= p;\n        e >>= 1;\n    }\n    return n;\n}\n\nlong long modsub(long long a, long long b, long long p=MOD) {\n    // returns n == a-b (mod p)\n    return ((a-b)%p+p) % p;\n}\n\nint main() {\n    size_t H, W;\n    scanf(\"%zu %zu\", &H, &W);\n    vector<string> F(H);\n    for (size_t i=0; i<H; ++i) {\n        char buf[1<<10];\n        scanf(\"%s\", buf);\n        F[i] = buf;\n    }\n\n    size_t R, C;\n    scanf(\"%zu %zu\", &R, &C);\n    vector<string> G(R);\n    for (size_t i=0; i<R; ++i) {\n        char buf[1<<10];\n        scanf(\"%s\", buf);\n        G[i] = buf;\n    }\n\n    long long target=0;\n    for (size_t i=0; i<R; ++i) {\n        long long key=0;\n        for (size_t j=0; j<C; ++j)\n            ((key *= BASE2) += G[i][j]) %= MOD;\n\n        ((target *= BASE1) += key) %= MOD;\n    }\n\n    vector<vector<long long>> t1(H, vector<long long>(W));\n    vector<vector<long long>> t2(H, vector<long long>(W));\n    long long pow=modpow(BASE2, C, MOD);\n    for (size_t i=0; i<H; ++i) {\n        long long key=0;\n        for (size_t j=0; j<W; ++j) {\n            ((key *= BASE2) += F[i][j]) %= MOD;\n            if (j >= C)\n                key = modsub(key, F[i][j-C]*pow, MOD);\n\n            t1[i][j] = t2[i][j] = key;\n        }\n    }\n\n    pow = modpow(BASE1, R, MOD);\n    for (size_t i=0; i<H; ++i)\n        for (size_t j=0; j<W; ++j) {\n            if (i)\n                (t1[i][j] += t1[i-1][j]*BASE1) %= MOD;\n\n            if (i >= R)\n                t1[i][j] = modsub(t1[i][j], t2[i-R][j]*pow, MOD);\n\n            if (t1[i][j]==target && i+1>=R && j+1>=C)\n                printf(\"%zu %zu\\n\", i-R+1, j-C+1);\n        }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\nchar s[MAX][MAX];\nchar a[MAX][MAX];\nint h,w,r,c;\n\nvector<pair<int,int>> match2d()\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash;\n\tull tmpa[MAX]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmpa[0]=tmpa[i]*B1+a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tahash=ahash*B2+tmpa[i];\n\t}\n\t\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d();\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(int i=0;i<m.size();i++)\n\t{\n\t\tcout<<m[i].first<<\" \"<<m[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W, R, C;\n\n\tcin >> H >> W;\n\n\tvector<string> p1(H);\n\n\tfor (int i = 0; i < H; i++) { cin >> p1[i]; }\n\n\tcin >> R >> C;\n\n\tvector<string> p2(R);\n\n\tfor (int i = 0; i < R; i++) { cin >> p2[i]; }\n\n\tfor (int i = 0; i <= H - R; i++)\n\t{\n\t\tfor (int j = 0; j <= W - C; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < R; k++)\n\t\t\t{\n\t\t\t\tif (p1[i + k].substr(j, C) != p2[k])\n\t\t\t\t{\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d %d\\n\", i, j);\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\nconst ull BASE = 1e9 + 7;\n\nstruct RollingHash {\n\n    ull base1, base2;\n    ull mod1, mod2;\n    vector<ull> hash1, hash2;\n    vector<ull> pow1, pow2;\n\n    RollingHash() : base1(9973), base2(1000000000 + 7), mod1(999999937), mod2(1000000000 + 7) {}\n\n    void construct(const string &s) {\n        int n = s.size();\n\n        hash1.assign(n + 1, 0);\n        hash2.assign(n + 1, 0);\n        pow1.assign(n + 1, 1);\n        pow2.assign(n + 1, 1);\n\n        for (int i = 0; i < n;i++) {\n            hash1[i + 1] = (hash1[i] + s[i]) * base1;\n            hash2[i + 1] = (hash2[i] + s[i]) * base2;\n            pow1[i + 1] = pow1[i] * base1;\n            pow2[i + 1] = pow2[i] * base2;\n        }\n    }\n    //[l, r)\n    pullull get(int l, int r) {\n        ull t1 = hash1[r] - hash1[l] * pow1[r - l];\n        ull t2 = hash2[r] - hash2[l] * pow2[r - l];\n        return make_pair(t1, t2);\n    }\n\n    bool match(int l1, int r1, int l2, int r2) {\n        return get(l1, r1) == get(l2, r2) ? true : false;\n    }\n};\n\nint h, w, r, c;\nstring t[1005], p[1005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    rep(i, h) cin >> t[i];\n    cin >> r >> c;\n    rep(i, r) cin >> p[i];\n    if (h < r || w < c) exit(0);\n\n    RollingHash t_yoko[1005], p_yoko[1005];\n    vector<vector<ull>> t_tate(1005, vector<ull>(1005, 0));\n    ull p_hs = 0;\n    rep(i, h) t_yoko[i].construct(t[i]);\n    rep(i, r) p_yoko[i].construct(p[i]);\n    rep(i, r) p_hs = (p_hs + p_yoko[i].hash1[c]) * (1000000000 + 7);\n    rep(j, w - c + 1) {\n        rep(i, h) {\n            pair<ull, ull> pt_hs = t_yoko[i].get(j, j + c);\n            t_tate[i + 1][j] = (t_tate[i][j] + pt_hs.fi) * (1000000000 + 7);\n        }\n    }\n    ull pw[1005];\n    pw[0] = 1;\n    rep2(i, 1, 1005) pw[i] = pw[i - 1] * (1000000000 + 7);\n    rep(i, h - r + 1)rep(j, w - c + 1) {\n        ull t_hs = t_tate[i + r][j] - t_tate[i][j] * pw[r];\n        if (t_hs == p_hs) cout << i << \" \" << j << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define BASE1 124248592\n#define BASE2 163282852\n#define MOD 197436252\n\nlong long hash_temp[1000][1000], hash_field[1000][1000], hash_pattern[1000][1000];\n\nvoid gen_hash(string str[], int H, int W, int R, int C, long long hash[][1000]) {\n    for (int i = 0; i < H; i++) {\n        long long temp = 0, multi = 1;\n        for (int j = 0; j < W; j++) {\n            temp = (temp * BASE1 + str[i][j]) % MOD;\n            if (j < C) {\n                multi = multi * BASE1 % MOD;\n            }\n            else {\n                temp = ((temp - str[i][j - C] * multi) % MOD + MOD) % MOD;\n            }\n            hash_temp[i][j] = temp;\n        }\n    }\n    for (int j = 0; j < W; j++) {\n        long long temp = 0, multi = 1;\n        for (int i = 0; i < H; i++) {\n            temp = (temp * BASE2 + hash_temp[i][j]) % MOD;\n            if (i < R) {\n                multi = multi * BASE2 % MOD;\n            }\n            else {\n                temp = ((temp -hash_temp[i - R][j] * multi) % MOD + MOD) % MOD;\n            }\n            hash[i][j] = temp;\n        }\n    }\n}\n\nint main() {\n    int H, W, R, C;\n    string field[1000], pattern[1000];\n\n    cin >> H >> W;\n    for (int i = 0; i < H; i++) {\n        cin >> field[i];\n    }\n    cin >> R >> C;\n    for (int i = 0; i < R; i++) {\n        cin >> pattern[i];\n    }\n\n    gen_hash(field, H, W, R, C, hash_field);\n    gen_hash(pattern, R, C, R, C, hash_pattern);\n    \n    for (int i = R - 1; i < H; i++) {\n        for (int j = C - 1; j < W; j++) {\n            if (hash_field[i][j] == hash_pattern[R - 1][C - 1]) {\n                cout << i - R + 1 << \" \" << j - C + 1 << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\null hash2d(char a[MAX][MAX],int r,int c)\n{\n\tull tmp[r]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmp[i]=tmp[i]*B1+a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<r;i++)\n\t{\n\t\ttmp[0]=tmp[0]*B2+tmp[i];\n\t}\n\treturn tmp[0];\n}\n\nvector<pair<int,int>> match2d(char s[MAX][MAX],char a[MAX][MAX],int h,int w,int r,int c)\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash=hash2d(a,r,c);\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tchar s[MAX][MAX];\n\tchar a[MAX][MAX];\n\tint h,w,r,c;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d(s,a,h,w,r,c);\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1110\n#define MAX_T 10\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 100000007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n//Modified case lByokoP,lMyokoP,ptnP\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point == -1){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){ //ADD\n\t\t\t\t\t\t\t\t\tif(T[row][col+tmp_col]!=P[0][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tif(T[0][0]==P[0][0]){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RollingHash2D{\n  typedef unsigned long long ull;\n  \n  struct RollingHash{\n    typedef unsigned long long ull;\n    string S;\n    ull B;\n    int len;\n    vector<ull> hash,p;\n    RollingHash(){}\n    RollingHash(string S_,ull B_=1000000007LL):\n      S(S_),B(B_),len(S.length()),hash(len+1),p(len+1){\n      hash[0]=0;p[0]=1;\n      for(int i=0;i<len;i++){\n\thash[i+1]=hash[i]*B+S[i];\n\tp[i+1]=p[i]*B;\n      }\n    }\n    //S[l,r)\n    ull find(int l,int r){\n      return hash[r]-hash[l]*p[r-l];\n    }\n  };\n  \n  vector<string> S;\n  int h,w,r,c;\n  ull B;\n  vector<ull> p;\n  vector<vector<ull> > hash;\n  vector<RollingHash> rh;\n  RollingHash2D(){}\n  RollingHash2D(vector<string> S_,int r_,int c_,ull B_=1000000009LL):\n    S(S_),h(S_.size()),w(S_[0].size()),r(r_),c(c_),B(B_),\n    p(h+1),hash(h+1,vector<ull>(w-c+1,0)),rh(h){\n    for(int i=0;i<h;i++) rh[i]=RollingHash(S[i]);\n    p[0]=1;\n    for(int i=0;i<h;i++) p[i+1]=p[i]*B;\n    for(int j=0;j<w-c+1;j++){\n      hash[0][j]=0;\t\t    \n      for(int i=0;i<h;i++)\n\thash[i+1][j]=hash[i][j]*B+rh[i].find(j,j+c);\n    }\n  }\n  //[i,i+r) * [j,j+c)\n  ull find(int i,int j){\n    return hash[i+r][j]-hash[i][j]*p[r];\n  }\n};\n\nint main() {\n  int H, W;\n  cin >> H >> W;\n  \n  vector<string> T(H);\n  for ( int i = 0; i < H; i++ ) cin >> T[i];\n\n  int R, C;\n  cin >> R >> C;\n  \n  vector<string> P(R);\n  for ( int i = 0; i < R; i++ ) cin >> P[i];\n\n  RollingHash2D rht(T, R, C), rhp(P, R, C);\n  for ( int i = 0; i <= H-R; i++ ) {\n    for ( int j = 0; j <= W-C; j++ ) {\n      if ( rht.find(i, j) == rhp.find(0, 0) )\n\tcout << i << \" \" << j << endl;      \n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            if( ary_HW[i][j] == ary_RC[0][0] )\n            {\n                // 先頭文字を比較\n                patternMatching(i, j);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    hEnd = hPos + ( R - 1 );\n    wEnd = wPos + ( C - 1 );\n\n    if( hEnd > H - 1 || wEnd > W - 1 )\n    {\n        // 配列の範囲をオーバーしているので, 検索不要\n        return;\n    }\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\tif (t >= 500 && k >= 100) {\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long hira;\nint ho,res,ha,rus;\nstring ryo[1005],sawa[1005];\nhira x=1,y=1,AB[1005][1005],CIS[1005][1005],EF[1005],IS=0;\n \nint main(){\n  cin>>ho>>res;\n  for(int i=0;i<ho;i++)cin>>ryo[i];\n  cin>>ha>>rus;\n  for(int i=0;i<ha;i++)cin>>sawa[i];\n   \n  for(int i=0;i<rus;i++)x*=131;\n  for(int i=0;i<ha;i++)y*=2000;\n   \n  for(int i=0;i<ha;i++)\n    for(int j=0;j<rus;j++)\n      EF[i]=EF[i]*131+sawa[i][j];\n   \n  for(int i=0;i<ha;i++)IS=IS*2000+EF[i];\n   \n  for(int i=0;i<ho;i++){\n    AB[i][0]=ryo[i][0];\n    for(int j=1;j<rus;j++)AB[i][j]=AB[i][j-1]*131+ryo[i][j];\n    for(int j=rus;j<res;j++)\n      AB[i][j]=AB[i][j-1]*131-x*ryo[i][j-rus]+ryo[i][j];\n  }\n   \n  for(int j=rus-1;j<res;j++){\n    CIS[0][j]=AB[0][j];\n    for(int i=1;i<ha;i++)CIS[i][j]=CIS[i-1][j]*2000+AB[i][j];\n    for(int i=ha;i<ho;i++){\n      CIS[i][j]=CIS[i-1][j]*2000-y*AB[i-ha][j]+AB[i][j];\n    }\n  }\n  for(int i=0;i<ho;i++){\n    for(int j=0;j<res;j++){\n      if(CIS[i][j]==IS){\n    printf(\"%d %d\\n\",i-ha+1  , j-rus+1);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_C\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n\tint H, W, R, C;\n\tvector<string> T, P;\n\tstring str;\n\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++){\n\t\tcin>>str;\n\t\tT.push_back(str);\n\t}\n\n\tcin>>R>>C;\n\tfor(int i=0;i<R;i++){\n\t\tcin>>str;\n\t\tP.push_back(str);\n\t}\n\n\tif((H>=R) && (W>=C))\n\t\tfor(int i=0;i<=H-R;i++)\n\t\t\tfor(int j=0;j<=W-C;j++)\n\t\t\t\tif(T[i].substr(j, P[0].length()) == P[0])\n\t\t\t\t\tfor(int k=i+1;k<R;k++)\n\t\t\t\t\t\tif(T[k].substr(j, P[k-i].length()) == P[k-i])\n\t\t\t\t\t\t\tif(k == R-1)\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 950527\n#define base2 1777771\nusing namespace std;\ntypedef unsigned long long ull;\null a[1001][1001],b[1001][1001],A[1001][1001],tmp[1001][1001],ans;\n\n\nvoid Reverse(int p){for(int i=0;i<p;i++)reverse(b[i],b[i]+p);}\n\nvoid rol_90(int p){\n  for(int i=0;i<p;i++)\n    for(int j=0;j<p;j++) tmp[p-j-1][i]=b[i][j];\n  \n  for(int i=0;i<p;i++)\n    for(int j=0;j<p;j++) b[i][j]=tmp[i][j];\n}\n\null ctoi(char ch){\n  if('A'<=ch&&ch<='Z') return ch-'A';\n  if('a'<=ch&&ch<='z') return 26+ch-'a';\n  if(isdigit(ch)) return 52+ch-'0';\n  if(ch=='+') return 62;\n  return 63;\n}\n\nvoid in(int w,int h,ull tmp[1001][1001]){\n  string str[1001];\n  for(int i=0;i<h;i++) cin>>str[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<(int)str[i].size();j++){\n      int num=ctoi(str[i][j]);\n      for(int k=0;k<6;k++)tmp[i][6*j+5-k]=num&1,num/=2;\n    }\n}\n\nset <ull> S;\nvoid roll_hs(int w,int h,int p){\n  ull target=0;\n  for(int i=0;i<p;i++){\n    ull k=0;\n    for(int j=0;j<p;j++)k=k*base+b[i][j];\n    target=target*base2+k; \n  }\n  \n  if(S.count(target))return;\n  S.insert(target);\n  \n  memset(A,0,sizeof(0));\n  for(int i=0;i<h;i++){\n    ull k=0,l=1;\n    for(int j=0;j<w;j++){\n      k=k*base+a[i][j];\n      if(j-p>=0) k-=l*a[i][j-p];\n      else l*=base;\n      A[i][j]=k;\n    }\n  }\n\n  for(int j=p-1;j<w;j++){\n    ull k=0,l=1;\n    for(int i=0;i<h;i++){\n      k=k*base2+A[i][j];\n      if(i-p>=0) k-=l*A[i-p][j];\n      else l*=base2;\n      if(target==k&&i>=p-1)ans++;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    int w,h,p;\n    cin>>w>>h>>p;\n    if(!w&&!h&&!p)break;\n    in(w,h,a),in(p,p,b);\n\n    \n    ans=0,S.clear();\n    for(int i=0;i<4;i++){\n      rol_90(p),roll_hs(w,h,p); \n      Reverse(p),roll_hs(w,h,p),Reverse(p);\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <sstream>\n\nusing namespace std;\n\nint main (void)\n{\n\tlong n,m,r,c;\n\tstring a[2000],b[2000];\n\tcin >> n >> m;\n\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tcin >> r >> c;\n\n\tfor (long j = 0; j < r; j++)\n\t{\n\t\tcin >> b[j];\n\t}\n\n\tfor (long i = 0; i < n - r + 1; i++)\n\t{\n\t\tfor (long k = 0; k < m - c + 1; k++)\n\t\t{\n\t\t\tif (a[i].substr(k,c) == b[0])\n\t\t\t{\n\t\t\t\tfor (long j = 0; j < r; j++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i + j].substr(k,c) != b[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (j == r - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << i << \" \" << k << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<string>\n\n#define MAX 1000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint H,W,R,C;\nchar field[MAX][MAX]; //????´¢????±?\nchar pattern[MAX][MAX]; //????????????\n\null hashh[MAX][MAX],temp[MAX][MAX];\null target;\n\n//a???R*C?????¨??????hash????¨????\nvoid compute_hash(char a[MAX][MAX], int n, int m){\n\tconst ull B1=9973;\n\tconst ull B2=100000007;\n\t\n\tull t1=1;//B1???C???\n\tfor(int i=0;i<C;i++) t1*=B1;\n\t//????????????hash????¨????\n\tfor(int i=0;i<n;i++){\n\t\tull e=0;\n\t\tfor(int j=0;j<C;j++) e=e*B1+a[i][j];\n\t\tfor(int j=0;C+j<=m;j++){\n\t\t\ttemp[i][j]=e;\n\t\t\te=e*B1-t1*a[i][j]+a[i][j+C];\n\t\t}\n\t}\n\tull t2=1;//B2???R???\n\tfor(int i=0;i<R;i++) t2*=B2;\n\tfor(int j=0;j+C<=m;j++){\n\t\tull e=0;\n\t\tfor(int i=0;i<R;i++) e=e*B2+temp[i][j];\n\t\tfor(int i=0;i+R<=n;i++){\n\t\t\thashh[i][j]=e;\n\t\t\te=e*B2-t2*temp[i][j]+temp[i+R][j];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcompute_hash(pattern,R,C);//pattern???hash???????±???????\n\ttarget=hashh[0][0];\n\tcompute_hash(field,H,W);//field???hash???????±???????\n\t//target??¨?????´??????hash??????search\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(target==hashh[i][j])\n\t\t\tprintf(\"%d %d\\n\",i,j);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&H,&W);\n\tcin.ignore();\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%c\",&field[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tscanf(\"%d %d\",&R,&C);\n\tcin.ignore();\n\tfor(int i=0;i<R;i++){\n\t\tfor(int j=0;j<C;j++){\n\t\t\tscanf(\"%c\",&pattern[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tif(H>=R&&W>=C)\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst ULL B[] = { 999999937ULL,1000000007ULL, };\n\nconst int MAX_SIZE = 1000;\n\nint h, w, r, c;\n\nchar field[MAX_SIZE][MAX_SIZE];//検索対象\nchar patterns[MAX_SIZE][MAX_SIZE];//検索パターン\n\nULL Hash[MAX_SIZE][MAX_SIZE], tmp[MAX_SIZE][MAX_SIZE];\n\n//aのP*Qの部分に関するハッシュを計算\nvoid compute_hash(char a[MAX_SIZE][MAX_SIZE], int n, int m) {\n\tULL t0 = 1;//B0のQ乗\n\tfor (int j = 0; j < c; j++) t0 *= B[0];\n\n\t//行方向にハッシュ値を計算\n\tfor (int i = 0; i < n; i++) {\n\t\tULL e = 0;\n\t\tfor (int j = 0; j < c; j++)e = e*B[0] + a[i][j];\n\n\t\tfor (int j = 0; j + c <= m; j++) {\n\t\t\ttmp[i][j] = e;\n\t\t\tif (j + c < m)e = e*B[0] - t0*a[i][j] + a[i][j + c];\n\t\t}\n\t}\n\n\tULL t2 = 1;//B2のp乗\n\tfor (int i = 0; i < r; i++)t2 *= B[2];\n\n\t//列方向にハッシュ値を計算\n\tfor (int j = 0; j + c <= m; j++) {\n\t\tULL e = 0;\n\t\tfor (int i = 0; i < r; i++)e = e*B[2] + tmp[i][j];\n\n\t\tfor (int i = 0; i + r <= n; i++) {\n\t\t\tHash[i][j] = e;\n\t\t\tif (i + r < n)e = e*B[2] - t2*tmp[i][j] + tmp[i + r][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> h >> w;\n\tREP(i, h)REP(j, w)cin >> field[i][j];\n\tcin >> r >> c;\n\tREP(i, r)REP(j, c)cin >> patterns[i][j];\n\tcompute_hash(patterns, r, c);\n\tULL HashP = Hash[0][0];\n\t\n\tcompute_hash(field, h, w);\n\tfor (int i = 0; i + r <= h; i++) {\n\t\tfor (int j = 0; j + c <= w; j++) {\n\t\t\tif (HashP == Hash[i][j]) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\t//system(\"pause\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nll genHash(const vector<string> v, int x, int y, int r, int c)\n{\n  ll h = 0;\n  REP(i,r) REP(j,c) h = (h * 401 + v[x+i][y+j])%MOD;\n  return h;\n}\n\nint main()\n{\n  int h,w; cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  int r,c; cin >> r >> c;\n  vector<string> b(r);\n  REP(i,r) cin >> b[i];\n  map<ll,vector<int> > T;\n  REP(i,h-r+1) REP(j,w-c+1)\n    T[genHash(a,i,j,r,c)].push_back(i*w+j);\n  for(auto v : T[genHash(b,0,0,r,c)]) printf(\"%d %d\\n\",v/w,v%w);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename T>\nclass PMA {\nprivate:\n    uint32_t id = 0;\n\npublic:\n    struct Node {\n        uint32_t id;\n        bool accepted = false;\n        unordered_map<T, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const vector<T> &vec) {\n        Node *node = root;\n        for (T v : vec) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[v] = new Node;\n                node->children[v]->id = id++;\n                node = node->children[v];\n            }\n        }\n\n        node->accepted = true;\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, T v) {\n        while (node != nullptr) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                T v = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, v);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\nint main() {\n    int32_t H, W, R, C;\n    scanf(\"%d %d\\n\", &H, &W);\n\n    vector<vector<uint8_t>> T(H);\n    for (int32_t r = 0; r < H; r++) {\n        for (int32_t c = 0; c < W; c++) {\n            T[i][j] = getchar();\n        }\n    }\n\n    cin >> R >> C;\n\n    vector<vector<uint8_t>> P(R);\n    for (int32_t r = 0; r < R; r++) {\n        for (int32_t c = 0; c < C; c++) {\n            P[i][j] = getchar();\n        }\n    }\n\n    PMA<uint8_t> pma_p;\n    vector<uint32_t> M;\n    for (vector<uint8_t> vec : P) M.push_back(pma_p.insert(vec));\n    pma_p.link_failure();\n\n    PMA<uint32_t> pma_m;\n    pma_m.insert(M);\n    pma_m.link_failure();\n\n    vector<vector<uint32_t>> T2(W);\n\n    for (vector<uint8_t> vec : T) {\n        PMA<uint8_t>::Node *node = pma_p.root;\n        for (uint32_t i = 0; i < vec.size(); i++) {\n            node = pma_p.transition(node, vec[i]);\n            T2[i].push_back(node->id);\n        }\n    }\n\n    vector<pair<uint32_t, uint32_t>> res;\n    for (int32_t c = 0; c < W; c++) {\n        PMA<uint32_t>::Node *node = pma_m.root;\n        for (int32_t r = 0; r < H; r++) {\n            node = pma_m.transition(node, T2[c][r]);\n            if (node->accepted) {\n                res.push_back(make_pair(r - R + 1, c - C + 1));\n            }\n        }\n    }\n\n    sort(res.begin(), res.end());\n\n    for (auto p : res) printf(\"%d %d\\n\", p.first, p.second);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[1000][1000];\n\tlong long has_P[500][500];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + has_P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"%d %d\\n\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1777771\nusing namespace std;\ntypedef unsigned long long ull;\null s[1000][1000],p[1000][1000];\null roll[1000][1000],roll2[1000][1000];\nstring s1[1000],p1[1000];\nint main(){\n  int h,w,h1,w1;\n  cin>>h>>w;\n\n  for(int i=0;i<h;i++)cin>>s1[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)s[i][j]=s1[i][j];\n\n  cin>>h1>>w1;\n  for(int i=0;i<h1;i++)cin>>p1[i];\n\n  for(int i=0;i<h1;i++)\n    for(int j=0;j<w1;j++)p[i][j]=p1[i][j]; \n\n\n\n  ull a=0;\n  for(int i=0;i<h1;i++)\n    for(int j=0;j<w1;j++)a=a*N+p[i][j];\n\n  for(int j=0;j<h;j++){\n    ull b=0,g=1;\n    for(int i=0;i<w1;i++)b*=N,b+=s[j][i],g*=N;\n    roll[j][w1-1]=b;\n    for(int i=w1;i<w;i++){\n      b*=N,b+=s[j][i],b-=s[j][i-w1]*g;\n      roll[j][i]=b;\n    }\n  }\n\n  for(int j=w1-1;j<w;j++){\n    ull b=0,g=1,n=1;\n    for(int i=0;i<w1;i++)n*=N;\n    for(int i=0;i<h1;i++)b*=n,b+=roll[i][j],g*=n;\n    roll2[h1-1][j]=b;\n    for(int i=h1;i<h;i++){\n      b*=n,b+=roll[i][j],b-=roll[i-h1][j]*g; \n      roll2[i][j]=b;\n    }\n  }\n\n\n  for(int i=h1-1;i<h;i++)\n    for(int j=w1-1;j<w;j++)\n      if(a==roll2[i][j])printf(\"%d %d\\n\",i-h1+1,j-w1+1);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef unsigned long long ull;\nusing namespace std;\n\nvoid DD_Rolling_Hash(int P, int Q, const vector<vector<char>>& a, vector<vector<ull>>& res) {\n\tconst ull B1 = 9973;\n\tconst ull B2 = 100000007;\n\tvector<vector<ull>> tmp(a.size(), vector<ull>(a[0].size() - Q + 1));\n\tres = vector<vector<ull>>(a.size() - P + 1, vector<ull>(a[0].size() - Q + 1));\n\n\tull t1 = 1;\n\tfor (int j = 0; j < Q; j++) t1 *= B1;\n\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tull e = 0;\n\t\tfor (int j = 0; j < Q; j++) e = e * B1 + a[i][j];\n\n\t\tfor (int j = 0; j + Q <= a[0].size(); j++) {\n\t\t\ttmp[i][j] = e;\n\t\t\tif (j + Q < a[0].size()) e = e * B1 - t1 * a[i][j] + a[i][j + Q];\n\t\t}\n\t}\n\n\tull t2 = 1;\n\tfor (int i = 0; i < P; i++) t2 *= B2;\n\n\tfor (int j = 0; j + Q <= a[0].size(); j++) {\n\t\tull e = 0;\n\t\tfor (int i = 0; i < P; i++) e = e * B2 + tmp[i][j];\n\n\t\tfor (int i = 0; i + P <= a.size(); i++) {\n\t\t\tres[i][j] = e;\n\t\t\tif (i + P < a.size()) e = e * B2 - t2 * tmp[i][j] + tmp[i + P][j];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H, W, R, C;\n\tcin >> H >> W;\n\tvector<vector<char>> a(W, vector<char>(H));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> a[j][i];\n\t\t}\n\t}\n\tcin >> R >> C;\n\tvector<vector<char>> b(C, vector<char>(R));\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> b[j][i];\n\t\t}\n\t}\n\tvector<vector<ull>> res;\n\tDD_Rolling_Hash(C, R, b, res);\n\tull f = res[0][0];\n\tDD_Rolling_Hash(C, R, a, res);\n\tfor (int i = 0; i < res[0].size(); i++) {\n\t\tfor (int j = 0; j < res.size(); j++) {\n\t\t\tif (res[j][i] == f) {\n\t\t\t\tcout << i << ' ' << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1001; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX][N_MAX];\nchar P[N_MAX][N_MAX];\nint H, W, R, C;\n\nint Hash[N_MAX][N_MAX];\nint Bpow[N_MAX][N_MAX];\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%d %d\", &H, &W);\n    rep(i,0,H) {\n        rep(j,0,W) {\n            scanf(\" %c\", &T[i][j]);\n        }\n    }\n    \n    scanf(\"%d %d\", &R, &C);\n    \n    rep(i,0,R) {\n        rep(j,0,C) {\n            scanf(\" %c\", &P[i][j]);\n        }\n    }\n    \n#ifdef debug\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << T[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n    din >> R >> C;\n    rep(i,0,R) {\n        rep(j,0,C) {\n            dout << P[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n#ifdef debug\n    //calc.\n    bool found;\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            found = true;\n            rep(ii,0,R) {\n                rep(jj,0,C) {\n                    if(T[i+ii][j+jj]!=P[ii][jj]) {\n                        found = false;\n                        ii = R;\n                        jj = C;\n                    }\n                }\n            }\n            \n            if(found) {\n                printf(\"%d %d\\n\", i, j);\n            }\n        }\n    }\n    \n    \n    dout << \"============================================\\n\";\n#endif\n    \n    \n    //calc.\n    const int B = 10007;\n    int t = 1;\n    \n    for(int i=R-1; i>=0; i--) {\n        for(int j=C-1; j>=0; j--) {\n            Bpow[i][j] = t;\n            t *= B;\n        }\n    }\n    \n#ifdef debug\n    dout << \"Bpow[][] = \\n\";\n    rep(i,0,R) {\n        rep(j,0,C) {\n            dout << Bpow[i][j] << \" \";\n        }\n        dout << endl;\n    }\n#endif\n    \n    \n    int HashP = 0;\n    rep(i,0,R) {\n        rep(j,0,C) {\n            HashP += P[i][j]*Bpow[i][j];\n        }\n    }\n    \n#ifdef debug\n    disp(HashP);\n#endif\n    \n    int HashT = 0;\n    rep(i,0,R) {\n        rep(j,0,C) {\n            HashT += T[i][j]*Bpow[i][j];\n        }\n    }\n    \n#ifdef debug\n    disp(HashT);\n#endif\n    \n    //search\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            \n            Hash[i][j] = HashT;\n            \n#ifdef debug\n            dout << \"-------------------------\\n\";\n            dout << i << \" \" << j << endl;\n            disp(HashT);\n            disp(HashP);\n            \n            dout << \"Hash[][] = \\n\";\n            rep(i,0,H) {\n                rep(j,0,W) {\n                    dout << Hash[i][j] << \" \";\n                }\n                dout << endl;\n            }\n#endif\n            \n            if(HashT == HashP) {\n                printf(\"%d %d\\n\", i, j);\n#ifdef debug\n                dout << \"//////////////////////////////////////////////////////////////\\n\";\n#endif\n            }\n            \n            if(j+C<W) {\n                HashT *= B;\n                rep(k,i,i+R) {\n                    HashT -= T[k][j]*Bpow[k-i][0]*B;\n                    HashT += T[k][j+C]*Bpow[k-i][C-1];\n                }\n            }\n            else if(i+R<H) { //j+C = W ????????? j=W-C ???????????????j??????????????°???????????´???\n                HashT = Hash[i][0] * Bpow[R-1][0] * B;\n                rep(k,0,C) {\n                    HashT -= T[i][k]*Bpow[0][k]*Bpow[R-1][0]*B;\n                    HashT += T[i+R][k]*Bpow[R-1][k];\n                }\n            }\n            \n        }\n    }\n    \n\n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\nconst int X=14314214;\nconst int Y=4186347;\n\nint bX[1100]={1},bY[1100]={1};\n\nint ban[1100][1100];\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tmod=inf+2;\n\tfor(int i=1;i<=1010;i++){\n\t\tbX[i]=bX[i-1]*X%mod;\n\t\tbY[i]=bY[i-1]*Y%mod;\n\t}\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint t=s[j]-'!';\n\t\t\tban[i][j]=t*bX[i]%mod*bY[j]%mod;\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(i){\n\t\tban[i][j]+=ban[i-1][j];\n\t\tban[i][j]%=mod;\n\t}\n\t\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(j){\n\t\tban[i][j]+=ban[i][j-1];\n\t\tban[i][j]%=mod;\n\t}\n\tint r,c;\n\tcin>>r>>c;\n\tint ans=0;\n\tfor(int i=0;i<r;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint t=s[j]-'!';\n\t\t\tans+=t*bX[i]%mod*bY[j]%mod;\n\t\t\tans%=mod;\n\t\t}\n\t}\n\tfor(int i=0;i<=h-r;i++)for(int j=0;j<=w-c;j++){\n\t\tint q=ban[i+r-1][j+c-1];\n\t\tif(i>0)q+=mod-ban[i-1][j+c-1];\n\t\tif(j>0)q+=mod-ban[i+r-1][j-1];\n\t\tif(i>0&&j>0)q+=ban[i-1][j-1];\n\t\tq%=mod;\n\t\tif(ans*bX[i]%mod*bY[j]%mod==q){\n\t\tcout<<i<<\" \"<<j<<endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull B1 = 9973;\nconst ull B2 = 1000000007;\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n    char a[h][w];\n    for(int i = 0; i < h; i++)  for(int j = 0; j < w; j++)  cin >> a[i][j];\n    int r, c;\n    cin >> r >> c;\n    char b[r][c];\n    for(int i = 0; i < r; i++)  for(int j = 0; j < c; j++)  cin >> b[i][j];\n    \n    ull d[h][w-c+1], hash[h-r+1][w-c+1];\n    ull t1 = 1;\n    for(int i = 0; i < c; i++)  t1 *= B1;\n    for(int i = 0; i < h; i++){\n        ull tmp = 0;\n        for(int j = 0; j < c; j++){\n            tmp = tmp * B1 + a[i][j];\n        }\n        for(int j = 0; j+c <= w; j++){\n            d[i][j] = tmp;\n            if(j+c < w) tmp = tmp*B1 + a[i][j+c] - a[i][j]*t1;\n        }\n    }\n    ull t2 = 1;\n    for(int i = 0; i < r; i++)  t2 *= B2;\n    for(int j = 0; j < w-c+1; j++){\n        ull tmp = 0;\n        for(int i = 0; i < r; i++){\n            tmp = tmp * B2 + d[i][j];\n        }\n        for(int i = 0; i+r <= h; i++){\n            hash[i][j] = tmp;\n            if(i+r < h) tmp = tmp * B2 + d[i+r][j] - d[i][j]*t2;\n        }\n    }\n\n    ull pat[r];\n    for(int i = 0; i < r; i++){\n        pat[i] = 0;\n        for(int j = 0; j < c; j++){\n            pat[i] = pat[i] * B1 + b[i][j];\n        }\n    }\n    ull x = 0;\n    for(int i = 0; i < r; i++){\n        x = x * B2 + pat[i];\n    }\n\n    for(int i = 0; i < h-r+1; i++){\n        for(int j = 0; j < w-c+1; j++){\n            if(hash[i][j] == x){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\n#define HEIGHT 1000\n#define WIDTH 1000\n#define ROW 1000\n#define COL 1000\n\nbool compareText(char **t1, int i0, int j0, char **t2, int row, int col);\n\nint main (void)\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar **field = new char*[h];\n\tfor (int i = 0; i < h; i++) {\n\t\tfield[i] = new char[w];\n\t}\n\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tchar f;\n\t\t\tcin >> f;\n\t\t\tfield[i][j] = f;\n\t\t}\n\t}\n\n\tint r, c;\n\tcin >> r >> c;\n\tchar **pattern = new char*[r];\n\tfor (int i = 0; i < r; i++) {\n\t\tpattern[i] = new char[c];\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tchar p;\n\t\t\tcin >> p;\n\t\t\tpattern[i][j] = p;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= h - r; i++) {\n\t\tfor (int j = 0; j <= w - c; j++) {\n\t\t\tif (compareText(field, i, j, pattern, r, c)) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\n}\n\nbool compareText(char **t1, int i0, int j0, char **t2, int row, int col)\n{\n\tfor (int i = 0; i < row; i++) {\n\t\tfor (int j = 0; j < col; j++) {\n\t\t\tif (t1[i0 + i][j0 + j] != t2[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n     \n     \nusing namespace std;\n     \nstruct AhoCorasick {\n     \n  static const int ALPHABET_SIZE = 62, root=0;\n     \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n       \n  int N; // num of node\n     \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n     \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n     \n  vector<Node> nodes;\n     \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n     \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] == -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n     \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n     \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n     \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n     \n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n       \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n     \n  const int til = T[0].size();\n       \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, T[i][j]);\n      td[pil-j-1][i]=node;\n    }\n  }\n     \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<pil;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n     \nint main(void){\n  int h,w,r,c;\n       \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n     \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \n#define B (1000000007ULL)\nusing namespace std;\ntypedef unsigned long long ull;\n \nint h, w, r, c;\nchar t[1000][1001], p[1000][1001];\null th[1000][1000], ph[1000];\nint st[1001];\n \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>h>>w;\n    cin.ignore();\n    for(int i=0; i<h; i++) \n        cin.getline(t[i], 1001);\n    cin>>r>>c;\n    cin.ignore();\n    for(int i=0; i<r; i++) \n        cin.getline(p[i], 1001);\n \n    for(int i=0; i<r; i++){\n        for(int j=0; j<c; j++){\n            ph[i]=ph[i]*B+p[i][j];\n        }\n    }\n    ull bn=B;\n    for(int i=1; i<c; i++) bn*=B;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<c; j++) th[i][0]=th[i][0]*B+t[i][j];\n        for(int j=0; j<w-c; j++) th[i][j+1]=th[i][j]*B-t[i][j]*bn+t[i][j+c];\n    }\n    for(int y=0; y<=h-r; y++){\n        for(int x=0; x<=w-c; x++){\n            int i;\n            for(i=0; i<r&&th[y+i][x]==ph[i]; i++);\n            if(i==r) cout<<y<<' '<<x<<'\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1001; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX][N_MAX];\nchar P[N_MAX][N_MAX];\nint H, W, R, C;\n\nint Hash[N_MAX][N_MAX];\nint Bpow[N_MAX][N_MAX];\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%d %d\", &H, &W);\n    rep(i,0,H) {\n        rep(j,0,W) {\n            scanf(\" %c\", &T[i][j]);\n        }\n    }\n    \n    scanf(\"%d %d\", &R, &C);\n    \n    rep(i,0,R) {\n        rep(j,0,C) {\n            scanf(\" %c\", &P[i][j]);\n        }\n    }\n    \n#ifdef debug\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << T[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n    din >> R >> C;\n    rep(i,0,R) {\n        rep(j,0,C) {\n            dout << P[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n#ifdef debug\n    //naive search\n    bool found;\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            found = true;\n            rep(ii,0,R) {\n                rep(jj,0,C) {\n                    if(T[i+ii][j+jj]!=P[ii][jj]) {\n                        found = false;\n                        ii = R;\n                        jj = C;\n                    }\n                }\n            }\n            \n            if(found) {\n                printf(\"%d %d\\n\", i, j);\n            }\n        }\n    }\n    \n    \n    dout << \"============================================\\n\";\n#endif\n    \n//    \n//    //my original Rabin-Karp Algorithm (using Rolling Hash)\n//    const int B = 10007;\n//    int t = 1;\n//    \n//    for(int i=R-1; i>=0; i--) {\n//        for(int j=C-1; j>=0; j--) {\n//            Bpow[i][j] = t;\n//            t *= B;\n//        }\n//    }\n//    \n//#ifdef debug\n//    dout << \"Bpow[][] = \\n\";\n//    rep(i,0,R) {\n//        rep(j,0,C) {\n//            dout << Bpow[i][j] << \" \";\n//        }\n//        dout << endl;\n//    }\n//#endif\n//    \n//    \n//    int HashP = 0;\n//    rep(i,0,R) {\n//        rep(j,0,C) {\n//            HashP += P[i][j]*Bpow[i][j];\n//        }\n//    }\n//    \n//#ifdef debug\n//    disp(HashP);\n//#endif\n//    \n//    int HashT = 0;\n//    rep(i,0,R) {\n//        rep(j,0,C) {\n//            HashT += T[i][j]*Bpow[i][j];\n//        }\n//    }\n//    \n//#ifdef debug\n//    disp(HashT);\n//#endif\n//    \n//    //search\n//    rep(i,0,H-R+1) {\n//        rep(j,0,W-C+1) {\n//            \n//            Hash[i][j] = HashT;\n//            \n//#ifdef debug\n//            dout << \"-------------------------\\n\";\n//            dout << i << \" \" << j << endl;\n//            disp(HashT);\n//            disp(HashP);\n//            \n//            dout << \"Hash[][] = \\n\";\n//            rep(i,0,H) {\n//                rep(j,0,W) {\n//                    dout << Hash[i][j] << \" \";\n//                }\n//                dout << endl;\n//            }\n//#endif\n//            \n//            if(HashT == HashP) {\n//                printf(\"%d %d\\n\", i, j);\n//#ifdef debug\n//                dout << \"//////////////////////////////////////////////////////////////\\n\";\n//#endif\n//            }\n//            \n//            if(j+C<W) {\n//                HashT *= B;\n//                rep(k,i,i+R) {\n//                    HashT -= T[k][j]*Bpow[k-i][0]*B;\n//                    HashT += T[k][j+C]*Bpow[k-i][C-1];\n//                }\n//            }\n//            else if(i+R<H) { //j+C = W ????????? j=W-C ???????????????j??????????????°???????????´???\n//                HashT = Hash[i][0] * Bpow[R-1][0] * B;\n//                rep(k,0,C) {\n//                    HashT -= T[i][k]*Bpow[0][k]*Bpow[R-1][0]*B;\n//                    HashT += T[i+R][k]*Bpow[R-1][k];\n//                }\n//            }\n//            \n//        }\n//    }\n//    \n//#ifdef debug\n//    dout << \"============================================\\n\";\n//#endif\n    \n    //orthodox procedure by Rabin-Karp Algorithm (using Rolling Hash)\n    const int B1 = 10007;\n    const int B2 = 100000007;\n    \n    \n    int tmp[N_MAX][N_MAX]; //?¨??????????B1??§??????????????°???????????\\?????????????????????P???T??????????????????????????\\????¨??????????????¨???§???????????¨\n    int hashTable_T[N_MAX][N_MAX]; //tmp?????????????????????B2??§??????????????°???????????\\??????????????????????????????T[][]??????????????????????????\\?????¨??????\n    \n    int B1powC = 1;\n    rep(i,0,C) B1powC *= B1;\n    \n    int B2powR = 1;\n    rep(i,0,R) B2powR *= B2;\n    \n    \n    //calc. hash(P)\n    int hash_P = 0;\n    \n    rep(i,0,R) {\n        tmp[i][0] = 0;\n        \n        rep(jj,0,C) {\n            tmp[i][0] = tmp[i][0]*B1 + P[i][jj];\n        }\n    }\n    rep(ii,0,R) {\n        hash_P = hash_P*B2 + tmp[ii][0];\n    }\n    \n    \n    \n    \n    //calc. tmp[][]\n    rep(i,0,H) {\n        tmp[i][0] = 0;\n        \n        rep(jj,0,C) {\n            tmp[i][0] = tmp[i][0]*B1 + T[i][jj];\n        }\n        \n        rep(j,1,W-C+1) {\n            tmp[i][j] = tmp[i][j-1]*B1 - T[i][j-1]*B1powC + T[i][j+C-1];\n        }\n    }\n    \n#ifdef debug\n    dout << \"tmp[][] = \\n\";\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << tmp[i][j] << \" \";\n        }\n        dout << endl;\n    }\n#endif\n    \n    \n    //calc. hashTable_T\n    rep(j,0,W-C+1) {\n        \n        hashTable_T[0][j] = 0;\n        \n        rep(ii,0,R) {\n            hashTable_T[0][j] = hashTable_T[0][j]*B2 + tmp[ii][j];\n        }\n        \n        rep(i,1,H-R+1) {\n            hashTable_T[i][j] = hashTable_T[i-1][j]*B2 - tmp[i-1][j]*B2powR + tmp[i+R-1][j];\n        }\n    }\n    \n#ifdef debug\n    disp(hash_P);\n    dout << \"hashTable_T[][] = \\n\";\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << hashTable_T[i][j] << \" \";\n        }\n        dout << endl;\n    }\n#endif\n    \n    //find\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            if(hash_P==hashTable_T[i][j]) {\n                printf(\"%d %d\\n\", i, j);\n#ifdef debug\n                dout << \"//////////////////////////////////////////////////////////////\\n\";\n#endif\n            }\n        }\n    }\n    \n    \n\n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n    nodes[N].parent = cur;\n    nodes[N].ch = ch;\n    nodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int link(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n    \ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n    \n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n      \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n      \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128],P_last_loc[128] = {0};\n\n\tfor(int i=48;i<=122;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t\tP_last_loc[P[row][col]] = 1000*row+col;\n\t\t}\n\t}\n\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i]>0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\n\t\t\tbool matchFLG;\n\t\t\tint first_row=P_first_loc[min_char]/1000,first_col=P_first_loc[min_char]%1000;\n\n\t\t\tif(c_min == 1){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00&&T[row+first_row][col+first_col]==P[first_row][first_col]){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint last_row=P_last_loc[min_char]/1000,last_col=P_last_loc[min_char]%1000;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00&&T[row+first_row][col+first_col]==P[first_row][first_col]&&T[row+last_row][col+last_col]==P[last_row][last_col]){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\n\t\t\tbool ptnFLG=true;\n\t\t\tif(((100*c_max/P_h*P_w)<=5)||((100*tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(abs(100*c_max/(P_h*P_w)-(100*tc_max/(T_h*T_w)))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=48;i<=122;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(abs(100*second_p_max/(P_h*P_w)-(100*second_t_max/(T_h*T_w)))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif((100*p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=48;k<=122;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=48;k<=122;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=48;i<=122;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif((100*p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if((100*p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if((100*p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif((100*t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=48;i<=122;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((100*t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if((100*t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if((100*t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point == -1){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row][col+tmp_col]!=P[0][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS,top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(T[0][0]==P[0][0]){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\tif (t >= 50000 && k >= 30) {\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int h, w, r, c;\n    string f1[1000], f2[1000];\n\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[0]) {\n                bool success = true;\n                for (int k = 1; k < r; k++) {\n                    if (f1[i + k].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i << \" \" << j << endl;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nclass RollingHash2D\n{\n    int h, w;\n    static const uint64_t b1 = 9973, b2 = 100000007; // (1000000007, 1000000009)\n    std::vector<uint64_t> rh, rw;\n    std::vector<std::vector<uint64_t>> hash;\n\n  public:\n    RollingHash2D(const std::vector<std::vector<T>> &mat) : h(mat.size()), w(mat[0].size()), rh(h + 1), rw(w + 1), hash(h + 1, std::vector<uint64_t>(w + 1))\n    {\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                hash[i + 1][j + 1] = hash[i + 1][j] * b2 + mat[i][j];\n            }\n            for (int j = 0; j < w; j++)\n            {\n                hash[i + 1][j + 1] += hash[i][j + 1] * b1;\n            }\n        }\n        rh[0] = rw[0] = 1;\n        for (int i = 0; i < h; i++)\n            rh[i + 1] = rh[i] * b1;\n        for (int i = 0; i < w; i++)\n            rw[i + 1] = rw[i] * b2;\n    }\n    // [sx, gx) * [sy, gy) のハッシュ値を取得\n    uint64_t query(int sx, int sy, int gx, int gy)\n    {\n        assert(0 <= sx && sx <= gx && gx <= h);\n        assert(0 <= sy && sy <= gy && gy <= w);\n        uint64_t h1 = hash[gx][gy] - hash[gx][sy] * rw[gy - sy];\n        uint64_t h2 = hash[sx][gy] - hash[sx][sy] * rw[gy - sy];\n        return h1 - h2 * rh[gx - sx];\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> mat(H, vector<char>(W));\n    for (int i = 0; i < H; i++)\n    {\n        string s;\n        cin >> s;\n        for (int j = 0; j < W; j++)\n        {\n            mat[i][j] = s[j];\n        }\n    }\n    int R, C;\n    cin >> R >> C;\n    vector<vector<char>> pattern(R, vector<char>(C));\n    for (int i = 0; i < R; i++)\n    {\n        string s;\n        cin >> s;\n        for (int j = 0; j < C; j++)\n        {\n            pattern[i][j] = s[j];\n        }\n    }\n    RollingHash2D<char> rh(mat);\n    RollingHash2D<char> p(pattern);\n    auto ret = p.query(0, 0, R, C);\n    for (int i = 0; i + R <= H; i++)\n    {\n        for (int j = 0; j + C <= W; j++)\n        {\n            auto v = rh.query(i, j, i + R, j + C);\n            if (ret == v)\n                cout << i << \" \" << j << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n#define MAX 1000\nint d[MAX][MAX];\nint p[MAX][MAX];\nint h, w, r, c;\n\nvoid input(){\n\tstring s;\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tcin >> s;\n\t\tfor(int j = 0;j < w;j++)d[i][j] = s[j] - '0';\n\t}\n\tcin >> r >> c;\n\tfor(int i = 0;i < r;i++){\n\t\tcin >> s;\n\t\tfor(int j = 0;j < c;j++)p[i][j] = s[j] - '0';\n\t}\n}\n\nint calc(int y, int x){\n\tfor(int i = 0;i < r;i++){\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tif(d[y+i][x+j] != p[i][j])return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\tinput();\n\t/*for(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++)cout << d[i][j] << \" \";\n\t\tcout << endl;\n\t}*/\n\tfor(int i = 0;i < h-r+1;i++){\n\t\tfor(int j = 0;j < w-c+1;j++){\n\t\t\tif(calc(i, j))cout << i << \" \" << j << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\n#include<fstream>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\nbool Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareRight(int idxi, int idxj)\n{\n\tint j = C - 1;\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareBottom(int idxi, int idxj)\n{\n\tint i = R - 1;\n\tfor (int j = C - 1; j >= 0; j--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CheckPP() {\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 1; j < C; j++) {\n\t\t\tif (P[i][j] != P[0][0]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//search and output\n\t//ofstream outputfile(\"outputfile.txt\");\n\tif (CheckPP()) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tbool flag_ok_r = false;\n\t\tbool flag_ok_b = false;\n\t\tbool flag_r = true;\n\t\twhile (i + R <= H) {\n\t\t\tbool ret;\n\t\t\tif (flag_r && flag_ok_r) {\n\t\t\t\tret = CompareRight(i, j);\n\t\t\t}\n\t\t\telse if (!flag_r && flag_ok_b) {\n\t\t\t\tret = CompareBottom(i, j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret = Compare(i, j);\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tflag_ok_r = true;\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tflag_ok_b = true;\n\t\t\t\t}\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tflag_ok_r = false;\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tflag_ok_b = false;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i + R <= H) {\n\t\t\tif (Compare(i, j)) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    //outputfile.close();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <sstream>\n\nusing namespace std;\n\nint main (void)\n{\n\tlong n,m,r,c;\n\tstring a[5000],b[5000];\n\tcin >> n >> m;\n\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tcin >> r >> c;\n\n\tfor (long j = 0; j < r; j++)\n\t{\n\t\tcin >> b[j];\n\t}\n\n\tfor (long i = 0; i < n - r + 1; i++)\n\t{\n\t\tfor (long k = 0; k < m - c + 1; k++)\n\t\t{\n\t\t\tif (a[i].substr(k,c) == b[0])\n\t\t\t{\n\t\t\t\tfor (long j = 0; j < r; j++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i + j].substr(k,c) != b[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (j == r - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << i << \" \" << k << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nclass PMA {\nprivate:\n    uint32_t id = 0;\n\npublic:\n    struct Node {\n        uint32_t id;\n        string *str = nullptr;\n        unordered_map<uint8_t, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const string &str) {\n        Node *node = root;\n        for (uint8_t c : str) {\n            auto itr = node->children.find(c);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[c] = new Node;\n                node->children[c]->id = id++;\n                node = node->children[c];\n            }\n        }\n\n        node->str = new string(str);\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, uint8_t c) {\n        while (node != nullptr) {\n            auto itr = node->children.find(c);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                uint8_t c = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, c);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\nint main() {\n    int32_t H, W, R, C;\n    cin >> H >> W;\n\n    vector<string> T(H);\n    for (int32_t i = 0; i < H; i++) {\n        string temp;\n        cin >> temp;\n        T[i] = temp;\n    }\n\n    cin >> R >> C;\n\n    vector<string> P(R);\n    for (int32_t i = 0; i < R; i++) {\n        string temp;\n        cin >> temp;\n        P[i] = temp;\n    }\n\n    PMA pma_p, pma_m;\n    string M;\n    for (string str : P) M += to_string(pma_p.insert(str));\n    pma_p.link_failure();\n    pma_m.insert(M);\n    pma_m.link_failure();\n\n    vector<string> T2(T[0].length());\n\n    for (string str : T) {\n        PMA::Node *node = pma_p.root;\n        for (uint32_t i = 0; i < str.length(); i++) {\n            node = pma_p.transition(node, str[i]);\n            T2[i] += to_string(node->id);\n        }\n    }\n\n    vector<pair<uint32_t, uint32_t>> res;\n    for (uint32_t c = 0; c < T2.size(); c++) {\n        PMA::Node *node = pma_m.root;\n        for (uint32_t r = 0; r < T2[c].length(); r++) {\n            node = pma_m.transition(node, T2[c][r]);\n            if (node->str != nullptr) {\n                res.push_back(make_pair(r - R + 1, c - C + 1));\n            }\n        }\n    }\n\n    sort(res.begin(), res.end());\n\n    for (auto p : res) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[0]) {\n                for (int k = 1; k < r; k++) {\n                    if (f1[i + k].substr(j, c) != f2[k]) {\n                        break;\n                    }\n                    if (k == r - 1) {\n                        cout << i << \" \" << j << endl;\n                    }\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <set>\n#include <algorithm>\n\ntypedef std::pair<int, int> Coordinate;\n\nstruct State {\n\tint num;\n\tstd::map<char, int> trans_to;\n\t// std::string str;\n\tint failure_to;\n};\n\nint max(int x, int y)\n{\n\treturn x>y ? x : y;\n}\n\nvoid constructPMA(std::vector<State>& PMA, int* finalstates, char** P, int R, int C)\n{\n\tState starting_state;\n\tstarting_state.num = 0;\n\tstarting_state.failure_to = 0;\n\tPMA.push_back(starting_state);\n\t\n\tstd::set<char> appears;\n\t\n\t// create trie tree\n\tfor (int i=0; i<R; i++) {\n\t\tint curr_state = 0;\n\t\tfor (int j=0; j<C; j++) {\n\t\t\tchar x = P[i][j];\n\t\t\tappears.insert(x);\n\t\t\tif (PMA[curr_state].trans_to.find(x) == PMA[curr_state].trans_to.end() ) {\n\t\t\t\tState s; s.num = PMA.size();\n\t\t\t\t// s.str = pattern[i].substr(0, j+1);\n\t\t\t\ts.failure_to = 0;\n\t\t\t\tPMA.push_back(s);\n\t\t\t\tPMA[curr_state].trans_to[x] = PMA.size() - 1;\n\t\t\t}\n\t\t\tcurr_state = PMA[curr_state].trans_to[x];\n\t\t}\n\t\tfinalstates[i] = curr_state;\n\t}\n\t\n\t// failure function\n\tstd::queue<int> que;\n\tque.push(0);\n\t\n\twhile (!que.empty()) {\n\t\tint k = que.front(); que.pop();\n\t\tfor (std::set<char>::iterator it = appears.begin(); it != appears.end(); ++it) {\n\t\t\tchar x = *it;\n\t\t\tif ( PMA[k].trans_to.find(x) != PMA[k].trans_to.end() ) { // PMA[k].trans_to has a transition by x\n\t\t\t\tint next = PMA[k].trans_to[x];\n\t\t\t\tque.push(next);\n\t\t\t\tif (k > 0) {\n\t\t\t\t\tint f = PMA[k].failure_to;\n\t\t\t\t\twhile (f > 0 && PMA[f].trans_to.find(x) == PMA[f].trans_to.end()) {\n\t\t\t\t\t\tf = PMA[f].failure_to;\n\t\t\t\t\t}\n\t\t\t\t\tPMA[next].failure_to = PMA[f].trans_to[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid convert(int** T, char** rectangle, std::vector<State> PMA, int H, int W)\n{\n\tfor (int i=0; i<H; i++) {\n\t\tint state_id = 0;\n\t\tfor (int j=0; j<W; j++) {\n\t\t\tchar x = rectangle[i][j];\n\t\t\twhile ( state_id > 0 && PMA[state_id].trans_to.find(x) == PMA[state_id].trans_to.end() ) {\n\t\t\t\tstate_id = PMA[state_id].failure_to;\n\t\t\t}\n\t\t\tstate_id = PMA[state_id].trans_to[x];\n\t\t\tT[i][j] = state_id;\n\t\t}\n\t}\n}\n\nvoid constructKMP(int* KMPtable, int* P, int m)\n{\n\tKMPtable[0] = -1;\n\tKMPtable[1] = 0;\n\tint i=2, j=0;\n\twhile (i<m+1) {\n\t\tif (P[i-1] == P[j]) {\n\t\t\tKMPtable[i] = j + 1; i++; j++;\n\t\t} else if (j>0) {\n\t\t\tj = KMPtable[j];\n\t\t} else {\n\t\t\tKMPtable[i] = 0; i++;\n\t\t}\n\t}\n\t\n\t// std::cout << \"KMP Table :\" << std::endl;\n\t// for (int i=0; i<m+1; i++) std::cout << KMPtable[i] << std::endl;\n}\n\t\n\nvoid search(int** T, int* finalstates, int H, int W, int R, int C)\n{\n\tstd::vector<Coordinate> ans;\n\t\n\tint* KMPtable = new int[R+1];\n\tconstructKMP(KMPtable, finalstates, R);\n\t\n\tfor (int col=C-1; col<W; col++) {\n\t\tint j = 0;\n\t\tfor (int row=0; row<=H-R; ) {\n\t\t\tif (T[row+j][col] == finalstates[j]) {\n\t\t\t\tif (j==R-1) {\n\t\t\t\t\tans.push_back( Coordinate(row, col-C+1) );\n\t\t\t\t\trow += R - KMPtable[R];\n\t\t\t\t\tj = KMPtable[R];\n\t\t\t\t}\n\t\t\t\telse { j++; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\trow += j - KMPtable[j];\n\t\t\t\tj = max(0, KMPtable[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstd::sort(ans.begin(), ans.end());\n\tfor (int i=0; i<ans.size(); i++) {\n\t\tstd::cout << ans[i].first << \" \" << ans[i].second << std::endl;\n\t}\n\t\n\tdelete[] KMPtable;\n}\n\nint main()\n{\n\tint H, W;\n\tstd::cin >> H >> W;\n\tchar** rectangle = new char*[H];\n\tfor (int i=0; i<H; i++) rectangle[i] = new char[W];\n\tfor (int i=0; i<H; i++) {\n\t\tfor (int j=0; j<W; j++) std::cin >> rectangle[i][j];\n\t}\n\t\n\tint R, C;\n\tstd::cin >> R >> C;\n\tchar** pattern = new char*[R];\n\tfor (int i=0; i<R; i++) pattern[i] = new char[C];\n\tfor (int i=0; i<R; i++) {\n\t\tfor (int j=0; j<C; j++) std::cin >> pattern[i][j];\n\t}\n\t\n\tstd::vector<State> PMA;\n\tint* finalstates = new int[R];\n\t\n\tconstructPMA(PMA, finalstates, pattern, R, C);\n\t\n\tint** converted_rectangle = new int*[H];\n\tfor (int i=0; i<H; i++) converted_rectangle[i] = new int[W];\n\t\n\tconvert(converted_rectangle, rectangle, PMA, H, W);\n\t\n\t/*\n\t\n\tstd::cout << \"Rectangle :\" << std::endl;\n\tfor (int i=0; i<H; i++) {\n\t\tfor (int j=0; j<W; j++) std::cout << rectangle[i][j] << \" \";\n\t\tstd::cout << std::endl;\n\t}\n\t\n\tstd::cout << \"Pattern :\" << std::endl;\n\tfor (int i=0; i<R; i++) {\n\t\tfor (int j=0; j<C; j++) std::cout << pattern[i][j] << \" \";\n\t\tstd::cout << std::endl;\n\t}\n\t\n\tstd::cout << \"PMA :\" << std::endl;\n\tfor (int i=0; i<PMA.size(); i++) {\n\t\tstd::cout << i << \": \";\n\t\tfor (std::map<char,int>::iterator it = PMA[i].trans_to.begin(); it != PMA[i].trans_to.end(); ++it) {\n\t\t\tstd::cout << \"[\" << (*it).first << \", \" << (*it).second << \"], \";\n\t\t}\n\t\t\n\t\tstd::cout << \"failure(\" << i << \") = \" << PMA[i].failure_to << std::endl;\n\t}\n\t\n\tstd::cout << \"Final States :\" << std::endl;\n\tfor (int i=0; i<R; i++) {\n\t\tstd::cout << finalstates[i] << std::endl;\n\t}\n\t\n\tstd::cout << \"Converted Rectangle :\" << std::endl;\n\tfor (int i=0; i<H; i++) {\n\t\tfor (int j=0; j<W; j++) std::cout << converted_rectangle[i][j] << \" \";\n\t\tstd::cout << std::endl;\n\t}\n\t\n\t*/\n\t\n\t\n\tsearch(converted_rectangle, finalstates, H, W, R, C);\n\t\n\tfor (int i=0; i<H; i++) delete[] converted_rectangle[i];\n\tdelete[] converted_rectangle;\n\tdelete[] finalstates;\n\tfor (int i=0; i<H; i++) delete[] rectangle[i];\n\tdelete[] rectangle;\n\tfor (int i=0; i<R; i++) delete[] pattern[i];\n\tdelete[] pattern;\n\t\n\treturn 0;\n}\n\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n        int h, w;\n        vector<string> hw;\n        int r, c;\n        vector<string> rc;\n        string s;\n        vector<P> ans;\n\n        cin >> h >> w;\n        for (int i = 0; i < h; i++) {\n                cin >> s;\n                hw.push_back(s);\n        }\n\n        cin >> r >> c;\n        for (int i = 0; i < r; i++) {\n                cin >> s;\n                rc.push_back(s);\n        }\n\n        for (int i = 0; i <= h-r; i++) {\n                for (int j = 0; j <= w-c; j++) {\n                        int flag = true;\n                        for (int k = 0; k < r; k++) {\n                                for (int l = 0; l < c; l++) {\n                                        if (hw[i+k][j+l] != rc[k][l]) {\n                                                flag = false;\n                                                break;\n                                        }\n                                }\n                                if (!flag)\n                                        break;\n                        }\n                        if (flag)\n                                ans.push_back(make_pair(i, j));\n                }\n        }\n\n        vector<P>::iterator it = ans.begin();\n        while (it != ans.end()) {\n                cout << it->first << \" \" << it->second << endl;\n                it++;\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint h, w, r, c;\nchar t[1000][1001], p[1000][1001];\nint st[1001];\nvector<int> li;\n\nvoid kmp_table(char *w)\n{\n    int i=2, j=0;\n    st[0]=st[1]=0;\n    while(i<=c){\n        if(w[i-1]==w[j]) st[i++]=++j;\n        else if(j>0)j=st[j];\n        else st[i++]=0;\n    }\n}\n\nvoid kmp_search(char *s, char *t)\n{\n    int p=0, i=0;\n    li.resize(0);\n    while(p<=w){\n        if(t[i]==s[p]){\n            ++p;\n            ++i;\n            if(i==c){\n                li.push_back(p-c);\n                i=st[c];\n            }\n        }else{\n            if(i==0) ++p;\n            i=st[i];\n        }\n    }\n}\n\nbool check(int x, int y)\n{\n    for(int i=1; i<r; i++){\n        if(memcmp(t[y+i]+x, p[i], c)) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>h>>w;\n    cin.ignore();\n    for(int i=0; i<h; i++) \n        cin.getline(t[i], 1001);\n    cin>>r>>c;\n    cin.ignore();\n    for(int i=0; i<r; i++) \n        cin.getline(p[i], 1001);\n    kmp_table(p[0]);\n\n    for(int y=0; y<=h-r; y++) {\n        kmp_search(t[y], p[0]);\n        for(int i=0, n=li.size(); i<n; i++){\n            int x=li[i];\n            if(check(x, y)){\n                cout<<y<<' '<<x<<'\\n';\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            if( ary_HW[i][j] == ary_RC[0][0] )\n            {\n                // 先頭文字を比較\n                patternMatching(i, j);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    hEnd = hPos + ( R - 1 );\n    wEnd = wPos + ( C - 1 );\n\n    if( hEnd > H - 1 || wEnd > W - 1 )\n    {\n        // 配列の範囲をオーバーしているので, 検索不要\n        return;\n    }\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の行が1行見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<functional>\nusing namespace std;\n\nstring a[1000], b[1000];\nint r, c;\n\nstring oneString(string *a, int i, int j){\n        string s;\n        for(int p=i;p<i+r;p++){\n                s += a[i].substr(j, c);\n        }\n        return s;\n}\n\nint main(){\n        int h,w;\n        cin>>h>>w;\n        for(int i=0;i<h;i++) cin>>a[i];\n        cin>>r>>c;\n        for(int i=0;i<r;i++) cin>>b[i];\n        hash<string> getHash;\n        auto target = getHash(oneString(b, 0, 0));\n\n        for(int i=0;i+r-1<h;i++){\n                for(int j=0;j+c-1<w;j++){\n                        auto tmp_hash = getHash(oneString(a, i, j));\n                        if(target == tmp_hash) cout<<i<<\" \"<<j<<endl;\n                }\n        }\n\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // 先頭文字を比較\n            if( ary_HW[hPos][wPos] == ary_RC[0][0] )\n            {\n                // 文字パターンの検索を実施する\n                patternMatching(hPos, wPos);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の行が1行見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n     \n     \nusing namespace std;\n     \nstruct AhoCorasick {\n     \n  static const int ALPHABET_SIZE = 62, root=0;\n     \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n       \n  int N; // num of node\n     \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n     \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n     \n  vector<Node> nodes;\n     \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n     \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] > -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n     \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n     \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n     \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n     \n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n       \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n     \n  const int til = T[0].size();\n       \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n     \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n     \nint main(void){\n  int h,w,r,c;\n       \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n     \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n   \n   \nusing namespace std;\n   \nstruct AhoCorasick {\n   \n  static const int ALPHABET_SIZE = 62, root=0;\n   \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n     \n  int N; // num of node\n   \n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n   \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n   \n  vector<Node> nodes;\n   \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n   \n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n    nodes[N].parent = cur;\n    nodes[N].ch = ch;\n    nodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n   \n  int link(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n   \n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n   \ntypedef pair<int,int> pii;\n   \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n   \n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n     \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n   \n  const int til = T[0].size();\n     \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n   \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n   \nint main(void){\n  int h,w,r,c;\n     \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n   \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int max_size=1010;\nchar pattern[max_size][max_size];\nchar target[max_size][max_size];\n\null hash[max_size][max_size],tmp[max_size][max_size];\n\nvoid calc(char a[max_size][max_size],int n,int m,int r,int c){\n\tconst ull br=1000000007;\n\tconst ull bc=1000000009;\n\n\tull tc=1;\n\trep(i,c) tc*=bc;\n\n\trep(i,n){\n\t\tull e=0;\n\t\trep(j,c) e=e*bc+a[i][j];\n\t\trep(j,m){\n\t\t\ttmp[i][j]=e;\n\t\t\tif(j+c>=m) break;\n\t\t\te=e*bc-tc*a[i][j]+a[i][j+c];\n\t\t}\n\t}\n\n\tull tr=1;\n\trep(j,r) tr*=br;\n\n\trep(j,m-c+1){\n\t\tull e=0;\n\t\trep(i,r) e=e*br+tmp[i][j];\n\t\trep(i,n){\n\t\t\thash[i][j]=e;\n\t\t\tif(i+r>=n) break;\n\t\t\te=e*br-tr*tmp[i][j]+tmp[i+r][j];\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint h,w;\n\tcin >> h >> w;\n\trep(i,h)rep(j,w) cin >> target[i][j];\n\tint r,c;\n\tcin >> r >> c;\n\trep(i,r)rep(j,c) cin >> pattern[i][j];\n\tcalc(pattern,r,c,r,c);\n\tull pattern_hash=hash[0][0];\n\tcalc(target,h,w,r,c);\n\tfor(int i=0;i+r<=h;++i)\n\t\tfor(int j=0;j+c<=w;++j)\n\t\t\tif(pattern_hash==hash[i][j])\n\t\t\t\tcout << i << \" \" << j << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\null mhash(vector<ull> v,ull k){\n  ull B=1000000007LL+k*4;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=(res*255+v[i])%B;\n  return res;\n}\null mhash2(vector<ull> v,ull k){\n  ull B=1000000007LL+k*4;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=res*B+v[i];\n  return res;\n}\nconst int CNT=6;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  RollingHash srh[CNT][h];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<h;i++){\n      srh[k][i].S=s[i];\n      srh[k][i].B=1000000007LL+(2*k);\n      srh[k][i].init();\n    }\n  }\n  int r,c;\n  cin>>r>>c;\n  string t[r];\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash trh[CNT][r];\n  vector<ull> v[CNT];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<r;i++){\n      trh[k][i].S=t[i];\n      trh[k][i].B=1000000007LL+(2*k);\n      trh[k][i].init();\n      v[k].push_back(trh[k][i].find(0,c));\n    }\n  }\n  ull base[CNT];\n  for(int k=0;k<CNT;k++) base[k]=mhash(v[k],k);\n  ull base2[CNT];\n  for(int k=0;k<CNT;k++) base2[k]=mhash2(v[k],k);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      bool flg=1;\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash(u,k)==base[k]);\n      }\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash2(u,k)==base2[k]);\n      }\n      if(flg) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing u64 = uint_fast64_t; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n////////////////////////////////////////////////////////////////////////\n\ntemplate <typename S>\nstruct RollingHash {\nprivate:\n    static const u64 mod = (1ull << 61) - 1;\n    const u64 MASK30 = (1ull << 30) - 1;\n    const u64 MASK31 = (1ull << 31) - 1;\n    const u64 POSITIVIZER = mod * ((1ull << 3) - 1);\n    u64 baseh,basew;\n    vector<u64> powerh,powerw;\n\n    u64 Mul (u64 a, u64 b) {\n        u64 au = a >> 31;\n        u64 ad = a & MASK31;\n        u64 bu = b >> 31;\n        u64 bd = b & MASK31;\n        u64 mid = ad * bu + au * bd;\n        u64 midu = mid >> 30;\n        u64 midd = mid & MASK30;\n        return (au * bu * 2 + midu + (midd << 31) + ad * bd);\n    }\n\n    u64 CalcMod(u64 val) {\n        val = (val & mod) + (val >> 61);\n        if (val >= mod) val -= mod;\n        return val;\n    }\n\npublic:\n    static inline u64 generate_base() {\n        mt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n        uniform_int_distribution<u64> rand(1, RollingHash::mod - 1);\n        return rand(mt);\n    }\n\n    RollingHash(int H, int W, u64 baseh, u64 basew) : powerh(H+1,1), powerw(W+1,1), baseh(baseh), basew(basew) {\n        for (int i = 0; i < H; ++i) {\n            powerh[i+1] = CalcMod(Mul(powerh[i],baseh));\n        }\n        for (int i = 0; i < W; ++i) {\n            powerw[i+1] = CalcMod(Mul(powerw[i],basew));\n        }\n    }\n\n    vector<vector<u64>> gethash(vector<S>& s) {\n        int h = s.size();\n        s.emplace_back();\n        int w = s[0].size();\n        s.pop_back();\n        vector<vector<u64>> ret(h+1, vector<u64>(w+1));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                ret[i+1][j+1] = CalcMod(Mul(ret[i+1][j],basew) + s[i][j] + 1);\n            }\n        }\n        for (int j = 0; j < w; ++j) {\n            for (int i = 0; i < h; ++i) {\n                ret[i+1][j+1] = CalcMod(Mul(ret[i][j+1],baseh) + ret[i+1][j+1]);\n            }\n        }\n        return ret;\n    }\n    // [h1,h2) * [w1,w2) (0-indexed)\n    u64 getarea(const vector<vector<u64>> &hash, int h1, int h2, int w1, int w2) {\n        u64 ret, val;\n        ret = CalcMod(hash[h2][w2] + POSITIVIZER - Mul(hash[h1][w2],powerh[h2-h1]));\n        val = CalcMod(hash[h2][w1] + POSITIVIZER - Mul(hash[h1][w1],powerh[h2-h1]));\n        ret = CalcMod(ret + POSITIVIZER - Mul(val,powerw[w2-w1]));\n        return ret;\n    }\n\n    u64 getval(vector<S>& s) {\n        int h = s.size();\n        s.emplace_back();\n        int w = s[0].size();\n        s.pop_back();\n        vector<vector<u64>> ret(h + 1, vector<u64>(w + 1, 0));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                ret[i+1][j+1] = CalcMod(Mul(ret[i+1][j],basew) + s[i][j] + 1);\n            }\n        }\n        for (int j = 0; j < w; ++j) {\n            for (int i = 0; i < h; ++i) {\n                ret[i+1][j+1] = CalcMod(Mul(ret[i][j+1],baseh) + ret[i+1][j+1]);\n            }\n        }\n        return ret[h][w];\n    }\n};\n\n/////////////////////////////////////////////////////////////////////////////////\n\nvoid ALDS1_14_C() {\n    int H,W; cin >> H >> W;\n    vector<string> S(H);\n    for (int i = 0; i < H; ++i) cin >> S[i];\n    int R,C; cin >> R >> C;\n    vector<string> T(R);\n    for (int i = 0; i < R; ++i) cin >> T[i];\n\n    using RH = RollingHash<string>;\n    auto baseh = RH::generate_base();\n    auto basew = RH::generate_base();\n    RH rh(max(H,R),max(W,C),baseh,basew);\n\n    auto hash = rh.gethash(S);\n    auto t = rh.getval(T);\n    for (int i = 0; i+R <= H; ++i) {\n        for (int j = 0; j+C <= W; ++j) {\n            if (rh.getarea(hash,i,i+R,j,j+C)==t) {\n                cout << i << \" \" << j << ln;\n            }\n        }\n    }\n\n}\nint main() {\n\tios::sync_with_stdio(false); cin.tie(nullptr);\n    ALDS1_14_C();\n}\n\n/*\n  verified on 2020/05/26\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_C&lang=ja\n*/\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\ntypedef pair<long long int, long long int> P;\n\nstring P1[1100], P2[1100];\nunsigned long long int rec[1100][1100];\n\nint main(){\n\t\n\tint H, W;\n\tcin >> H >> W;\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin >> P1[i];\n\t}\n\t\n\tint R, C;\n\tcin >> R >> C;\n\t\n\tfor(int i = 0; i < R; i++){\n\t\tcin >> P2[i];\n\t}\n\t\n\tif(H < R || W < C){\n\t\treturn 0;\n\t}\n\t\n\tunsigned long long int B1 = 9973, B2 = 1e9 + 7, t1 = 1, t2 = 1;\n\t\n\tunsigned long long int ans = 0;\n\t\n\tfor(int i = 0; i < C; i++){\n\t\tunsigned long long int val = 0;\n\t\tfor(int j = 0; j < R; j++){\n\t\t\tval *= B1;\n\t\t\tval += P2[j][i];\n\t\t}\n\t\tans *= B2;\n\t\tans += val;\n\t}\n\t\n\tfor(int i = 0; i < R; i++){\n\t\tt1 *= B1;\n\t}\n\tfor(int i = 0; i < C; i++){\n\t\tt2 *= B2;\n\t}\n\t\n\tfor(int i = 0; i < W; i++){\n\t\tunsigned long long int val = 0;\n\t\tfor(int j = 0; j < R; j++){\n\t\t\tval *= B1;\n\t\t\tval += P1[j][i];\n\t\t}\n\t\trec[0][i] = val;\n\t\tfor(int j = R; j < H; j++){\n\t\t\tval *= B1;\n\t\t\tval += P1[j][i];\n\t\t\tval -= t1 * P1[j - R][i];\n\t\t\trec[j - R + 1][i] = val;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= H - R; i++){\n\t\tunsigned long long int val = 0;\n\t\tfor(int j = 0; j < C; j++){\n\t\t\tval *= B2;\n\t\t\tval += rec[i][j];\n\t\t}\n\t\tif(val == ans){\n\t\t\tcout << i << \" \" << 0 << endl;\n\t\t}\n\t\tfor(int j = C; j < W; j++){\n\t\t\tval *= B2;\n\t\t\tval += rec[i][j];\n\t\t\tval -= t2 * rec[i][j - C];\n\t\t\tif(val == ans){\n\t\t\t\tcout << i << \" \" << j - C + 1 << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (63533)\n#define P2 (100007)\n\n#define MAX (1010)\nchar str[MAX][MAX];\nchar pat[MAX][MAX];\null str_hash[MAX][MAX];\null tmp[MAX][MAX];\nint sh, sw, ph, pw;\n\nvoid rolling_hash(int height, int width, char character[MAX][MAX])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < pw; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i < height; i++) {\n        hash = 0;\n        for (int j = 0; j < pw; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + pw <= width; j++) {\n            tmp[i][j] = hash;\n            if (j + width < width) {\n                hash = hash * P1 + character[i][j + pw] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < ph; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + pw <= width; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < ph; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + ph <= height; i++) {\n            str_hash[i][j] = hash;\n            if(i + height < height){\n                hash = hash * P2 + tmp[i + ph][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(sh, sw, str);\n    \n    for(int i = 0; i <= sh; i++){\n        for (int j = 0; j <= sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename T>\nclass PMA {\nprivate:\n    uint32_t id = 0;\n\npublic:\n    struct Node {\n        uint32_t id;\n        bool accepted = false;\n        unordered_map<T, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const vector<T> &vec) {\n        Node *node = root;\n        for (T v : vec) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[v] = new Node;\n                node->children[v]->id = id++;\n                node = node->children[v];\n            }\n        }\n\n        node->accepted = true;\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, T v) {\n        while (node != nullptr) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                T v = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, v);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\nint main() {\n    int32_t H, W, R, C;\n    cin >> H >> W;\n\n    vector<vector<uint8_t>> T(H);\n    for (int32_t i = 0; i < H; i++) {\n        string temp;\n        cin >> temp;\n        T[i] = vector<uint8_t>(temp.begin(), temp.end());\n    }\n\n    cin >> R >> C;\n\n    vector<vector<uint8_t>> P(R);\n    for (int32_t i = 0; i < R; i++) {\n        string temp;\n        cin >> temp;\n        P[i] = vector<uint8_t>(temp.begin(), temp.end());\n    }\n\n    PMA<uint8_t> pma_p;\n    vector<uint32_t> M;\n    for (vector<uint8_t> vec : P) M.push_back(pma_p.insert(vec));\n    pma_p.link_failure();\n\n    PMA<uint32_t> pma_m;\n    pma_m.insert(M);\n    pma_m.link_failure();\n\n    vector<vector<uint32_t>> T2(W);\n\n    for (vector<uint8_t> vec : T) {\n        PMA<uint8_t>::Node *node = pma_p.root;\n        for (uint32_t i = 0; i < vec.size(); i++) {\n            node = pma_p.transition(node, vec[i]);\n            T2[i].push_back(node->id);\n        }\n    }\n\n    vector<pair<uint32_t, uint32_t>> res;\n    for (int32_t c = 0; c < W; c++) {\n        PMA<uint32_t>::Node *node = pma_m.root;\n        for (int32_t r = 0; r < H; r++) {\n            node = pma_m.transition(node, T2[c][r]);\n            if (node->accepted) {\n                res.push_back(make_pair(r - R + 1, c - C + 1));\n            }\n        }\n    }\n\n    sort(res.begin(), res.end());\n\n    for (auto p : res) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int MAX_N = 1001;\nconst ull B1 = 9973;\nconst ull B2 = 1e9 + 7;\nint H, W, P, Q;\null Hash[MAX_N][MAX_N], tmp[MAX_N][MAX_N];\nchar field[MAX_N][MAX_N], patterns[MAX_N][MAX_N];\nvoid RollingHash(int n, int m, char ch[MAX_N][MAX_N])\n{\n    //行方向\n    ull t1 = 1;\n    for(int j = 0; j < Q; j++) t1 *= B1;\n    for(int i = 0; i < n; i++)\n    {\n        ull e1 = 0;\n        for(int j = 0; j < Q; j++) e1 = e1 * B1 + ch[i][j];\n        for(int j = 0; j + Q <= m; j++)\n        {\n            tmp[i][j] = e1;\n            if(j + Q < m) e1 = e1 * B1 - t1 * ch[i][j] + ch[i][j + Q];\n        }\n    }\n    //双方向\n    ull t2 = 1;\n    for(int i = 0; i < P; i++) t2 *= B2;\n    for(int j = 0; j + Q <= m; j++)\n    {\n        ull e2 = 0;\n        for(int i = 0; i < P; i++) e2 = e2 * B2 + tmp[i][j];\n        for(int i = 0; i + P <= n; i++)\n        {\n            Hash[i][j] = e2;\n            if(i + P < n) e2 = e2 * B2 - t2 * tmp[i][j] + tmp[i + P][j];\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> H >> W;\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0; i < P; i++)\n    {\n        for(int j = 0; j < Q; j++)\n        {\n            cin >> patterns[i][j];\n        }\n    }\n    RollingHash(P, Q, patterns);\n    ull f = Hash[0][0];\n    RollingHash(H, W, field);\n    for(int i = 0; i + P <= H; i++)\n    {\n        for(int j = 0; j + Q <= W; j++)\n        {\n            //cout << Hash[i][j] << \" \" << f << endl;\n            if(Hash[i][j] == f) cout << i << \" \" << j << \"\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tif (R == 1){\n\t\tfor (long i = 0; i < H - R + 1; i++){\n\t\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\t\tif (T[i].substr(j, C) == P[0]) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define MAX 1010\ntypedef unsigned long long ull;\n\nint H,W,R,C;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash1[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int w,int h){\n    const ull B1 = 9999973;\n    const ull B2 = 950527;\n    \n    ull t1 = 1;\n    // ハッシュ作成列\n    for(int j = 0 ; j < C ; ++j) t1 *= B1;\n    \n    for(int i = 0 ; i < w ; ++i){\n        ull e = 0;\n        for(int j = 0 ; j < C ; ++j){\n          e = e * B1 + a[i][j];\n        }\n        for(int j = 0 ; j + C <= h ; ++j){\n            tmp[i][j] = e;\n            if(j + C < h) e = e * B1 - t1 * a[i][j] + a[i][j + C];\n        }\n    }\n    \n    // ハッシュ作成行\n    ull t2 = 1;\n    for(int i = 0 ; i < R ; ++i) t2 *= B2;\n    \n    for(int j = 0 ; j + C <= h ; ++j){\n        ull e = 0;\n        for(int i = 0 ; i < R ; ++i) e = e * B2 + tmp[i][j];\n        \n        for(int i = 0 ; i + R <= w; ++i){\n            hash1[i][j] = e;\n            if(i + R < w) e = e * B2 - t2 * tmp[i][j] + tmp[i + R][j];\n        }\n    }\n}\n\nvoid solve(){\n    compute_hash(pattern, R, C);\n    ull res = hash1[0][0];\n    compute_hash(field, W, H);\n    for(int i = 0 ; i <= W ; ++i){\n        for(int j = 0 ; j <= H ; ++j){\n            if(res == hash1[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> W >> H;\n    for(int i = 0 ; i < W ; ++i){\n        for(int j = 0 ; j < H ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> R >> C;\n    for(int i = 0 ; i < R ;++i){\n        for(int j = 0 ; j < C ;++j){\n            cin >> pattern[i][j];\n        }\n    }\n    if(W < R && H < C) return 0;\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_T 10\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 10007;\n    const ull B2 = 100000007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 100000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 7) {\n\t\t\t\tlong long c1 = MOD - ((1LL << ((M - 1) * 8))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A=9999973,B=950527;\n\nint H,W;\nchar T[1005][1005];\null t[1005][1005];\null t2[1005][1005];\nint h,w;\nchar U[1005][1005];\n\n\nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n\n  ull target=0;\n  for(int i=0;i<h;i++){\n    ull key=0;\n    for(int j=0;j<w;j++){\n      key=key*B+U[i][j];\n    }\n    target=target*A+key;\n  }\n\n  ull C=1;\n  for(int i=0;i<w;i++)C*=B;\n\n  for(int i=0;i<H;i++){\n    ull key=0;\n    for(int j=0;j<W;j++){\n      key=key*B+T[i][j];\n      if(j-w>=0)key-=T[i][j-w]*C;\n      t[i][j]=key;\n      t2[i][j]=t[i][j];\n    }\n  }\n\n  C=1;\n  for(int i=0;i<h;i++)C*=A;\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(i)t[i][j]+=t[i-1][j]*A;\n      if(i-h>=0)t[i][j]-=t2[i-h][j]*C;\n      if(t[i][j]==target){\n        if(i-h+1>=0&&j-w+1>=0)\n          printf(\"%d %d\\n\",i-h+1,j-w+1);\n      }\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\nAhoCorasick aho(500000);\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (1000000007)\n#define P2 (99991)\n\n#define H (1000)\n#define W (1000)\n#define R (1000)\n#define C (1000)\nchar str[H][W];\nchar pat[R][C];\null str_hash[H][W];\null tmp[H][W];\n\nvoid rolling_hash(int height, int width, char character[H][W])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < width; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i + height < H; i++) {\n        \n        hash = 0;\n        for (int j = 0; j < width; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + width <= W; j++) {\n            tmp[i][j] = hash;\n            if (j + width < W) {\n                hash = hash * P1 + character[i][j + width] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < height; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + width <= W; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < height; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + height <= H; i++) {\n            str_hash[i][j] = hash;\n            if(i + height < H){\n                hash = hash * P2 + tmp[i + height][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    int sh, sw, ph, pw;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(ph, pw, str);\n    \n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t\tif (t >= 50000 && k>=30) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n//Modified case lByokoP,lMyokoP,ptnP\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point == -1){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){ //ADD\n\t\t\t\t\t\t\t\t\tif(T[row][col+tmp_col]!=P[row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tif(T[0][0]==P[0][0]){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include <cstdlib>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull X = 100001;\nconst ull Y = 9973;\nconst int MAX = 105;\n\null hash1[MAX][MAX];\null hash2[MAX][MAX];\n\nvoid hashCalc(int T[MAX][MAX],int H,int W,int R, int  C) {\n\t//x???X???C???\n\tull x = 1;\n\tfor (int i = 0; i < C; i++) {\n\t\tx *= X;\n\t}\n\n\tull y = 1;\n\tfor (int i = 0; i < R; i++) {\n\t\ty *= Y;\n\t}\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + T[i][j];\n\t\t}\n\t\tfor (int k = 0; k + C <= W; k++) {\n\t\t\thash1[i][k] = h;\n\t\t\th = h*X + T[i][k + C] - T[i][k] * x;\n\t\t}\n\t}\n\n\tfor (int j = 0; j + C <= W; j++) {\n\t\tull h = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\th=h*Y+hash1[i][j];\n\t\t}\n\t\tfor (int k = 0; k + R <= H; k++) {\n\t\t\thash2[k][j] = h;\n\t\t\th = h*Y + hash1[k + R][j] - hash1[k][j] * y;\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s,t;\n\t\n\tint H, W;\n\tcin >> H >> W;\n\tint T[MAX][MAX];\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s;\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tt=s[j];\n\t\t\tT[i][j]=atoi(t.c_str());\n\t\t}\n\t}\n\n\tint R, C;\n\tcin >> R >> C;\n\tint P[R][C];\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> s;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tt=s[j];\n\t\t\tP[i][j]=atoi(t.c_str());\n\t\t}\n\t}\n\n\tull tmp[R];\n\n\thashCalc(T, H, W, R, C);\n\t\n\tfor (int i = 0; i < R; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + P[i][j];\n\t\t}\n\t\ttmp[i] = h;\n\t}\n\n\tull hs = 0;\n\tfor (int i = 0; i < R; i++) {\n\t\ths = hs*Y + tmp[i];\n\t}\n\n\tfor (int i = 0; i + R <= H; i++) {\n\t\tfor (int j = 0; j + C <= W; j++) {\n\t\t\tif (hash2[i][j]==hs) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tif (R == 1) cout << i << \" \" << j << endl;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) cout << i << \" \" << j << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\nbool Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareRight(int idxi, int idxj)\n{\n\tint j = C - 1;\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareBottom(int idxi, int idxj)\n{\n\tint i = R - 1;\n\tfor (int j = C - 1; j >= 0; j--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CheckPP() {\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 1; j < C; j++) {\n\t\t\tif (P[i][j] != P[0][0]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//search and output\n\tif (CheckPP()) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tbool flag_ok = false;\n\t\tbool flag_r = true;\n\t\twhile (i + R <= H) {\n\t\t\tbool ret;\n\t\t\tif (flag_ok) {\n\t\t\t\tif (flag_r) {\n\t\t\t\t\tret = CompareRight(i, j);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = CompareBottom(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret = Compare(i, j);\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tflag_ok = true;\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tflag_ok = false;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i + R <= H) {\n\t\t\tif (Compare(i, j)) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD,T B>\nstruct RollingHash{\n  using ll = long long;\n  vector<T> hash,p;\n  RollingHash(){}\n  RollingHash(vector<T> vs){init(vs);}\n  RollingHash(string &s){\n    vector<T> vs;\n    for(char c:s) vs.emplace_back(c);\n    init(vs);\n  }\n  void init(vector<T> vs){\n    int n=vs.size();\n    hash.assign(n+1,0);\n    p.assign(n+1,1);\n    for(int i=0;i<n;i++){\n      hash[i+1]=((ll)hash[i]*B+vs[i])%MOD;\n      p[i+1]=(ll)p[i]*B%MOD;\n    }\n  }\n  //S[l, r)\n  T find(int l,int r){\n    T res=(ll)hash[r]+MOD-(ll)hash[l]*p[r-l]%MOD;\n    return res>=MOD?res-MOD:res;\n  }\n};\n\ntemplate<typename T,T MOD,T B1,T B2>\nauto rectangle_hash(vector<string> vs,int r,int c){\n  vector< RollingHash<T, MOD, B1> > hs;\n  for(string s:vs) hs.emplace_back(s);\n\n  int h=vs.size(),w=vs[0].size();\n  vector< vector<T> > res(h-r+1,vector<T>(w-c+1));\n\n  for(int j=0;j+c<=w;j++){\n    vector<T> ts(h);\n    for(int i=0;i<h;i++)\n      ts[i]=hs[i].find(j,j+c);\n\n    RollingHash<T, MOD, B2> rh(ts);\n    for(int i=0;i+r<=h;i++)\n      res[i][j]=rh.find(i,i+r);\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> ss(h);\n  for(int i=0;i<h;i++) cin>>ss[i];\n\n  int r,c;\n  cin>>r>>c;\n  vector<string> ts(r);\n  for(int i=0;i<r;i++) cin>>ts[i];\n\n  const int MOD = 1e9+7;\n  const int B1 = 1777771;\n  const int B2 = 1e8+7;\n  auto srh=rectangle_hash<int, MOD, B1, B2>(ss,r,c);\n  auto trh=rectangle_hash<int, MOD, B1, B2>(ts,r,c);\n\n  for(int i=0;i<h-r+1;i++)\n    for(int j=0;j<w-c+1;j++)\n      if(srh[i][j]==trh[0][0]) cout<<i<<\" \"<<j<<\"\\n\";\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\n// 行方向の和を保持する配列 ( 配列の要素No.から, 検索パターンの文字数分の和を格納する )\nlong ary_SumHW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズは, ary_HW[]より小さくなる\n\n// 行方向の和を保持する配列 ( 検索パターン側は, 行ごとの和のみで良い )\nlong ary_SumRC[MAX_ROW];\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        ary_SumRC[i] = 0;\n\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n\n            // 行ごとの和を求める\n            ary_SumRC[i] += ary_RC[i][j];\n        }\n    }\n\n    // ***************\n    // 各行の和を求める\n    // ***************\n    for(int i = 0; i < H; i++)\n    {\n        // 残りの要素が C 以下なら計算不要\n        for(int j = 0; j < W - C + 1; j++)\n        {\n            if( j == 0 )\n            {\n                ary_SumHW[i][j] = 0;\n\n                for(int k = 0; k < C; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_SumHW[i][j] += ary_HW[i][k];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, C個先の値を足しておく\n                ary_SumHW[i][j] = ary_SumHW[i][j - 1] - ary_HW[i][j - 1] + ary_HW[i][j + C - 1];\n            }\n        }\n    }\n\n    // パターン検索を実施する\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // // 行方向の和を確認\n            if( ary_SumHW[hPos][wPos] == ary_SumRC[0] )\n            {\n                bool searchGo = true;\n\n                // 全行の和を確認\n                for(int i = 1; i < R; i++)\n                {\n                    if( ary_SumHW[hPos + i][wPos] != ary_SumRC[i] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == true )\n                {\n                    // 文字パターンの検索を実施する\n                    patternMatching(hPos, wPos);\n                }\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の箇所が見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull P1=9973;\nconst ull P2=1e8+7;\n\nint r1,r2,c1,c2;\n\nconst int N=1e3+10;\nint mat[N][N],pat[N][N];\null cal[N][N];\null Hash;\n\nvector<pair<int,int> > ans;\n\nvoid getPatHash()\n{\n    Hash=0;\n    for(int i=0;i<r2;i++)\n    {\n        ull tmp=0;\n        for(int j=0;j<c2;j++)\n        {\n            tmp=tmp*P1+pat[i][j];\n        }\n        Hash=Hash*P2+tmp;\n    }\n}\n\nvoid go()\n{\n    ull tmp,base;\n    for(int i=0;i<r1;i++)\n    {\n        tmp=0;\n        base=1;\n        for(int j=0;j<c1&&j<c2;j++)\n        {\n            tmp=tmp*P1+mat[i][j];\n            base=base*P1;\n        }\n        cal[i][0]=tmp;\n        for(int j=c2;j<c1;j++)\n        {\n            tmp=tmp*P1-mat[i][j-c2]*base+mat[i][j];\n            cal[i][j-c2+1]=tmp;\n        }\n    }\n    for(int j=0;j+c2<=c1;j++)\n    {\n        tmp=0;\n        base=1;\n        ull temp;\n        for(int i=0;i<r1&&i<r2;i++)\n        {\n            tmp=tmp*P2+cal[i][j];\n            base=base*P2;\n        }\n        temp=cal[0][j];\n        cal[0][j]=tmp;\n        if(cal[0][j]==Hash){\n            ans.push_back(make_pair(0,j));\n        }\n        for(int i=r2;i<r1;i++)\n        {\n            tmp=tmp*P2-temp*base+cal[i][j];\n            temp=cal[i-r2+1][j];\n            cal[i-r2+1][j]=tmp;\n            if(cal[i-r2+1][j]==Hash)\n            {\n                ans.push_back(make_pair(i-r2+1,j));\n            }\n        }\n    }\n\n}\n\nint main()\n{\n    scanf(\"%d %d\",&r1,&c1);\n\n    char ch;\n\n    for(int i=0;i<r1;i++)\n    {\n        getchar();\n        for(int j=0;j<c1;j++)\n        {\n            ch=getchar();\n            mat[i][j]=ch;\n        }\n    }\n\n    scanf(\"%d %d\",&r2,&c2);\n\n    for(int i=0;i<r2;i++)\n    {\n        getchar();\n        for(int j=0;j<c2;j++)\n        {\n            ch=getchar();\n            pat[i][j]=ch;\n        }\n    }\n\n    getPatHash();\n\n    go();\n\n    sort(ans.begin(),ans.end());\n\n    for(int i=0;i<ans.size();i++)\n    {\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define INF (ll)(1e18)\n#define abs(x) (x >= 0 ? x : -(x))\n#define ceil(a, b) a / b + !!(a % b)\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\n\ntypedef unsigned long long ull;\nint n, m, p, q;\nconst int max_size = 1000;\nchar field[max_size][max_size]; // でかい方\nchar patterns[max_size][max_size]; // 小さい方\n\null hash_[max_size][max_size], tmp[max_size][max_size];\n\n// でかい方のhash計算用だが, 小さい方にも使える\nvoid compute_hash(char a[max_size][max_size], int n, int m) {\n    const ull B1 = 9973;\n    const ull B2 = 1000000007;\n    \n    // B1^q\n    ull t1 = 1;\n    rep(j, q) t1 *= B1;\n    \n    // 行方向\n    rep(i, n) {\n        ull e = 0;\n        rep(j, q) e = e * B1 + a[i][j];\n        for (int j = 0; j + q <= m; ++j) {\n            tmp[i][j] = e;\n            if (j + q < m) e = e * B1 - t1 * a[i][j] + a[i][j + q];\n        }\n    }\n    \n    // B1^p\n    ull t2 = 1;\n    rep(i, p) t2 *= B2;\n    \n    // 列方向\n    for (int j = 0; j + q <= m; ++j) {\n        ull e = 0;\n        rep(i, p) e = e * B2 + tmp[i][j];\n        \n        for (int i = 0; i + p <= n; ++i) {\n            hash_[i][j] = e;\n            if (i + p < n) e = e * B2 - t2 * tmp[i][j] + tmp[i + p][j];\n        }\n    }\n}\n\nvoid solve() {\n    set<ull> unseen;\n    \n    compute_hash(patterns, p, q);\n    unseen.insert(hash_[0][0]);\n    // cout << hash_[0][0] << endl;\n    \n    compute_hash(field, n, m);\n    for (int i = 0; i + p <= n; ++i) {\n        for (int j = 0; j + q <= m; ++j) {\n            // cout << i << \" \" << j << \" \" << hash_[i][j] << \" \" << n << \" \" << m << \" \" << p << \" \" << q << endl;\n            \n            if (unseen.find(hash_[i][j]) != unseen.end()) {\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n    \n    \n}\n\nint main() {\n    \n    cin >> n >> m;\n    rep(i, n) rep(j, m) cin >> field[i][j];\n    \n    cin >> p >> q;\n    rep(i, p) rep(j, q) cin >> patterns[i][j];\n    \n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(400000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nclass PMA {\nprivate:\n    uint32_t id = 0;\n\npublic:\n    struct Node {\n        uint32_t id;\n        string *str = nullptr;\n        unordered_map<uint8_t, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const string &str) {\n        Node *node = root;\n        for (uint8_t c : str) {\n            auto itr = node->children.find(c);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[c] = new Node;\n                node->children[c]->id = id++;\n                node = node->children[c];\n            }\n        }\n\n        node->str = new string(str);\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, uint8_t c) {\n        while (node != nullptr) {\n            auto itr = node->children.find(c);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                uint8_t c = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, c);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\n\nclass BakerBird {\nprivate:\n    PMA pma_p, pma_m;\n\npublic:\n    BakerBird(const vector<string> &P) {\n        string M;\n        for (string str : P) M += to_string(pma_p.insert(str));\n        pma_p.link_failure();\n\n        pma_m.insert(M);\n        pma_m.link_failure();\n    }\n\n    void match(const vector<string> &T) {\n        vector<string> T2(T[0].length());\n\n        for (string str : T) {\n            PMA::Node *node = pma_p.root;\n            for (uint32_t i = 0; i < str.length(); i++) {\n                node = pma_p.transition(node, str[i]);\n                T2[i] += to_string(node->id);\n            }\n        }\n\n        vector<pair<uint32_t, uint32_t>> res;\n        for (uint32_t c = 0; c < T2.size(); c++) {\n            PMA::Node *node = pma_m.root;\n            for (uint32_t r = 0; r < T2[c].length(); r++) {\n                node = pma_m.transition(node, T2[c][r]);\n                if (node->str != nullptr) {\n                    res.push_back(make_pair(r - node->str->length() + 1, c - 1));\n                }\n            }\n        }\n\n        sort(res.begin(), res.end());\n\n        for (auto p : res) {\n            cout << p.first << \" \" << p.second << endl;\n        }\n\n        return;\n    }\n};\n\nint main() {\n    int32_t H, W, R, C;\n    cin >> H >> W;\n\n    vector<string> T(H);\n    for (int32_t i = 0; i < H; i++) {\n        string temp;\n        cin >> temp;\n        T[i] = temp;\n    }\n\n    cin >> R >> C;\n\n    vector<string> P(R);\n    for (int32_t i = 0; i < R; i++) {\n        string temp;\n        cin >> temp;\n        P[i] = temp;\n    }\n\n    BakerBird bb(P);\n    bb.match(T);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int h, w, r, c;\n    string f1[1000], f2[1000];\n\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[0]) {\n                bool success = true;\n                for (int k = 1; k < r; k++) {\n                    if (f1[i + k].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\nbool Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareRight(int idxi, int idxj)\n{\n\tint j = C - 1;\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareBottom(int idxi, int idxj)\n{\n\tint i = R - 1;\n\tfor (int j = C - 1; j >= 0; j--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CheckPP() {\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 1; j < C; j++) {\n\t\t\tif (P[i][j] != P[0][0]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//search and output\n\tif (CheckPP) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tbool flag_ok = false;\n\t\tbool flag_r = true;\n\t\twhile (i + R <= H) {\n\t\t\tbool ret;\n\t\t\tif (flag_ok) {\n\t\t\t\tif (flag_r) {\n\t\t\t\t\tret = CompareRight(i, j);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = CompareBottom(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret = Compare(i, j);\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tflag_ok = true;\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tflag_ok = false;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i + R <= H) {\n\t\t\tif (Compare(i, j)) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 62;\n\nint encode(char c){\n\tint res = c - '0';\n\tif(isdigit(c)) return res;\n\tres += c - 'a';\n\tif(islower(c)) return res;\n\tres += c - 'A';\n\tif(isupper(c)) return res;\n\tassert(false && \"invalid string\");\n}\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = encode(str[str_index]);\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[encode(c)];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[encode(c)];\n\t\t}\n};\n\nclass KnuthMorrisPratt{\n\tpublic:\n\t\tvector<int> fail;\n\t\tstring t; // 探す文字列\n\t\tKnuthMorrisPratt(string& t) {\n\t\t\tthis->t = t;\n\t\t\tint m = t.size();\n\t\t\tfail = vector<int>(m + 1);\n\t\t\tint j = fail[0] = -1;\n\t\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\t\twhile (j >= 0 && t[j] != t[i - 1]) j = fail[j];\n\t\t\t\tfail[i] = ++j;\n\t\t\t}\n\t\t}\n\t\tvector<int> match(string& s){ // s に含まれる連続する部分文字列 t のインデックスを返す\n\t\t\tint n = s.size(), m = t.size();\n\t\t\tvector<int> res;\n\t\t\tfor (int i = 0, k = 0; i < n; ++i) {\n\t\t\t\twhile (k >= 0 && t[k] != s[i]) k = fail[k];\n\t\t\t\tif (++k >= m) {\n\t\t\t\t\tres.emplace_back(i - m + 1); // match at s[i-m+1 .. i]\n\t\t\t\t\tk = fail[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\n// tに一致するsの部分集合の左上の座標を返す\nvector<pair<int, int>> BakerBird(vector<string>& s, vector<string>& t){\n\tAhoCorasick aho;\n\tfor(auto str : t) aho.add(str);\n\taho.build();\n\n\tvector<vector<int>> status(s.size(), vector<int>(s[0].size()));\n\trep(i,s.size()){\n\t\tint now = 0;\n\t\trep(j,s[0].size()){\n\t\t\tnow = aho.next(now, s[i][j]);\n\t\t\tstatus[i][j] = now;\n\t\t}\n\t}\n\n\tstring patern;\n\trep(i,aho.ac.size()){\n\t\tpatern += aho.ac[i] + '0';\n\t}\n\n\tvector<pair<int, int>> res;\n\tKnuthMorrisPratt kmp(patern);\n\trange(i,t[0].size() - 1, s[0].size()){\n\t\tstring sstr; // statusを縦に見た文字列\n\t\trep(j,s.size()){\n\t\t\tsstr += status[j][i] + '0';\n\t\t}\n\t\tfor(auto y : kmp.match(sstr)){\n\t\t\tres.emplace_back(y, i - t[0].size() + 1);\n\t\t}\n\t}\n\tsort(all(res));\n\treturn res;\n}\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> s(h);\n\trep(i,h){\n\t\tcin >> s[i];\n\t}\n\n\n\tint c,r;\n\tcin >> r >> c;\n\tvector<string> t(r);\n\trep(i,r){\n\t\tcin >> t[i];\n\t}\n\n\tfor(auto p : BakerBird(s, t)){\n\t\tcout << p.first << ' ' << p.second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint H,W,R,C;\nchar f[1000][1000],p[1000][1000];\nint solve(int i, int j){\n\tint same = 1;\n\t//printf(\"now checking i: %d and j: %d\\n\",i,j);\n\tfor(int k=0;k<R;k++){\n\t\tfor(int l=0;l<C;l++){\n\t\t\t//printf(\"now checking k: %d and l: %d\\n\",k,l);\n\t\t\tif(f[i+k][j+l] != p[k][l]){\n\t\t\t\treturn 0;\n\t\t\t\t//printf(\"didn't match\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif(same == 1) return 1;\n}\n\nint main(){\n\tscanf(\"%d %d\",&W,&H);\n\tfor(int i=0;i<W;i++){\n\t\tscanf(\"%s\",&f[i]);\n\t}\n\t/*for(int i=0;i<W;i++){\n\t\tprintf(\"%s\\n\",f[i]);\n\t}*/\n\tscanf(\"%d %d\",&R,&C);\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%s\",&p[i]);\n\t}\n\t/*for(int i=0;i<R;i++){\n\t\tprintf(\"%s\\n\",p[i]);\n\t}*/\n\tfor(int i=0;i<=W-R;i++){\n\t\tfor(int j=0;j<=H-C;j++){\n\t\t\tif(solve(i,j)==1) printf(\"%d %d\\n\",i,j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cassert>\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 2, root=0;\n\n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = ch - '0';\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    if(nodes[id].link == -1){\n      if(!nodes[id].parent)nodes[id].link=root;\n      else nodes[id].link=trans(link(nodes[id].parent),nodes[id].ch);\n    }\n    return nodes[id].link;\n  }\n\n  int trans(int id, char ch) {\n    int c = ch - '0';\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    int minn = 1001, mini;\n    for (int i = 0; i < r; i++) {\n        int count[62] = { 0 }, maxn = 0;\n        for (int j = 0; j < c; j++) {\n            if ('0' <= f2[i][j] && f2[i][j] <= '9') {\n                count[f2[i][j] - '0']++;\n            }\n            if ('A' <= f2[i][j] && f2[i][j] <= 'Z') {\n                count[f2[i][j] - 55]++;\n            }\n            if ('a' <= f2[i][j] && f2[i][j] <= 'z') {\n                count[f2[i][j] - 61]++;\n            }\n        }\n        for (int j = 0; j < 62; j++) {\n            maxn = max(maxn, count[j]);\n        }\n        if (minn > maxn) {\n            minn = maxn;\n            mini = i;\n        }\n    }\n    \n    for (int i = mini; i <= h - r + mini; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[mini]) {\n                bool success = true;\n                for (int k = mini - 1; k >= 0; k--) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n                for (int k = mini + 1; k < r; k++) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i - mini << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T;\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n\n    long long hash[1000][1000];\n    long long s;\n\n    char P[1000];\n    for(i = 0; i < R; i++){\n        s = 0;\n        scanf(\"%s\", P);\n        for(j = 0; j < C; j++){\n            s = (s * B + P[j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * A + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * B + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * A + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\tdelete [] T;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint H, W, R, C; string s[1000], t[1000]; unsigned long long power[1001], h1[1000][1000], h2[1000];\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor(int i = 0; i < H; i++) cin >> s[i];\n\tscanf(\"%d%d\", &R, &C);\n\tfor(int i = 0; i < R; i++) cin >> t[i];\n\tpower[0] = 1;\n\tfor(int i = 1; i <= 1000; i++) power[i] = power[i - 1] * 257;\n\tfor(int i = 0; i < H; i++) {\n\t\tunsigned long long val = 1;\n\t\tfor(int j = 0; j < C; j++) val = val * 257 + s[i][j]; h1[i][0] = val;\n\t\tfor(int j = C; j < W; j++) val = val * 257 + s[i][j] - power[C] * s[i][j - C], h1[i][j - C - 1] = val;\n\t}\n\tfor(int i = 0; i < R; i++) {\n\t\tfor(int j = 0; j < C; j++) h2[i] = h2[i] * 257 + t[i][j];\n\t}\n\tfor(int i = 0; i <= H - R; i++) {\n\t\tfor(int j = 0; j <= W - C; j++) {\n\t\t\tbool flag = true;\n\t\t\tfor(int k = i; k < i + R; k++) {\n\t\t\t\tif(h1[k][j] != h2[k - i]) {\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\tif (t >= 500 && k >= 60) {\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include <cstdlib>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull X = 100001;\nconst ull Y = 9973;\nconst int MAX = 105;\n\null hash1[MAX][MAX];\null hash2[MAX][MAX];\n\nvoid hashCalc(int T[MAX][MAX],int H,int W,int R, int  C) {\n\t//x???X???C???\n\tull x = 1;\n\tfor (int i = 0; i < C; i++) {\n\t\tx *= X;\n\t}\n\n\tull y = 1;\n\tfor (int i = 0; i < R; i++) {\n\t\ty *= Y;\n\t}\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + T[i][j];\n\t\t}\n\t\tfor (int k = 0; k + C <= W; k++) {\n\t\t\thash1[i][k] = h;\n\t\t\th = h*X + T[i][k + C] - T[i][k] * x;\n\t\t}\n\t}\n\n\tfor (int j = 0; j + C <= W; j++) {\n\t\tull h = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\th=h*Y+hash1[i][j];\n\t\t}\n\t\tfor (int k = 0; k + R <= H; k++) {\n\t\t\thash2[k][j] = h;\n\t\t\th = h*Y + hash1[k + R][j] - hash1[k][j] * y;\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s,t;\n\t\n\tint H, W;\n\tcin >> H >> W;\n\tint T[MAX][MAX];\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s;\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tt=s[j];\n\t\t\tT[i][j]=atoi(t.c_str());\n\t\t}\n\t}\n\n\tint R, C;\n\tcin >> R >> C;\n\tint P[R][C];\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> s;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tt=s[j];#include <cstdlib>\n\t\t\tP[i][j]=atoi(t.c_str());\n\t\t}\n\t}\n\n\tull tmp[R];\n\n\thashCalc(T, H, W, R, C);\n\t\n\tfor (int i = 0; i < R; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + P[i][j];\n\t\t}\n\t\ttmp[i] = h;\n\t}\n\n\tull hs = 0;\n\tfor (int i = 0; i < R; i++) {\n\t\ths = hs*Y + tmp[i];\n\t}\n\n\tfor (int i = 0; i + R <= H; i++) {\n\t\tfor (int j = 0; j + C <= W; j++) {\n\t\t\tif (hash2[i][j]==hs) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint h, w, r, c;\nstring t[1000], p[1000];\n\nbool check(int x, int y) {\n    for(int i=0; i<r; i++) {\n        for(int j=0; j<c; j++) {\n            if(t[y+i][x+j]!=p[i][j]) return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>h>>w;\n    for(int i=0; i<h; i++) \n        cin>>t[i];\n    cin>>r>>c;\n    for(int i=0; i<r; i++) \n        cin>>p[i];\n    for(int y=0; y<=h-r; y++) {\n        for(int x=0; x<=w-c; x++) {\n            if(check(x, y)) {\n                cout<<y<<' '<<x<<'\\n';\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "t = gets.chomp\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  if t.index(p) == nil then\n    puts \"0\"\n  else\n    puts \"1\"\n  end\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1125899906842624LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> y[i][j];\n\t\t\tsum *= 2; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 2; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 50) {\n\t\t\t\tlong long c1 = MOD - ((1LL << (M - 1))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 2;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n  \n  \nusing namespace std;\n  \nstruct AhoCorasick {\n  \n  static const int ALPHABET_SIZE = 62, root=0;\n  \n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n    \n  int N; // num of node\n  \n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n  \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n  \n  vector<Node> nodes;\n  \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n  \n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n    nodes[N].parent = cur;\n    nodes[N].ch = ch;\n    nodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n  \n  int link(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n  \n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n  \ntypedef pair<int,int> pii;\n  \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n  \n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n    \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n  \n  const int til = T[0].size();\n    \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n  \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n  \nint main(void){\n  int h,w,r,c;\n    \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n  \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvoid gen_hash(const vector<string> &m,int H,int W,int R,int C,vector<vector<long long> >&hash){\n\tvector<vector<long long> > hash1(H);\n\thash.resize(H);\n\n\tfor(int h=0;h<H;h++){\n\t\thash1[h].resize(W);\n\t\thash[h].resize(W);\n\n\t\tlong long c=0;\n\t\tlong long Brev=1;\n\t\tfor(int w=0;w<W;w++){\n\t\t\tc=(c*B+m[h][w])%P;\n\t\t\tif(w<C)Brev=Brev*B%P;else c=((c-m[h][w-C]*Brev)%P+P)%P;\n\t\t\thash1[h][w]=c;\n\t\t}\n\t}\n\tfor(int w=0;w<W;w++){\n\t\tlong long c=0;\n\t\tlong long Brev=1;\n\t\t\tfor(int h=0;h<H;h++){\n\t\t\tc=(c*B+hash1[h][w])%P;\n\t\t\tif(h<R)Brev=Brev*B%P;else c=((c-hash1[h-R][w]*Brev)%P+P)%P;\n\t\t\thash[h][w]=c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint H,W,R,C;\n\tcin>>H>>W;\n\tvector<string>field(H);\n\tfor(int i=0;i<H;i++)cin>>field[i];\n\tcin>>R>>C;\n\tvector<string>pattern(R);\n\tfor(int i=0;i<H;i++)cin>>pattern[i];\n\tvector<vector<long long> >hash_field,hash_pattern;\n\tgen_hash(field,H,W,R,C,hash_field);\n\tgen_hash(pattern,R,C,R,C,hash_pattern);\n\tfor(int h=R-1;h<H;h++)for(int w=C-1;w<W;w++){\n\t\tif(hash_field[h][w]==hash_pattern[R-1][C-1])printf(\"%d %d\\n\",h-R+1,w-C+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] == S[k + i].substr(j, c)) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == r) {\n\t\t\t\tcout << i << ' ' << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<string>\n\n#define MAX 1000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint H,W,R,C;\nchar field[MAX][MAX]; //????´¢????±?\nchar pattern[MAX][MAX]; //????????????\n\null hashh[MAX][MAX],temp[MAX][MAX];\null target;\n\n//a???R*C?????¨??????hash????¨????\nvoid compute_hash(char a[MAX][MAX], int n, int m){\n\tconst ull B1=9973;\n\tconst ull B2=100000007;\n\t\n\tull t1=1;//B1???C???\n\tfor(int i=0;i<C;i++) t1*=B1;\n\t//????????????hash????¨????\n\tfor(int i=0;i<n;i++){\n\t\tull e=0;\n\t\tfor(int j=0;j<C;j++) e=e*B1+a[i][j];\n\t\tfor(int j=0;C+j<=m;j++){\n\t\t\ttemp[i][j]=e;\n\t\t\te=e*B1-t1*a[i][j]+a[i][j+C];\n\t\t}\n\t}\n\tull t2=1;//B2???R???\n\tfor(int i=0;i<R;i++) t2*=B2;\n\tfor(int j=0;j+C<=m;j++){\n\t\tull e=0;\n\t\tfor(int i=0;i<R;i++) e=e*B2+temp[i][j];\n\t\tfor(int i=0;i+R<=n;i++){\n\t\t\thashh[i][j]=e;\n\t\t\te=e*B2-t2*temp[i][j]+temp[i+R][j];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcompute_hash(pattern,R,C);//pattern???hash???????±???????\n\ttarget=hashh[0][0];\n\tcompute_hash(field,H,W);//field???hash???????±???????\n\t//target??¨?????´??????hash??????search\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(target==hashh[i][j])\n\t\t\tprintf(\"%d %d\\n\",i,j);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&H,&W);\n\tcin.ignore();\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%c\",&field[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tscanf(\"%d %d\",&R,&C);\n\tcin.ignore();\n\tfor(int i=0;i<R;i++){\n\t\tfor(int j=0;j<C;j++){\n\t\t\tscanf(\"%c\",&pattern[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_T 10\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 9973;\n    const ull B2 = 100000007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef unsigned long long lli;\ntypedef unsigned long long ull;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nint h,w;\nvst m;\nint r,c;\nvst x;\nmat cmpm;\nlli hsh = 0;\nlli cmp = 0;\n\nconst lli b = 1000000007;\nlli bbr = 1,bbc = 1;\n\nvector<pll> ans;\n\nint main(){\n    cin >> h >> w;\n    m = vst(h);\n    for(lli i = 0;i < h;i++) cin >> m[i];\n    cin >> r >> c;\n    x = vst(r);\n    for(lli i = 0;i < r;i++) cin >> x[i];\n    for(lli i = 0;i < r;i++) bbr *= b;\n    for(lli i = 0;i < c;i++) bbc *= b;\n    for(lli i = 0;i < r;i++){\n        lli hs = 0;\n        for(lli j = 0;j < c;j++){\n            hs =\n            hs*b + \n            x[i][j];\n        }\n        hsh = hsh*b + hs;\n    }\n    cmpm = mat(h,vll(w));\n    for(int i = 0;i < h;i++){\n        for(int j = 0;j < w;j++){\n            cmpm[i][j] = \n            (j-1 >= 0 ? cmpm[i][j-1]*b : 0) + \n            m[i][j] - \n            (j-c >= 0 ? m[i][j-c]*bbc : 0);\n        }\n    }\n    for(int j = 0;j < w;j++){\n        cmp = 0;\n        for(int i = 0;i < h;i++){\n            cmp = \n            cmp*b + \n            cmpm[i][j] -\n            (i-r >= 0 ? cmpm[i-r][j]*bbr : 0);\n            if(cmp == hsh) ans.push_back(pll(i-r+1,j-c+1));\n        }\n    }\n    sort(ans.begin(),ans.end());\n    for(lli i = 0;i < ans.size();i++) cout << ans[i].first << \" \" << ans[i].second << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 950527\n#define base2 1777771\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair <int,int> P;\nll A[1001][1001];\nstring a[1001],b[1001];\n\nint main(){\n  int W,H,w,h;\n  cin>>H>>W;\n  for(int i=0;i<H;i++)cin>>a[i];\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>b[i];\n\n\n  ll target=0;\n  for(int i=0;i<h;i++){\n    ll key=0;\n    for(int j=0;j<w;j++){\n      key=key*base+b[i][j];\n    }\n    target=target*base2+key;\n  }\n  \n  for(int i=0;i<H;i++){\n    ll k=0,l=1;\n    for(int j=0;j<W;j++){\n      k=k*base+a[i][j];\n      if(j-w>=0) k-= l*a[i][j-w];\n      else l*=base;\n      A[i][j]=k;\n    }\n  }\n\n  vector <P> ans;\n  for(int j=w;j<W;j++){\n    ll k=0,l=1;\n    for(int i=0;i<H;i++){\n      k=k*base2+A[i][j];\n      if(i-h>=0) k-=l*A[i-h][j];\n      else l*=base2;\n      if(target==k) ans.push_back(P(i-h+1,j-w+1)); \n    }\n  }\n\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<(int)ans.size();i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\null hash2d(char a[][MAX],int r,int c)\n{\n\tull tmp[r]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmp[i]=tmp[i]*B1+a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<r;i++)\n\t{\n\t\ttmp[0]=tmp[0]*B2+tmp[i];\n\t}\n\treturn tmp[0];\n}\n\nvector<pair<int,int>> match2d(char s[][MAX],char a[][MAX],int h,int w,int r,int c)\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash=hash2d(a,r,c);\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tchar s[MAX][MAX];\n\tchar a[MAX][MAX];\n\tint h,w,r,c;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d(s,a,h,w,r,c);\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\tif (t >= 500 && k >= 50) {\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            if( ary_HW[i][j] == ary_RC[0][0] )\n            {\n                // 先頭文字を比較\n                patternMatching(i, j);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    hEnd = hPos + ( R - 1 );\n    wEnd = wPos + ( C - 1 );\n\n    if( hEnd > H - 1 || wEnd > W - 1 )\n    {\n        // 配列の範囲をオーバーしているので, 検索不要\n        return;\n    }\n\n    if( ary_HW[hPos][wEnd] == ary_RC[0][C - 1] )\n    {\n        int rPos = 0;\n\n        startPoint.x = hPos;\n        startPoint.y = wPos;\n\n        for(int colNum = hPos; colNum < hPos + H - 1; colNum++)\n        {\n            matchFlag = false;\n\n            // 最終文字を比較\n            p_search(colNum, wPos, rPos, 0, C - 1);\n\n            if( matchFlag == false )\n            {\n                break;\n            }\n\n            rPos++;\n        }\n\n        if( matchFlag == true )\n        {\n            // 文字列のパターンが一致する箇所が見つかった\n            Qst.push(startPoint);\n        }\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\nconst ll MOD = (ll)1e9+7;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n\tif(was_output)cout << \" \";\n\tcout << a;\n\twas_output = true;\n}\nvoid outendl(){\n\twas_output = false;\n\tcout << endl;\n}\n\ntemplate<ll B, ll MOD>\nclass rolling_hash{\npublic:\n\tvector<int> prefix;\n\n\tvvector<ll> to_hash(const vector<string> &x){\n\t\tint h = x.size();\n\t\tint w = x.front().size();\n\t\tvvector<ll> res(h, vector<ll>(w));\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tres[i][j] = x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<pii> solve(const vector<string> &x, const vector<string> &y){\n\t\tvvector<ll> x_, y_;\n\t\tx_ = to_hash(x);\n\t\ty_ = to_hash(y);\n\t\treturn solve(x_, y_, B);\n\t}\n\n\tvector<pii> solve(const vvector<ll> &x, const vvector<ll> &y, ll b){\n\t\tint x_h = x.size();\n\t\tint x_w = x.front().size();\n\t\tint y_h = y.size();\n\t\tint y_w = y.front().size();\n\t\tif(x_h<y_h||x_w<y_w)return vector<pii>(0);\n\t\tll pow_b_y_h = 1;\n\t\tll pow_b_y_h_1 = 1;\n\t\tfor(int i=0;i<y_h;++i){\n\t\t\tpow_b_y_h = pow_b_y_h * b % MOD;\n\t\t}\n\t\tfor(int i=0;i<y_h-1;++i){\n\t\t\tpow_b_y_h_1 = pow_b_y_h_1 * b % MOD;\n\t\t}\n\t\tvvector<ll> hash_table(x_h-y_h+1, vector<ll>(x_w));\n\t\tvector<ll> y_hash(y_w);\n\t\tfor(int i=0;i<x_w;++i){\n\t\t\tll now_hash = 0;\n\t\t\tfor(int j=0;j<y_h-1;++j){\n\t\t\t\tnow_hash = now_hash * b + x[j][i];\n\t\t\t\tnow_hash %= MOD;\n\t\t\t}\n\t\t\tfor(int j=0;j<x_h-y_h+1;++j){\n\t\t\t\tnow_hash = now_hash * b + x[j+y_h-1][i];\n\t\t\t\tnow_hash %= MOD;\n\t\t\t\thash_table[j][i] = now_hash;\n\t\t\t\tif(j+y_h<x_h){\n\t\t\t\t\tnow_hash = now_hash - x[j][i] * pow_b_y_h_1;\n\t\t\t\t\tnow_hash = (now_hash % MOD + MOD) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<y_w;++i){\n\t\t\tll now_hash = 0;\n\t\t\tfor(int j=0;j<y_h;++j){\n\t\t\t\tnow_hash = now_hash * b + y[j][i];\n\t\t\t\tnow_hash %= MOD;\n\t\t\t}\n\t\t\ty_hash[i] = now_hash;\n\t\t}\n\t\tvector<pii> res;\n\t\tfor(int i=0;i<x_h-y_h+1;++i){\n\t\t\tvector<int> now_res = solve(hash_table[i], y_hash, pow_b_y_h);\n\t\t\tfor(auto j:now_res){\n\t\t\t\tres.emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t} \n\n\tvector<int> solve(const string &x, const string &y){\n\t\tvector<ll> x_, y_;\n\t\tfor(auto i:x){\n\t\t\tx_.push_back(i);\n\t\t}\n\t\tfor(auto i:y){\n\t\t\ty_.push_back(i);\n\t\t}\n\t\treturn solve(x_, y_, B);\n\t}\n\n\tvector<int> solve(const vector<ll> &x, const vector<ll> &y, ll b){\n\t\tll x_len = x.size();\n\t\tll y_len = y.size();\n\t\tll pow_b_y = 1;\n\t\tif(x_len<y_len)return vector<int>(0);\n\n\t\tll x_hash = 0;\n\t\tll y_hash = 0;\n\t\trep(i, y_len){\n\t\t\ty_hash = y_hash * b + y[i];\n\t\t\tx_hash = x_hash * b + x[i];\n\t\t\tpow_b_y = pow_b_y * b;\n\t\t\ty_hash %= MOD;\n\t\t\tx_hash %= MOD;\n\t\t\tpow_b_y %= MOD;\n\t\t}\n\t\tprefix.clear();\n\t\tfor(int i=y_len;i<=x_len;++i){\n\t\t\tif(x_hash==y_hash){\n\t\t\t\tprefix.emplace_back(i-y_len);\n\t\t\t}\n\t\t\tif(i<x_len){\n\t\t\t\tx_hash = x_hash * b - x[i-y_len] * pow_b_y + x[i];\n\t\t\t\tx_hash = (x_hash % MOD + MOD) % MOD;\n\t\t\t\tx_hash %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn prefix;\n\t}\n\n};\n\n\nint main(){\n\trolling_hash<17777, (ll)1e9+7> r;\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> target(h);\n\tforeach(i, target){\n\t\tcin >> i;\n\t}\n\tcin >> h >> w;\n\tvector<string> search(h);\n\tforeach(i, search){\n\t\tcin >> i;\n\t}\n\tvector<pii> ans = r.solve(target, search);\n\tforeach(i, ans){\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<RollingHash>rhs(H);\n\tvector<string>sts(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\tcin >> sts[i];\n\t\trhs[i].init(sts[i]);\n\t}\n\tint R, C; cin >> R >> C;\n\tvector<ha>hashes(R);\n\tfor (int i = 0; i < R; ++i) {\n\t\tstring st; cin >> st;\n\t\tRollingHash rh;\n\t\trh.init(st);\n\t\thashes[i] = rh.hash();\n\t}\n\tfor (int u = 0; u <= H - R; ++u) {\n\t\tfor (int l = 0; l <= W - C; ++l) {\n\t\t\tbool ok = true;\n\t\t\tfor (int y = u; y < u + R; ++y) {\n\t\t\t\tif (hashes[y - u] == rhs[y].hash(l, l + C-1)) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcout << u << \" \" << l << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull X = 3;\nconst ull Y = 5;\nconst int MAX = 1005;\n\null hash1[MAX][MAX];\null hash2[MAX][MAX];\n\nvoid hashCalc(int T[MAX][MAX],int H,int W,int R, int  C) {\n\t//x???X???C???\n\tull x = 1;\n\tfor (int i = 0; i < C; i++) {\n\t\tx *= X;\n\t}\n\n\tull y = 1;\n\tfor (int i = 0; i < R; i++) {\n\t\ty *= Y;\n\t}\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + T[i][j];\n\t\t}\n\t\tfor (int k = 0; k + C <= W; k++) {\n\t\t\thash1[i][k] = h;\n\t\t\th = h*X + T[i][k + C] - T[i][k] * x;\n\t\t}\n\t}\n\n\tfor (int j = 0; j + C <= W; j++) {\n\t\tull h = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\th=h*Y+hash1[i][j];\n\t\t}\n\t\tfor (int k = 0; k + R <= H; k++) {\n\t\t\thash2[k][j] = h;\n\t\t\th = h*Y + hash1[k + R][j] - hash1[k][j] * y;\n\t\t}\n\t}\n}\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tint T[MAX][MAX];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> T[i][j];\n\t\t}\n\t}\n\n\tint R, C;\n\tcin >> R >> C;\n\tint P[R][C];\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tull tmp[R];\n\n\thashCalc(T, H, W, R, C);\n\t\n\tfor (int i = 0; i < R; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + P[i][j];\n\t\t}\n\t\ttmp[i] = h;\n\t}\n\n\tull hs = 0;\n\tfor (int i = 0; i < R; i++) {\n\t\ths = hs*Y + tmp[i];\n\t}\n\n\tfor (int i = 0; i + R <= H; i++) {\n\t\tfor (int j = 0; j + C <= W; j++) {\n\t\t\tif (hash2[i][j]==hs) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 100000000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 7) {\n\t\t\t\tlong long c1 = MOD - ((1LL << ((M - 1) * 8))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_C\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n\tint H, W, R, C;\n\tvector<string> T, P;\n\tstring str;\n\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++){\n\t\tcin>>str;\n\t\tT.push_back(str);\n\t}\n\n\tcin>>R>>C;\n\tfor(int i=0;i<R;i++){\n\t\tcin>>str;\n\t\tP.push_back(str);\n\t}\n\n\tif((H>=R) && (W>=C))\n\t\tfor(int i=0;i<=H-R;i++)\n\t\t\tfor(int j=0;j<=W-C;j++)\n\t\t\t\tif(T[i].substr(j, C) == P[0])\n\t\t\t\t\tfor(int k=i+1;k<i+R;k++)\n\t\t\t\t\t\tif(T[k].substr(j, C) == P[k-i])\n\t\t\t\t\t\t\tif(k == R+i-1)\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    int32_t H, W;\n    cin >> H >> W;\n\n    string T;\n    for (int32_t i = 0; i < H; i++) {\n        string temp;\n        cin >> temp;\n        T += temp;\n    }\n\n    int32_t R, C;\n    cin >> R >> C;\n\n    string P;\n    for (int32_t i = 0; i < R; i++) {\n        string temp;\n        cin >> temp;\n        P += temp;\n        if (i < R-1) {\n            for (int32_t j = C; j < W; j++) P += '?';\n        }\n    }\n\n    unordered_map<uint8_t, int32_t> bch;\n    bch['?'] = P.length();\n    for (uint32_t i = 0; i < P.length()-1; i++) {\n        bch[P[i]] = min((int32_t)(P.length()-i-1), bch['?']);\n    }\n    bch[P[P.length()-1]] = min((int32_t)P.length(), bch['?']);\n\n    int32_t i = 0;\n    while (i <= (int32_t)(T.length() - P.length())) {\n        int32_t j = P.length()-1;\n\n        while (j >= 0 && (T[i+j] == P[j] || P[j] == '?')) j--;\n\n        if (j < 0) {\n            cout << i / W << \" \" << i % W << endl;\n            i++;\n        } else {\n            auto itr = bch.find(T[i+j]);\n            if (itr != bch.end()) {\n                i += max(itr->second + j - (int32_t)P.length() + 1, 1);\n            } else {\n                i += j+1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tif(multFLG==true){\n\n\t\tchar p00=P[0][0];\n\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=t_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tif(t_multFLG){\n\n\t\t\tif(((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<P_h;row++){\n\t\t\t\t\tfor(int col=0;col<P_w;col++){\n\t\t\t\t\t\tif(P[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(T_w-1<center_col+(P_w-1)){\n\t\t\t\t\t\tdel_right=T_w-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_right=center_col+(P_w-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(T_h-1<center_row+(P_h-1)){\n\t\t\t\t\t\tdel_floor=T_h-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_floor=center_row+ (P_h-1);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(T[0][0]==P[0][0]){\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (63533)\n#define P2 (100007)\n\n#define MAX (1010)\nchar str[MAX][MAX];\nchar pat[MAX][MAX];\null str_hash[MAX][MAX];\null tmp[MAX][MAX];\nint sh, sw, ph, pw;\n\nvoid rolling_hash(int height, int width, char character[MAX][MAX])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < pw; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i < height; i++) {\n        hash = 0;\n        for (int j = 0; j < pw; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + pw <= width; j++) {\n            tmp[i][j] = hash;\n            if (j + pw < width) {\n                hash = hash * P1 + character[i][j + pw] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < ph; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + pw <= width; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < ph; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + ph <= height; i++) {\n            str_hash[i][j] = hash;\n            if(i + ph < height){\n                hash = hash * P2 + tmp[i + ph][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(sh, sw, str);\n    \n    if (ph > sh || pw > sw) return 0;\n    \n    for(int i = 0; i <= sh; i++){\n        for (int j = 0; j <= sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] != -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ??????????????????????????????????????????????????????????????¶??????acc?????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n\n  \n  int td[pil][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, T[i][j]);\n      td[pil-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<pil;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by ?????°?????? on 2016/07/02.\n//\n\n#include <iostream>\nusing namespace std;\nconst int MAX =1010;\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 10007;\n\n    ull t1 = 1;\n    for (int j = 0; j < Q ; ++j)  t1 *= B1;\n\n    for (int i = 0; i < n ; ++i) {\n        ull e = 0;\n        for (int j = 0; j < Q ; ++j)  e = e * B1  + a[i][j];\n        for (int j = 0; j + Q < m  ; ++j) {\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q];\n        }\n    }\n\n    ull t2 = 1;\n\n    for (int j = 0; j + Q <= m  ; ++j) {\n        ull e = 0;\n        for (int i = 0; i < P ; ++i)e = e * B2 + tmp[i][j];\n        for (int i = 0; i + P <= n ; ++i) {\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i + P][j];\n        }\n    }\n}\n\nvoid solve(){\n    compute_hash(pattern,P,Q);\n    ull res = hash[0][0];\n    compute_hash(field,N,M);\n    for (int i = 0; i <= N ; ++i) {\n        for (int j = 0; j <= M ; ++j) {\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for (int i = 0; i < N ; ++i) {\n        for (int j = 0; j < M ; ++j) {\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for (int i = 0; i < P ; ++i) {\n        for (int j = 0; j < Q ; ++j) {\n            cin >> pattern[i][j];\n        }\n        if(N < P && M < Q) return 0;\n        solve();\n        return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nconstexpr long long INF = 1LL << 60;\nconstexpr long long MOD = 1000000007;\ndouble PI = acos(-1.0);\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define perm(c) sort(ALL(c));for(bool c##p=1;c##p;c##p=next_permutation(ALL(c)))\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define drop(x) cout << (x) << '\\n', exit(0)\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> tpl;\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> vec2;\ntypedef vector<vector<vector<ll>>> vec3;\ntemplate<class S, class T> inline bool chmax(S &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class S, class T> inline bool chmin(S &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline ll msb(ll v) { return 1 << (31 - __builtin_clzll(v)); }\ninline ll devc(ll x, ll y) { return (x + y - 1) / y; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }\n \nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n} iosetup;\n \ntemplate< typename T1, typename T2 >\nostream &operator << (ostream &os, const pair< T1, T2 > &p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator >> (istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nostream &operator << (ostream &os, const tuple< T1, T2, T3 > &t) {\n    os << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t);\n    return os;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nistream &operator >> (istream &is, tuple< T1, T2, T3 > &t) {\n    is >> get<0>(t) >> get<1>(t) >> get<2>(t);\n    return is;\n}\n \ntemplate< typename T >\nostream &operator << (ostream &os, const vector< T > &v){\n    for (int i = 0; i < (int)v.size(); ++i) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\n \ntemplate< typename T >\nistream &operator >>  (istream &is, vector< T > &v){\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate< typename T >\nostream &operator << (ostream &os, const set< T > &st){\n    int ct = 0;\n    for(auto& s : st) cout << s << (++ct != st.size() ? \" \" : \"\");\n    return os;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator|= (set<T> &st1, const set<T> &st2) { \n    for(auto& s : st2) st1.insert(s);\n    return st1; \n}\n\ntemplate <typename T>\nconstexpr set<T> &operator-= (set<T> &st1, const set<T> &st2) {\n    for(auto& s : st2) if(st1.count(s)) st1.erase(s);\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator&= (set<T> &st1, const set<T> &st2) {\n    auto itr = st1.begin();\n    while(itr != st1.end()){\n        if(!st2.count(*itr)) itr = st1.erase(itr);\n        else ++itr;\n    }\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator| (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res |= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator- (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res -= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator& (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res &= st2;\n    return res;\n}\n\n/*---------------------------------    Tools    ------------------------------------------*/\ntemplate< typename T >\nvector<T> cumsum(const vector<T> &X){\n    vector<T> res(X.size() + 1, 0);\n    for(int i = 0; i < X.size(); ++i) res[i + 1] += res[i] + X[i];\n    return res;\n}\n \ntemplate< typename S, typename T, typename F>\npair<T, T> bisearch(S left, T right, F f) {\n    while(abs(right - left) > 1){\n        T mid = (right + left) / 2;\n        if(f(mid)) right = mid;\n        else left = mid;\n    }\n    return {left, right};\n}\n \ntemplate< typename S, typename T, typename F>\ndouble trisearch(S left, T right, F f, int maxLoop = 90){\n    double low = left, high = right;\n    while(maxLoop--){\n        double mid_left = high / 3 + low * 2 / 3;\n        double mid_right = high * 2 / 3 + low / 3;\n        if(f(mid_left) >= f(mid_right)) low = mid_left;\n        else high = mid_right;\n    }\n    return (low + high) * 0.5;\n}\n\ntemplate< typename F >\nll ternarySearch(ll L, ll R, F f) { //[L, R)\n    ll lo = L - 1, hi = R - 1;\n    while (lo + 1 != hi) {\n        ll mi = (lo + hi) / 2;\n        if (f(mi) <= f(mi + 1)) hi = mi;\n        else lo = mi;\n    }\n    return hi;\n}\n\nstruct xorShift128 {\n    ull x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    xorShift128(ull seed = 0) {\n        w ^= seed;\n    }\n    ull operator()() {\n        ull t = x ^ (x << 11);\n        x = y; y = z; z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n};\n\nxorShift128 xs(time(NULL));\nconst unsigned long long BASE = xs();\nstruct RollingHash {\n    const ull MASK30 = (1ull << 30) - 1;\n    const ull MASK31 = (1ull << 31) - 1;\n    const ull MOD = (1ull << 61) - 1;\n    const ull MASK61 = MOD;\n    const ull POSITIVIZER = MOD * ((1ull << 3) - 1);\n    const ull base;\n\n    vector<ull> hashed, power;\n\n    RollingHash(const string& s, ull base = BASE) : hashed(s.size() + 1, 0), power(s.size() + 1, 0), base(base) {\n        power[0] = 1;\n        for (int i = 0; i < s.size(); ++i) power[i + 1] = CalcMod(Mul(power[i], BASE));\n        for (int i = 0; i < s.size(); ++i) hashed[i + 1] = CalcMod(Mul(hashed[i], BASE) + s[i]);\n    }\n\n    RollingHash(const vector<ull>& s, ull base = BASE) : hashed(s.size() + 1, 0), power(s.size() + 1, 0), base(base) {\n        power[0] = 1;\n        for (int i = 0; i < s.size(); ++i) power[i + 1] = CalcMod(Mul(power[i], BASE));\n        for (int i = 0; i < s.size(); ++i) hashed[i + 1] = CalcMod(Mul(hashed[i], BASE) + s[i]);\n    }\n\n    ull get(int l, int r) { // [L, r)\n        return CalcMod(hashed[r] + POSITIVIZER - Mul(hashed[l], power[r - l]));\n    }\n\n    ull Mul(ull a, ull b) {\n        ull au = a >> 31;\n        ull ad = a & MASK31;\n        ull bu = b >> 31;\n        ull bd = b & MASK31;\n        ull mid = ad * bu + au * bd;\n        ull midu = mid >> 30;\n        ull midd = mid & MASK30;\n        return au * bu * 2 + midu + (midd << 31) + ad * bd;\n    }\n\n    ull CalcMod(ull x) {\n        ull xu = x >> 61;\n        ull xd = x & MASK61;\n        ull res = xu + xd;\n        if (res >= MOD) res -= MOD;\n        return res;\n    }\n};\n\n/*------------------------------- Main Code Here -----------------------------------------*/\n \nint main()\n{\n    ll H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    cin >> S;\n    ll R, C;\n    cin >> R >> C;\n    vector<string> T(R);\n    cin >> T;\n\n    vector<vector<ull>> hash(H);\n\n    map<ull, ll> mp;\n    ll ct = 50;\n\n    rep(i, H){\n        RollingHash RH(S[i]);\n        rep(j, W) if (j + C <= W) {\n            ll x = RH.get(j, j + C);\n            if (!mp.count(x)) mp[x] = ct, ++ct;\n            hash[i].pb(mp[x]);\n        }\n    }\n\n    vector<vector<ull>> tmp(H, vector<ull>(W));\n\n    rep(j, W) if(j + C <= W) {\n        vector<ull> now;\n        rep(i, H) now.pb(hash[i][j]);\n        RollingHash X(now);\n        rep(i, H) if (i + R <= H) {\n            tmp[i][j] = X.get(i, i + R);\n        }\n    }\n\n\n    vector<ull> h;\n    rep(i, R){\n        RollingHash RH(T[i]);\n        ull x = RH.get(0, C);\n        if (!mp.count(x)) mp[x] = ct, ++ct;\n        h.emplace_back(mp[x]);\n    }\n    RollingHash RH(h);\n\n    ll res = RH.get(0, R);\n\n    rep(i, H - R + 1) rep(j, W - C + 1){\n        if (tmp[i][j] == res) cout << i << \" \" << j << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, R, C; string s[1000], t[1000]; unsigned long long power[1001], h1[1000][1000], h2[1000];\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) cin >> s[i];\n\tscanf(\"%d%d\", &R, &C);\n\tfor (int i = 0; i < R; i++) cin >> t[i];\n\tpower[0] = 1;\n\tfor (int i = 1; i <= 1000; i++) power[i] = power[i - 1] * 257;\n\tfor (int i = 0; i < H; i++) {\n\t\tunsigned long long val = 0;\n\t\tfor (int j = 0; j < C; j++) val = val * 257 + s[i][j]; h1[i][0] = val;\n\t\tfor (int j = C; j < W; j++) val = val * 257 + s[i][j] - power[C] * s[i][j - C], h1[i][j - C + 1] = val;\n\t}\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) h2[i] = h2[i] * 257 + t[i][j];\n\t}\n\tfor (int i = 0; i <= H - R; i++) {\n\t\tfor (int j = 0; j <= W - C; j++) {\n\t\t\tbool flag = true;\n\t\t\tfor (int k = i; k < i + R; k++) {\n\t\t\t\tif (h1[k][j] != h2[k - i]) {\n\t\t\t\t\tflag = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\t// for (long j = 0; j < W - C + 1; j++){\n\t\t\t// if (T[i][j] == P[0][0]){\n\t\t\t// \tif (T[i].substr(j, C) == P[0]){\n\t\t\tlong j = T[i].find(P[0], 0);\n\t\t\tif (j != -1){\n\t\t\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t// }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T;\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n\n    long long hash[100][100];\n    long long s;\n\n    char P[1000];\n    for(i = 0; i < R; i++){\n        s = 0;\n        scanf(\"%s\", P);\n        for(j = 0; j < C; j++){\n            s = (s * B + P[j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * A + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * B + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * A + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\tdelete [] T;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define B (1000000007ULL)\nusing namespace std;\ntypedef unsigned long long ull;\n\nint h, w, r, c;\nchar t[1000][1001], p[1000][1001];\null th[1000][1000], ph[1000];\nint st[1001];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>h>>w;\n    cin.ignore();\n    for(int i=0; i<h; i++) \n        cin.getline(t[i], 1001);\n    cin>>r>>c;\n    cin.ignore();\n    for(int i=0; i<r; i++) \n        cin.getline(p[i], 1001);\n\n    for(int i=0; i<r; i++){\n        for(int j=0; j<c; j++){\n            ph[i]=ph[i]*B+p[i][j];\n        }\n    }\n    ull bn=B;\n    for(int i=1; i<c; i++) bn*=B;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<c; j++) th[i][0]=th[i][0]*B+t[i][j];\n        for(int j=0; j<w-c; j++) th[i][j+1]=th[i][j]*B-t[i][j]*bn+t[i][j+c];\n    }\n    for(int y=0; y<=h-r; y++){\n        for(int x=0; x<=w-c; x++){\n            int i;\n            for(i=0; i<r&&th[y+i][x]==ph[i]; i++);\n            if(i==r) cout<<y<<' '<<x<<'\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\tif (t >= 5000 && k >= 40) {\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[100][100];\n\tlong long has_P[100][100];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"(%d, %d)\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD=1e9+7;\nconst long long BASE=0x234567;\n\nstruct RollingHash {\n    string s;\n    long long mod, base;\n    vector<long long> hash, pow;\n    RollingHash() {}\n    RollingHash(string s, long long m, long long b): s(s), mod(m), base(b) {\n        pow.resize(s.length()+1); pow[0]=1;\n        for (size_t i=0; i<s.length(); ++i)\n            (pow[i+1] = pow[i]*base) %= mod;\n\n        hash.assign(s.length()+1, 0);\n        for (size_t i=0; i<s.length(); ++i)\n            (hash[i+1] = hash[i]+pow[i]*s[i]) %= mod;\n    }\n    long long get_hash(size_t first, size_t last) const {\n        return (hash[last]-hash[first]+mod) % mod;\n    }\n    long long make_hash(string t) {\n        long long h=0;\n        for (size_t i=0; i<t.length(); ++i)\n            (h += pow[i]*t[i]) %= mod;\n\n        return h;\n    }\n    long long diff(long long h, size_t pos, size_t len) const {\n        return (h*pow[pos]-get_hash(pos, pos+len)+mod)%mod;\n    }\n    bool is_equiv(long long h, size_t pos, size_t len) const {\n        return !diff(h, pos, len);\n    }\n    template <class Functor>\n    void findall(const string &t, Functor F) {\n        long long h=make_hash(t);\n        for (size_t pos=0; pos+t.length()<=s.length(); ++pos)\n            if (is_equiv(h, pos, t.length()))\n                F(pos);\n    }\n};\n\nbool is_equiv(\n    const vector<RollingHash> &rhash, const vector<long long> &subhash,\n    size_t pos1, size_t pos2, size_t r, size_t c\n) {\n    for (size_t i=0; i<r; ++i)\n        if (!rhash[pos1+i].is_equiv(subhash[i], pos2, c))\n            return false;\n\n    return true;\n}\n\nint main() {\n    size_t H, W;\n    scanf(\"%zu %zu\", &H, &W);\n    vector<string> F(H);\n    for (size_t i=0; i<H; ++i) {\n        char buf[1<<10];\n        scanf(\"%s\", buf);\n        F[i] = buf;\n    }\n\n    size_t R, C;\n    scanf(\"%zu %zu\", &R, &C);\n    vector<string> G(R);\n    for (size_t i=0; i<R; ++i) {\n        char buf[1<<10];\n        scanf(\"%s\", buf);\n        G[i] = buf;\n    }\n\n    vector<RollingHash> rhash(H);\n    for (size_t i=0; i<H; ++i)\n        rhash[i] = RollingHash(F[i], MOD, BASE);\n\n    vector<long long> subhash(R);\n    for (size_t i=0; i<R; ++i)\n        subhash[i] = rhash[0].make_hash(G[i]);\n\n    for (size_t i=0; i+R<=H; ++i)\n        for (size_t j=0; j+C<=W; ++j)\n            if (is_equiv(rhash, subhash, i, j, R, C))\n                printf(\"%zu %zu\\n\", i, j);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nconst ull B1=1000000007,B2=9973;\n\nint h,w;\nchar field[1111][1111];\nint r,c;\nchar pat[1111][1111];\n\null allhash[1111][1111],rowhash[1111][1111],pathash;\null t1=1,t2=1;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>h>>w;\n\trep(i,h)cin>>field[i];\n\tcin>>r>>c;\n\trep(i,r)cin>>pat[i];\n\n\tif(h<r||w<c)return 0;\n\n\tpathash=0;\n\trep(i,r){\n\t\tull sum=0;\n\t\trep(j,c)sum=B1*sum+pat[i][j];\n\t\tpathash=B2*pathash+sum;\n\t}\n\n\trep(i,c)t1*=B1;\n\trep(i,r)t2*=B2;\n\n\trep(i,h){\n\t\trep(j,c)rowhash[i][0]=B1*rowhash[i][0]+field[i][j];\n\t\trepl(j,1,w-c+1){\n\t\t\trowhash[i][j]=rowhash[i][j-1]*B1-t1*field[i][j-1]+field[i][j+c-1];\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(i,r)allhash[0][j]=B2*allhash[0][j]+rowhash[i][j];\n\t\trepl(i,1,h-r+1){\n\t\t\tallhash[i][j]=allhash[i-1][j]*B2-t2*rowhash[i-1][j]+rowhash[i+r-1][j];\n\t\t}\n\t}\n\n\trep(i,h-r+1)rep(j,w-c+1){\n\t\tif(allhash[i][j]==pathash){\n\t\t\tprintf(\"%d %d\\n\", i,j);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(100000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef unsigned long long lli;\ntypedef unsigned long long ull;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nint h,w;\nvst m;\nint r,c;\nvst x;\nmat cmpm;\nlli hsh = 0;\nlli cmp = 0;\n\nconst lli b = 1000000007;\nconst lli d = 1000000009;\nlli bbr = 1,bbc = 1;\n\nvector<pll> ans;\n\nint main(){\n    cin >> h >> w;\n    m = vst(h);\n    for(lli i = 0;i < h;i++) cin >> m[i];\n    cin >> r >> c;\n    x = vst(r);\n    for(lli i = 0;i < r;i++) cin >> x[i];\n    for(lli i = 0;i < r;i++) bbr *= d;\n    for(lli i = 0;i < c;i++) bbc *= b;\n    for(lli i = 0;i < r;i++){\n        lli hs = 0;\n        for(lli j = 0;j < c;j++){\n            hs =\n            hs*b + \n            x[i][j];\n        }\n        hsh = hsh*d + hs;\n    }\n    cmpm = mat(h,vll(w));\n    for(int i = 0;i < h;i++){\n        for(int j = 0;j < w;j++){\n            cmpm[i][j] = \n            (j-1 >= 0 ? cmpm[i][j-1]*b : 0) + \n            m[i][j] - \n            (j-c >= 0 ? m[i][j-c]*bbc : 0);\n        }\n    }\n    for(int j = 0;j < w;j++){\n        cmp = 0;\n        for(int i = 0;i < h;i++){\n            cmp = \n            cmp*d + \n            cmpm[i][j] -\n            (i-r >= 0 ? cmpm[i-r][j]*bbr : 0);\n            if(cmp == hsh) ans.push_back(pll(i-r+1,j-c+1));\n        }\n    }\n    sort(ans.begin(),ans.end());\n    for(lli i = 0;i < ans.size();i++) cout << ans[i].first << \" \" << ans[i].second << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct Point{\n    int r;\n    int c;\n};\n\nvector<Point> V;\n\nchar BAN[1000][1001] = {};\nint H,W;\n\nvoid makeV(){\n    char CC[1000][1001] = {};\n    int T,R,C;\n    cin >> R >> C;\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\",CC[i]);\n    }\n    for (int i = 0; i < C; i++) {\n        if(CC[0][i] == '1'){\n            T = i;\n            break;\n        }\n    }\n    \n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (CC[i][j] == '1') {\n                Point p;\n                p.r = i - T;\n                p.c = j;\n                \n                V.push_back(p);\n            }\n        }\n    }\n}\n\nvoid rec(int i, int j){\n    int VS = V.size();\n    \n    for (int v = 1; v < VS; v++) {\n        if (BAN[i + V[v].r][j + V[v].c] == '0' || i + V[v].r > H || j + V[v].c > W) {\n            return;\n        }\n    }\n    printf(\"%d %d\\n\",i,j);\n}\n\nint main(){\n    cin >> H >> W;\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\",BAN[i]);\n    }\n    \n    makeV();\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (BAN[i][j] == '1') {\n                rec(i,j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<string> vstr;\n\n#define endl \"\\n\"\n\nll power_mod(ll x, ll y, ll m){\n  ll res = 1;\n  if(y>0){\n    res = power_mod(x,y/2,m);\n    if(y%2==0) res = (res*res)%m;\n    else res = (((res*res)%m)*x)%m;\n  }\n  return res;\n}\n\nll trans(char c){\n  return (ll)(c) + 1;\n}\n\n// r行c列の領域のハッシュ値を返す\nvvvll rolling_hash2D(vstr str, ll r, ll c){\n  ll h = str.size();\n  ll w = str[0].size();\n    if(h < r || w < c) return {}; // 空の配列を返す\n\n  vll mod = {1000000000 + 7, 1000000000 + 9, 1000000000 + 21};\n  vll base = {257, 521};\n\n  ll mods = mod.size();\n\n  vvvll res(h,vvll(w,vll(mods)));\n  vvvll tmp(h,vvll(w,vll(mods)));\n\n  for(ll m=0;m<mods;m++){\n    ll k0 = power_mod(base[0],c,mod[m]); //行\n    ll k1 = power_mod(base[1],r,mod[m]); //列\n\n    for(ll i=0;i<h;i++){\n      ll hog = 0;\n      for(ll j=0;j<c;j++) hog = ( hog * base[0] % mod[m] + trans(str[i][j]) ) % mod[m];\n\n      for(ll j=0;j+c<=w;j++){\n        tmp[i][j][m] = hog;\n        if(j+c < w) hog = ( hog * base[0] % mod[m] - k0 * trans(str[i][j]) + mod[m] * mod[m] + trans(str[i][j+c])) % mod[m];\n      }\n    }\n\n    for(ll j=0;j+c<=w;j++){\n      ll hog = 0;\n      for(ll i=0;i<r;i++) hog = ( hog * base[1] % mod[m] + tmp[i][j][m]) % mod[m];\n\n      for(ll i=0;i+r<=h;i++){\n        res[i][j][m] = hog;\n        if(i+r < h) hog = (hog * base[1] % mod[m] - k1 * tmp[i][j][m] + mod[m] * mod[m] + tmp[i+r][j][m]) % mod[m];\n      }\n    }\n\n  }\n  return res;\n}\n \nint main(){\n    ll h, w;\n    cin >> h >> w;\n    vstr s(h);\n    for(ll i=0;i<h;i++) cin >> s[i];\n    ll r, c;\n    cin >> r >> c;\n    vstr t(r);\n    for(ll i=0;i<r;i++) cin >> t[i];\n    vvvll hs = rolling_hash2D(s,r,c);\n    vvvll ht = rolling_hash2D(t,r,c);\n    \n    if(hs.size() == 0 || ht.size() == 0) return 0;\n    \n    for(ll i=0;i<h-r+1;i++){\n        for(ll j=0;j<w-c+1;j++){\n            if(hs[i][j] == ht[0][0]) cout << i << \" \" << j <<endl;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A=9999973,B=950527;\n \nint H,W;\nchar T[1005][1005];\null t[1005][1005];\null t2[1005][1005];\nint h,w;\nchar U[1005][1005];\n \n \nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n \n  ull target=0;\n  for(int i=0;i<h;i++){\n    ull key=0;\n    for(int j=0;j<w;j++){\n      key=key*B+U[i][j];\n    }\n    target=target*A+key;\n  }\n \n  ull C=1;\n  for(int i=0;i<w;i++)C*=B;\n \n  for(int i=0;i<H;i++){\n    ull key=0;\n    for(int j=0;j<W;j++){\n      key=key*B+T[i][j];\n      if(j-w>=0)key-=T[i][j-w]*C;\n      t[i][j]=key;\n      t2[i][j]=t[i][j];\n    }\n  }\n \n  C=1;\n  for(int i=0;i<h;i++)C*=A;\n \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(i)t[i][j]+=t[i-1][j]*A;\n      if(i-h>=0)t[i][j]-=t2[i-h][j]*C;\n      if(t[i][j]==target){\n        if(i-h+1>=0&&j-w+1>=0)\n          printf(\"%d %d\\n\",i-h+1,j-w+1);\n      }\n    }\n  }\n \n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\tif (k == R - 1) cout << i << \" \" << j << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 10000000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nlong long modpow[1001];\nint main() {\n\tmodpow[0] = 1;\n\tfor (int i = 1; i <= 1000; i++) {\n\t\tmodpow[i] = modpow[i - 1] * 256;\n\t\tmodpow[i] %= MOD;\n\t}\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tdp[i][j - M + 1] += MOD - modpow[M - 1];\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<functional>\nusing namespace std;\n\nstring a[1000], b[1000];\nint r, c;\n\nstring oneString(string *v, int i, int j){\n        string s;\n        for(int p=i;p<i+r;p++){\n                s += v[p].substr(j, c);\n        }\n        return s;\n}\n\nint main(){\n        int h,w;\n        cin>>h>>w;\n        for(int i=0;i<h;i++) cin>>a[i];\n        cin>>r>>c;\n        for(int i=0;i<r;i++) cin>>b[i];\n\n        hash<string> getHash;\n        auto target = getHash(oneString(b, 0, 0));\n\n        for(int i=0;i+r-1<h;i++){\n                for(int j=0;j+c-1<w;j++){\n                        auto tmp_hash = getHash(oneString(a, i, j));\n                        if(target == tmp_hash) cout<<i<<\" \"<<j<<endl;\n                }\n        }\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 72057594037927936LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 7) {\n\t\t\t\tlong long c1 = MOD - ((1LL << ((M - 1) * 8))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 1005\nusing namespace std;\n/*????¬??????????????????°???????????\\ O(H*W)*/\n/*T????????????U????????´????????´????????¢???*/\ntypedef unsigned long long ull;\nconst ull A=9999973,B=950527; //A:???????´???°, B:?¨?????´???°\n \nint H,W;\nchar T[MAX_N][MAX_N];\null t[MAX_N][MAX_N]; \null t2[MAX_N][MAX_N];\n\nint h,w;\nchar U[1005][1005];\n \nvoid rol_hash2(){\n\n  ull target=0;  //????????¨?????????????????\\\n  for(int i=0; i<h ;i++){\n    ull key=0;\n    for(int j=0; j<w ;j++)key= key * B + U[i][j];\n    target = target * A + key;\n  }\n \n  ull C=1;\n  for(int i=0; i<w ;i++)C*=B;\n   \n  //?¨?????????????????????\\????????????\n  for(int i=0; i<H ;i++){\n    ull key=0;\n    for(int j=0; j<W ;j++){\n      key = key * B + T[i][j];\n      if(j-w >= 0)key -= T[i][j-w] * C;\n      t[i][j] = key;\n      t2[i][j] = t[i][j];\n    }\n  }\n   \n  C=1;\n  for(int i=0; i<h ;i++)C*=A;\n  \n  //???????????????????????\\????????????\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++){\n      if( i ) t[i][j] += t[i-1][j] * A;\n      if(i-h >= 0) t[i][j] -= t2[i-h][j] * C;\n      if(t[i][j] == target)\n        if(i-h+1>=0&&j-w+1>=0)\n\t  printf(\"%d %d\\n\",i-h+1,j-w+1);//???????????§?¨??????????\n    }\n}\n \nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n  rol_hash2();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    int minn = 1001, mini;\n    for (int i = 0; i < r; i++) {\n        int count[62] = { 0 }, maxn = 0;\n        for (int j = 0; j < c; j++) {\n            if ('0' <= f2[i][j] && f2[i][j] <= '9') {\n                count[f2[i][j] - '0']++;\n            }\n            if ('A' <= f2[i][j] && f2[i][j] <= 'Z') {\n                count[f2[i][j] - 55]++;\n            }\n            if ('a' <= f2[i][j] && f2[i][j] <= 'z') {\n                count[f2[i][j] - 61]++;\n            }\n        }\n        for (int j = 0; j < 62; j++) {\n            maxn = max(maxn, count[j]);\n        }\n        if (minn > maxn) {\n            minn = maxn;\n            mini = i;\n        }\n    }\n    \n    for (int i = mini; i <= h - mini; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[mini]) {\n                bool success = true;\n                for (int k = mini - 1; k >= 0; k--) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n                for (int k = mini + 1; k < r; k++) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i - mini << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node{\n\tint data;\n\tNode* prev;\n\tNode* next;\n};\n\nclass List{\npublic:\n\tList(){\n\t\tmotherNode = new Node();\n\t\tmotherNode->data = -1;\n\t\tmotherNode->prev = motherNode;\t//?????°?§?????????????\n\t\tmotherNode->next = motherNode;\n\t};\n\n\t//??????????????????????????\\???????????±?????°??????????´¢???????????????\n\tvoid insertFromFirst(int x){\n\t\tNode* tmpNode = motherNode->next;\n\t\twhile(tmpNode != motherNode && tmpNode->data < x){\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\n\t\tif(tmpNode == motherNode){\t//??????????????\\????????´???\n\t\t\tNode* tmpNode = motherNode->next;\n\t\t\tmotherNode->next = new Node();\n\t\t\tmotherNode->next->data = x;\n\t\t\tmotherNode->next->prev = motherNode;\n\t\t\tmotherNode->next->next = tmpNode;\n\t\t\ttmpNode->prev = motherNode->next;\n\t\t}else{\n\t\t\twhile(tmpNode != motherNode && tmpNode->data < x){\n\t\t\t\ttmpNode = tmpNode->next;\n\t\t\t}\n\t\t\tNode* prevNode = tmpNode->prev;\n\t\t\ttmpNode->prev = new Node();\n\t\t\ttmpNode->prev->data = x;\n\t\t\ttmpNode->prev->next = tmpNode;\n\t\t\ttmpNode->prev->prev = prevNode;\n\t\t\tprevNode->next = tmpNode->prev;\n\t\t}\n\t};\n\tvoid insertFromLast(int x){\t//???????????§??°????????§????°??????????\n\t\tNode* tmpNode = motherNode->prev;\n\t\tif(tmpNode == motherNode){\t//???????????????????????????????????´???\n\t\t\tmotherNode->next = new Node();\n\t\t\tmotherNode->next->data = x;\n\t\t\tmotherNode->next->next = motherNode;\n\t\t\tmotherNode->next->prev = motherNode;\n\t\t\tmotherNode->prev = motherNode->next;\n\t\t}else{\t//??¢?????????????????????????????????????????¨????????´???\n\t\t\twhile(tmpNode != motherNode && tmpNode->data > x){\n\t\t\t\ttmpNode = tmpNode->prev;\n\t\t\t}\n\t\t\tNode* nextNode = tmpNode->next;\n\t\t\ttmpNode->next = new Node();\n\t\t\ttmpNode->next->data = x;\n\t\t\ttmpNode->next->next = nextNode;\n\t\t\ttmpNode->next->prev = tmpNode;\n\t\t\tnextNode->prev = tmpNode->next;\n\t\t}\n\t}\n\n\tvoid showList(){\n\t\tNode* tmpNode = motherNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tprintf(\"%d %d\\n\",tmpNode->data/1000,tmpNode->data%1000);\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t}\n\nprivate:\n\tNode* motherNode;\n};\n\nclass RangeTable{\n\npublic:\n\tRangeTable(int T_height,int T_width,int P_height,int P_width){\n\t\t//ranges = new Range[166500];\n\t\t//range_index = 0;\n\t\tthis->T_height = T_height;\n\t\tthis->T_width = T_width;\n\t\tthis->P_height = P_height;\n\t\tthis->P_width = P_width;\n\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\tcheck_table = new char*[T_height];\t//??????????????????????????????????????¨?????????????????§???????????????????????¨\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tcheck_table[i] = new char[T_width];\n\n\t\t\t//???????????´??????????????§???????????´????????????n???????????????\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(i <= row_limit && k <= col_limit){\n\t\t\t\t\tcheck_table[i][k] = 'o';\n\t\t\t\t}else{\n\t\t\t\t\tcheck_table[i][k] = 'x';\t//???????????´??????????????§???????????´?????????x???????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//????????????\n\tvoid registerRange(int left_up,int right_down){\n\t\tint row_start = left_up/1000;\t//??????????§???´???\n\t\tint row_end = right_down/1000;\t//????????????\n\t\tint col_start = left_up%1000;\t//??????????§?\n\t\tint col_end = right_down%1000;\t//????????????\n\t\t//?????????????????????????¨????<<??????????????£????????????>>??¬???????????????[??¬?????????????????¨??????]?????????????????????????´¢??????????????????????????????????????????????????????????????????????????¨???????????¨??????????????????????????????\n\t\t//??????????????????????????????????????????????????????????£?????????????????????´??????????????????????????????????¨??????°???????????¨????????????????????¬????????????????????????????????£?????????????????¨??????????????????????????????\n\t\t//???????????????????????¢??????????????§????????¬?????????????????§??????????????£????????????\n\t\tfor(int i = row_start; i < row_end; i++){\n\t\t\tfor(int k = col_start; k < col_end; k++){\n\t\t\t\tcheck_table[i][k] = 'r';\t//registerd\n\t\t\t}\n\t\t}\n\t}\n\n\tint nextSearchLoc(int row,int col){\n\t\t//????????¨??????????????????????????¨??????????????¬???????????????????????????????????????????????¬??????????§??????¨????????????????????????\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\n\t\tfor(int tmp_col = col;tmp_col <= col_limit; tmp_col++){\t//????????????????????§??¢???\n\t\t\tif(check_table[row][tmp_col] == 'o'){\n\t\t\t\treturn 1000*row + tmp_col;\n\t\t\t}\n\t\t}\n\t\tfor(int tmp_row = row+1; row <=row_limit; row++){\t//?¬?????????\\???\n\t\t\tfor(int tmp_col = 0; tmp_col <= col_limit; tmp_col++){\n\t\t\t\tif(check_table[tmp_row][tmp_col] == 'o'){\n\t\t\t\t\treturn 1000*tmp_row + tmp_col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\t//??¨?????????range????????£?????´???\n\t}\n\nprivate:\n\tchar** check_table;\n\t//Range* ranges;\n\tint T_height,T_width,P_height,P_width;\n};\n\n\nint main(){\n\n\tint T_height,T_width,P_height,P_width;\n\n\tscanf(\"%d %d\",&T_height,&T_width);\n\n\tchar T[T_height][T_width+1];\n\n\tfor(int i = 0; i < T_height; i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\n\tscanf(\"%d %d\",&P_height,&P_width);\n\n\tif(T_height < P_height || T_width < P_width) return 0;\t//T??????????????????????????????????°????????????°????´¢??????\n\n\tchar P[P_height][P_width+1];\n\n\tfor(int i = 0; i < P_height; i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\t//P????????????????¨??????????????????\\??????????????§?????????P???????????°?????°??????\n\tint P_total_char_count[128] = {0},P_each_char_count[P_height][128],P_first_appeard_loc[128];\n\tfor(int i = 0; i < 128; i++) P_first_appeard_loc[i] = -1;\n\n\tfor(int i = 0; i < P_height;i++){\n\t\tfor(int k = 0; k < 128; k++) P_each_char_count[i][k] = 0;\n\n\t}\n\n\tfor(int row = 0; row < P_height; row++){\n\t\tfor(int col = 0; col < P_width; col++){\n\t\t\tP_total_char_count[P[row][col]]++;\t//??¨??????????????°????¨????\n\t\t\tP_each_char_count[row][P[row][col]]++;\t//????????¨???????????°????¨????\n\t\t\tif(P_first_appeard_loc[P[row][col]] == -1){\n\t\t\t\tP_first_appeard_loc[P[row][col]] = 1000*row+col;\t//?????????????????´??????????¨????\n\t\t\t}\n\n\t\t}\n\t}\n\n\tint c_count = 0,c_min = 10001,c_max = -1,min_char,max_char,second_appeard_loc,appeard_min = 10001;\n\tbool multFLG = false;\n\tfor(int i = 48; i <= 122; i++){\n\t\tif(P_total_char_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min > P_total_char_count[i]){\n\t\t\t\tc_min = P_total_char_count[i];\t//????????????????°???????????????????????????°????¨????\n\t\t\t\tmin_char = i;\t//?????????????????°????°?????????????????¨????\n\t\t\t}\n\t\t\tif(c_max < P_total_char_count[i]){\n\t\t\t\tc_max = P_total_char_count[i];\t//?????????????????????????????????????????°????¨????\n\t\t\t\tmax_char = i;//?????????????????°???????????????????¨????\n\t\t\t}\n\t\t}\n\t\tif(P_first_appeard_loc[i] != 0 && P_first_appeard_loc[i] < appeard_min){\n\t\t\tappeard_min = P_first_appeard_loc[i];\t//2??????????????????????????´???????????????\n\t\t}\n\t}\n\tif(c_count == 2) multFLG = true;\n\n\n\tint second_appeard_row = appeard_min/1000,second_appeard_col = appeard_min%1000;\t//2??????????????????????????´??????????¨????\n\tif((multFLG == true) || (P_height*P_width != 1 && (P_height*P_width*100 > T_height*T_width))){\t//?????????????????????????¨????????????°????????????????????°1??§?????????????????¢????????§?????????????????´???\n\n\t\tchar start_char = P[0][0];\n\n\t\tif(c_max/(P_height*P_width-c_max) >= 1000){\t//?????????????????§???????????£???????????´???\n\n\t\t\tint min_appeard_row = P_first_appeard_loc[min_char]/1000,min_appeard_col = P_first_appeard_loc[min_char]%1000;\n\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char && T[row+min_appeard_row][col+min_appeard_col] == P[min_appeard_row][min_appeard_col]){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_width*second_appeard_row+second_appeard_col > 1000){ //?????????????????§???????????£????????????????????????????????´????????????1000???????¶?????????´???\n\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char && T[row+second_appeard_row][col+second_appeard_col] == P[second_appeard_row][second_appeard_col]){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t}else if(P_height == 1 && P_width == 1){ //1???????????´???\n\t\tchar ch = P[0][0];\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(T[i][k] == ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\t//???????¨???????????????°???????????´???\n\n\t\tchar ch = P[0][0];\t//??¢?????????\n\t\tint location;\n\n\t\tRangeTable rangeTable(T_height,T_width,P_height,P_width);\n\t\tList list;\n\n\t\tlocation = rangeTable.nextSearchLoc(0,0);\n\n\t\tint start_row,start_col,tmp_row,tmp_col,range_height,range_width,min_width = 0,min_height = 0;\n\t\tint calc_start_row,calc_start_col,calc_tmp_row,calc_tmp_col,calc_min_width = 0,calc_min_height = 0;\n\t\tif(P_height > P_width){\t//???????????´???\n\t\t\twhile(location != -1){\n\t\t\t\tstart_row = location/1000,start_col = location%1000;\n\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\tfor(tmp_row = start_row;tmp_row < T_height;tmp_row++){\n\t\t\t\t\tfor(tmp_col = start_col;tmp_col < T_width;tmp_col++){\n\t\t\t\t\t\tif(T[tmp_row][tmp_col] != ch){\n\t\t\t\t\t\t\tif((tmp_col-1) - start_col >= P_width){\t//????????????????????????????????????????????????<tmp_col-1>:?????´??????????????????\n\t\t\t\t\t\t\t\tmin_width = std::min(min_width,(tmp_col-1) - start_col);\t//????????????????????\\?????§???????????????range?????§???????°??????????<??¨???????????????????????????>????±???????\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp_col-1) - start_col < P_width) break;\t//???????´¢???????????§?????´????????¨???<(tmp_row-1)-start_row>????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t}\n\t\t\t\tif((tmp_row-1)-start_row >= P_height){\t//range????????????????????§???list????????? <<?????¶????????????????????????????????????????????\\?????§????????¨???????????¨>>\n\n\t\t\t\t\t//?????¨???????????????????????????????????????\n\t\t\t\t\trange_height = (tmp_row-1)-start_row;\t//range?????????\n\t\t\t\t\trange_width = min_width;\t//range??????\n\t\t\t\t\trangeTable.registerRange(location,1000*(start_row+range_height)+(start_col+range_width)); //??¬???????????????????????¬???????????????\n\n\t\t\t\t\tint calc_row_limit = start_row+range_height,calc_col_limit = start_col+range_width;\t//??¬??????????????????\n\t\t\t\t\tint secure_row_limit = calc_row_limit-P_height,secure_col_limit = calc_col_limit-P_width;\t//????????????????????????????????????????????\\???????¨??????????????????????????????¨???\n\t\t\t\t\tint danger_row_start = secure_row_limit+1,danger_col_start = secure_col_limit+1;\t//??¨??????????£???????????????????range???????????????????????§???????????¨???\n\t\t\t\t\tint danger_row_end = calc_row_limit-1,danger_col_end=calc_col_limit-1;\t//??±??????????????¨??????????????????????????????????????\\???range??¨??????????????????????????????????????§?????§????????????\n\n\t\t\t\t\tfor(int calc_row = start_row;calc_row <= calc_row_limit;calc_row++){\n\t\t\t\t\t\tfor(int calc_col = start_col;calc_col <= calc_col_limit;calc_col++){\n\t\t\t\t\t\t\tif(calc_row <= secure_row_limit && calc_col <= secure_col_limit){\t//?????¨???\n\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_row+calc_col);\n\t\t\t\t\t\t\t}else if(calc_row >= danger_row_start && calc_row <= danger_row_end && calc_col >= danger_col_start && calc_col <= danger_col_end){\t//??±?????????\n\t\t\t\t\t\t\t\t//?????????????§?????????????range??????????????????list?????????\n\t\t\t\t\t\t\t\tcalc_start_row = calc_row,calc_start_col = calc_col;\n\t\t\t\t\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\t\t\t\t\tfor(calc_tmp_row = calc_start_row;calc_tmp_row < T_height;calc_tmp_row++){\n\t\t\t\t\t\t\t\t\tfor(calc_tmp_col = calc_start_col;calc_tmp_col < T_width;calc_tmp_col++){\n\t\t\t\t\t\t\t\t\t\tif(T[calc_tmp_row][calc_tmp_col] != ch){\n\t\t\t\t\t\t\t\t\t\t\tif((calc_tmp_col-1) - calc_start_col >= P_width){\t//????????????????????????????????????????????????<tmp_col-1>:?????´??????????????????\n\t\t\t\t\t\t\t\t\t\t\t\tcalc_min_width = std::min(calc_min_width,(calc_tmp_col-1) - calc_start_col);\t//????????????????????\\?????§???????????????range?????§???????°??????????<??¨???????????????????????????>????±???????\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif((calc_tmp_col-1) -calc_start_col < P_width) break;\t//???????´¢???????????§?????´????????¨???????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((calc_tmp_row-1)-calc_start_row >= P_height){\t//??¨??????????£???????????????????range????????????????????§???list?????????\n\t\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_start_row+calc_start_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocation = rangeTable.nextSearchLoc(location/1000,location%1000);\t//?¬????range???????§?????????¨???????????????????§????\n\t\t\t}\n\t\t}else{\t//??£?????¢?????????????¨?????????´???\n\t\t\twhile(location != -1){\n\t\t\t\tstart_row = location/1000,start_col = location%1000;\n\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\tfor(tmp_col = start_col;tmp_col < T_width;tmp_col++){\n\t\t\t\t\tfor(tmp_row = start_row;tmp_row < T_height;tmp_row++){\n\t\t\t\t\t\tif(T[tmp_row][tmp_col] != ch){\n\t\t\t\t\t\t\tif((tmp_row-1) - start_row >= P_height){\t//???????????????????????????????????????????????????\n\t\t\t\t\t\t\t\tmin_height = std::min(min_height,(tmp_row-1) - start_row);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp_row-1) - start_row < P_height) break;\n\t\t\t\t}\n\t\t\t\tif((tmp_col-1)-start_col >= P_width){\t//range????????????\n\t\t\t\t\t//rangeTable.registerRange(1000*start_row+start_col,1000*last_row+(tmp_col-1));\n\t\t\t\t\t//?????¨???????????????????????????????????????\n\t\t\t\t\trange_width = (tmp_col-1)-start_col;\t//range??????\n\t\t\t\t\trange_height = min_height;\t//range??????\n\t\t\t\t\trangeTable.registerRange(location,1000*(start_row+range_height)+(start_col+range_width));\n\n\t\t\t\t\tint calc_row_limit = start_row+range_height,calc_col_limit = start_col+range_width;\t//??¬??????????????????\n\t\t\t\t\tint secure_row_limit = calc_row_limit-P_height,secure_col_limit = calc_col_limit-P_width;\t//????????????????????????????????????????????\\???????¨??????????????????????????????¨???\n\t\t\t\t\tint danger_row_start = secure_row_limit+1,danger_col_start = secure_col_limit+1;\t//??¨??????????£???????????????????range???????????????????????§???????????¨???\n\t\t\t\t\tint danger_row_end = calc_row_limit-1,danger_col_end=calc_col_limit-1;\t//??±??????????????¨??????????????????????????????????????\\???range??¨??????????????????????????????????????§?????§????????????\n\n\t\t\t\t\tfor(int calc_col = start_col;calc_col <= calc_col_limit;calc_col++){\n\t\t\t\t\t\tfor(int calc_row = start_row;calc_row <= calc_row_limit;calc_row++){\n\t\t\t\t\t\t\tif(calc_col <= secure_col_limit && calc_row <= secure_row_limit){\t//?????¨???\n\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_row+calc_col);\n\t\t\t\t\t\t\t}else if(calc_col >= danger_col_start && calc_col <= danger_col_end && calc_row >= danger_row_start && calc_row <= danger_row_end){\t//??±?????????\n\t\t\t\t\t\t\t\t//?????????????§?????????????range??????????????????list?????????\n\t\t\t\t\t\t\t\tcalc_start_col = calc_col,calc_start_row = calc_row;\n\t\t\t\t\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\t\t\t\t\tfor(calc_tmp_col = calc_start_col;calc_tmp_col < T_width;calc_tmp_col++){\n\t\t\t\t\t\t\t\t\tfor(calc_tmp_row = calc_start_row;calc_tmp_row < T_height;calc_tmp_row++){\n\t\t\t\t\t\t\t\t\t\tif(T[calc_tmp_row][calc_tmp_col] != ch){\n\t\t\t\t\t\t\t\t\t\t\tif((calc_tmp_row-1) - calc_start_row >= P_height){\n\t\t\t\t\t\t\t\t\t\t\t\tcalc_min_height = std::min(calc_min_height,(calc_tmp_row-1) - calc_start_row);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif((calc_tmp_row-1) -calc_start_row < P_height) break;\t//???????????§?????´????????¨???????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((calc_tmp_col-1)-calc_start_col >= P_width){\t//??¨??????????£???????????????????range????????????????????§???list?????????\n\t\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_start_row+calc_start_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocation = rangeTable.nextSearchLoc(location/1000,location%1000);\t//?¬????range???????§?????????¨???????????????????§????\n\t\t\t}\n\t\t}\n\n\t\tlist.showList();\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cassert>\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 2, root=0;\n\n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = ch - '0';\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = ch - '0';\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  //vector<vector<int> >td(til);\n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      //td[til-j-1].push_back(node);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 1007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i <= N ; i++){\n        for(int j = 0 ; j <= M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cassert>\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 2, root=0;\n\n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = ch - '0';\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = ch - '0';\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n\n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n\n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int h,w,r,c;\n\n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t\tif (t >= 50000 && k>=30) {\n\t\t\t\t\t\tgoto Exit2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    printf(\"%d %d\\n\",res[i].first,res[i].second);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\t// for (long j = 0; j < W - C + 1; j++){\n\t\t\t// if (T[i][j] == P[0][0]){\n\t\t\t// \tif (T[i].substr(j, C) == P[0]){\n\t\t\tlong j = T[i].find(P[0], 0);\n\t\t\tif (j != -1){\n\t\t\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].find(P[k], 0) == -1) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t// }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // 先頭文字を比較\n            if( ary_HW[hPos][wPos] == ary_RC[0][0] )\n            {\n                // 文字パターンの検索を実施する\n                patternMatching(hPos, wPos);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の箇所が見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define ZERO(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\ntemplate <class T, class S, class R>\nlong long pow(T n_0, S k_0, R mod_0) {\n    long long n = n_0;\n    long long k = k_0;\n    long long mod = mod_0;\n    long long now = 1;\n    while (true) {\n        if (k & 1) { now = now * n % mod; }\n        k >>= 1;\n        if (k == 0) { return now; }\n        n = (n * n) % mod;\n    }\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nstruct rolling_hash_2d {\n    using ul = unsigned long long;\n    int seq_h, seq_w, base;\n    int base2 = 10000357;  // 適当な素数\n    ul mod = (ul)(pow(2, 61)) - 1;\n    ul bit = (ul)(pow(2, 31));\n    ul base_i, base2_i = pow_r(base2, mod - 2);      // 逆元\n    vector<ul> pow_base_i = {1}, pow_base2_i = {1};  // 累乗の事前計算\n    map<char, ul> char_dict;  // 文字と数値の対応表\n    vector<string> seq;\n    string char_list;\n    // 先頭からi-1文字目までのハッシュ値\n    vector<vector<ul>> Hash;\n    rolling_hash_2d(vector<string> t1, string t2) {\n        seq = t1, char_list = t2;\n        // 文字列の長さ\n        seq_h = (int)seq.size(), seq_w = (int)seq[0].size();\n        base = (int)char_list.size() + 1;  // 文字の種類数\n        base_i = pow_r(base, mod - 2);\n        // char_dictの作成\n        for (int i = 0; i < base - 1; i++) {\n            char_dict[char_list[i]] = (ul)(i + 1);\n        }\n        // 累乗の事前計算\n        vector<ul> pow_base = {1}, pow_base2 = {1};\n        for (int i = 0; i < seq_w; i++) {\n            pow_base.push_back(mul(pow_base.back(), base));\n            pow_base_i.push_back(mul(pow_base_i.back(), base_i));\n        }\n        for (int i = 0; i < seq_h; i++) {\n            pow_base2.push_back(mul(pow_base2.back(), base2));\n            pow_base2_i.push_back(mul(pow_base2_i.back(), base2_i));\n        }\n        // ハッシュ値の計算\n        Hash.assign(seq_h + 1, vector<ul>(seq_w + 1, 0));\n        for (int i = 1; i < seq_h + 1; i++) {\n            for (int j = 0; j < seq_w; j++) {\n                Hash[i][j + 1] =\n                    (Hash[i][j] + mul(char_dict[seq[i - 1][j]], pow_base[j])) %\n                    mod;\n            }\n        }\n        for (int i = 0; i < seq_h; i++) {\n            for (int j = 1; j < seq_w + 1; j++) {\n                Hash[i + 1][j] =\n                    (Hash[i][j] + mul(Hash[i + 1][j], pow_base2[i])) % mod;\n            }\n        }\n    }\n    // 縦[a,b),横[c,d)のハッシュ値\n    long long calc_hash(int a, int b, int c, int d) {\n        return (long long)mul(\n            (Hash[a][c] + Hash[b][d] + (mod << 1) - Hash[a][d] - Hash[b][c]),\n            mul(pow_base2_i[a], pow_base_i[c]));\n    }\n    // 累乗の関数\n    ul pow_r(ul n, ul k) {\n        ul now = 1;\n        while (true) {\n            if (k & 1) { now = mul(now, n); }\n            k >>= 1;\n            if (k == 0) { return now; }\n            n = mul(n, n);\n        }\n    }\n    // 掛け算の関数\n    ul mul(ul a, ul b) {\n        ul au = a >> 31;\n        ul ad = a & (bit - 1);\n        ul bu = b >> 31;\n        ul bd = b & (bit - 1);\n        ul mid = (au * bd + ad * bu);\n        ul midu = mid >> 30;\n        ul midd = mid & ((bit >> 1) - 1);\n        return (au * bu * 2 + midu + (midd << 31) + ad * bd) % mod;\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int h, w, r, c;\n    INPUT(h, w);\n    vector<string> a(h);\n    INPUT(a, r, c);\n    vector<string> b(r);\n    INPUT(b);\n    string charlist =\n        \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    rolling_hash_2d rb(b, charlist);\n    ll hb = rb.calc_hash(0, r, 0, c);\n    rolling_hash_2d ra(a, charlist);\n    REP(i, h - r + 1) {\n        REP(j, w - c + 1) {\n            if (ra.calc_hash(i, i + r, j, j + c) == hb) { PRINT(i, j); }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\null mhash(vector<ull> v,ull k){\n  ull B=1000000007LL+k*2;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=(res*255+v[i])%B;\n  return res;\n}\null mhash2(vector<ull> v,ull k){\n  ull B=1000000007LL+k*2;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=res*B+v[i];\n  return res;\n}\nconst int CNT=7;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  RollingHash srh[CNT][h];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<h;i++){\n      srh[k][i].S=s[i];\n      srh[k][i].B=1000000007LL+(2*k);\n      srh[k][i].init();\n    }\n  }\n  int r,c;\n  cin>>r>>c;\n  string t[r];\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash trh[CNT][r];\n  vector<ull> v[CNT];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<r;i++){\n      trh[k][i].S=t[i];\n      trh[k][i].B=1000000007LL+(2*k);\n      trh[k][i].init();\n      v[k].push_back(trh[k][i].find(0,c));\n    }\n  }\n  ull base[CNT];\n  for(int k=0;k<CNT;k++) base[k]=mhash(v[k],k);\n  ull base2[CNT];\n  for(int k=0;k<CNT;k++) base2[k]=mhash2(v[k],k);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      bool flg=1;\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash(u,k)==base[k]);\n      }\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash2(u,k)==base2[k]);\n      }\n      if(flg) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 43;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(const vector<string> &T, const vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  ull hash_pmminus1, hash_pm;\n  if (m == 1) {\n    hash_pmminus1 = 1;\n    hash_pm = PRIME;\n  } else {\n    int lgpow = 1; // current log power, minus 1\n    hash_pmminus1 = PRIME;\n    for (; (1 << lgpow) <= m - 1;\n         ++lgpow) { // each loop, we WILL COMPUTE h(p^(2^pow))\n      hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n    }\n    for (int to_compute = (1 << (lgpow - 1)) + 1; to_compute <= m - 1;\n         ++to_compute) { // each loop, we WILL COMPUTE h(p^(to_compute))\n      hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n    }\n    hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n  }\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash = (segment_hash + MODULUS -\n                      ((hash_pmminus1 * ValueOf(T[i][j - 1])) % MODULUS)) %\n                     MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash = (text_hash + MODULUS -\n                   (((hash_ppowermtimes[n - 1]) * H[i - 1][j]) % MODULUS)) %\n                  MODULUS;                                 // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS;         // shift up\n      text_hash = (text_hash + H[i + n - 1][j]) % MODULUS; // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\nusing VULL = vector<ull>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\n/*\n#include <string>\n#include <unordered_set>\n#include <vector>\n#include <utility>\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\nusing ull = unsigned long long;\nusing VS = vector<string>;\nusing Pi_i = pair<int, int>;\n*/\n\n//一致する全ての部分の左端のインデックス\nclass RollingHush2DIndex{\n    VS field, purpose;\n    const ull B1 = 9973;\n    const ull B2 = 100000007;\npublic:\n    RollingHush2DIndex(){}\n    RollingHush2DIndex(VS T, VS P): field(T), purpose(P){}\nprivate:\n    ull sthash(VS s){\n        int R = purpose.size(), C = purpose[0].length();\n        vector<ull> tmp(R, 0ull);\n        //行方向\n        ull b1p = 1;\n        REP(i, R){\n            REP(j, C){\n                tmp[i] = tmp[i] * B1 + s[i][j];\n            }\n        }\n        ull b2p = 1;\n        ull hashed = 0;\n        REP(i, R){\n            b2p *= B2;\n            hashed = hashed * B2 + tmp[i];\n        }\n        return hashed;\n    }\npublic:\n    void setPurpose(VS s){\n        purpose = s;\n    }\n    void setField(VS s){\n        field = s;\n    }\n\n    vector<Pi_i> getCommonIdx(){\n        vector<Pi_i> ret;\n        int H = field.size(), W = field[0].length();\n        int R = purpose.size(), C = purpose[0].length();\n        if(H < R || W < C) return ret;\n        ull b1p = 1, b2p = 1;\n        REP(i, C) b1p *= B1;\n        REP(i, R) b2p *= B2;\n        ull fh = sthash(field), ph = sthash(purpose);\n        ull prvRowLeft = fh;\n        REPS(i, H-R){\n            if(i){\n                fh = prvRowLeft*B2;\n                ull p1 = 1;\n                RREP(j, C-1){\n                    fh += (-field[i-1][j] * b2p + field[i+R-1][j]) * p1;\n                    p1 *= B1;\n                }\n                prvRowLeft = fh;\n            }\n            REPS(j, W-C){\n                if(j){\n                    ull p2 = 1;\n                    fh *= B1;\n                    RREP(k, R-1){\n                        fh += (-field[i+k][j-1]*b1p + field[i+k][j+C-1]) * p2;\n                        p2 *= B2;\n                    }\n                }\n                //    cout << i << \" \" << j << \": \" << sh << \"\\n\";\n                if(fh == ph) ret.PB(MP(i, j));\n            }\n\n        }\n        return ret;\n    }\n};\n\n\nint main(){\n    int H, W, R, C;\n    cin >> H >> W;\n    VS field(H);\n    REP(i, H) cin >> field[i];\n    cin >> R >> C;\n    VS pattern(R);\n    REP(i, R) cin >> pattern[i];\n    RollingHush2DIndex RH(field, pattern);\n    vector<Pi_i> ans = RH.getCommonIdx();\n    REP(i, ans.size())\n        cout << ans[i].first << \" \" << ans[i].second << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\null mhash(vector<ull> v,ull k){\n  ull B=1000000007LL+k*4;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=(res*255+v[i])%B;\n  return res;\n}\null mhash2(vector<ull> v,ull k){\n  ull B=1000000007LL+k*4;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=res*B+v[i];\n  return res;\n}\nconst int CNT=2;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  RollingHash srh[CNT][h];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<h;i++){\n      srh[k][i].S=s[i];\n      srh[k][i].B=1000000007LL+(2*k);\n      srh[k][i].init();\n    }\n  }\n  int r,c;\n  cin>>r>>c;\n  string t[r];\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash trh[CNT][r];\n  vector<ull> v[CNT];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<r;i++){\n      trh[k][i].S=t[i];\n      trh[k][i].B=1000000007LL+(2*k);\n      trh[k][i].init();\n      v[k].push_back(trh[k][i].find(0,c));\n    }\n  }\n  ull base[CNT];\n  for(int k=0;k<CNT;k++) base[k]=mhash(v[k],k);\n  ull base2[CNT];\n  for(int k=0;k<CNT;k++) base2[k]=mhash2(v[k],k);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      bool flg=1;\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash(u,k)==base[k]);\n      }\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash2(u,k)==base2[k]);\n      }\n      if(flg) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 43;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(const vector<string> &T, const vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  ull hash_pmminus1, hash_pm;\n  if (m == 1) {\n    hash_pmminus1 = 1;\n    hash_pm = PRIME;\n  } else {\n    int current_power = 1;\n    hash_pmminus1 = PRIME;\n    for (; current_power < m - 1; current_power <<= 1)\n      hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n    for (; current_power < m - 1; ++current_power)\n      hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n    hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n  }\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash = (segment_hash + MODULUS -\n                      (hash_pmminus1 * ValueOf(T[i][j - 1]) % MODULUS)) %\n                     MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash = (text_hash + MODULUS -\n                   (((hash_ppowermtimes[n - 1]) * H[i - 1][j]) % MODULUS)) %\n                  MODULUS;                               // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS;       // shift up\n      text_hash = text_hash + H[i + n - 1][j] % MODULUS; // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            for (int k = 0; k < r; k++) {\n                if (f1[i + k].substr(j, c) != f2[k]) {\n                    break;\n                }\n                if (k == r - 1) {\n                    cout << i << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstring s[1005],t[1005];\nll pre[1005][1005];\nll pre2[1005][1005];\nll mp[1005];\nll mq[1005];\nint n1,m1,n2,m2;\nll p=131,q=233;\nll Q=1e9+7;\nvoid solve(){\n\tmp[0]=mq[0]=1;\n\tfor(int i=1;i<=1000;i++){\n\t\tmp[i]=mp[i-1]*p%Q;\n\t\tmq[i]=mq[i-1]*q%Q;\n\t}\n\tfor(int i=1;i<=n1;i++){\n\t\tfor(int j=1;j<=m1;j++){\n\t\t\tpre[i][j]=(-pre[i-1][j-1]*p*q+pre[i-1][j]*p+pre[i][j-1]*q+s[i-1][j-1])%Q;\n\t\t\tpre[i][j]=(pre[i][j]+Q)%Q;\n\t\t}\n\t}\n\tfor(int i=1;i<=n2;i++){\n\t\tfor(int j=1;j<=m2;j++){\n\t\t\tpre2[i][j]=(-pre2[i-1][j-1]*p*q+pre2[i-1][j]*p+pre2[i][j-1]*q+t[i-1][j-1])%Q;\n\t\t\tpre2[i][j]=(pre2[i][j]+Q)%Q;\n\t\t}\n\t}\n\tll hs=pre2[n2][m2];\n\tfor(int i=1;i<=n1-n2+1;i++){\n\t\tfor(int j=1;j<=m1-m2+1;j++){\n\t\t\tll v=(pre[i+n2-1][j+m2-1]+pre[i-1][j-1]*mp[n2]%Q*mq[m2]%Q-pre[i+n2-1][j-1]*mq[m2]%Q-pre[i-1][j+m2-1]*mp[n2]%Q)%Q;\n\t\t\tv=(v+Q)%Q;\n\t\t\tif(v==hs){\n\t\t\t\tcout<<i-1<<' '<<j-1<<\"\\n\";\n\t\t\t}\n\t\t}\n\t}\t\n}\nint main(){\n//\tfreopen(\"a.txt\",\"r\",stdin);\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tcin>>n1>>m1;\n\tfor(int i=0;i<n1;i++)cin>>s[i];\n\tcin>>n2>>m2;\n\tfor(int i=0;i<n2;i++)cin>>t[i];\n\tsolve();\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * c.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\n\ntypedef long long ll;\n\nconst ll BS0 = 2549;\nconst ll BS1 = 4283;\nconst ll MOD = 1000000007;\n\n/* typedef */\n\n/* global variables */\n\nstring s[MAX_N], p[MAX_N];\nll es0[MAX_N + 1], es1[MAX_N + 1];\nll shs[MAX_N + 1][MAX_N + 1], phs[MAX_N + 1][MAX_N + 1];\n\n/* subroutines */\n\nvoid makehash(int h, int w, ll hs[MAX_N + 1][MAX_N + 1], string s[]) {\n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      hs[y + 1][x + 1] =\n\t(es0[y] * es1[x] % MOD * s[y][x] % MOD +\n\t hs[y][x + 1] + hs[y + 1][x] - hs[y][x] + MOD) % MOD;\n}\n\n/* main */\n\nint main() {\n  es0[0] = es1[0] = 1;\n  for (int i = 1; i <= MAX_N; i++) {\n    es0[i] = (es0[i - 1] * BS0) % MOD;\n    es1[i] = (es1[i - 1] * BS1) % MOD;\n  }\n\n  int h, w;\n  cin >> h >> w;\n  for (int y = 0; y < h; y++) cin >> s[y];\n\n  int r, c;\n  cin >> r >> c;\n  for (int y = 0; y < r; y++) cin >> p[y];\n\n  makehash(h, w, shs, s);\n  makehash(r, c, phs, p);\n\n  for (int y = 0; y <= h - r; y++)\n    for (int x = 0; x <= w - c; x++) {\n      ll sh =\n\t(shs[y + r][x + c] + shs[y][x]\n\t - shs[y][x + c] + MOD - shs[y + r][x] + MOD) % MOD;\n      ll ph = phs[r][c] * es0[y] % MOD * es1[x] % MOD;\n      if (sh == ph) printf(\"%d %d\\n\", y, x);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 62;\n\nint encode(char c){\n\tif(isdigit(c)){\n\t\treturn  c - '0';\n\t}else if(islower(c)){\n\t\treturn 10 + c - 'a';\n\t}else if(isupper(c)){\n\t\treturn 10 + 26 + c - 'A';\n\t}\n\n\tassert(false && \"invalid string\");\n}\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = encode(str[str_index]);\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[encode(c)];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[encode(c)];\n\t\t}\n};\n\nclass KnuthMorrisPratt{\n\tpublic:\n\t\tvector<int> fail;\n\t\tstring t; // 探す文字列\n\t\tKnuthMorrisPratt(string& t) {\n\t\t\tthis->t = t;\n\t\t\tint m = t.size();\n\t\t\tfail = vector<int>(m + 1);\n\t\t\tint j = fail[0] = -1;\n\t\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\t\twhile (j >= 0 && t[j] != t[i - 1]) j = fail[j];\n\t\t\t\tfail[i] = ++j;\n\t\t\t}\n\t\t}\n\t\tvector<int> match(string& s){ // s に含まれる連続する部分文字列 t のインデックスを返す\n\t\t\tint n = s.size(), m = t.size();\n\t\t\tvector<int> res;\n\t\t\tfor (int i = 0, k = 0; i < n; ++i) {\n\t\t\t\twhile (k >= 0 && t[k] != s[i]) k = fail[k];\n\t\t\t\tif (++k >= m) {\n\t\t\t\t\tres.emplace_back(i - m + 1); // match at s[i-m+1 .. i]\n\t\t\t\t\tk = fail[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\n// tに一致するsの部分集合の左上の座標を返す\nvector<pair<int, int>> BakerBird(vector<string>& s, vector<string>& t){\n\tAhoCorasick aho;\n\tfor(auto str : t) aho.add(str);\n\taho.build();\n\n\tvector<vector<int>> status(s.size(), vector<int>(s[0].size()));\n\trep(i,s.size()){\n\t\tint now = 0;\n\t\trep(j,s[0].size()){\n\t\t\tnow = aho.next(now, s[i][j]);\n\t\t\tstatus[i][j] = now;\n\t\t}\n\t}\n\n\tstring patern;\n\trep(i,aho.ac.size()){\n\t\tpatern += aho.ac[i] + '0';\n\t}\n\n\tvector<pair<int, int>> res;\n\tKnuthMorrisPratt kmp(patern);\n\trange(i,t[0].size() - 1, s[0].size()){\n\t\tstring sstr; // statusを縦に見た文字列\n\t\trep(j,s.size()){\n\t\t\tsstr += status[j][i] + '0';\n\t\t}\n\t\tfor(auto y : kmp.match(sstr)){\n\t\t\tres.emplace_back(y, i - t[0].size() + 1);\n\t\t}\n\t}\n\tsort(all(res));\n\treturn res;\n}\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> s(h);\n\trep(i,h){\n\t\tcin >> s[i];\n\t}\n\n\n\tint c,r;\n\tcin >> r >> c;\n\tvector<string> t(r);\n\trep(i,r){\n\t\tcin >> t[i];\n\t}\n\n\tfor(auto p : BakerBird(s, t)){\n\t\tcout << p.first << ' ' << p.second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nconst int B1=123456789;\nconst int B2=999999937;\nconst int P=1000000007;\n\nvoid gen_hash(const vector<string> &m,int H,int W,int R,int C,vector<vector<long long> >&hash){\n\tvector<vector<long long> > hash1(H);\n\thash.resize(H);\n\n\tfor(int h=0;h<H;h++){\n\t\thash1[h].resize(W);\n\t\thash[h].resize(W);\n\n\t\tlong long c=0;\n\t\tlong long Brev=1;\n\t\tfor(int w=0;w<W;w++){\n\t\t\tc=(c*B1+m[h][w])%P;\n\t\t\tif(w<C)Brev=Brev*B1%P;else c=((c-m[h][w-C]*Brev)%P+P)%P;\n\t\t\thash1[h][w]=c;\n\t\t}\n\t}\n\tfor(int w=0;w<W;w++){\n\t\tlong long c=0;\n\t\tlong long Brev=1;\n\t\t\tfor(int h=0;h<H;h++){\n\t\t\tc=(c*B2+hash1[h][w])%P;\n\t\t\tif(h<R)Brev=Brev*B2%P;else c=((c-hash1[h-R][w]*Brev)%P+P)%P;\n\t\t\thash[h][w]=c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint H,W,R,C;\n\tcin>>H>>W;\n\tvector<string>field(H);\n\tfor(int i=0;i<H;i++)cin>>field[i];\n\tcin>>R>>C;\n\tvector<string>pattern(R);\n\tfor(int i=0;i<H;i++)cin>>pattern[i];\n\tvector<vector<long long> >hash_field,hash_pattern;\n\tgen_hash(field,H,W,R,C,hash_field);\n\tgen_hash(pattern,R,C,R,C,hash_pattern);\n\tfor(int h=R-1;h<H;h++)for(int w=C-1;w<W;w++){\n\t\tif(hash_field[h][w]==hash_pattern[R-1][C-1])printf(\"%d %d\\n\",h-R+1,w-C+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\n//list<int> T_index;\nchar P_index[UCHAR_MAX + 1][2] = {\"\\0\"};\n\nint Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn T[idxi + i][idxj + j];\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//make P_index\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tP_index[P[i][j]][0] = i;\n\t\t\tP_index[P[i][j]][1] = j;\n\t\t}\n\t}\n\n\t//search and output\n\tint i = 0;\n\tint j = 0;\n\twhile (i + R <= H) {\n\t\tint ret = Compare(i, j);\n\t\tif (ret == -1) {\n\t\t\tcout << i << \" \" << j << endl;\n\t\t\tj++;\n\t\t\tif (j + C > W) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (i + R - 1 - P_index[ret][0] > i) {\n\t\t\t\ti += R - 1 - P_index[ret][0];\n\t\t\t}\n\t\t\tif (j + C - 1 - P_index[ret][1] > j) {\n\t\t\t\tj += C - 1 - P_index[ret][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\twhile (j + C > W) {\n\t\t\t\ti++;\n\t\t\t\tj = j + C - W;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=t_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(T_w-1<center_col+(P_w-1)){\n\t\t\t\t\t\tdel_right=T_w-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_right=center_col+(P_w-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(T_h-1<center_row+(P_h-1)){\n\t\t\t\t\t\tdel_floor=T_h-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_floor=center_row+ (P_h-1);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(T[0][0]==P[0][0]){\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  //vector<vector<int> >td(til);\n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      //td[til-j-1].push_back(node);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  //vector<int>a(acc.size()+tl+2,-1);\n  int a[acc.size()+tl+2];\n  fill(a,a+acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t\tif (t >= 5000 && k>=20) {\n\t\t\t\t\t\tgoto Exit2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 950527\n#define base2 1777771\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair <int,int> P;\nll A[1001][1001];\nstring a[1001],b[1001];\n\nint main(){\n  int W,H,w,h;\n  cin>>H>>W;\n  for(int i=0;i<H;i++)cin>>a[i];\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>b[i];\n\n  ll target=0;\n  for(int i=0;i<h;i++){\n    ll key=0;\n    for(int j=0;j<w;j++){\n      key=key*base+b[i][j];\n    }\n    target=target*base2+key;\n  }\n  \n  for(int i=0;i<H;i++){\n    ll k=0,l=1;\n    for(int j=0;j<W;j++){\n      k=k*base+a[i][j];\n      if(j-w>=0) k-= l*a[i][j-w];\n      else l*=base;\n      A[i][j]=k;\n    }\n  }\n\n  vector <P> ans;\n  for(int j=w-1;j<W;j++){\n    ll k=0,l=1;\n    for(int i=0;i<H;i++){\n      k=k*base2+A[i][j];\n      if(i-h>=0) k-=l*A[i-h][j];\n      else l*=base2;\n      if(target==k) ans.push_back(P(i-h+1,j-w+1)); \n    }\n  }\n\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<(int)ans.size();i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T;\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n\n    long long hash[1000][1000];\n    long long s;\n\n    for(i = 0; i < R; i++){\n        s = 0;\n        char P[1000];\n        scanf(\"%s\", P);\n        for(j = 0; j < C; j++){\n            s = (s * A + P[j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * A + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\tdelete [] T; delete [] P;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009;\n\tstatic ll mul0,mul1,mul2,mul3; static vector<ll> pmo[4];\n\tstatic const ll add0=1000010007,add1=1003333331;\n\tvector<string> s; int rw,cl; vector<vector<ll> > hash_[2];\n\tvoid init(vector<string> s) {\n\t\tthis->s=s; rw=(int)s.size(); cl=(int)s[0].size();\n\t\thash_[0].resize(rw+1,vector<ll>(cl+1,0)),hash_[1].resize(rw+1,vector<ll>(cl+1,0));\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(!mul2) mul2=10039+(((ll)&mul2)>>5)%289,mul3=10037+(((ll)&mul3)>>5)%287;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1),pmo[2].pb(1),pmo[3].pb(1);\n\t\trep(i,rw)rep(j,cl) hash_[0][i+1][j+1]=(hash_[0][i+1][j]*mul0+add0+s[i][j])%mo0;\t//hash_[0][i][j]はインデックス0~i-1,0~j-1までの文字列のハッシュ値\n\t\trep(i,rw)rep(j,cl) hash_[1][i+1][j+1]=(hash_[1][i+1][j]*mul1+add1+s[i][j])%mo1;\n\t\trep(j,cl)rep(i,rw) hash_[0][i+1][j+1]=(hash_[0][i][j+1]*mul2+hash_[0][i+1][j+1])%mo0;\n\t\trep(j,cl)rep(i,rw) hash_[1][i+1][j+1]=(hash_[1][i][j+1]*mul3+hash_[1][i+1][j+1])%mo1;\n\t}\n\tll comp(int u,int l,int d,int r,int id,const ll mod){\n\t\treturn (hash_[id][d+1][r+1]+(mod-hash_[id][d+1][l]*pmo[id][r+1-l]%mod)\n\t\t\t\t\t+(mod-hash_[id][u][r+1]*pmo[id+2][d+1-u]%mod)+(hash_[id][u][l]*pmo[id][r+1-l]%mod*pmo[id+2][d+1-u]%mod))%mod;\n\t}\n\tpair<ll,ll> hash(int u,int l,int d,int r) {\t//文字列sのインデックスu~d,l~rまでの部分文字列のハッシュ値\n\t\tif(l>r||u>d) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\twhile((int)pmo[2].size()<d+2) pmo[2].pb(pmo[2].back()*mul2%mo0), pmo[3].pb(pmo[3].back()*mul3%mo1);\n\t\treturn make_pair(comp(u,l,d,r,0,mo0),comp(u,l,d,r,1,mo1));\n\t}\n\tpair<ll,ll> hash(vector<string> s) { init(s); return hash(0,0,(int)s.size()-1,(int)s[0].size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> rconcat(pair<ll,ll> L,pair<ll,ll> R,int len) {\t//Lの右にRを結合する(lenはRの横方向の長さ)\n\t\twhile((int)pmo[0].size()<len+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][len])%mo0,(R.second + L.second*pmo[1][len])%mo1);\n\t}\n\tstatic pair<ll,ll> cconcat(pair<ll,ll> L,pair<ll,ll> R,int len) {\t//Lの下にRを結合する(lenはRの縦方向の長さ)\n\t\twhile((int)pmo[2].size()<len+2) pmo[2].pb(pmo[2].back()*mul2%mo0), pmo[3].pb(pmo[3].back()*mul3%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[2][len])%mo0,(R.second + L.second*pmo[3][len])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[4]; ll RollingHash::mul0,RollingHash::mul1,RollingHash::mul2,RollingHash::mul3;\n\nvoid contain(RollingHash& arg1,vector<string>& arg2,vector<P>& ans)\n{\n\tint r = (int)arg2.size(),c = (int)arg2[0].size();\n\tif(arg1.rw < r || arg1.cl < c){\n\t\treturn;\n\t}\n\tRollingHash rh;\n\tpair<ll,ll> hs = rh.hash(arg2);\n\trep(i,arg1.rw-r+1){\n\t\trep(j,arg1.cl-c+1){\n\t\t\tif(arg1.hash(i,j,i+r-1,j+c-1) == hs){\n\t\t\t\tans.pb(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vs s(n);\n    rep(i,n){\n        cin >> s[i];\n    }\n    RollingHash rh;\n    rh.init(s);\n    cin >> n >> m;\n    vs t(n);\n    rep(i,n){\n        cin >> t[i];\n    }\n    vp ans;\n    contain(rh,t,ans);\n    rep(i,len(ans)){\n        cout << ans[i].fi << \" \" << ans[i].se << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define debug //*******************************************************************************************************************************************\n#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = 1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1001; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX][N_MAX];\nchar P[N_MAX][N_MAX];\nint H, W, R, C;\n\n\n\nint main() {\n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%d%d\", &H, &W);\n    rep(i,0,H) {\n        rep(j,0,W) {\n            scanf(\" %c\", &T[i][j]);\n        }\n    }\n    \n    scanf(\"%d%d\", &R, &C);\n    \n    rep(i,0,R) {\n        rep(j,0,C) {\n            scanf(\" %c\", &P[i][j]);\n        }\n    }\n    \n#ifdef debug\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << T[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n    din >> R >> C;\n    rep(i,0,R) {\n        rep(j,0,C) {\n            dout << P[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n#endif\n    \n    \n    \n    //calc.\n    bool found;\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            found = true;\n            rep(ii,0,R) {\n                rep(jj,0,C) {\n                    if(T[i+ii][j+jj]!=P[ii][jj]) {\n                        found = false;\n                        ii = R;\n                        jj = C;\n                    }\n                }\n            }\n            \n            if(found) {\n                printf(\"%d %d\\n\", i, j);\n            }\n            \n#ifdef debug\n            dout << \"--------------\\n\";\n            disp(i);\n            disp(j);\n            disp(found);\n#endif\n        }\n    }\n    \n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\n//list<int> T_index;\nchar P_index[UCHAR_MAX + 1][2] = {\"\\0\"};\n\nint Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn T[idxi + i][idxj + j];\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//make P_index\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tP_index[P[i][j]][0] = i;\n\t\t\tP_index[P[i][j]][1] = j;\n\t\t}\n\t}\n\n\t//search and output\n\tint i = 0;\n\tint j = 0;\n\twhile (i + R <= H) {\n\t\tint ret = Compare(i, j);\n\t\tif (ret == -1) {\n\t\t\tcout << i << \" \" << j << endl;\n\t\t\tj++;\n\t\t\tif (j + C > W) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (j + C - 1 - P_index[ret][1] > j) {\n\t\t\t\tj += C - 1 - P_index[ret][1];\n\t\t\t\twhile (j + C > W) {\n\t\t\t\t\tj = j + C - W;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\n#define C1  401\n#define C2  397\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nint h,w,r,c;\n\nvector<vector<ll> > genHash(const vector<string> v, int xs, int ys)\n{\n  vector<vector<ll> > h1(xs,vector<ll>(ys,0));\n  vector<vector<ll> > h2(xs,vector<ll>(ys,0));\n  ll cn1 = 1, cn2 = 1;\n  REP(i,c) cn1 = (cn1*C1)%MOD;\n  REP(i,r) cn2 = (cn2*C2)%MOD;\n  REP(i,xs)\n  {\n    ll h = 0;\n    REP(j,c) h=(h*C1+v[i][j])%MOD;\n    REP(j,ys-c+1)\n    {\n      h1[i][j] = h;\n      if(j+c<ys) h = (h*C1-v[i][j]*cn1+v[i][j+c])%MOD;\n      h = (h<0)?h+MOD:h;\n    }\n  }\n  REP(j,ys)\n  {\n    ll h = 0;\n    REP(i,r) h=(h*C2+h1[i][j])%MOD;\n    REP(i,xs-r+1)\n    {\n      h2[i][j] = h;\n      if(i+r<xs) h = (h*C2-h1[i][j]*cn2+h1[i+r][j])%MOD;\n      h = (h<0)?h+MOD:h;\n    }\n  }\n  return h2;\n}\n\nint main()\n{\n  cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  cin >> r >> c;\n  vector<string> b(r);\n  REP(i,r) cin >> b[i];\n  if(h<r||w<c) return 0;\n  auto f = genHash(a,h,w);\n  auto p = genHash(b,r,c);\n  REP(i,h-r+1) REP(j,w-c+1) if(f[i][j] == p[0][0])\n    printf(\"%d %d\\n\",i,j);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong Pow(long X,long R){\n\tlong Z = X;\n\tlong ans = 1;\n\twhile(R){\n\t\tif(R % 2){\n\t\t\tans *= Z;\n\t\t\tans %= mod;\n\t\t}\n\t\tZ = Z*Z%mod;\n\t\tR /= 2;\n\t}\n\treturn ans;\n}\nlong Rev(long X){\n\treturn Pow(X,mod-2);\n}\nstruct HashNumber{\n\tstatic const long X0 = 118306800;\n\tstatic const long X1 = 686550364;\n\tstatic const long X2 = 218792700;\n\tstatic const long X3 = 202607072;\n\tstatic const long reX0 = 346452252;\n\tstatic const long reX1 = 153603143;\n\tstatic const long reX2 = 60932367;\n\tstatic const long reX3 = 30668905;\n\tlong val0;\n\tlong val1;\n\tlong val2;\n\tlong val3;\n\tHashNumber(long v0,long v1,long v2,long v3){\n\t\tval0 = v0;\n\t\tval1 = v1;\n\t\tval2 = v2;\n\t\tval3 = v3;\n\t}\n\tHashNumber(long v){\n\t\tval0 = v;\n\t\tval1 = v;\n\t\tval2 = v;\n\t\tval3 = v;\n\t}\n\tHashNumber(){\n\t\tval0 = 0;\n\t\tval1 = 0;\n\t\tval2 = 0;\n\t\tval3 = 0;\n\t}\n\tstatic HashNumber make(long v0,long v1,long v2,long v3){\n\t\tHashNumber ans(v0,v1,v2,v3);\n\t\treturn ans;\n\t}\n\tHashNumber& operator=(const HashNumber &x){\n\t\tval0 = x.val0;\n\t\tval1 = x.val1;\n\t\tval2 = x.val2;\n\t\tval3 = x.val3;\n\t\treturn *this;\n\t}\n\tHashNumber operator+(const long &x){\n\t\treturn make((val0+x)%mod,(val1+x)%mod,(val2+x)%mod,(val3+x)%mod);\n\t}\n\tHashNumber operator-(const long &x){\n\t\treturn make((val0-x+mod)%mod,(val1-x+mod)%mod,(val2-x+mod)%mod,(val3-x+mod)%mod);\n\t}\n\tHashNumber operator+(const HashNumber &x){\n\t\treturn make((val0+x.val0)%mod,(val1+x.val1)%mod,(val2+x.val2)%mod,(val3+x.val3)%mod);\n\t}\n\tHashNumber operator-(const HashNumber &x){\n\t\treturn make((val0-x.val0+mod)%mod,(val1-x.val1+mod)%mod,(val2-x.val2+mod)%mod,(val3-x.val3+mod)%mod);\n\t}\n\tHashNumber operator<<(const long &x){\n\t\treturn make(val0*Pow(X0,x)%mod,val1*Pow(X1,x)%mod,val2*Pow(X2,x)%mod,val3*Pow(X3,x)%mod);\n\t}\n\tHashNumber operator>>(const long &x){\n\t\treturn make(val0*Pow(reX0,x)%mod,val1*Pow(reX1,x)%mod,val2*Pow(reX2,x)%mod,val3*Pow(reX3,x)%mod);\n\t}\n\tbool operator==(const HashNumber &x){\n\t\treturn val0==x.val0 && val1==x.val1 && val2==x.val2 && val3==x.val3;\n\t}\n\tbool operator!=(const HashNumber &x){\n\t\treturn val0!=x.val0 || val1!=x.val1 || val2!=x.val2 || val3!=x.val3;\n\t}\n\tbool operator<(const HashNumber &x){\n\t\tif(val0 != x.val0){\n\t\t\treturn val0 < x.val0;\n\t\t}\n\t\tif(val1 != x.val1){\n\t\t\treturn val1 < x.val1;\n\t\t}\n\t\tif(val2 != x.val2){\n\t\t\treturn val2 < x.val2;\n\t\t}\n\t\treturn val3 < x.val3;\n\t}\n\tbool operator>(const HashNumber &x){\n\t\tif(val0 != x.val0){\n\t\t\treturn val0 > x.val0;\n\t\t}\n\t\tif(val1 != x.val1){\n\t\t\treturn val1 > x.val1;\n\t\t}\n\t\tif(val2 != x.val2){\n\t\t\treturn val2 > x.val2;\n\t\t}\n\t\treturn val3 > x.val3;\n\t}\n\tbool operator<=(const HashNumber &x){\n\t\tif(val0 != x.val0){\n\t\t\treturn val0 < x.val0;\n\t\t}\n\t\tif(val1 != x.val1){\n\t\t\treturn val1 < x.val1;\n\t\t}\n\t\tif(val2 != x.val2){\n\t\t\treturn val2 < x.val2;\n\t\t}\n\t\treturn val3 <= x.val3;\n\t}\n\tbool operator>=(const HashNumber &x){\n\t\tif(val0 != x.val0){\n\t\t\treturn val0 > x.val0;\n\t\t}\n\t\tif(val1 != x.val1){\n\t\t\treturn val1 > x.val1;\n\t\t}\n\t\tif(val2 != x.val2){\n\t\t\treturn val2 > x.val2;\n\t\t}\n\t\treturn val3 >= x.val3;\n\t}\n\tHashNumber& operator+=(const long &x){\n\t\treturn *this = (*this+x);\n\t}\n\tHashNumber operator-=(const long &x){\n\t\treturn *this = (*this-x);\n\t}\n\tHashNumber& operator+=(const HashNumber &x){\n\t\treturn *this = (*this+x);\n\t}\n\tHashNumber operator-=(const HashNumber &x){\n\t\treturn *this = (*this-x);\n\t}\n\tHashNumber& operator<<=(const long &x){\n\t\treturn *this = (*this<<x);\n\t}\n\tHashNumber operator>>=(const long &x){\n\t\treturn *this = (*this>>x);\n\t}\n};\nint chartoint(char x){\n\tif('0' <= x && x <= '9'){\n\t\treturn x - '0';\n\t}\n\tif('a' <= x && x <= 'z'){\n\t\treturn x - 'a' + 10;\n\t}\n\treturn x - 'A' + 36;\n}\nHashNumber DP[1000][1000];\nvoid Calc(){\n\tint H = rei();\n\tint W = rei();\n\tfor(int i=0;i<H;i++){\n\t\tstring S = res();\n\t\tfor(int j=0;j<W;j++){\n\t\t\tHashNumber d;\n\t\t\td += chartoint(S[j]);\n\t\t\td <<= (1000*i+j);\n\t\t\tif(i != 0){\n\t\t\t\td += DP[i-1][j];\n\t\t\t}\n\t\t\tif(j != 0){\n\t\t\t\td += DP[i][j-1];\n\t\t\t}\n\t\t\tif(i != 0 && j != 0){\n\t\t\t\td -= DP[i-1][j-1];\n\t\t\t}\n\t\t\tDP[i][j] = d;\n\t\t}\n\t}\n\tHashNumber target;\n\tint h = rei();\n\tint w = rei();\n\tfor(int i=0;i<h;i++){\n\t\tstring S = res();\n\t\tfor(int j=0;j<w;j++){\n\t\t\tHashNumber d;\n\t\t\td += chartoint(S[j]);\n\t\t\td <<= (1000*i+j);\n\t\t\ttarget += d;\n\t\t}\n\t}\n\tfor(int i=h-1;i<H;i++){\n\t\tfor(int j=w-1;j<W;j++){\n\t\t\tHashNumber d = DP[i][j];\n\t\t\tif(i != h-1){\n\t\t\t\td -= DP[i-h][j];\n\t\t\t}\n\t\t\tif(j != w-1){\n\t\t\t\td -= DP[i][j-w];\n\t\t\t}\n\t\t\tif(i != h-1 && j != w-1){\n\t\t\t\td += DP[i-h][j-w];\n\t\t\t}\n\t\t\td >>= (1000*(i-h+1)+(j-w+1));\n\t\t\tif(target == d){\n\t\t\t\tcout << i-h+1 << \" \" << j-w+1 << endl;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\null mhash(vector<ull> v){\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=res*1000000007LL+v[i];\n  return res;\n}\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  RollingHash srh[h];\n  for(int i=0;i<h;i++){\n    srh[i].S=s[i];\n    srh[i].B=1000000007LL;\n    srh[i].init();\n  }\n  int r,c;\n  cin>>r>>c;\n  string t[r];\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash trh[r];\n  vector<ull> v;\n  for(int i=0;i<r;i++){\n    trh[i].S=t[i];\n    trh[i].B=1000000007LL;\n    trh[i].init();\n    v.push_back(trh[i].find(0,c));\n  }\n  ull base=mhash(v);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      vector<ull> u;\n      for(int k=0;k<r;k++)\n\tu.push_back(srh[i+k].find(j,j+c));\n      if(mhash(u)==base) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tint h, w, r, c;\n\tstring s[1000], t[1000];\n\n\tcin >> h >> w;\n\n\tfor (int i = 0; i < h; i++)\n\t\tcin >> s[i];\n\n\tcin >> r >> c;\n\n\tfor (int i = 0; i < r; i++)\n\t\tcin >> t[i];\n\n\tfor (int i = 0; i < h - r + 1; i++) {\n\t\tfor (int j = 0; j < w - c + 1; j++) {\n\t\t\tif (s[i][j] == t[0][0]) {\n\t\t\t\tbool f = 1;\n\t\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\t\tfor(int u = 0; u < c; u++)\n\t\t\t\t\t\tif (s[i + k][j + u] != t[k][u]) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (f == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (f == 1)\n\t\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntemplate<class T, int base>\nclass RollingHash{\n    vector<long long> hash, power;\n    static const int mod = 1000000007;\npublic:\n    RollingHash(const T& s){\n        init(s);\n    }\n    \n    void init(const T& s){\n        int n = s.size();\n        hash.assign(n+1, 0);\n        power.assign(n+1, 1);\n        for(int i = 0; i < n; ++i){\n            hash[i+1] = (hash[i] * base + s[i]) % mod;\n            power[i+1] = power[i] * base % mod;\n        }\n    }\n    \n    //S[l, r)\n    long long find(const int l, const int r){\n        long long res = hash[r] + mod - hash[l] * power[r-l] % mod;\n        if(res >= mod){\n            res -= mod;\n        }\n        return res;\n    }\n};\n\ntemplate<class T>\nvector<vector<long long>> rectangle_hash(const vector<T>& field, const int r, const int c){\n    static const long long base1 = 1007, base2 = 2009;\n    vector<RollingHash<T, base1>> rh;\n    for(auto s : field){\n        rh.emplace_back(s);\n    }\n    int h = field.size();\n    int w = field[0].size();\n\n    vector<vector<long long>> res(h-r+1, vector<long long>(w-c+1));\n\n    for(int j = 0; j+c <= w; ++j){\n        vector<long long> tmp(h);\n        for(int i = 0; i < h; ++i){\n            tmp[i] = rh[i].find(j, j+c);\n        }\n\n        RollingHash<vector<long long>, base2> second_step(tmp);\n        for(int i = 0; i+r <= h; ++i){\n            res[i][j] = second_step.find(i, i+r);\n        }\n    }\n    return res;\n}\n\nint main(){\n\n    int h, w;\n    cin >> h >> w;\n    vector<string> field(h);\n    for(int i = 0; i < h; ++i){\n        cin >> field[i];\n    }\n    int r, c;\n    cin >> r >> c;\n    vector<string> pattern(r);\n    for(int i = 0; i < r; ++i){\n        cin >> pattern[i];\n    }\n\n    auto feild_hash = rectangle_hash<string>(field, r, c);\n    auto pattern_hash = rectangle_hash<string>(pattern, r, c);\n\n    for(int i = 0; i+r <= h; ++i){\n        for(int j = 0; j+c <= w; ++j){\n            if(feild_hash[i][j] == pattern_hash[0][0]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            if( ary_HW[i][j] == ary_RC[0][0] )\n            {\n                // 先頭文字を比較\n                patternMatching(i, j);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    hEnd = hPos + ( R - 1 );\n    wEnd = wPos + ( C - 1 );\n\n    if( hEnd > H - 1 || wEnd > W - 1 )\n    {\n        // 配列の範囲をオーバーしているので, 検索不要\n        return;\n    }\n\n    if( ary_HW[hPos][wEnd] == ary_RC[0][C - 1] )\n    {\n        int rPos = 0;\n\n        startPoint.x = hPos;\n        startPoint.y = wPos;\n\n        for(int colNum = hPos; colNum < hPos + R; colNum++)\n        {\n            matchFlag = false;\n\n            // 最終文字を比較\n            if( ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n            {\n                p_search(colNum, wPos, rPos, 0, C - 1);\n            }\n\n            if( matchFlag == false )\n            {\n                break;\n            }\n\n            rPos++;\n        }\n\n        if( matchFlag == true )\n        {\n            // 文字列のパターンが一致する箇所が見つかった\n            Qst.push(startPoint);\n        }\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A=9999973,B=950527;\n \nint H,W;\nchar T[1005][1005];\null t[1005][1005];\null t2[1005][1005];\nint h,w;\nchar U[1005][1005];\n \n \nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n   \n  ull target=0;  \n  for(int i=0;i<h;i++){\n    ull key=0;\n    for(int j=0;j<w;j++){\n      key=key*B+U[i][j];\n    }\n    target=target*A+key;\n  }\n \n  ull C=1;\n  for(int i=0;i<w;i++)C*=B;\n   \n  for(int i=0;i<H;i++){\n    ull key=0;\n    for(int j=0;j<W;j++){\n      key=key*B+T[i][j];\n      if(j-w>=0)key-=T[i][j-w]*C;\n      t[i][j]=key;\n      t2[i][j]=t[i][j];\n    }\n  }\n   \n  C=1;\n  for(int i=0;i<h;i++)C*=A;\n   \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(i)t[i][j]+=t[i-1][j]*A;\n      if(i-h>=0)t[i][j]-=t2[i-h][j]*C;\n      if(t[i][j]==target){\n        if(i-h+1>=0&&j-w+1>=0)\n          printf(\"%d %d\\n\",i-h+1,j-w+1);\n      }\n    }\n  }\n \n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  //for(int i=0;i<h;i++)cin >> s[i];\n  char ch;\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&ch);\n      s[i][j]=ch;\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  //for(int i=0;i<r;i++)cin >> t[i];\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&ch);\n      t[i][j]=ch;\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 9803\n#define B 9901\n#define M 10091\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tint has_T[1000][1000];\n\tint has_P[1000][1000];\n\tint s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + has_P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tint last_has = has_P[R - 1][C - 1];\n\tint power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tint block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"%d %d\\n\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\n#define C1  401\n#define C2  397\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nint h,w,r,c;\n\nvector<vector<ll> > genHash(const vector<string> v, int xs, int ys)\n{\n  vector<vector<ll> > h1(xs,vector<ll>(ys,0));\n  vector<vector<ll> > h2(xs,vector<ll>(ys,0));\n  ll cn1 = 1, cn2 = 1;\n  REP(i,c) cn1 = (cn1*C1)%MOD;\n  REP(i,r) cn2 = (cn2*C2)%MOD;\n  REP(i,xs)\n  {\n    ll h = 0;\n    REP(j,c) h=(h*C1+v[i][j])%MOD;\n    REP(j,ys-c+1)\n    {\n      h1[i][j] = h;\n      if(j+c<ys) h = (h*C1-v[i][j]*cn1+v[i][j+c])%MOD;\n      h = (h<0)?h+MOD:h;\n    }\n  }\n  REP(j,ys)\n  {\n    ll h = 0;\n    REP(i,r) h=(h*C2+h1[i][j])%MOD;\n    REP(i,xs-r+1)\n    {\n      h2[i][j] = h;\n      if(i+r<xs) h = (h*C2-h1[i][j]*cn2+h1[i+r][j])%MOD;\n      h = (h<0)?h+MOD:h;\n    }\n  }\n  return h2;\n}\n\nint main()\n{\n  cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  cin >> r >> c;\n  vector<string> b(r);\n  REP(i,r) cin >> b[i];\n  auto f = genHash(a,h,w);\n  auto p = genHash(b,r,c);\n  REP(i,h-r+1) REP(j,w-c+1) if(f[i][j] == p[0][0])\n    printf(\"%d %d\\n\",i,j);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\t// for (long j = 0; j < W - C + 1; j++){\n\t\t\t// if (T[i][j] == P[0][0]){\n\t\t\t// \tif (T[i].substr(j, C) == P[0]){\n\t\t\tlong l = T[i].find(P[0], 0);\n\t\t\tif (l != -1){\n\t\t\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t// }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_T 10\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 1000007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i <= N ; i++){\n        for(int j = 0 ; j <= M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \ntemplate<typename T=int>inline T readT() {\n  char c = getchar_unlocked(); bool neg = (c=='-');\n  T res = neg?0:c-'0';\n  while(isdigit(c=getchar_unlocked())) res = res*10 + c-'0';\n  return neg?-res:res;\n}\ntemplate<typename T=int>inline void writeT(T x, char c='\\n'){\n  int d[20],i=0; if(x<0)putchar_unlocked('-'),x*=-1;\n  do{d[i++]=x%10;}while(x/=10); while(i--)putchar_unlocked('0'+d[i]);\n  putchar_unlocked(c);\n}\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\nusing ld= long double;\n\nULL p1, p2, h1[1010][1010], h2[1010][1010];\nULL h3[1010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(5);\n    \n    int H, W; cin >> H >> W;\n    vector<string> T(H);\n    for(int i=0; i<H; i++)cin >> T[i];\n\n    int R,C; cin >> R >> C;\n    vector<string> P(R);\n\n    for(int i=0; i<R; i++)cin >> P[i];\n\n    p1 = 1, p2 = 1;\n    for(int i=0; i<R; i++) p2 *= 1000000007;\n    for(int i=0; i<C; i++) p1 *= 9973;\n\n    for(int i=0; i<H; i++){\n        ULL w = 0;\n        //[0~C)\n        for(int j=0; j<C; j++) h1[i][0] = (w = w * 9973 + T[i][j]);\n        //[C~W)\n        for(int j=C; j<W; j++) h1[i][j-C+1] = (w = T[i][j] + w * 9973 - p1 * T[i][j-C]);\n        \n    }\n\n    for(int i=0; i<W-C+1; i++){\n        ULL w = 0;\n        for(int j=0; j<R; j++) h2[0][i] = (w = w * 1000000007 + h1[j][i]);\n        \n        for(int j=R; j<H; j++) h2[j-R+1][i] = (w = w * 1000000007 + h1[j][i] - p2 * h1[j-R][i]);\n    }\n\n    for(int i=0; i<R; i++){\n        for(int j=0; j<C; j++) h3[i] = h3[i] * 9973 + P[i][j];\n    }\n\n    ULL h4 = 0;\n    for(int i=0; i<R; i++) h4 = h4 * 1000000007 + h3[i];\n\n    for(int i=0; i<H-R+1; i++){\n        for(int j=0; j<W-C+1; j++){\n            if(h2[i][j] == h4) cout << i << \" \" << j << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\ntypedef unsigned long long ull;\n\nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n\nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 100007;\n   \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n   \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n   \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n   \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n     \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i <= N ; i++){\n        for(int j = 0 ; j <= M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    if(N < P && M < Q) return 0;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(10000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint H, W, R, C; char s[1001][1007], t[1001][1007];\nunsigned long long pw1, pw2, h1[1001][1007], h2[1001][1007], h3[1001];\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor(int i = 0; i < H; i++) scanf(\"%s\", s[i]);\n\tscanf(\"%d%d\", &R, &C); pw1 = 1, pw2 = 1;\n\tfor(int i = 0; i < R; i++) scanf(\"%s\", t[i]), pw2 *= 1000000007;\n\tfor(int i = 0; i < C; i++) pw1 *= 257;\n\tfor(int i = 0; i < H; i++) {\n\t\tunsigned long long w = 0;\n\t\tfor(int j = 0; j < C; j++) w = w * 257 + s[i][j]; h1[i][0] = w;\n\t\tfor(int j = C; j < W; j++) w = w * 257 + s[i][j] - pw1 * s[i][j - C], h1[i][j - C + 1] = w;\n\t}\n\tfor(int i = 0; i <= W - C; i++) {\n\t\tunsigned long long w = 0;\n\t\tfor(int j = 0; j < R; j++) w = w * 1000000007 + h1[j][i]; h2[0][i] = w;\n\t\tfor(int j = R; j < H; j++) w = w * 1000000007 + h1[j][i] - pw2 * h1[j - R][i], h2[j - R + 1][i] = w;\n\t}\n\tfor(int i = 0; i < R; i++) {\n\t\tfor(int j = 0; j < C; j++) h3[i] = h3[i] * 257 + t[i][j];\n\t}\n\tunsigned long long h4 = 0;\n\tfor(int i = 0; i < R; i++) h4 = h4 * 1000000007 + h3[i];\n\tfor(int i = 0; i <= H - R; i++) { \n\t\tfor(int j = 0; j <= W - C; j++) {\n\t\t\tif(h2[i][j] == h4) printf(\"%d %d\\n\", i, j);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] != -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ??????????????????????????????????????????????????????????????¶??????acc?????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n    nodes[N].parent = cur;\n    nodes[N].ch = ch;\n    nodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n    \n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n      \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n      \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <String.h>\n#include <math.h>\n#include <limits.h>\n\n\n/*\n * ?????????????´¢????????????rolling-hash???\n * String????????????????????¨??????Pattern????????????????????????\n * ??????????±???????????????°???????????°????????????????????£??¬??????????????????\n *\n */\n\nchar String[1001][1001];\nchar Pattern[1001][1001];\n\n\n\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n#define P (1000000007)\n\null power[1000001];\n\n/*\n * String:????´¢????±??????????\n * s_num:????´¢????±???????????????????\n * Pattern:????´¢??????????????????\n * p_num:????´¢???????????????????????????\n */\nvoid rolling_hash(int h, int w, int r, int c)\n{\n    int i, j, k , l;\n    ull target_hash = 0, Pattern_hash = 0;\n    \n    \n    /*\n     * target hash??????????¨?????????¨?????????????????????????±?????????????\n     */\n    power[0] = 1;\n    for (i=0; i <r*c; i++) {\n            power[i+1]= power[i]* P;\n    }\n    \n    /*\n     * Pattern??????????????\\???????±???????\n     */\n    for (i=0; i < r; i++) {\n        for (j=0; j < c; j++) {\n            Pattern_hash += Pattern[i][j] * power[i*c + j];\n        }\n    }\n    \n    \n    for (i = 0; i + r <= h; i++) {\n        \n        /*\n         * String???????????\\???????±???????\n         */\n        target_hash = 0;\n        for (k=i; k < r; k++) {\n            for (l=0; l < c; l++) {\n                target_hash += String[k][l] * power[c *(k-i)  + l] ;\n            }\n        }\n        \n        for (j=0; j+c <= w; j++) {\n            /*\n             * hash???????????´????????°?????????????????¨????????????\n             */\n            if (target_hash == Pattern_hash) {\n                printf(\"%d %d\\n\", i, j);\n            }\n            \n            \n            /*\n             * target???????????????????????????????????????????????????????????????????????\\??????????¨??????????\n             */\n            if (j+c != w) {\n                target_hash = 0;\n                for (k=0; k < r; k++) {\n                    for (l=0; l < c; l++) {\n                        target_hash += String[i+k][l+j+1] * power[k*c + l] ;\n                    }\n                }\n            }\n\n        }\n    }\n    \n    return;\n}\n\n\nint main( ){\n    \n    int i, j, H, W, R,C;\n    scanf(\"%d\", &H);\n    scanf(\"%d\", &W);\n    getchar();\n    for (i = 0; i < H ; i++) {\n        for (j = 0; j < W; j++) {\n            scanf(\"%c\", &String[i][j]);\n        }\n        getchar();\n    }\n    \n    scanf(\"%d\", &R);\n    scanf(\"%d\", &C);\n    getchar();\n    for (i = 0; i < R ; i++) {\n        for (j = 0; j < C; j++) {\n            scanf(\"%c\", &Pattern[i][j]);\n        }\n        getchar();\n    }\n    \n    rolling_hash(H, W, R, C);\n   \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef unsigned long long lli;\ntypedef unsigned long long ull;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nint h,w;\nvst m;\nint r,c;\nvst x;\nmat cmpm;\nlli hsh = 0;\nlli cmp = 0;\n\nconst lli b = 1000000007;\nlli bbr = 1,bbc = 1;\n\nvector<pll> ans;\n\nint main(){\n    cin >> h >> w;\n    m = vst(h);\n    for(lli i = 0;i < h;i++) cin >> m[i];\n    cin >> r >> c;\n    x = vst(r);\n    for(lli i = 0;i < r;i++) cin >> x[i];\n    for(lli i = 0;i < r;i++) bbr *= b;\n    for(lli i = 0;i < c;i++) bbc *= b;\n    for(lli i = 0;i < r;i++){\n        lli hs = 0;\n        for(lli j = 0;j < c;j++){\n            hs =\n            hs*b + \n            x[i][j];\n        }\n        hsh = hsh*b + hs;\n    }\n    cmpm = mat(h,vll(w));\n    for(int i = 0;i < h;i++){\n        for(int j = 0;j < w;j++){\n            cmpm[i][j] = \n            (j-1 >= 0 ? cmpm[i][j-1]*b : 0) + \n            m[i][j] - \n            (j-c >= 0 ? m[i][j-c]*bbc : 0);\n        }\n    }\n    for(int j = 0;j < w;j++){\n        cmp = 0;\n        for(int i = 0;i < h;i++){\n            cmp = \n            cmp*b + \n            cmpm[i][j] -\n            (i-r >= 0 ? cmpm[i-r][j]*bbr : 0);\n            if(cmp == hsh) ans.push_back(pll(i-r+1,j-1));\n        }\n    }\n    sort(ans.begin(),ans.end());\n    for(lli i = 0;i < ans.size();i++) cout << ans[i].first << \" \" << ans[i].second << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\nusing ll=long long;\n\nconst int MAX = 500000, MS = 2;\nconst ll mod[]={999999937LL, 1000000007LL}, base = 9973;\nclass RollingHash{\n  public:\n    int n;\n    vector<ll> hs[MS], pw[MS];\n    RollingHash(){}\n    RollingHash(const string &s){\n      n = s.size();\n      rep(i,MS){\n        hs[i].assign(n+1, 0);\n        pw[i].assign(n+1, 0);\n        hs[i][0] = 0;\n        pw[i][0] = 1;\n        rep(j, n){\n          pw[i][j+1] = pw[i][j]*base %mod[i];\n          hs[i][j+1] = (hs[i][j]*base+s[j])%mod[i];\n        }\n      }\n    }\n    ll hash(int l, int r, int i){\n      if(r > n)return -1;\n      return ((hs[i][r]-hs[i][l]*pw[i][r-l])%mod[i]+mod[i])%mod[i];\n    }\n    bool match(int l1, int r1, int l2, int r2){\n      bool ret = 1;\n      rep(i,MS){\n        ret &= hash(l1, r1, i) == hash(l2, r2, i);\n      }\n      return ret;\n    }\n\n    bool match(int l, int r, ll h[]){\n      bool ret = 1;\n      rep(i,MS) ret&=hash(l,r,i)==h[i];\n      return ret;\n    }\n};\n\nint main(void){\n  string t[1024], tt[1024];\n  string p[1024], pt[1024];\n  RollingHash rht[1024][2];\n  RollingHash rhp[1024][2];\n  int h[2], w[2];\n\n  cin >> h[0] >> w[0];\n  rep(i,h[0]) cin >> t[i];\n  rep(i,w[0]) rep(j,h[0]) tt[i]+=t[j][i];\n\n  cin >> h[1] >> w[1];\n  rep(i,h[1]) cin >> p[i];\n  rep(i,w[1]) rep(j,h[1]) pt[i]+=p[j][i];\n\n\n  rep(i,h[0]) rht[i][0] = RollingHash(t[i]);\n  rep(i,w[0]) rht[i][1] = RollingHash(tt[i]);\n  rep(i,h[1]) rhp[i][0] = RollingHash(p[i]);\n  rep(i,w[1]) rhp[i][1] = RollingHash(pt[i]);\n  \n  \n  ll ps[1024][2][MS];\n  rep(j, MS){\n    rep(i, h[1]){\n      ps[i][0][j] = rhp[i][0].hash(0, w[1], j);\n    }\n    rep(i, w[1]){\n      ps[i][1][j] = rhp[i][1].hash(0, h[1], j);\n    }\n  }\n\n  rep(i, h[0]){\n    rep(j, w[0]){\n      bool ok = true;\n      if( i + h[1] > h[0] || j + w[1] > w[0])continue;\n      // ver\n      rep(k,h[1]){\n        ok &= rht[i+k][0].match(j, j+w[1], ps[k][0]);\n      }\n      if(!ok)continue;\n      // hori\n      rep(k,w[1]){\n        ok &= rht[j+k][1].match(i, i+h[1], ps[k][1]);\n      }\n      if(ok) cout << i << \" \" << j << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\null mhash(vector<ull> v,ull k){\n  ull B=1000000007LL+k*2;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=(res*255+v[i])%B;\n  return res;\n}\null mhash2(vector<ull> v,ull k){\n  ull B=1000000007LL+k*2;\n  ull res=0;\n  for(int i=0;i<(int)v.size();i++) res=res*B+v[i];\n  return res;\n}\nconst int CNT=10;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  RollingHash srh[CNT][h];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<h;i++){\n      srh[k][i].S=s[i];\n      srh[k][i].B=1000000007LL+(2*k);\n      srh[k][i].init();\n    }\n  }\n  int r,c;\n  cin>>r>>c;\n  string t[r];\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash trh[CNT][r];\n  vector<ull> v[CNT];\n  for(int k=0;k<CNT;k++){\n    for(int i=0;i<r;i++){\n      trh[k][i].S=t[i];\n      trh[k][i].B=1000000007LL+(2*k);\n      trh[k][i].init();\n      v[k].push_back(trh[k][i].find(0,c));\n    }\n  }\n  ull base[CNT];\n  for(int k=0;k<CNT;k++) base[k]=mhash(v[k],k);\n  ull base2[CNT];\n  for(int k=0;k<CNT;k++) base2[k]=mhash2(v[k],k);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      bool flg=1;\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash(u,k)==base[k]);\n      }\n      for(int k=0;k<CNT;k++){\n\tvector<ull> u;\n\tfor(int l=0;l<r;l++)\n\t  u.push_back(srh[k][i+l].find(j,j+c));\n\tflg&=(mhash2(u,k)==base2[k]);\n      }\n      if(flg) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef unsigned long long ull;\nusing namespace std;\n\nbool DD_Rolling_Hash(int P, int Q, const vector<vector<char>>& a, vector<vector<ull>>& res) {\n\tconst ull B1 = 9973;\n\tconst ull B2 = 100000007;\n\tif (a.size() < P || a[0].size() < Q) return false;\n\tvector<vector<ull>> tmp(a.size(), vector<ull>(a[0].size() - Q + 1));\n\tres = vector<vector<ull>>(a.size() - P + 1, vector<ull>(a[0].size() - Q + 1));\n\n\tull t1 = 1;\n\tfor (int j = 0; j < Q; j++) t1 *= B1;\n\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tull e = 0;\n\t\tfor (int j = 0; j < Q; j++) e = e * B1 + a[i][j];\n\n\t\tfor (int j = 0; j + Q <= a[0].size(); j++) {\n\t\t\ttmp[i][j] = e;\n\t\t\tif (j + Q < a[0].size()) e = e * B1 - t1 * a[i][j] + a[i][j + Q];\n\t\t}\n\t}\n\n\tull t2 = 1;\n\tfor (int i = 0; i < P; i++) t2 *= B2;\n\n\tfor (int j = 0; j + Q <= a[0].size(); j++) {\n\t\tull e = 0;\n\t\tfor (int i = 0; i < P; i++) e = e * B2 + tmp[i][j];\n\n\t\tfor (int i = 0; i + P <= a.size(); i++) {\n\t\t\tres[i][j] = e;\n\t\t\tif (i + P < a.size()) e = e * B2 - t2 * tmp[i][j] + tmp[i + P][j];\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint H, W, R, C;\n\tcin >> H >> W;\n\tvector<vector<char>> a(W, vector<char>(H));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> a[j][i];\n\t\t}\n\t}\n\tcin >> R >> C;\n\tvector<vector<char>> b(C, vector<char>(R));\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> b[j][i];\n\t\t}\n\t}\n\tvector<vector<ull>> res;\n\tDD_Rolling_Hash(C, R, b, res);\n\tull f = res[0][0];\n\n\tif (DD_Rolling_Hash(C, R, a, res)) {\n\t\tfor (int i = 0; i < res[0].size(); i++) {\n\t\t\tfor (int j = 0; j < res.size(); j++) {\n\t\t\t\tif (res[j][i] == f) {\n\t\t\t\t\tcout << i << ' ' << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename T>\nclass PMA {\nprivate:\n    uint32_t id = 0;\n\npublic:\n    struct Node {\n        uint32_t id;\n        bool accepted = false;\n        unordered_map<T, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const vector<T> &vec) {\n        Node *node = root;\n        for (T v : vec) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[v] = new Node;\n                node->children[v]->id = id++;\n                node = node->children[v];\n            }\n        }\n\n        node->accepted = true;\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, T v) {\n        while (node != nullptr) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                T v = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, v);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\nint main() {\n    int32_t H, W, R, C;\n    scanf(\"%d %d\\n\", &H, &W);\n\n    vector<vector<uint8_t>> T(H);\n    for (int32_t r = 0; r < H; r++) {\n        for (int32_t c = 0; c < W; c++) {\n            T[i][j] = getchar();\n        }\n    }\n\n    cin >> R >> C;\n\n    vector<vector<uint8_t>> P(R);\n    for (int32_t r = 0; r < R; r++) {\n        for (int32_t c = 0; c < C; c++) {\n            P[i][j] = getchar();\n        }\n    }\n\n    PMA<uint8_t> pma_p;\n    vector<uint32_t> M;\n    for (vector<uint8_t> vec : P) M.push_back(pma_p.insert(vec));\n    pma_p.link_failure();\n\n    PMA<uint32_t> pma_m;\n    pma_m.insert(M);\n    pma_m.link_failure();\n\n    vector<vector<uint32_t>> T2(W);\n\n    for (vector<uint8_t> vec : T) {\n        PMA<uint8_t>::Node *node = pma_p.root;\n        for (uint32_t i = 0; i < vec.size(); i++) {\n            node = pma_p.transition(node, vec[i]);\n            T2[i].push_back(node->id);\n        }\n    }\n\n    vector<pair<uint32_t, uint32_t>> res;\n    for (int32_t c = 0; c < W; c++) {\n        PMA<uint32_t>::Node *node = pma_m.root;\n        for (int32_t r = 0; r < H; r++) {\n            node = pma_m.transition(node, T2[c][r]);\n            if (node->accepted) {\n                res.push_back(make_pair(r - R + 1, c - C + 1));\n            }\n        }\n    }\n\n    sort(res.begin(), res.end());\n\n    for (auto p : res) printf(\"%d %d\\n\", p.first, p.second);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n//Modified case lByokoP,lMyokoP\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point == -1){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tif(T[0][0]==P[0][0]){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\n// 行と列の方向の和を保持する配列 ( 配列の要素No.から, 検索パターンの文字数分の和を格納する )\nlong ary_Sum_H[MAX_ROW][MAX_COLUMN];\nlong ary_Sum_W[MAX_ROW][MAX_COLUMN];\n// 配列のサイズは, ary_HW[]より小さくなる\n\n// 行と列の方向の和を保持する配列 ( 検索パターン側 )\nlong ary_Sum_R[MAX_ROW];\nlong ary_Sum_C[MAX_COLUMN];\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        ary_Sum_R[i] = 0;\n\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n\n            // 行ごとの和を求める\n            ary_Sum_R[i] += ary_RC[i][j];\n        }\n    }\n\n    for(int j = 0; j < C; j++)\n    {\n        ary_Sum_C[j] = 0;\n\n        for(int i = 0; i < R; i++)\n        {\n            // 列ごとの和を求める\n            ary_Sum_C[j] += ary_RC[i][j];\n        }\n    }\n\n    // ***************\n    // 各行の和を求める\n    // ***************\n    for(int i = 0; i < H; i++)\n    {\n        // 残りの要素が C 以下なら計算不要\n        for(int j = 0; j < W - C + 1; j++)\n        {\n            if( j == 0 )\n            {\n                ary_Sum_H[i][j] = 0;\n\n                for(int k = 0; k < C; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_Sum_H[i][j] += ary_HW[i][k];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, C個先の値を足しておく\n                ary_Sum_H[i][j] = ary_Sum_H[i][j - 1] - ary_HW[i][j - 1] + ary_HW[i][j + C - 1];\n            }\n        }\n    }\n\n    // ***************\n    // 各列の和を求める\n    // ***************\n    for(int j = 0; j < W; j++)\n    {\n        // 残りの要素が R 以下なら計算不要\n        for(int i = 0; i < H - R + 1; i++)\n        {\n            if( i == 0 )\n            {\n                ary_Sum_W[i][j] = 0;\n\n                for(int k = 0; k < R; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_Sum_W[i][j] += ary_HW[k][j];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, R個先の値を足しておく\n                ary_Sum_W[i][j] = ary_Sum_W[i - 1][j] - ary_HW[i - 1][j] + ary_HW[i + R - 1][j];\n            }\n        }\n    }\n\n    // パターン検索を実施する\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    st_Pos pos;\n\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // 行と列方向の和を確認\n            if( ary_Sum_H[hPos][wPos] == ary_Sum_R[0]\n                && ary_Sum_W[hPos][wPos] == ary_Sum_C[0] )\n            {\n                bool searchGo = true;\n\n                // 行方向の和を確認\n                for(int i = 1; i < R; i++)\n                {\n                    if( ary_Sum_H[hPos + i][wPos] != ary_Sum_R[i] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == false )\n                {\n                    continue;\n                }\n\n                // 列方向の和を確認\n                for(int j = 1; j < C; j++)\n                {\n                    if( ary_Sum_W[hPos][wPos + j] != ary_Sum_C[j] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == true )\n                {\n                    // パターンが一致している\n                    pos.x = hPos;\n                    pos.y = wPos;\n\n                    Qst.push(pos);\n                }\n            }\n        }\n    }\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tif (R == 1){\n\t\tfor (long i = 0; i < H - R + 1; i++){\n\t\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\t\tif (T[i].substr(j, C) == P[0]) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long i = 0; i < H - R + 1; i++){\n\t\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    int minn = 1001, mini;\n    for (int i = 0; i < r; i++) {\n        int count[62] = { 0 }, maxn = 0;\n        for (int j = 0; j < c; j++) {\n            if ('0' <= f2[i][j] && f2[i][j] <= '9') {\n                count[f2[i][j] - '0']++;\n            }\n            if ('A' <= f2[i][j] && f2[i][j] <= 'Z') {\n                count[f2[i][j] - 55]++;\n            }\n            if ('a' <= f2[i][j] && f2[i][j] <= 'z') {\n                count[f2[i][j] - 61]++;\n            }\n        }\n        for (int j = 0; j < 62; j++) {\n            maxn = max(maxn, count[j]);\n        }\n        if (minn > maxn) {\n            minn = maxn;\n            mini = i;\n        }\n    }\n    mini = 0;\n    \n    for (int i = mini; i <= h - r + mini; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[mini]) {\n                bool success = true;\n                for (int k = mini - 1; k >= 0; k--) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n                for (int k = mini + 1; k < r; k++) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i - mini << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define rep(i, n) for (int i = 0; i < n; i++)\null A = 9999973;\null B = 950527;\n\nint H, W, R, C;\nstring txt[1005];\nstring pat[1005];\null t[1005][1005];\null t2[1005][1005];\n\nint main()\n{\n    cin >> H >> W;\n    rep(i, H)\n    {\n        cin >> txt[i];\n    }\n    cin >> R >> C;\n    rep(i, R)\n    {\n        cin >> pat[i];\n    }\n\n    ull target = 0;\n    rep(i, R)\n    {\n        ull key = 0;\n        rep(j, C)\n        {\n            key = key * B + pat[i][j];\n        }\n        target = target * A + key;\n    }\n\n    ull c = 1;\n    rep(i, C) c *= B;\n\n    rep(i, H)\n    {\n        ull key = 0;\n        rep(j, W)\n        {\n            key = key * B + txt[i][j];\n            if (j - C >= 0)\n                key -= txt[i][j - C] * c;\n            t[i][j] = key;\n            t2[i][j] = t[i][j];\n        }\n    }\n\n    c = 1;\n    rep(i, R) c *= A;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (i) {\n                t[i][j] += t[i - 1][j] * A;\n            }\n            if (i - R >= 0) {\n                t[i][j] -= t2[i - R][j] * c;\n            }\n            if (t[i][j] == target) {\n                if (i - R + 1 >= 0 && j - C + 1 >= 0)\n                    printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] != -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ??????????????????????????????????????????????????????????????¶??????acc?????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;jtil;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1001; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX][N_MAX];\nchar P[N_MAX][N_MAX];\nint H, W, R, C;\n\nint Hash[N_MAX][N_MAX];\nint Bpow[N_MAX][N_MAX];\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%d %d\", &H, &W);\n    rep(i,0,H) {\n        rep(j,0,W) {\n            scanf(\" %c\", &T[i][j]);\n        }\n    }\n    \n    scanf(\"%d %d\", &R, &C);\n    \n    rep(i,0,R) {\n        rep(j,0,C) {\n            scanf(\" %c\", &P[i][j]);\n        }\n    }\n    \n#ifdef debug\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << T[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n    din >> R >> C;\n    rep(i,0,R) {\n        rep(j,0,C) {\n            dout << P[i][j] << \" \";\n        }\n        dout << endl;\n    }\n    dout << endl;\n    \n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n#ifdef debug\n    //naive search\n    bool found;\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            found = true;\n            rep(ii,0,R) {\n                rep(jj,0,C) {\n                    if(T[i+ii][j+jj]!=P[ii][jj]) {\n                        found = false;\n                        ii = R;\n                        jj = C;\n                    }\n                }\n            }\n            \n            if(found) {\n                printf(\"%d %d\\n\", i, j);\n            }\n        }\n    }\n    \n    \n    dout << \"============================================\\n\";\n#endif\n    \n//    \n//    //my original Rabin-Karp Algorithm (using Rolling Hash)\n//    const int B = 10007;\n//    int t = 1;\n//    \n//    for(int i=R-1; i>=0; i--) {\n//        for(int j=C-1; j>=0; j--) {\n//            Bpow[i][j] = t;\n//            t *= B;\n//        }\n//    }\n//    \n//#ifdef debug\n//    dout << \"Bpow[][] = \\n\";\n//    rep(i,0,R) {\n//        rep(j,0,C) {\n//            dout << Bpow[i][j] << \" \";\n//        }\n//        dout << endl;\n//    }\n//#endif\n//    \n//    \n//    int HashP = 0;\n//    rep(i,0,R) {\n//        rep(j,0,C) {\n//            HashP += P[i][j]*Bpow[i][j];\n//        }\n//    }\n//    \n//#ifdef debug\n//    disp(HashP);\n//#endif\n//    \n//    int HashT = 0;\n//    rep(i,0,R) {\n//        rep(j,0,C) {\n//            HashT += T[i][j]*Bpow[i][j];\n//        }\n//    }\n//    \n//#ifdef debug\n//    disp(HashT);\n//#endif\n//    \n//    //search\n//    rep(i,0,H-R+1) {\n//        rep(j,0,W-C+1) {\n//            \n//            Hash[i][j] = HashT;\n//            \n//#ifdef debug\n//            dout << \"-------------------------\\n\";\n//            dout << i << \" \" << j << endl;\n//            disp(HashT);\n//            disp(HashP);\n//            \n//            dout << \"Hash[][] = \\n\";\n//            rep(i,0,H) {\n//                rep(j,0,W) {\n//                    dout << Hash[i][j] << \" \";\n//                }\n//                dout << endl;\n//            }\n//#endif\n//            \n//            if(HashT == HashP) {\n//                printf(\"%d %d\\n\", i, j);\n//#ifdef debug\n//                dout << \"//////////////////////////////////////////////////////////////\\n\";\n//#endif\n//            }\n//            \n//            if(j+C<W) {\n//                HashT *= B;\n//                rep(k,i,i+R) {\n//                    HashT -= T[k][j]*Bpow[k-i][0]*B;\n//                    HashT += T[k][j+C]*Bpow[k-i][C-1];\n//                }\n//            }\n//            else if(i+R<H) { //j+C = W ????????? j=W-C ???????????????j??????????????°???????????´???\n//                HashT = Hash[i][0] * Bpow[R-1][0] * B;\n//                rep(k,0,C) {\n//                    HashT -= T[i][k]*Bpow[0][k]*Bpow[R-1][0]*B;\n//                    HashT += T[i+R][k]*Bpow[R-1][k];\n//                }\n//            }\n//            \n//        }\n//    }\n//    \n//#ifdef debug\n//    dout << \"============================================\\n\";\n//#endif\n    \n    //orthodox procedure by Rabin-Karp Algorithm (using Rolling Hash)\n    const int B1 = 2;//10007;\n    const int B2 = 3; //100000007;\n    \n    \n    int tmp[N_MAX][N_MAX]; //?¨??????????B1??§??????????????°???????????\\?????????????????????P???T??????????????????????????\\????¨??????????????¨???§???????????¨\n    int hashTable_T[N_MAX][N_MAX]; //tmp?????????????????????B2??§??????????????°???????????\\??????????????????????????????T[][]??????????????????????????\\?????¨??????\n    \n    int B1powC = 1;\n    rep(i,0,C) B1powC *= B1;\n    \n    int B2powR = 1;\n    rep(i,0,R) B2powR *= B2;\n    \n    \n    //calc. hash(P)\n    int hash_P = 0;\n    \n    rep(i,0,R) {\n        tmp[i][0] = 0;\n        \n        rep(jj,0,C) {\n            tmp[i][0] = tmp[i][0]*B1 + P[i][jj];\n        }\n    }\n    rep(ii,0,R) {\n        hash_P = hash_P*B2 + tmp[ii][0];\n    }\n    \n    \n    \n    \n    //calc. tmp[][]\n    rep(i,0,H) {\n        tmp[i][0] = 0;\n        \n        rep(jj,0,C) {\n            tmp[i][0] = tmp[i][0]*B1 + T[i][jj];\n        }\n        \n        rep(j,1,W-C+1) {\n            tmp[i][j] = tmp[i][j-1]*B1 - T[i][j-1]*B1powC + T[i][j+C-1];\n        }\n    }\n    \n#ifdef debug\n    dout << \"tmp[][] = \\n\";\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << tmp[i][j] << \" \";\n        }\n        dout << endl;\n    }\n#endif\n    \n    \n    //calc. hashTable_T\n    rep(j,0,W-C+1) {\n        \n        hashTable_T[0][j] = 0;\n        \n        rep(ii,0,R) {\n            hashTable_T[0][j] = hashTable_T[0][j]*B2 + tmp[ii][j];\n        }\n        \n        rep(i,1,H-R+1) {\n            hashTable_T[i][j] = hashTable_T[i-1][j]*B2 - tmp[i-1][j]*B2powR + tmp[i+R-1][j];\n        }\n    }\n    \n#ifdef debug\n    disp(hash_P);\n    dout << \"hashTable_T[][] = \\n\";\n    rep(i,0,H) {\n        rep(j,0,W) {\n            dout << hashTable_T[i][j] << \" \";\n        }\n        dout << endl;\n    }\n#endif\n    \n    //find\n    rep(i,0,H-R+1) {\n        rep(j,0,W-C+1) {\n            if(hash_P==hashTable_T[i][j]) {\n                printf(\"%d %d\\n\", i, j);\n#ifdef debug\n                dout << \"//////////////////////////////////////////////////////////////\\n\";\n#endif\n            }\n        }\n    }\n    \n    \n\n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=48;i<=122;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i]>0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\n\t\t\tbool ptnFLG=true;\n\t\t\tif(((100*c_max/P_h*P_w)<=5)||((100*tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(abs(100*c_max/(P_h*P_w)-(100*tc_max/(T_h*T_w)))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=48;i<=122;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(abs(100*second_p_max/(P_h*P_w)-(100*second_t_max/(T_h*T_w)))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif((100*p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=48;k<=122;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=48;k<=122;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=48;i<=122;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif((100*p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if((100*p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if((100*p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif((100*t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=48;k<=122;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=48;k<=122;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=48;i<=122;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=48;k<=122;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((100*t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if((100*t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if((100*t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point == -1){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row][col+tmp_col]!=P[0][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS,top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(T[0][0]==P[0][0]){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\n\nll genHash(string s)\n{\n  ll h = 0;\n  REP(i,s.size()) h = (h * 401 + s[i])%MOD;\n  return h;\n}\n\nint main()\n{\n  int h,w; cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  int r,c; cin >> r >> c;\n  string b = \"\";\n  REP(i,r)\n  {\n    string t;\n    cin >> t;\n    b += t;\n  }\n  map<ll,vector<int> > T;\n  REP(i,h-r+1) REP(j,w-c+1)\n  {\n    string t = \"\";\n    REP(k,r) t+=a[i+k].substr(j,c);;\n    T[genHash(t)].push_back(i*w+j);\n  }\n  for(auto v : T[genHash(b)]) printf(\"%d %d\\n\",v/w,v%w);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 10000000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nlong long modpow[1001];\nint main() {\n\tmodpow[0] = 1;\n\tfor (int i = 1; i <= 1000; i++) {\n\t\tmodpow[i] = modpow[i - 1] * 256;\n\t\tmodpow[i] %= MOD;\n\t}\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tdp[i][j - M + 1] += MOD * 256 - modpow[M - 1] * x[i][j - M];\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX 100005\n#define INF 1001001001\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\nint main(int, char**)\n{\n  const mint B1 = 3;\n  const mint B2 = 9973;\n\n  int h, w;\n  cin >> h >> w;\n  vector< vector<int> > tbl(h, vector<int>(w));\n  rep(i,h) {\n    string s; cin >> s;\n    rep(j,w) tbl[i][j] = s[j]-'0';\n  }\n\n  int r, c;\n  cin >> r >> c;\n  vector< vector<int> > ptn(r, vector<int>(c));\n  rep(i,r) {\n    string s; cin >> s;\n    rep(j,c) ptn[i][j] = s[j]-'0';\n  }\n\n  vector< vector<mint> > H(h+1, vector<mint>(w+1));\n  mint e1, e2;\n\n  e2 = 1;\n  rep(i,h) {\n    e1 = 1;\n    rep(j,w) {\n      H[i+1][j+1] = e1 * e2 * (tbl[i][j]+1) + H[i][j+1] + H[i+1][j] - H[i][j];\n      e1 *= B1;\n    }\n    e2 *= B2;\n  }\n\n  mint hash_ptn = 0;\n  e2 = 1;\n  rep(i,r) {\n    e1 = 1;\n    rep(j,c) {\n      hash_ptn += e1 * e2 * (ptn[i][j]+1);\n      e1 *= B1;\n    }\n    e2 *= B2;\n  }\n\n  vector<P> ans;\n  rep(i,h-r+1) rep(j,w-c+1) {\n    mint hash_tbl = H[i+r][j+c] - H[i+r][j] - H[i][j+c] + H[i][j];\n    hash_tbl /= B2.pow(i) * B1.pow(j);\n    if (hash_ptn.x == hash_tbl.x) {\n      ans.emplace_back(i,j);\n    }\n  }\n\n  for (auto a : ans) cout << a.first << \" \" << a.second << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nconst int B=123456789;\nconst int P=1000000007;\n\nvoid gen_hash(const vector<string> &m,int H,int W,int R,int C,vector<vector<long long> >&hash){\n\tvector<vector<long long> > hash1(H);\n\thash.resize(H);\n\n\tfor(int h=0;h<H;h++){\n\t\thash1[h].resize(W);\n\t\thash[h].resize(W);\n\n\t\tlong long c=0;\n\t\tlong long Brev=1;\n\t\tfor(int w=0;w<W;w++){\n\t\t\tc=(c*B+m[h][w])%P;\n\t\t\tif(w<C)Brev=Brev*B%P;else c=((c-m[h][w-C]*Brev)%P+P)%P;\n\t\t\thash1[h][w]=c;\n\t\t}\n\t}\n\tfor(int w=0;w<W;w++){\n\t\tlong long c=0;\n\t\tlong long Brev=1;\n\t\t\tfor(int h=0;h<H;h++){\n\t\t\tc=(c*B+hash1[h][w])%P;\n\t\t\tif(h<R)Brev=Brev*B%P;else c=((c-hash1[h-R][w]*Brev)%P+P)%P;\n\t\t\thash[h][w]=c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint H,W,R,C;\n\tcin>>H>>W;\n\tvector<string>field(H);\n\tfor(int i=0;i<H;i++)cin>>field[i];\n\tcin>>R>>C;\n\tvector<string>pattern(R);\n\tfor(int i=0;i<H;i++)cin>>pattern[i];\n\tvector<vector<long long> >hash_field,hash_pattern;\n\tgen_hash(field,H,W,R,C,hash_field);\n\tgen_hash(pattern,R,C,R,C,hash_pattern);\n\tfor(int h=R-1;h<H;h++)for(int w=C-1;w<W;w++){\n\t\tif(hash_field[h][w]==hash_pattern[R-1][C-1])printf(\"%d %d\\n\",h-R+1,w-C+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n\nusing namespace std;\n\nint main()\n{\n  int h,w; cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  int r,c; cin >> r >> c;\n  string b = \"\";\n  REP(i,r)\n  {\n    string t;\n    cin >> t;\n    b += t;\n  }\n  map<string,vector<int> > T;\n  vector<vector<string> > U(h,vector<string>(w-c+1));\n  REP(i,h) REP(j,w-c+1)\n    U[i][j] = a[i].substr(j,c);\n  REP(i,h-r+1) REP(j,w-c+1)\n  {\n    string t = \"\";\n    REP(k,r) t+=U[i+k][j];\n    T[t].push_back(i*w+j);\n  }\n  for(auto v : T[b]) printf(\"%d %d\\n\",v/w,v%w);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull X = 3;\nconst ull Y = 5;\nconst int MAX = 105;\n\null hash1[MAX][MAX];\null hash2[MAX][MAX];\n\nvoid hashCalc(int T[MAX][MAX],int H,int W,int R, int  C) {\n\t//x???X???C???\n\tull x = 1;\n\tfor (int i = 0; i < C; i++) {\n\t\tx *= X;\n\t}\n\n\tull y = 1;\n\tfor (int i = 0; i < R; i++) {\n\t\ty *= Y;\n\t}\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + T[i][j];\n\t\t}\n\t\tfor (int k = 0; k + C <= W; k++) {\n\t\t\thash1[i][k] = h;\n\t\t\th = h*X + T[i][k + C] - T[i][k] * x;\n\t\t}\n\t}\n\n\tfor (int j = 0; j + C <= W; j++) {\n\t\tull h = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\th=h*Y+hash1[i][j];\n\t\t}\n\t\tfor (int k = 0; k + R <= H; k++) {\n\t\t\thash2[k][j] = h;\n\t\t\th = h*Y + hash1[k + R][j] - hash1[k][j] * y;\n\t\t}\n\t}\n}\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tint T[MAX][MAX];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> T[i][j];\n\t\t}\n\t}\n\n\tint R, C;\n\tcin >> R >> C;\n\tint P[R][C];\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tull tmp[R];\n\n\thashCalc(T, H, W, R, C);\n\t\n\tfor (int i = 0; i < R; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + P[i][j];\n\t\t}\n\t\ttmp[i] = h;\n\t}\n\n\tull hs = 0;\n\tfor (int i = 0; i < R; i++) {\n\t\ths = hs*Y + tmp[i];\n\t}\n\n\tfor (int i = 0; i + R <= H; i++) {\n\t\tfor (int j = 0; j + C <= W; j++) {\n\t\t\tif (hash2[i][j]==hs) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 100000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nlong long modpow[1001];\nint main() {\n\tmodpow[0] = 1;\n\tfor (int i = 1; i <= 1000; i++) {\n\t\tmodpow[i] = modpow[i - 1] * 256;\n\t\tmodpow[i] %= MOD;\n\t}\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tdp[i][j - M + 1] += MOD * 256 - modpow[M - 1] * x[i][j - M];\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node{\n\tint data;\n\tNode* prev;\n\tNode* next;\n};\n\nclass List{\npublic:\n\tList(){\n\t\tmotherNode = new Node();\n\t\tmotherNode->data = -1;\n\t\tmotherNode->prev = motherNode;\t//?????°?§?????????????\n\t\tmotherNode->next = motherNode;\n\t};\n\n\t//??????????????????????????\\???????????±?????°??????????´¢???????????????\n\tvoid insertFromFirst(int x){\n\t\tNode* tmpNode = motherNode->next;\n\t\twhile(tmpNode != motherNode && tmpNode->data < x){\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\n\t\tif(tmpNode == motherNode){\t//??????????????\\????????´???\n\t\t\tNode* tmpNode = motherNode->next;\n\t\t\tmotherNode->next = new Node();\n\t\t\tmotherNode->next->data = x;\n\t\t\tmotherNode->next->prev = motherNode;\n\t\t\tmotherNode->next->next = tmpNode;\n\t\t\ttmpNode->prev = motherNode->next;\n\t\t}else{\n\t\t\twhile(tmpNode != motherNode && tmpNode->data < x){\n\t\t\t\ttmpNode = tmpNode->next;\n\t\t\t}\n\t\t\tNode* prevNode = tmpNode->prev;\n\t\t\ttmpNode->prev = new Node();\n\t\t\ttmpNode->prev->data = x;\n\t\t\ttmpNode->prev->next = tmpNode;\n\t\t\ttmpNode->prev->prev = prevNode;\n\t\t\tprevNode->next = tmpNode->prev;\n\t\t}\n\t};\n\tvoid insertFromLast(int x){\t//???????????§??°????????§????°??????????\n\t\tNode* tmpNode = motherNode->prev;\n\t\tif(tmpNode == motherNode){\t//???????????????????????????????????´???\n\t\t\tmotherNode->next = new Node();\n\t\t\tmotherNode->next->data = x;\n\t\t\tmotherNode->next->next = motherNode;\n\t\t\tmotherNode->next->prev = motherNode;\n\t\t\tmotherNode->prev = motherNode->next;\n\t\t}else{\t//??¢?????????????????????????????????????????¨????????´???\n\t\t\twhile(tmpNode != motherNode && tmpNode->data > x){\n\t\t\t\ttmpNode = tmpNode->prev;\n\t\t\t}\n\t\t\tNode* nextNode = tmpNode->next;\n\t\t\ttmpNode->next = new Node();\n\t\t\ttmpNode->next->data = x;\n\t\t\ttmpNode->next->next = nextNode;\n\t\t\ttmpNode->next->prev = tmpNode;\n\t\t\tnextNode->prev = tmpNode->next;\n\t\t}\n\t}\n\n\tvoid showList(){\n\t\tNode* tmpNode = motherNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tprintf(\"%d %d\\n\",tmpNode->data/1000,tmpNode->data%1000);\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t}\n\nprivate:\n\tNode* motherNode;\n};\n\nclass RangeTable{\n\npublic:\n\tRangeTable(int T_height,int T_width,int P_height,int P_width){\n\t\t//ranges = new Range[166500];\n\t\t//range_index = 0;\n\t\tthis->T_height = T_height;\n\t\tthis->T_width = T_width;\n\t\tthis->P_height = P_height;\n\t\tthis->P_width = P_width;\n\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\tcheck_table = new char*[T_height];\t//??????????????????????????????????????¨?????????????????§???????????????????????¨\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tcheck_table[i] = new char[T_width];\n\n\t\t\t//???????????´??????????????§???????????´????????????n???????????????\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(i <= row_limit && k <= col_limit){\n\t\t\t\t\tcheck_table[i][k] = 'o';\n\t\t\t\t}else{\n\t\t\t\t\tcheck_table[i][k] = 'x';\t//???????????´??????????????§???????????´?????????x???????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//????????????\n\tvoid registerRange(int left_up,int right_down){\n\t\tint row_start = left_up/1000;\t//??????????§???´???\n\t\tint row_end = right_down/1000;\t//????????????\n\t\tint col_start = left_up%1000;\t//??????????§?\n\t\tint col_end = right_down%1000;\t//????????????\n\t\t//?????????????????????????¨????<<??????????????£????????????>>??¬???????????????[??¬?????????????????¨??????]?????????????????????????´¢??????????????????????????????????????????????????????????????????????????¨???????????¨??????????????????????????????\n\t\t//??????????????????????????????????????????????????????????£?????????????????????´??????????????????????????????????¨??????°???????????¨????????????????????¬????????????????????????????????£?????????????????¨??????????????????????????????\n\t\t//???????????????????????¢??????????????§????????¬?????????????????§??????????????£????????????\n\t\tfor(int i = row_start; i < row_end; i++){\n\t\t\tfor(int k = col_start; k < col_end; k++){\n\t\t\t\tcheck_table[i][k] = 'r';\t//registerd\n\t\t\t}\n\t\t}\n\t}\n\n\tint nextSearchLoc(int row,int col){\n\t\t//????????¨??????????????????????????¨??????????????¬???????????????????????????????????????????????¬??????????§??????¨????????????????????????\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\n\t\tfor(int tmp_col = col;tmp_col <= col_limit; tmp_col++){\t//????????????????????§??¢???\n\t\t\tif(check_table[row][tmp_col] == 'o'){\n\t\t\t\treturn 1000*row + tmp_col;\n\t\t\t}\n\t\t}\n\t\tfor(int tmp_row = row+1; row <=row_limit; row++){\t//?¬?????????\\???\n\t\t\tfor(int tmp_col = 0; tmp_col <= col_limit; tmp_col++){\n\t\t\t\tif(check_table[tmp_row][tmp_col] == 'o'){\n\t\t\t\t\treturn 1000*tmp_row + tmp_col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\t//??¨?????????range????????£?????´???\n\t}\n\nprivate:\n\tchar** check_table;\n\t//Range* ranges;\n\tint T_height,T_width,P_height,P_width;\n};\n\n\nint main(){\n\n\tint T_height,T_width,P_height,P_width;\n\n\tscanf(\"%d %d\",&T_height,&T_width);\n\n\tchar T[T_height][T_width+1];\n\n\tfor(int i = 0; i < T_height; i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%d %d\",&P_height,&P_width);\n\n\n\tif((T_height < P_height) || (T_width < P_width)) return 0;\t//T??????????????????????????????????°????????????°????´¢??????\n\n\tchar P[P_height][P_width+1];\n\n\tfor(int i = 0; i < P_height; i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\n\t//P????????????????¨??????????????????\\??????????????§?????????P???????????°?????°??????\n\tint P_total_char_count[128] = {0},P_each_char_count[P_height][128],P_first_appeard_loc[128];\n\tfor(int i = 0; i < 128; i++) P_first_appeard_loc[i] = -1;\n\n\tfor(int i = 0; i < P_height;i++){\n\t\tfor(int k = 0; k < 128; k++) P_each_char_count[i][k] = 0;\n\n\t}\n\n\n\n\tfor(int row = 0; row < P_height; row++){\n\t\tfor(int col = 0; col < P_width; col++){\n\t\t\tP_total_char_count[P[row][col]]++;\t//??¨??????????????°????¨????\n\t\t\tP_each_char_count[row][P[row][col]]++;\t//????????¨???????????°????¨????\n\t\t\tif(P_first_appeard_loc[P[row][col]] == -1){\n\t\t\t\tP_first_appeard_loc[P[row][col]] = 1000*row+col;\t//?????????????????´??????????¨????\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\n\tint c_count = 0,c_min = 10001,c_max = -1,min_char,max_char,second_appeard_loc,appeard_min = 10001;\n\tbool multFLG = false;\n\tfor(int i = 48; i <= 122; i++){\n\t\tif(P_total_char_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min > P_total_char_count[i]){\n\t\t\t\tc_min = P_total_char_count[i];\t//????????????????°???????????????????????????°????¨????\n\t\t\t\tmin_char = i;\t//?????????????????°????°?????????????????¨????\n\t\t\t}\n\t\t\tif(c_max < P_total_char_count[i]){\n\t\t\t\tc_max = P_total_char_count[i];\t//?????????????????????????????????????????°????¨????\n\t\t\t\tmax_char = i;//?????????????????°???????????????????¨????\n\t\t\t}\n\t\t}\n\t\tif(P_first_appeard_loc[i] != 0 && P_first_appeard_loc[i] < appeard_min){\n\t\t\tappeard_min = P_first_appeard_loc[i];\t//2??????????????????????????´???????????????\n\t\t}\n\t}\n\tif(c_count >= 2) multFLG = true;\n\n\tint second_appeard_row = appeard_min/1000,second_appeard_col = appeard_min%1000;\t//2??????????????????????????´??????????¨????\n\n\tif((multFLG == true) || (P_height*P_width != 1 && (P_height*P_width*100 > T_height*T_width))){\t//?????????????????????????¨????????????°????????????????????°1??§?????????????????¢????????§?????????????????´???\n\n\t\tchar start_char = P[0][0];\n\n\t\tif(c_max/(P_height*P_width-c_max) >= 1000){\t//?????????????????§???????????£???????????´???\n\n\n\t\t\tint min_appeard_row = P_first_appeard_loc[min_char]/1000,min_appeard_col = P_first_appeard_loc[min_char]%1000;\n\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char && T[row+min_appeard_row][col+min_appeard_col] == P[min_appeard_row][min_appeard_col]){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_width*second_appeard_row+second_appeard_col > 1000){ //?????????????????§???????????£????????????????????????????????´????????????1000???????¶?????????´???\n\n\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char && T[row+second_appeard_row][col+second_appeard_col] == P[second_appeard_row][second_appeard_col]){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t}else if(P_height == 1 && P_width == 1){ //1???????????´???\n\t\tchar ch = P[0][0];\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(T[i][k] == ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\t//???????¨???????????????°???????????´???\n\n\t\tchar ch = P[0][0];\t//??¢?????????\n\t\tint location;\n\n\t\tRangeTable rangeTable(T_height,T_width,P_height,P_width);\n\t\tList list;\n\n\t\tlocation = rangeTable.nextSearchLoc(0,0);\n\n\t\tint start_row,start_col,tmp_row,tmp_col,range_height,range_width,min_width = 0,min_height = 0;\n\t\tint calc_start_row,calc_start_col,calc_tmp_row,calc_tmp_col,calc_min_width = 0,calc_min_height = 0;\n\t\tif(P_height > P_width){\t//???????????´???\n\t\t\twhile(location != -1){\n\t\t\t\tstart_row = location/1000,start_col = location%1000;\n\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\tfor(tmp_row = start_row;tmp_row < T_height;tmp_row++){\n\t\t\t\t\tfor(tmp_col = start_col;tmp_col < T_width;tmp_col++){\n\t\t\t\t\t\tif(T[tmp_row][tmp_col] != ch){\n\t\t\t\t\t\t\tif((tmp_col-1) - start_col >= P_width){\t//????????????????????????????????????????????????<tmp_col-1>:?????´??????????????????\n\t\t\t\t\t\t\t\tmin_width = std::min(min_width,(tmp_col-1) - start_col);\t//????????????????????\\?????§???????????????range?????§???????°??????????<??¨???????????????????????????>????±???????\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp_col-1) - start_col < P_width) break;\t//???????´¢???????????§?????´????????¨???<(tmp_row-1)-start_row>????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t}\n\t\t\t\tif((tmp_row-1)-start_row >= P_height){\t//range????????????????????§???list????????? <<?????¶????????????????????????????????????????????\\?????§????????¨???????????¨>>\n\n\t\t\t\t\t//?????¨???????????????????????????????????????\n\t\t\t\t\trange_height = (tmp_row-1)-start_row;\t//range?????????\n\t\t\t\t\trange_width = min_width;\t//range??????\n\t\t\t\t\trangeTable.registerRange(location,1000*(start_row+range_height)+(start_col+range_width)); //??¬???????????????????????¬???????????????\n\n\t\t\t\t\tint calc_row_limit = start_row+range_height,calc_col_limit = start_col+range_width;\t//??¬??????????????????\n\t\t\t\t\tint secure_row_limit = calc_row_limit-P_height,secure_col_limit = calc_col_limit-P_width;\t//????????????????????????????????????????????\\???????¨??????????????????????????????¨???\n\t\t\t\t\tint danger_row_start = secure_row_limit+1,danger_col_start = secure_col_limit+1;\t//??¨??????????£???????????????????range???????????????????????§???????????¨???\n\t\t\t\t\tint danger_row_end = calc_row_limit-1,danger_col_end=calc_col_limit-1;\t//??±??????????????¨??????????????????????????????????????\\???range??¨??????????????????????????????????????§?????§????????????\n\n\t\t\t\t\tfor(int calc_row = start_row;calc_row <= calc_row_limit;calc_row++){\n\t\t\t\t\t\tfor(int calc_col = start_col;calc_col <= calc_col_limit;calc_col++){\n\t\t\t\t\t\t\tif(calc_row <= secure_row_limit && calc_col <= secure_col_limit){\t//?????¨???\n\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_row+calc_col);\n\t\t\t\t\t\t\t}else if(calc_row >= danger_row_start && calc_row <= danger_row_end && calc_col >= danger_col_start && calc_col <= danger_col_end){\t//??±?????????\n\t\t\t\t\t\t\t\t//?????????????§?????????????range??????????????????list?????????\n\t\t\t\t\t\t\t\tcalc_start_row = calc_row,calc_start_col = calc_col;\n\t\t\t\t\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\t\t\t\t\tfor(calc_tmp_row = calc_start_row;calc_tmp_row < T_height;calc_tmp_row++){\n\t\t\t\t\t\t\t\t\tfor(calc_tmp_col = calc_start_col;calc_tmp_col < T_width;calc_tmp_col++){\n\t\t\t\t\t\t\t\t\t\tif(T[calc_tmp_row][calc_tmp_col] != ch){\n\t\t\t\t\t\t\t\t\t\t\tif((calc_tmp_col-1) - calc_start_col >= P_width){\t//????????????????????????????????????????????????<tmp_col-1>:?????´??????????????????\n\t\t\t\t\t\t\t\t\t\t\t\tcalc_min_width = std::min(calc_min_width,(calc_tmp_col-1) - calc_start_col);\t//????????????????????\\?????§???????????????range?????§???????°??????????<??¨???????????????????????????>????±???????\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif((calc_tmp_col-1) -calc_start_col < P_width) break;\t//???????´¢???????????§?????´????????¨???????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((calc_tmp_row-1)-calc_start_row >= P_height){\t//??¨??????????£???????????????????range????????????????????§???list?????????\n\t\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_start_row+calc_start_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocation = rangeTable.nextSearchLoc(location/1000,location%1000);\t//?¬????range???????§?????????¨???????????????????§????\n\t\t\t}\n\t\t}else{\t//??£?????¢?????????????¨?????????´???\n\t\t\twhile(location != -1){\n\t\t\t\tstart_row = location/1000,start_col = location%1000;\n\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\tfor(tmp_col = start_col;tmp_col < T_width;tmp_col++){\n\t\t\t\t\tfor(tmp_row = start_row;tmp_row < T_height;tmp_row++){\n\t\t\t\t\t\tif(T[tmp_row][tmp_col] != ch){\n\t\t\t\t\t\t\tif((tmp_row-1) - start_row >= P_height){\t//???????????????????????????????????????????????????\n\t\t\t\t\t\t\t\tmin_height = std::min(min_height,(tmp_row-1) - start_row);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp_row-1) - start_row < P_height) break;\n\t\t\t\t}\n\t\t\t\tif((tmp_col-1)-start_col >= P_width){\t//range????????????\n\t\t\t\t\t//rangeTable.registerRange(1000*start_row+start_col,1000*last_row+(tmp_col-1));\n\t\t\t\t\t//?????¨???????????????????????????????????????\n\t\t\t\t\trange_width = (tmp_col-1)-start_col;\t//range??????\n\t\t\t\t\trange_height = min_height;\t//range??????\n\t\t\t\t\trangeTable.registerRange(location,1000*(start_row+range_height)+(start_col+range_width));\n\n\t\t\t\t\tint calc_row_limit = start_row+range_height,calc_col_limit = start_col+range_width;\t//??¬??????????????????\n\t\t\t\t\tint secure_row_limit = calc_row_limit-P_height,secure_col_limit = calc_col_limit-P_width;\t//????????????????????????????????????????????\\???????¨??????????????????????????????¨???\n\t\t\t\t\tint danger_row_start = secure_row_limit+1,danger_col_start = secure_col_limit+1;\t//??¨??????????£???????????????????range???????????????????????§???????????¨???\n\t\t\t\t\tint danger_row_end = calc_row_limit-1,danger_col_end=calc_col_limit-1;\t//??±??????????????¨??????????????????????????????????????\\???range??¨??????????????????????????????????????§?????§????????????\n\n\t\t\t\t\tfor(int calc_col = start_col;calc_col <= calc_col_limit;calc_col++){\n\t\t\t\t\t\tfor(int calc_row = start_row;calc_row <= calc_row_limit;calc_row++){\n\t\t\t\t\t\t\tif(calc_col <= secure_col_limit && calc_row <= secure_row_limit){\t//?????¨???\n\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_row+calc_col);\n\t\t\t\t\t\t\t}else if(calc_col >= danger_col_start && calc_col <= danger_col_end && calc_row >= danger_row_start && calc_row <= danger_row_end){\t//??±?????????\n\t\t\t\t\t\t\t\t//?????????????§?????????????range??????????????????list?????????\n\t\t\t\t\t\t\t\tcalc_start_col = calc_col,calc_start_row = calc_row;\n\t\t\t\t\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\t\t\t\t\tfor(calc_tmp_col = calc_start_col;calc_tmp_col < T_width;calc_tmp_col++){\n\t\t\t\t\t\t\t\t\tfor(calc_tmp_row = calc_start_row;calc_tmp_row < T_height;calc_tmp_row++){\n\t\t\t\t\t\t\t\t\t\tif(T[calc_tmp_row][calc_tmp_col] != ch){\n\t\t\t\t\t\t\t\t\t\t\tif((calc_tmp_row-1) - calc_start_row >= P_height){\n\t\t\t\t\t\t\t\t\t\t\t\tcalc_min_height = std::min(calc_min_height,(calc_tmp_row-1) - calc_start_row);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif((calc_tmp_row-1) -calc_start_row < P_height) break;\t//???????????§?????´????????¨???????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((calc_tmp_col-1)-calc_start_col >= P_width){\t//??¨??????????£???????????????????range????????????????????§???list?????????\n\t\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_start_row+calc_start_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocation = rangeTable.nextSearchLoc(location/1000,location%1000);\t//?¬????range???????§?????????¨???????????????????§????\n\t\t\t}\n\t\t}\n\n\t\tlist.showList();\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include<iterator>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 47;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(vector<string> &T, vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  int current_power = 1;\n  ull hash_pmminus1 = PRIME;\n  for (; current_power < m - 1; current_power <<= 1)\n    hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n  for (; current_power < m - 1; ++current_power)\n    hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n  ull hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash =\n          (segment_hash - (hash_pmminus1 * ValueOf(T[i][j - 1]) % MODULUS)) %\n          MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash =\n          (text_hash - ((hash_ppowermtimes[n - 1]) * H[i - 1][j] % MODULUS)) %\n          MODULUS;                                 // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS; // shift up\n      text_hash += H[i + n - 1][j];                // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (1000000007)\n#define P2 (99991)\n\n#define H (1000)\n#define W (1000)\n#define R (1000)\n#define C (1000)\nchar str[H][W];\nchar pat[R][C];\null str_hash[H][W];\null tmp[H][W];\n\nvoid rolling_hash(int height, int width, char character[H][W])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < width; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i + height < H; i++) {\n        \n        hash = 0;\n        for (int j = 0; j < width; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + width <= W; j++) {\n            tmp[i][j] = hash;\n            if (j + width < W) {\n                hash = hash * P1 + character[i][j + width] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < height; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + width <= W; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < height; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + height <= H; i++) {\n            str_hash[i][j] = hash;\n            if(i + height < H){\n                hash = hash * P2 + tmp[i + height][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    int sh, sw, ph, pw;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(ph, pw, str);\n    \n    for(int i = 0; i <= sh; i++){\n        for (int j = 0; j <= sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntemplate <unsigned long long MOD = 1000000007, unsigned long long base = 2009>\nstruct RollingHash {\n\tvector<unsigned long long> hash, power;\n\n\tRollingHash() {}\n\tRollingHash(const string& s) {\n\t\tint n = s.size();\n\t\thash.assign(n + 1, 0);\n\t\tpower.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash[i + 1] = (hash[i] * base + s[i]) % MOD;\n\t\t\tpower[i + 1] = power[i] * base % MOD;\n\t\t}\n\t}\n\tRollingHash(vector<unsigned long long> si) {\n\t\tint n = si.size();\n\t\thash.assign(n + 1, 0);\n\t\tpower.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash[i + 1] = (hash[i] * base + si[i]) % MOD;\n\t\t\tpower[i + 1] = power[i] * base % MOD;\n\t\t}\n\t}\n\t\n\tunsigned long long get(int l, int r) {\n\t\tunsigned long long res = hash[r] + MOD - hash[l] * power[r - l] % MOD;\n\t\treturn res - (res >= MOD ? MOD : 0);\n\t}\n\n\tint LCP(const RollingHash<MOD, base>& b, int l1, int r1, int l2, int r2) {\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid)) low = mid;\n\t\t\telse high = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\ntemplate <unsigned long long MOD, unsigned long long base1, unsigned long long base2>\nvector<vector<unsigned long long> > RollingHash_2d(vector<string> &T, int r, int c) {\n\tvector<RollingHash<MOD, base1> > rhs;\n\tfor (string s : T) rhs.push_back(s);\n\tint h = T.size(), w = T[0].size();\n\tvector<vector<unsigned long long> > res(h - r + 1, vector<unsigned long long>(w - c + 1));\n\n\tfor (int j = 0; j + c <= w; ++j) {\n\t\tvector<unsigned long long> si(h);\n\t\tfor (int i = 0; i < h; ++i) si[i] = rhs[i].get(j, j + c);\n\t\tRollingHash<MOD, base2> rh(si);\n\t\tfor (int i = 0; i + r <= h; ++i)\n\t\t\tres[i][j] = rh.get(i, i + r);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<string> T(H);\n\tfor (string& s : T) cin >> s;\n\tint R, C; cin >> R >> C;\n\tvector<string> P(R);\n\tfor (string& s : P) cin >> s;\n\tconst unsigned long long mod = 1000000007,\n\t\tbase1 = 1007, base2 = 2009;\n\tauto trh = RollingHash_2d<mod, base1, base2>(T, R, C);\n\tauto prh = RollingHash_2d<mod, base1, base2>(P, R, C);\n\tfor (int i = 0; i < H - R + 1; ++i)\n\t\tfor (int j = 0; j < W - C + 1; ++j)\n\t\t\tif (trh[i][j] == prh[0][0]) printf(\"%d %d\\n\", i, j);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\n// 行方向の和を保持する配列 ( 配列の要素No.から, 検索パターンの文字数分の和を格納する )\nlong ary_SumHW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズは, ary_HW[]より小さくなる\n\n// 行方向の和を保持する配列 ( 検索パターン側は, 行ごとの和のみで良い )\nlong ary_SumRC[MAX_ROW];\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        ary_SumRC[i] = 0;\n\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n\n            // 行ごとの和を求める\n            ary_SumRC[i] += ary_RC[i][j];\n        }\n    }\n\n    // ***************\n    // 各行の和を求める\n    // ***************\n    for(int i = 0; i < H; i++)\n    {\n        // 残りの要素が C 以下なら計算不要\n        for(int j = 0; j < W - C + 1; j++)\n        {\n            if( j == 0 )\n            {\n                ary_SumHW[i][j] = 0;\n\n                for(int k = 0; k < C; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_SumHW[i][j] += ary_HW[i][k];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, C個先の値を足しておく\n                ary_SumHW[i][j] = ary_SumHW[i][j - 1] - ary_HW[i][j - 1] + ary_HW[i][j + C - 1];\n            }\n        }\n    }\n\n    // パターン検索を実施する\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // // 行方向の和を確認\n            if( ary_SumHW[hPos][wPos] == ary_SumRC[0] )\n            {\n                bool searchGo = true;\n\n                // 全行の和を確認\n                for(int i = 1; i < R; i++)\n                {\n                    if( ary_SumHW[hPos + i][wPos] != ary_SumRC[i] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == true )\n                {\n                    // 文字パターンの検索を実施する\n                    patternMatching(hPos, wPos);\n                }\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の箇所が見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\n// 行方向の和を保持する配列 ( 配列の要素No.から, 検索パターンの文字数分の和を格納する )\nlong ary_SumHW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズは, ary_HW[]より小さくなる\n\n// 行方向の和を保持する配列 ( 検索パターン側は, 行ごとの和のみで良い )\nlong ary_SumRC[MAX_ROW];\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        ary_SumRC[i] = 0;\n\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n\n            // 行ごとの和を求める\n            ary_SumRC[i] += ary_RC[i][j];\n        }\n    }\n\n    // ***************\n    // 各行の和を求める\n    // ***************\n    for(int i = 0; i < H; i++)\n    {\n        // 残りの要素が C 以下なら計算不要\n        for(int j = 0; j < W - C + 1; j++)\n        {\n            if( j == 0 )\n            {\n                ary_SumHW[i][j] = 0;\n\n                for(int k = 0; k < C; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_SumHW[i][j] += ary_HW[i][k];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, C個先の値を足しておく\n                ary_SumHW[i][j] = ary_SumHW[i][j - 1] - ary_HW[i][j - 1] + ary_HW[i][j + C - 1];\n            }\n        }\n    }\n\n    // パターン検索を実施する\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // // 行方向の和を確認\n            if( ary_SumHW[hPos][wPos] == ary_SumRC[0] )\n            {\n                bool searchGo = true;\n\n                // 全行の和を確認\n                for(int i = 1; i < R; i++)\n                {\n                    if( ary_SumHW[hPos + i][wPos] != ary_SumRC[i] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == true )\n                {\n                    // 文字パターンの検索を実施する\n                    patternMatching(hPos, wPos);\n                }\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の箇所が見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, double> pld;\ntypedef pair<double, ll> pdl;\ntypedef pair<int, char> pic;\ntypedef vector<ll> vl;\ntypedef priority_queue<pll, vector<pll>, greater<pll>> pllgreaterq;\ntypedef priority_queue<pair<ll, pll>, vector<pair<ll, pll>>, greater<pair<ll, pll>>> plpllgreaterq;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 310000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[200010];\nint lank[200010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nint same(int x, int y) {\n\treturn parent(x) == parent(y);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (lank[px] < lank[py]) {\n\t\tpr[py] = px;\n\t\tlank[px] += lank[py] + 1;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t\tlank[py] += lank[px] + 1;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll* a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char>* a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char>* a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll* a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char>* a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char>* a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nll n;\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode* parent, * left, * right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node* t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node* t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node* t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node* t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]) {\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H / 2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\n\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,-1,0,1 };\nstd::vector<int> find_all(const std::string str, const std::string subStr) {\n\tstd::vector<int> result;\n\n\tint subStrSize = subStr.size();\n\tint pos = str.find(subStr);\n\n\twhile (pos != std::string::npos) {\n\t\tresult.push_back(pos);\n\t\tpos = str.find(subStr, pos + 1);\n\t}\n\n\treturn result;\n}\n//ll memo[100010];\n//ll next[100010];\n//ll dm[100010];\n//int f[100010];\n//ll rec(int x) {\n//\n//\tif (~memo[x]) return memo[x];\n//\tif (x == n) { \n//\t\tdm[n] = 1;\n//\t\treturn 1; \n//\t}\n//\tll *res = &memo[x];\n//\t*res = 0;\n//\tset<int> st;\n//\tst.insert(f[x]);\n//\tfor (int i = x + 1; i <= n; i++)\n//\t{\n//\t\tif (~memo[i]) {\n//\t\t\t*res += memo[i] + 1;\n//\t\t\t*res %= INF;\n//\t\t\tbreak;\n//\t\t}\n//\n//\t\t*res += rec(i);\n//\t\t*res %= INF;\n//\t\tif (st.find(f[i]) != st.end()) {break; }\n//\t\tst.insert(f[i]);\n//\t}\n//\n//\treturn *res;\n//}\n#define bit(x,v) ((ll)x << v)\n\nclass BIT {\n\n\tstatic const int MAX_N = 200010;\npublic:\n\tBIT() { memset(bit, 0, sizeof(bit)); }\n\tint bit[MAX_N + 1], n;\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n)\n\t\t{\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tvoid clear() {\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\tint a[MAX_N];\n\tvoid bable_swap_count() {\n\t\tll ans = 0;\n\t\tfor (size_t j = 0; j < n; j++)\n\t\t{\n\t\t\tans += j - sum(a[j]);\n\t\t\tadd(a[j], 1);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\tint search(int s, int x) {\n\n\t\tll half = (s + x) / 2;\n\t\tll sh = sum(x);\n\n\t\tll sl = sum(half);\n\n\t\tll st = sum(s);\n\t\tif (sh - sl == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (sh - sl < x - half) {\n\t\t\treturn search(half, x);\n\t\t}\n\n\t\tif (sl - st == 0) {\n\t\t\treturn half;\n\t\t}\n\n\t\tif (sl - st < half - s) {\n\t\t\treturn search(s, half);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lankSearch(int lank) {\n\t\treturn lankSearch(lank, 0, MAX_N);\n\t}\n\tint lankSearch(int lank, int s, int t) {\n\n\t\tll half = (s + t) / 2;\n\n\t\tll v = sum(half);\n\t\tll v1 = sum(t);\n\t\tll v2 = sum(s);\n\t\tif (lank == 1) {\n\t\t\tif (s + 1 >= t) return t;\n\t\t\telse if (v - v2 > 0) {\n\t\t\t\treturn lankSearch(lank, s, half);\n\t\t\t}\n\t\t\telse return lankSearch(lank, half, t);\n\t\t}\n\n\t\tif ((v - v2) < lank) {\n\t\t\treturn lankSearch(lank - (v - v2), half, t);\n\t\t}\n\t\tif ((v - v2) >= lank) {\n\t\t\treturn lankSearch(lank, s, half);\n\t\t}\n\n\t\treturn -1;\n\t}\n};\n//void test() {\n//\tdouble m;\n//\tcin >> m;\n//\t//p11(15, m);\n//\tdouble b = 5854;\n//\tdouble ba = 4224.96;\n//\tdouble bb = (ba / 12);\n//\tdouble ret = 222;\n//\tdouble mon = 23.472;\n//\tcout << fixed << endl;\n//\n//\tfor (double i = 5; i <= 15; i++)\n//\t{\n//\t\tdouble p = b * i;\n//\t\tdouble u = ba * i;\n//\t\tdouble r = ret * (15 - i) - (bb * (15 - i));\n//\t\tdouble m = mon * i;\n//\t\tcout << i << \" mon:\" << m << \" ret:\" << p + r << \" pay:\" << u << \" gross\" << p + r - u << \" %:\" << (p + r) / u << endl;\n//\t}\n//\t//double reib = 21542.8;\n//\t//double reiba = 17358.264;\n//\tdouble reib = 8298;\n//\tdouble reiba = 5599.44;\n//\tdouble reim = 46.662;\n//\tdouble ret2 = 233.1;\n//\tcout << \"reti\" << endl;\n//\tfor (double i = 0; i <= 5; i++)\n//\t{\n//\t\tdouble p = reib * i;\n//\t\tdouble u = reiba * i;\n//\t\tdouble m = reim * i;\n//\t\tdouble r = -(ret2 * (5 - i));\n//\t\tcout << i << \" mon:\" << m << \" ret:\" << p + r << \" u:\" << u << \" gross:\" << p + r - u << \" %\" << (p + r) / u << endl;\n//\t}\n//\tcout << \"resutl \" << endl;\n//\tfor (double i = 5; i <= 15; i++)\n//\t{\n//\t\tdouble p = b * i;\n//\t\tdouble u = ba * i;\n//\t\tdouble r = ret * (15 - i) - (bb * (15 - i));\n//\t\tdouble m = mon * i;\n//\t\tfor (double j = 0; j <= 5; j++)\n//\t\t{\n//\t\t\tdouble p2 = reib * j;\n//\t\t\tdouble u2 = reiba * j;\n//\t\t\tdouble m2 = reim * j;\n//\t\t\tdouble r2 = -(ret2 * (5 - j));\n//\t\t\tif (m + m2 > (585.39 - 230)) continue;\n//\t\t\tcout << (int)i << \" \" << (int)j << \" mon:\" << m + m2 << \" ret:\" << p + p2;\n//\t\t\tcout << \" u:\" << u + u2 << \" gross:\" << (p + r - u) + (p2 + r2 - u2);\n//\t\t\tcout << \" %\" << ((p + r) + (p2 + r2)) / (u + u2) << endl;\n//\t\t}\n//\t\tcout << endl;\n//\t}\n//}\nvector<ll> getp(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tif (n % 2 == 0) {\n\t\tres.push_back(2);\n\t\twhile (n % 2 == 0)n /= 2;\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\twhile (n % i == 0)n /= i;\n\t\t}\n\t}\n\tif (n != 1) res.push_back(n);\n\treturn res;\n}\nvector<ll> getp2(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tif (n % 2 == 0) {\n\t\t\n\t\twhile (n % 2 == 0) { n /= 2; res.push_back(2);}\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\t\t\t\n\t\t\twhile (n % i == 0) { n /= i; res.push_back(i); }\n\t\t}\n\t}\n\tif (n != 1) res.push_back(n);\n\treturn res;\n}\nvector<ll> getDivisors(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tres.push_back(1);\n\tfor (ll i = 2; i * i <= n; i++)\n\t{\n\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\tif (n / i != i)\n\t\t\t\tres.push_back(n / i);\n\t\t}\n\t}\n\treturn res;\n}\nbool check(ll a, ll b) {\n\n\tll c = a * b;\n\tint t[10];\n\tfill(t, t + 10, 0);\n\twhile (a > 0) { if (t[a % 10] > 0)return false; t[a % 10]++;  a /= 10; }\n\twhile (b > 0) { if (t[b % 10] > 0)return false; t[b % 10]++; b /= 10; }\n\twhile (c > 0) { if (t[c % 10] > 0)return false; t[c % 10]++; c /= 10; }\n\tif (t[0] > 0) return false;\n\t\n\tfor (size_t i = 1; i < 10; i++)\n\t{\n\t\tif (t[i] == 0) return false;\n\t}\n\treturn true;\n}\n\nvoid solv() {\n\n\t// \n\t//string a(1000, 'c');\n\t//string b(1000, 'c');\n\t//int cnt = 0;\n\t//for (size_t i = 0; i < 1000000; i++)\n\t//{\n\t//\ta = a.substr(0, 1000);\n\t//\tb = b.substr(0, 1000);\n\t//\tif (a == b) {\n\t//\t\tcnt++;\n\t//\t}\n\t//}\n\n\t//cout << cnt << endl;\n\tint h, w, r, c;\n\tcin >> h >> w;\n\tstring tb[1010];\n\tfor (size_t i = 0; i < h; i++)\n\t{\n\t\tcin >> tb[i];\n\t}\n\tcin >> r >> c;\n\tstring pa[1010];\n\tfor (size_t i = 0; i < r; i++)\n\t{\n\t\tcin >> pa[i];\n\t}\n\tstring b[1010];\n\tvector<pii> res;\n\tfor (size_t i = 0; i < w - c + 1; i++)\n\t{\n\t\tfor (size_t j = 0; j < h; j++)\n\t\t{\n\t\t\tb[j] = tb[j].substr(i, c);\n\t\t}\n\n\t\tfor (size_t j = 0; j < h - r + 1; j ++)\n\t\t{\n\t\t\tbool ok = true;\n\t\t\tfor (size_t k = j; k < j + r; k++)\n\t\t\t{\n\t\t\t\tif (pa[k - j] != b[k]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tres.push_back(make_pair(j, i));\n\t\t\t}\n\t\t}\n\t}\n\tsort(res.begin(), res.end());\n\tfor (size_t i = 0; i < res.size(); i++)\n\t{\n\t\tcout << res[i].first << \" \" << res[i].second << endl;\n\t}\n}\n\nint main() {\n\t//COMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring S[10000];\nstring T[10000];\n\nint main() {\n\tint n, m, r, c, sum, t=0;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i];\n\t}\n\tcin >> r >> c;\n\tfor (int i = 0; i < r; i++) {\n\t\tcin >> T[i];\n\t}\n\tfor (int i = 0; i <= n - r; i++) {\n\t\tfor (int j = 0; j <= m - c; j++) {\n\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\tif (T[k] != S[k + i].substr(j, c)) {\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\tif (t >= 500 && k >= r) {\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t}\n\t\tExit2:;\n\t\t\tcout << i << ' ' << j << endl;\n\t\t\tt++;\n\t\tExit:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\n//I'm sorry. Data is too big to submit. So I omit some cases.\n\nclass LocRecord{\n\npublic:\n\tLocRecord(){\n\t\tlocationTable = new int[1001];\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tlocationTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\n\tvoid regist_loc(int location){\n\t\tlocationTable[index++] = location;\n\t}\n\n\tint next_loc(){\n\t\tint ret = locationTable[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\n\n\tvoid deBug(){\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tprintf(\"locationTable[%d]:%d\\n\",i,locationTable[i]);\n\t\t}\n\t}\n\nprivate:\n\tint* locationTable;\n\tint index;\n};\n\n\n\nint main(){\n\n\tlong long T_height,T_width,P_height,P_width;\n\n\tscanf(\"%lld %lld\",&T_height,&T_width);\n\n\tchar T[T_height][T_width+1];\n\n\tfor(int i = 0; i < T_height; i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_height,&P_width);\n\n\tif((T_height < P_height) || (T_width < P_width)) return 0;\n\n\tchar P[P_height][P_width+1];\n\n\tfor(int i = 0; i < P_height; i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tint P_total_char_count[128] = {0},P_first_appeard_loc[128];\n\n\tfor(int i = 0; i < 128; i++) P_first_appeard_loc[i] = -1;\n\n\n\tfor(int row = 0; row < P_height; row++){\n\t\tfor(int col = 0; col < P_width; col++){\n\t\t\tP_total_char_count[P[row][col]]++;\n\t\t\tif(P_first_appeard_loc[P[row][col]] == -1){\n\t\t\t\tP_first_appeard_loc[P[row][col]] = 1000*row+col;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tint c_count = 0,c_min = 1000001,c_max = -1,min_char,max_char,appeard_min = 1000001;\n\tbool multFLG = false;\n\tfor(int i = 48; i <= 122; i++){\n\t\tif(P_total_char_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min > P_total_char_count[i]){\n\t\t\t\tc_min = P_total_char_count[i];\n\t\t\t\tmin_char = i;\n\t\t\t}\n\t\t\tif(c_max < P_total_char_count[i]){\n\t\t\t\tc_max = P_total_char_count[i];\n\t\t\t\tmax_char = i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_appeard_loc[i] != 0 && P_first_appeard_loc[i] < appeard_min){\n\t\t\tappeard_min = P_first_appeard_loc[i];\n\t\t}\n\t}\n\tif(c_count >= 2) multFLG = true;\n\n\tint second_appeard_row = appeard_min/1000,second_appeard_col = appeard_min%1000;\n\n\n\tint T_char_count[128] = {0};\n\n\tfor(int row = 0; row < T_height; row++){\n\t\tfor(int col = 0; col < T_width; col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\n\tint tc_count = 0,tc_max = -1,t_max_char;\n\tbool t_multFLG = false;\n\tfor(int i = 48; i <= 122; i++){\n\t\tif(T_char_count[i] > 0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max < T_char_count[i]){\n\t\t\t\ttc_max = T_char_count[i];\n\t\t\t\tt_max_char = i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count >= 2) t_multFLG = true;\n\n\tfor(int i = 0; i < 128; i++){\n\t\tif(T_char_count[i] < P_total_char_count[i])\treturn 0;\n\t}\n\n\tif(multFLG == true){\n\n\t\tchar start_char = P[0][0];\n\n\t\tif(c_max/(P_height*P_width-c_max) >= 899){\n\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\tint check_row = P_first_appeard_loc[min_char]/1000,check_col = P_first_appeard_loc[min_char]%1000;\n\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char && T[row+check_row][col+check_col] == P[check_row][check_col]){\n\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_width*second_appeard_row+second_appeard_col > 1000){\n\n\t\t\tbool matchFLG;\n\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\n\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\tif(T[row][col] == start_char && T[row+second_appeard_row][col+second_appeard_col] == P[second_appeard_row][second_appeard_col]){\n\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tbool patternFLG = true;\n\t\t\tif((100*(c_max/P_height*P_width) <= 5) || (100*(tc_max/T_height*T_width) <= 5)){\n\t\t\t\tpatternFLG = false;\n\t\t\t}\n\n\t\t\tif(patternFLG){\n\t\t\t\tif((T_height-P_height)*(T_width-P_width)*(P_height*P_width) < 500000000){\n\t\t\t\t\tpatternFLG = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(patternFLG){\n\t\t\t\tif(100*abs(c_max/(P_height*P_width) - tc_max/(T_height*T_width)) >= 5){\n\t\t\t\t\tpatternFLG = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max = -1,second_t_max = -1,second_p_char,second_t_char;\n\t\t\tif(patternFLG){\n\t\t\t\tfor(int i = 0; i < 128; i++){\n\t\t\t\t\tif(T_char_count[i] > 0 && i != t_max_char){\n\t\t\t\t\t\tsecond_t_max = std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_total_char_count[i] > 0 && i != max_char){\n\t\t\t\t\t\tsecond_p_max = std::max(second_p_max,P_total_char_count[i]);\n\t\t\t\t\t\tsecond_p_char = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_height*P_width) - second_t_max/(T_height*T_width)) >= 2){\n\t\t\t\t\tpatternFLG = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(patternFLG){\n\t\t\t\tif((max_char != t_max_char && max_char != second_t_char) || (second_p_char != t_max_char && second_p_char != second_t_char)){\n\t\t\t\t\tpatternFLG = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLocRecord p_brokenHorizon,p_brokenVertical,t_brokenHorizon,t_brokenVertical;\n\t\t\tbool horizonP = false,regularP = false,littleBrokenHorizonP = false,littleMatchHorizonP = false;\n\t\t\tbool horizonT = false,regularT = false,littleBrokenHorizonT = false,littleMatchHorizonT = false;\n\t\t\tint p_horizon_max_succeed = 0,tmp_succeed = 0;\n\t\t\tint t_horizon_max_succeed = 0;\n\t\t\tif(patternFLG){\n\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i = 0,k=0; i < P_height; i++){\n\t\t\t\t\ttmp = P[i][0];\n\t\t\t\t\tfor(k = 1; k < P_width; k++){\n\t\t\t\t\t\tif(tmp != P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k != P_width){\n\t\t\t\t\t\tp_horizon_max_succeed = std::max(p_horizon_max_succeed,tmp_succeed);\n\t\t\t\t\t\ttmp_succeed = 0;\n\t\t\t\t\t\tp_brokenHorizon.regist_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_succeed++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_horizon_max_succeed = std::max(p_horizon_max_succeed,tmp_succeed);\n\n\n\t\t\t\tif(100*(p_horizon_max_succeed/P_height) <= 5){\n\t\t\t\t\tint** P_each_row_char = new int*[P_height];\n\n\t\t\t\t\tfor(int i = 0; i < P_height; i++){\n\t\t\t\t\t\tP_each_row_char[i] = new int[128];\n\t\t\t\t\t\tfor(int k = 0; k < 128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = 0; k < P_width;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint** P_char_distance_table = new int*[P_height];\n\t\t\t\t\tfor(int i = 0; i < P_height; i++){\n\t\t\t\t\t\tP_char_distance_table[i] = new int[128];\n\t\t\t\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\t\t\t\tP_char_distance_table[i][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tint history_loc[128],tmp_distance,history_max,history_min;\n\t\t\t\t\tfor(int i = 0; i < P_height; i++){\n\t\t\t\t\t\tfor(int k = 0; k < 128; k++) history_loc[k] = 0;\n\t\t\t\t\t\tfor(int k = 0; k < P_width; k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]] == 0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]] = k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_distance = k - history_loc[P[i][k]];\n\n\t\t\t\t\t\t\t\thistory_max = P_char_distance_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min = P_char_distance_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max == 0 || history_max < tmp_distance){\n\t\t\t\t\t\t\t\t\thistory_max = tmp_distance;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min == 0 || history_min > tmp_distance){\n\t\t\t\t\t\t\t\t\thistory_min = tmp_distance;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_char_distance_table[i][P[i][k]] = 1000*history_max + history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool num_of_val_and_appeard_count = true;\n\t\t\t\t\tbool char_distance = true;\n\n\t\t\t\t\tfor(int i = 1,k = 0; i < P_height; i++){\n\n\t\t\t\t\t\tfor(k = 0; k < 128; k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k] != P_each_row_char[0][k] && abs(P_each_row_char[i][k] - P_each_row_char[0][k]) > 1){\n\t\t\t\t\t\t\t\tnum_of_val_and_appeard_count = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k != 128) break;\n\t\t\t\t\t}\n\n\t\t\t\t\tbool isDistance_constant0 = true;\n\t\t\t\t\tbool isDistance_constantOther = true;\n\t\t\t\t\tif(num_of_val_and_appeard_count){\n\t\t\t\t\t\tint min_0 = 1001,max_0 = -1;\n\t\t\t\t\t\tfor(int i = 0; i < 128; i++){\n\t\t\t\t\t\t\tif(P_char_distance_table[0][i] > 0){\n\t\t\t\t\t\t\t\tif(min_0 == 1001 && max_0 == -1){\n\t\t\t\t\t\t\t\t\tmin_0 = P_char_distance_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0 = P_char_distance_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0 != max_0){\n\t\t\t\t\t\t\t\t\t\tisDistance_constant0 = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0 != 1001 && max_0 != -1){\n\t\t\t\t\t\t\t\t\tif(P_char_distance_table[0][i]%1000 != min_0 || P_char_distance_table[0][i]/1000 != max_0){\n\t\t\t\t\t\t\t\t\t\tisDistance_constant0 = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(isDistance_constant0){\n\t\t\t\t\t\tfor(int i = 1; i < P_height; i++){\n\t\t\t\t\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\t\t\t\t\tif(P_char_distance_table[0][k] != P_char_distance_table[i][k]){\n\t\t\t\t\t\t\t\t\tisDistance_constantOther = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(num_of_val_and_appeard_count == true && char_distance == true && isDistance_constant0 == true && isDistance_constantOther == true){\n\t\t\t\t\t\tregularP = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(100*(p_horizon_max_succeed/P_height) <= 5 && regularP == false){\n\t\t\t\t\tpatternFLG = false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_horizon_max_succeed == P_height){\n\t\t\t\t\t\thorizonP = true;\n\t\t\t\t\t}else if(100*(p_horizon_max_succeed/P_height) >= 50){\n\t\t\t\t\t\tlittleBrokenHorizonP = true;\n\t\t\t\t\t}else if(100*(p_horizon_max_succeed/P_height) >= 6){\n\t\t\t\t\t\tlittleMatchHorizonP = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(patternFLG){\n\n\t\t\t\t\ttmp_succeed = 0;\n\n\t\t\t\t\tfor(int i = 0,k=0; i < T_height; i++){\n\t\t\t\t\t\ttmp = T[i][0];\n\t\t\t\t\t\tfor(k = 1; k < T_width; k++){\n\t\t\t\t\t\t\tif(tmp != T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k != T_width){\n\t\t\t\t\t\t\tt_horizon_max_succeed = std::max(t_horizon_max_succeed,tmp_succeed);\n\t\t\t\t\t\t\ttmp_succeed = 0;\n\t\t\t\t\t\t\tt_brokenHorizon.regist_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_succeed++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_horizon_max_succeed = std::max(t_horizon_max_succeed,tmp_succeed);\n\n\n\t\t\t\t\tif(100*(t_horizon_max_succeed/T_height) <= 5){\n\n\t\t\t\t\t\tint** T_each_row_char = new int*[T_height];\n\n\t\t\t\t\t\tfor(int i = 0; i < T_height; i++){\n\t\t\t\t\t\t\tT_each_row_char[i] = new int[128];\n\t\t\t\t\t\t\tfor(int k = 0; k < 128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k = 0; k < T_width;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint** T_char_distance_table = new int*[T_height];\n\t\t\t\t\t\tfor(int i = 0; i < T_height; i++){\n\t\t\t\t\t\t\tT_char_distance_table[i] = new int[128];\n\t\t\t\t\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\t\t\t\t\tT_char_distance_table[i][k] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tint history_loc[128],tmp_distance,history_max,history_min;\n\t\t\t\t\t\tfor(int i = 0; i < T_height; i++){\n\t\t\t\t\t\t\tfor(int k = 0; k < 128; k++) history_loc[k] = 0;\n\t\t\t\t\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]] == 0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]] = k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_distance = k - history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max = T_char_distance_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min = T_char_distance_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max == 0 || history_max < tmp_distance){\n\t\t\t\t\t\t\t\t\t\thistory_max = tmp_distance;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min == 0 || history_min > tmp_distance){\n\t\t\t\t\t\t\t\t\t\thistory_min = tmp_distance;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_char_distance_table[i][T[i][k]] = 1000*history_max + history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]] = k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool num_of_val_and_appeard_count = true;\n\t\t\t\t\t\tbool char_distance = true;\n\n\t\t\t\t\t\tfor(int i = 1,k = 0; i < T_height; i++){\n\n\t\t\t\t\t\t\tfor(k = 0; k < 128; k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k] != T_each_row_char[0][k] && abs(T_each_row_char[i][k] - T_each_row_char[0][k]) > 1){\n\t\t\t\t\t\t\t\t\tnum_of_val_and_appeard_count = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k != 128) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool isDistance_constant0 = true;\n\t\t\t\t\t\tbool isDistance_constantOther = true;\n\t\t\t\t\t\tif(num_of_val_and_appeard_count){\n\t\t\t\t\t\t\tint min_0 = 1001,max_0 = -1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 128; i++){\n\t\t\t\t\t\t\t\tif(T_char_distance_table[0][i] > 0){\n\t\t\t\t\t\t\t\t\tif(min_0 == 1001 && max_0 == -1){\n\t\t\t\t\t\t\t\t\t\tmin_0 = T_char_distance_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0 = T_char_distance_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0 != max_0){\n\t\t\t\t\t\t\t\t\t\t\tisDistance_constant0 = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0 != 1001 && max_0 != -1){\n\t\t\t\t\t\t\t\t\t\tif(T_char_distance_table[0][i]%1000 != min_0 || T_char_distance_table[0][i]/1000 != max_0){\n\t\t\t\t\t\t\t\t\t\t\tisDistance_constant0 = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(isDistance_constant0){\n\t\t\t\t\t\t\tfor(int i = 1; i < T_height; i++){\n\t\t\t\t\t\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\t\t\t\t\t\tif(T_char_distance_table[0][k] != T_char_distance_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tisDistance_constantOther = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(num_of_val_and_appeard_count == true && char_distance == true && isDistance_constant0 == true && isDistance_constantOther == true){\n\t\t\t\t\t\t\tregularT = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tif(100*(t_horizon_max_succeed/T_height) <= 5 && regularT == false){\n\t\t\t\t\t\tpatternFLG = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_horizon_max_succeed == T_height){\n\t\t\t\t\t\t\thorizonT = true;\n\t\t\t\t\t\t}else if(100*(t_horizon_max_succeed/T_height) >= 50){\n\t\t\t\t\t\t\tlittleBrokenHorizonT = true;\n\t\t\t\t\t\t}else if(100*(t_horizon_max_succeed/T_height) >= 6){\n\t\t\t\t\t\t\tlittleMatchHorizonT = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(patternFLG){\n\n\t\t\t\t\tif((horizonP == true || littleBrokenHorizonP == true || littleMatchHorizonP == true) &&\n\t\t\t\t\t\t(horizonT == false && littleBrokenHorizonT == false && littleMatchHorizonT == false)){\n\t\t\t\t\t\tpatternFLG = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(regularP == true && regularT == false){\n\t\t\t\t\t\tpatternFLG = false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(patternFLG){\n\t\t\t\tif(horizonP == true){\n\n\t\t\t\t\tif(horizonT == true  && p_horizon_max_succeed <= t_horizon_max_succeed){\n\t\t\t\t\t\tint horizon_top = 0,horizon_bottom = P_height-1;\n\t\t\t\t\t\tint top_limit = T_height-P_height,search_row,out_col_limit = T_width-P_width;\n\n\t\t\t\t\t\twhile(horizon_top <= top_limit){\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++ ){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0] != T[search_row][0]) break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row > horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col = 0; out_col <= out_col_limit;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((littleBrokenHorizonT == true || littleMatchHorizonT == true )&& p_horizon_max_succeed <= t_horizon_max_succeed){\n\t\t\t\t\t\t//omit\n\t\t\t\t\t}\n\n\t\t\t\t}else if(littleBrokenHorizonP == true){\n\t\t\t\t\tif(horizonT == true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((littleBrokenHorizonT == true || littleMatchHorizonT == true )&& p_horizon_max_succeed <= t_horizon_max_succeed){\n\t\t\t\t\t\t//omit\n\t\t\t\t\t}\n\t\t\t\t}else if(littleMatchHorizonP == true){\n\t\t\t\t\tif(horizonT == true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((littleBrokenHorizonT == true || littleMatchHorizonT == true )&& p_horizon_max_succeed <= t_horizon_max_succeed){\n\n\t\t\t\t\t\t//omit\n\t\t\t\t\t}\n\t\t\t\t}else if(regularP){\n\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\t\t\tif(T[row][col] == start_char){\n\t\t\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col] != P[tmp_row][col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\t\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\n\t\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\t\tif(T[row][col] == start_char){\n\t\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_height == 1 && P_width == 1){\n\t\tchar ch = P[0][0];\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(T[i][k] == ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tif(t_multFLG){\n\n\t\t\tif(((tc_max)/(T_height*T_width-tc_max) >= 10000) && (t_max_char == P[0][0])){\n\n\t\t\t\tLocRecord tLocRecord;\n\n\t\t\t\tfor(int row = 0; row < P_height; row++){\n\t\t\t\t\tfor(int col = 0; col < P_width; col++){\n\t\t\t\t\t\tif(P[row][col] != t_max_char){\n\t\t\t\t\t\t\ttLocRecord.regist_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable = new int*[T_height];\n\t\t\t\tfor(int i = 0; i < T_height; i++){\n\t\t\t\t\tpossibilityTable[i] = new int[T_width];\n\t\t\t\t\tfor(int k = 0; k < T_width;k++){\n\t\t\t\t\t\tpossibilityTable[i][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint del_location = tLocRecord.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_location != -1){\n\t\t\t\t\tcenter_row = del_location/1000;\n\t\t\t\t\tcenter_col = del_location%1000;\n\t\t\t\t\tif(0 < center_col-P_width){\n\t\t\t\t\t\tdel_left = center_col-P_width;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left = 0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right = std::min(T_width-1,center_col+P_width);\n\t\t\t\t\tif(0 < center_row-P_height){\n\t\t\t\t\t\tdel_top = center_row-P_height;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top = 0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor = std::min(T_height-1,center_row+P_height);\n\t\t\t\t\tfor(int i = del_top; i <= del_floor; i++){\n\t\t\t\t\t\tfor(int k = del_left; k <= del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_location = tLocRecord.next_loc();\n\t\t\t\t}\n\n\t\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\t\tif(possibilityTable[row][col] == 0)\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_height-P_height)*(T_width-P_width)*(P_height*P_width) < 500000000) || (tc_max/(T_height*T_width-tc_max) <= 1000)){\n\n\t\t\t\tchar p_ch = P[0][0];\n\t\t\t\tbool matchFLG;\n\t\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\n\t\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\t\tif(T[row][col] == p_ch){\n\t\t\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t}\n\n\t\t}else{\n\t\t\tif(T[0][0] == P[0][0]){\n\t\t\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_C\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n\tint H, W, R, C;\n\tvector<string> T, P;\n\tstring str;\n\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++){\n\t\tcin>>str;\n\t\tT.push_back(str);\n\t}\n\n\tcin>>R>>C;\n\tfor(int i=0;i<R;i++){\n\t\tcin>>str;\n\t\tP.push_back(str);\n\t}\n\n\tif((H>=R) && (W>=C))\n\t\tfor(int i=0;i<=H-R;i++)\n\t\t\tfor(int j=0;j<=W-C;j++)\n\t\t\t\tif(T[i].substr(j, C) == P[0])\n\t\t\t\t\tif(R == 1)\n\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(int k=i+1;k<i+R;k++)\n\t\t\t\t\t\t\tif(T[k].substr(j, C) == P[k-i])\n\t\t\t\t\t\t\t\tif(k == R+i-1)\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  //vector<vector<int> >td(til);\n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      //td[til-j-1].push_back(node);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  //vector<int>a(acc.size()+tl+2,-1);\n  int a[acc.size()+tl+2];\n  //fill(a,a+acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n\nusing namespace std;\n\nint main()\n{\n  int h,w; cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  int r,c; cin >> r >> c;\n  string b = \"\";\n  REP(i,r)\n  {\n    string t;\n    cin >> t;\n    b += t;\n  }\n  map<string,vector<int> > T;\n  REP(i,h-r+1) REP(j,w-c+1)\n  {\n    string t = \"\";\n    REP(k,r) t+=a[i+k].substr(j,c);;\n    T[t].push_back(i*w+j);\n  }\n  for(auto v : T[b]) printf(\"%d %d\\n\",v/w,v%w);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[1000][1000];\n\tlong long has_P[1000][1000];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"(%d, %d)\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\nint N,M,T,P,Q;\nchar field[1010][1010];\nchar pattern[1010][1010];\nll hash_[1010][1010],tmp[1010][1010];\n\nvoid compute_hash(char a[1010][1010],int n,int m){\n    const ull B1=9973;\n    const ull B2=100000007;\n    ull t1=1;\n    for(int j=0;j<Q;j++)t1*=B1;\n    for(int i=0;i<n;i++){\n        ull e=0;\n        for(int j=0;j<Q;j++)e=e*B1+a[i][j];\n        for(int j=0;j+Q<=m;j++){\n            tmp[i][j]=e;\n            if(j+Q<m)e=e*B1-t1*a[i][j]+a[i][j+Q];\n        }\n    }\n    ull t2=1;\n    for(int i=0;i<P;i++)t2*=B2;\n    for(int j=0;j+Q<=m;j++){\n        ull e=0;\n        for(int i=0;i<P;i++)e=e*B2+tmp[i][j];\n        for(int i=0;i+P<=n;i++){\n            hash_[i][j]=e;\n            if(i+P<n)e=e*B2-t2*tmp[i][j]+tmp[i+P][j];\n        }\n    }\n}\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    cin>>N>>M;\n    for(int i=0;i<N;i++)for(int j=0;j<M;j++)cin>>field[i][j];\n    cin>>P>>Q;\n    for(int i=0;i<P;i++)for(int j=0;j<Q;j++)cin>>pattern[i][j];\n    compute_hash(pattern,P,Q);\n    ull ttmp=hash_[0][0];\n    compute_hash(field,N,M);\n    for(int i=0;i+P<=N;i++){\n        for(int j=0;j+Q<=M;j++){\n            if(hash_[i][j]==ttmp){\n                cout<<i<<\" \"<<j<<endl;\n            }\n        }\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n     \n     \nusing namespace std;\n     \nstruct AhoCorasick {\n     \n  static const int ALPHABET_SIZE = 62, root=0;\n     \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n       \n  int N; // num of node\n     \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n     \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n     \n  vector<Node> nodes;\n     \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n     \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] == -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n     \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n     \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n     \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n     \n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n       \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n     \n  const int til = T[0].size();\n       \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n     \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n     \nint main(void){\n  int h,w,r,c;\n       \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n     \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstd::vector<int> MPAlgorithm(const std::string& str)\n{\n\tstd::vector<int> ret(str.size() + 1);\n\tret[0] = -1;\n\tfor (int i{}; i < (int)str.size(); i++)\n\t{\n\t\tint prev{ret[i]};\n\t\twhile (prev >= 0 && str[prev] != str[i]) prev = ret[prev];\n\t\tret[i + 1] = prev + 1;\n\t}\n\treturn std::move(ret);\n}\n\nint main()\n{\n\tint H, W;\n\tscanf(\"%d%d\", &H, &W);\n\tstd::vector<std::string> field(H);\n\tfor (auto& e: field) std::cin >> e;\n\tint R, C;\n\tscanf(\"%d%d\", &R, &C);\n\tstd::vector<std::string> pattern(R);\n\tfor (auto& e: pattern) std::cin >> e;\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\tvvi mp(R);\n\tfor (int i{}; i < R; i++)\n\t\tmp[i] = MPAlgorithm(pattern[i]);\n\tfor (int row{}; row + R <= H; row++)\n\t{\n\t\tstd::bitset<1000> bs{};\n\t\tfor (int i{}; i + C <= W; i++)\n\t\t\tbs[i] = true;\n\t\tfor (int p_r{}; p_r < R; p_r++)\n\t\t{\n\t\t\tfor (int i{}, length{}; i < W; i++)\n\t\t\t{\n\t\t\t\twhile (length >= 0 && field[row + p_r][i] != pattern[p_r][length]) length = mp[p_r][length];\n\t\t\t\tlength++;\n\t\t\t\tif (length < C)\n\t\t\t\t{\n\t\t\t\t\tif (i - C + 1 >= 0)\n\t\t\t\t\t\tbs[i - C + 1] = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlength = mp[p_r][length];\n\t\t\t}\n\t\t}\n\t\tfor (int col{}; col < W; col++)\n\t\t\tif (bs[col])\n\t\t\t\tprintf(\"%d %d\\n\", row, col);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tlong j = T[i].find(P[0], 0);\n\t\tif (j != -1){\n\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\telse {\n\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\tif (T[i + k].find(P[k], j) != j) break;\n\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T;\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n\n    long long hash[1000][1000];\n    long long s;\n\n    for(i = 0; i < R; i++){\n        s = 0;\n        char P[1000];\n        scanf(\"%s\", P);\n        for(j = 0; j < C; j++){\n            s = (s * A + P[j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * A + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\tdelete [] T;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\ntypedef unsigned long long ull;\n \nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n \nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 100007;\n    \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n    \n    for(int i = 0 ; i < n ; i++){\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q]; \n        }\n    }\n    \n    ull t2 = 1;\n    for(int i = 0 ; i < P ; i++) t2 *= B2;\n    \n    for(int j = 0 ; j + Q <= m ; j++){\n        ull e = 0;\n        for(int i = 0 ; i < P ; i++) e = e * B2 + tmp[i][j];\n      \n        for(int i = 0 ; i + P <= n ; i++){\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i+P][j];\n        }\n    }\n}\n  \nvoid solve(){\n    compute_hash(pattern, P, Q);\n    ull res = hash[0][0];\n    compute_hash(field, N, M);\n    for(int i = 0 ; i <= N ; i++){\n        for(int j = 0 ; j <= M ; j++){\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n \nint main(){\n    cin >> N >> M;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for(int i = 0 ; i < P ; i++){\n        for(int j = 0 ; j < Q ; j++){\n            cin >> pattern[i][j];\n        }\n    }\n    if(N < P && M < Q) return 0;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\null hash2d(char a[MAX][MAX],int r,int c)\n{\n\tull tmp[r]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmp[i]=tmp[i]*B1+a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<r;i++)\n\t{\n\t\ttmp[0]=tmp[0]*B2+tmp[i];\n\t}\n\treturn tmp[0];\n}\n\nvector<pair<int,int>> match2d(char s[MAX][MAX],char a[MAX][MAX],int h,int w,int r,int c)\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash=hash2d(a,r,c);\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tchar s[MAX][MAX];\n\tchar a[MAX][MAX];\n\tint h,w,r,c;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d(s,a,h,w,r,c);\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(int i=0;i<m.size();i++)\n\t{\n\t\tcout<<m[i].first<<\" \"<<m[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tif (R == 1){\n\t\tfor (long i = 0; i < H - R + 1; i++){\n\t\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\t\tif (T[i].substr(j, C) == P[0]) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long i = 0; i < H - R + 1; i++){\n\t\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=t_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(T[0][0]==P[0][0]){\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define MAX 2100\n\n#define  B  (ull)((int)1e9+7)\n#define  B2  (ull)((int)1e9+9)\n\nint H, W, R, C;\nstring hw[MAX], rc[MAX];\n\nvoid solve(){\n\tull bm = 1, bm2 = 1, hhw = 0, hrc = 0, temph[MAX] = {}, temp = 0;\n\t\n\tfor(int i = 0; i < C; i++) bm *= B;\n\tfor(int i = 0; i < R; i++) bm2 *= B2;\n\t\n\tfor(int i = 0; i < R; i++){\n\t\tfor(int j = 0; j < C; j++) temph[i] = temph[i]*B + hw[i][j];\n\t\thhw = hhw*B2 + temph[i];\n\t\t// for(int j = C; j < W; j++) temp = temp*B + hw[i][j];\n\t}\n\t\n\tfor(int i = 0; i < R; i++){\n\t\ttemp = 0;\n\t\tfor(int j = 0; j < C; j++) temp = temp*B + rc[i][j];\n\t\thrc = hrc*B2 + temp;\n\t}\n\t// cout<<hhw<<\" \"<<hrc<<endl;\n\tfor(int i = 0; i + R <= H; i++){\n\t\tfor(int j = 0; j + C <= W; j++){\n\t\t\t// cout<<i<<\" \"<<j<<\" \"<<hhw<<\" \"<<hrc<<endl;\n\t\t\tif(hhw == hrc) cout<<i<<\" \"<<j<<endl;\n\t\t\tif(j+C>W)continue;\n\t\t\thhw = 0;\n\t\t\tfor(int k = 0; k < R; k++){\n\t\t\t\ttemph[i+k] = temph[i+k]*B + hw[i+k][j+C] - hw[i+k][j]*bm;\n\t\t\t\t// temph[i+k] = 0;\n\t\t\t\t// for(int l = j; l < C+j; l++) temph[i+k] = temph[i+k]*B + hw[i+k][j];\n\t\t\t\thhw = hhw*B2 + temph[i+k];\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<temph[i+k]<<endl;\n\t\t\t}\n\t\t\t// cout<<hhw<<\" +++ \"<<endl<<endl;\n\t\t}\n\t\tif(i+R>H)continue;\n\t\thhw = 0;\n\t\tfor(int j = 1; j <= R; j++){\n\t\t\ttemph[i+j] = 0;\n\t\t\tfor(int k = 0; k < C; k++) temph[i+j] = temph[i+j]*B + hw[i+j][k];\n\t\t\thhw = hhw*B2 + temph[i+j];\n\t\t}\n\t\t// for(int j = 0; j < C; j++) temph[i+R] = temph[i+R]*B + hw[i+R][j];\n\t\t// hhw = hhw*B2 + temph[i+R] - temph[i]*bm2;\t\t\n\t}\n}\n\nint main(){\n\tcin>>H>>W;\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin>>hw[i];\n\t}\n\t\n\tcin>>R>>C;\n\t\n\tfor(int i = 0; i < R; i++){\n\t\tcin>>rc[i];\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstruct RollingHash{\n  LL H, W;\n  const LL B1, B2, M;\n  vector<vector<LL>> h;\n  VL pow1, pow2;\n  RollingHash(VS& str): B1(1009), B2(1007), M(1000000009){\n\tH = str.size(), W = str[0].size();\n\th.assign(H+1, vector<LL>(W+1, 0));\n\tpow1.assign(H+1,1);\n\tpow2.assign(W+1,1);\n\n\tREP(i,H)\n\t  pow1[i+1] = pow1[i] * B1 % M;\n\tREP(i,W)\n\t  pow2[i+1] = pow2[i] * B2 % M;\n\t\n\tREP(y,H) REP(x,W){\n\t  h[y+1][x+1] = (h[y][x+1] * B1 % M + h[y+1][x] * B2 % M\n\t\t\t\t\t\t+ (M - h[y][x] * B1 % M * B2 % M) + str[y][x]) % M;\n\t}\n  }\n\n  LL hash(int x1, int y1, int x2, int y2){\n\treturn (h[y2][x2]\n\t\t\t+ (M - h[y1][x2] * pow1[y2-y1] % M)\n\t\t\t+ (M - h[y2][x1] * pow2[x2-x1] % M)\n\t\t\t+ (h[y1][x1] * pow1[y2-y1] % M * pow2[x2-x1] % M)) % M;\n  }\n};\n\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W;\n  cin >> H >> W;\n  VS vs(H);\n  REP(y,H) cin >> vs[y];\n  int R, C;\n  cin >> R >> C;\n  VS pat(R);\n  REP(y,R) cin >> pat[y];\n\n  RollingHash rs(vs), pt(pat);\n  LL target = pt.hash(0, 0, C, R);\n  FOR(y,R,H+1) FOR(x,C,W+1){\n\tif(rs.hash(x-C, y-R, x, y) == target){\n\t  cout << y-R << \" \" << x-C << endl;\n\t}\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (63533)\n#define P2 (100007)\n\n#define H (1000)\n#define W (1000)\n#define R (1000)\n#define C (1000)\nchar str[H][W];\nchar pat[R][C];\null str_hash[H][W];\null tmp[H][W];\nint sh, sw, ph, pw;\n\nvoid rolling_hash(int height, int width, char character[H][W])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < pw; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i < height; i++) {\n        hash = 0;\n        for (int j = 0; j < pw; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + pw <= width; j++) {\n            tmp[i][j] = hash;\n            if (j + width < W) {\n                hash = hash * P1 + character[i][j + pw] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < ph; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + pw <= width; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < ph; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + ph <= height; i++) {\n            str_hash[i][j] = hash;\n            if(i + height < H){\n                hash = hash * P2 + tmp[i + ph][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(sh, sw, str);\n    \n    for(int i = 0; i <= sh; i++){\n        for (int j = 0; j <= sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (63533)\n#define P2 (100007)\n\n#define H (1000)\n#define W (1000)\n#define R (1000)\n#define C (1000)\nchar str[H][W];\nchar pat[R][C];\null str_hash[H][W];\null tmp[H][W];\n\nvoid rolling_hash(int height, int width, char character[H][W])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < width; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i + height < H; i++) {\n        \n        hash = 0;\n        for (int j = 0; j < width; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + width <= W; j++) {\n            tmp[i][j] = hash;\n            if (j + width < W) {\n                hash = hash * P1 + character[i][j + width] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < height; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + width <= W; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < height; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + height <= H; i++) {\n            str_hash[i][j] = hash;\n            if(i + height < H){\n                hash = hash * P2 + tmp[i + height][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    int sh, sw, ph, pw;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(ph, pw, str);\n    \n    for(int i = 0; i <= sh; i++){\n        for (int j = 0; j <= sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A=9999973,B=950527;\n\nint H,W;\nchar T[1005][1005];\null t[1005][1005];\null t2[1005][1005];\nint h,w;\nchar U[1005][1005];\n\n\nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n  \n  ull target=0;  \n  for(int i=0;i<h;i++){\n    ull key=0;\n    for(int j=0;j<w;j++){\n      key=key*B+U[i][j];\n    }\n    target=target*A+key;\n  }\n\n  ull C=1;\n  for(int i=0;i<w;i++)C*=B;\n  \n  for(int i=0;i<H;i++){\n    ull key=0;\n    for(int j=0;j<W;j++){\n      key=key*B+T[i][j];\n      if(j-w>=0)key-=T[i][j-w]*C;\n      t[i][j]=key;\n      t2[i][j]=t[i][j];\n    }\n  }\n  \n  C=1;\n  for(int i=0;i<h;i++)C*=A;\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(i)t[i][j]+=t[i-1][j]*A;\n      if(i-h>=0)t[i][j]-=t2[i-h][j]*C;\n      if(t[i][j]==target){\n        if(i-h+1>=0&&j-w+1>=0)\n          printf(\"%d %d\\n\",i-h+1,j-w+1);\n      }\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define HIRA 177771\n#define R 1000\nusing namespace std;\ntypedef unsigned long long ull;\null ab[R][R],cd[R][R];\null lo[R][R],to[R][R];\nstring su[R],pu[R];\nint main(){\n  int h1,w1,h11,w11;\n  cin>>h1>>w1;\n \n  for(int i=0;i<h1;i++)cin>>su[i];\n \n  for(int i=0;i<h1;i++)\n    for(int j=0;j<w1;j++)ab[i][j]=su[i][j];\n \n  cin>>h11>>w11;\n  for(int i=0;i<h11;i++)cin>>pu[i];\n \n  for(int i=0;i<h11;i++)\n    for(int j=0;j<w11;j++)cd[i][j]=pu[i][j]; \n \n \n \n  ull sawa=0;\n  for(int i=0;i<h11;i++)\n    for(int j=0;j<w11;j++)sawa=sawa*HIRA+cd[i][j];\n \n  for(int j=0;j<h1;j++){\n    ull bor=0,gojob=1;\n    for(int i=0;i<w11;i++)bor*=HIRA,bor+=ab[j][i],gojob*=HIRA;\n    lo[j][w11-1]=bor;\n    for(int i=w11;i<w1;i++){\n      bor*=HIRA,bor+=ab[j][i],bor-=ab[j][i-w11]*gojob;\n      lo[j][i]=bor;\n    }\n  }\n \n  for(int j=w11-1;j<w1;j++){\n    ull bor=0,gojob=1,n=1;\n    for(int i=0;i<w11;i++)n*=HIRA;\n    for(int i=0;i<h11;i++)bor*=n,bor+=lo[i][j],gojob*=n;\n    to[h11-1][j]=bor;\n    for(int i=h11;i<h1;i++){\n      bor*=n,bor+=lo[i][j],bor-=lo[i-h11][j]*gojob; \n      to[i][j]=bor;\n    }\n  }\n \n \n  for(int i=h11-1;i<h1;i++)\n    for(int j=w11-1;j<w1;j++)\n      if(sawa==to[i][j])printf(\"%d %d\\n\",i-h11+1,j-w11+1);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include <cstdlib>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull X = 100001;\nconst ull Y = 9973;\nconst int MAX = 1005;\n\null hash1[MAX][MAX];\null hash2[MAX][MAX];\n\nvoid hashCalc(char T[MAX][MAX],int H,int W,int R, int  C) {\n\t//x???X???C???\n\tull x = 1;\n\tfor (int i = 0; i < C; i++) {\n\t\tx *= X;\n\t}\n\n\tull y = 1;\n\tfor (int i = 0; i < R; i++) {\n\t\ty *= Y;\n\t}\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + T[i][j];\n\t\t}\n\t\tfor (int k = 0; k + C <= W; k++) {\n\t\t\thash1[i][k] = h;\n\t\t\th = h*X + T[i][k + C] - T[i][k] * x;\n\t\t}\n\t}\n\n\tfor (int j = 0; j + C <= W; j++) {\n\t\tull h = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\th=h*Y+hash1[i][j];\n\t\t}\n\t\tfor (int k = 0; k + R <= H; k++) {\n\t\t\thash2[k][j] = h;\n\t\t\th = h*Y + hash1[k + R][j] - hash1[k][j] * y;\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s,t;\n\t\n\tint H, W;\n\tcin >> H >> W;\n\tchar T[MAX][MAX];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> T[i][j];\n\t\t}\n\t}\n\n\tint R, C;\n\tcin >> R >> C;\n\tchar P[R][C];\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tull tmp[R];\n\n\thashCalc(T, H, W, R, C);\n\t\n\tfor (int i = 0; i < R; i++) {\n\t\tull h = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\th = h*X + P[i][j];\n\t\t}\n\t\ttmp[i] = h;\n\t}\n\n\tull hs = 0;\n\tfor (int i = 0; i < R; i++) {\n\t\ths = hs*Y + tmp[i];\n\t}\n\n\tfor (int i = 0; i + R <= H; i++) {\n\t\tfor (int j = 0; j + C <= W; j++) {\n\t\t\tif (hash2[i][j]==hs) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[100][100];\n\tlong long has_P[100][100];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + has_P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"%d %d\\n\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 47;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(const vector<string> &T, const vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  int current_power = 1;\n  ull hash_pmminus1 = PRIME;\n  for (; current_power < m - 1; current_power <<= 1)\n    hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n  for (; current_power < m - 1; ++current_power)\n    hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n  ull hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash =\n          (segment_hash - (hash_pmminus1 * ValueOf(T[i][j - 1]) % MODULUS)) %\n          MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash =\n          (text_hash - ((hash_ppowermtimes[n - 1]) * H[i - 1][j] % MODULUS)) %\n          MODULUS;                                 // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS; // shift up\n      text_hash += H[i + n - 1][j];                // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define HIRA 177771\n#define R 1000\nusing namespace std;\ntypedef unsigned long long ull;\null ab[R][R],cd[R][R];\null lo[R][R],to[R][R];\nstring su[R],pu[R];\nint main(){\n  int h1,w1,h11,w11;\n  cin>>h1>>w1;\n \n  for(int i=0;i<h1;i++)cin>>su[i];\n \n  for(int i=0;i<h1;i++)\n    for(int j=0;j<w1;j++)ab[i][j]=su[i][j];\n \n  cin>>h11>>w11;\n  for(int i=0;i<h11;i++)cin>>pu[i];\n \n  for(int i=0;i<h11;i++)\n    for(int j=0;j<w11;j++)cd[i][j]=pu[i][j]; \n \n \n \n  ull sawa=0;\n  for(int i=0;i<h11;i++)\n    for(int j=0;j<w11;j++)sawa=sawa*HIRA+cd[i][j];\n \n  for(int j=0;j<h1;j++){\n    ull bor=0,gojob=1;\n    for(int i=0;i<w11;i++)bor*=HIRA,bor+=sawabor[j][i],gojob*=HIRA;\n    lo[j][w11-1]=bor;\n    for(int i=w11;i<w1;i++){\n      bor*=HIRA,bor+=sawabor[j][i],bor-=sawabor[j][i-w11]*gojob;\n      lo[j][i]=bor;\n    }\n  }\n \n  for(int j=w11-1;j<w1;j++){\n    ull bor=0,gojob=1,n=1;\n    for(int i=0;i<w11;i++)n*=HIRA;\n    for(int i=0;i<h11;i++)bor*=n,bor+=lo[i][j],gojob*=n;\n    to[h11-1][j]=bor;\n    for(int i=h11;i<h1;i++){\n      bor*=n,bor+=lo[i][j],bor-=lo[i-h11][j]*gojob; \n      to[i][j]=bor;\n    }\n  }\n \n \n  for(int i=h11-1;i<h1;i++)\n    for(int j=w11-1;j<w1;j++)\n      if(sawa==to[i][j])printf(\"%d %d\\n\",i-h11+1,j-w11+1);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\n//Code size is too big,sorry.\n//Modified case lByokoP,lMyokoP\n\nclass Loc{\npublic:\n\tLoc(){\n\t\tTable = new int[1001];\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tTable[i] = -1;\n\t\t}\n\t\tindex = 0;\n\t}\n\tvoid init_index(){\n\t\tindex = 0;\n\t}\n\tvoid reg_loc(int location){\n\t\tTable[index++] = location;\n\t}\n\tint next_loc(){\n\t\tint ret = Table[index];\n\t\tindex++;\n\t\treturn ret;\n\t}\nprivate:\n\tint* Table;\n\tint index;\n};\n\nint H_lmt,W_lmt;\nlong long T_h,T_w,P_h,P_w;\n\nint main(){\n\n\tscanf(\"%lld %lld\",&T_h,&T_w);\n\n\tchar T[T_h][T_w+1];\n\n\tfor(int i=0;i<T_h;i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\tscanf(\"%lld %lld\",&P_h,&P_w);\n\n\tif((T_h<P_h)||(T_w<P_w)) return 0;\n\n\tchar P[P_h][P_w+1];\n\n\tfor(int i=0;i<P_h;i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\tH_lmt=T_h-P_h,W_lmt=T_w-P_w;\n\n\tint P_count[128]={0},P_first_loc[128];\n\n\tfor(int i=0;i<128;i++) P_first_loc[i] = -1;\n\n\tfor(int row=0;row<P_h;row++){\n\t\tfor(int col=0;col<P_w;col++){\n\t\t\tP_count[P[row][col]]++;\n\t\t\tif(P_first_loc[P[row][col]]==-1){\n\t\t\t\tP_first_loc[P[row][col]]=1000*row+col;\n\t\t\t}\n\t\t}\n\t}\n\tint c_count=0,c_min=1000001,c_max=-1,min_char,max_char,appeard_min=1000001;\n\tbool multFLG = false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(P_count[i] > 0){\n\t\t\tc_count++;\n\t\t\tif(c_min>P_count[i]){\n\t\t\t\tc_min=P_count[i];\n\t\t\t\tmin_char=i;\n\t\t\t}\n\t\t\tif(c_max<P_count[i]){\n\t\t\t\tc_max=P_count[i];\n\t\t\t\tmax_char=i;\n\t\t\t}\n\t\t}\n\t\tif(P_first_loc[i]!=0&&P_first_loc[i]<appeard_min){\n\t\t\tappeard_min=P_first_loc[i];\n\t\t}\n\t}\n\tif(c_count>=2)multFLG=true;\n\n\tint second_row=appeard_min/1000,second_col=appeard_min%1000,T_char_count[128]={0};\n\n\tfor(int row=0;row<T_h;row++){\n\t\tfor(int col=0;col<T_w;col++){\n\t\t\tT_char_count[T[row][col]]++;\n\t\t}\n\t}\n\tint tc_count=0,tc_max=-1,t_max_char;\n\tbool t_multFLG=false;\n\tfor(int i=48;i<=122;i++){\n\t\tif(T_char_count[i]>0){\n\t\t\ttc_count++;\n\t\t\tif(tc_max<T_char_count[i]){\n\t\t\t\ttc_max=T_char_count[i];\n\t\t\t\tt_max_char=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(tc_count>=2)t_multFLG=true;\n\n\tfor(int i=0;i<128;i++){\n\t\tif(T_char_count[i]<P_count[i])\treturn 0;\n\t}\n\n\tchar p00=P[0][0];\n\tif(multFLG==true){\n\t\tif(c_max/(P_h*P_w-c_max)>=899){\n\t\t\tbool matchFLG;\n\t\t\tint chk_row=P_first_loc[min_char]/1000,chk_col=P_first_loc[min_char]%1000;\n\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+chk_row][col+chk_col]==P[chk_row][chk_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(P_w*second_row+second_col>1000){\n\t\t\tbool matchFLG;\n\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\tif(T[row][col]==p00&&T[row+second_row][col+second_col]==P[second_row][second_col]){\n\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool ptnFLG=true;\n\t\t\tif((100*(c_max/P_h*P_w)<=5)||(100*(tc_max/T_h*T_w)<=5)){\n\t\t\t\tptnFLG=false;\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif(100*abs(c_max/(P_h*P_w)-tc_max/(T_h*T_w))>=5){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint second_p_max=-1,second_t_max=-1,second_p_char,second_t_char;\n\t\t\tif(ptnFLG){\n\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\tif(T_char_count[i]>0&&i!=t_max_char){\n\t\t\t\t\t\tsecond_t_max=std::max(second_t_max,T_char_count[i]);\n\t\t\t\t\t\tsecond_t_char=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(P_count[i]>0&&i!=max_char){\n\t\t\t\t\t\tsecond_p_max=std::max(second_p_max,P_count[i]);\n\t\t\t\t\t\tsecond_p_char=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*abs(second_p_max/(P_h*P_w)-second_t_max/(T_h*T_w))>=2){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ptnFLG){\n\t\t\t\tif((max_char!=t_max_char&&max_char!=second_t_char)||(second_p_char!=t_max_char&&second_p_char!=second_t_char)){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoc p_brokenH,t_brokenH;\n\n\t\t\tbool yokoP=false,ptnP=false,lByokoP=false,lMyokoP=false,yokoT=false,ptnT=false,lByokoT=false,lMyokoT=false;\n\t\t\tint p_yoko_max_suc=0,tmp_suc=0,t_yoko_max_suc=0;\n\t\t\tif(ptnFLG){\n\t\t\t\tchar tmp;\n\t\t\t\tfor(int i=0,k=0;i<P_h;i++){\n\t\t\t\t\ttmp=P[i][0];\n\t\t\t\t\tfor(k=1;k<P_w;k++){\n\t\t\t\t\t\tif(tmp!=P[i][k])\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=P_w){\n\t\t\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\tp_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp_yoko_max_suc=std::max(p_yoko_max_suc,tmp_suc);\n\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5){\n\t\t\t\t\tint** P_each_row_char=new int*[P_h];\n\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_each_row_char[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tP_each_row_char[i][P[i][k]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint** P_dist_table=new int*[P_h];\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tP_dist_table[i]=new int[128];\n\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\tP_dist_table[i][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\tfor(int i=0;i<P_h;i++){\n\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\tfor(int k=0;k<P_w;k++){\n\t\t\t\t\t\t\tif(history_loc[P[i][k]]==0){\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[P[i][k]];\n\t\t\t\t\t\t\t\thistory_max=P_dist_table[i][P[i][k]]/1000;\n\t\t\t\t\t\t\t\thistory_min=P_dist_table[i][P[i][k]]%1000;\n\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tP_dist_table[i][P[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\thistory_loc[P[i][k]]=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool val_and_count=true,char_dist=true;\n\t\t\t\t\tfor(int i=1,k=0;i<P_h;i++){\n\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\tif(P_each_row_char[i][k]!=P_each_row_char[0][k]&&abs(P_each_row_char[i][k]-P_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t}\n\t\t\t\t\tbool Dist0=true,DistOther=true;\n\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\tif(P_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\tmin_0=P_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\tmax_0=P_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\tif(P_dist_table[0][i]%1000!=min_0||P_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\tfor(int i=1;i<P_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(P_dist_table[0][k]!=P_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\tptnP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(100*(p_yoko_max_suc/P_h)<=5&&ptnP==false){\n\t\t\t\t\tptnFLG=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(p_yoko_max_suc==P_h){\n\t\t\t\t\t\tyokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=50){\n\t\t\t\t\t\tlByokoP=true;\n\t\t\t\t\t}else if(100*(p_yoko_max_suc/P_h)>=6){\n\t\t\t\t\t\tlMyokoP=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ptnFLG){\n\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\tfor(int i=0,k=0;i<T_h;i++){\n\t\t\t\t\t\ttmp=T[i][0];\n\t\t\t\t\t\tfor(k=1;k<T_w;k++){\n\t\t\t\t\t\t\tif(tmp!=T[i][k])\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k!=T_w){\n\t\t\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\t\t\t\t\t\t\ttmp_suc=0;\n\t\t\t\t\t\t\tt_brokenH.reg_loc(1000*i+k);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttmp_suc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt_yoko_max_suc=std::max(t_yoko_max_suc,tmp_suc);\n\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5){\n\t\t\t\t\t\tint** T_each_row_char=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_each_row_char[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tT_each_row_char[i][T[i][k]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint** T_dist_table=new int*[T_h];\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tT_dist_table[i]=new int[128];\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\tT_dist_table[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint history_loc[128],tmp_dist,history_max,history_min;\n\t\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(int k=0;k<128;k++)history_loc[k]=0;\n\t\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\t\tif(history_loc[T[i][k]]==0){\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttmp_dist=k-history_loc[T[i][k]];\n\n\t\t\t\t\t\t\t\t\thistory_max=T_dist_table[i][T[i][k]]/1000;\n\t\t\t\t\t\t\t\t\thistory_min=T_dist_table[i][T[i][k]]%1000;\n\t\t\t\t\t\t\t\t\tif(history_max==0||history_max<tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_max=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(history_min==0||history_min>tmp_dist){\n\t\t\t\t\t\t\t\t\t\thistory_min=tmp_dist;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tT_dist_table[i][T[i][k]]=1000*history_max+history_min;\n\t\t\t\t\t\t\t\t\thistory_loc[T[i][k]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool val_and_count=true;\n\t\t\t\t\t\tbool char_dist=true;\n\t\t\t\t\t\tfor(int i=1,k=0;i<T_h;i++){\n\t\t\t\t\t\t\tfor(k=0;k<128;k++){\n\t\t\t\t\t\t\t\tif(T_each_row_char[i][k]!=T_each_row_char[0][k]&&abs(T_each_row_char[i][k]-T_each_row_char[0][k])>1){\n\t\t\t\t\t\t\t\t\tval_and_count=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k!=128)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool Dist0=true;\n\t\t\t\t\t\tbool DistOther=true;\n\t\t\t\t\t\tif(val_and_count){\n\t\t\t\t\t\t\tint min_0=1001,max_0=-1;\n\t\t\t\t\t\t\tfor(int i=0;i<128;i++){\n\t\t\t\t\t\t\t\tif(T_dist_table[0][i]>0){\n\t\t\t\t\t\t\t\t\tif(min_0==1001&&max_0==-1){\n\t\t\t\t\t\t\t\t\t\tmin_0=T_dist_table[0][i]%1000;\n\t\t\t\t\t\t\t\t\t\tmax_0=T_dist_table[0][i]/1000;\n\t\t\t\t\t\t\t\t\t\tif(min_0!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(min_0!=1001&&max_0!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T_dist_table[0][i]%1000!=min_0||T_dist_table[0][i]/1000!=max_0){\n\t\t\t\t\t\t\t\t\t\t\tDist0=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Dist0){\n\t\t\t\t\t\t\tfor(int i=1;i<T_h;i++){\n\t\t\t\t\t\t\t\tfor(int k=0;k<128;k++){\n\t\t\t\t\t\t\t\t\tif(T_dist_table[0][k]!=T_dist_table[i][k]){\n\t\t\t\t\t\t\t\t\t\tDistOther=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(val_and_count==true&&char_dist==true&&Dist0==true&&DistOther==true){\n\t\t\t\t\t\t\tptnT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(100*(t_yoko_max_suc/T_h)<=5&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t_yoko_max_suc==T_h){\n\t\t\t\t\t\t\tyokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=50){\n\t\t\t\t\t\t\tlByokoT=true;\n\t\t\t\t\t\t}else if(100*(t_yoko_max_suc/T_h)>=6){\n\t\t\t\t\t\t\tlMyokoT=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\t\tif((yokoP==true||lByokoP==true||lMyokoP==true)&&\n\t\t\t\t\t\t(yokoT==false&&lByokoT==false&&lMyokoT==false)){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ptnP==true&&ptnT==false){\n\t\t\t\t\t\tptnFLG=false;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ptnFLG){\n\t\t\t\tif(yokoP==true){\n\n\t\t\t\t\tif(yokoT==true&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint yoko_top=0,yoko_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w;\n\n\t\t\t\t\t\twhile(yoko_top<=top_limit){\n\t\t\t\t\t\t\tfor(search_row=yoko_top;search_row<=yoko_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-yoko_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(search_row>yoko_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",yoko_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tyoko_top++;\n\t\t\t\t\t\t\tyoko_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tint horizon_top=0,horizon_bottom=P_h-1;\n\t\t\t\t\t\tint top_limit=T_h-P_h,search_row,out_W_lmt=T_w-P_w,broken_row;\n\n\n\t\t\t\t\t\twhile(horizon_top<=top_limit){\n\t\t\t\t\t\t\tt_brokenH.init_index();\n\t\t\t\t\t\t\tfor(search_row=horizon_top;search_row<=horizon_bottom;search_row++){\n\t\t\t\t\t\t\t\tif(P[search_row-horizon_top][0]!=T[search_row][0])break;\n\t\t\t\t\t\t\t\twhile((broken_row=t_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\tif(broken_row/1000==search_row){\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(search_row>horizon_bottom){\n\t\t\t\t\t\t\t\tfor(int out_col=0;out_col<=out_W_lmt;out_col++){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",horizon_top,out_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thorizon_top++;\n\t\t\t\t\t\t\thorizon_bottom++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(lByokoP == true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point == -1){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(lMyokoP==true){\n\t\t\t\t\tif(yokoT==true){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else if((lByokoT==true||lMyokoT==true)&&p_yoko_max_suc<=t_yoko_max_suc){\n\t\t\t\t\t\tbool matchFLG;\n\t\t\t\t\t\tint broken_point,comp_count;\n\t\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\t\tp_brokenH.init_index();\n\t\t\t\t\t\t\t\t\tcomp_count=0;\n\t\t\t\t\t\t\t\t\twhile((broken_point=p_brokenH.next_loc())!=-1&&comp_count<100){\n\t\t\t\t\t\t\t\t\t\tif(T[row+(broken_point/1000)][col+(broken_point%1000)]!=P[broken_point/1000][broken_point%1000]){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcomp_count++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(broken_point==-1||comp_count==100){\n\n\t\t\t\t\t\t\t\t\t\tbool leftMatchFLG=true;\n\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][0]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\t\t\tleftMatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(leftMatchFLG){\n\t\t\t\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(ptnP){\n\t\t\t\t\tbool matchFLG;\n\t\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col]!=P[tmp_row][0]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//omit\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p00){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_h==1&&P_w==1){\n\t\tchar ch= P[0][0];\n\t\tfor(int i=0;i<T_h;i++){\n\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\tif(T[i][k]==ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(t_multFLG){\n\t\t\tif(max_char==p00&&((tc_max)/(T_h*T_w-tc_max)>=10000)&&(t_max_char==P[0][0])){\n\n\t\t\t\tLoc tLoc;\n\t\t\t\tfor(int row=0;row<T_h;row++){\n\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\tif(T[row][col]!=t_max_char){\n\t\t\t\t\t\t\ttLoc.reg_loc(1000*row+col);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint** possibilityTable=new int*[T_h];\n\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\tpossibilityTable[i]=new int[T_w];\n\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\tpossibilityTable[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttLoc.init_index();\n\t\t\t\tint del_loc=tLoc.next_loc();\n\t\t\t\tint del_left,del_right,del_top,del_floor,center_row,center_col;\n\n\t\t\t\twhile(del_loc!=-1){\n\t\t\t\t\tcenter_row=del_loc/1000;\n\t\t\t\t\tcenter_col=del_loc%1000;\n\n\t\t\t\t\tif(0<center_col-(P_w-1)){\n\t\t\t\t\t\tdel_left=center_col-(P_w-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_left=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_right=center_col;\n\t\t\t\t\tif(0<center_row-(P_h-1)){\n\t\t\t\t\t\tdel_top=center_row-(P_h-1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdel_top=0;\n\t\t\t\t\t}\n\t\t\t\t\tdel_floor=center_row;\n\t\t\t\t\tfor(int i=del_top;i<=del_floor;i++){\n\t\t\t\t\t\tfor(int k=del_left;k<=del_right;k++){\n\t\t\t\t\t\t\tpossibilityTable[i][k]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel_loc=tLoc.next_loc();\n\t\t\t\t}\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(possibilityTable[row][col]==0)printf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(((T_h-P_h)*(T_w-P_w)*(P_h*P_w)<500000000)||(tc_max/(T_h*T_w-tc_max)<=1000)){\n\n\t\t\t\tchar p_ch=P[0][0];\n\t\t\t\tbool matchFLG;\n\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tif(T[row][col]==p_ch){\n\t\t\t\t\t\t\tmatchFLG=true;\n\t\t\t\t\t\t\tfor(int tmp_row=0;tmp_row<P_h;tmp_row++){\n\t\t\t\t\t\t\t\tfor(int tmp_col=0;tmp_col<P_w;tmp_col++){\n\t\t\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col]!=P[tmp_row][tmp_col]){\n\t\t\t\t\t\t\t\t\t\tmatchFLG=false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!matchFLG)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\tint S=0,historyS;\n\t\t\t\t\tint top,bottom,left,right;\n\t\t\t\t\tint** calcTable=new int*[T_h];\n\n\t\t\t\t\tfor(int i=0;i<T_h;i++){\n\t\t\t\t\t\tcalcTable[i]=new int[T_w];\n\t\t\t\t\t\tfor(int k=0;k<T_w;k++){\n\t\t\t\t\t\t\tif(T[i][k]!=P[0][0]){\n\t\t\t\t\t\t\t\tcalcTable[i][k]=1;\n\t\t\t\t\t\t\t\tif(i<P_h&&k<P_w){\n\t\t\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalcTable[i][k]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(S==0)printf(\"0 0\\n\");\n\t\t\t\t\thistoryS=S;\n\n\t\t\t\t\ttop=0,left=1,right=P_w,bottom=P_h-1;\n\t\t\t\t\twhile(top<=H_lmt){\n\t\t\t\t\t\twhile(right<T_w){\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS-=calcTable[row][left-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int row=top;row<=bottom;row++){\n\t\t\t\t\t\t\t\tS+=calcTable[row][right+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top,left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(bottom<H_lmt){\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS-=calcTable[top][col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int col=0;col<T_w;col++){\n\t\t\t\t\t\t\t\thistoryS+=calcTable[bottom+1][col];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(historyS==0){\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\",top+1,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tbottom++;\n\t\t\t\t\t\tleft=1,right=P_w,S=historyS;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tif(T[0][0]==P[0][0]){\n\t\t\t\tfor(int row=0;row<=H_lmt;row++){\n\t\t\t\t\tfor(int col=0;col<=W_lmt;col++){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] != -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ??????????????????????????????????????????????????????????????¶??????acc?????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n\n  \n  int td[pil][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<pil;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n\n#define P1 (63533)\n#define P2 (100007)\n\n#define MAX (1010)\nchar str[MAX][MAX];\nchar pat[MAX][MAX];\null str_hash[MAX][MAX];\null tmp[MAX][MAX];\nint sh, sw, ph, pw;\n\nvoid rolling_hash(int height, int width, char character[MAX][MAX])\n{\n\n    ull pow = 1;\n    ull hash;\n    \n    for (int i=0; i < pw; i++){\n        pow *= P1;\n    }\n    \n    for (int i=0; i < height; i++) {\n        hash = 0;\n        for (int j = 0; j < pw; j++){\n            hash = hash * P1 + character[i][j];\n        }\n        \n        for (int j = 0; j + pw <= width; j++) {\n            tmp[i][j] = hash;\n            if (j + pw < width) {\n                hash = hash * P1 + character[i][j + pw] - pow * character[i][j];\n            }\n        }\n    }\n    \n    pow = 1;\n    for (int i=0; i < ph; i++){\n         pow *= P2;\n    }\n    \n    for (int j=0; j + pw <= width; j++) {\n        \n        hash = 0;\n        for (int i = 0; i < ph; i++){\n            hash = hash * P2 + tmp[i][j];\n        }\n        \n        for (int i = 0; i + ph <= height; i++) {\n            str_hash[i][j] = hash;\n            if(i + ph < height){\n                hash = hash * P2 + tmp[i + ph][j] - pow * tmp[i][j];\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    ull pat_hash;\n    char c;\n    \n    cin >> sh >> sw;\n    for(int i = 0; i < sh; i++){\n        for (int j = 0; j < sw; j++) {\n            cin >> c;\n            str[i][j] = c;\n        }\n    }\n    \n    cin >> ph >> pw;\n    for(int i = 0; i < ph; i++){\n        for (int j = 0; j < pw; j++) {\n            cin >> c;\n            pat[i][j] = c;\n        }\n    }\n    \n    rolling_hash(ph, pw, pat);\n    pat_hash = str_hash[0][0];\n    rolling_hash(sh, sw, str);\n    \n    for(int i = 0; i <= sh; i++){\n        for (int j = 0; j <= sw; j++) {\n            if (pat_hash == str_hash[i][j]) {\n                cout << i << \" \" << j <<endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1125899906842624LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W; char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '0') { x[i][j] = 0; }\n\t\t\tif (c == '1') { x[i][j] = 1; }\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '0') { y[i][j] = 0; }\n\t\t\tif (c == '1') { y[i][j] = 1; }\n\t\t\tsum *= 2; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 2; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 50) {\n\t\t\t\tlong long c1 = MOD - ((1LL << (M - 1))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 2;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tT[i] = s;\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tP[i] = s;\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\tif (T[i][j] == P[0][0]){\n\t\t\t\tif (T[i].substr(j, C) == P[0]){\n\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\tif (k == R - 1) cout << i << \" \" << j << endl;\n\t\t\t\t\t\tif (T[i + k].substr(j, C) == P[k]) continue;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 47;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(vector<string> &T, vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  int current_power = 1;\n  ull hash_pmminus1 = PRIME;\n  for (; current_power < m - 1; current_power <<= 1)\n    hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n  for (; current_power < m - 1; ++current_power)\n    hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n  ull hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash =\n          (segment_hash - (hash_pmminus1 * ValueOf(T[i][j - 1]) % MODULUS)) %\n          MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash =\n          (text_hash - ((hash_ppowermtimes[n - 1]) * H[i - 1][j] % MODULUS)) %\n          MODULUS;                                 // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS; // shift up\n      text_hash += H[i + n - 1][j];                // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tlong j = T[i].find(P[0], 0);\n\t\tif (j != -1){\n\t\t\twhile (j < W - C + 1 && j != -1){\n\t\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\telse {\n\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\tif (T[i + k].find(P[k], j) != j){ // ayashi\n\t\t\t\t\t\t\t// cout << \"miss: find: \" << T[i + k].find(P[k], j) << \" \" << j << endl;\n\t\t\t\t\t\t\t// cout << \"miss: i = \" << i << \", j = \" << j << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj = T[i].find(P[0], j + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int H, W, r, c, f1[1000][1000], f2[1000][1000];\n    char ch;\n\n    cin >> H >> W;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> ch;\n            f1[i][j] = ch - '0';\n        }\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        for(int j = 0; j < c; j++) {\n            cin >> ch;\n            f2[i][j] = ch - '0';\n        }\n    }\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            bool success = true;\n            for (int k = 0; k < r; k++) {\n                for (int l = 0; l < c; l++) {\n                    if (f1[i + k][j + l] != f2[k][l]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    break;\n                }\n            }\n            if (success == true) {\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct RollingHash2D{\n  typedef unsigned long long ull;\n  \n  struct RollingHash{\n    typedef unsigned long long ull;\n    string S;\n    ull B;\n    int len;\n    vector<ull> hash,p;\n    RollingHash(){}\n    RollingHash(string S_,ull B_=1000000007LL):\n      S(S_),B(B_),len(S.length()),hash(len+1),p(len+1){\n      hash[0]=0;p[0]=1;\n      for(int i=0;i<len;i++){\n\thash[i+1]=hash[i]*B+S[i];\n\tp[i+1]=p[i]*B;\n      }\n    }\n    //S[l,r)\n    ull find(int l,int r){\n      return hash[r]-hash[l]*p[r-l];\n    }\n  };\n  \n  vector<string> S;\n  int h,w,r,c;\n  ull B;\n  vector<ull> p;\n  vector<vector<ull> > hash;\n  vector<RollingHash> rh;\n  RollingHash2D(){}\n  RollingHash2D(vector<string> S_,int r_,int c_,ull B_=1000000009LL):\n    S(S_),h(S_.size()),w(S_[0].size()),r(r_),c(c_),B(B_),\n    p(h+1),hash(h+1,vector<ull>(w-c+1,0)),rh(h){\n    for(int i=0;i<h;i++) rh[i]=RollingHash(S[i]);\n    p[0]=1;\n    for(int i=0;i<h;i++) p[i+1]=p[i]*B;\n    for(int j=0;j<w-c+1;j++){\n      hash[0][j]=0;\t\t    \n      for(int i=0;i<h;i++)\n\thash[i+1][j]=hash[i][j]*B+rh[i].find(j,j+c);\n    }\n  }\n  //[i,i+r) * [j,j+c)\n  ull find(int i,int j){\n    return hash[i+r][j]-hash[i][j]*p[r];\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(int i=0;i<h;i++) cin>>s[i];\n  int r,c;\n  cin>>r>>c;\n  vector<string> t(r);\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash2D srh(s,r,c);\n  RollingHash2D trh(t,r,c);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      if(srh.find(i,j)==trh.find(0,0)) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}\n\n/*\nverified on 2017/10/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_C\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint main(){\n\tlong H, W, R, C;\n\tstring T[1000], P[1000];\n\tcin >> H >> W;\n\tfor (long i = 0; i < H; i++){\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tif (H < R || W < C) return 0;\n\tfor (long i = 0; i < R; i++){\n\t\tcin >> P[i];\n\t}\n\tfor (long i = 0; i < H - R + 1; i++){\n\t\tfor (long j = 0; j < W - C + 1; j++){\n\t\t\t// if (T[i][j] == P[0][0]){\n\t\t\t// \tif (T[i].substr(j, C) == P[0]){\n\t\t\tlong l = T[i].find(P[0], 0);\n\t\t\tif (l != -1){\n\t\t\t\t\tif (R == 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (long k = 1; k < R; k++){\n\t\t\t\t\t\t\tif (T[i + k].substr(j, C) != P[k]) break;\n\t\t\t\t\t\t\tif (k == R - 1) printf(\"%ld %ld\\n\", i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T, *P;\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n    P = new string [R];\n    for(i = 0; i < R; i++){ cin >> P[i]; }\n\n    long long hash[1000][1000];\n    long long s;\n\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * A + P[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(i = 0; i < R; i++){\n        s = 0;\n        for(j = 0; j < C; j++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * A + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n    nodes[N].parent = cur;\n    nodes[N].ch = ch;\n    nodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int link(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] >= 0){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n    \ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n    \n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n      \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n      \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] != -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ??????????????????????????????????????????????????????????????¶??????acc?????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 950527\n#define base2 1777771\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair <int,int> P;\nll A[1001][1001];\nchar a[1001][1001],b[1001][1001];\n\nint main(){\n  int W,H,w,h;\n  cin>>H>>W;\n  for(int i=0;i<H;i++)scanf(\"%s\",a[i]);\n  cin>>h>>w;\n  for(int i=0;i<h;i++)scanf(\"%s\",b[i]);\n\n  ll target=0;\n  for(int i=0;i<h;i++){\n    ll key=0;\n    for(int j=0;j<w;j++){\n      key=key*base+b[i][j];\n    }\n    target=target*base2+key;\n  }\n  \n  for(int i=0;i<H;i++){\n    ll k=0,l=1;\n    for(int j=0;j<W;j++){\n      k=k*base+a[i][j];\n      if(j-w>=0) k-= l*a[i][j-w];\n      else l*=base;\n      A[i][j]=k;\n    }\n  }\n\n  vector <P> ans;\n  for(int j=w-1;j<W;j++){\n    ll k=0,l=1;\n    for(int i=0;i<H;i++){\n      k=k*base2+A[i][j];\n      if(i-h>=0) k-=l*A[i-h][j];\n      else l*=base2;\n      if(target==k) ans.push_back(P(i-h+1,j-w+1)); \n    }\n  }\n\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<(int)ans.size();i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\nbool Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareRight(int idxi, int idxj)\n{\n\tint j = C - 1;\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CompareBottom(int idxi, int idxj)\n{\n\tint i = R - 1;\n\tfor (int j = C - 1; j >= 0; j--) {\n\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool CheckPP() {\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 1; j < C; j++) {\n\t\t\tif (P[i][j] != P[0][0]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//search and output\n\tif (CheckPP) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tbool flag_ok = false;\n\t\tbool flag_r = true;\n\t\twhile (i + R <= H) {\n\t\t\tbool ret;\n\t\t\tif (flag_ok) {\n\t\t\t\tif (flag_r) {\n\t\t\t\t\tret = CompareRight(i, j);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = CompareBottom(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret = Compare(i, j);\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tflag_ok = true;\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tflag_ok = false;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t\tflag_r = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag_r = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i + R <= H) {\n\t\t\tif (Compare(i, j)) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tj++;\n\t\t\t\tif (j + C > W) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_C\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n\tint H, W, R, C;\n\tvector<string> T, P;\n\tstring str;\n\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++){\n\t\tcin>>str;\n\t\tT.push_back(str);\n\t}\n\n\tcin>>R>>C;\n\tfor(int i=0;i<R;i++){\n\t\tcin>>str;\n\t\tP.push_back(str);\n\t}\n\n\tif((H>=R) && (W>=C))\n\t\tfor(int i=0;i<=H-R;i++)\n\t\t\tfor(int j=0;j<=W-C;j++)\n\t\t\t\tif(T[i].substr(j, P[0].length()) == P[0])\n\t\t\t\t\tfor(int k=i+1;k<R;k++)\n\t\t\t\t\t\tif(T[k].substr(j, P[k-i].length()) == P[k-i])\n\t\t\t\t\t\t\tif(k == R-1)\n\t\t\t\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)2 - (T)123456;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832;\nconstexpr long double Golden = 1.61803398874989484820;\n\n#define iostream_untie true\n#define stdout_precision 10\n#define stderr_precision 10\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int_fast64_t i = 0; i < (int_fast64_t)(n); ++i)\n#define rrep(i,n) for(int_fast64_t i = (int_fast64_t)(n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(stdout_precision);\n            std::cerr << std::fixed << std::setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"stderr.txt\",\"wt\",stderr)) {\n                freopen(\"CON\",\"wt\",stderr);\n                std::cerr << \"Failed to open the stderr file\\n\";\n            }\n            if(!freopen(\"stdout.txt\",\"wt\",stdout)) {\n                freopen(\"CON\",\"wt\",stdout);\n                std::cerr << \"Failed to open the stdout file\\n\";\n            }\n            if(!freopen(\"stdin.txt\",\"rt\",stdin)) {\n                freopen(\"CON\",\"rt\",stdin);\n                std::cerr << \"Failed to open the stdin file.\\n\";\n            }\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct hashval_calc {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hashval_calc<tuple_t, index - 1>::apply(seed, t);\n            hash_combine(seed,get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct hashval_calc<tuple_t, 0> {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hash_combine(seed,get<0>(t));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& t) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,t);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; }   return s; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; }   return s;\n}\ntemplate <class tuple_t, size_t index>\nstruct tupleos {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        tupleos<tuple_t,index - 1>::apply(s,t);\n        return s << \" \" << get<index>(t);\n    }\n}; \ntemplate <class tuple_t>\nstruct tupleos<tuple_t, 0> {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        return s << get<0>(t);\n    }\n};\ntemplate <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t) {\n    return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n}\ntemplate <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n#ifdef LOCAL\n    #define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \", dump_func(__VA_ARGS__)\n#else\n    #define dump(...) \n#endif\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\ntemplate <class P> void read(P __first, P __second) {\n    for(P i = __first; i != __second; ++i) cin >> *i;\n}\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n};\nusing updater::add;\nusing updater::mul;\nusing updater::chmax;\nusing updater::chmin;\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\nint_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const function<bool(int_fast64_t)> &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\nvoid for_subset(int_fast64_t s, const function<void(int_fast64_t)> &fn) {\n    int_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\n\ntemplate <int32_t mod>\nstruct modint {\n    int x;\n    constexpr modint() : x(0) {}\n    constexpr modint(int_fast64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    constexpr modint &operator+=(const modint &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    constexpr modint &operator++() { return ++x,*this; }\n\n    constexpr modint operator++(int) {\n        modint t = *this;\n        return ++x,t;\n    }\n\n    constexpr modint &operator-=(const modint &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    constexpr modint &operator--() { return --x, *this; }\n\n    constexpr modint operator--(int) {\n        modint t = *this;\n        return --x,t;\n    }\n\n    constexpr modint &operator*=(const modint &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    constexpr modint &operator/=(const modint &p) {\n        *this *= inverse(p);\n        return *this;\n    }\n\n    constexpr modint operator-() const { return modint(-x); }\n\n    constexpr modint operator+(const modint &p) const { return modint(*this) += p; }\n\n    constexpr modint operator-(const modint &p) const { return modint(*this) -= p; }\n\n    constexpr modint operator*(const modint &p) const { return modint(*this) *= p; }\n\n    constexpr modint operator/(const modint &p) const { return modint(*this) /= p; }\n\n    constexpr bool operator==(const modint &p) const { return x == p.x; }\n\n    constexpr bool operator!=(const modint &p) const { return x != p.x; }\n\n    constexpr bool operator!() const { return !x; }\n\n    // constexpr bool operator>(const modint &p) const { return x > p.x; }\n\n    // constexpr bool operator<(const modint &p) const { return x <  p.x; }\n\n    // constexpr bool operator>=(const modint &p) const { return x >= p.x; }\n\n    // constexpr bool operator<=(const modint &p) const { return x <= p.x; }\n\n    constexpr static modint inverse(const modint &p) {\n        int a = p.x, b = mod, u = 1, v = 0;\n        while(b > 0) {\n            int t = a / b;\n            a -= t * b;\n            a ^= b ^= a ^= b;\n            u -= t * v;\n            u ^= v ^= u ^= v;\n        }\n        return modint(u);\n    }\n\n    constexpr static modint pow(modint p, int_fast64_t e) {\n        if(!e) return 1;\n        if(e < 0) e = (e % (mod - 1) + mod - 1) % (mod - 1);\n        return pow(p * p, e >> 1) * (e & 1 ? p : 1);\n    }\n\n    friend ostream &operator<<(ostream &s, const modint &p) { return s << p.x; }\n\n    friend istream &operator>>(istream &s, modint &p) {\n        uint_fast64_t x;\n        p = modint((s >> x,x));\n        return s;\n    }\n};\n\nusing mint=modint<1'000'000'007>;\nint h,w,r,c;\nstring s[1010];\nstring t[1010];\nconst mint base=36;\nmint baspow[1000100];\nmint ibaspow[1000100];\nmint chas[1010][1010];\n\nint ctoi(char c) {\n    int x=c-'0';\n    return (x<10 && x>=0) ? x : (c-'a'+10);\n}\n\nvoid solve() {\n    mint thash=0;\n    for(int i=0; i<c; ++i) {\n        thash*=baspow[r];\n        mint now=0;\n        for(int j=0; j<r; ++j) {\n            now+=baspow[j]*ctoi(t[j][i]);\n        }\n        thash+=now;\n    }\n\n    if(w<c || h<r) {\n        return;\n    }\n    \n    for(int i=0; i<w; ++i) {\n        for(int j=0; j<h; ++j) {\n            chas[i][j+1]=chas[i][j]+baspow[j]*ctoi(s[j][i]);\n        }\n    }\n\n    for(int j=0; j+r<=h; ++j) {\n        mint nhas=0;\n        vector<mint> cols(w);\n        for(int i=0; i<w; ++i) {\n            mint trow=(chas[i][j+r]-chas[i][j])*ibaspow[j];\n            if(i<c) nhas=nhas*baspow[r]+trow;\n            cols[i]=trow;\n        }\n        for(int i=0; i+c<=w; ++i) {\n            if(nhas==thash) {\n                cout<<j<<\" \"<<i<<\"\\n\";\n            }\n            // dump(j,i,nhas,thash);\n            if(i+c<w) {\n                nhas=nhas*baspow[r]+cols[i+c];\n                nhas-=cols[i]*baspow[r*c];\n            }\n        }\n    }\n\n}\n\nsigned main() {\n    baspow[0]=1;\n    for(int i=0; i<1000000; ++i) {\n        baspow[i+1]=baspow[i]*base;\n    }\n    ibaspow[0]=1;\n    ibaspow[1]=mint::inverse(base);\n    for(int i=0; i<1000000; ++i) {\n        ibaspow[i+1]=ibaspow[i]*ibaspow[1];\n    }\n\n    cin>>h>>w;\n    for(int i=0; i<h; ++i) cin>>s[i];\n    cin>>r>>c;\n    for(int i=0; i<r; ++i) cin>>t[i];\n\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2D string matching\n * Approach: 2D fingerprinting\n */\n\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing ull = unsigned long long;\nconstexpr ull MODULUS = 1e9 + 9;\nconstexpr ull PRIME = 47;\n\nint ValueOf(char ch) {\n  if ('0' <= ch && ch <= '9')\n    return ch - '0';\n  return 10 + ch - 'a';\n}\n\nvoid Match(const vector<string> &T, const vector<string> &P) {\n  int N = T.size(), M = T[0].size(), n = P.size(), m = P[0].size();\n  // Precompute:\n  // 1. h(P) -- treating rectangular ranges as 1D vectors in row-major order\n  // 2. h(p^{km}) for k=1,...,n-1\n  // 2a. h(p^{m-1})\n  // 3. h(T[i][j..(j+m-1)]) for i=0,...,n-1, j=0,...,M-m\n\n  ull pattern_hash = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      pattern_hash =\n          (((pattern_hash * PRIME) % MODULUS) + ValueOf(P[i][j])) % MODULUS;\n\n  int current_power = 1;\n\n  ull hash_pmminus1, hash_pm;\n  if (m == 1) {\n    hash_pmminus1 = 1;\n    hash_pm = PRIME;\n  } else {\n    hash_pmminus1 = PRIME;\n    for (; current_power < m - 1; current_power <<= 1)\n      hash_pmminus1 = (hash_pmminus1 * hash_pmminus1) % MODULUS;\n    for (; current_power < m - 1; ++current_power)\n      hash_pmminus1 = (hash_pmminus1 * PRIME) % MODULUS;\n    hash_pm = (hash_pmminus1 * PRIME) % MODULUS;\n  }\n\n  vector<ull> hash_ppowermtimes(n); // ith element stores h(p^{mi})\n  hash_ppowermtimes[0] = 1;\n  hash_ppowermtimes[1] = hash_pm;\n  for (int i = 2; i < n; ++i) {\n    // h(p^{mi}) = h(p^m)h(p^{m(i-1)})\n    hash_ppowermtimes[i] = (hash_pm * hash_ppowermtimes[i - 1]) % MODULUS;\n  }\n\n  vector<vector<ull>> H(N, vector<ull>(M));\n  for (int i = 0; i < N; ++i) {\n    ull segment_hash = 0;\n    for (int j = 0; j < m; ++j)\n      segment_hash =\n          (((segment_hash * PRIME) % MODULUS) + ValueOf(T[i][j])) % MODULUS;\n    H[i][0] = segment_hash;\n    for (int j = 1; j <= M - m; ++j) {\n      segment_hash =\n          (segment_hash - (hash_pmminus1 * ValueOf(T[i][j - 1]) % MODULUS)) %\n          MODULUS; // remove earliest element\n      segment_hash = (segment_hash * PRIME) % MODULUS; // shift left\n      segment_hash =\n          (segment_hash + ValueOf(T[i][j + m - 1])) % MODULUS; // append\n      H[i][j] = segment_hash;\n    }\n  }\n\n  // Traverse and report\n  vector<pair<int, int>> matches;\n  for (int j = 0; j <= M - m; ++j) {\n    ull text_hash = 0;\n    for (int i = 0; i < n; ++i)\n      text_hash = (((text_hash * hash_pm) % MODULUS) + H[i][j]) % MODULUS;\n    if (text_hash == pattern_hash)\n      matches.emplace_back(0, j);\n    for (int i = 1; i <= N - n; ++i) {\n      text_hash =\n          (text_hash - ((hash_ppowermtimes[n - 1]) * H[i - 1][j] % MODULUS)) %\n          MODULUS;                                 // remove top row\n      text_hash = (text_hash * hash_pm) % MODULUS; // shift up\n      text_hash += H[i + n - 1][j];                // append\n      if (text_hash == pattern_hash)\n        matches.emplace_back(i, j);\n    }\n  }\n  sort(begin(matches), end(matches));\n  for (auto &p : matches)\n    cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> T, P;\n  string cur;\n  while (n--) {\n    cin >> cur;\n    T.push_back(cur);\n  }\n  cin >> n >> m;\n  while (n--) {\n    cin >> cur;\n    P.push_back(cur);\n  }\n  Match(T, P);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint H,W,R,C;\nchar f[1000][1000],p[1000][1000];\nvoid solve(int i, int j){\n\tint same = 1;\n\t//printf(\"now checking i: %d and j: %d\\n\",i,j);\n\tfor(int k=0;k<R;k++){\n\t\tfor(int l=0;l<C;l++){\n\t\t\t//printf(\"now checking k: %d and l: %d\\n\",k,l);\n\t\t\tif(f[i+k][j+l] != p[k][l]){\n\t\t\t\tsame = -1;\n\t\t\t\t//printf(\"didn't match\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif(same == 1) printf(\"%d %d\\n\",i,j);\n}\n\nint main(){\n\tscanf(\"%d %d\",&W,&H);\n\tfor(int i=0;i<W;i++){\n\t\tscanf(\"%s\",&f[i]);\n\t}\n\t/*for(int i=0;i<W;i++){\n\t\tprintf(\"%s\\n\",f[i]);\n\t}*/\n\tscanf(\"%d %d\",&R,&C);\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%s\",&p[i]);\n\t}\n\t/*for(int i=0;i<R;i++){\n\t\tprintf(\"%s\\n\",p[i]);\n\t}*/\n\tfor(int i=0;i<=W-R;i++){\n\t\tfor(int j=0;j<=H-C;j++){\n\t\t\tsolve(i,j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nclass string_hash{\nprivate:\n    typedef long long int ll;\n    typedef unsigned long long int ull;\n    typedef unsigned long ul;\n    typedef vector<ull> Hash;\n    \n    const ull mod;\n    const ull roll;\n    Hash H;\n    string W;\n    \n    ull mod_pow(ull a,ull x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a; a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ull R(ull a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_hash(){\n        H[0]=W[0];\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+W[i];\n            H[i]%=mod;\n        }\n    }\n    \npublic:\n    string_hash(const string &W={},ull mod=1000000007,ull roll=65537):W(W),mod(mod),roll(roll),H(W.size()){\n        mk_hash();\n    }\n    \n    void push_back(const string &A){\n        ull d=H.size();\n        H.resize(d+A.size());\n        W.resize(d+A.size());\n        for(ull i=d;i<H.size();i++){\n            W[i]=A[i-d];\n            H[i]=W[i];\n            if(i!=0){\n                H[i]+=H[i-1]*roll%mod;\n            }\n            H[i]%=mod;\n        }\n    }\n    \n    void push_back(char c){\n        W.push_back(c);\n        H.push_back(c);\n        if(H.size()==1){return;}\n        H[H.size()-1]+=H[H.size()-2]*roll%mod;\n        H[H.size()-1]%=mod;\n    }\n    \n    unsigned long size() const {return W.size();}\n    \n    const ull & MOD() const {return mod;}\n    \n    const ull & ROLL() const {return roll;}\n    \n    ull & operator [] (const ul &s){\n        assert(s<H.size());\n        return H[s];\n    }\n    \n    bool operator == (string_hash &S) const {\n        return S.size()==H.size() && H[H.size()-1]==S[H.size()-1];\n    }\n    \n    //共通の長さ、初めて違う文字のインデックス\n    unsigned long same(string_hash &W) const {\n        ul r=min(H.size(),W.size())-1;\n        if(H[r]==W[r]){return r+1;}\n        ul l=0;\n        while(r-l>3){\n            ul m=l+(r-l)/2;\n            if(W[m]!=H[m]){r=m;}\n            else{l=m+1;}\n        }\n        for(ul i=l;i<r;i++){\n            if(W[i]!=H[i]){return i;}\n        }\n        return r;\n    }\n    \n    //[l,r)\n    ull hash(ul l,ul r){\n        assert(l<r && r<=H.size());\n        if(l==0){return H[r-1];}\n        return (mod+H[r-1]-H[l-1]*mod_pow(roll,r-l)%mod)%mod;\n    }\n    \n    ull merge_hash(ull hash,ul Long){\n        return (H[H.size()-1]*mod_pow(roll,Long)%mod+hash)%mod;\n    }\n};\n\n\n\ntemplate<typename T>\nclass vector_hash{\nprivate:\n    typedef long long int ll;\n    typedef unsigned long long int ull;\n    typedef unsigned long ul;\n    typedef vector<ull> Hash;\n    \n    const ull mod;\n    const ull roll;\n    Hash H;\n    vector<T> W;\n    \n    ull mod_pow(ull a,ull x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a; a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ull R(ull a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_hash(){\n        H[0]=W[0]%mod;\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+W[i]%mod;\n            H[i]%=mod;\n        }\n    }\n    \npublic:\n    vector_hash(const vector<T> &W={},ull mod=1000000007,ull roll=65537):W(W),mod(mod),roll(roll),H(W.size()){\n        mk_hash();\n    }\n    \n    void push_back(const vector<T> &A){\n        ull d=H.size();\n        H.resize(d+A.size());\n        W.resize(d+A.size());\n        for(ull i=d;i<H.size();i++){\n            W[i]=A[i-d];\n            H[i]=W[i]%mod;\n            if(i!=0){\n                H[i]+=H[i-1]*roll%mod;\n            }\n            H[i]%=mod;\n        }\n    }\n    \n    void push_back(T c){\n        W.push_back(c);\n        H.push_back(c)%mod;\n        if(H.size()==1){return;}\n        H[H.size()-1]+=H[H.size()-2]*roll%mod;\n        H[H.size()-1]%=mod;\n    }\n    \n    unsigned long size() const {return W.size();}\n    \n    const ull & MOD() const {return mod;}\n    \n    const ull & ROLL() const {return roll;}\n    \n    T & operator [] (const ul &s){\n        assert(s<H.size());\n        return H[s];\n    }\n    \n    bool operator == (vector_hash &S) const {\n        return S.size()==H.size() && H[H.size()-1]==S[H.size()-1];\n    }\n    \n    //共通の長さ、初めて違う文字のインデックス\n    unsigned long same(vector_hash &W) const {\n        ul r=min(H.size(),W.size())-1;\n        if(H[r]==W[r]){return r+1;}\n        ul l=0;\n        while(r-l>3){\n            ul m=l+(r-l)/2;\n            if(W[m]!=H[m]){r=m;}\n            else{l=m+1;}\n        }\n        for(ul i=l;i<r;i++){\n            if(W[i]!=H[i]){return i;}\n        }\n        return r;\n    }\n    \n    //[l,r)\n    ull hash(ul l,ul r){\n        assert(l<r && r<=H.size());\n        if(l==0){return H[r-1];}\n        return (mod+H[r-1]-H[l-1]*mod_pow(roll,r-l)%mod)%mod;\n    }\n    \n    ull merge_hash(ull hash,ul Long){\n        return (H[H.size()-1]*mod_pow(roll,Long)%mod+hash)%mod;\n    }\n};\n\nclass Find{\nprivate:\n    set<pll> Q;\n    \npublic:\n    Find(ll h,ll w,ll r,ll c,ull mod1,ull mod2,vector<string> &S,vector<string> &P,ull Y,ull X){\n        vector<ull> F(r);\n        for(int i=0;i<r;i++){\n            string_hash S(P[i],mod1,X);\n            F[i]=S[S.size()-1];\n        }\n        vector_hash<ull> A(F,mod2,Y);\n        ull k=A[A.size()-1];\n        vector<vector<ull>> dp(w,vector<ull>(h,0));\n        for(int i=0;i<S.size();i++){\n            string_hash a(S[i],mod1,X);\n            for(ll t=c-1;t<w;t++){\n                dp[t][i]=a.hash(t-c+1,t+1);\n            }\n        }\n        for(int i=0;i<w;i++){\n            vector_hash<ull> a(dp[i],mod2,Y);\n            for(ll t=r-1;t<h;t++){\n                dp[i][t]=a.hash(t-r+1,t+1);\n            }\n        }\n        for(ll i=r-1;i<h;i++){\n            for(ll t=c-1;t<w;t++){\n                if(dp[t][i]==k){\n                    Q.insert({i,t});\n                    //{i-r+1,t-c+1}\n                }\n            }\n        }\n    }\n    \n    bool is(ll a,ll b){\n        return Q.find({a,b})!=Q.end();\n    }\n};\n\n\nint main(){\n    random_device rand;\n    mt19937 mt(rand());\n    uniform_int_distribution<int> R(100,MOD-1);\n    ll h,w;\n    cin>>h>>w;\n    vector<string> S(h);\n    for(int i=0;i<h;i++){\n        cin>>S[i];\n    }\n    ll r,c;\n    cin>>r>>c;\n    vector<ull> F(r);\n    vector<string> Q(r);\n    for(int i=0;i<r;i++){\n        cin>>Q[i];\n    }\n    Find A(h,w,r,c,1001832439,1001821259,S,Q,R(mt),R(mt)),B(h,w,r,c,1001628343,1001703679,S,Q,R(mt),R(mt)),C(h,w,r,c,MOD,1002075103,S,Q,R(mt),R(mt));\n    for(ll i=r-1;i<h;i++){\n        for(ll t=c-1;t<w;t++){\n            if(A.is(i,t) && B.is(i,t) && C.is(i,t)){\n                cout<<i-r+1<<\" \"<<t-c+1<<endl;\n            }\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\n#define M1 131\n#define M2 1999\nusing namespace std;\ntypedef unsigned long long ull;\nint h1,w1,h2,w2;\nstring a[N],b[N];\null x=1,y=1,X[N][N],Y[N][N],C[N],D=0;\n\nint main(){\n  cin>>h1>>w1;\n  for(int i=0;i<h1;i++)cin>>a[i];\n  cin>>h2>>w2;\n  for(int i=0;i<h2;i++)cin>>b[i];\n  \n  for(int i=0;i<w2;i++)x*=M1;\n  for(int i=0;i<h2;i++)y*=M2;\n  \n  for(int i=0;i<h2;i++)\n    for(int j=0;j<w2;j++)\n      C[i]=C[i]*M1+b[i][j];\n  \n  for(int i=0;i<h2;i++)D=D*M2+C[i];\n  \n  for(int i=0;i<h1;i++){\n    X[i][0]=a[i][0];\n    for(int j=1;j<w2;j++)X[i][j]=X[i][j-1]*M1+a[i][j];\n    for(int j=w2;j<w1;j++)\n      X[i][j]=X[i][j-1]*M1-x*a[i][j-w2]+a[i][j];\n  }\n  \n  for(int j=w2-1;j<w1;j++){\n    Y[0][j]=X[0][j];\n    for(int i=1;i<h2;i++)Y[i][j]=Y[i-1][j]*M2+X[i][j];\n    for(int i=h2;i<h1;i++){\n      Y[i][j]=Y[i-1][j]*M2-y*X[i-h2][j]+X[i][j];\n    }\n  }\n  for(int i=0;i<h1;i++){\n    for(int j=0;j<w1;j++){\n      if(Y[i][j]==D){\n\tprintf(\"%d %d\\n\",i-h2+1  , j-w2+1);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <sstream>\n\nusing namespace std;\n\nint main (void)\n{\n\tint n,m,r,c;\n\tstring a[100],b[100];\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tcin >> r >> c;\n\n\tfor (int j = 0; j < r; j++)\n\t{\n\t\tcin >> b[j];\n\t}\n\n\tfor (int i = 0; i < n - r + 1; i++)\n\t{\n\t\tfor (int k = 0; k < m - c + 1; k++)\n\t\t{\n\t\t\tif (a[i].substr(k,c) == b[0])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < r; j++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i + j].substr(k,c) != b[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (j == r - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << i << \" \" << k << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n  \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  //for(int i=0;i<h;i++)cin >> s[i];\n  char ch;\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&ch);\n      s[i][j]=ch;\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  //for(int i=0;i<r;i++)cin >> t[i];\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&ch);\n      t[i][j]=ch;\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node{\n\tint data;\n\tNode* prev;\n\tNode* next;\n};\n\nclass List{\npublic:\n\tList(){\n\t\tmotherNode = new Node();\n\t\tmotherNode->data = -1;\n\t\tmotherNode->prev = motherNode;\t//?????°?§?????????????\n\t\tmotherNode->next = motherNode;\n\t};\n\n\t//??????????????????????????\\???????????±?????°??????????´¢???????????????\n\tvoid insertFromFirst(int x){\n\t\tNode* tmpNode = motherNode->next;\n\t\twhile(tmpNode != motherNode && tmpNode->data < x){\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\n\t\tif(tmpNode == motherNode){\t//??????????????\\????????´???\n\t\t\tNode* tmpNode = motherNode->next;\n\t\t\tmotherNode->next = new Node();\n\t\t\tmotherNode->next->data = x;\n\t\t\tmotherNode->next->prev = motherNode;\n\t\t\tmotherNode->next->next = tmpNode;\n\t\t\ttmpNode->prev = motherNode->next;\n\t\t}else{\n\t\t\twhile(tmpNode != motherNode && tmpNode->data < x){\n\t\t\t\ttmpNode = tmpNode->next;\n\t\t\t}\n\t\t\tNode* prevNode = tmpNode->prev;\n\t\t\ttmpNode->prev = new Node();\n\t\t\ttmpNode->prev->data = x;\n\t\t\ttmpNode->prev->next = tmpNode;\n\t\t\ttmpNode->prev->prev = prevNode;\n\t\t\tprevNode->next = tmpNode->prev;\n\t\t}\n\t};\n\tvoid insertFromLast(int x){\t//???????????§??°????????§????°??????????\n\t\tNode* tmpNode = motherNode->prev;\n\t\tif(tmpNode == motherNode){\t//???????????????????????????????????´???\n\t\t\tmotherNode->next = new Node();\n\t\t\tmotherNode->next->data = x;\n\t\t\tmotherNode->next->next = motherNode;\n\t\t\tmotherNode->next->prev = motherNode;\n\t\t\tmotherNode->prev = motherNode->next;\n\t\t}else{\t//??¢?????????????????????????????????????????¨????????´???\n\t\t\twhile(tmpNode != motherNode && tmpNode->data > x){\n\t\t\t\ttmpNode = tmpNode->prev;\n\t\t\t}\n\t\t\tNode* nextNode = tmpNode->next;\n\t\t\ttmpNode->next = new Node();\n\t\t\ttmpNode->next->data = x;\n\t\t\ttmpNode->next->next = nextNode;\n\t\t\ttmpNode->next->prev = tmpNode;\n\t\t\tnextNode->prev = tmpNode->next;\n\t\t}\n\t}\n\n\tvoid showList(){\n\t\tNode* tmpNode = motherNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tprintf(\"%d %d\\n\",tmpNode->data/1000,tmpNode->data%1000);\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t}\n\nprivate:\n\tNode* motherNode;\n};\n\nclass RangeTable{\n\npublic:\n\tRangeTable(int T_height,int T_width,int P_height,int P_width){\n\t\t//ranges = new Range[166500];\n\t\t//range_index = 0;\n\t\tthis->T_height = T_height;\n\t\tthis->T_width = T_width;\n\t\tthis->P_height = P_height;\n\t\tthis->P_width = P_width;\n\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\tcheck_table = new char*[T_height];\t//??????????????????????????????????????¨?????????????????§???????????????????????¨\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tcheck_table[i] = new char[T_width];\n\n\t\t\t//???????????´??????????????§???????????´????????????n???????????????\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(i <= row_limit && k <= col_limit){\n\t\t\t\t\tcheck_table[i][k] = 'o';\n\t\t\t\t}else{\n\t\t\t\t\tcheck_table[i][k] = 'x';\t//???????????´??????????????§???????????´?????????x???????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//????????????\n\tvoid registerRange(int left_up,int right_down){\n\t\tint row_start = left_up/1000;\t//??????????§???´???\n\t\tint row_end = right_down/1000;\t//????????????\n\t\tint col_start = left_up%1000;\t//??????????§?\n\t\tint col_end = right_down%1000;\t//????????????\n\t\t//?????????????????????????¨????<<??????????????£????????????>>??¬???????????????[??¬?????????????????¨??????]?????????????????????????´¢??????????????????????????????????????????????????????????????????????????¨???????????¨??????????????????????????????\n\t\t//??????????????????????????????????????????????????????????£?????????????????????´??????????????????????????????????¨??????°???????????¨????????????????????¬????????????????????????????????£?????????????????¨??????????????????????????????\n\t\t//???????????????????????¢??????????????§????????¬?????????????????§??????????????£????????????\n\t\tfor(int i = row_start; i < row_end; i++){\n\t\t\tfor(int k = col_start; k < col_end; k++){\n\t\t\t\tcheck_table[i][k] = 'r';\t//registerd\n\t\t\t}\n\t\t}\n\t}\n\n\tint nextSearchLoc(int row,int col){\n\t\t//????????¨??????????????????????????¨??????????????¬???????????????????????????????????????????????¬??????????§??????¨????????????????????????\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\n\t\tfor(int tmp_col = col;tmp_col <= col_limit; tmp_col++){\t//????????????????????§??¢???\n\t\t\tif(check_table[row][tmp_col] == 'o'){\n\t\t\t\treturn 1000*row + tmp_col;\n\t\t\t}\n\t\t}\n\t\tfor(int tmp_row = row+1; row <=row_limit; row++){\t//?¬?????????\\???\n\t\t\tfor(int tmp_col = 0; tmp_col <= col_limit; tmp_col++){\n\t\t\t\tif(check_table[tmp_row][tmp_col] == 'o'){\n\t\t\t\t\treturn 1000*tmp_row + tmp_col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\t//??¨?????????range????????£?????´???\n\t}\n\nprivate:\n\tchar** check_table;\n\t//Range* ranges;\n\tint T_height,T_width,P_height,P_width;\n};\n\n\nint main(){\n\n\tint T_height,T_width,P_height,P_width;\n\n\tscanf(\"%d %d\",&T_height,&T_width);\n\n\tchar T[T_height][T_width+1];\n\n\tfor(int i = 0; i < T_height; i++){\n\t\tscanf(\"%s\",T[i]);\n\t}\n\n\n\tscanf(\"%d %d\",&P_height,&P_width);\n\n\tif(T_height < P_height || T_width < P_width) return 0;\t//T??????????????????????????????????°????????????°????´¢??????\n\n\tchar P[P_height][P_width+1];\n\n\tfor(int i = 0; i < P_height; i++){\n\t\tscanf(\"%s\",P[i]);\n\t}\n\n\t//P????????????????¨??????????????????\\??????????????§?????????P???????????°?????°??????\n\tint P_total_char_count[128] = {0},P_each_char_count[P_height][128];\n\tfor(int i = 0; i < P_height;i++){\n\t\tfor(int k = 0; k < 128; k++) P_each_char_count[i][k] = 0;\n\n\t}\n\n\tfor(int row = 0; row < P_height; row++){\n\t\tfor(int col = 0; col < P_width; col++){\n\t\t\tP_total_char_count[P[row][col]]++;\t//??¨??????????????°????¨????\n\t\t\tP_each_char_count[row][P[row][col]]++;\t//????????¨???????????°????¨????\n\t\t}\n\t}\n\n\tint c_count = 0;\n\tbool multFLG = false;\n\tfor(int i = 48; i <= 122; i++){\n\t\tif(P_total_char_count[i] > 0){\n\t\t\tc_count++;\n\t\t}\n\t\tif(c_count == 2) break;\n\t}\n\tif(c_count == 2) multFLG = true;\n\n\n\tif((multFLG == true) || (P_height*P_width != 1 && (P_height*P_width*100 > T_height*T_width))){\t//?????????????????????????¨????????????°????????????????????°1??§?????????????????¢????????§?????????????????´???\n\n\t\tchar start_char = P[0][0];\n\n\t\tbool matchFLG;\n\t\tint row_limit = T_height-P_height,col_limit = T_width-P_width;\n\t\t//T???????????????????????°???????????¨????????°??????????????????????´¢???\n\t\tfor(int row = 0; row <= row_limit; row++){\n\t\t\tfor(int col = 0; col <= col_limit; col++){\n\t\t\t\tif(T[row][col] == start_char){\t//????????¨???????????????????????????????????§?????°?????????\n\t\t\t\t\tmatchFLG = true;\n\t\t\t\t\tfor(int tmp_row = 0; tmp_row < P_height; tmp_row++){ //??????tmp_row,tmp_col?????????\n\t\t\t\t\t\tfor(int tmp_col = 0; tmp_col < P_width; tmp_col++){\n\t\t\t\t\t\t\tif(T[row+tmp_row][col+tmp_col] != P[tmp_row][tmp_col]){ //???????????????????????¨??????????????????????????´?????£?????´???\n\t\t\t\t\t\t\t\tmatchFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!matchFLG) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(matchFLG){\n\t\t\t\t\t\tprintf(\"%d %d\\n\",row,col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else if(P_height == 1 && P_width == 1){ //1???????????´???\n\t\tchar ch = P[0][0];\n\t\tfor(int i = 0; i < T_height; i++){\n\t\t\tfor(int k = 0; k < T_width; k++){\n\t\t\t\tif(T[i][k] == ch){\n\t\t\t\t\tprintf(\"%d %d\\n\",i,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\t//???????¨???????????????°???????????´???\n\n\t\tchar ch = P[0][0];\t//??¢?????????\n\t\tint location;\n\n\t\tRangeTable rangeTable(T_height,T_width,P_height,P_width);\n\t\tList list;\n\n\t\tlocation = rangeTable.nextSearchLoc(0,0);\n\n\t\tint start_row,start_col,tmp_row,tmp_col,range_height,range_width,min_width = 0,min_height = 0;\n\t\tint calc_start_row,calc_start_col,calc_tmp_row,calc_tmp_col,calc_min_width = 0,calc_min_height = 0;\n\t\tif(P_height > P_width){\t//???????????´???\n\t\t\twhile(location != -1){\n\t\t\t\tstart_row = location/1000,start_col = location%1000;\n\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\tfor(tmp_row = start_row;tmp_row < T_height;tmp_row++){\n\t\t\t\t\tfor(tmp_col = start_col;tmp_col < T_width;tmp_col++){\n\t\t\t\t\t\tif(T[tmp_row][tmp_col] != ch){\n\t\t\t\t\t\t\tif((tmp_col-1) - start_col >= P_width){\t//????????????????????????????????????????????????<tmp_col-1>:?????´??????????????????\n\t\t\t\t\t\t\t\tmin_width = std::min(min_width,(tmp_col-1) - start_col);\t//????????????????????\\?????§???????????????range?????§???????°??????????<??¨???????????????????????????>????±???????\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp_col-1) - start_col < P_width) break;\t//???????´¢???????????§?????´????????¨???<(tmp_row-1)-start_row>????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t}\n\t\t\t\tif((tmp_row-1)-start_row >= P_height){\t//range????????????????????§???list????????? <<?????¶????????????????????????????????????????????\\?????§????????¨???????????¨>>\n\n\t\t\t\t\t//?????¨???????????????????????????????????????\n\t\t\t\t\trange_height = (tmp_row-1)-start_row;\t//range?????????\n\t\t\t\t\trange_width = min_width;\t//range??????\n\t\t\t\t\trangeTable.registerRange(location,1000*(start_row+range_height)+(start_col+range_width)); //??¬???????????????????????¬???????????????\n\n\t\t\t\t\tint calc_row_limit = start_row+range_height,calc_col_limit = start_col+range_width;\t//??¬??????????????????\n\t\t\t\t\tint secure_row_limit = calc_row_limit-P_height,secure_col_limit = calc_col_limit-P_width;\t//????????????????????????????????????????????\\???????¨??????????????????????????????¨???\n\t\t\t\t\tint danger_row_start = secure_row_limit+1,danger_col_start = secure_col_limit+1;\t//??¨??????????£???????????????????range???????????????????????§???????????¨???\n\t\t\t\t\tint danger_row_end = calc_row_limit-1,danger_col_end=calc_col_limit-1;\t//??±??????????????¨??????????????????????????????????????\\???range??¨??????????????????????????????????????§?????§????????????\n\n\t\t\t\t\tfor(int calc_row = start_row;calc_row <= calc_row_limit;calc_row++){\n\t\t\t\t\t\tfor(int calc_col = start_col;calc_col <= calc_col_limit;calc_col++){\n\t\t\t\t\t\t\tif(calc_row <= secure_row_limit && calc_col <= secure_col_limit){\t//?????¨???\n\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_row+calc_col);\n\t\t\t\t\t\t\t}else if(calc_row >= danger_row_start && calc_row <= danger_row_end && calc_col >= danger_col_start && calc_col <= danger_col_end){\t//??±?????????\n\t\t\t\t\t\t\t\t//?????????????§?????????????range??????????????????list?????????\n\t\t\t\t\t\t\t\tcalc_start_row = calc_row,calc_start_col = calc_col;\n\t\t\t\t\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\t\t\t\t\tfor(calc_tmp_row = calc_start_row;calc_tmp_row < T_height;calc_tmp_row++){\n\t\t\t\t\t\t\t\t\tfor(calc_tmp_col = calc_start_col;calc_tmp_col < T_width;calc_tmp_col++){\n\t\t\t\t\t\t\t\t\t\tif(T[calc_tmp_row][calc_tmp_col] != ch){\n\t\t\t\t\t\t\t\t\t\t\tif((calc_tmp_col-1) - calc_start_col >= P_width){\t//????????????????????????????????????????????????<tmp_col-1>:?????´??????????????????\n\t\t\t\t\t\t\t\t\t\t\t\tcalc_min_width = std::min(calc_min_width,(calc_tmp_col-1) - calc_start_col);\t//????????????????????\\?????§???????????????range?????§???????°??????????<??¨???????????????????????????>????±???????\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif((calc_tmp_col-1) -calc_start_col < P_width) break;\t//???????´¢???????????§?????´????????¨???????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((calc_tmp_row-1)-calc_start_row >= P_height){\t//??¨??????????£???????????????????range????????????????????§???list?????????\n\t\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_start_row+calc_start_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocation = rangeTable.nextSearchLoc(location/1000,location%1000);\t//?¬????range???????§?????????¨???????????????????§????\n\t\t\t}\n\t\t}else{\t//??£?????¢?????????????¨?????????´???\n\t\t\twhile(location != -1){\n\t\t\t\tstart_row = location/1000,start_col = location%1000;\n\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\tfor(tmp_col = start_col;tmp_col < T_width;tmp_col++){\n\t\t\t\t\tfor(tmp_row = start_row;tmp_row < T_height;tmp_row++){\n\t\t\t\t\t\tif(T[tmp_row][tmp_col] != ch){\n\t\t\t\t\t\t\tif((tmp_row-1) - start_row >= P_height){\t//???????????????????????????????????????????????????\n\t\t\t\t\t\t\t\tmin_height = std::min(min_height,(tmp_row-1) - start_row);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp_row-1) - start_row < P_height) break;\n\t\t\t\t}\n\t\t\t\tif((tmp_col-1)-start_col >= P_width){\t//range????????????\n\t\t\t\t\t//rangeTable.registerRange(1000*start_row+start_col,1000*last_row+(tmp_col-1));\n\t\t\t\t\t//?????¨???????????????????????????????????????\n\t\t\t\t\trange_width = (tmp_col-1)-start_col;\t//range??????\n\t\t\t\t\trange_height = min_height;\t//range??????\n\t\t\t\t\trangeTable.registerRange(location,1000*(start_row+range_height)+(start_col+range_width));\n\n\t\t\t\t\tint calc_row_limit = start_row+range_height,calc_col_limit = start_col+range_width;\t//??¬??????????????????\n\t\t\t\t\tint secure_row_limit = calc_row_limit-P_height,secure_col_limit = calc_col_limit-P_width;\t//????????????????????????????????????????????\\???????¨??????????????????????????????¨???\n\t\t\t\t\tint danger_row_start = secure_row_limit+1,danger_col_start = secure_col_limit+1;\t//??¨??????????£???????????????????range???????????????????????§???????????¨???\n\t\t\t\t\tint danger_row_end = calc_row_limit-1,danger_col_end=calc_col_limit-1;\t//??±??????????????¨??????????????????????????????????????\\???range??¨??????????????????????????????????????§?????§????????????\n\n\t\t\t\t\tfor(int calc_col = start_col;calc_col <= calc_col_limit;calc_col++){\n\t\t\t\t\t\tfor(int calc_row = start_row;calc_row <= calc_row_limit;calc_row++){\n\t\t\t\t\t\t\tif(calc_col <= secure_col_limit && calc_row <= secure_row_limit){\t//?????¨???\n\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_row+calc_col);\n\t\t\t\t\t\t\t}else if(calc_col >= danger_col_start && calc_col <= danger_col_end && calc_row >= danger_row_start && calc_row <= danger_row_end){\t//??±?????????\n\t\t\t\t\t\t\t\t//?????????????§?????????????range??????????????????list?????????\n\t\t\t\t\t\t\t\tcalc_start_col = calc_col,calc_start_row = calc_row;\n\t\t\t\t\t\t\t\t//?????????????????????????????±?????¨???????????????\n\t\t\t\t\t\t\t\tfor(calc_tmp_col = calc_start_col;calc_tmp_col < T_width;calc_tmp_col++){\n\t\t\t\t\t\t\t\t\tfor(calc_tmp_row = calc_start_row;calc_tmp_row < T_height;calc_tmp_row++){\n\t\t\t\t\t\t\t\t\t\tif(T[calc_tmp_row][calc_tmp_col] != ch){\n\t\t\t\t\t\t\t\t\t\t\tif((calc_tmp_row-1) - calc_start_row >= P_height){\n\t\t\t\t\t\t\t\t\t\t\t\tcalc_min_height = std::min(calc_min_height,(calc_tmp_row-1) - calc_start_row);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif((calc_tmp_row-1) -calc_start_row < P_height) break;\t//???????????§?????´????????¨???????????????????????????????????????range????´¢???????????£????????§break\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((calc_tmp_col-1)-calc_start_col >= P_width){\t//??¨??????????£???????????????????range????????????????????§???list?????????\n\t\t\t\t\t\t\t\t\tlist.insertFromLast(1000*calc_start_row+calc_start_col);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocation = rangeTable.nextSearchLoc(location/1000,location%1000);\t//?¬????range???????§?????????¨???????????????????§????\n\t\t\t}\n\t\t}\n\n\t\tlist.showList();\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n \n \nusing namespace std;\n \nstruct AhoCorasick {\n \n  static const int ALPHABET_SIZE = 62, root=0;\n \n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n   \n  int N; // num of node\n \n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n \n  vector<Node> nodes;\n \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n \n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n    nodes[N].parent = cur;\n    nodes[N].ch = ch;\n    nodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n \n  int link(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n \n  int trans(int id, char ch) {\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n \n  for(int i=0;i<pl;i++)aho.addString(pattern[i]);\n   \n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n \n  const int til = T[0].size();\n   \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n \nint main(void){\n  int h,w,r,c;\n   \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101  // large prime number 1.\n#define B 1466700101  // large prime number 2.\n#define M 1522101101  // large prime number 3, larger than A and B.\n\nint main()\n{\n    int i, j, H, W, R, C;\n    string *T;\n\n    scanf(\"%d %d\", &H, &W);\n    T = new string [H];\n    for(i = 0; i < H; i++){ cin >> T[i]; }\n    scanf(\"%d %d\", &R, &C);\n\n    long long hash[100][100];\n    long long s;\n\n    char P[1000];\n    for(i = 0; i < R; i++){\n        s = 0;\n        scanf(\"%s\", P);\n        for(j = 0; j < C; j++){\n            s = (s * A + P[j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < C; j++){\n        s = 0;\n        for(i = 0; i < R; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    long long last_has = hash[R - 1][C - 1];\n\n    for(i = 0; i < H; i++){\n        s = 0;\n        for(j = 0; j < W; j++){\n            s = (s * A + T[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n    for(j = 0; j < W; j++){\n        s = 0;\n        for(i = 0; i < H; i++){\n            s = (s * B + hash[i][j]) % M;\n            hash[i][j] = s;\n        }\n    }\n\n    long long power_a, power_b, power_c, x, y, z;\n    x = A, y = R, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_a = z;\n    x = B, y = C, z = 1;\n    for( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n    power_b = z;\n    power_c = (power_a * power_b) % M;\n\n    long long block1, block2, block3;\n    for(i = R - 1; i < H; i++){\n        for(j = C - 1; j < W; j++){\n            block1 = ((i >= R ? hash[i - R][j] : 0) * power_a) % M;\n            block2 = ((j >= C ? hash[i][j - C] : 0) * power_b) % M;\n            block3 = M - ((((i >= R && j >= C) ? hash[i - R][j - C] : 0) * power_c) % M);\n            if(hash[i][j] == (block1 + block2 + block3 + last_has) % M){\n            printf(\"%d %d\\n\", i - R + 1, j - C + 1);\n            }\n        }\n    }\n\tdelete [] T;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n        }\n    }\n\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                return;\n            }\n\n            // 先頭文字を比較\n            if( ary_HW[hPos][wPos] == ary_RC[0][0] )\n            {\n                // 文字パターンの検索を実施する\n                patternMatching(hPos, wPos);\n            }\n        }\n    }\n\n    st_Pos pos;\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の行が1行見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int max_size=1010;\nchar pattern[max_size][max_size];\nchar target[max_size][max_size];\n\null hash[max_size][max_size],tmp[max_size][max_size];\n\nvoid calc(char a[max_size][max_size],int n,int m,int r,int c){\n\tconst ull br=1000000007;\n\tconst ull bc=1000000009;\n\n\tull tc=1;\n\trep(i,c) tc*=bc;\n\n\trep(i,n){\n\t\tull e=0;\n\t\trep(j,c) e=e*bc+a[i][j];\n\t\trep(j,m){\n\t\t\ttmp[i][j]=e;\n\t\t\tif(j+c>=m) break;\n\t\t\te=e*bc-tc*a[i][j]+a[i][j+c];\n\t\t}\n\t}\n\n\tull tr=1;\n\trep(j,r) tr*=br;\n\n\trep(j,m-c+1){\n\t\tull e=0;\n\t\trep(i,r) e=e*br+tmp[i][j];\n\t\trep(i,n){\n\t\t\thash[i][j]=e;\n\t\t\tif(i+r>=n) break;\n\t\t\te=e*br-tr*tmp[i][j]+tmp[i+r][j];\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint h,w;\n\tcin >> h >> w;\n\trep(i,h)rep(j,w) cin >> target[i][j];\n\tint r,c;\n\tcin >> r >> c;\n\trep(i,r)rep(j,c) cin >> pattern[i][j];\n\tcalc(pattern,r,c,r,c);\n\tull pattern_hash=hash[0][0];\n\tcalc(target,h,w,r,c);\n\tfor(int i=0;i+r<=h;++i)\n\t\tfor(int j=0;j+c<=w;++j)\n\t\t\tif(pattern_hash==hash[i][j])\n\t\t\t\tcout << i << \" \" << j << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n     \n     \nusing namespace std;\n     \nstruct AhoCorasick {\n     \n  static const int ALPHABET_SIZE = 62, root=0;\n     \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n       \n  int N; // num of node\n     \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n     \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n     \n  vector<Node> nodes;\n     \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n     \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] == -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n     \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n     \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n     \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ?????????????????????????????¶????????????????????????????????????acc?????\\????????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n  \n  const int til = T[0].size();\n\n  // ???????????????????????????????????????????????????????????????????????????\n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      // ????????????????????????????????¶???????§???????????????°??????????????????T'?????????\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n  \n  // ??????????????????????????´????????????????????????????????????????????£????¨??????????\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<tl;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n     \nint main(void){\n  int h,w,r,c;\n       \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n     \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1355471101\n#define B 1466700101\n#define M 1522101101\n\n\nint main()\n{\n\tint i, j, H, W, R, C;\n\tstring *T, *P;\n\n\tscanf(\"%d %d\", &H, &W);\n\tT = new string [H];\n\tfor(i = 0; i < H; i++){ cin >> T[i]; }\n\tscanf(\"%d %d\", &R, &C);\n\tP = new string [R];\n\tfor(i = 0; i < R; i++){ cin >> P[i]; }\n\n\tlong long has_T[800][800];\n\tlong long has_P[500][500];\n\tlong long s;\n\n\tfor(j = 0; j < W; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\ts = (s * A + T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < H; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < W; j++){\n\t\t\ts = (s * B + has_T[i][j]) % M;\n\t\t\thas_T[i][j] = s;\n\t\t}\n\t}\n\tfor(j = 0; j < C; j++){\n\t\ts = 0;\n\t\tfor(i = 0; i < R; i++){\n\t\t\ts = (s * A + P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\tfor(i = 0; i < R; i++){\n\t\ts = 0;\n\t\tfor(j = 0; j < C; j++){\n\t\t\ts = (s * B + has_P[i][j]) % M;\n\t\t\thas_P[i][j] = s;\n\t\t}\n\t}\n\n\tlong long last_has = has_P[R - 1][C - 1];\n\tlong long power_a, power_b, power_c, x, y, z;\n\tx = A, y = R, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_a = z;\n\tx = B, y = C, z = 1;\n\tfor( ; y; y >>= 1){ if((y & 1) != 0){ z = (z * x) % M; } x = (x * x) % M; }\n\tpower_b = z;\n\tpower_c = (power_a * power_b) % M;\n\n\tlong long block1, block2, block3;\n\tfor(i = R - 1; i < H; i++){\n\t\tfor(j = C - 1; j < W; j++){\n\t\t\tblock1 = ((i >= R ? has_T[i - R][j] : 0) * power_a) % M;\n\t\t\tblock2 = ((j >= C ? has_T[i][j - C] : 0) * power_b) % M;\n\t\t\tblock3 = M - ((((i >= R && j >= C) ? has_T[i - R][j - C] : 0) * power_c) % M);\n\t\t\tif(has_T[i][j] == (block1 + block2 + block3 + last_has) % M){\n\t\t\t\tprintf(\"%d %d\\n\", i - R + 1, j - C + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[0]) {\n                bool success = true;\n                for (int k = 1; k < r; k++) {\n                    if (f1[i + k].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i << \" \" << j << endl;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nint h,w,r,c;\n\null has[1000][1000],tmp[1000][1000];\n\nvoid make_hash(string a[1000],int n,int m){\n\n  ull b1=9973,b2=(ull)1e9+7;\n\n  ull t1=1;\n  REP(i,c) t1*=b1;\n\n  REP(i,n){\n\n    ull e=0;\n    REP(j,c) e=e*b1+a[i][j];\n\n    for(int j=0;j+c<m+1;j++){\n\n      tmp[i][j]=e;\n      if(j+c<m) e=e*b1-t1*a[i][j]+a[i][j+c];\n\n    }\n\n  }\n\n  ull t2=1;\n  REP(i,r) t2*=b2;\n\n  for(int j=0;j+c<m+1;j++){\n\n    ull e=0;\n    REP(i,r) e=e*b2+tmp[i][j];\n\n    for(int i=0;i+r<=n;i++){\n\n      has[i][j]=e;\n      if(i+r<n) e=e*b2-t2*tmp[i][j]+tmp[i+r][j];\n\n    }\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  string s[1000],t[1000];\n\n  cin>>h>>w;\n  REP(i,h) cin>>s[i];\n\n  cin>>r>>c;\n  REP(i,r) cin>>t[i];\n\n  make_hash(t,r,c);\n  ull t_hash=has[0][0];\n\n  make_hash(s,h,w);\n  REP(i,h-r+1) REP(j,w-c+1) if(has[i][j]==t_hash) cout<<i<<\" \"<<j<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = unsigned long long;\n\nclass rolling_hash2 {\n\tstatic const ull b1 = 9973, b2 = 100000007;\n\tconst int h, w;\n\tvector<ull> rh, rw;\n\tvector<vector<ull>> hs;\npublic:\n\ttemplate <class T> rolling_hash2(const vector<vector<T>>& a)\n\t\t: h(a.size()), w(a[0].size()), rh(h + 1), rw(w + 1), hs(h + 1, vector<ull>(w + 1))\n\t{\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\ths[i + 1][j + 1] = hs[i + 1][j] * b2 + a[i][j];\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\ths[i + 1][j + 1] += hs[i][j + 1] * b1;\n\t\t}\n\t\trh[0] = rw[0] = 1;\n\t\tfor (int i = 0; i < h; i++) rh[i + 1] = rh[i] * b1;\n\t\tfor (int i = 0; i < w; i++) rw[i + 1] = rw[i] * b2;\n\t}\n\tull get(int li, int lj, int ri, int rj) {\n\t\tassert(0 <= li && li <= ri && ri <= h);\n\t\tassert(0 <= lj && lj <= rj && rj <= w);\n\t\tull u = hs[ri][rj] - hs[ri][lj] * rw[rj - lj];\n\t\tull d = hs[li][rj] - hs[li][lj] * rw[rj - lj];\n\t\treturn u - d * rh[ri - li];\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<char>> A(H, vector<char>(W));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tint R, C;\n\tcin >> R >> C;\n\tvector<vector<char>> B(R, vector<char>(C));\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> B[i][j];\n\t\t}\n\t}\n\trolling_hash2 rha(A), rhb(B);\n\tull h = rhb.get(0, 0, R, C);\n\tfor (int i = 0; i + R <= H; i++) {\n\t\tfor (int j = 0; j + C <= W; j++) {\n\t\t\tif (rha.get(i, j, i + R, j + C) == h) {\n\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<string>\n\n#define MAX 1000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint H,W,R,C;\nchar field[MAX][MAX]; //????´¢????±?\nchar pattern[MAX][MAX]; //????????????\n\null hashh[MAX][MAX],temp[MAX][MAX];\null target;\n\n//a???R*C?????¨??????hash????¨????\nvoid compute_hash(char a[MAX][MAX], int n, int m){\n\tconst ull B1=9973;\n\tconst ull B2=100000007;\n\t\n\tull t1=1;//B1???C???\n\tfor(int i=0;i<C;i++) t1*=B1;\n\t//????????????hash????¨????\n\tfor(int i=0;i<n;i++){\n\t\tull e=0;\n\t\tfor(int j=0;j<C;j++) e=e*B1+a[i][j];\n\t\tfor(int j=0;C+j<=m;j++){\n\t\t\ttemp[i][j]=e;\n\t\t\te=e*B1-t1*a[i][j]+a[i][j+C];\n\t\t}\n\t}\n\tull t2=1;//B2???R???\n\tfor(int i=0;i<R;i++) t2*=B2;\n\tfor(int j=0;j+C<=m;j++){\n\t\tull e=0;\n\t\tfor(int i=0;i<R;i++) e=e*B2+temp[i][j];\n\t\tfor(int i=0;i+R<=n;i++){\n\t\t\thashh[i][j]=e;\n\t\t\te=e*B2-t2*temp[i][j]+temp[i+R][j];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcompute_hash(pattern,R,C);//pattern???hash???????±???????\n\ttarget=hashh[0][0];\n\tcompute_hash(field,H,W);//field???hash???????±???????\n\t//target??¨?????´??????hash??????search\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(target==hashh[i][j])\n\t\t\tprintf(\"%d %d\\n\",i,j);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tscanf(\"%d %d\",&R,&C);\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%s\",pattern[i]);\n\t}\n\tif(H>=R&&W>=C)\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nchar BAN[1000][1001] = {};\nchar CC[1000][1001] = {};\nint H,W;\nint R,C;\nint T;\n\nvoid makeCC(){\n    cin >> R >> C;\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\",CC[i]);\n    }\n}\n\nvoid rec(int i, int j){\n    if (i + R > H || j + C > W) {\n        return;\n    }\n    for (int r = 0; r < R; r++) {\n        for (int c = 0; c < C; c++) {\n            if (BAN[i+r][j+c] != CC[r][c]) {\n                return;\n            }\n        }\n    }\n    printf(\"%d %d\\n\",i,j);\n}\n\nint main(){\n    cin >> H >> W;\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\",BAN[i]);\n    }\n    \n    makeCC();\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (BAN[i][j] == CC[0][0]) {\n                rec(i,j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\null hash2d(char a[MAX][MAX],int r,int c)\n{\n\tull tmp[r]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmp[i]=tmp[i]*B1+a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<r;i++)\n\t{\n\t\ttmp[0]=tmp[0]*B2+tmp[i];\n\t}\n\treturn tmp[0];\n}\n\nvector<pair<int,int> > match2d(char s[MAX][MAX],char a[MAX][MAX],int h,int w,int r,int c)\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash=hash2d(a,r,c);\n\tvector<pair<int,int> > ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tchar s[MAX][MAX];\n\tchar a[MAX][MAX];\n\tint h,w,r,c;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int> > m=match2d(s,a,h,w,r,c);\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(int i=0;i<m.size();i++)\n\t{\n\t\tcout<<m[i].first<<\" \"<<m[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint h, w, r, c;\nchar t[1000][1001], p[1000][1001];\n\nbool check(int x, int y)\n{\n    for(int i=0; i<r; i++){\n        if(memcmp(t[y+i]+x, p[i], c)) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>h>>w;\n    cin.ignore();\n    for(int i=0; i<h; i++) \n        cin.getline(t[i], 1001);\n    cin>>r>>c;\n    cin.ignore();\n    for(int i=0; i<r; i++) \n        cin.getline(p[i], 1001);\n\n    for(int y=0; y<=h-r; y++) {\n        for(int x=0; x<=w-c; x++) {\n            if(check(x, y)) {\n                cout<<y<<' '<<x<<'\\n';\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nchar BAN[1000][1001] = {};\nchar CC[1000][1001] = {};\nint H,W;\nint R,C;\nint T;\n\nvoid makeCC(){\n    cin >> R >> C;\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\",CC[i]);\n    }\n}\n\nvoid rec(int i, int j){\n    for (int r = 0; r < R; r++) {\n        for (int c = 0; c < C; c++) {\n            if (BAN[i+r][j+c] != CC[r][c]) {\n                return;\n            }\n        }\n    }\n    printf(\"%d %d\\n\",i,j);\n}\n\nint main(){\n    cin >> H >> W;\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\",BAN[i]);\n    }\n    \n    makeCC();\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (BAN[i][j] == CC[0][0]) {\n                rec(i,j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    int minn = 1001, mini;\n    for (int i = 0; i < r; i++) {\n        int count[62] = { 0 }, maxn = 0;\n        for (int j = 0; j < c; j++) {\n            if ('0' <= f2[i][j] && f2[i][j] <= '9') {\n                count[f2[i][j] - '0']++;\n            }\n            if ('A' <= f2[i][j] && f2[i][j] <= 'Z') {\n                count[f2[i][j] - 55]++;\n            }\n            if ('a' <= f2[i][j] && f2[i][j] <= 'z') {\n                count[f2[i][j] - 61]++;\n            }\n        }\n        for (int j = 0; j < 62; j++) {\n            maxn = max(maxn, count[j]);\n        }\n        if (minn > maxn) {\n            minn = maxn;\n            mini = i;\n        }\n    }\n    \n    for (int i = mini; i <= h - r + mini; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            if (f1[i].substr(j, c) == f2[mini]) {\n                bool success = true;\n                for (int k = mini - 1; k >= 0; k--) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == false) {\n                    continue;\n                }\n                for (int k = mini + 1; k < r; k++) {\n                    if (f1[i + k - mini].substr(j, c) != f2[k]) {\n                        success = false;\n                        break;\n                    }\n                }\n                if (success == true) {\n                    cout << i - mini << \" \" << j << \"\\n\";\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar Big[1005][1005];\nchar Small[1005][1005];\nint H, W, R, C;\n\nbool search_ok(int r, int c) {\n\tbool flag = true;\n\tfor (int i = 0; flag && i < R; i++) {\n\t\tfor (int j = 0; flag && j < C; j++) {\n\t\t\tif (Big[r + i][c + j] != Small[i][j]) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(void) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> Big[i][j];\n\t\t}\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tcin >> Small[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= H - R; i++) {\n\t\tfor (int j = 0; j <= W - C; j++) {\n\t\t\tif (search_ok(i, j)) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n     \n     \nusing namespace std;\n     \nstruct AhoCorasick {\n     \n  static const int ALPHABET_SIZE = 62, root=0;\n     \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n       \n  int size;\n     \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n     \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n     \n  vector<Node> nodes;\n     \n  AhoCorasick(int maxNodes):size(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n     \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] == -1){\n\tnodes[size].parent = cur;\n\tnodes[size].ch = ch;\n\tnodes[cur].child[c] = size++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n     \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n  \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n \ntypedef pair<int,int> pii;\n     \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ?????????????????????????????¶????????????????????????????????????acc?????\\????????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n  \n  const int til = T[0].size();\n\n  // ???????????????????????????????????????????????????????????????????????????\n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      // ????????????????????????????????¶???????§???????????????°??????????????????T'?????????\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n  \n  // ??????????????????????????´????????????????????????????????????????????£????¨??????????\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<tl;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n     \nint main(void){\n  int h,w,r,c;\n       \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n     \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B1=1e8+7;\nconst ull B2=1e9+7;\nconst int MAX=1000;\n\nchar s[MAX][MAX];\nchar a[MAX][MAX];\nint h,w,r,c;\n\nvector<pair<int,int>> match2d()\n{\n\tull t1=1,t2=1;\n\tfor(int i=0;i<c;i++)t1*=B1;\n\tfor(int i=0;i<r;i++)t2*=B2;\n\t\n\tull tmp[MAX][MAX]={};\n\t\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)tmp[i][0]=tmp[i][0]*B1+s[i][j];\n\t\tfor(int j=0;j+c<w;j++)tmp[i][j+1]=tmp[i][j]*B1+s[i][j+c]-s[i][j]*t1;\n\t}\n\t\n\tull shash[MAX][MAX]={};\n\t\n\tfor(int i=0;i+c<=w;i++)\n\t{\n\t\tull e=0;\n\t\tfor(int j=0;j<r;j++)e=e*B2+tmp[j][i];\n\t\tshash[0][i]=e;\n\t\tfor(int j=0;j+r<h;j++)\n\t\t{\n\t\t\te=e*B2+tmp[j+r][i]-tmp[j][i]*t2;\n\t\t\tshash[j+1][i]=e;\n\t\t}\n\t}\n\t\n\tull ahash=0;\n\tull tmpa[MAX]={};\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\ttmpa[i]=tmpa[i]*B1+a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tahash=ahash*B2+tmpa[i];\n\t}\n\t\n\tvector<pair<int,int>> ans;\n\t\n\tfor(int i=0;i+r<=h;i++)\n\t{\n\t\tfor(int j=0;j+c<=w;j++)\n\t\t{\n\t\t\tif(ahash==shash[i][j])ans.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>s[i][j];\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];\n\t\n\tvector<pair<int,int>> m=match2d();\n\t\n\tsort(m.begin(),m.end());\n\t\n\tfor(int i=0;i<m.size();i++)\n\t{\n\t\tcout<<m[i].first<<\" \"<<m[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <random>\n#include <vector>\n#include <cassert>\n\nstruct rolling_hash_2d {\n    using ull = unsigned long long;\n    static constexpr ull MASK30 = (1ULL << 30) - 1;\n    static constexpr ull MASK31 = (1ULL << 31) - 1;\n    static constexpr ull MOD = (1ULL << 61) - 1;\n    static constexpr ull POSITIVIZER = MOD << 2;\n    static std::vector<ull> pow_base_y, pow_base_x;\n    int h, w;\n    std::vector<std::vector<ull>> hash;\n    static void push_pow_y(int h) {\n        while (pow_base_y.size() <= h) { pow_base_y.push_back(calc_mod(mul(pow_base_y.back(), pow_base_y[1]))); }\n    }\n    static void push_pow_x(int w) {\n        while (pow_base_x.size() <= w) { pow_base_x.push_back(calc_mod(mul(pow_base_x.back(), pow_base_x[1]))); }\n    }\n    static ull rng() {\n        std::random_device rd;\n        return std::uniform_int_distribution<ull>(MOD >> 1, MOD - 1)(rd);\n    }\n    static ull mul(ull a, ull b) {\n        ull au = a >> 31;\n        ull ad = a & MASK31;\n        ull bu = b >> 31;\n        ull bd = b & MASK31;\n        ull mid = ad * bu + au * bd;\n        return (au * bu << 1) + (mid >> 30) + ((mid & MASK30) << 31) + ad * bd;\n    }\n    static ull calc_mod(ull val) {\n        val = (val & MOD) + (val >> 61);\n        if (val >= MOD) { val -= MOD; }\n        return val;\n    }\n    static ull connect_y(ull uhs, ull dhs, int dh) {\n        push_pow_y(dh);\n        return calc_mod(mul(uhs, pow_base_y[dh]) + dhs);\n    }\n    static ull connect_x(ull lhs, ull rhs, int rw) {\n        push_pow_x(rw);\n        return calc_mod(mul(lhs, pow_base_x[rw]) + rhs);\n    }\n    template<typename T> rolling_hash_2d(const std::vector<std::vector<T>> &src)\n        : h(src.size()), w(src[0].size()), hash(h + 1, std::vector<ull>(w + 1)) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                hash[i + 1][j + 1] = calc_mod((mul(hash[i][j + 1], pow_base_y[1]) + src[i][j]));\n            }\n        }\n        for (int i = 1; i <= h; i++) {\n            for (int j = 0; j < w; j++) {\n                hash[i][j + 1] = calc_mod((mul(hash[i][j], pow_base_x[1]) + hash[i][j + 1]));\n            }\n        }\n        push_pow_y(h);\n        push_pow_x(w);\n    }\n    ull get_hash(int y0, int x0, int y1, int x1) const {\n        assert(0 <= y0 && y0 < h);\n        assert(0 < y1 && y1 <= h);\n        assert(0 <= x0 && x0 < w);\n        assert(0 < x1 && x1 <= w);\n        ull hl = calc_mod(POSITIVIZER - mul(hash[y0][x0], pow_base_y[y1 - y0]) + hash[y1][x0]);\n        ull hr = calc_mod(POSITIVIZER - mul(hash[y0][x1], pow_base_y[y1 - y0]) + hash[y1][x1]);\n        return calc_mod(POSITIVIZER - mul(hl, pow_base_x[x1 - x0]) + hr);\n    }\n};\nstd::vector<rolling_hash_2d::ull> rolling_hash_2d::pow_base_y{1, rng()};\nstd::vector<rolling_hash_2d::ull> rolling_hash_2d::pow_base_x{1, rng()};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W, R, C;\n    cin >> H >> W;\n    vector<string> F(H);\n    vector<vector<char>> Fv(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        cin >> F[i];\n        copy(F[i].begin(), F[i].end(), Fv[i].begin());\n    }\n    cin >> R >> C;\n    vector<string> P(R);\n    vector<vector<char>> Pv(R, vector<char>(C));\n    for (int i = 0; i < R; i++) {\n        cin >> P[i];\n        copy(P[i].begin(), P[i].end(), Pv[i].begin());\n    }\n    rolling_hash_2d Fh(Fv), Ph(Pv);\n    for (int i = 0; i < H - R + 1; i++) {\n        for (int j = 0; j < W - C + 1; j++) {\n            if (Fh.get_hash(i, j, i + R, j + C) == Ph.get_hash(0, 0, R, C)) {\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<string> A(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> A[i];\n\t}\n\tint R, C; cin >> R >> C;\n\tvector<string> B(R);\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> B[i];\n\t}\n\n\tfor (int i = 0; i <= H - R; i++) {\n\t\tfor (int j = 0; j <= W - C; j++) {\n\t\t\tfor (int k = 0; k < R; k++) {\n\t\t\t\tfor (int l = 0; l < C; l++) {\n\t\t\t\t\tif (A[i + k][j + l] != B[k][l])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (k == R - 1 && l == C - 1)\n\t\t\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\nbool Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//search and output\n\tint i = 0;\n\tint j = 0;\n\tint p_i;\n\tint t;\n\twhile (i + R <= H) {\n\t\tif (Compare(i, j)) {\n\t\t\tcout << i << \" \" << j << endl;\n\t\t\tj++;\n\t\t\tif (j + C > W) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\n\t\t\tj++;\n\t\t\tif (j + C > W) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// パターン検索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n// 最大行数\nconst int MAX_ROW = 1000;\n// 最大列数\nconst int MAX_COLUMN = 1000;\n\n// 検索対象の文字フィールド\nchar ary_HW[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint H, W;\n\n// 検索する文字パターン\nchar ary_RC[MAX_ROW][MAX_COLUMN];\n// 配列のサイズ\nint R, C;\n\n// 行と列の方向の和を保持する配列 ( 配列の要素No.から, 検索パターンの文字数分の和を格納する )\nlong ary_Sum_H[MAX_ROW][MAX_COLUMN];\nlong ary_Sum_W[MAX_ROW][MAX_COLUMN];\n// 配列のサイズは, ary_HW[]より小さくなる\n\n// 行と列の方向の和を保持する配列 ( 検索パターン側 )\nlong ary_Sum_R[MAX_ROW];\nlong ary_Sum_C[MAX_COLUMN];\n\nvoid searchPattern(void);\nvoid patternMatching(int hPos, int wPos);\nvoid p_search(int hPos, int startHW, int rPos, int start, int end);\n\n// メイン関数\nint main(void)\n{\n    // 文字フィールドの入力\n    cin >> H >> W;\n\n    for(int i = 0; i < H; i++)\n    {\n        for(int j = 0; j < W; j++)\n        {\n            cin >> ary_HW[i][j];\n        }\n    }\n\n    // 文字パターンの入力\n    cin >> R >> C;\n\n    for(int i = 0; i < R; i++)\n    {\n        ary_Sum_R[i] = 0;\n\n        for(int j = 0; j < C; j++)\n        {\n            cin >> ary_RC[i][j];\n\n            // 行ごとの和を求める\n            ary_Sum_R[i] += ary_RC[i][j];\n        }\n    }\n\n    for(int j = 0; j < C; j++)\n    {\n        ary_Sum_C[j] = 0;\n\n        for(int i = 0; i < R; i++)\n        {\n            // 列ごとの和を求める\n            ary_Sum_C[j] += ary_RC[i][j];\n        }\n    }\n\n    // ***************\n    // 各行の和を求める\n    // ***************\n    for(int i = 0; i < H; i++)\n    {\n        // 残りの要素が C 以下なら計算不要\n        for(int j = 0; j < W - C + 1; j++)\n        {\n            if( j == 0 )\n            {\n                ary_Sum_H[i][j] = 0;\n\n                for(int k = 0; k < C; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_Sum_H[i][j] += ary_HW[i][k];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, C個先の値を足しておく\n                ary_Sum_H[i][j] = ary_Sum_H[i][j - 1] - ary_HW[i][j - 1] + ary_HW[i][j + C - 1];\n            }\n        }\n    }\n\n    // ***************\n    // 各列の和を求める\n    // ***************\n    for(int j = 0; j < W; j++)\n    {\n        // 残りの要素が R 以下なら計算不要\n        for(int i = 0; i < H - R + 1; i++)\n        {\n            if( i == 0 )\n            {\n                ary_Sum_W[i][j] = 0;\n\n                for(int k = 0; k < R; k++)\n                {\n                    // 一度, 全要素の和を求めておく\n                    ary_Sum_W[i][j] += ary_HW[k][j];\n                }\n            }\n            else\n            {\n                // 求めたい要素の1個前の和から, 1つ前の要素の値を引いて, R個先の値を足しておく\n                ary_Sum_W[i][j] = ary_Sum_W[i - 1][j] - ary_HW[i - 1][j] + ary_HW[i + R - 1][j];\n            }\n        }\n    }\n\n    // パターン検索を実施する\n    searchPattern();\n\n    return 0;\n}\n\n// 左上の座標位置を保持する構造体\ntypedef struct\n{\n    int x;\n    int y;\n}st_Pos;\n\nqueue<st_Pos> Qst;\n\n// パターン検索を実施する関数\nvoid searchPattern(void)\n{\n    st_Pos pos;\n\n    // 検索時の最後尾の要素No.\n    int hEnd, wEnd;\n\n    for(int hPos = 0; hPos < H; hPos++)\n    {\n        for(int wPos = 0; wPos < W; wPos++)\n        {\n            hEnd = hPos + ( R - 1 );\n            wEnd = wPos + ( C - 1 );\n\n            if( hEnd > H - 1 || wEnd > W - 1 )\n            {\n                // 最後尾が配列の範囲をオーバーするので, 検索不要\n                break;\n            }\n\n            // 行と列方向の和を確認\n            if( ary_Sum_H[hPos][wPos] == ary_Sum_R[0]\n                && ary_Sum_W[hPos][wPos] == ary_Sum_C[0] )\n            {\n                bool searchGo = true;\n\n                // 行方向の和を確認\n                for(int i = 1; i < R; i++)\n                {\n                    if( ary_Sum_H[hPos + i][wPos] != ary_Sum_R[i] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == false )\n                {\n                    continue;\n                }\n\n                // 列方向の和を確認\n                for(int j = 1; j < C; j++)\n                {\n                    if( ary_Sum_W[hPos][wPos + j] != ary_Sum_C[j] )\n                    {\n                        // 和が異なれば, 文字パターンが一致することは無い\n                        searchGo = false;\n                        break;\n                    }\n                }\n\n                if( searchGo == true )\n                {\n                    // 文字パターンの検索を実施する\n                    patternMatching(hPos, wPos);\n                }\n            }\n        }\n    }\n\n    // 結果の表示\n    while( !Qst.empty() )\n    {\n        pos = Qst.front();\n        Qst.pop();\n\n        printf(\"%d %d\\n\", pos.x, pos.y);\n    }\n}\n\n// 全ての文字列が一致しているかを表現するフラグ\nbool matchFlag = false;\n\nvoid patternMatching(int hPos, int wPos)\n{\n    st_Pos startPoint;\n\n    // 検索時の最後尾の要素No.\n    int wEnd;\n\n    wEnd = wPos + ( C - 1 );\n\n    // 最後尾の文字が違うので, 検索不要\n    if( ary_HW[hPos][wEnd] != ary_RC[0][C - 1] )\n    {\n        return;\n    }\n\n    int rPos = 0;\n\n    startPoint.x = hPos;\n    startPoint.y = wPos;\n\n    for(int colNum = hPos; colNum < hPos + R; colNum++)\n    {\n        matchFlag = false;\n\n        if( ary_HW[colNum][wPos] == ary_RC[rPos][0]\n            && ary_HW[colNum][wEnd] == ary_RC[rPos][C - 1] )\n        {\n            // 先頭文字と最終文字を比較して, 一致していたら検索を続ける\n            matchFlag = true;\n            p_search(colNum, wPos, rPos, 0, C - 1);\n        }\n\n        if( matchFlag == false )\n        {\n            break;\n        }\n\n        rPos++;\n    }\n\n    if( matchFlag == true )\n    {\n        // 文字列のパターンが一致する箇所が見つかった\n        Qst.push(startPoint);\n    }\n\n    return;\n}\n\n// 再帰的に2分探索を実施する関数\nvoid p_search(int hPos, int startHW, int rPos, int start, int end)\n{\n    int midNo, midHW;\n\n    if( matchFlag == false )\n    {\n        // 不一致の箇所が見つかった時点で, 以降の検索は実施しない\n        return;\n    }\n\n    // 範囲の中点を計算する\n    // 比較する文字列の長さは同じなので, 検索側の文字列を基準にする\n    midNo = ( start + end ) / 2;\n    midHW = startHW + midNo;\n\n    if( start == end )\n    {\n        // 最後まで比較をして, 全ての文字が一致している\n        matchFlag = true;\n        return;\n    }\n    else\n    {\n        if( ary_HW[hPos][midHW] != ary_RC[rPos][midNo] )\n        {\n            // 文字が一致していない\n            matchFlag = false;\n            return;\n        }\n\n        // 前半部分を探索\n        p_search(hPos, startHW, rPos, start, midNo);\n\n        // 後半部分を探索\n        p_search(hPos, startHW, rPos, midNo + 1, end);\n    }\n\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<string> A(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> A[i];\n\t}\n\tint R, C; cin >> R >> C;\n\tvector<string> B(R);\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> B[i];\n\t}\n\n\tfor (int i = 0; i <= H - R; i++) {\n\t\tfor (int j = 0; j <= W - C; j++) {\n\t\t\tfor (int k = 0; k < R; k++) {\n\t\t\t\tfor (int l = 0; l < C; l++) {\n\t\t\t\t\tif (A[i + k][j + l] != B[k][l])\n\t\t\t\t\t\tgoto BREAK2;\n\t\t\t\t\tif (k == R - 1 && l == C - 1) {\n\t\t\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\t\t\t//for (int K = 0; K < R; K++) {\n\t\t\t\t\t\t//\tfor (int L = 0; L < C; L++) {\n\t\t\t\t\t\t//\t\tcout << \" \" << A[i + K][j + L] << \" \" << B[K][L] << endl;\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t//}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tBREAK2:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define floot10 cout<<fixed<<setprecision(10);\n//#define int long long\n\nstruct RollingHash2D{\n  typedef unsigned long long ull;\n \n  struct RollingHash{\n\ttypedef unsigned long long ull;\n\tstring S;\n\tull B;\n\tint len;\n\tvector<ull> hash,p;\n\tRollingHash(){}\n\tRollingHash(string S_,ull B_=1000000007LL):\n  \tS(S_),B(B_),len(S.length()),hash(len+1),p(len+1){\n  \thash[0]=0;p[0]=1;\n  \tfor(int i=0;i<len;i++){\n    \thash[i+1]=hash[i]*B+S[i];\n    \tp[i+1]=p[i]*B;\n  \t}\n\t}\n\t//S[l,r)\n\tull find(int l,int r){\n  \treturn hash[r]-hash[l]*p[r-l];\n\t}\n  };\n \n  vector<string> S;\n  int h,w,r,c;\n  ull B;\n  vector<ull> p;\n  vector<vector<ull> > hash;\n  vector<RollingHash> rh;\n  RollingHash2D(){}\n  RollingHash2D(vector<string> S_,int r_,int c_,ull B_=1000000009LL):\n\tS(S_),h(S_.size()),w(S_[0].size()),r(r_),c(c_),B(B_),\n\tp(h+1),hash(h+1,vector<ull>(w-c+1,0)),rh(h){\n\tfor(int i=0;i<h;i++) rh[i]=RollingHash(S[i]);\n\tp[0]=1;\n\tfor(int i=0;i<h;i++) p[i+1]=p[i]*B;\n\tfor(int j=0;j<w-c+1;j++){\n  \thash[0][j]=0;   \t\t \n  \tfor(int i=0;i<h;i++)\n    \thash[i+1][j]=hash[i][j]*B+rh[i].find(j,j+c);\n\t}\n  }\n  //[i,i+r) * [j,j+c)\n  ull find(int i,int j){\n\treturn hash[i+r][j]-hash[i][j]*p[r];\n  }\n};\n\n\nsigned main(){\n\tint h,w;\n\tcin>>h>>w;\n\tvector<string> s;\n\tlp(i,h){\n\t\tstring sh;\n\t\tcin>>sh;\n\t\ts.push_back(sh);\n\t}\n\tint r,c;\n\tcin>>r>>c;\n\tvector<string> t;\n\tlp(i,r){\n\t\tstring sh;\n\t\tcin>>sh;\n\t\tt.push_back(sh);\n\t}\n\tRollingHash2D srh(s,r,c),trh(t,r,c);\n\tlp(i,h-r+1){\n\t\tlp(j,w-c+1){\n\t\t\tif(srh.find(i,j)==trh.find(0,0)){\n\t\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring a[1000], b[1000];\nint r, c;\n\nstring oneString(string *v, int i, int j){\n        string s;\n        for(int p=i;p<i+r;p++){\n                s += v[p].substr(j, c);\n        }\n        return s;\n}\n\nint main(){\n        int h,w;\n        cin>>h>>w;\n        for(int i=0;i<h;i++) cin>>a[i];\n        cin>>r>>c;\n        for(int i=0;i<r;i++) cin>>b[i];\n\n        string target = oneString(b, 0, 0);\n\n        for(int i=0;i+r-1<h;i++){\n                for(int j=0;j+c-1<w;j++){\n                        if(target == oneString(a, i, j)) cout<<i<<\" \"<<j<<endl;\n                }\n        }\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A = 9999973, B = 950527;\n\nint H, W;\nchar T[1005][1005];\null t[1005][1005];\null t2[1005][1005];\nint h, w;\nchar U[1005][1005];\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for(int i = 0; i < H; i++) scanf(\"%s\", T[i]);\n    scanf(\"%d %d\", &h, &w);\n    for(int i = 0; i < h; i++) scanf(\"%s\", U[i]);\n    \n    ull target = 0;\n    for(int i = 0; i < h; i++) {\n        ull key = 0;\n        for(int j = 0; j < w; j++) {\n            key = key * B + U[i][j];\n        }\n        target = target * A + key;\n    }\n    \n    ull C = 1;\n    for(int i = 0; i < w; i++) C *= B;\n    \n    for(int i = 0; i < H; i++) {\n        ull key = 0;\n        for(int j = 0; j < W; j++) {\n            key = key * B + T[i][j];\n            if(j - w >= 0) key -= T[i][j - w] * C;\n            t[i][j] = key;\n            t2[i][j] = t[i][j];\n        }\n    }\n    \n    C = 1;\n    for(int i = 0; i < h; i++) C *= A;\n    \n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            if(i) t[i][j] += t[i-1][j] * A;\n            if(i - h >= 0) t[i][j] -= t2[i-h][j] * C;\n            if(t[i][j] == target) {\n                if(i - h + 1 >= 0 && j - w + 1 >= 0) {\n                    printf(\"%d %d\\n\", i - h + 1, j - w + 1);\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cassert>\n\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 62, root=0;\n\n  int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n  \n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    //int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    short child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      //int c = ch - '0';\n      int c = index(ch);\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    //int c = ch - '0';\n    int c = index(ch);\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\ntypedef std::vector<std::string> TRect;\n\nTRect ReadRect(std::istream& in, int Row)\n{\n    TRect Rect(Row);\n    for(int i = 0; i < Row; ++i){\n        in >> Rect[i];\n    }\n    return Rect;\n}\nbool IsFit(const TRect& Field, int Row, int Col, const TRect& Pattern)\n{\n    if(Row + Pattern.size() > Field.size()) return false;\n    if(Col + Pattern[0].size() > Field[0].size()) return false;\n    for(int i = 0; i < Pattern.size(); ++i){\n        int R = Row + i;\n        if(Field[R].substr(Col, Pattern[i].size()) != Pattern[i]){\n            return false;\n        }\n    }\n    return true;\n}\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n\n    int FieldRow, FieldCow;\n    std::cin >> FieldRow >> FieldCow;\n    TRect Field = ReadRect(std::cin, FieldRow);\n    \n    int PatternRow, PatternCol;\n    std::cin >> PatternRow >> PatternCol;\n    TRect Pattern = ReadRect(std::cin, PatternRow);\n\n    for(int i = 0; i <= Field.size() - Pattern.size(); ++i){\n        int Pos = Field[i].find(Pattern[0], 0);\n        while(Pos != std::string::npos){\n            if(IsFit(Field, i, Pos, Pattern)){\n                std::cout << i << \" \" << Pos << std::endl;\n            }\n            Pos = Field[i].find(Pattern[0], Pos+1);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int h, w, r, c;\n    string f1[1000], f2[1000];\n    \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> f1[i];\n    }\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) {\n        cin >> f2[i];\n    }\n\n    for (int i = 0; i <= h - r; i++) {\n        for (int j = 0; j <= w - c; j++) {\n            for (int k = 0; k < r; k++) {\n                if (f1[i + k].substr(j, c) != f2[k]) {\n                    break;\n                }\n                if (k == r - 1) {\n                    cout << i << \" \" << j << endl;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<string.h>\n\n#define MAX 1000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint H,W,R,C;\nchar field[MAX][MAX]; \nchar pattern[MAX][MAX]; \n\null hashh[MAX][MAX],temp[MAX][MAX];\null target;\n\n\nvoid compute_hash(char a[MAX][MAX], int n, int m){\n\tconst ull B1=9973;\n\tconst ull B2=100000007;\n\t\n\tull t1=1;\n\tfor(int i=0;i<C;i++) t1*=B1;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tull e=0;\n\t\tfor(int j=0;j<C;j++) e=e*B1+a[i][j];\n\t\tfor(int j=0;C+j<=m;j++){\n\t\t\ttemp[i][j]=e;\n\t\t\te=e*B1-t1*a[i][j]+a[i][j+C];\n\t\t}\n\t}\n\tull t2=1;\n\tfor(int i=0;i<R;i++) t2*=B2;\n\tfor(int j=0;j+C<=m;j++){\n\t\tull e=0;\n\t\tfor(int i=0;i<R;i++) e=e*B2+temp[i][j];\n\t\tfor(int i=0;i+R<=n;i++){\n\t\t\thashh[i][j]=e;\n\t\t\te=e*B2-t2*temp[i][j]+temp[i+R][j];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcompute_hash(pattern,R,C);\n\ttarget=hashh[0][0];\n\tcompute_hash(field,H,W);\n\t\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(target==hashh[i][j])\n\t\t\tprintf(\"%d %d\\n\",i,j);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&H,&W);\n\tcin.ignore();\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%c\",&field[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tscanf(\"%d %d\",&R,&C);\n\tcin.ignore();\n\tfor(int i=0;i<R;i++){\n\t\tfor(int j=0;j<C;j++){\n\t\t\tscanf(\"%c\",&pattern[i][j]);\n\t\t}\n\t\tcin.ignore();\n\t}\n\tif(H>=R&&W>=C)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef unsigned long long ull;\nstruct RollingHash2D{\n  struct RollingHash{\n    string S;\n    ull B;\n    vector<ull> hash,p;\n    int len;\n    RollingHash(){}\n    RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n    void init(){\n      len=S.length();\n      hash.resize(len+1);\n      p.resize(len+1);\n      hash[0]=0;p[0]=1;\n      for(int i=0;i<len;i++){\n\thash[i+1]=hash[i]*B+S[i];\n\tp[i+1]=p[i]*B;\n      }\n    }\n  //S[l,r)\n    ull find(int l,int r){\n      return hash[r]-hash[l]*p[r-l];\n    }\n  };\n  vector<string> S;\n  vector<RollingHash> rh;\n  vector<vector<ull> > hash;\n  vector<ull> p;\n  int h,w,r,c;\n  ull B;\n  RollingHash2D(){}\n  RollingHash2D(vector<string> S,int r,int c,ull B=9973):S(S),r(r),c(c),B(B){init();};\n  void init(){\n    h=S.size();\n    w=S[0].size();\n    hash.resize(h+1,vector<ull>(w-c+1,0));\n    rh.resize(h);\n    for(int i=0;i<h;i++) rh[i]=RollingHash(S[i]);\n    p.resize(h+1);\n    p[0]=1;\n    for(int i=0;i<h;i++) p[i+1]=p[i]*B;\n    for(int j=0;j<w-c+1;j++){\n      hash[0][j]=0;\t\t    \n      for(int i=0;i<h;i++)\n\thash[i+1][j]=hash[i][j]*B+rh[i].find(j,j+c);\n    }\n  }\n  //S[l,r)\n  ull find(int i,int j){\n    return hash[i+r][j]-hash[i][j]*p[r];\n  }\n};\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(int i=0;i<h;i++) cin>>s[i];\n  int r,c;\n  cin>>r>>c;\n  vector<string> t(r);\n  for(int i=0;i<r;i++) cin>>t[i];\n  RollingHash2D srh(s,r,c);\n  RollingHash2D trh(t,r,c);\n  for(int i=0;i<h-r+1;i++){\n    for(int j=0;j<w-c+1;j++){\n      if(srh.find(i,j)==trh.find(0,0)) cout<<i<<\" \"<<j<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 10000000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nlong long modpow[1001];\nint main() {\n\tmodpow[0] = 1;\n\tfor (int i = 1; i <= 1000; i++) {\n\t\tmodpow[i] = modpow[i - 1] * 256;\n\t\tmodpow[i] %= MOD;\n\t}\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tdp[i][j - M + 1] += MOD - modpow[M - 1] * x[i][j - M];\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n// #define SIZE 300005\n// #define MOD 1000000007LL\n// #define INF 1 << 30\n// #define LLINF 1LL << 60\n// #define REP(i,n) for(int i=0;i<n;i++)\n// #define FOR(i,a,b) for(int i=a;i<=b;i++)\n// #define DOWN(i,b,a) for(int i=b;i>=a;i--)\n// #define SET(a,c) memset(a,c,sizeof a)\n// #define BIT(i,j) ((i)>>(j))&1\n// #define ALL(o) (o).begin(), (o).end()\n// #define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n// #define SQ(x) ((x)*(x))\n// using namespace std;\n// typedef long long ll;\n// typedef pair<ll,ll> Pll;\n// typedef pair<int, int> Pii;\n// typedef pair<double, double> Pdd;\n// typedef complex<double> dcomplex;\n// template<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\n// ll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\n// ll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\n// ll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\n#include <bits/stdc++.h>\n#define MOD 1000000007LL\n#define C1  401\n#define C2  397\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nint h,w,r,c;\n\nvector<vector<ll> > genHash(const vector<string> v, int xs, int ys)\n{\n  vector<vector<ll> > h1(xs,vector<ll>(ys,0));\n  vector<vector<ll> > h2(xs,vector<ll>(ys,0));\n  ll cn1 = 1, cn2 = 1;\n  REP(i,c) cn1 = (cn1*C1)%MOD;\n  REP(i,r) cn2 = (cn2*C2)%MOD;\n  REP(i,xs)\n  {\n    ll h = 0;\n    REP(j,c) h=(h*C1+v[i][j])%MOD;\n    REP(j,ys-c+1)\n    {\n      h1[i][j] = h;\n      if(j+c<ys) h = (h*C1-v[i][j]*cn1+v[i][j+c])%MOD;\n      h = (h<0)?h+MOD:h;\n    }\n  }\n  REP(j,ys)\n  {\n    ll h = 0;\n    REP(i,r) h=(h*C2+h1[i][j])%MOD;\n    REP(i,xs-r+1)\n    {\n      h2[i][j] = h;\n      if(i+r<xs) h = (h*C2-h1[i][j]*cn2+h1[i+r][j])%MOD;\n      h = (h<0)?h+MOD:h;\n    }\n  }\n  return h2;\n}\n\nint main()\n{\n  cin >> h >> w;\n  vector<string> a(h);\n  REP(i,h) cin >> a[i];\n  cin >> r >> c;\n  vector<string> b(r);\n  REP(i,r) cin >> b[i];\n  if(h<r||w<c) return 0;\n  auto f = genHash(a,h,w);\n  auto p = genHash(b,r,c);\n  REP(i,h-r+1) REP(j,w-c+1) if(f[i][j] == p[0][0])\n    printf(\"%d %d\\n\",i,j);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<cassert>\n    \n    \nusing namespace std;\n    \nstruct AhoCorasick {\n    \n  static const int ALPHABET_SIZE = 62, root=0;\n    \n  inline int index(char ch){\n    if(isupper(ch))return ch-'A';\n    if(islower(ch))return 26+ch-'a';\n    if(isdigit(ch))return 52+ch-'0';\n    assert(false);\n    return -1;\n  }\n      \n  int N; // num of node\n    \n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch;\n    bool leaf;\n    \n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n    \n  vector<Node> nodes;\n    \n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n    \n  void add(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = index(ch);\n      if(nodes[cur].child[c] != -1){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n    \n  int failure(int id) {\n    Node& node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=go(failure(node.parent),node.ch);\n    }\n    return node.link;\n  }\n    \n  int go(int id, char ch) {\n    int c = index(ch);\n    Node& node = nodes[id];\n    if(node.next[c] == -1){\n      if(node.child[c] != -1)node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=go(failure(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n    \nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(500000);\n\n  // ???????????????????????¨?????????????????????????????°???????????????????????????\n  for(int i=0;i<pl;i++)aho.add(pattern[i]);\n\n  // ??????????????????????????????????????????????????????????????¶??????acc?????????\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n    \n  const int til = T[0].size();\n\n  \n  int td[til][tl];\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.go(node, T[i][j]);\n      td[til-j-1][i]=node;\n    }\n  }\n    \n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n    \nint main(void){\n  int h,w,r,c;\n      \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++){\n    s[i].resize(w);\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n    }\n  }\n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++){\n    t[i].resize(c);\n    for(int j=0;j<c;j++){\n      scanf(\" %c\",&t[i][j]);\n    }\n  }\n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n    \n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 10000000000000007LL\nlong long dp[1001][1001];\nlong long x[1001][1001];\nlong long y[1001][1001];\nlong long z[1001];\nlong long H, W, N, M;\nint main() {\n\tcin >> H >> W; unsigned char c;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c; x[i][j] = c;\n\t\t}\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> c; y[i][j] = c;\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += y[i][j];\n\t\t}\n\t\tz[i] = sum;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tlong long sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum *= 256; sum %= MOD;\n\t\t\tsum += x[i][j];\n\t\t}\n\t\tdp[i][0] = sum;\n\t\tfor (int j = M; j < W; j++) {\n\t\t\tdp[i][j - M + 1] = dp[i][j - M];\n\t\t\tif (M < 7) {\n\t\t\t\tlong long c1 = MOD - ((1LL << ((M - 1) * 8))*x[i][j - M]);\n\t\t\t\tdp[i][j - M + 1] += c1;\n\t\t\t}\n\t\t\tdp[i][j - M + 1] *= 256;\n\t\t\tdp[i][j - M + 1] %= MOD;\n\t\t\tdp[i][j - M + 1] += x[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= H - N; i++) {\n\t\tfor (int j = 0; j <= W - M; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (dp[i + k][j] != z[k]) { goto E; }\n\t\t\t}\n\t\t\tcout << i << ' ' << j << endl;\n\t\tE:;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\ntypedef unsigned long long ull;\n \nint N,M,P,Q;\nchar field[MAX][MAX],pattern[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\n \nvoid compute_hash(char a[MAX][MAX],int n,int m){\n    const ull B1 = 63533;\n    const ull B2 = 100007;\n \n    ull t1 = 1;\n    for(int j = 0 ; j < Q ; j++) t1 *= B1;\n \n    for (int i = 0; i < n ; ++i) {\n        ull e = 0;\n        for(int j = 0 ; j < Q ; j++) e = e * B1 + a[i][j];\n        for(int j = 0 ; j + Q <= m ; j++){\n            tmp[i][j] = e;\n            if(j + Q < m) e = e * B1 - t1 * a[i][j] + a[i][j+Q];\n        }\n    }\n \n    ull t2 = 1;\n    for (int i = 0; i < P ; ++i)  t2 *= B2;\n \n    for (int j = 0; j + Q <= m  ; ++j) {\n        ull e = 0;\n        for (int i = 0; i < P ; ++i)e = e * B2 + tmp[i][j];\n        for (int i = 0; i + P <= n ; ++i) {\n            hash[i][j] = e;\n            if(i + P < n) e = e * B2 - t2 * tmp[i][j] + tmp[i + P][j];\n        }\n    }\n}\n \nvoid solve(){\n    compute_hash(pattern,P,Q);\n    ull res = hash[0][0];\n    compute_hash(field,N,M);\n    for (int i = 0; i <= N ; ++i) {\n        for (int j = 0; j <= M ; ++j) {\n            if(res == hash[i][j]){\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n \nint main(){\n    cin >> N >> M;\n    for (int i = 0; i < N ; ++i) {\n        for (int j = 0; j < M ; ++j) {\n            cin >> field[i][j];\n        }\n    }\n    cin >> P >> Q;\n    for (int i = 0; i < P ; i++) {\n        for (int j = 0; j < Q; ++j) {\n            cin >> pattern[i][j];\n        }\n    }\n        if(N < P && M < Q) return 0;\n        solve();\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate < uint_fast64_t MOD = 1000000007, uint_fast64_t base = 9973 >\nclass RollingHash {\npublic:\n        using u64 = uint_fast64_t;\n        using i32 = int_fast32_t;\n        RollingHash() {}\n\n        RollingHash(const string &s) {\n                i32 n = s.size();\n                hash.assign(n + 1, 0);\n                power.assign(n + 1, 1);\n                for ( i32 i = 0; i < n; i++ ) {\n                        hash[i + 1] = (hash[i] * base + s[i]) % MOD;\n                        power[i + 1] = power[i] * base % MOD;\n                }\n        }\n\n        //[l, r)\n        u64 get(i32 l, i32 n) {\n                u64 value = hash[l + n] + MOD - hash[l] * power[n] % MOD;\n                return ( value - (value >= MOD ? MOD : 0) );\n        }\n\nprivate:\n        vector < u64 > hash, power;\n};\n\ntemplate < uint_fast64_t MOD = 1000000007, uint_fast64_t base1 = 2009, uint_fast64_t base2 = 9973 >\nclass RollingHash2D {\npublic:\n        using u64 = uint_fast64_t;\n        using i32 = int_fast32_t;\n\n        RollingHash2D () {}\n        \n        RollingHash2D(const vector < string > &D, i32 R, i32 C) : row(R), col(C) {\n                i32 H = D.size(), W = D[0].size();\n                vector < RollingHash < MOD, base2 > > data;\n\n                hash.assign(H - R + 1, vector < u64 >(W - C + 1, 0));\n                for ( const string &s : D ) data.emplace_back(s);\n\n                for ( i32 j = 0; j < W - C + 1; j++ ) {\n                        vector < u64 > hh(H + 1, 0);\n                        vector < u64 > power(H + 1, 1);\n                        for ( i32 i = 0; i < H; i++ ) {\n                                hh[i + 1] = (hh[i] * base1 + data[i].get(j, C)) % MOD;\n                                power[i + 1] = power[i] * base1 % MOD;\n                        }\n                        for ( i32 i = 0; i < H - R + 1; i++ ) {\n                                hash[i][j] = hh[i + R] + MOD - hh[i] * power[R] % MOD;\n                                if ( hash[i][j] >= MOD ) hash[i][j] -= MOD;\n                        }\n                }\n        }\n        u64 get(i32 y, i32 x) { return ( hash[y][x] ); }\n        \nprivate:\n        vector < vector < u64 > > hash;\n        i32 row, col;\n};\n\n\nint main()\n{\n        constexpr int mod = 1000000007, base1 = 2009, base2 = 9973;\n        int H, W, R, C;\n                        \n        cin >> H >> W;\n        vector < string > S(H);\n        for ( string &s : S ) cin >> s;\n        cin >> R >> C;\n        vector < string > T(R);\n        for ( string &t : T ) cin >> t;\n        \n        RollingHash2D < mod, base1, base2 > r1(S, R, C);\n        RollingHash2D < mod, base1, base2 > r2(T, R, C);\n        \n        uint_fast64_t b = r2.get(0, 0);\n        for ( int i = 0; i < H - R + 1; i++ ) {\n                for ( int j = 0; j < W - C + 1; j++ ) {\n                        if ( r1.get(i, j) == b ) cout << i << \" \" << j << endl;\n                }\n        }\n        return ( 0 );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null A=9999973,B=950527;\n\nint H,W;\nchar T[1005][1005];\null t[1005][1005];\null t2[1005][1005];\nint h,w;\nchar U[1005][1005];\n\n\nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n  \n  ull target=0;  \n  for(int i=0;i<h;i++){\n    ull key=0;\n    for(int j=0;j<w;j++){\n      key=key*B+U[i][j];\n    }\n    target=target*A+key;\n  }\n\n  ull C=1;\n  for(int i=0;i<w;i++)C*=B;\n  \n  for(int i=0;i<H;i++){\n    ull key=0;\n    for(int j=0;j<W;j++){\n      key=key*B+T[i][j];\n      if(j-w>=0)key-=T[i][j-w]*C;\n      t[i][j]=key;\n      t2[i][j]=t[i][j];\n    }\n  }\n  \n  C=1;\n  for(int i=0;i<h;i++)C*=A;\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(i)t[i][j]+=t[i-1][j]*A;\n      if(i-h>=0)t[i][j]-=t2[i-h][j]*C;\n      if(t[i][j]==target){\n        if(i-h+1>=0&&j-w+1>=0)\n          printf(\"%d %d\\n\",i-h+1,j-w+1);\n      }\n    }\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <limits.h>\n#include <list>\nusing namespace std;\n\n#define HW_MAX 1000\n#define RC_MAX 1000\n\nchar T[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nchar P[HW_MAX + 1][HW_MAX + 1] = {\"\\0\"};\nint H, W, R, C;\n\n//list<int> T_index;\nchar P_index[UCHAR_MAX + 1][2] = {\"\\0\"};\n\nint Compare(int idxi, int idxj)\n{\n\tfor (int i = R - 1; i >= 0; i--) {\n\t\tfor (int j = C - 1; j >= 0; j--) {\n\t\t\tif (T[idxi + i][idxj + j] != P[i][j]) {\n\t\t\t\treturn T[idxi + i][idxj + j];\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> T[i];\n\t}\n\tcin >> R >> C;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> P[i];\n\t}\n\n\t//make P_index\n\tfor (int i = 0; i < R; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tP_index[P[i][j]][0] = i;\n\t\t\tP_index[P[i][j]][1] = j;\n\t\t}\n\t}\n\n\t//search and output\n\tint i = 0;\n\tint j = 0;\n\twhile (i + R <= H) {\n\t\tint ret = Compare(i, j);\n\t\tif (ret == -1) {\n\t\t\tcout << i << \" \" << j << endl;\n\t\t\tj++;\n\t\t\tif (j + C > W) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (j + C - 1 - P_index[ret][1] > j) {\n\t\t\t\tj += C - 1 - P_index[ret][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\twhile (j + C > W) {\n\t\t\t\ti++;\n\t\t\t\tj = j + C - W;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 26;\nconst char OFFSET = 'a';\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = str[str_index] - OFFSET;\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[c-OFFSET]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[c-OFFSET];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[c-OFFSET]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[c-OFFSET];\n\t\t}\n};\n\nclass KnuthMorrisPratt{\n\tpublic:\n\t\tvector<int> fail;\n\t\tstring t; // 探す文字列\n\t\tKnuthMorrisPratt(string& t) {\n\t\t\tthis->t = t;\n\t\t\tint m = t.size();\n\t\t\tfail = vector<int>(m + 1);\n\t\t\tint j = fail[0] = -1;\n\t\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\t\twhile (j >= 0 && t[j] != t[i - 1]) j = fail[j];\n\t\t\t\tfail[i] = ++j;\n\t\t\t}\n\t\t}\n\t\tvector<int> match(string& s){ // s に含まれる連続する部分文字列 t のインデックスを返す\n\t\t\tint n = s.size(), m = t.size();\n\t\t\tvector<int> res;\n\t\t\tfor (int i = 0, k = 0; i < n; ++i) {\n\t\t\t\twhile (k >= 0 && t[k] != s[i]) k = fail[k];\n\t\t\t\tif (++k >= m) {\n\t\t\t\t\tres.emplace_back(i - m + 1); // match at s[i-m+1 .. i]\n\t\t\t\t\tk = fail[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nvoid change(vector<string> &s){\n\tfor(auto& str : s){\n\t\tfor(auto& c : str){\n\t\t\tc = c == '1' ? 'a' : 'b';\n\t\t}\n\t}\n}\n\n// tに一致するsの部分集合の左上の座標を返す\nvector<pair<int, int>> BakerBird(vector<string>& s, vector<string>& t){\n\tchange(s);\n\tchange(t);\n\n\tAhoCorasick aho;\n\tfor(auto str : t) aho.add(str);\n\taho.build();\n\n\tvector<vector<int>> status(s.size(), vector<int>(s[0].size()));\n\trep(i,s.size()){\n\t\tint now = 0;\n\t\trep(j,s[0].size()){\n\t\t\tnow = aho.next(now, s[i][j]);\n\t\t\tstatus[i][j] = now;\n\t\t}\n\t}\n\n\tstring patern;\n\trep(i,aho.ac.size()){\n\t\tpatern += aho.ac[i] + '0';\n\t}\n\n\tvector<pair<int, int>> res;\n\tKnuthMorrisPratt kmp(patern);\n\trange(i,t[0].size() - 1, s[0].size()){\n\t\tstring sstr; // statusを縦に見た文字列\n\t\trep(j,s.size()){\n\t\t\tsstr += status[j][i] + '0';\n\t\t}\n\t\tfor(auto y : kmp.match(sstr)){\n\t\t\tres.emplace_back(y, i - t[0].size() + 1);\n\t\t}\n\t}\n\tsort(all(res));\n\treturn res;\n}\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> s(h);\n\trep(i,h){\n\t\tcin >> s[i];\n\t}\n\n\n\tint c,r;\n\tcin >> r >> c;\n\tvector<string> t(r);\n\trep(i,r){\n\t\tcin >> t[i];\n\t}\n\n\tfor(auto p : BakerBird(s, t)){\n\t\tcout << p.first << ' ' << p.second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int i, j, h, w, r, c, m, n;\n  char ch;\n  fscanf(stdin, \"%d %d\\n\", &h, &w);\n  int a[h][w];\n  for (i=0; i<h; i++) {\n    for (j=0; j<w; j++) {\n      fscanf(stdin, \"%c\", &ch);\n      a[i][j] = ch-'0';\n    }\n    fscanf(stdin, \"%*c\");\n  }\n\n  fscanf(stdin, \"%d %d\\n\", &r, &c);\n  int b[r][c];\n  for (i=0; i<r; i++) {\n    for (j=0; j<c; j++) {\n      fscanf(stdin, \"%c\", &ch);\n      b[i][j] = ch-'0';\n    }\n    fscanf(stdin, \"%*c\");\n  }\n  \n  for (i=0; i<h-r+1; i++) {\n    for (j=0; j<w-c+1; j++) {\n      if (a[i][j]==b[0][0]) {\n\tfor (m=0; m<r; m++) {\n\t  for (n=0; n<c; n++) {\n\t    if (a[i+m][j+n]!=b[m][n])  goto next;\n\t  }\n\t}\n\tprintf(\"%d %d\\n\", i, j);\n      }\n    next:\n      ;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <String.h>\n#include <math.h>\n#include <limits.h>\n\n\n/*\n * ?????????????´¢????????????rolling-hash???\n * String????????????????????¨??????Pattern????????????????????????\n * ??????????±???????????????°???????????°????????????????????£??¬??????????????????\n *\n */\n\nchar String[1001][1001];\nchar Pattern[1001][1001];\n\n\n\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n#define P (1000000007)\n\null power[1000001];\n\n/*\n * String:????´¢????±??????????\n * s_num:????´¢????±???????????????????\n * Pattern:????´¢??????????????????\n * p_num:????´¢???????????????????????????\n */\nvoid rolling_hash(int h, int w, int r, int c)\n{\n    int i, j, k , l;\n    ull target_hash = 0, Pattern_hash = 0;\n    \n    \n    /*\n     * target hash??????????¨?????????¨?????????????????????????±?????????????\n     */\n    power[0] = 1;\n    for (i=0; i <r*c; i++) {\n            power[i+1]= power[i]* P;\n    }\n    \n    /*\n     * Pattern??????????????\\???????±???????\n     */\n    for (i=0; i < r; i++) {\n        for (j=0; j < c; j++) {\n            Pattern_hash += Pattern[i][j] * power[i*c + j];\n        }\n    }\n    \n    \n    for (i = 0; i + r <= h; i++) {\n        \n        /*\n         * String???????????\\???????±???????\n         */\n        target_hash = 0;\n        for (k=i; k < r; k++) {\n            for (l=0; l < c; l++) {\n                target_hash += String[k][l] * power[c *(k-i)  + l] ;\n            }\n        }\n        \n        for (j=0; j+c <= w; j++) {\n            /*\n             * hash???????????´????????°?????????????????¨????????????\n             */\n            if (target_hash == Pattern_hash) {\n                printf(\"%d %d\\n\", i, j);\n            }\n            \n            \n            /*\n             * target???????????????????????????????????????????????????????????????????????\\??????????¨??????????\n             */\n            if (j+c != w) {\n                target_hash = 0;\n                for (k=0; k < r; k++) {\n                    for (l=0; l < c; l++) {\n                        target_hash += String[i+k][l+j+1] * power[k*c + l] ;\n                    }\n                }\n            }\n\n        }\n    }\n    \n    return;\n}\n\n\nint main( ){\n    \n    int i, j, H, W, R,C;\n    scanf(\"%d\", &H);\n    scanf(\"%d\", &W);\n    getchar();\n    for (i = 0; i < H ; i++) {\n        for (j = 0; j < W; j++) {\n            scanf(\"%c\", &String[i][j]);\n        }\n        getchar();\n    }\n    \n    scanf(\"%d\", &R);\n    scanf(\"%d\", &C);\n    getchar();\n    for (i = 0; i < R ; i++) {\n        for (j = 0; j < C; j++) {\n            scanf(\"%c\", &Pattern[i][j]);\n        }\n        getchar();\n    }\n    \n    rolling_hash(H, W, R, C);\n   \n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_C Pattern Search\n// 2018.5.13 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n\t\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n}\n\ntypedef unsigned long long ull;\n#define C1  401\n#define C2  397\n\n#define MAX_L 1005\nchar text[MAX_L][MAX_L]; int H, W;\nchar pat[MAX_L][MAX_L]; int R, C;\null a[MAX_L][MAX_L], b[MAX_L][MAX_L];\null t[MAX_L][MAX_L];\n\nvoid genHash(ull res[MAX_L][MAX_L], char s[MAX_L][MAX_L], int h, int w)\n{\n\tint r, c;\n\tull x, y, k;\n\n//\tmemset(t, 0, sizeof(t));\n//\tmemset(res, 0, sizeof(res));\n\n\tx = 1, y = 1;\n\tfor (c = 0; c < C; c++) x *= C1;\n\tfor (r = 0; r < R; r++) y *= C2;\n\n\tfor (r = 0; r < h; r++) {\n\t\tk = 0;\n\t\tfor (c = 0; c < C; c++) k = k*C1 + s[r][c];\n\t\tfor (c = 0; c <= w-C; c++) {\n\t\t\tt[r][c] = k;\n\t\t\tif (c + C < w) k = k*C1-s[r][c]*x+s[r][c+C];\n\t\t}\n\t}\n\n\tfor (c = 0; c < w; c++) {\n\t\tk = 0;\n\t\tfor (r = 0; r < R; r++) k = k*C2+t[r][c];\n\t\tfor (r = 0; r <= h-R; r++) {\n\t\t\tres[r][c] = k;\n\t\t\tif (r+R < h) k = k*C2-t[r][c]*y+t[r+R][c];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint  r, c;\n\tchar ch, *p;\n\tull  f;\n\n\tH = in(), W = in();\n\tfor (r = 0; r < H; r++) {\n\t\tp = text[r];\n\t\twhile ((ch = gc()) > ' ') *p++ = ch;\n\t\t*p = 0;\n\t}\n\n\tR = in(), C = in();\n\tfor (r = 0; r < R; r++) {\n\t\tp = pat[r];\n\t\twhile ((ch = gc()) > ' ') *p++ = ch;\n\t\t*p = 0;\n\t}\n\n\tgenHash(a, text, H, W);\n\tgenHash(b, pat, R, C);\n\tf = b[0][0];\n\n\tfor (r = 0; r <= H-R; r++) for (c = 0; c <= W-C; c++) {\n\t\tif (f == a[r][c]) {\n\t\t\tout(r), pc(' '), out(c), pc('\\n');\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define mod 1000000009\n#define e 32769\n\nchar s[1010][1010];\nchar data1[1010][1010];\nint tttthassh[1010][1010];\n\nint main(){\n\tint n,m,a,b;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)scanf(\" %s\",s[i]);\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\" %s\",data1[i]);\n\tlong po=1;\n\tfor(int j=0;j<b;j++)po=po*e%mod;\n\tlong pop=1;\n\tfor(int i=0;i<a;i++)pop=pop*po%mod;\n\tfor(int j=0;j<m;j++){\n\t\tlong hhhhhhash=0;\n\t\tfor(int i=0;i<a;i++)hhhhhhash=(hhhhhhash*po+s[i][j])%mod;\n\t\tfor(int i=a;i<=n;i++){\n\t\t\ttttthassh[i-a][j]=hhhhhhash;\n\t\t\thhhhhhash=((hhhhhhash*po+s[i][j]-s[i-a][j]*pop)%mod+mod)%mod;\n\t\t}\n\t}\n\tlong thash=0;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)thash=(thash*e+data1[i][j])%mod;\n\n\tfor(int i=0;i<=n-a;i++){\n\t\tlong hhhhhhash=0;\n\t\tfor(int j=0;j<b;j++)hhhhhhash=(hhhhhhash*e+tttthassh[i][j])%mod;\n\t\tfor(int j=b;j<=m;j++){\n\t\t\tif(thash==hhhhhhash)printf(\"%d %d\\n\",i,j-b);\n\t\t\thhhhhhash=((hhhhhhash*e+tttthassh[i][j]-tttthassh[i][j-b]*po)%mod+mod)%mod;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <limits.h>\n\n\n/*\n * ?????????????´¢????????????rolling-hash???\n * String????????????????????¨??????Pattern????????????????????????\n * ??????????±???????????????°???????????°????????????????????£??¬??????????????????\n *\n */\n\nchar String[1001][1001];\nchar Pattern[1001][1001];\n\n\n\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n#define P (1000000007)\n\null power[1000001];\n\n/*\n * String:????´¢????±??????????\n * s_num:????´¢????±???????????????????\n * Pattern:????´¢??????????????????\n * p_num:????´¢???????????????????????????\n */\nvoid rolling_hash(int h, int w, int r, int c)\n{\n    int i, j, k , l;\n    ull target_hash = 0, Pattern_hash = 0;\n    \n    \n    /*\n     * target hash??????????¨?????????¨?????????????????????????±?????????????\n     */\n    power[0] = 1;\n    for (i=0; i <r*c; i++) {\n            power[i+1]= power[i]* P;\n    }\n    \n    /*\n     * Pattern??????????????\\???????±???????\n     */\n    for (i=0; i < r; i++) {\n        for (j=0; j < c; j++) {\n            Pattern_hash += Pattern[i][j] * power[i*c + j];\n        }\n    }\n    \n    \n    for (i = 0; i + r <= h; i++) {\n        \n        /*\n         * String???????????\\???????±???????\n         */\n        target_hash = 0;\n        for (k=i; k < r; k++) {\n            for (l=0; l < c; l++) {\n                target_hash += String[k][l] * power[c *(k-i)  + l] ;\n            }\n        }\n        \n        for (j=0; j+c <= w; j++) {\n            /*\n             * hash???????????´????????°?????????????????¨????????????\n             */\n            if (target_hash == Pattern_hash) {\n                printf(\"%d %d\\n\", i, j);\n            }\n            \n            \n            /*\n             * target???????????????????????????????????????????????????????????????????????\\??????????¨??????????\n             */\n            if (j+c != w) {\n                target_hash = 0;\n                for (k=0; k < r; k++) {\n                    for (l=0; l < c; l++) {\n                        target_hash += String[i+k][l+j+1] * power[k*c + l] ;\n                    }\n                }\n            }\n\n        }\n    }\n    \n    return;\n}\n\n\nint main( ){\n    \n    int i, j, H, W, R,C;\n    scanf(\"%d\", &H);\n    scanf(\"%d\", &W);\n    getchar();\n    for (i = 0; i < H ; i++) {\n        for (j = 0; j < W; j++) {\n            scanf(\"%c\", &String[i][j]);\n        }\n        getchar();\n    }\n    \n    scanf(\"%d\", &R);\n    scanf(\"%d\", &C);\n    getchar();\n    for (i = 0; i < R ; i++) {\n        for (j = 0; j < C; j++) {\n            scanf(\"%c\", &Pattern[i][j]);\n        }\n        getchar();\n    }\n    \n    rolling_hash(H, W, R, C);\n   \n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define HWRC 1000\n \nint main()\n{\n    char HW[HWRC][HWRC];\n    char RC[HWRC][HWRC];\n    int H,W,R,C,i,j,k,cnt = 0;\n    int Ck[HWRC];\n    int Cn[HWRC];\n\n    scanf(\"%d%d\",&H,&W);\n    for(i=0;i<H;i++)    scanf(\"%s\",&HW[i]);\n    scanf(\"%d%d\",&R,&C);\n    for(i=0;i<R;i++)    scanf(\"%s\",&RC[i]);\n\n    for(i=0;i<R;i++)\n    {\n        k = 0;\n        Cn[i] = 0;\n\n        for(j=0;j<C;j++)\n        {\n            if(RC[i][j]==RC[i][0])\n            {\n                k++; /* 0列目と同じなのは何列目までか */\n                Cn[i] = k-1; /* 比較済みとなり得る列数 */\n            }\n            else\n            {\n                break;\n            }\n        }\n        Ck[i] = C-k+1; /* 必ず比較しなければならない列数 */\n    }\n\n\t/* テーブルAの行を検索 */\n    for(i=0;i<=H-R;i++)\n    {\n\t\t/* テーブルAの列を検索 */\n        for(j=0;j<=W-C;j++)\n        {\n\t\t\t/* テーブルBの行と一致する列を検索 */\n            for(cnt = 0;cnt < R;cnt++)\n            {\n                if(memcmp(&HW[i+cnt][j],&RC[cnt][0],C)!=0)\n                {\n                    break;\n                }\n            }\n\n            while(cnt == R)\n            {\n                printf(\"%d %d\\n\",i,j);\n                j++;\n                if(j<=W-C)\n                {\n                    for(cnt = 0;cnt < R;cnt++)\n                    {\n                        if(memcmp(&HW[i+cnt][j+Cn[cnt]],&RC[cnt][Cn[cnt]],Ck[cnt])!=0)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \n#define MAX 100\n#define INF 100000000\n#define white 0\n#define gray 1\n#define black 2\n \ntypedef struct{\n  int data[MAX];\n  int head;\n  int tail;\n}queue;\n \nqueue Q;\n \nint n,d[MAX] = {INF};\nint g[MAX][MAX] = {0};\nint color[MAX] = {white};\n \nvoid bfs(int);\nvoid enqueue(int);\nint dequeue(void);\n \nint main(){\n  int i,j,u,k,v;\n \n  scanf(\"%d\",&n);\n \n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&u,&k);\n    for(j=0;j<k;j++){\n      scanf(\"%d\",&v);\n      g[u-1][v-1] = 1;\n    }\n  }\n  for(i=0;i<n;i++)\n    d[i] = INF;\n \n  bfs(0);\n \n  for(i=0;i<n;i++){\n    if(d[i] == INF)printf(\"%d %d\\n\",i+1,-1);\n    else printf(\"%d %d\\n\",i+1,d[i]);\n  }\n  return 0;\n}\n \nvoid bfs(s){\n  int v,u;\n \n  d[s] = 0;\n  color[s] = gray;\n  Q.head = Q.tail = 0;\n  enqueue(s);\n \n  while(Q.tail < n){\n    u = dequeue();\n    if(u == INF)break;\n    for(v=0;v<n;v++){\n      if(g[u][v] == 0)continue;\n      if(color[v] == white){\n    d[v] = d[u] + 1;\n    color[v] = gray;\n    enqueue(v);\n      }\n    }\n    color[u] = black;\n  }\n}\n \nvoid enqueue(int s){\n \n  if(Q.tail >= n)return;\n   \n  Q.data[Q.tail] = s;\n  Q.tail++;\n}\n \nint dequeue(){\n  int s;\n \n  if(Q.head == Q.tail)return INF;\n \n  s = Q.data[Q.head];\n  Q.head++;\n \n  return s;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[10000][10000], b[10000][10000];\nint check(int x, int y, int r, int c){\n    int i, j;\n    for(i=0; i<r; i++)for(j=1; j<c+1; j++)if(a[i+x][j+y]!=b[i][j])return 0;\n    return 1;\n}\nint main(){\n    int i, j, h, w, r, c;\n    scanf(\"%d %d\", &h, &w);\n    for(i=0; i<h; i++)for(j=0; j<w+1; j++)a[i][j]=getchar();\n    scanf(\"%d %d\", &r, &c);\n    for(i=0; i<r; i++)for(j=0; j<c+1; j++)b[i][j]=getchar();\n    for(i=0; i<h-r+1; i++)for(j=0; j<w-c+1; j++)if(check(i, j, r, c))printf(\"%d %d\\n\", i, j);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <limits.h>\n\n\n/*\n * ?????????????´¢????????????rolling-hash???\n * String????????????????????¨??????Pattern????????????????????????\n * ??????????±???????????????°???????????°????????????????????£??¬??????????????????\n *\n */\n\nchar String[1001][1001];\nchar Pattern[1001][1001];\n\n\n\n\n/*\n * unsinged long long?????¨???????????¨??§???????????????????????????????????????????????? mod (2<<64)??¨??????????????¨????????????\n * P????????¨????????????(2<<64)??¨?´???§???????????????????????§????????????????????¶\n */\ntypedef unsigned long long ull;\n#define P (1000000007)\n\null power[1000001];\n\n/*\n * String:????´¢????±??????????\n * s_num:????´¢????±???????????????????\n * Pattern:????´¢??????????????????\n * p_num:????´¢???????????????????????????\n */\nvoid rolling_hash(int h, int w, int r, int c)\n{\n    int i, j, k , l;\n    ull target_hash = 0, Pattern_hash = 0;\n    \n    \n    /*\n     * target hash??????????¨?????????¨?????????????????????????±?????????????\n     */\n    power[0] = 1;\n    for (i=0; i <r*c; i++) {\n            power[i+1]= power[i]* P;\n    }\n    \n    /*\n     * Pattern??????????????\\???????±???????\n     */\n    for (i=0; i < r; i++) {\n        for (j=0; j < c; j++) {\n            Pattern_hash += Pattern[i][j] * power[i*c + j];\n        }\n    }\n    \n    \n    for (i = 0; i + r <= h; i++) {\n        \n        /*\n         * String???????????\\???????±???????\n         */\n        target_hash = 0;\n        for (k=0; k < r; k++) {\n            for (l=0; l < c; l++) {\n                target_hash += String[k+i][l] * power[c * k  + l] ;\n            }\n        }\n        \n        for (j=0; j+c <= w; j++) {\n            /*\n             * hash???????????´????????°?????????????????¨????????????\n             */\n            if (target_hash == Pattern_hash) {\n                printf(\"%d %d\\n\", i, j);\n            }\n            \n            \n            /*\n             * target???????????????????????????????????????????????????????????????????????\\??????????¨??????????\n             */\n            if (j+c != w) {\n                target_hash = 0;\n                for (k=0; k < r; k++) {\n                    for (l=0; l < c; l++) {\n                        target_hash += String[i+k][l+j+1] * power[k*c + l] ;\n                    }\n                }\n            }\n\n        }\n    }\n    \n    return;\n}\n\n\nint main( ){\n    \n    int i, j, H, W, R,C;\n    scanf(\"%d\", &H);\n    scanf(\"%d\", &W);\n    getchar();\n    for (i = 0; i < H ; i++) {\n        for (j = 0; j < W; j++) {\n            scanf(\"%c\", &String[i][j]);\n        }\n        getchar();\n    }\n    \n    scanf(\"%d\", &R);\n    scanf(\"%d\", &C);\n    getchar();\n    for (i = 0; i < R ; i++) {\n        for (j = 0; j < C; j++) {\n            scanf(\"%c\", &Pattern[i][j]);\n        }\n        getchar();\n    }\n    \n    rolling_hash(H, W, R, C);\n   \n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_C Pattern Search\n// 2018.5.13 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ntypedef unsigned long long ull;\n#define C1  401\n#define C2  397\n\n#define MAX_L 1005\nchar text[MAX_L][MAX_L]; int H, W;\nchar pat[MAX_L][MAX_L]; int R, C;\null a[MAX_L][MAX_L], b[MAX_L][MAX_L];\null t[MAX_L][MAX_L];\n\nvoid genHash(ull res[MAX_L][MAX_L], char s[MAX_L][MAX_L], int h, int w)\n{\n\tint r, c;\n\tull x, y, k;\n\n\tmemset(t, 0, sizeof(t));\n\tmemset(res, 0, sizeof(res));\n\n\tx = 1, y = 1;\n\tfor (c = 0; c < C; c++) x *= C1;\n\tfor (r = 0; r < R; r++) y *= C2;\n\n\tfor (r = 0; r < h; r++) {\n\t\tk = 0;\n\t\tfor (c = 0; c < C; c++) k = k*C1 + s[r][c];\n\t\tfor (c = 0; c <= w-C; c++) {\n\t\t\tt[r][c] = k;\n\t\t\tif (c + C < w) k = k*C1-s[r][c]*x+s[r][c+C];\n\t\t}\n\t}\n\n\tfor (c = 0; c < w; c++) {\n\t\tk = 0;\n\t\tfor (r = 0; r < R; r++) k = k*C2+t[r][c];\n\t\tfor (r = 0; r <= h-R; r++) {\n\t\t\tres[r][c] = k;\n\t\t\tif (r+R < h) k = k*C2-t[r][c]*y+t[r+R][c];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint r, c;\n\tchar ch, *p;\n\n\tH = in(), W = in();\n\tfor (r = 0; r < H; r++) {\n\t\tp = text[r];\n\t\twhile ((ch = gc()) > ' ') *p++ = ch;\n\t\t*p = 0;\n\t}\n\n\tR = in(), C = in();\n\tfor (r = 0; r < R; r++) {\n\t\tp = pat[r];\n\t\twhile ((ch = gc()) > ' ') *p++ = ch;\n\t\t*p = 0;\n\t}\n\n\tgenHash(a, text, H, W);\n\tgenHash(b, pat, R, C);\n\n\tfor (r = 0; r <= H-R; r++) for (c = 0; c <= W-C; c++) {\n\t\tif (a[r][c] == b[0][0]) printf(\"%d %d\\n\", r, c);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(void)\n{\n  int i,j,k;//counter\n  int h,w;\n  int r,c;\n  char ***str1,**str2;\n  scanf(\"%d%d\",&h,&w);\n  str1=(char***)malloc(sizeof(char**)*h);\n  for(i=0;i<h;i++)\n    {\n      str1[i]=(char**)malloc(sizeof(char*)*w);\n      str1[i][0]=(char*)malloc(sizeof(char)*w);\n      scanf(\"%s\",str1[i][0]);\n      for(j=1;j<w;j++)\n        {\n          str1[i][j]=(char*)malloc(sizeof(char)*(w-j));\n          strcpy(str1[i][j],str1[i][j-1]+1);\n        }\n    }\n  scanf(\"%d%d\",&r,&c);\n  str2=(char**)malloc(sizeof(char*)*r);\n  for(i=0;i<r;i++)\n    {\n      str2[i]=(char*)malloc(sizeof(char)*(c+1));\n      scanf(\"%s\",str2[i]);\n    }\n  for(i=0;i<r;i++) scanf(\"%s\\n\",str2[i]);\n  //patternSearch\n  for(i=0;i<=h-r;i++)\n    {\n      for(j=0;j<=w-c;j++)\n        {\n          for(k=0;k<r;k++)\n            {\n              if(strncmp(str1[i+k][j],str2[k],c)!=0) break;\n            }\n          if(k==r) printf(\"%d %d\\n\",i,j);\n        }\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MOD 1000000009\n#define e 32769\n\nchar s[1010][1010];\nchar t[1010][1010];\nint tatehash[1010][1010];\n\nint main(){\n\tint n,m,a,b;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)scanf(\" %s\",s[i]);\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\" %s\",t[i]);\n\n\tlong po=1;\n\tfor(int j=0;j<b;j++)po=po*e%MOD;\n\tlong popo=1;\n\tfor(int i=0;i<a;i++)popo=popo*po%MOD;\n\tfor(int j=0;j<m;j++){\n\t\tlong hash=0;\n\t\tfor(int i=0;i<a;i++)hash=(hash*po+s[i][j])%MOD;\n\t\tfor(int i=a;i<=n;i++){\n\t\t\ttatehash[i-a][j]=hash;\n\t\t\thash=((hash*po+s[i][j]-s[i-a][j]*popo)%MOD+MOD)%MOD;\n\t\t}\n\t}\n\tlong thash=0;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)thash=(thash*e+t[i][j])%MOD;\n\t\t\n\tfor(int i=0;i<=n-a;i++){\n\t\tlong hash=0;\n\t\tfor(int j=0;j<b;j++)hash=(hash*e+tatehash[i][j])%MOD;\n\t\tfor(int j=b;j<=m;j++){\n\t\t\tif(thash==hash)printf(\"%d %d\\n\",i,j-b);\n\t\t\thash=((hash*e+tatehash[i][j]-tatehash[i][j-b]*po)%MOD+MOD)%MOD;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(void)\n{\n  int i,j,k;//counter\n  int h,w;\n  int r,c;\n  char **str1,**str2;\n  scanf(\"%d%d\",&h,&w);\n  str1=(char**)malloc(sizeof(char*)*h);\n  for(i=0;i<h;i++)\n    {\n      str1[i]=(char*)malloc(sizeof(char)*(w+1));\n      scanf(\"%s\",str1[i]);\n    }\n  scanf(\"%d%d\",&r,&c);\n  str2=(char**)malloc(sizeof(char*)*r);\n  for(i=0;i<r;i++)\n    {\n      str2[i]=(char*)malloc(sizeof(char)*(c+1));\n      scanf(\"%s\",str2[i]);\n    }\n  for(i=0;i<r;i++) scanf(\"%s\\n\",str2[i]);\n  //patternSearch\n  for(i=0;i<h-r+1;i++)\n    {\n      for(j=0;j<w-c+1;j++)\n        {\n          for(k=0;k<r;k++)\n            {\n              if(strncmp(str1[i+k]+j,str2[k],c)!=0) break;\n            }\n          if(k==r) printf(\"%d %d\\n\",i,j);\n        }\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(){\n    int i,j,k,l,i1,j1,i2,j2,state;\n    \n    scanf(\"%d%d\",&i1,&j1);\n    char indata[i1][j1];\n    \n    for(i=0;i<i1;i++){\n        scanf(\"%s\",indata[i]);\n        //printf(\"%s\\n\",indata[i]);\n    }\n    \n    scanf(\"%d%d\",&i2,&j2);\n    char load[i2][j2];\n    \n    for(i=0;i<i2;i++){\n        scanf(\"%s\",load[i]);\n        //printf(\"%s\\n\",load[i]);\n    }\n    \n    for(i=0;i<=i1-i2;i++){\n        for(j=0;j<=j1-j2;j++){\n            state=1;\n            //printf(\"%5s , %2s\\n\",&indata[i][j],load[0]);\n            if(strncmp(&indata[i][j],load[0],j2)==0){\n                //printf(\"%d %d\\n\",i,j);\n                state=0;\n                for(k=1;k<i2;k++){\n                    if(strncmp(&indata[i+k][j],load[k],j2)!=0){\n                        state=1;\n                        break;\n                    }\n                }\n                if(state==0)printf(\"%d %d\\n\",i,j);\n            }\n        }\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[20000][20000], b[20000][20000];\nint check(int x, int y, int r, int c){\n    int i, j;\n    for(i=0; i<r; i++)for(j=1; j<c+1; j++)if(a[i+x][j+y]!=b[i][j])return 0;\n    return 1;\n}\nint main(){\n    int i, j, h, w, r, c;\n    scanf(\"%d %d\", &h, &w);\n    for(i=0; i<h; i++)for(j=0; j<w+1; j++)a[i][j]=getchar();\n    scanf(\"%d %d\", &r, &c);\n    for(i=0; i<r; i++)for(j=0; j<c+1; j++)b[i][j]=getchar();\n    for(i=0; i<h-r+1; i++)for(j=0; j<w-c+1; j++)if(check(i, j, r, c))printf(\"%d %d\\n\", i, j);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[1000][1000], b[1000][1000];\nint check(int x, int y, int r, int c){\n    int i, j;\n    for(i=0; i<r; i++)for(j=1; j<c+1; j++)if(a[i+x][j+y]!=b[i][j])return 0;\n    return 1;\n}\nint main(){\n    int i, j, h, w, r, c;\n    scanf(\"%d %d\", &h, &w);\n    for(i=0; i<h; i++)for(j=0; j<w+1; j++)a[i][j]=getchar();\n    scanf(\"%d %d\", &r, &c);\n    for(i=0; i<r; i++)for(j=0; j<c+1; j++)b[i][j]=getchar();\n    for(i=0; i<h-r+1; i++)for(j=0; j<w-c+1; j++)if(check(i, j, r, c))printf(\"%d %d\\n\", i, j);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_C Pattern Search\n// 2018.5.13 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define MOD 1000000007LL\n#define C1  401\n#define C2  397\n\n#define MAX_L 1005\nchar text[MAX_L][MAX_L]; int H, W;\nchar pat[MAX_L][MAX_L]; int R, C;\nint  a[MAX_L][MAX_L], b[MAX_L][MAX_L];\nint  t[MAX_L][MAX_L];\n\nvoid genHash(int res[MAX_L][MAX_L], char s[MAX_L][MAX_L], int h, int w)\n{\n\tint r, c;\n\tlong long x, y, k;\n\n\tmemset(t, 0, sizeof(t));\n\tmemset(res, 0, sizeof(res));\n\n\tx = 1, y = 1;\n\tfor (c = 0; c < C; c++) x = (x*C1) % MOD;\n\tfor (r = 0; r < R; r++) y = (y*C2) % MOD;\n\n\tfor (r = 0; r < h; r++) {\n\t\tk = 0;\n\t\tfor (c = 0; c < C; c++) k = (k*C1 + s[r][c]) % MOD;\n\t\tfor (c = 0; c <= w-C; c++) {\n\t\t\tt[r][c] = (int)k;\n\t\t\tif (c + C < w) k = (k*C1-s[r][c]*x+s[r][c+C]) % MOD;\n\t\t\tif (k < 0) k += MOD;\n\t\t}\n\t}\n\n\tfor (c = 0; c < w; c++) {\n\t\tk = 0;\n\t\tfor (r = 0; r < R; r++) k = (k*C2+t[r][c]) % MOD;\n\t\tfor (r = 0; r <= h-R; r++) {\n\t\t\tres[r][c] = (int)k;\n\t\t\tif (r+R < h) k = (k*C2-t[r][c]*y+t[r+R][c]) % MOD;\n\t\t\tif (k < 0) k += MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint r, c;\n\tchar ch, *p;\n\n\tH = in(), W = in();\n\tfor (r = 0; r < H; r++) {\n\t\tp = text[r];\n\t\twhile ((ch = gc()) > ' ') *p++ = ch;\n\t\t*p = 0;\n\t}\n\n\tR = in(), C = in();\n\tfor (r = 0; r < R; r++) {\n\t\tp = pat[r];\n\t\twhile ((ch = gc()) > ' ') *p++ = ch;\n\t\t*p = 0;\n\t}\n\n\tgenHash(a, text, H, W);\n\tgenHash(b, pat, R, C);\n\n\tfor (r = 0; r <= H-R; r++) for (c = 0; c <= W-C; c++) {\n\t\tif (a[r][c] == b[0][0]) printf(\"%d %d\\n\", r, c);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef unsigned int ull;\n\nconst ull B1 = 9973;\nconst ull B2 = 100000007;\n\nint main()\n{\n  int i, h, w, r, c, j;\n  ull t1, t2, e;\n  fscanf(stdin, \"%d %d\\n\", &h, &w);\n  char a[h][w+3];\n  for (i=0; i<h; i++)  fgets(a[i], w+2, stdin);\n  fscanf(stdin, \"%d %d\\n\", &r, &c);\n  char b[c+3];\n  ull bh, tmp;\n  bh = 0;\n  t2 = 1;\n  for (i=0; i<r; i++) {\n    fgets(b, c+2, stdin);\n    tmp = 0;\n    for (j=0; j<c; j++) tmp = tmp * B1 + b[j];\n    bh = bh * B2 + tmp;\n    t2 *= B2;\n  }\n\n  ull *tmp2 = (ull*)malloc(sizeof(ull)*h*w);\n  \n  for (j=0; j<w; j++) {\n    e = a[0][j];\n    for (i=1; i<r; i++)   e = e * B2 + a[i][j];\n    for (i=0; i+r<=h; i++) {\n      *(tmp2+i*w+j) = e;\n      if (i+r<h) e = e * B2 - t2 * a[i][j] + a[i+r][j];\n    }\n  }\n  t1 = B1;\n  for (i=1; i<c; i++) t1 *= B1;\n  for (i=0; i+r<=h; i++) {\n    e = *(tmp2+i*w);\n    for (j=1; j<c; j++)  e = e*B1 + *(tmp2+i*w+j);\n    for (j=0; j+c<=w; j++) {\n      if (e==bh) printf(\"%d %d\\n\", i, j);\n      if (j+c<w) e = e*B1 - t1 * *(tmp2+i*w+j) + *(tmp2+i*w+j+c);\n    }\n  \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 1000\n\nint\nmain(int argc, char** argv)\n{\n\tchar a[MAX_N][MAX_N];\n\tchar b[MAX_N][MAX_N];\n\tchar t[MAX_N];\n\tint h, w;\n\tint r, c;\n\tint i, j;\n\tint u, v;\n\n\tscanf(\"%d %d\", &h, &w);\n\tfor (i = 0; i < h; ++i)\n\t{\n\t\tscanf(\"%s\", t);\n\t\tfor (j = 0; j < w; ++j)\n\t\t\ta[i][j] = t[j];\n\t}\n\n\tscanf(\"%d %d\", &r, &c);\n\tfor (i = 0; i < r; ++i)\n\t{\n\t\tscanf(\"%s\", t);\n\t\tfor (j = 0; j < c; ++j)\n\t\t\tb[i][j] = t[j];\n\t}\n\n\tfor (i = 0; i <= h - r; ++i)\n\t{\n\t\tfor (j = 0; j <= w - c; ++j)\n\t\t{\n\t\t\tbool f = true;\n\t\t\tfor (u = 0; u < r; ++u)\n\t\t\t{\n\t\t\t\tfor (v = 0; v < c; ++v)\n\t\t\t\t{\n\t\t\t\t\tif (a[i + u][j + v] != b[u][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!f)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (f)\n\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tString[] t = new String[h];\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tt[i] = scan.next();\n\n\t\tint r = scan.nextInt();\n\t\tint c = scan.nextInt();\n\t\tString[] p = new String[r];\n\t\tfor(int i = 0; i < r; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind{\n\tboolean debug;\n\n\tpublic PtFind(String[] t, String[] p, boolean d){\n\t\tdebug = d;\n\n\t\tboolean[][] jg = new boolean[t.length - p.length + 1][t[0].length() - p[0].length() + 1];\n\t\t//length????????????????´???°???length()??????????????°\n\t\tfor(int y = 0; y < jg.length; y++)\n\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\tjg[y][x] = true; //true?????£??\\??????\n\n\t\tfor(int r = 0; r < p.length; r++){\n\t\t\tStFind stf = new StFind(p[r], d);\n\t\t\tfor(int y = 0; y < jg.length; y++){\n\t\t\t\tboolean[] result = new boolean[jg[0].length];\n\t\t\t\tstf.find(t[y+r], p[r], result);\n\t\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\t\tjg[y][x] &= result[x];\n\t\t\t\t\t//a &= b??????a = a & b\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = 0; y < jg.length; y++)\n\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\tif(jg[y][x])\n\t\t\t\t\tSystem.out.println(y + \" \" + x);\n\t}\n}\n\n//\nclass StFind{\n\tboolean debug;\n\tint[] msft;\n\tint[] sft = new int[Character.MAX_CODE_POINT];\n\n\tpublic StFind(String p, boolean d){\n\t\tdebug = d;\n\t\tcreateMatchPt(p);\n\t}\n\n\tpublic void find(String t, String p, boolean[] result){\n\t\tint x = 0;\n\t\tfor(int st = 0; st < t.length() - p.length() + 1;){\n\t\t\tif((x = isBaEqual(t, p, st)) == p.length())\n\t\t\t\tresult[st] = true;\n\t\t\tst += msft[x];\n\t\t}\n\t}\n\n\tprivate void createMatchPt(String p){\n\t\tmsft = new int[p.length() + 1];\n\t\tmsft[0] = p.length();\n\n\t\tfor(int sft = p.length(); sft > 0; sft--){\n\t\t\tfor(int m = 1; m < msft.length; m++){\n\t\t\t\tif(m > p.length() - sft){\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(p.charAt(p.length() - m) != p.charAt(p.length() - m- sft)){\n\t\t\t\t\tmsft[m-1] = sft;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(m == p.length() -sft)\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t}\n\t\t}\n\n\t\tif(debug)\n\t\t\tfor(int i = 0; i < msft.length; i++)\n\t\t\t\tSystem.out.println(\"--- \" + i + \" : \" + msft[i]);\n\t}\n\n\t//\n\tint stPre = 0;\n\tint retPre = 0;\n\n\tprivate int isBaEqual(String t, String p, int st){\n\t\tint clen = p.length();\n\t\tif(st >= stPre + p.length() - retPre && st < stPre + p.length())\n\t\t\tclen -= stPre + p.length() - st;\n\t\tfor(int i = 0; i < clen; i++){\n\t\t\tif(t.charAt(p.length() - 1 - i + st) != p.charAt(p.length() - 1 - i)){\n\t\t\t\tstPre = st;\n\t\t\t\tretPre = i;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tstPre = st;\n\t\tretPre = p.length();\n\t\treturn p.length();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal long b1 = 401;\n\tfinal long b2 = 397;\n\tfinal long h = 1000000007l;\n\tfinal int MAX_SIZE = 1000;\n\n\tint N, M, T, P, Q;\n\tchar[][] field, pattern;\n\tlong[][] hash, tmp;\n\tvoid computeHash(char[][] a, int n, int m) {\n\t\tlong t1 = 1;\n\t\tfor (int j = 0; j < Q; j++) t1 = (t1 * b1) % h;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong e = 0;\n\t\t\tfor (int j = 0; j < Q; j++) e = (e * b1 + a[i][j]) % h;\n\t\t\t\n\t\t\tfor (int j = 0; j + Q <= m; j++) {\n\t\t\t\ttmp[i][j] = e;\n\t\t\t\tif (j + Q < m) e = (e * b1 - t1 * a[i][j] + a[i][j + Q]) % h;\n\t\t\t\te = (e < 0) ? e + h : e;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong t2 = 1;\n\t\tfor (int i = 0; i < P; i++) t2 = (t2 * b2) % h;\n\t\t\n\t\tfor (int j = 0; j + Q <= m; j++) {\n\t\t\tlong e = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < P; i++) e = (e * b2 + tmp[i][j]) % h;\n\t\t\t\n\t\t\tfor (int i = 0; i + P <= n; i++) {\n\t\t\t\thash[i][j] = e;\n\t\t\t\tif (i + P < n) e = (e * b2 - t2 * tmp[i][j] + tmp[i + P][j]) % h;\n\t\t\t\te = (e < 0) ? e + h : e;\n\t\t\t}\n\t\t}\n\t}\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfield   = new char[MAX_SIZE][MAX_SIZE];\n\t\tpattern = new char[MAX_SIZE][MAX_SIZE];\n\t\thash = new long[MAX_SIZE][MAX_SIZE];\n\t\ttmp  = new long[MAX_SIZE][MAX_SIZE];\n\t\tN = scan.nextInt();\n\t\tM = scan.nextInt();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tchar[] line = scan.next().toCharArray();\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t\tfield[i][j] = line[j];\n\t\t}\n\t\tP = scan.nextInt();\n\t\tQ = scan.nextInt();\n\t\tfor (int i = 0; i < P; i++) {\n\t\t\tchar[] line = scan.next().toCharArray();\n\t\t\tfor (int j = 0; j < Q; j++)\n\t\t\t\tpattern[i][j] = line[j];\n\t\t}\n\t\tcomputeHash(pattern, P, Q);\n\t\tlong pHash = hash[0][0];\n\t\t\n\t\tcomputeHash(field, N, M);\n\t\tfor (int i = 0; i + P <= N; i++)\n\t\t\tfor (int j = 0; j + Q <= M; j++)\n\t\t\t\tif (hash[i][j] == pHash)\n\t\t\t\t\tsb.append(i + \" \" + j + \"\\n\");\n\t\t\n\t\tSystem.out.print(sb.toString());\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] hw = new char[h][];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\thw[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint r = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tchar[][] rc = new char[h][];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\trc[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tif (r > h || c > w) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal long B1 = 10_000;\n\t\tfinal long B2 = 20_000;\n\t\tfinal long MOD = 1_000_000_009;\n\t\tlong Bmr = 1;\n\t\tlong Bmc = 1;\n\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\tBmr *= B1;\n\t\t\tBmr %= MOD;\n\t\t}\n\t\tfor (int i = 0; i < c - 1; i++) {\n\t\t\tBmc *= B2;\n\t\t\tBmc %= MOD;\n\t\t}\n\n\n\t\tlong hs = 0;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tlong tmp = 0;\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\ttmp = tmp * B2 + rc[i][j];\n\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t\ths = hs * B1 + tmp;\n\t\t\ths %= MOD;\n\t\t}\n\n\n\t\tList<Pair> ans = new ArrayList<>();\n\t\tlong[] ht = new long[h];\n\t\tfor (int j = 0; j + c - 1 < w; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\t\tht[i] = ht[i] * B2 + hw[i][k];\n\t\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tht[i] -= Bmc * hw[i][j - 1];\n\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t\tif (ht[i] < 0) {\n\t\t\t\t\t\tht[i] += MOD;\n\t\t\t\t\t}\n\t\t\t\t\tht[i] = ht[i] * B2 + hw[i][j + c - 1];\n\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong hash = 0;\n\t\t\tfor (int i = 0; i + r - 1 < h; i++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\t\t\thash = hash * B1 + ht[k];\n\t\t\t\t\t\thash %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thash -= Bmr * ht[i - 1];\n\t\t\t\t\thash %= MOD;\n\t\t\t\t\tif (hash < 0) {\n\t\t\t\t\t\thash += MOD;\n\t\t\t\t\t}\n\t\t\t\t\thash = hash * B1 + ht[i + r - 1];\n\t\t\t\t\thash %= MOD;\n\t\t\t\t}\n\n\t\t\t\tif (hash == hs) {\n//\t\t\t\t\tpr.printf(\"%d %d\\n\", i, j);\n\t\t\t\t\tans.add(new Pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans);\n\n\t\tfor (Pair e : ans) {\n\t\t\tpr.printf(\"%d %d\\n\", e.a, e.b);\n\t\t}\n\t}\n\n\tprivate static class Pair implements Comparable<Pair> {\n\t\tint a;\n\t\tint b;\n\n\t\tPair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (a == o.a) {\n\t\t\t\treturn Integer.compare(b, o.b);\n\t\t\t}\n\t\t\treturn Integer.compare(a, o.a);\n\t\t}\n\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tboolean allSameChar = true;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(charType == 1 && pattern[0][0] != pattern[i][0]){\n\t\t\t\tallSameChar = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1 && allSameChar == true){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tString[] t = new String[h];\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tt[i] = scan.next();\n\n\t\tint r = scan.nextInt();\n\t\tint c = scan.nextInt();\n\t\tString[] p = new String[r];\n\t\tfor(int i = 0; i < r; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind{\n\tboolean debug;\n\n\tpublic PtFind(String[] t, String[] p, boolean d){\n\t\tdebug = d;\n\n\t\tboolean[][] jg = new boolean[t.length - p.length + 1][t[0].length() - p[0].length() + 1];\n\t\t//length????????????????´???°???length()??????????????°\n\t\tfor(int y = 0; y < jg.length; y++)\n\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\tjg[y][x] = true; //true?????£??\\??????\n\n\t\tfor(int r = 0; r < p.length; r++){\n\t\t\tStFind stf = new StFind(p[r], d);\n\t\t\tfor(int y = 0; y < jg.length; y++){\n\t\t\t\tboolean[] result = new boolean[jg[0].length];\n\t\t\t\tstf.find(t[y+r], p[r], result);\n\t\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\t\tjg[y][x] &= result[x];\n\t\t\t\t\t//a &= b??????a = a & b\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = 0; y < jg.length; y++)\n\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\tif(jg[y][x])\n\t\t\t\t\tSystem.out.println(y + \" \" + x);\n\t}\n}\n\n//\nclass StFind{\n\tboolean debug;\n\tint[] msft;\n\tint[] sft = new int[Character.MAX_CODE_POINT];\n\n\tpublic StFind(String p, boolean d){\n\t\tdebug = d;\n\t\tcreateMatchPt(p);\n\t}\n\n\tpublic void find(String t, String p, boolean[] result){\n\t\tint x = 0;\n\t\tfor(int st = 0; st < t.length() - p.length() + 1;){\n\t\t\tif((x = isBaEqual(t, p, st)) == p.length())\n\t\t\t\tresult[st] = true;\n\t\t\tst += msft[x];\n\t\t}\n\t}\n\n\tprivate void createMatchPt(String p){\n\t\tmsft = new int[p.length() + 1];\n\t\tmsft[0] = p.length();\n\n\t\tfor(int sft = p.length(); sft > 0; sft--){\n\t\t\tfor(int m = 1; m < msft.length; m++){\n\t\t\t\tif(m > p.length() - sft){\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(p.charAt(p.length() - m) != p.charAt(p.length() - m- sft)){\n\t\t\t\t\tmsft[m-1] = sft;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(m == p.length() -sft)\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t}\n\t\t}\n\n\t\tif(debug)\n\t\t\tfor(int i = 0; i < msft.length; i++)\n\t\t\t\tSystem.out.println(\"--- \" + i + \" : \" + msft[i]);\n\t}\n\n\t//\n\tint stPre = 0;\n\tint retPre = 0;\n\n\tprivate int isBaEqual(String t, String p, int st){\n\t\tint clen = p.length();\n\t\t/*if(st >= stPre + p.length() - retPre && st < stPre + p.length())\n\t\t\tclen -= stPre + p.length() - st;*/\n\t\tfor(int i = 0; i < clen; i++){\n\t\t\tif(t.charAt(p.length() - 1 - i + st) != p.charAt(p.length() - 1 - i)){\n\t\t\t\tstPre = st;\n\t\t\t\tretPre = i;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tstPre = st;\n\t\tretPre = p.length();\n\t\treturn p.length();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] hw = new char[h][];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\thw[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint r = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tchar[][] rc = new char[h][];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\trc[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tif (r > h || c > w) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal long B1 = 10_000;\n\t\tfinal long B2 = 10_000;\n\t\tfinal long MOD = 1_000_000_009;\n\t\tlong Bmr = 1;\n\t\tlong Bmc = 1;\n\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\tBmr *= B1;\n\t\t\tBmr %= MOD;\n\t\t}\n\t\tfor (int i = 0; i < c - 1; i++) {\n\t\t\tBmc *= B2;\n\t\t\tBmc %= MOD;\n\t\t}\n\n\n\t\tlong hs = 0;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tlong tmp = 0;\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\ttmp = tmp * B2 + rc[i][j];\n\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t\ths = hs * B1 + tmp;\n\t\t\ths %= MOD;\n\t\t}\n\n\n\t\tList<Pair> ans = new ArrayList<>();\n\t\tlong[] ht = new long[h];\n\t\tfor (int j = 0; j + c - 1 < w; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\t\tht[i] = ht[i] * B2 + hw[i][k];\n\t\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tht[i] -= Bmc * hw[i][j - 1];\n\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t\tif (ht[i] < 0) {\n\t\t\t\t\t\tht[i] += MOD;\n\t\t\t\t\t}\n\t\t\t\t\tht[i] = ht[i] * B2 + hw[i][j + c - 1];\n\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong hash = 0;\n\t\t\tfor (int i = 0; i + r - 1 < h; i++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\t\t\thash = hash * B1 + ht[k];\n\t\t\t\t\t\thash %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thash -= Bmr * ht[i - 1];\n\t\t\t\t\thash %= MOD;\n\t\t\t\t\tif (hash < 0) {\n\t\t\t\t\t\thash += MOD;\n\t\t\t\t\t}\n\t\t\t\t\thash = hash * B2 + ht[i + r - 1];\n\t\t\t\t\thash %= MOD;\n\t\t\t\t}\n\n\t\t\t\tif (hash == hs) {\n//\t\t\t\t\tpr.printf(\"%d %d\\n\", i, j);\n\t\t\t\t\tans.add(new Pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans);\n\n\t\tfor (Pair e : ans) {\n\t\t\tpr.printf(\"%d %d\\n\", e.a, e.b);\n\t\t}\n\t}\n\n\tprivate static class Pair implements Comparable<Pair> {\n\t\tint a;\n\t\tint b;\n\n\t\tPair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (a == o.a) {\n\t\t\t\treturn Integer.compare(b, o.b);\n\t\t\t}\n\t\t\treturn Integer.compare(a, o.a);\n\t\t}\n\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\treturn index;\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t//???????????????2????????????????????¨????°???¨??¢?????´?????????\n\t\telse if(isBinary){\n\t\t\t//System.out.println(\"BINARY\");\n\t\t\tint repeatLevel = repeatLevel(matrix);\n\t\t\t\n\t\t\t//System.out.println(\"REPEAT LEVEL \"+repeatLevel);\n\t\t\t\n\t\t\tif(repeatLevel == 2){\n\t\t\t\tboolean[][] isOK = new boolean[2][matrix[0].length];\n\t\t\t\t\n\t\t\t\tfor(int i = 0 ; i < 2; i++){\n\t\t\t\t\tArrays.fill(isOK[i], false);\n\t\t\t\t\tint sumOfIndex = 0;\n\t\t\t\t\tchar[] str1char = matrix[i];\n\t\t\t\t\tchar[] str2char = pattern[0];\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\t\t\tint index = BMSearcher.indexOf(str1char,str2char);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(index == -1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsumOfIndex += index;\n\t\t\t\t\t\tisOK[i][sumOfIndex] = true;\n\t\t\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\t\t\tsumOfIndex++;\n\t\t\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 2; i + r <= h ; i++){\n\t\t\t\t\tfor(int j = 0 ; j + c <= w ; j++){\n\t\t\t\t\t\tif(isOK[i%2][j]){\n\t\t\t\t\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic boolean isBinary = false;\n\t//static int repeatLevel = -1;\n\t\n\tstatic int repeatLevel(char[][] matrix) {\n\t\tboolean rLevel1 = true;\n\t\tboolean rLevel2 = true;\n\t\t\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tif(i >= 1 && rLevel1 == true && !Arrays.equals(matrix[i], matrix[i-1])){\n\t\t\t\trLevel1 = false;\n\t\t\t}\n\t\t\tif(i >= 2 && rLevel2 == true && !Arrays.equals(matrix[i], matrix[i-2])){\n\t\t\t\trLevel2 = false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!rLevel1 && !rLevel2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(rLevel1){\n\t\t\treturn  1;\n\t\t}\n\t\telse if(rLevel2){\n\t\t\treturn  2;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tboolean allSameChar = true;\n\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(charType == 1 && pattern[0][0] != pattern[i][0]){\n\t\t\t\tallSameChar = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(charType == 2){\n\t\t\tisBinary = true;\n\t\t}\n\t\t\n\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1 && allSameChar == true){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t//???????????????2????????????????????¨????°???¨??¢?????´?????????\n\t\telse if(isBinary){\n\t\t\t//System.out.println(\"BINARY\");\n\t\t\tint repeatLevel = repeatLevel(matrix);\n\t\t\t\n\t\t\t//System.out.println(\"REPEAT LEVEL \"+repeatLevel);\n\t\t\t\n\t\t\tif(repeatLevel == 2){\n\t\t\t\tboolean[][] isOK = new boolean[2][matrix[0].length];\n\t\t\t\t\n\t\t\t\tfor(int i = 0 ; i < 2; i++){\n\t\t\t\t\tArrays.fill(isOK[i], false);\n\t\t\t\t\tint sumOfIndex = 0;\n\t\t\t\t\tchar[] str1char = matrix[i];\n\t\t\t\t\tchar[] str2char = pattern[0];\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\t\t\tint index = BMSearcher.indexOf(str1char,str2char);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(index == -1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsumOfIndex += index;\n\t\t\t\t\t\tisOK[i][sumOfIndex] = true;\n\t\t\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\t\t\tsumOfIndex++;\n\t\t\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 2; i + r <= h ; i++){\n\t\t\t\t\tfor(int j = 0 ; j + c <= w ; j++){\n\t\t\t\t\t\tif(isOK[i%2][j]){\n\t\t\t\t\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint vRepeat = verticalRepeat(matrix);\n\t\t\t//System.out.println(\"vertical repeat \"+vRepeat);\n\t\t\t\n\t\t\tif(vRepeat == 1){\n\t\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\t\tif(Arrays.equals(pattern[0], Arrays.copyOf(matrix[i], c))){\n\t\t\t\t\t\tif(isMatch(matrix, pattern, i, 0)){\n\t\t\t\t\t\t\t//System.out.println(\"HIT \" + i + \" 0\");\n\t\t\t\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic boolean isBinary = false;\n\t//static int repeatLevel = -1;\n\t\n\tstatic int verticalRepeat(char[][] matrix){\n\t\tboolean rLevel1 = true;\n\t\t\n\t\tfor(int j = 1; j < matrix[0].length ; j++){\n\t\t\tfor(int i = 0 ; i < matrix.length ; i++){\n\t\t\t\tif(matrix[i][j] != matrix[i][j-1]){\n\t\t\t\t\trLevel1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(rLevel1 == false){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(rLevel1) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tstatic int repeatLevel(char[][] matrix) {\n\t\tboolean rLevel1 = true;\n\t\tboolean rLevel2 = true;\n\t\t\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tif(i >= 1 && rLevel1 == true && !Arrays.equals(matrix[i], matrix[i-1])){\n\t\t\t\trLevel1 = false;\n\t\t\t}\n\t\t\tif(i >= 2 && rLevel2 == true && !Arrays.equals(matrix[i], matrix[i-2])){\n\t\t\t\trLevel2 = false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!rLevel1 && !rLevel2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(rLevel1){\n\t\t\treturn  1;\n\t\t}\n\t\telse if(rLevel2){\n\t\t\treturn  2;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tboolean allSameChar = true;\n\t\tboolean all0or1 = true;\n\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\t\n//\t\t\tif(tmp == 1 && pattern[i][0] != '0' && pattern[i][0] != '1'){\n//\t\t\t\tall0or1 = false;\n//\t\t\t}\n\t\t\t\n\t\t\tif(charType == 1 && pattern[0][0] != pattern[i][0]){\n\t\t\t\tallSameChar = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(charType == 2){\n\t\t\tisBinary = true;\n\t\t}\n\t\t\n\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1 && allSameChar == true){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] hw = new char[h][];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\thw[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tint r = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tchar[][] rc = new char[r][];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\trc[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tif (r > h || c > w) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal long B1 = 10_000;\n\t\tfinal long B2 = 20_000;\n\t\tfinal long MOD = 1_000_000_009;\n\t\tlong Bmr = 1;\n\t\tlong Bmc = 1;\n\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\tBmr *= B1;\n\t\t\tBmr %= MOD;\n\t\t}\n\t\tfor (int i = 0; i < c - 1; i++) {\n\t\t\tBmc *= B2;\n\t\t\tBmc %= MOD;\n\t\t}\n\n\n\t\tlong hs = 0;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tlong tmp = 0;\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\ttmp = tmp * B2 + rc[i][j];\n\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t\ths = hs * B1 + tmp;\n\t\t\ths %= MOD;\n\t\t}\n\n\n\t\tList<Pair> ans = new ArrayList<>();\n\t\tlong[] ht = new long[h];\n\t\tfor (int j = 0; j + c - 1 < w; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\t\tht[i] = ht[i] * B2 + hw[i][k];\n\t\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tht[i] -= Bmc * hw[i][j - 1];\n\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t\tif (ht[i] < 0) {\n\t\t\t\t\t\tht[i] += MOD;\n\t\t\t\t\t}\n\t\t\t\t\tht[i] = ht[i] * B2 + hw[i][j + c - 1];\n\t\t\t\t\tht[i] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong hash = 0;\n\t\t\tfor (int i = 0; i + r - 1 < h; i++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tfor (int k = 0; k < r; k++) {\n\t\t\t\t\t\thash = hash * B1 + ht[k];\n\t\t\t\t\t\thash %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thash -= Bmr * ht[i - 1];\n\t\t\t\t\thash %= MOD;\n\t\t\t\t\tif (hash < 0) {\n\t\t\t\t\t\thash += MOD;\n\t\t\t\t\t}\n\t\t\t\t\thash = hash * B1 + ht[i + r - 1];\n\t\t\t\t\thash %= MOD;\n\t\t\t\t}\n\n\t\t\t\tif (hash == hs) {\n//\t\t\t\t\tpr.printf(\"%d %d\\n\", i, j);\n\t\t\t\t\tans.add(new Pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans);\n\n\t\tfor (Pair e : ans) {\n\t\t\tpr.printf(\"%d %d\\n\", e.a, e.b);\n\t\t}\n\t}\n\n\tprivate static class Pair implements Comparable<Pair> {\n\t\tint a;\n\t\tint b;\n\n\t\tPair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (a == o.a) {\n\t\t\t\treturn Integer.compare(b, o.b);\n\t\t\t}\n\t\t\treturn Integer.compare(a, o.a);\n\t\t}\n\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tString[] t = new String[h];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tt[i] = scan.next();\n\n\t\tint r = scan.nextInt();\n\t\tint c = scan.nextInt();\n\t\tString[] p = new String[r];\n\t\tfor (int i = 0; i < r; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind {\n\tboolean debug;\n\n\tpublic PtFind(String[] t, String[] p, boolean d) {\n\t\tdebug = d;\n\n\t\tboolean[][] jg = new boolean[t.length - p.length + 1][t[0].length() - p[0].length() + 1];\n\t\tfor (int y = 0; y < jg.length; y++)\n\t\t\tfor (int x = 0; x < jg[0].length; x++)\n\t\t\t\tjg[y][x] = true;\n\n\t\tfor (int r = 0; r < p.length; r++) {\n\t\t\tStFind stf = new StFind(p[r], d);\n\t\t\tfor (int y = 0; y < jg.length; y++) {\n\t\t\t\tboolean[] result = new boolean[jg[0].length];\n\t\t\t\tstf.find(t[y + r], p[r], result);\n\t\t\t\tfor (int x = 0; x < jg[0].length; x++)\n\t\t\t\t\tjg[y][x] &= result[x];\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < jg.length; y++)\n\t\t\tfor (int x = 0; x < jg[0].length; x++)\n\t\t\t\tif (jg[y][x])\n\t\t\t\t\tSystem.out.println(y + \" \" + x);\n\t}\n\n}\n\nclass StFind {\n\tboolean debug;\n\n\tpublic StFind(String p, boolean d) {\n\t\tdebug = d;\n\t\t// createCharPt(p);\n\t\tcreateMatchPt(p);\n\t}\n\n\tpublic void find(String t, String p, boolean[] result) {\n\t\tint x = 0;\n\t\tfor (int st = 0; st < t.length() - p.length() + 1;) {\n\t\t\tif ((x = isBaEqual(t, p, st)) == p.length())\n\t\t\t\t// System.out.println(st);\n\t\t\t\tresult[st] = true;\n\t\t\t// st += Math.max(sft[t.charAt(st + p.length() - 1)], msft[x]);\n\t\t\tst += msft[x];\n\t\t}\n\t}\n\n\tint[] msft;\n\n\tprivate void createMatchPt(String p) {\n\t\tmsft = new int[p.length() + 1];\n\t\tmsft[0] = p.length();\n\n\t\tfor (int sft = p.length(); sft > 0; sft--) {\n\t\t\tfor (int m = 1; m < msft.length; m++) {\n\t\t\t\tif (m > p.length() - sft) {\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p.charAt(p.length() - m) != p.charAt(p.length() - m - sft)) {\n\t\t\t\t\tmsft[m - 1] = sft;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (m == p.length() - sft)\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t}\n\t\t}\n\n\t\tif (debug)\n\t\t\tfor (int i = 0; i < msft.length; i++)\n\t\t\t\tSystem.out.println(\"--- \" + i + \" : \" + msft[i]);\n\t}\n\n\tint[] sft = new int[Character.MAX_CODE_POINT];\n\n\tprivate void createCharPt(String p) {\n\t\tfor (int i = 0; i < sft.length; i++)\n\t\t\tsft[i] = p.length();\n\n\t\tfor (int i = 1; i < p.length(); i++) {\n\t\t\tchar c = p.charAt(p.length() - i - 1);\n\t\t\tif (sft[c] == p.length())\n\t\t\t\tsft[c] = i;\n\t\t}\n\n\t\tif (debug)\n\t\t\tfor (int i = 0; i < sft.length; i++)\n\t\t\t\tif (('a' <= i && i <= 'z') || ('A' <= i && i <= 'Z') || ('0' <= i && i <= '9'))\n\t\t\t\t\tSystem.out.println(\"-- \" + (char) i + \" : \" + sft[i]);\n\t}\n\n\tprivate boolean isEqual(String t, String p, int st) {\n\t\tfor (int i = 0; i < p.length(); i++)\n\t\t\tif (t.charAt(i + st) != p.charAt(i))\n\t\t\t\treturn false;\n\t\treturn true;\n\n\t}\n\n\tint stPre = 0;\n\tint retPre = 0;\n\n\tprivate int isBaEqual(String t, String p, int st) {\n\t\tint clen = p.length();\n\t\tif (st >= stPre + p.length() - retPre && st < stPre + p.length())\n\t\t\tclen -= stPre + p.length() - st;\n\t\tfor (int i = 0; i < clen; i++)\n\t\t\tif (t.charAt(p.length() - 1 - i + st) != p.charAt(p.length() - 1 - i)) {\n\t\t\t\tstPre = st;\n\t\t\t\tretPre = i;\n\t\t\t\treturn i;\n\t\t\t}\n\t\tstPre = st;\n\t\tretPre = p.length();\n\t\treturn p.length();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\treturn index;\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[0], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\tString[] t = new String[h];\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tt[i] = scan.next();\n\n\t\tint r = scan.nextInt();\n\t\tint c = scan.nextInt();\n\t\tString[] p = new String[r];\n\t\tfor(int i = 0; i < r; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind{\n\tboolean debug;\n\n\tpublic PtFind(String[] t, String[] p, boolean d){\n\t\tdebug = d;\n\n\t\tboolean[][] jg = new boolean[t.length - p.length + 1][t[0].length() - p[0].length() + 1];\n\t\t//length????????????????´???°???length()??????????????°\n\t\tfor(int y = 0; y < jg.length; y++)\n\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\tjg[y][x] = true; //true?????£??\\??????\n\n\t\tfor(int r = 0; r < p.length; r++){\n\t\t\tStFind stf = new StFind(p[r], d);\n\t\t\tfor(int y = 0; y < jg.length; y++){\n\t\t\t\tboolean[] result = new boolean[jg[0].length];\n\t\t\t\tstf.find(t[y+r], p[r], result);\n\t\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\t\tjg[y][x] &= result[x];\n\t\t\t\t\t//a &= b??????a = a & b\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = 0; y < jg.length; y++)\n\t\t\tfor(int x = 0; x < jg[0].length; x++)\n\t\t\t\tif(jg[y][x])\n\t\t\t\t\tSystem.out.println(y + \" \" + x);\n\t}\n}\n\n//\nclass StFind{\n\tboolean debug;\n\tint[] msft;\n\tint[] sft = new int[Character.MAX_CODE_POINT];\n\n\tpublic StFind(String p, boolean d){\n\t\tdebug = d;\n\t\tcreateMatchPt(p);\n\t}\n\n\tpublic void find(String t, String p, boolean[] result){\n\t\tint x = 0;\n\t\tfor(int st = 0; st < t.length() - p.length() + 1;){\n\t\t\tif((x = isBaEqual(t, p, st)) == p.length())\n\t\t\t\tresult[st] = true;\n\t\t\tst += msft[x];\n\t\t}\n\t}\n\n\tprivate void createMatchPt(String p){\n\t\tmsft = new int[p.length() + 1];\n\t\tmsft[0] = p.length();\n\n\t\tfor(int sft = p.length(); sft > 0; sft--){\n\t\t\tfor(int m = 1; m < msft.length; m++){\n\t\t\t\tif(m > p.length() - sft){\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(p.charAt(p.length() - m) != p.charAt(p.length() - m- sft)){\n\t\t\t\t\tmsft[m-1] = sft;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(m == p.length() -sft)\n\t\t\t\t\tmsft[m] = sft;\n\t\t\t}\n\t\t}\n\n\t\tif(debug)\n\t\t\tfor(int i = 0; i < msft.length; i++)\n\t\t\t\tSystem.out.println(\"--- \" + i + \" : \" + msft[i]);\n\t}\n\n\t//\n\tint stPre = 0;\n\tint retPre = 0;\n\n\tprivate int isBaEqual(String t, String p, int st){\n\t\tint clen = p.length();\n\t\tint stlen = stPre + p.length();\n\t\tif(st >= stlen - retPre && st < stlen){\n\t\t\tclen -= stlen - st;\n\t\t}\n\t\t/*\n\t\tif(st >= stPre + p.length() - retPre && st < stPre + p.length()){\n\t\t\n\t\t\tclen -= stPre + p.length() - st;\n\t\t}\n\t\t*/\n\t\tfor(int i = 0; i < clen; i++){\n\t\t\tif(t.charAt(p.length() - 1 - i + st) != p.charAt(p.length() - 1 - i)){\n\t\t\t\tstPre = st;\n\t\t\t\tretPre = i;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tstPre = st;\n\t\tretPre = p.length();\n\t\treturn p.length();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t//???????????????2????????????????????¨????°???¨??¢?????´?????????\n\t\telse if(isBinary){\n\t\t\t//System.out.println(\"BINARY\");\n\t\t\t//System.out.println(\"REPEAT LEVEL \"+repeatLevel);\n\t\t\t\n\t\t\tif(repeatLevel == 2){\n\t\t\t\tboolean[][] isOK = new boolean[2][matrix[0].length];\n\t\t\t\t\n\t\t\t\tfor(int i = 0 ; i < 2; i++){\n\t\t\t\t\tArrays.fill(isOK[i], false);\n\t\t\t\t\tint sumOfIndex = 0;\n\t\t\t\t\tchar[] str1char = matrix[i];\n\t\t\t\t\tchar[] str2char = pattern[0];\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\t\t\tint index = BMSearcher.indexOf(str1char,str2char);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(index == -1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsumOfIndex += index;\n\t\t\t\t\t\tisOK[i][sumOfIndex] = true;\n\t\t\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\t\t\tsumOfIndex++;\n\t\t\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 2; i + r <= h ; i++){\n\t\t\t\t\tfor(int j = 0 ; j + c <= w ; j++){\n\t\t\t\t\t\tif(isOK[i%2][j]){\n\t\t\t\t\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic boolean isBinary = false;\n\tstatic int repeatLevel = -1;\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tboolean allSameChar = true;\n\t\tboolean rLevel1 = true;\n\t\tboolean rLevel2 = true;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\tif(i >= 1 && rLevel1 == true && !Arrays.equals(pattern[i], pattern[i-1])){\n\t\t\t\trLevel1 = false;\n\t\t\t}\n\t\t\tif(i >= 2 && rLevel2 == true && !Arrays.equals(pattern[i], pattern[i-2])){\n\t\t\t\trLevel2 = false;\n\t\t\t}\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(charType == 1 && pattern[0][0] != pattern[i][0]){\n\t\t\t\tallSameChar = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(charType == 2){\n\t\t\tisBinary = true;\n\t\t}\n\t\t\n\t\tif(rLevel1){\n\t\t\trepeatLevel = 1;\n\t\t}\n\t\telse if(rLevel2){\n\t\t\trepeatLevel = 2;\n\t\t}\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1 && allSameChar == true){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t//???????????????2????????????????????¨????°???¨??¢?????´?????????\n\t\telse if(isBinary){\n\t\t\tSystem.out.println(\"BINARY\");\n\t\t\tSystem.out.println(\"REPEAT LEVEL \"+repeatLevel);\n\t\t\t\n\t\t\tif(repeatLevel == 2){\n\t\t\t\tboolean[][] isOK = new boolean[2][matrix[0].length];\n\t\t\t\t\n\t\t\t\tfor(int i = 0 ; i < 2; i++){\n\t\t\t\t\tArrays.fill(isOK[i], false);\n\t\t\t\t\tint sumOfIndex = 0;\n\t\t\t\t\tchar[] str1char = matrix[i];\n\t\t\t\t\tchar[] str2char = pattern[0];\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\t\t\tint index = BMSearcher.indexOf(str1char,str2char);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(index == -1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsumOfIndex += index;\n\t\t\t\t\t\tisOK[i][sumOfIndex] = true;\n\t\t\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\t\t\tsumOfIndex++;\n\t\t\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 2; i + r <= h ; i++){\n\t\t\t\t\tfor(int j = 0 ; j + c <= w ; j++){\n\t\t\t\t\t\tif(isOK[i%2][j]){\n\t\t\t\t\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\tSystem.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic boolean isBinary = false;\n\tstatic int repeatLevel = -1;\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tboolean allSameChar = true;\n\t\tboolean rLevel1 = true;\n\t\tboolean rLevel2 = true;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\tif(i >= 1 && rLevel1 == true && !Arrays.equals(pattern[i], pattern[i-1])){\n\t\t\t\trLevel1 = false;\n\t\t\t}\n\t\t\tif(i >= 2 && rLevel2 == true && !Arrays.equals(pattern[i], pattern[i-2])){\n\t\t\t\trLevel2 = false;\n\t\t\t}\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(charType == 1 && pattern[0][0] != pattern[i][0]){\n\t\t\t\tallSameChar = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(charType == 2){\n\t\t\tisBinary = true;\n\t\t}\n\t\t\n\t\tif(rLevel1){\n\t\t\trepeatLevel = 1;\n\t\t}\n\t\telse if(rLevel2){\n\t\t\trepeatLevel = 2;\n\t\t}\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1 && allSameChar == true){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(tmpArray[0]);\n\t\tint w = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] matrix = new char[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tmatrix[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint r = Integer.parseInt(tmpArray[0]);\n\t\tint c = Integer.parseInt(tmpArray[1]);\n\n\t\tchar[][] pattern = new char[r][c];\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tString tmpStr = br.readLine();\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tpattern[i][j] = tmpStr.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint complexRow = complexRow(pattern);\n\t\t//???????????????1????????????????????´???????°???¨??¢?????´?????????\n\t\tif(complexRow == -1){\n\t\t\t//System.out.println(\"only \"+(char)pattern[0][0] +\" included\");\n\t\t\t\n\t\t\tArrayList<Point> plist = illegularList(matrix, pattern[0][0]);\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\t\tfor(int j = 0; j + c <= w ; j++){\n\t\t\t\t\tboolean notPattern = false;\n\t\t\t\t\tfor(int k = 0; k < plist.size() ; k++){\n\t\t\t\t\t\tint x = plist.get(k).x;\n\t\t\t\t\t\tint y = plist.get(k).y;\n\t\t\t\t\t\tif(y >= i && y < i + r && x >= j && x < j + c){\n\t\t\t\t\t\t\tnotPattern = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!notPattern){\n\t\t\t\t\t\t//System.out.println(i+\" \"+j);\n\t\t\t\t\t\tsb.append(i+\" \"+j+\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//??¢?´¢????§?\n\t\tfor(int i = 0; i + r <= h ; i++){\n\t\t\tchar[] str1char = Arrays.copyOf(matrix[i+complexRow], w);\n\t\t\tchar[] str2char = Arrays.copyOf(pattern[complexRow], c);\n\t\t\tint sumOfIndex = 0;\n\t\t\twhile(true){\n\t\t\t\t//System.out.println(\"str1 \" + new String(str1char) + \"str2 \"+ new String(str2char));\n\t\t\t\tint index = BMSearcher.indexOf(str1char, str2char);\n\t\t\t\t\n\t\t\t\tif(index == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsumOfIndex += index;\n\t\t\t\t//System.out.println(sumOfIndex);\n\t\t\t\tif(isMatch(matrix, pattern, i, sumOfIndex)){\n\t\t\t\t\t//System.out.println(i+\" \"+sumOfIndex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstr1char = Arrays.copyOfRange(str1char, index + 1, str1char.length);\n\t\t\t\tsumOfIndex++;\n\t\t\t\tif(str1char.length == 0 || str1char.length < str2char.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Point> illegularList (char[][] matrix, char pchar){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tfor(int i = 0; i < matrix.length ;i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pchar){\n\t\t\t\t\t//System.out.println(\"illegal \"+i + \" \"+j);\n\t\t\t\t\tlist.add(new Point(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t}\n\t\n\tstatic int complexRow (char[][] pattern){\n\t\tint charType = 0;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\tint tmp = countCharType(pattern[i]);\n\t\t\t\n\t\t\t//??£??´???????????????????????°??????\n\t\t\tif(tmp >= 5){\n\t\t\t\t//System.out.println(\"enough at \"+i);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse if (tmp > charType){\n\t\t\t\tcharType = tmp;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"max charType = \"+charType);\n\t\tif(charType == 1){\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn index;\n\t\t}\n\t}\n\t\n\tstatic int countCharType(char[] str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tfor(int i = 0; i < str.length ; i++){\n\t\t\tchar tmp = str[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic int countCharType(String str){\n\t\tint[] countArray = new int[255];\n\t\tint count = 0;\n\t\t\n\t\tchar[] strChar = str.toCharArray();\n\t\t\n\t\tfor(int i = 0; i < strChar.length ; i++){\n\t\t\tchar tmp = strChar[i];\n\t\t\tif(countArray[tmp] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcountArray[tmp]++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tstatic boolean isMatch(char[][] matrix, char[][] pattern, int y, int x){\n\t\tfor(int i = y; i < y + pattern.length ; i++){\n\t\t\tfor(int j = x; j < x + pattern[0].length ; j++){\n\t\t\t\tif(matrix[i][j] != pattern[i - y][j - x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\t\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int mapH = int.Parse(input[0]);\n\n            string[] map = new string[mapH];\n\n            for (int i = 0; i < mapH; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            input = Console.ReadLine().Split(' ');\n            int patH = int.Parse(input[0]);\n            int patW = int.Parse(input[1]);\n\n            string[] pat = new string[patH];\n\n            for (int i = 0; i < patH; i++)\n            {\n                pat[i] = Console.ReadLine();\n            }\n\n            BoyerMoore BM = new BoyerMoore();\n\n            List<int> candidateIndex;\n            int max = mapH - patH;\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i <= max; i++)\n            {\n                candidateIndex = BM.SearchString(map[i], pat[0]);\n\n                foreach (var index in candidateIndex)\n                {\n                    bool isSame = true;\n\n                    for (int j = 0; j < patH; j++)\n                    {\n                        if (!isSame) continue;\n\n                        var str = map[i + j].Skip(index).Take(patW);\n\n                        if (!str.SequenceEqual(pat[j]))\n                        {\n                            isSame = false;\n                            break;\n                        }\n                    }\n                    if (isSame) sb.AppendLine(i + \" \" + index);\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class BoyerMoore\n    {\n        public List<int> SearchString(string text, string pattern)\n        {\n            List<int> ret = new List<int>();\n\n            if (pattern.Length == 0) return ret;\n\n            int[] charTable = MakeCharTable(pattern);\n            int[] offsetTable = MakeOffsetTable(pattern);\n\n            int i = pattern.Length - 1, j;\n\n            while (i < text.Length)\n            {\n                for (j = pattern.Length - 1; pattern[j] == text[i]; i--, j--)\n                {\n                    if (j == 0)\n                    {\n                        ret.Add(i);\n                        break;\n                    }\n                }\n\n                i += Math.Max(offsetTable[pattern.Length - 1 - j], charTable[text[i]]);\n            }\n            return ret;\n        }\n\n        private int[] MakeCharTable(string pattern)\n        {\n            const int ALPHABET_SIZE = 256;\n\n            int[] table = new int[ALPHABET_SIZE];\n\n            for (int i = 0; i < table.Length; i++)\n            {\n                table[i] = pattern.Length;\n            }\n\n            for (int i = 0; i < pattern.Length - 1; i++)\n            {\n                table[pattern[i]] = pattern.Length - 1 - i;\n            }\n            return table;\n        }\n\n        private int[] MakeOffsetTable(string pattern)\n        {\n            int[] table = new int[pattern.Length];\n\n            int lastPrefixPosition = pattern.Length;\n            int plen = pattern.Length - 1;\n\n            for (int i = plen; i >= 0; i--)\n            {\n                if (IsPrefix(pattern, i + 1)) lastPrefixPosition = i + 1;\n\n                table[plen - i] = lastPrefixPosition - i + plen;\n            }\n\n            for (int i = 0; i < plen; i++)\n            {\n                int slen = SuffixLength(pattern, i);\n\n                table[slen] = plen - i + slen;\n            }\n            return table;\n        }\n\n        private bool IsPrefix(string pattern, int p)\n        {\n            for (int i = p, j = 0; i < pattern.Length; i++, j++)\n            {\n                if (pattern[i] != pattern[j]) return false;\n            }\n            return true;\n        }\n\n        private int SuffixLength(string pattern, int p)\n        {\n            int len = 0;\n\n            for (int i = p, j = pattern.Length - 1; i >= 0 && pattern[i] == pattern[j]; i--, j--)\n            {\n                len++;\n            }\n            return len;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int mapH = int.Parse(input[0]);\n\n            string[] map = new string[mapH];\n\n            for (int i = 0; i < mapH; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            input = Console.ReadLine().Split(' ');\n            int patH = int.Parse(input[0]);\n            int patW = int.Parse(input[1]);\n\n            string[] pat = new string[patH];\n\n            for (int i = 0; i < patH; i++)\n            {\n                pat[i] = Console.ReadLine();\n            }\n\n            KMP kmp = new KMP();\n\n            List<int> candidateIndex;\n            int max = mapH - patH;\n\n            List<KeyValuePair<int, int>> ans = new List<KeyValuePair<int, int>>();\n\n            for (int i = max; i >= 0; i--)\n            {\n                candidateIndex = kmp.SearchString(map[i + patH - 1], pat[patH - 1]);\n\n                foreach (var index in candidateIndex)\n                {\n                    bool isSame = true;\n\n                    for (int j = patH - 2; j >= 0; j--)\n                    {\n                        if (!isSame) continue;\n\n                        var str = map[i + j].Skip(index).Take(patW);\n\n                        if (!str.SequenceEqual(pat[j]))\n                        {\n                            isSame = false;\n                            break;\n                        }\n                    }\n                    if (isSame) ans.Add(new KeyValuePair<int, int>(i, index));\n                }\n            }\n\n            ans = ans.OrderBy(a => a.Key).ThenBy(a => a.Value).ToList();\n\n            StringBuilder sb = new StringBuilder();\n            foreach (var a in ans) sb.AppendLine(a.Key + \" \" + a.Value);\n            Console.Write(sb);\n        }\n    }\n\n    class KMP\n    {\n        int[] lps;\n\n        public List<int> SearchString(string text, string pattern)\n        {\n            List<int> ret = new List<int>();\n\n            int M = pattern.Length;\n            int N = text.Length;\n            int i = 0;\n            int j = 0;\n\n            ComputeLPS(pattern, M);\n\n            while (i < N)\n            {\n                if (pattern[j] == text[i])\n                {\n                    j++;\n                    i++;\n                }\n\n                if (j == M)\n                {\n                    ret.Add(i - j);\n                    j = lps[j - 1];\n                }\n\n                else if (i < N && pattern[j] != text[i])\n                {\n                    if (j != 0) j = lps[j - 1];\n                    else i++;\n                }\n            }\n\n            return ret;\n        }\n\n        private void ComputeLPS(string pattern, int M)\n        {\n            lps = new int[M];\n            lps[0] = 0;\n\n            int len = 0;\n            int i = 1;\n\n            while (i < M)\n            {\n                if (pattern[i] == pattern[len])\n                {\n                    len++;\n                    lps[i] = len;\n                    i++;\n                }\n                else\n                {\n                    if (len != 0)\n                    {\n                        len = lps[len - 1];\n                    }\n                    else\n                    {\n                        lps[i] = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n\n// arihon p333\nnamespace ALDS1_14_C\n{\n    class Program\n    {\n        static int H, W, R, C;\n        static char[][] field, pattern;\n        static ulong[,] hash, tmp;\n        static StringBuilder sb = new StringBuilder();\n\n        static void Main(string[] args)\n        {\n            var t = scan;\n            H = t[0]; W = t[1];\n            field = new char[H][];\n            hash = new ulong[H,W];\n            tmp = new ulong[H, W];\n\n            for (int i = 0; i < H; i++)\n            {\n                field[i] = Console.ReadLine().ToCharArray();\n            }\n\n            t = scan;\n            R = t[0]; C = t[1];\n            pattern = new char[R][];\n\n            for (int i = 0; i < R; i++)\n            {\n                pattern[i] = Console.ReadLine().ToCharArray();\n            }\n\n            solve();\n\n            Console.Write(sb);\n        }\n        static void solve()\n        {\n            if (R > H || C > W) return;\n\n            //??????????????????????????\\???????±???????\n            ulong HP;\n            compute_hash(pattern, R, C);\n            HP = hash[0, 0];\n\n            //?????????????????\\????????????????????????????¨????\n            compute_hash(field, H, W);\n            for (int i = 0; i + R <= H; i++)\n            {\n                for (int j = 0; j + C <= W; j++)\n                {\n                    if (HP == hash[i, j]) sb.AppendLine(i + \" \" + j);\n                }\n            }\n        }\n\n        //a??????R*C?????¨????????¢?????????????????\\????¨????\n        static void compute_hash(char[][] a, int n, int m)\n        {\n            const ulong B1 = 9973;\n            const ulong B2 = 100000007;\n\n            ulong t1 = 1; //B1???C???\n            for (int j = 0; j < C; j++) t1 *= B1;\n\n            //???????????????????????\\???????¨????\n            for (int i = 0; i < n; i++)\n            {\n                ulong e = 0;\n                for (int j = 0; j < C; j++) e = e * B1 + a[i][j];\n\n                for (int j = 0; j + C <= m; j++)\n                {\n                    tmp[i, j] = e;\n                    if (j + C < m) e = e * B1 - t1 * a[i][j] + a[i][j + C];\n                }\n            }\n\n            ulong t2 = 1; //B2??????\n            for (int i = 0; i < R; i++) t2 *= B2;\n\n            //???????????????????????\\???????¨????\n            for (int j = 0; j + C <= m ; j++)\n            {\n                ulong e = 0;\n                for (int i = 0; i < R; i++) e = e * B2 + tmp[i, j];\n\n                for (int i = 0; i + R <= n; i++)\n                {\n                    hash[i, j] = e;\n                    if (i + R < n) e = e * B2 - t2 * tmp[i, j] + tmp[i + R, j];\n                }\n            }\n\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n\n// arihon p333\nnamespace ALDS1_14_C\n{\n    class Program\n    {\n        static int H, W, R, C;\n        static char[][] field, pattern;\n        static ulong[,] hash, tmp;\n        static StringBuilder sb = new StringBuilder();\n\n        static void Main(string[] args)\n        {\n            var t = scan;\n            H = t[0]; W = t[1];\n            field = new char[H][];\n            hash = new ulong[H,W];\n            tmp = new ulong[H, W];\n\n            for (int i = 0; i < H; i++)\n            {\n                field[i] = Console.ReadLine().ToCharArray();\n            }\n\n            t = scan;\n            R = t[0]; C = t[1];\n            pattern = new char[R][];\n\n            for (int i = 0; i < R; i++)\n            {\n                pattern[i] = Console.ReadLine().ToCharArray();\n            }\n\n            solve();\n\n            Console.Write(sb);\n        }\n        static void solve()\n        {\n            //??????????????????????????\\???????±???????\n            ulong HP;\n            compute_hash(pattern, R, C);\n            HP = hash[0, 0];\n\n            //?????????????????\\????????????????????????????¨????\n            compute_hash(field, H, W);\n            for (int i = 0; i + R <= H; i++)\n            {\n                for (int j = 0; j + C <= W; j++)\n                {\n                    if (HP == hash[i, j]) sb.AppendLine(i + \" \" + j);\n                }\n            }\n        }\n\n        //a??????R*C?????¨????????¢?????????????????\\????¨????\n        static void compute_hash(char[][] a, int n, int m)\n        {\n            const ulong B1 = 9973;\n            const ulong B2 = 100000007;\n\n            ulong t1 = 1; //B1???C???\n            for (int j = 0; j < C; j++) t1 *= B1;\n\n            //???????????????????????\\???????¨????\n            for (int i = 0; i < n; i++)\n            {\n                ulong e = 0;\n                for (int j = 0; j < C; j++) e = e * B1 + a[i][j];\n\n                for (int j = 0; j + C <= m; j++)\n                {\n                    tmp[i, j] = e;\n                    if (j + C < m) e = e * B1 - t1 * a[i][j] + a[i][j + C];\n                }\n            }\n\n            ulong t2 = 1; //B2??????\n            for (int i = 0; i < R; i++) t2 *= B2;\n\n            //???????????????????????\\???????¨????\n            for (int j = 0; j + C <= m ; j++)\n            {\n                ulong e = 0;\n                for (int i = 0; i < R; i++) e = e * B2 + tmp[i, j];\n\n                for (int i = 0; i + R <= n; i++)\n                {\n                    hash[i, j] = e;\n                    if (i + R < n) e = e * B2 - t2 * tmp[i, j] + tmp[i + R, j];\n                }\n            }\n\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tvar h=new int[s[0]][];\n\t\tvar t=new string[s[0]];\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\th[i]=new int[s[1]];\n\t\t\tt[i]=sc.S;\n\t\t}\n\t\tvar r=sc.Ia;\n\t\tvar p=sc.Arr(r[0],()=>sc.S);\n\t\tAc ac=new Ac(p,'0','z');\n\t\tvar ra=new Rh(true);\n\t\tfor(int i = 0;i<r[0];i++) {ra+=ac.tp[i].n;}\n\t\tfor(int i = 0;i<s[0];i++) {ac.Match(t[i],(a,e)=>{h[i][a]=e.n;});}\n\t\tvar li=new List<int[]>();\n\t\tfor(int i = s[1]-1;i>=r[1]-1;i--) {\n\t\t\tvar rb=new Rh(true);\n\t\t\tfor(int j = 0;j<s[0];j++) {\n\t\t\t\tif(j<ra.d){rb+=h[j][i];}\n\t\t\t\telse{\n\t\t\t\t\trb-=h[j-ra.d][i];\n\t\t\t\t\trb+=h[j][i];\n\t\t\t\t}\n\t\t\t\tif(ra==rb){li.Add(new int[]{j+1-r[0],i+1-r[1]});}\n\t\t\t}\n\t\t}\n\t\tli=li.OrderBy(x=>x[0]).ThenBy(x=>x[1]).ToList();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<li.Count;i++) {sb.Append(li[i][0]).Append(\" \").Append(li[i][1]).Append(\"\\n\");}\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Ac{\n\tstatic private int o;\n\tprivate int n,cnt=1;\n\tprivate Nd root;\n\tpublic Nd[] tp;\n\tpublic class Nd{\n\t\tpublic Nd[] ar;\n\t\tpublic List<Nd> li=new List<Nd>();\n\t\tpublic Nd sx;\n\t\tpublic List<string> stl=new List<string>();\n\t\tpublic int c,l=0,n;\n\t\tpublic bool b=false;\n\t\tpublic Nd(int c,int l){this.c=c-o;this.l=l;}\n\t}\n\tpublic Ac(string[] t,int a,int z){\n\t\tn=z-a+1;\n\t\to=a;\n\t\troot=new Nd(a-1,0);\n\t\ttp=new Nd[t.Length];\n\t\tfor(int i = 0;i<t.Length;i++) {\n\t\t\tvar r=root;\n\t\t\tfor(int j = 0;j<t[i].Length;j++) {\n\t\t\t\tif(!r.b){r.ar=new Nd[n];r.b=true;}\n\t\t\t\tif(r.ar[t[i][j]-o]==null){r.li.Add(r=r.ar[t[i][j]-o]=new Nd(t[i][j],j+1));cnt++;}\n\t\t\t\telse{r=r.ar[t[i][j]-o];}\n\t\t\t}\n\t\t\ttp[i]=r;\n\t\t\tr.stl.Add(t[i]);\n\t\t}\n\t\tint p=1;\n\t\tvar qu=new Queue<Nd>();\n\t\tfor(int i = 0;i<root.li.Count;i++,p++) {\n\t\t\troot.li[i].sx=root;\n\t\t\tif(root.li[i].b){qu.Enqueue(root.li[i]);}\n\t\t\troot.li[i].n=p;\n\t\t}\n\t\twhile(qu.Count>0){\n\t\t\tvar e=qu.Dequeue();\n\t\t\tfor(int i = 0;i<e.li.Count;i++,p++) {\n\t\t\t\tvar r=e.sx;\n\t\t\t\twhile(r!=null&&(!r.b||r.ar[e.li[i].c]==null)){r=r.sx;}\n\t\t\t\te.li[i].sx=r!=null?r.ar[e.li[i].c]:root;\n\t\t\t\tif(e.li[i].sx.stl.Count>0){e.li[i].stl.AddRange(e.li[i].sx.stl);}\n\t\t\t\tif(e.li[i].b){qu.Enqueue(e.li[i]);}\n\t\t\t\te.li[i].n=p;\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Match(string t,Action<int,Nd> f){\n\t\tvar e=root;\n\t\tfor(int i = 0;i<t.Length;i++) {\n\t\t\twhile(e!=root&&(!e.b||e.ar[t[i]-o]==null)){e=e.sx;}\n\t\t\tif(e.ar[t[i]-o]!=null){e=e.ar[t[i]-o];}\n\t\t\tf(i,e);\n\t\t}\n\t}\n}\npublic struct Rh{\n\tstatic readonly private int[] mod={1073741783,1073741789};\n\tstatic readonly private int[] b={1007,1009};\n\tpublic long[] h;\n\tpublic int d;\n\tpublic Rh(bool b){\n\t\th=new long[]{0,0};\n\t\td=0;\n\t}\n\tpublic static Rh operator+(Rh a,int c){\n\t\tfor(int i=0;i<2;i++){a.h[i]=(a.h[i]*b[i]+c)%mod[i];}\n\t\ta.d++;\n\t\treturn a;\n\t}\n\tpublic static Rh operator-(Rh a,int c){\n\t\ta.d--;\n\t\tfor(int i=0;i<2;i++){a.h[i]=(a.h[i]+mod[i]-(Fp(b[i],a.d,mod[i])*c%mod[i]))%mod[i];}\n\t\treturn a;\n\t}\n\tpublic static bool operator==(Rh a,Rh b){return a.h[0]==b.h[0]&&a.h[1]==b.h[1]&&a.d==b.d;}\n\tpublic static bool operator!=(Rh a,Rh b){return a.h[0]!=b.h[0]||a.h[1]!=b.h[1]||a.d!=b.d;}\n\tpublic override bool Equals(object obj){return false;}\n\tpublic override int GetHashCode(){return 0;}\n\tprivate static long Fp(long x,long e,int mod){\n\t\tlong r=1;\n\t\twhile(e>0){\n\t\t\tif((e&1)>0){r*=x;r%=mod;}\n\t\t\tx=(x*x)%mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn r;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int mapH = int.Parse(input[0]);\n\n            string[] map = new string[mapH];\n\n            for (int i = 0; i < mapH; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            input = Console.ReadLine().Split(' ');\n            int patH = int.Parse(input[0]);\n            int patW = int.Parse(input[1]);\n\n            string[] pat = new string[patH];\n\n            for (int i = 0; i < patH; i++)\n            {\n                pat[i] = Console.ReadLine();\n            }\n\n            KMP kmp = new KMP();\n\n            List<int> candidateIndex;\n            int max = mapH - patH;\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = max; i >= 0; i--)\n            {\n                candidateIndex = kmp.SearchString(map[i], pat[patH - 1]);\n\n                foreach (var index in candidateIndex)\n                {\n                    bool isSame = true;\n\n                    for (int j = patH - 2; j >= 0; j--)\n                    {\n                        if (!isSame) continue;\n\n                        for (int k = 0; k < patW; k++)\n                        {\n                            if (map[i + j][index + k] != pat[j][k])\n                            {\n                                isSame = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (isSame) sb.Insert(0, i + \" \" + index + \"\\n\");\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class KMP\n    {\n        int[] lps;\n\n        public List<int> SearchString(string text, string pattern)\n        {\n            List<int> ret = new List<int>();\n\n            int M = pattern.Length;\n            int N = text.Length;\n            int i = 0;\n            int j = 0;\n\n            ComputeLPS(pattern, M);\n\n            while (i < N)\n            {\n                if (pattern[j] == text[i])\n                {\n                    j++;\n                    i++;\n                }\n\n                if (j == M)\n                {\n                    ret.Add(i - j);\n                    j = lps[j - 1];\n                }\n\n                else if (i < N && pattern[j] != text[i])\n                {\n                    if (j != 0) j = lps[j - 1];\n                    else i++;\n                }\n            }\n\n            return ret;\n        }\n\n        private void ComputeLPS(string pattern, int M)\n        {\n            lps = new int[M];\n            lps[0] = 0;\n\n            int len = 0;\n            int i = 1;\n\n            while (i < M)\n            {\n                if (pattern[i] == pattern[len])\n                {\n                    len++;\n                    lps[i] = len;\n                    i++;\n                }\n                else\n                {\n                    if (len != 0)\n                    {\n                        len = lps[len - 1];\n                    }\n                    else\n                    {\n                        lps[i] = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace ALDS1_14_C\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int[] line = ReadIntAr();\n            char[,] target = new char[line[0],line[1]];\n            for (int i = 0 ; i < line[0] ; i++)\n            {\n                string item = ReadSt();\n                for (int j = 0 ; j < line[1] ; j++)\n                {\n                    target[i,j] = item[j];\n                }            \n            }\n\n            int[] line2 = ReadIntAr();\n            char[,] pattern = new char[line2[0],line2[1]];\n            for (int i = 0 ; i < line2[0] ; i++)\n            {\n                string item = ReadSt();\n                for (int j = 0 ; j < line2[1] ; j++)\n                {\n                    pattern[i, j] = item[j];\n                }\n            }\n\n            StringSearch ss = new StringSearch();\n            StringBuilder sb = new StringBuilder();\n\n            ss.PatternMatch(target, pattern, sb);\n            Console.Write(sb);\n\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\n\nnamespace CompProgLib\n{\n    public class StringSearch\n    {\n        \n        public void PatternMatch(char[,] target, char[,] pattern, StringBuilder sb)\n        {\n\n            const long B1 = 100000007;\n            const long B2 = 100000009;\n\n            int tRowCnt = target.GetLength(0);\n            int pRowCnt = pattern.GetLength(0);\n            int tColCnt = target.GetLength(1);\n            int pColCnt = pattern.GetLength(1);\n\n            if (pRowCnt > tRowCnt || pColCnt > tColCnt) return;\n\n            //パターンのハッシュ値\n            long pHash = 0;\n            long[] tmp = new long[pRowCnt];\n\n            for (int i = 0 ; i < pRowCnt ; i++)\n            {\n                for (int j = 0 ; j < pColCnt ; j++)\n                {\n                    tmp[i] = tmp[i] * B1 + pattern[i, j];\n                }\n            }\n\n            for (int i = 0 ; i < pRowCnt ; i++) pHash = pHash * B2 + tmp[i];\n\n            //ターゲットのハッシュ値\n\n            long t1 = 1;\n            for (int i = 0 ; i < pColCnt ; i++) t1 *= B1;\n\n            long t2 = 1;\n            for (int i = 0 ; i < pRowCnt ; i++) t2 *= B2;\n\n            long[,] tmp2 = new long[tRowCnt, tColCnt - pColCnt + 1];\n            bool[,] matchTbl = new bool[tRowCnt - pRowCnt + 1, tColCnt - pColCnt + 1];\n            for (int i = 0 ; i < tRowCnt ; i++)\n            {\n                long e = 0;\n                for (int j = 0 ; j < pColCnt ; j++) e = e * B1 + target[i, j];\n\n                for (int j = 0 ; j + pColCnt <= tColCnt ; j++)\n                {\n                    tmp2[i, j] = e;\n                    if (j + pColCnt < tColCnt) e = e * B1 - t1 * target[i, j] + target[i, j + pColCnt];\n                }\n\n            }\n\n            for (int j = 0 ; j + pColCnt <= tColCnt ; j++)\n            {\n                long e = 0;\n                for (int i = 0 ; i < pRowCnt ; i++) e = e * B2 + tmp2[i, j];\n\n                for (int i = 0 ; i + pRowCnt <= tRowCnt ; i++)\n                {\n                    if (e == pHash) matchTbl[i,j] = true;\n                    if (i + pRowCnt < tRowCnt) e = e * B2 - t2 * tmp2[i, j] + tmp2[i + pRowCnt, j];\n                }\n            }\n\n            for (int i = 0 ; i < matchTbl.GetLength(0) ; i++)\n            {\n                for (int j = 0 ; j < matchTbl.GetLength(1) ; j++)\n                {\n                    if (matchTbl[i, j]) sb.AppendLine(i.ToString() + \" \" + j.ToString());\n                }\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int mapH = int.Parse(input[0]);\n\n            string[] map = new string[mapH];\n\n            for (int i = 0; i < mapH; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            input = Console.ReadLine().Split(' ');\n            int patH = int.Parse(input[0]);\n            int patW = int.Parse(input[1]);\n\n            string[] pat = new string[patH];\n\n            for (int i = 0; i < patH; i++)\n            {\n                pat[i] = Console.ReadLine();\n            }\n\n            KMP kmp = new KMP();\n\n            List<int> candidateIndex;\n            int max = mapH - patH;\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i <= max; i++)\n            {\n                candidateIndex = kmp.SearchString(map[i], pat[0]);\n\n                foreach (var index in candidateIndex)\n                {\n                    bool isSame = true;\n\n                    for (int j = 1; j < patH; j++)\n                    {\n                        if (!isSame) continue;\n\n                        for (int k = 0; k < patW; k++)\n                        {\n                            if (map[i + j][index + k] != pat[j][k])\n                            {\n                                isSame = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (isSame) sb.AppendLine(i + \" \" + index);\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class KMP\n    {\n        int[] lps;\n\n        public List<int> SearchString(string text, string pattern)\n        {\n            List<int> ret = new List<int>();\n\n            int M = pattern.Length;\n            int N = text.Length;\n            int i = 0;\n            int j = 0;\n\n            ComputeLPS(pattern, M);\n\n            while (i < N)\n            {\n                if (pattern[j] == text[i])\n                {\n                    j++;\n                    i++;\n                }\n\n                if (j == M)\n                {\n                    ret.Add(i - j);\n                    j = lps[j - 1];\n                }\n\n                else if (i < N && pattern[j] != text[i])\n                {\n                    if (j != 0) j = lps[j - 1];\n                    else i++;\n                }\n            }\n\n            return ret;\n        }\n\n        private void ComputeLPS(string pattern, int M)\n        {\n            lps = new int[M];\n            lps[0] = 0;\n\n            int len = 0;\n            int i = 1;\n\n            while (i < M)\n            {\n                if (pattern[i] == pattern[len])\n                {\n                    len++;\n                    lps[i] = len;\n                    i++;\n                }\n                else\n                {\n                    if (len != 0)\n                    {\n                        len = lps[len - 1];\n                    }\n                    else\n                    {\n                        lps[i] = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class SearchString\n    {\n        readonly int MOD = 1000000007;\n        readonly int C1 = 401;\n        readonly int C2 = 397;\n\n        readonly string[] txt, pat;\n        readonly int H, W, R, C;\n\n        public SearchString(string[] txt, int h, int w, string[] pat, int r, int c)\n        {\n            this.txt = txt; H = h; W = w;\n            this.pat = pat; R = r; C = c;\n        }\n\n        public void PrintIndex()\n        {\n            if (H < R || W < C) return;\n\n            long[,] txtTable = GenHash(txt, H, W);\n            long[,] patTable = GenHash(pat, R, C);\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i <= H - R; i++)\n            {\n                for (int j = 0; j <= W - C; j++)\n                {\n                    if (txtTable[i, j] == patTable[0, 0]) sb.AppendLine(i + \" \" + j);\n                }\n            }\n            Console.Write(sb);\n        }\n\n        private long[,] GenHash(string[] v, int h, int w)\n        {\n            long[,] h1 = new long[h, w];\n            long[,] h2 = new long[h, w];\n\n            long cn1 = 1, cn2 = 1;\n\n            for (int i = 0; i < C; i++) cn1 = (cn1 * C1) % MOD;\n            for (int i = 0; i < R; i++) cn2 = (cn2 * C2) % MOD;\n\n            for (int i = 0; i < h; i++)\n            {\n                long hs = 0;\n\n                for (int j = 0; j < C; j++) hs = (hs * C1 + v[i][j]) % MOD;\n\n                for (int j = 0; j <= w - C; j++)\n                {\n                    h1[i, j] = hs;\n\n                    if (j + C < w) hs = (hs * C1 - v[i][j] * cn1 + v[i][j + C]) % MOD;\n\n                    hs = (hs < 0) ? hs + MOD : hs;\n                }\n            }\n\n            for (int i = 0; i < w; i++)\n            {\n                long hs = 0;\n\n                for (int j = 0; j < R; j++) hs = (hs * C2 + h1[j, i]) % MOD;\n\n                for (int j = 0; j <= h - R; j++)\n                {\n                    h2[j, i] = hs;\n\n                    if (j + R < h) hs = (hs * C2 - h1[j, i] * cn2 + h1[j + R, i]) % MOD;\n\n                    hs = (hs < 0) ? hs + MOD : hs;\n                }\n            }\n            return h2;\n        }\n\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int H = input[0];\n            int W = input[1];\n\n            string[] text = new string[H];\n            for (int i = 0; i < H; i++) text[i] = Console.ReadLine();\n\n            input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int R = input[0];\n            int C = input[1];\n\n            string[] pattarn = new string[R];\n            for (int i = 0; i < R; i++) pattarn[i] = Console.ReadLine();\n\n            SearchString SS = new SearchString(text, H, W, pattarn, R, C);\n\n            SS.PrintIndex();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int mapH = int.Parse(input[0]);\n            int mapW = int.Parse(input[1]);\n\n            string[] map = new string[mapH];\n\n            for (int i = 0; i < mapH; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            input = Console.ReadLine().Split(' ');\n            int patH = int.Parse(input[0]);\n            int patW = int.Parse(input[1]);\n\n            string[] pat = new string[patH];\n\n            for (int i = 0; i < patH; i++)\n            {\n                pat[i] = Console.ReadLine();\n            }\n\n            KMP kmp = new KMP();\n\n            List<int> candidateIndex;\n            int max = mapH - patH;\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i <= max; i++)\n            {\n                candidateIndex = kmp.SearchString(map[i], pat[0]);\n\n                foreach (var index in candidateIndex)\n                {\n                    bool isSame = true;\n\n                    for (int j = 1; j < patH; j++)\n                    {\n                        if (!isSame) continue;\n\n                        for (int k = 0; k < patW; k++)\n                        {\n                            if (map[i + j][index + k] != pat[j][k])\n                            {\n                                isSame = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (isSame) sb.AppendLine(i + \" \" + index);\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class KMP\n    {\n        int[] lps;\n\n        public List<int> SearchString(string text, string pattern)\n        {\n            List<int> ret = new List<int>();\n\n            int M = pattern.Length;\n            int N = text.Length;\n            int i = 0;\n            int j = 0;\n\n            ComputeLPS(pattern, M);\n\n            while (i < N)\n            {\n                if (pattern[j] == text[i])\n                {\n                    j++;\n                    i++;\n                }\n\n                if (j == M)\n                {\n                    ret.Add(i - j);\n                    j = lps[j - 1];\n                }\n\n                else if (i < N && pattern[j] != text[i])\n                {\n                    if (j != 0) j = lps[j - 1];\n                    else i++;\n                }\n            }\n\n            return ret;\n        }\n\n        private void ComputeLPS(string pattern, int M)\n        {\n            lps = new int[M];\n            lps[0] = 0;\n\n            int len = 0;\n            int i = 1;\n\n            while (i < M)\n            {\n                if (pattern[i] == pattern[len])\n                {\n                    len++;\n                    lps[i] = len;\n                    i++;\n                }\n                else\n                {\n                    if (len != 0)\n                    {\n                        len = lps[len - 1];\n                    }\n                    else\n                    {\n                        lps[i] = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n\n// arihon p333\nnamespace ALDS1_14_C\n{\n    class Program\n    {\n        static int H, W, R, C;\n        static char[][] field, pattern;\n        static ulong[,] hash, tmp;\n        static StringBuilder sb = new StringBuilder();\n\n        static void Main(string[] args)\n        {\n            var t = scan;\n            H = t[0]; W = t[1];\n            field = new char[H][];\n            hash = new ulong[H,W];\n            tmp = new ulong[H, W];\n\n            for (int i = 0; i < H; i++)\n            {\n                field[i] = Console.ReadLine().ToCharArray();\n            }\n\n            t = scan;\n            R = t[0]; C = t[1];\n            pattern = new char[R][];\n\n            for (int i = 0; i < R; i++)\n            {\n                pattern[i] = Console.ReadLine().ToCharArray();\n            }\n\n            solve();\n\n            Console.Write(sb);\n        }\n        static void solve()\n        {\n            //??????????????????????????\\???????±???????\n            ulong HP;\n            compute_hash(pattern, R, C);\n            HP = hash[0, 0];\n            Console.WriteLine(HP);\n\n            //?????????????????\\????????????????????????????¨????\n            compute_hash(field, H, W);\n            for (int i = 0; i + R <= H; i++)\n            {\n                for (int j = 0; j + C <= W; j++)\n                {\n                    if (HP == hash[i, j]) sb.AppendLine(i + \" \" + j);\n                }\n            }\n        }\n\n        //a??????R*C?????¨????????¢?????????????????\\????¨????\n        static void compute_hash(char[][] a, int n, int m)\n        {\n            const ulong B1 = 9973;\n            const ulong B2 = 100000007;\n\n            ulong t1 = 1; //B1???C???\n            for (int j = 0; j < C; j++) t1 *= B1;\n\n            //???????????????????????\\???????¨????\n            for (int i = 0; i < n; i++)\n            {\n                ulong e = 0;\n                for (int j = 0; j < C; j++) e = e * B1 + a[i][j];\n\n                for (int j = 0; j + C <= m; j++)\n                {\n                    tmp[i, j] = e;\n                    if (j + C < m) e = e * B1 - t1 * a[i][j] + a[i][j + C];\n                }\n            }\n\n            ulong t2 = 1; //B2??????\n            for (int i = 0; i < R; i++) t2 *= B2;\n\n            //???????????????????????\\???????¨????\n            for (int j = 0; j + C <= m ; j++)\n            {\n                ulong e = 0;\n                for (int i = 0; i < R; i++) e = e * B2 + tmp[i, j];\n\n                for (int i = 0; i + R <= n; i++)\n                {\n                    hash[i, j] = e;\n                    if (i + R < n) e = e * B2 - t2 * tmp[i, j] + tmp[i + R, j];\n                }\n            }\n\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class SearchString\n    {\n        readonly int MOD = 1000000007;\n        readonly int C1 = 401;\n        readonly int C2 = 397;\n\n        readonly string[] txt, pat;\n        readonly int H, W, R, C;\n\n        public SearchString(string[] txt, int h, int w, string[] pat, int r, int c)\n        {\n            this.txt = txt; H = h; W = w;\n            this.pat = pat; R = r; C = c;\n        }\n\n        public void PrintIndex()\n        {\n            long[,] txtTable = GenHash(txt, H, W);\n            long[,] patTable = GenHash(pat, R, C);\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i <= H - R; i++)\n            {\n                for (int j = 0; j <= W - C; j++)\n                {\n                    if (txtTable[i, j] == patTable[0, 0]) sb.AppendLine(i + \" \" + j);\n                }\n            }\n            Console.Write(sb);\n        }\n\n        private long[,] GenHash(string[] v, int h, int w)\n        {\n            long[,] h1 = new long[h, w];\n            long[,] h2 = new long[h, w];\n\n            long cn1 = 1, cn2 = 1;\n\n            for (int i = 0; i < C; i++) cn1 = (cn1 * C1) % MOD;\n            for (int i = 0; i < R; i++) cn2 = (cn2 * C2) % MOD;\n\n            for (int i = 0; i < h; i++)\n            {\n                long hs = 0;\n\n                for (int j = 0; j < C; j++) hs = (hs * C1 + v[i][j]) % MOD;\n\n                for (int j = 0; j <= w - C; j++)\n                {\n                    h1[i, j] = hs;\n\n                    if (j + C < w) hs = (hs * C1 - v[i][j] * cn1 + v[i][j + C]) % MOD;\n\n                    hs = (hs < 0) ? hs + MOD : hs;\n                }\n            }\n\n            for (int i = 0; i < w; i++)\n            {\n                long hs = 0;\n\n                for (int j = 0; j < R; j++) hs = (hs * C2 + h1[j, i]) % MOD;\n\n                for (int j = 0; j <= h - R; j++)\n                {\n                    h2[j, i] = hs;\n\n                    if (j + R < h) hs = (hs * C2 - h1[j, i] * cn2 + h1[j + R, i]) % MOD;\n\n                    hs = (hs < 0) ? hs + MOD : hs;\n                }\n            }\n            return h2;\n        }\n\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int H = input[0];\n            int W = input[1];\n\n            string[] text = new string[H];\n            for (int i = 0; i < H; i++) text[i] = Console.ReadLine();\n\n            input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int R = input[0];\n            int C = input[1];\n\n            string[] pattarn = new string[R];\n            for (int i = 0; i < R; i++) pattarn[i] = Console.ReadLine();\n\n            SearchString SS = new SearchString(text, H, W, pattarn, R, C);\n\n            SS.PrintIndex();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int mapH = int.Parse(input[0]);\n\n            string[] map = new string[mapH];\n\n            for (int i = 0; i < mapH; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            input = Console.ReadLine().Split(' ');\n            int patH = int.Parse(input[0]);\n\n            string[] pat = new string[patH];\n\n            for (int i = 0; i < patH; i++)\n            {\n                pat[i] = Console.ReadLine();\n            }\n\n            KMP kmp = new KMP();\n\n            List<List<int>> candidateIndex;\n            int max = mapH - patH;\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i <= max; i++)\n            {\n                candidateIndex = new List<List<int>>();\n\n                bool hasVal = true;\n\n                for (int j = 0; j < patH; j++)\n                {\n                    List<int> temp = kmp.SearchString(map[i + j], pat[j]);\n\n                    if (temp.Count == 0)\n                    {\n                        hasVal = false;\n                        break;\n                    }\n\n                    candidateIndex.Add(temp);\n                }\n\n                if (hasVal)\n                {\n                    foreach (var index in candidateIndex[0])\n                    {\n                        bool isSame = true;\n\n                        for (int j = 1; j < patH; j++)\n                        {\n                            if (!candidateIndex[j].Contains(index))\n                            {\n                                isSame = false;\n                                break;\n                            }\n                        }\n\n                        if (isSame) sb.AppendLine(i + \" \" + index);\n                    }\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class KMP\n    {\n        int[] lps;\n\n        public List<int> SearchString(string text, string pattern)\n        {\n            List<int> ret = new List<int>();\n\n            int M = pattern.Length;\n            int N = text.Length;\n            int i = 0;\n            int j = 0;\n\n            ComputeLPS(pattern, M);\n\n            while (i < N)\n            {\n                if (pattern[j] == text[i])\n                {\n                    j++;\n                    i++;\n                }\n\n                if (j == M)\n                {\n                    ret.Add(i - j);\n                    j = lps[j - 1];\n                }\n\n                else if (i < N && pattern[j] != text[i])\n                {\n                    if (j != 0) j = lps[j - 1];\n                    else i++;\n                }\n            }\n\n            return ret;\n        }\n\n        private void ComputeLPS(string pattern, int M)\n        {\n            lps = new int[M];\n            lps[0] = 0;\n\n            int len = 0;\n            int i = 1;\n\n            while (i < M)\n            {\n                if (pattern[i] == pattern[len])\n                {\n                    len++;\n                    lps[i] = len;\n                    i++;\n                }\n                else\n                {\n                    if (len != 0)\n                    {\n                        len = lps[len - 1];\n                    }\n                    else\n                    {\n                        lps[i] = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nconst assert = require('assert');\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\nline = null; // dispose\n\nif (H < R || W < C) process.exit();\n\n// changes a string into the segments of a number\n\nconst SEGMENT_NUMBER_LENGTH = 31;\n\nfunction makeSegment(str) {\n  var ary, i;\n  ary = [];\n  for (i = 0; i < str.length; i += SEGMENT_NUMBER_LENGTH)\n    ary.push(str.substr(i, SEGMENT_NUMBER_LENGTH));\n  ary = ary.map(function (str) {\n    return parseInt(str.split('').reverse().join(''), 2); });\n  return {'length': str.length, 'offset': 0, 'body': ary};\n}\n\nfunction isHead(longSegment, shortSegment) {\n  var llen, slen, lofst, sofst, l, s;\n  assert(longSegment.length >= shortSegment.length);\n  llen = longSegment.length;\n  slen = shortSegment.length;\n  lofst = longSegment.offset;\n  sofst = shortSegment.offset;\n  l = longSegment.body;\n  s = shortSegment.body;\n  while (slen > SEGMENT_NUMBER_LENGTH) {\n    if (s[sofst] !== l[lofst]) return false;\n    sofst++;\n    lofst++;\n    slen -= SEGMENT_NUMBER_LENGTH;\n    llen -= SEGMENT_NUMBER_LENGTH;\n  }\n  return ((l[lofst] % Math.pow(2, slen)) === s[sofst]);\n}\n\nfunction shiftSegment(seg) {\n  seg.length -= SEGMENT_NUMBER_LENGTH;\n  seg.offset++;\n  if (seg.length <= 0) return null;\n  return seg;\n}\n\nfunction makeSegmentSeries(str) {\n  var res, i;\n  res = new Array(SEGMENT_NUMBER_LENGTH);\n  for (i = 0; i < SEGMENT_NUMBER_LENGTH; i++) res[i] = null;\n  for (i = 0; i < SEGMENT_NUMBER_LENGTH && i < str.length; i++)\n    res[i] = makeSegment(str.slice(i));\n  return res;\n}\n\nfunction copySegmentSeries(dst, src) {\n  var i, dst_i, src_i;\n  for (i in src) {\n    if (!src[i]) {\n      dst[i] = null;\n      continue;\n    }\n    if (!dst[i]) {\n      dst[i] = Object.assign({}, src[i]);\n    } else {\n      Object.assign(dst[i], src[i]);\n    }\n  }\n}\n\nsegmentSeriesInSegmentMatch = new Array(SEGMENT_NUMBER_LENGTH);\n\nfunction segmentMatch(segmentSeries, segment) {\n  var series, res, i;\n  series = segmentSeriesInSegmentMatch;\n  copySegmentSeries(series, segmentSeries);\n  res = [];\n  i = 0;\n  while (series[i] && series[i].length >= segment.length) {\n    res.push(isHead(series[i], segment));\n    series[i] = shiftSegment(series[i]);\n    i++;\n    if (i === SEGMENT_NUMBER_LENGTH) i = 0;\n  }\n  return res;\n}\n\nfield = field.map(makeSegmentSeries);\npat = pat.map(makeSegment);\n\n// pattern matching\n\nmem = new Array(H-R+1);\nfor (i = 0; i <= H-R; i++) {\n  mem[i] = new Array(W-C+1);\n  for (j = 0; j <= W-C; j++) mem[i][j] = 0;\n}\n\nfor (i = 0; i < H; i++) {\n  for (j = Math.max(0, i-H+R); j < R && j <= i; j++) {\n    match = segmentMatch(field[i], pat[j]);\n    for (k in match) {\n      if (!match[k]) continue;\n      mem[i-j][k]++;\n    }\n  }\n}\n\nfor (i in mem)\n  for (j in mem[i])\n    if (mem[i][j] === R) console.log('%s %s', i, j);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nif (H < R || W < C) process.exit();\n\nmatrix = field.map(function (str) {\n  var res, i;\n  res = [];\n  for (i = 0; i <= W-C; i++) res.push(str.slice(i, i+C));\n  return res;\n});\n\nhash = {};\ncnt = 0;\nfunction register(str) {\n  if (!hash.hasOwnProperty(str)) {\n    hash[str] = cnt;\n    cnt++;\n    return cnt;\n  }\n  return hash[str];\n}\n\nmatrix = matrix.map(function (row) { return row.map(register); });\npat = pat.map(register);\n\nfor (i = 0; i <= H-R; i++) {\n  for (j = 0; j <= W-C; j++) {\n    flag = true;\n    for (k = 0; k < R; k++) {\n      if (matrix[i+k][j] !== pat[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) console.log(i, j);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nconst assert = require('assert');\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\nline = null; // dispose\n\nif (H < R || W < C) process.exit();\n\n// changes a string into the segments of a number\n\nconst SEGMENT_NUMBER_LENGTH = 30;\n\nfunction makeSegment(str) {\n  var ary, i;\n  ary = [];\n  for (i = 0; i < str.length; i += SEGMENT_NUMBER_LENGTH)\n    ary.push(str.substr(i, SEGMENT_NUMBER_LENGTH));\n  ary = ary.map(function (str) {\n    return parseInt(str.split('').reverse().join(''), 2); });\n  return {'length': str.length, 'offset': 0, 'body': ary};\n}\n\nfunction isHead(longSegment, shortSegment) {\n  var llen, slen, lofst, sofst, l, s;\n  assert(longSegment.length >= shortSegment.length);\n  llen = longSegment.length;\n  slen = shortSegment.length;\n  lofst = longSegment.offset;\n  sofst = shortSegment.offset;\n  l = longSegment.body;\n  s = shortSegment.body;\n  while (slen > SEGMENT_NUMBER_LENGTH) {\n    if (s[sofst] !== l[lofst]) return false;\n    sofst++;\n    lofst++;\n    slen -= SEGMENT_NUMBER_LENGTH;\n    llen -= SEGMENT_NUMBER_LENGTH;\n  }\n  return (l[lofst] % (1 << slen) === s[sofst]);\n}\n\nfunction shiftSegment(seg) {\n  seg.length -= SEGMENT_NUMBER_LENGTH;\n  seg.offset++;\n  if (seg.length <= 0) return null;\n  return seg;\n}\n\nfunction makeSegmentSeries(str) {\n  var res, i;\n  res = new Array(SEGMENT_NUMBER_LENGTH);\n  for (i = 0; i < SEGMENT_NUMBER_LENGTH; i++) res[i] = null;\n  for (i = 0; i < SEGMENT_NUMBER_LENGTH && i < str.length; i++)\n    res[i] = makeSegment(str.slice(i));\n  return res;\n}\n\nfunction copySegmentSeries(dst, src) {\n  var i, j, src_i, dst_i;\n  for (i in src) {\n    src_i = src[i];\n    if (!src_i) {\n      dst[i] = null;\n      continue;\n    }\n    dst_i = dst[i];\n    if (!dst_i) dst_i = {};\n    for (j in src_i) dst_i[j] = src_i[j]; // Object.assign\n    dst[i] = dst_i;\n  }\n}\n\nsegmentSeriesInSegmentMatch = new Array(SEGMENT_NUMBER_LENGTH);\n\nfunction segmentMatch(segmentSeries, segment) {\n  var series, res, i;\n  series = segmentSeriesInSegmentMatch;\n  copySegmentSeries(series, segmentSeries);\n  res = [];\n  i = 0;\n  while (series[i] && series[i].length >= segment.length) {\n    res.push(isHead(series[i], segment));\n    series[i] = shiftSegment(series[i]);\n    i++;\n    if (i === SEGMENT_NUMBER_LENGTH) i = 0;\n  }\n  return res;\n}\n\nfield = field.map(makeSegmentSeries);\npat = pat.map(makeSegment);\n\n// pattern matching\n\nmem = new Array(H-R+1);\nfor (i = 0; i <= H-R; i++) {\n  mem[i] = new Array(W-C+1);\n  for (j = 0; j <= W-C; j++) mem[i][j] = 0;\n}\n\nfor (i = 0; i < H; i++) {\n  for (j = Math.max(0, i-H+R); j < R && j <= i; j++) {\n    match = segmentMatch(field[i], pat[j]);\n    for (k in match) {\n      if (!match[k]) continue;\n      mem[i-j][k]++;\n    }\n  }\n}\n\nfor (i in mem)\n  for (j in mem[i])\n    if (mem[i][j] === R) console.log('%s %s', i, j);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nif (H < R || W < C) process.exit();\n\nmem = new Array(H-R+1);\nfor (i = 0; i <= H-R; i++) {\n  mem[i] = new Array(W-C+1);\n  for (j = 0; j <= W-C; j++) mem[i][j] = 0;\n}\n\nmatch_count = new Array(W-C+1);\nmatch = new Array(W-C+1);\nfor (i = 0; i <= W-C; i++) {\n  match_count[i] = 0;\n  match[i] = false;\n}\n\nfunction string_match(str1, str2, W, C) {\n  var i, j, k;\n  for (i in match_count) match_count[i] = 0;\n  for (i = 0; i <= W-C; i++) {\n    for (j = 0; j < C; j++) {\n      if (str1[i+j] === str2[j]) match_count[i]++;\n    }\n  }\n  for (i in match) match[i] = (match_count[i] === C);\n}\n\nfor (i = 0; i < H; i++) {\n  for (j = Math.max(0, i-H+R); j < R && j <= i; j++) {\n    string_match(field[i], pat[j], W, C);\n    for (k in match) {\n      if (!match[k]) continue;\n      mem[i-j][k]++;\n    }\n  }\n}\n\nfor (i in mem)\n  for (j in mem[i])\n    if (mem[i][j] === R) console.log('%s %s', i, j);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n \nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n \nif (H < R || W < C) process.exit();\n \nhash = {};\ncnt = 1;\nfunction register(str) {\n  if (!hash.hasOwnProperty(str)) {\n    hash[str] = cnt;\n    return cnt++;\n  }\n  return hash[str];\n}\npat = pat.map(register);\n \nmatrix = field.map(function (str) {\n  var res, i, sliced;\n  res = [];\n  for (i = 0; i <= W-C; i++)\n    res.push(hash[str.slice(i, i+C)] || 0); // safe because returns undefined\n  return res;\n});\n\nfunction transpose(matrix) {\n  var res = [], rows = matrix[0].length, cols = matrix.length, i, row, j;\n  for (i = 0; i < rows; i++) {\n    row = [];\n    for (j = 0; j < cols; j++) row.push(matrix[j][i]);\n    res.push(row);\n  }\n  return res;\n}\nmatrix = transpose(matrix);\n\nmatrix = matrix.map(function (row) {\n  return row.map(function (num) { return num.toString(36); }) });\n\nfunction makeJoinSeries(ary) {\n  var res, i;\n  res = [];\n  for (i = 0; i <= ary.length - R; i++)\n    res.push(ary.slice(i, i+R).join(' '));\n  return res;\n}\nmatrix = matrix.map(makeJoinSeries);\n\npatHash = {};\npatHash[makeJoinSeries(pat)] = true;\nmatrix = matrix.map(function (row) {\n  return row.map( function (str) { return patHash[str] || false; });\n});\n\nmatrix = transpose(matrix);\n\nfor (i in matrix)\n  for (j in matrix[i])\n    if (matrix[i][j]) console.log('%s %s', i, j);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nmem = new Array(H);\nfor (i = 0; i < H; i++) {\n  mem[i] = new Array(R);\n  for (j = 0; j < R; j++) {\n    mem[i][j] = new Array(W-C+1);\n    for (k = 0; k <= W-C; k++) mem[i][j][k] = false;\n    k = field[i].indexOf(pat[j])\n    while (k !== -1) {\n      mem[i][j][k] = true;\n      k = field[i].indexOf(pat[j], k + 1);\n    }\n  }\n}\n\nfor (i = 0; i <= H - R; i++) {\n  for (j = 0; j <= W - C; j++) {\n    flag = true;\n    for (k = 0; k < R; k++) {\n      if (!mem[i+k][k][j]) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) console.log('%d %d', i, j);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nif (H < R || W < C) process.exit();\n\nmem = new Array(H-R+1);\nfor (i = 0; i <= H-R; i++) {\n  mem[i] = new Array(W-C+1);\n  for (j = 0; j <= W-C; j++) mem[i][j] = 0;\n}\n\nfor (i = 0; i < H; i++) {\n  for (j = Math.max(0, i-H+R); j < R && j <= i; j++) {\n    k = field[i].indexOf(pat[j]);\n    while (k !== -1) {\n      mem[i-j][k]++;\n      k = field[i].indexOf(pat[j], k+1);\n    }\n  }\n}\n\nfor (i in mem)\n  for (j in mem[i])\n    if (mem[i][j] === R) console.log('%s %s', i, j);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nif (H < R || W < C) process.exit();\n\nmatrix = field.map(function (str) {\n  var res, i;\n  res = [];\n  for (i = 0; i <= W-C; i++) res.push(str.slice(i, i+C));\n  return res;\n});\n\nfor (i = 0; i <= H-R; i++) {\n  for (j = 0; j <= W-C; j++) {\n    flag = true;\n    for (k = 0; k < R; k++) {\n      if (matrix[i+k][j] !== pat[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) console.log(i, j);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nconst assert = require('assert');\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\nline = null; // dispose\n\nif (H < R || W < C) process.exit();\n\n// changes a string into the segments of a number\n\nconst SEGMENT_NUMBER_LENGTH = 31;\n\nfunction makeSegment(str) {\n  var ary, i;\n  ary = [];\n  for (i = 0; i < str.length; i += SEGMENT_NUMBER_LENGTH)\n    ary.push(str.substr(i, SEGMENT_NUMBER_LENGTH));\n  ary = ary.map(function (str) {\n    return parseInt(str.split('').reverse().join(''), 2); });\n  return {'length': str.length, 'offset': 0, 'body': ary};\n}\n\nfunction isHead(longSegment, shortSegment) {\n  var llen, slen, lofst, sofst, l, s;\n  assert(longSegment.length >= shortSegment.length);\n  llen = longSegment.length;\n  slen = shortSegment.length;\n  lofst = longSegment.offset;\n  sofst = shortSegment.offset;\n  l = longSegment.body;\n  s = shortSegment.body;\n  while (slen > SEGMENT_NUMBER_LENGTH) {\n    if (s[sofst] !== l[lofst]) return false;\n    sofst++;\n    lofst++;\n    slen -= SEGMENT_NUMBER_LENGTH;\n    llen -= SEGMENT_NUMBER_LENGTH;\n  }\n  return ((l[lofst] % (2 << slen)) === s[sofst]);\n}\n\nfunction shiftSegment(seg) {\n  seg.length -= SEGMENT_NUMBER_LENGTH;\n  seg.offset++;\n  if (seg.length <= 0) return null;\n  return seg;\n}\n\nfunction makeSegmentSeries(str) {\n  var res, i;\n  res = new Array(SEGMENT_NUMBER_LENGTH);\n  for (i = 0; i < SEGMENT_NUMBER_LENGTH; i++) res[i] = null;\n  for (i = 0; i < SEGMENT_NUMBER_LENGTH && i < str.length; i++)\n    res[i] = makeSegment(str.slice(i));\n  return res;\n}\n\nfunction copySegmentSeries(dst, src) {\n  var i, j, src_i, dst_i;\n  for (i in src) {\n    src_i = src[i];\n    if (!src_i) {\n      dst[i] = null;\n      continue;\n    }\n    dst_i = dst[i];\n    if (!dst_i) dst_i = {};\n    for (j in src_i) dst_i[j] = src_i[j]; // Object.assign\n    dst[i] = dst_i;\n  }\n}\n\nsegmentSeriesInSegmentMatch = new Array(SEGMENT_NUMBER_LENGTH);\n\nfunction segmentMatch(segmentSeries, segment) {\n  var series, res, i;\n  series = segmentSeriesInSegmentMatch;\n  copySegmentSeries(series, segmentSeries);\n  res = [];\n  i = 0;\n  while (series[i] && series[i].length >= segment.length) {\n    res.push(isHead(series[i], segment));\n    series[i] = shiftSegment(series[i]);\n    i++;\n    if (i === SEGMENT_NUMBER_LENGTH) i = 0;\n  }\n  return res;\n}\n\nfield = field.map(makeSegmentSeries);\npat = pat.map(makeSegment);\n\n// pattern matching\n\nmem = new Array(H-R+1);\nfor (i = 0; i <= H-R; i++) {\n  mem[i] = new Array(W-C+1);\n  for (j = 0; j <= W-C; j++) mem[i][j] = 0;\n}\n\nfor (i = 0; i < H; i++) {\n  for (j = Math.max(0, i-H+R); j < R && j <= i; j++) {\n    match = segmentMatch(field[i], pat[j]);\n    for (k in match) {\n      if (!match[k]) continue;\n      mem[i-j][k]++;\n    }\n  }\n}\n\nfor (i in mem)\n  for (j in mem[i])\n    if (mem[i][j] === R) console.log('%s %s', i, j);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nmem = new Array(H);\nfor (i = 0; i < H; i++) {\n  mem[i] = new Array(R);\n  for (j = 0; j < R; j++) {\n    mem[i][j] = {};\n    k = field[i].indexOf(pat[j])\n    while (k !== -1) {\n      mem[i][j][k] = true;\n      k = field[i].indexOf(pat[j], k + 1);\n    }\n  }\n}\n\nfor (i = 0; i <= H - R; i++) {\n  for (j = 0; j <= W - C; j++) {\n    flag = true;\n    for (k = 0; k < R; k++) {\n      if (!mem[i+k][k].hasOwnProperty(j)) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) console.log('%d %d', i, j);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nline[0] = line[0].split(' ').map(Number);\nH = line[0][0];\nW = line[0][1];\nfield = line.slice(1, 1+H);\nline[1+H] = line[1+H].split(' ').map(Number);\nR = line[1+H][0];\nC = line[1+H][1];\npat = line.slice(1+H+1, 1+H+1+R);\n\nif (H < R || W < C) process.exit();\n\nhash = {};\ncnt = 0;\nfunction register(str) {\n  if (!hash.hasOwnProperty(str)) {\n    hash[str] = cnt;\n    return cnt++;\n  }\n  return hash[str];\n}\n\nmatrix = field.map(function (str) {\n  var res, i;\n  res = [];\n  for (i = 0; i <= W-C; i++) res.push(register(str.slice(i, i+C)));\n  return res;\n});\npat = pat.map(register);\n\nfor (i = 0; i <= H-R; i++) {\n  for (j = 0; j <= W-C; j++) {\n    flag = true;\n    for (k = 0; k < R; k++) {\n      if (matrix[i+k][j] !== pat[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) console.log(i, j);\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = {}\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |h,k| h[k] = Hash.new(&h.default_proc) }\n\n0.upto(w-c){|j|\n  p j\n  str = []\n  r.times{|i|\n    if i == 0\n      str = [hw[i][j,c]]\n    else\n      str.push(hw[i][j,c])\n    end\n  }\n  (h-r).times{|i|\n    #    p \"#{i} #{j} #{str}\"\n    hash[str.join][i][j] = 1\n    str.shift()\n    str.push(hw[i+r][j,c])\n  }\n#  p \"#{h-r} #{j} #{str}\"\n  hash[str][h-r][j] = 1\n}\n\nit = rc.join\n#p hash[it]\nif hash[it] then\n  hash[it].sort.each{|i, val|\n    hash[it][i].sort.each{|j, val|\n      puts \"#{i} #{j}\"\n    }\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\ntemplate = rc.join\nhash = {}\nhash[template] = true\nexit if r > h || c > w\n\n0.upto(h-r){|i|\n  offset = 0\n  loop do\n    j = hw[i].index(rc[0], offset)\n    break if j == nil\n    offset = j+1\n    candidate = \"\"\n    0.upto(r-1){|k|\n      candidate << hw[i+k][j,c]\n    }\n    puts \"#{i} #{j}\" if hash[candidate]\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n  rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n  rc_hash[rc[i]] += 1\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\n\nif r < c then\n  min_val = rc_hash.values.min\n  min_key = rc_hash.key(min_val)\n  idx = rc.index(min_key)\n  # p rc_hash\n  # p min_val\n  # p min_key\n  # p idx\n\n  key = rc[idx]\n  h.times{|i|\n    0.upto(w-c){|j|\n      hash[hw[i][j,c]][i][j] = 1\n    }\n  }\n  if hash[key] then\n    hash[key].each_key{|i|\n      next if i - idx < 0 || i - idx + r > h\n      hash[key][i].each_key{|j|\n        #      p \"can: #{i} #{j}\"\n        ans = true\n        0.upto(r-1){|k|\n          # p \"k: #{h} #{i-idx+k}\"\n          #         p \"k: #{k} #{hw[i-idx+k][j,c]}\"\n          unless hw[i-idx+k][j,c] == rc[k] then\n            ans = false\n            break\n          end\n        }\n        puts \"#{i-idx} #{j}\" if ans\n      }\n    }\n  end\n else\n   #transpose mode\n  mat = Array.new(w){Array.new(h)}\n  h.times{|i|\n    tmp = hw[i].split(\"\")\n    tmp.size.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  wh = []\n  w.times{|j|\n    wh[j] = mat[j].join\n  }\n#  p wh\n  mat = Array.new(c){Array.new(r)}\n  r.times{|i|\n    tmp = rc[i].split(\"\")\n    tmp.size.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  cr_hash = {}\n  cr = []\n  c.times{|j|\n    cr[j] = mat[j].join\n    cr_hash[cr[j]] = 0 unless cr_hash[cr[j]]\n    cr_hash[cr[j]] += 1\n  }\n  min_val = cr_hash.values.min\n  min_key = cr_hash.key(min_val)\n  idx = cr.index(min_key)\n  key = cr[idx]\n  0.upto(h-r){|i|\n    w.times{|j|\n      hash[wh[j][i,r]][i][j] = 1\n    }\n  }\n#  p idx\n  if hash[key] then\n    hash[key].each_key{|i|\n      hash[key][i].each_key{|j|\n        next if j-idx < 0 || j-idx+c > w\n#        p \"can: #{i} #{j}\"\n        ans = true\n        0.upto(c-1){|k|\n          # p \"k: #{h} #{i-idx+k}\"\n#          p \"k: #{k} #{wh[j-idx+k][i,r]}  #{cr[k]}\"\n          unless wh[j-idx+k][i,r] == cr[k] then\n            ans = false\n            break\n          end\n        }\n        puts \"#{i} #{j}\" if ans\n      }\n    }\n  end\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = {}\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\n\n0.upto(w-c){|j|\n#  p j\n  str = []\n  r.times{|i|\n    if i == 0\n      str = [hw[i][j,c]]\n    else\n      str.push(hw[i][j,c])\n    end\n  }\n  (h-r).times{|i|\n    hash[str.join][i][j] = 1\n    str.shift()\n    str.push(hw[i+r][j,c])\n  }\n  hash[str.join][h-r][j] = 1\n}\n\nit = rc.join\nif hash[it] then\n  hash[it].sort.each{|i, val|\n    hash[it][i].sort.each{|j, v|\n      puts \"#{i} #{j}\"\n    }\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<16\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  f = f ? $f1 : $f2\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = e*B1 - t1*f[i][j] + f[i][j+$c] if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\n$hash = Array.new($h){ Array.new($w, 0) }\n$tmp = Array.new($h){ Array.new($w, 0) }\ncalc(nil,$r,$c)\n$key = $hash[0][0]\ncalc(true,$h,$w)\ncheck"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n  rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n  rc_hash[rc[i]] += 1\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\n\nmin_val = rc_hash.values.min\nmin_key = rc_hash.key(min_val)\nidx = rc.index(min_key)\n\nkey = rc[idx]\n0.upto(h-r){|i|\n  0.upto(w-c){|j|\n    hash[hw[i][j,c]][i][j] = 1\n  }\n}\nif hash[key] then\n  hash[key].each_key{|i|\n    hash[key][i].each_key{|j|\n      ans = true\n      0.upto(r-1){|k|\n        unless hw[i-idx+k][j,c] == rc[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i-idx} #{j}\" if ans\n    }\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "B = 101\nDIV = 1<<32\ndef rolling_hash(s, n)\n  hash = Array.new(n+1)\n  hash[0] = 0\n  n.times{ |i| hash[i+1] = (hash[i]*B + s[i].ord) % DIV }\n  hash\nend\n\ndef init(r, c)\n  f = Array.new(r)\n  r.times do |i|\n    f[i] = rolling_hash(gets.chomp, c)\n  end\n  f\nend\n\ndef check(i, j)\n  $r.times do |y|\n    return if ($f1[i+y][j+$c] - $f1[i+y][j]*$p[$c]) % DIV != $f2[y][$c]\n  end\n  puts \"#{i} #{j}\" \nend\n\nh, w = gets.split.map(&:to_i)\n\n$p = Array.new(w+1)\n$p[0] = 1\nw.times{ |i| $p[i+1] = $p[i]*B % DIV }\n\n$f1 = init(h, w)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r, $c)\n(0..h-$r).each do |i|\n  (0..w-$c).each do |j|\n    check(i, j)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# just a copy of http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2232033#1\nh, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp.split(\"\").map(&:ord)\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp.split(\"\").map(&:ord)\n}\nexit if r > h || c > w\n\nA = 9999973\nB = 950527\n\ntarget = 0\nr.times{|i|\n  key = 0\n  c.times{|j|\n    key = key*B+rc[i][j]\n  }\n  target = target*A+key\n}\nC = B**c\nt = Array.new(h){Array.new(w)}\nt2 = Array.new(h){Array.new(w)}\nh.times{|i|\n  key = 0\n  w.times{|j|\n    key = key*B+hw[i][j];\n    key -= hw[i][j-c]*C if j-c >= 0\n    t[i][j] = key\n    t2[i][j] = t[i][j]\n  }\n}\n\nD = A**r\n\nh.times{|i|\n  w.times{|j|\n    t[i][j] += t[i-1][j]*A if i > 0\n    t[i][j] -= t2[i-r][j]*D if i-r >= 0\n    if t[i][j] == target then\n      if i-r+1 >= 0 && j-c+1>= 0 then\n        puts \"#{i-r+1} #{j-c+1}\"\n      end\n    end\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "B1 = 97\nB2 = 101\nDIV = 1000000007\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c] + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\nif $h >= $r && $w >= $c\n  $hash = Array.new($h){ Array.new($w, 0) }\n  $tmp = Array.new($h){ Array.new($w, 0) }\n  calc($f2,$r,$c)\n  $key = $hash[0][0]\n  calc($f1,$h,$w)\n  check\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 63533\nB2 = 100007\nDIV = 1<<64\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 *= B1 }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = ((e*B1 - t1*f[i][j] + f[i][j+$c]) + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 *= B2 }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = ((e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j]) + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check(h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] == $key\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\n$hash = Array.new(h){ Array.new(w, 0) }\n$tmp = Array.new(h){ Array.new(w, 0) }\ncalc(f2,$r,$c)\n$key = $hash[0][0]\ncalc(f1,h,w)\ncheck(h,w)"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = [] }\n\nif r <= c then\n  rc_hash = {}\n  rc = []\n  r.times{|i|\n    rc[i] = gets.chomp\n    rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n    rc_hash[rc[i]] += 1\n  }\n\n  idx = rc.index(rc_hash.min {|a, b| a[1] <=> b[1] }[0])\n\n  idx.upto(h-r+idx){|i|\n    0.upto(w-c){|j|\n      hash[hw[i][j,c]] << \"#{i} #{j}\"\n    }\n  }\n  key = rc[idx]\n  if hash[key] then\n    if hash.size == 1 and rc_hash.size == 1 then\n      # uniform mode\n      hash[key].each{|ij|\n        i, j = ij.split.map(&:to_i)\n        ans = true\n        unless hw[i-idx][j,c] == rc[0] then\n          ans = false\n        end\n        puts \"#{i-idx} #{j}\" if ans\n      }\n    else\n      hash[key].each{|ij|\n        i, j = ij.split.map(&:to_i)\n        ans = true\n        r.times{|k|\n          unless hw[i-idx+k][j,c] == rc[k] then\n            ans = false\n            break\n          end\n        }\n        puts \"#{i-idx} #{j}\" if ans\n      }\n    end\n  end\n else\n   #transpose mode\n  mat = Array.new(w){Array.new(h)}\n  h.times{|i|\n    tmp = hw[i].split(\"\")\n    w.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  wh = []\n  w.times{|j|\n    wh[j] = mat[j].join\n  }\n  mat = Array.new(c){Array.new(r)}\n  r.times{|i|\n    tmp = gets.chomp.split(\"\")\n    c.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  cr_hash = {}\n  cr = []\n  c.times{|j|\n    cr[j] = mat[j].join\n    cr_hash[cr[j]] = 0 unless cr_hash[cr[j]]\n    cr_hash[cr[j]] += 1\n  }\n  idx = cr.index(cr_hash.min {|a, b| a[1] <=> b[1] }[0])\n  key = cr[idx]\n  0.upto(h-r){|i|\n    idx.upto(w-c+idx){|j|\n      hash[wh[j][i,r]] << \"#{i} #{j}\"\n    }\n  }\n  if hash[key] then\n    hash[key].each{|ij|\n      i, j = ij.split.map(&:to_i)\n      ans = true\n      c.times{|k|\n        unless wh[j-idx+k][i,r] == cr[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j-idx}\" if ans\n    }\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 63533\nB2 = 100007\nDIV = 1<<64\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = e*B1 - t1*f[i][j] + f[i][j+$c] if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] if i < r - $r\n    end\n  end\nend\n\ndef check(h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\n$hash = Array.new(h){ Array.new(w, 0) }\n$tmp = Array.new(h){ Array.new(w, 0) }\ncalc(f2,$r,$c)\n$key = $hash[0][0]\ncalc(f1,h,w)\ncheck(h,w)"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = [] }\n\nif r <= c then\n  rc = []\n  r.times{|i|\n    rc[i] = gets.chomp\n    rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n    rc_hash[rc[i]] += 1\n  }\n\n  idx = rc.index(rc_hash.min {|a, b| a[1] <=> b[1] }[0])\n\n  idx.upto(h-r+idx){|i|\n    0.upto(w-c){|j|\n      hash[hw[i][j,c]] << \"#{i} #{j}\"\n    }\n  }\n  key = rc[idx]\n  if hash[key] then\n    hash[key].each{|ij|\n      i, j = ij.split.map(&:to_i)\n      ans = true\n      r.times{|k|\n        unless hw[i-idx+k][j,c] == rc[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i-idx} #{j}\" if ans\n    }\n  end\n else\n   #transpose mode\n  mat = Array.new(w){Array.new(h)}\n  h.times{|i|\n    tmp = hw[i].split(\"\")\n    w.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  wh = []\n  w.times{|j|\n    wh[j] = mat[j].join\n  }\n  mat = Array.new(c){Array.new(r)}\n  r.times{|i|\n    tmp = gets.chomp.split(\"\")\n    c.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  cr_hash = {}\n  cr = []\n  c.times{|j|\n    cr[j] = mat[j].join\n    cr_hash[cr[j]] = 0 unless cr_hash[cr[j]]\n    cr_hash[cr[j]] += 1\n  }\n  idx = cr.index(cr_hash.min {|a, b| a[1] <=> b[1] }[0])\n  key = cr[idx]\n  0.upto(h-r){|i|\n    idx.upto(w-c+idx){|j|\n      hash[wh[j][i,r]] << \"#{i} #{j}\"\n    }\n  }\n  if hash[key] then\n    hash[key].each{|ij|\n      i, j = ij.split.map(&:to_i)\n      ans = true\n      c.times{|k|\n        unless wh[j-idx+k][i,r] == cr[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j-idx}\" if ans\n    }\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 97\nB2 = 101\nDIV = 1 << 32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c] + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\nif $h >= $r && $w >= $c\n  $hash = Array.new($h){ Array.new($w, 0) }\n  $tmp = Array.new($h){ Array.new($w, 0) }\n  calc($f2,$r,$c)\n  $key = $hash[0][0]\n  calc($f1,$h,$w)\n  check\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\nh.times{|i|\n  0.upto(w-c){|j|\n    hash[i][hw[i][j,c]][j] = 1\n  }\n}\n\n#p \"hash done\"\n\n0.upto(h-r){|i|\n  if hash[i][rc[0]]\n    # find candidate\n    hash[i][rc[0]].each_key{|j|\n      ans = true\n      1.upto(r){|k|\n        unless hash[i+k][rc[k]][j]\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if ans\n    }\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\nexit if r > h || c > w\n0.upto(h-r){|i|\n  0.upto(w-c){|j|\n    if hw[i][j,c] == rc[0] then\n      flag = true # it is candidate\n      (1).upto(r-1){|k|\n        unless hw[i+k][j,c] == rc[k] then\n          flag = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if flag\n    end\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  if t.index(p) == nil then\n    puts \"0\"\n  else\n    puts \"1\"\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 *= B1 }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = ((e*B1 - t1*f[i][j] + f[i][j+$c]) % DIV + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 *= B2 }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = ((e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j]) % DIV + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check(h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] == $key\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\n$hash = Array.new(h){ Array.new(w, 0) }\n$tmp = Array.new(h){ Array.new(w, 0) }\ncalc(f2,$r,$c)\n$key = $hash[0][0]\ncalc(f1,h,w)\ncheck(h,w)"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n  rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n  rc_hash[rc[i]] += 1\n}\n\nmin_val = rc_hash.values.min\nmin_key = rc_hash.key(min_val)\nidx = rc.index(min_key)\n\n# p rc_hash\n# p min_val\n# p min_key\n# p idx\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\nh.times{|i|\n  0.upto(w-c){|j|\n    hash[i][hw[i][j,c]][j] = 1\n  }\n}\n\n# p hash\n# p \"hash done\"\n\nidx.upto(h-r+idx){|i|\n  if hash[i][rc[idx]]\n    # find candidate\n    hash[i][rc[idx]].each_key{|j|\n#      p \"can: #{i} #{j}\"\n      ans = true\n      0.upto(r-1){|k|\n#        p \"k: #{k} #{hw[i-idx+k][j,c]}  #{rc[k]}\"\n        unless hw[i-idx+k][j,c] == rc[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i-idx} #{j}\" if ans\n    }\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\n0.upto(h-r){|i|\n  0.upto(w-c){|j|\n    if hw[i][j,c] == rc[0] then\n      flag = true # it is candidate\n      (1).upto(r-1){|k|\n        unless hw[i+k][j,c] == rc[k] then\n          flag = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if flag\n    end\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 *= B1 }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c]) % DIV  if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 *= B2 }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j]) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check(h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] == $key\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\n$hash = Array.new(h){ Array.new(w, 0) }\n$tmp = Array.new(h){ Array.new(w, 0) }\ncalc(f2,$r,$c)\n$key = $hash[0][0]\ncalc(f1,h,w)\ncheck(h,w)"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 *= B1 }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = ((e*B1 - t1*f[i][j] + f[i][j+$c]) + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 *= B2 }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = ((e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j]) + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check(h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] == $key\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\n$hash = Array.new(h){ Array.new(w, 0) }\n$tmp = Array.new(h){ Array.new(w, 0) }\ncalc(f2,$r,$c)\n$key = $hash[0][0]\ncalc(f1,h,w)\ncheck(h,w)"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\n0.upto(h-r){|i|\n  offset = 0\n  loop do\n    j = hw[i].index(rc[0], offset)\n    break if j == nil\n    offset = j+1\n    flag = true # it is candidate\n    (1).upto(r-1){|k|\n      unless hw[i+k][j,c] == rc[k] then\n        flag = false\n        break\n      end\n    }\n    puts \"#{i} #{j}\" if flag\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\nh.times{|i|\n  0.upto(w-c){|j|\n    hash[i][hw[i][j,c]][j] = 1\n  }\n}\n\n#p \"hash done\"\n\n0.upto(h-r){|i|\n  if hash[i][rc[0]]\n    # find candidate\n    hash[i][rc[0]].each_key{|j|\n      ans = true\n      0.upto(r-1){|k|\n        unless hash[i+k][rc[k]][j] == 1\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if ans\n    }\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n  rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n  rc_hash[rc[i]] += 1\n}\n\nmin_val = rc_hash.values.min\nmin_key = rc_hash.key(min_val)\nidx = rc.index(min_key)\n\np idx\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\nh.times{|i|\n  0.upto(w-c){|j|\n    hash[i][hw[i][j,c]][j] = 1\n  }\n}\n\n#p \"hash done\"\n\nidx.upto(h-r+idx){|i|\n  if hash[i][rc[idx]]\n    # find candidate\n    hash[i][rc[idx]].each_key{|j|\n#      p \"can: #{i} #{j}\"\n      ans = true\n      0.upto(r-1){|k|\n        unless hw[i-idx+k][j,c] == rc[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if ans\n    }\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\ntemplate = rc.join\n\nexit if r > h || c > w\n\n0.upto(h-r){|i|\n  offset = 0\n  loop do\n    j = hw[i].index(rc[0], offset)\n    break if j == nil\n    offset = j+1\n    candidate = \"\"\n    0.upto(r-1){|k|\n      candidate << hw[i+k][j,c]\n    }\n    puts \"#{i} #{j}\" if candidate == template\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<16\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = e*B1 - t1*f[i][j] + f[i][j+$c] if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] if i < r - $r\n    end\n  end\nend\n\ndef check(h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\n$hash = Array.new(h){ Array.new(w, 0) }\n$tmp = Array.new(h){ Array.new(w, 0) }\ncalc(f2,$r,$c)\n$key = $hash[0][0]\ncalc(f1,h,w)\ncheck(h,w)"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<16\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  f = f ? $f1 : $f2\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c] + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\n$hash = Array.new($h){ Array.new($w, 0) }\n$tmp = Array.new($h){ Array.new($w, 0) }\ncalc(nil,$r,$c)\n$key = $hash[0][0]\ncalc(true,$h,$w)\ncheck"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  if t.index(p) == nil then\n    puts \"0\"\n  else\n    puts \"1\"\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\nh.times{|i|\n  0.upto(w-c){|j|\n    hash[i][hw[i][j,c]][j] = 1\n  }\n}\n\n#p \"hash done\"\n\n0.upto(h-r){|i|\n  if hash[i][rc[0]]\n    # find candidate\n    hash[i][rc[0]].each_key{|j|\n      ans = true\n      1.upto(r-1){|k|\n        unless hash[i+k][rc[k]][j] == 1\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if ans\n    }\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "B = 101\nDIV = 1<<32\ndef rolling_hash(s, n)\n  hash = Array.new(n+1)\n  hash[0] = 0\n  n.times{ |i| hash[i+1] = (hash[i]*B + s[i].ord) % DIV }\n  hash\nend\n\ndef init(r, c)\n  f = Array.new(r)\n  r.times do |i|\n    f[i] = rolling_hash(gets.chomp, c)\n  end\n  f\nend\n\ndef check(i, j)\n  $r.times do |y|\n    $c.times do |x|\n      return if ($f1[i+y][j+x] - $f1[i+y][j]*$p[x]) % DIV != $f2[y][x]\n    end\n  end\n  puts \"#{i} #{j}\" \nend\n\nh, w = gets.split.map(&:to_i)\n\n$p = Array.new(w+1)\n$p[0] = 1\nw.times{ |i| $p[i+1] = $p[i]*B % DIV }\n\n$f1 = init(h, w)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r, $c)\n(0..h-$r).each do |i|\n  (0..w-$c).each do |j|\n    check(i, j)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 101\nB2 = 97\nDIV = 1<<16\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  f = f ? $f1 : $f2\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c]) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j]) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\n$hash = Array.new($h){ Array.new($w, 0) }\n$tmp = Array.new($h){ Array.new($w, 0) }\ncalc(nil,$r,$c)\n$key = $hash[0][0]\ncalc(true,$h,$w)\ncheck"
  },
  {
    "language": "Ruby",
    "code": "B1 = 97\nB2 = 101\nDIV = 1 << 32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  tmp = Array.new(r){ Array.new(c, 0) }\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c] + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*tmp[i][j] + tmp[i+$r][j] + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\nh, w = gets.split.map(&:to_i)\nf1 = init(h)\n$r, $c = gets.split.map(&:to_i)\nf2 = init($r)\nif h >= $r && w >= $c\n  $hash = Array.new(h){ Array.new(w, 0) }\n  calc(f2,$r,$c)\n  key = $hash[0][0]\n  calc(f1,h,w)\n  h.times do |i|\n    w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == key % DIV\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 63533\nB2 = 100007\nDIV = 1<<32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  f = f ? $f1 : $f2\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c] + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\nif $h >= $r && $w >= $c\n  $hash = Array.new($h){ Array.new($w, 0) }\n  $tmp = Array.new($h){ Array.new($w, 0) }\n  calc(nil,$r,$c)\n  $key = $hash[0][0]\n  calc(true,$h,$w)\n  check\nend"
  },
  {
    "language": "Ruby",
    "code": "B1 = 63533\nB2 = 100007\nDIV = 1<<32\n\ndef init(r)\n  f = Array.new(r){ Array.new }\n  r.times do |i|\n    f[i] = gets.chomp.split(\"\").map(&:ord)\n  end\n  f\nend\n\ndef calc(f, r, c)\n  f = f ? $f1 : $f2\n  t1 = 1\n  $c.times{ t1 = t1 * B1 % DIV }\n  r.times do |i|\n    e = 0\n    $c.times do |j|\n      e = e*B1 + f[i][j]\n    end\n    (0..c-$c).each do |j|\n      $tmp[i][j] = e\n      e = (e*B1 - t1*f[i][j] + f[i][j+$c] + DIV) % DIV if j < c - $c\n    end\n  end\n\n  t2 = 1\n  $r.times{ t2 = t2 * B2 % DIV }\n  (0..c-$c).each do |j|\n    e = 0\n    $r.times{ |i| e = e*B2 + $tmp[i][j] }\n    (0..r-$r).each do |i|\n      $hash[i][j] = e\n      e = (e*B2 - t2*$tmp[i][j] + $tmp[i+$r][j] + DIV) % DIV if i < r - $r\n    end\n  end\nend\n\ndef check\n  $h.times do |i|\n    $w.times do |j|\n      puts \"#{i} #{j}\" if $hash[i][j] % DIV == $key % DIV\n    end\n  end\nend\n\n$h, $w = gets.split.map(&:to_i)\n$f1 = init($h)\n$r, $c = gets.split.map(&:to_i)\n$f2 = init($r)\n$hash = Array.new($h){ Array.new($w, 0) }\n$tmp = Array.new($h){ Array.new($w, 0) }\ncalc(nil,$r,$c)\n$key = $hash[0][0]\ncalc(true,$h,$w)\ncheck"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = [] }\n\nif r <= c then\n  rc = []\n  r.times{|i|\n    rc[i] = gets.chomp\n    rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n    rc_hash[rc[i]] += 1\n  }\n\n  idx = rc.index(rc_hash.min {|a, b| a[1] <=> b[1] }[0])\n\n  idx.upto(h-r-idx){|i|\n    0.upto(w-c){|j|\n      hash[hw[i][j,c]] << \"#{i} #{j}\"\n    }\n  }\n  key = rc[idx]\n  if hash[key] then\n    hash[key].each{|ij|\n      i, j = ij.split.map(&:to_i)\n      ans = true\n      r.times{|k|\n        unless hw[i-idx+k][j,c] == rc[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i-idx} #{j}\" if ans\n    }\n  end\n else\n   #transpose mode\n  mat = Array.new(w){Array.new(h)}\n  h.times{|i|\n    tmp = hw[i].split(\"\")\n    w.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  wh = []\n  w.times{|j|\n    wh[j] = mat[j].join\n  }\n  mat = Array.new(c){Array.new(r)}\n  r.times{|i|\n    tmp = gets.chomp.split(\"\")\n    c.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  cr_hash = {}\n  cr = []\n  c.times{|j|\n    cr[j] = mat[j].join\n    cr_hash[cr[j]] = 0 unless cr_hash[cr[j]]\n    cr_hash[cr[j]] += 1\n  }\n  idx = cr.index(cr_hash.min {|a, b| a[1] <=> b[1] }[0])\n  key = cr[idx]\n  0.upto(h-r){|i|\n    idx.upto(w-c+idx){|j|\n      hash[wh[j][i,r]] << \"#{i} #{j}\"\n    }\n  }\n  if hash[key] then\n    hash[key].each{|ij|\n      i, j = ij.split.map(&:to_i)\n      ans = true\n      c.times{|k|\n        unless wh[j-idx+k][i,r] == cr[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i} #{j-idx}\" if ans\n    }\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n  rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n  rc_hash[rc[i]] += 1\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\n\n# if r < c then\nmin_val = rc_hash.values.min\nmin_key = rc_hash.key(min_val)\nidx = rc.index(min_key)\n# p rc_hash\n# p min_val\n# p min_key\n# p idx\n\nkey = rc[idx]\n0.upto(h-1){|i|\n  0.upto(w-c){|j|\n    hash[hw[i][j,c]][i][j] = 1\n  }\n}\nif hash[key] then\n  hash[key].each_key{|i|\n    next if i - idx < 0 || i - idx + r > h\n    hash[key][i].each_key{|j|\n#      p \"can: #{i} #{j}\"\n      ans = true\n      0.upto(r-1){|k|\n        # p \"k: #{h} #{i-idx+k}\"\n        #         p \"k: #{k} #{hw[i-idx+k][j,c]}\"\n        unless hw[i-idx+k][j,c] == rc[k] then\n          ans = false\n          break\n        end\n      }\n      puts \"#{i-idx} #{j}\" if ans\n    }\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nrc_hash = {}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n  rc_hash[rc[i]] = 0 unless rc_hash[rc[i]]\n  rc_hash[rc[i]] += 1\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\n\nif r < c then\n  min_val = rc_hash.values.min\n  min_key = rc_hash.key(min_val)\n  idx = rc.index(min_key)\n  # p rc_hash\n  # p min_val\n  # p min_key\n  # p idx\n\n  key = rc[idx]\n  h.times{|i|\n    0.upto(w-c){|j|\n      hash[hw[i][j,c]][i][j] = 1\n    }\n  }\n  if hash[key] then\n    hash[key].each_key{|i|\n      next if i - idx < 0 || i - idx + r > h\n      hash[key][i].each_key{|j|\n        #      p \"can: #{i} #{j}\"\n        ans = true\n        0.upto(r-1){|k|\n          # p \"k: #{h} #{i-idx+k}\"\n          #         p \"k: #{k} #{hw[i-idx+k][j,c]}\"\n          unless hw[i-idx+k][j,c] == rc[k] then\n            ans = false\n            break\n          end\n        }\n        puts \"#{i-idx} #{j}\" if ans\n      }\n    }\n  end\n else\n   #transpose mode\n  mat = Array.new(w){Array.new(h)}\n  h.times{|i|\n    tmp = hw[i].split(\"\")\n    tmp.size.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  wh = []\n  w.times{|j|\n    wh[j] = mat[j].join\n  }\n#  p wh\n  mat = Array.new(c){Array.new(r)}\n  r.times{|i|\n    tmp = rc[i].split(\"\")\n    tmp.size.times{|j|\n      mat[j][i] = tmp[j]\n    }\n  }\n  cr_hash = {}\n  cr = []\n  c.times{|j|\n    cr[j] = mat[j].join\n    cr_hash[cr[j]] = 0 unless cr_hash[cr[j]]\n    cr_hash[cr[j]] += 1\n  }\n  min_val = cr_hash.values.min\n  min_key = cr_hash.key(min_val)\n  idx = cr.index(min_key)\n  key = cr[idx]\n  0.upto(h-r){|i|\n    w.times{|j|\n      hash[wh[j][i,r]][i][j] = 1\n    }\n  }\n#  p idx\n  if hash[key] then\n    hash[key].each_key{|i|\n      hash[key][i].each_key{|j|\n        next if j-idx < 0 || j-idx+c > w\n#        p \"can: #{i} #{j}\"\n        ans = true\n        0.upto(c-1){|k|\n          # p \"k: #{h} #{i-idx+k}\"\n#          p \"k: #{k} #{wh[j-idx+k][i,r]}  #{cr[k]}\"\n          unless wh[j-idx+k][i,r] == cr[k] then\n            ans = false\n            break\n          end\n        }\n        puts \"#{i} #{j-idx}\" if ans\n      }\n    }\n  end\n  \nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp.split(\"\")\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp.split(\"\")\n}\n\nexit if r > h || c > w\nif r > c then\n  h, w = w, h\n  hw = hw.transpose\n  r, c = c, r\n  rc = rc.transpose\n  0.upto(w-c){|j|\n    0.upto(h-r){|i|\n      if hw[i][j,c] == rc[0] then\n        flag = true # it is candidate\n        (1).upto(r-1){|k|\n          unless hw[i+k][j,c] == rc[k] then\n            flag = false\n            break\n          end\n        }\n        puts \"#{j} #{i}\" if flag\n      end\n    }\n  }\nelse\n  0.upto(h-r){|i|\n    0.upto(w-c){|j|\n      if hw[i][j,c] == rc[0] then\n        flag = true # it is candidate\n        (1).upto(r-1){|k|\n          unless hw[i+k][j,c] == rc[k] then\n            flag = false\n            break\n          end\n        }\n        puts \"#{i} #{j}\" if flag\n      end\n    }\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = {}\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\nhash = Hash.new { |ha,k| ha[k] = Hash.new(&ha.default_proc) }\n\n0.upto(w-c){|j|\n#  p j\n  str = []\n  r.times{|i|\n    if i == 0\n      str = [hw[i][j,c]]\n    else\n      str.push(hw[i][j,c])\n    end\n  }\n  (h-r).times{|i|\n    hash[str.join][i][j] = 1\n    str.shift()\n    str.push(hw[i+r][j,c])\n  }\n  hash[str.join][h-r][j] = 1\n}\n\nit = rc.join\nif hash[it] then\n  hash[it].sort.each{|i, val|\n    hash[it][i].sort.each{|j, v|\n      puts \"#{i} #{j}\"\n    }\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\nhw = []\nh.times{|i|\n  hw[i] = gets.chomp\n}\nr, c = gets.split.map(&:to_i)\nrc = []\nr.times{|i|\n  rc[i] = gets.chomp\n}\n\nexit if r > h || c > w\n\n0.upto(h-r){|i|\n  0.upto(w-c){|j|\n    if hw[i][j,c] == rc[0] then\n      flag = true # it is candidate\n      (1).upto(c-1){|k|\n        unless hw[i+k][j,c] == rc[k] then\n          flag = false\n          break\n        end\n      }\n      puts \"#{i} #{j}\" if flag\n    end\n  }\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"strconv\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Area interface {\n\tcontent() [][]int\n}\n\ntype Pattern [][]int\n\nfunc (p Pattern) content() [][]int {\n\treturn p\n}\n\ntype Board [][]int\n\nfunc (b Board) content() [][]int {\n\treturn b\n}\n\nfunc equal(xs []int, ys []int) bool {\n\tif xs == nil {\n\t\treturn ys == nil\n\t} else if ys == nil {\n\t\treturn xs == nil\n\t}\n\tif len(xs) != len(ys) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(xs); i++ {\n\t\tif xs[i] != ys[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc Rows(area Area) [][]int {\n\treturn area.content()\n}\n\nfunc Cols(area Area) [][]int {\n\tp := area.content()\n\tif len(p) == 0 {\n\t\tpanic(fmt.Errorf(\"pattern should have more than one rows\"))\n\t}\n\tres := make([][]int, len(p[0]))\n\tfor i := 0; i < len(res); i++ {\n\t\tres[i] = make([]int, len(p))\n\t\tfor j := 0; j < len(res[i]); j++ {\n\t\t\tres[i][j] = p[j][i]\n\t\t}\n\t}\n\treturn res\n}\n\nfunc computeRowFunction(pattern Pattern) func(int)int {\n\treturn computeFunction(Rows(pattern))\n}\n\nfunc computeColFunction(pattern Pattern) func(int)int {\n\treturn computeFunction(Cols(pattern))\n}\n\nfunc computeFunction(is [][]int) func(int)int {\n\tres := make([]int, len(is))\n\tk := 0\n\n\tfor i := 1; i < len(is); i++ {\n\t\tfor k > 0 && !equal(is[k], is[i]) {\n\t\t\tk = res[k-1]\n\t\t}\n\t\tif equal(is[k], is[i]) {\n\t\t\tk += 1\n\t\t\tres[i] = k\n\t\t}\n\t}\n\n\treturn func(index int) int {\n\t\treturn res[index]\n\t}\n}\n\ntype Position struct {\n\tr int\n\tc int\n}\n\nfunc (p Position) String() string {\n\treturn strconv.Itoa(p.r) + \" \" + strconv.Itoa(p.c)\n}\n\nfunc doMatch(pattern Pattern, rowF func(int)int, colF func(int)int, board Board) []Position {\n\tbRows := Rows(board)\n\tbCols := Cols(board)\n\tpRows := Rows(pattern)\n\tpCols := Cols(pattern)\n\tres := []Position{}\n\n\t/* TODO: is it possible (and faster) to apply KMP for rows as well as cols? */\n\tfor i := 0; i < len(bRows)-len(pRows)+1; i++ {\n\t\tk := 0\n\t\tfor j := 0; j < len(bCols); j++ {\n\t\t\tfor k > 0 && !equal(pCols[k], bCols[j][i:i+len(pRows)]) {\n\t\t\t\tk = colF(k-1)\n\t\t\t}\n\t\t\tif equal(pCols[k], bCols[j][i:i+len(pRows)]) {\n\t\t\t\tk += 1\n\t\t\t\tif k == len(pCols) {\n\t\t\t\t\tres = append(res, Position{i, j - k + 1})\n\t\t\t\t\tk = colF(k-1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc Match(pattern Pattern, board Board) []Position {\n\trowF := computeRowFunction(pattern)\n\tcolF := computeColFunction(pattern)\n\treturn doMatch(pattern, rowF, colF, board)\n}\n\nfunc main() {\n\tvar r, c int\n\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tr, err := nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tc, err = nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tboard := make(Board, r)\n\tfor i := 0; i < r; i++ {\n\t\tboard[i] = make([]int, c)\n\t\tfor j, ch := range nextText(sc) {\n\t\t\tboard[i][j] = int(ch)\n\t\t}\n\t}\n\t\n\tr, err = nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tc, err = nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpattern := make(Pattern, r)\n\tfor i := 0; i < r; i++ {\n\t\tpattern[i] = make([]int, c)\n\t\tfor j, ch := range nextText(sc) {\n\t\t\tpattern[i][j] = int(ch)\n\t\t}\n\t}\n\n\tpositions := Match(pattern, board)\n\tif len(positions) > 0 {\n\t\tstrs := make([]string, len(positions))\n\t\tfor i := 0; i < len(strs); i++ {\n\t\t\tstrs[i] = positions[i].String()\n\t\t}\n\t\tfmt.Println(strings.Join(strs, \"\\n\"))\n\t}\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\treturn strconv.Atoi(nextText(sc))\n}\n\nfunc nextText(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar BR uint64 = 9973\nvar BC uint64 = 100000007\n\nfunc main() {\n\tvar h,w,r,c int\n\tfmt.Scan(&h)\n\tfmt.Scan(&w)\n\n\tfield := make([][]rune, h)\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tfor i := 0; i < h; i++ {\n\t\tsc.Scan()\n\t\tfield[i] = []rune(sc.Text())\n\t}\n\tsc.Scan()\n\tr, _ = strconv.Atoi(sc.Text())\n\tsc.Scan()\n\tc, _ = strconv.Atoi(sc.Text())\n\n\tif h < r || w < c {\n\t\treturn\n\t}\n\n\tpattern := make([][]rune, r)\n\tfor i := 0; i < r; i++ {\n\t\tsc.Scan()\n\t\tpattern[i] = []rune(sc.Text())\n\t}\n\n\tph1 := make([]uint64, r)\n\tvar ph2 uint64 = 0\n\tfor i := 0; i < r; i++ {\n\t\tfor j := 0; j < c; j++ {\n\t\t\tph1[i] = uint64(pattern[i][j]) + ph1[i]*BR\n\t\t}\n\t\tph2 = ph1[i] + ph2*BC\n\t}\n\n\tvar brc,bcr uint64 = 1,1\n\tfor i := 0; i < c; i++ {\n\t\tbrc *= BR\n\t}\n\tfor i := 0; i < r; i++ {\n\t\tbcr *= BC\n\t}\n\n\tfh1 := make([][]uint64, h)\n\tfor i := 0; i < h; i++ {\n\t\tfh1[i] = make([]uint64, w-c+1)\n\t\tfor j := 0; j < c; j++ {\n\t\t\tfh1[i][0] = uint64(field[i][j]) + fh1[i][0]*BR\n\t\t}\n\t\tfor j := 1; j <= w-c; j++ {\n\t\t\tfh1[i][j] = fh1[i][j-1]*BR + uint64(field[i][j+c-1]) - uint64(field[i][j-1])*brc\n\t\t}\n\t}\n\n\tfh2 := make([][]uint64, h-r+1)\n\tfor j := 0; j <= w-c; j++ {\n\t\tif j == 0 {\n\t\t\tfh2[0] = make([]uint64, w-c+1)\n\t\t}\n\t\tfor i := 0; i < r; i++ {\n\t\t\tfh2[0][j] = fh1[i][j] + fh2[0][j]*BC\n\t\t}\n\t\tfor i := 1; i <= h-r; i++ {\n\t\t\tif j == 0 {\n\t\t\t\tfh2[i] = make([]uint64, w-c+1)\n\t\t\t}\n\t\t\tfh2[i][j] = fh2[i-1][j]*BC + fh1[i+r-1][j] - fh1[i-1][j]*bcr\n\t\t}\n\t}\n\n\twr := bufio.NewWriter(os.Stdout)\n\tfor i := 0; i <= h-r; i++ {\n\t\tfor j := 0; j <= w-c; j++ {\n\t\t\tif fh2[i][j] == ph2 {\n\t\t\t\twr.WriteString(strconv.Itoa(i) + \" \" + strconv.Itoa(j) + \"\\n\")\n\t\t\t}\n\t\t}\n\t}\n\twr.Flush()\n}\n"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x mod p3) in\n  doit 0 1\n\nlet solve a (h, w) b (r, c) =\n  let make_hash v (y, x) =\n    let h1 = Array.make_matrix y x 0 in\n    let c1 = pow p1 c in\n    let rec duduwa i =\n      if i < y then begin\n        let rec calc_z j acc =\n          if j = c then acc\n          else calc_z (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n        let rec aux j z =\n          if j = x - c then h1.(i).(j) <- z\n          else begin\n            h1.(i).(j) <- z;\n            let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n            aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        duduwa (i + 1)\n      end in\n    duduwa 0;\n    let h2 = Array.make_matrix y x 0 in\n    let c2 = pow p2 r in\n    let rec doit j =\n      if j < x then begin\n        let rec calc_z i acc =\n          if i = r then acc\n          else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n        let rec aux i z =\n          if i = y - r then h2.(i).(j) <- z\n          else begin\n            h2.(i).(j) <- z;\n            let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n            aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        doit (j + 1)\n      end in\n    doit 0;\n    h2 in\n  let s = make_hash a (h, w) in\n  let t = make_hash b (r, c) in\n  let rec doit = function\n    | (i, _) when i > h - r -> ()\n    | (i, j) when j > w - c -> doit (i + 1, 0)\n    | (i, j) ->\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet split str delim =\n  let open String in\n  let rec doit s acc =\n    match\n      try Some (rindex s delim) with _ -> None\n    with\n    | None -> s :: acc\n    | Some i -> doit (sub s 0 i) (sub s (i + 1) (length s - i - 1) :: acc) in\n  doit str []\n\nlet str_to_list str =\n  let rec doit i acc =\n    if i < 0 then acc\n    else doit (i - 1) (String.get str i :: acc) in\n  doit (String.length str - 1) []\n\nlet input_array y x =\n  let a = Array.make_matrix y x '\\000' in\n  let rec doit i =\n    if i = y then a\n    else begin\n      let rec aux j = function\n        | [] -> ()\n        | c :: cs -> a.(i).(j) <- c; aux (j + 1) cs in\n      aux 0 (str_to_list (read_line ()));\n      doit (i + 1)\n    end in\n  doit 0\n\nlet () =\n  match List.map int_of_string (split (read_line ()) ' ') with\n  | [h; w] ->\n    begin\n      let a = input_array h w in\n      match List.map int_of_string (split (read_line ()) ' ') with\n      | [r; c] when h < r || w < c -> ()\n      | [r; c] ->\n        let b = input_array r c in\n        solve a (h, w) b (r, c)\n      | _ -> exit 1\n    end\n  | _ -> exit 1"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet pow x n =\n  let rec doit x n acc =\n    if n = 0 then acc\n    else if n mod 2 = 0 then doit (x * x mod p3) (n / 2) acc\n    else doit (x * x mod p3) (n / 2) (acc * x mod p3) in\n  doit x n 1\n\nlet hash x c = (x + c) mod p3\n\nlet make_hash v (x, y) (r, c) =\n  let h1 = Array.make_matrix x y 0 in\n  let c1 = pow p1 c in\n  for i = 0 to x - 1 do\n    let rec aux j acc =\n      if j = c then acc\n      else hash (acc*p1) (Char.code v.(i).(j)) |> aux (j + 1)  in\n    let rec doit j z =\n      if j = y - c then h1.(i).(j) <- z\n      else begin\n        h1.(i).(j) <- z;\n        let z = hash (z*p1) (Char.code v.(i).(j+c) - Char.code v.(i).(j) * c1) in\n        doit (j + 1) (if z < 0 then z + p3 else z)\n      end in\n    aux 0 0 |> doit 0;\n  done;\n  let h2 = Array.make_matrix x y 0 in\n  let c2 = pow p2 r in\n  for j = 0 to y - 1 do\n    let rec aux i acc =\n      if i = r then acc\n      else hash (acc*p2) h1.(i).(j) |> aux (i + 1) in\n    let rec doit i z =\n      if i = x - r then h2.(i).(j) <- z\n      else begin\n        h2.(i).(j) <- z;\n        let z = hash (z*p2) (h1.(i+r).(j) - h1.(i).(j) * c2) in\n        doit (i + 1) (if z < 0 then z + p3 else z)\n      end in\n    aux 0 0 |> doit 0;\n  done;\n  h2\n\nlet solve (h, w) (r, c) a b =\n  let s = make_hash a (h, w) (r, c) in\n  let t = make_hash b (r, c) (r, c) in\n  for i = 0 to h - r do\n    for j = 0 to w -c do\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n    done\n  done\n\nlet read_array x y =\n  let a = Array.make_matrix x y '\\000' in\n  for i = 0 to x - 1 do\n    let l = read_line () in\n    for j = 0 to y - 1 do\n      a.(i).(j) <- l.[j];\n    done\n  done;\n  a\n\nlet () =\n  match read_line () |> split_on_char ' ' |> List.map int_of_string with\n  | [h; w] ->\n    begin\n      let a = read_array h w in\n      match read_line () |> split_on_char ' ' |> List.map int_of_string with\n      | [r; c] ->\n        if h < r || w < c then ()\n        else read_array r c |> solve (h, w) (r, c) a\n      | _ -> assert false\n    end\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "open Scanf\nopen Printf\n       \nlet id x = x\nlet tuple x y = (x, y)\n             \nlet calc_rh a h w r c =\n  let bh = 10007 in\n  let bv = 999983 in\n  let rec pow x n =\n    if n = 0 then 1\n    else if n mod 2 = 0 then let y = pow x (n / 2) in y * y\n    else x * pow x (n-1) in\n  let rh a b i j =\n    let rec iter r k =\n      if k = j then r\n      else iter (r * b + a.(k)) (k+1) in\n    iter 0 i\n  in\n  let bh' = pow bh c in\n  let ta = Array.make_matrix h (w - c + 1) 0 in\n  let rec set_ta i j =\n    if i = h then ()\n    else if j = w - c + 1 then set_ta (i+1) 0\n    else begin\n        if j = 0 then ta.(i).(j) <- rh a.(i) bh 0 c\n        else ta.(i).(j) <- ta.(i).(j-1) * bh + a.(i).(j+c-1) - a.(i).(j-1) * bh';\n        set_ta i (j+1)\n      end\n  in\n  let bv' = pow bv r in\n  let rht = Array.make_matrix (h - r + 1) (w - c + 1) 0 in\n  let rec set_rht i j =\n    if j = w - c + 1 then ()\n    else if i = h - r + 1 then set_rht 0 (j+1)\n    else begin\n        if i = 0 then rht.(i).(j) <- rh (Array.init r (fun k -> ta.(k).(j))) bv 0 r\n        else rht.(i).(j) <- rht.(i-1).(j) * bv + ta.(i+r-1).(j) - ta.(i-1).(j) * bv';\n        set_rht (i+1) j\n      end\n  in\n  set_ta 0 0;\n  set_rht 0 0;\n  rht\n    \nlet () =\n  let h, w = scanf \"%d %d \" tuple in\n  let fld = Array.init h (fun _ ->\n                          let s = scanf \"%s \" id in\n                          Array.init w (fun i -> \n                                        Char.code s.[i]\n                                     )\n                         ) in\n  let r, c = scanf \"%d %d \" tuple in\n  let ptn = Array.init r (fun _ ->\n                          let s = scanf \"%s \" id in\n                          Array.init c (fun i -> \n                                        Char.code s.[i]\n                                       )\n                         ) in\n  let ft = calc_rh fld h w r c in\n  let pt = calc_rh ptn r c r c in\n  let rec loop i j =\n    if i = h - r + 1 then ()\n    else if j = w - c + 1 then loop (i+1) 0\n    else begin\n        if ft.(i).(j) = pt.(0).(0) then printf \"%d %d\\n\" i j;\n        loop i (j+1)\n      end\n  in\n  loop 0 0"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x mod p3) in\n  doit 0 1\n\nlet solve a (h, w) b (r, c) =\n  let make_hash v (y, x) =\n    let h1 = Array.make_matrix y x 0 in\n    let c1 = pow p1 c in\n    let rec duduwa i =\n      if i < y then begin\n        let rec calc_z j acc =\n          if j = c then acc\n          else calc_z (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n        let rec aux j z =\n          if j = x - c then h1.(i).(j) <- z\n          else begin\n            h1.(i).(j) <- z;\n            let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n            aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        duduwa (i + 1)\n      end in\n    duduwa 0;\n    let h2 = Array.make_matrix y x 0 in\n    let c2 = pow p2 r in\n    let rec doit j =\n      if j < x then begin\n        let rec calc_z i acc =\n          if i = r then acc\n          else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n        let rec aux i z =\n          if i = y - r then h2.(i).(j) <- z\n          else begin\n            h2.(i).(j) <- z;\n            let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n            aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        doit (j + 1)\n      end in\n    doit 0;\n    h2 in\n  let s = make_hash a (h, w) in\n  let t = make_hash b (r, c) in\n  let rec doit = function\n    | (i, _) when i > h - r -> ()\n    | (i, j) when j > w - c -> doit (i + 1, 0)\n    | (i, j) ->\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet input_array y x =\n  let a = Array.make_matrix y x '\\000' in\n  let rec doit = function\n    | (i, _) when i = y -> a\n    | (i, j) when j = x -> doit (i + 1, 0)\n    | (i, j) ->\n      a.(i).(j) <- Scanf.scanf \"%c \" (fun c -> c);\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet () =\n  let (h, w) = Scanf.scanf \"%d %d\\n\" (fun h w -> (h, w)) in\n  let a = input_array h w in\n  let (r, c) = Scanf.scanf \"%d %d\\n\" (fun r c -> (r, c)) in\n  let b = input_array r c in\n  solve a (h, w) b (r, c)"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x mod p3) in\n  doit 0 1\n\nlet solve a (h, w) b (r, c) =\n  let make_hash v (y, x) =\n    let h1 = Array.make_matrix y x 0 in\n    let c1 = pow p1 c in\n    let rec duduwa i =\n      if i < y then begin\n        let rec calc_z j acc =\n          if j = c then acc\n          else calc_z (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n        let rec aux j z =\n          if j = x - c then h1.(i).(j) <- z\n          else begin\n            h1.(i).(j) <- z;\n            let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n            aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        duduwa (i + 1)\n      end in\n    duduwa 0;\n    let h2 = Array.make_matrix y x 0 in\n    let c2 = pow p2 r in\n    let rec doit j =\n      if j < x then begin\n        let rec calc_z i acc =\n          if i = r then acc\n          else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n        let rec aux i z =\n          if i = y - r then h2.(i).(j) <- z\n          else begin\n            h2.(i).(j) <- z;\n            let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n            aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        doit (j + 1)\n      end in\n    doit 0;\n    h2 in\n  let s = make_hash a (h, w) in\n  let t = make_hash b (r, c) in\n  let rec doit = function\n    | (i, _) when i > h - r -> ()\n    | (i, j) when j > w - c -> doit (i + 1, 0)\n    | (i, j) ->\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet input_array y x =\n  let a = Array.make_matrix y x '\\000' in\n  let rec doit = function\n    | (i, _) when i = y -> a\n    | (i, j) when j = x -> doit (i + 1, 0)\n    | (i, j) ->\n      a.(i).(j) <- Scanf.scanf \"%c \" (fun c -> c);\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet () =\n  let (h, w) = Scanf.scanf \"%d %d\\n\" (fun h w -> (h, w)) in\n  let a = input_array h w in\n  let (r, c) = Scanf.scanf \"%d %d\\n\" (fun r c -> (r, c)) in\n  let b = input_array r c in\n  if h >= r && w >= c then solve a (h, w) b (r, c)"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x mod p3) in\n  doit 0 1\n\nlet solve a (h, w) b (r, c) =\n  let make_hash v (y, x) =\n    let h1 = Array.make_matrix y x 0 in\n    let c1 = pow p1 c in\n    let rec duduwa i =\n      if i < y then begin\n        let rec calc_z j acc =\n          if j = c then acc\n          else calc_z (j + 1) ((acc*p1 + Char.code (v.(i).(j))) mod p3) in\n        let rec aux j z =\n          if j = x - c then h1.(i).(j) <- z\n          else begin\n            h1.(i).(j) <- z;\n            let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n            aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        duduwa (i + 1)\n      end in\n    duduwa 0;\n    let h2 = Array.make_matrix y x 0 in\n    let c2 = pow p2 r in\n    let rec doit j =\n      if j < x then begin\n        let rec calc_z i acc =\n          if i = r then acc\n          else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n        let rec aux i z =\n          if i = y - r then h2.(i).(j) <- z\n          else begin\n            h2.(i).(j) <- z;\n            let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n            aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        doit (j + 1)\n      end in\n    doit 0;\n    h2 in\n  let s = make_hash a (h, w) in\n  let t = make_hash b (r, c) in\n  let rec doit = function\n    | (i, _) when i > h - r -> ()\n    | (i, j) when j > w - c -> doit (i + 1, 0)\n    | (i, j) ->\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet split str delim =\n  let open String in\n  let rec doit s acc =\n    match\n      try Some (rindex s delim) with _ -> None\n    with\n    | None -> s :: acc\n    | Some i -> doit (sub s 0 i) (sub s (i + 1) (length s - i - 1) :: acc) in\n  doit str []\n\nlet str_to_list str =\n  let rec doit i acc =\n    if i < 0 then acc\n    else doit (i - 1) (String.get str i :: acc) in\n  doit (String.length str - 1) []\n\nlet input_array y x =\n  let a = Array.make_matrix y x '\\000' in\n  let rec doit i =\n    if i = y then a\n    else begin\n      let rec aux j = function\n        | [] -> ()\n        | c :: cs -> a.(i).(j) <- c; aux (j + 1) cs in\n      aux 0 (str_to_list (read_line ()));\n      doit (i + 1)\n    end in\n  doit 0\n\nlet () =\n  match List.map int_of_string (split (read_line ()) ' ') with\n  | [h; w] ->\n    begin\n      let a = input_array h w in\n      match List.map int_of_string (split (read_line ()) ' ') with\n      | [r; c] ->\n        let b = input_array r c in\n        solve a (h, w) b (r, c)\n      | _ -> exit 1\n    end\n  | _ -> exit 1"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet pow x n =\n  let rec doit x n acc =\n    if n = 0 then acc\n    else if n mod 2 = 0 then doit (x * x mod p3) (n / 2) acc\n    else doit (x * x mod p3) (n / 2) (acc * x mod p3) in\n  doit x n 1\n\nlet make_hash v (x, y) (r, c) =\n  let h1 = Array.make_matrix x y 0 in\n  let c1 = pow p1 c in\n  for i = 0 to x - 1 do\n    let rec calc_z j acc =\n      if j = c then acc\n      else calc_z (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n    let rec aux j z =\n      if j = y - c then h1.(i).(j) <- z\n      else begin\n        h1.(i).(j) <- z;\n        let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n        aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n      end in\n    calc_z 0 0 |> aux 0;\n  done;\n  let h2 = Array.make_matrix x y 0 in\n  let c2 = pow p2 r in\n  for j = 0 to y - 1 do\n    let rec calc_z i acc =\n      if i = r then acc\n      else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n    let rec aux i z =\n      if i = x - r then h2.(i).(j) <- z\n      else begin\n        h2.(i).(j) <- z;\n        let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n        aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n      end in\n    calc_z 0 0 |> aux 0;\n  done;\n  h2\n\nlet solve (h, w) (r, c) a b =\n  let s = make_hash a (h, w) (r, c) in\n  let t = make_hash b (r, c) (r, c) in\n  for i = 0 to h - r do\n    for j = 0 to w -c do\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n    done\n  done\n\nlet read_array x y =\n  let a = Array.make_matrix x y '\\000' in\n  for i = 0 to x - 1 do\n    let l = read_line () in\n    for j = 0 to y - 1 do\n      a.(i).(j) <- l.[j];\n    done\n  done;\n  a\n\nlet () =\n  match read_line () |> split_on_char ' ' |> List.map int_of_string with\n  | [h; w] ->\n    begin\n      let a = read_array h w in\n      match read_line () |> split_on_char ' ' |> List.map int_of_string with\n      | [r; c] ->\n        if h < r || w < c then ()\n        else read_array r c |> solve (h, w) (r, c) a\n      | _ -> assert false\n    end\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x mod p3) in\n  doit 0 1\n\nlet solve a (h, w) b (r, c) =\n  let make_hash v (y, x) =\n    let h1 = Array.make_matrix y x 0 in\n    let c1 = pow p1 c in\n    let rec duduwa i =\n      if i < y then begin\n        let rec calc_z j acc =\n          if j = c then acc\n          else calc_z (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n        let rec aux j z =\n          if j = x - c then h1.(i).(j) <- z\n          else begin\n            h1.(i).(j) <- z;\n            let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n            aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        duduwa (i + 1)\n      end in\n    duduwa 0;\n    let h2 = Array.make_matrix y x 0 in\n    let c2 = pow p2 r in\n    let rec doit j =\n      if j < x then begin\n        let rec calc_z i acc =\n          if i = r then acc\n          else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n        let rec aux i z =\n          if i = y - r then h2.(i).(j) <- z\n          else begin\n            h2.(i).(j) <- z;\n            let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n            aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        doit (j + 1)\n      end in\n    doit 0;\n    h2 in\n  let s = make_hash a (h, w) in\n  let t = make_hash b (r, c) in\n  let rec doit = function\n    | (i, _) when i > h - r -> ()\n    | (i, j) when j > w - c -> doit (i + 1, 0)\n    | (i, j) ->\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet input_array y x =\n  let a = Array.make_matrix y x '\\000' in\n  let rec doit = function\n    | (i, _) when i = y -> a\n    | (i, j) when j = x -> doit (i + 1, 0)\n    | (i, j) ->\n      a.(i).(j) <- Scanf.scanf \"%c \" (fun c -> c);\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet () =\n  let (h, w) = Scanf.scanf \"%d %d\\n\" (fun h w -> (h, w)) in\n  let a = input_array h w in\n  let (r, c) = Scanf.scanf \"%d %d\\n\" (fun r c -> (r, c)) in\n  let b = input_array r c in\n  if h >= r && w >= c then solve a (h, w) b (r, c)"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x mod p3) in\n  doit 0 1\n\nlet solve a (h, w) b (r, c) =\n  let make_hash v (y, x) =\n    let h1 = Array.make_matrix y x 0 in\n    let c1 = pow p1 c in\n    let rec duduwa i =\n      if i < y then begin\n        let rec calc_z j acc =\n          if j = c then acc\n          else calc_z (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n        let rec aux j z =\n          if j = x - c then h1.(i).(j) <- z\n          else begin\n            h1.(i).(j) <- z;\n            let new_z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n            aux (j + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        duduwa (i + 1)\n      end in\n    duduwa 0;\n    let h2 = Array.make_matrix y x 0 in\n    let c2 = pow p2 r in\n    let rec doit j =\n      if j < x then begin\n        let rec calc_z i acc =\n          if i = r then acc\n          else calc_z (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n        let rec aux i z =\n          if i = y - r then h2.(i).(j) <- z\n          else begin\n            h2.(i).(j) <- z;\n            let new_z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n            aux (i + 1) (if new_z < 0 then new_z + p3 else new_z)\n          end in\n        aux 0 (calc_z 0 0);\n        doit (j + 1)\n      end in\n    doit 0;\n    h2 in\n  let s = make_hash a (h, w) in\n  let t = make_hash b (r, c) in\n  let rec doit = function\n    | (i, _) when i > h - r -> ()\n    | (i, j) when j > w - c -> doit (i + 1, 0)\n    | (i, j) ->\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n      doit (i, j + 1) in\n  doit (0, 0)\n\nlet split str delim =\n  let open String in\n  let rec doit s acc =\n    match\n      try Some (rindex s delim) with _ -> None\n    with\n    | None -> s :: acc\n    | Some i -> doit (sub s 0 i) (sub s (i + 1) (length s - i - 1) :: acc) in\n  doit str []\n\nlet str_to_list str =\n  let rec doit i acc =\n    if i < 0 then acc\n    else doit (i - 1) (String.get str i :: acc) in\n  doit (String.length str - 1) []\n\nlet input_array y x =\n  let a = Array.make_matrix y x '\\000' in\n  let rec doit i =\n    if i = y then a\n    else begin\n      let rec aux j = function\n        | [] -> ()\n        | c :: cs -> a.(i).(j) <- c; aux (j + 1) cs in\n      aux 0 (str_to_list (read_line ()));\n      doit (i + 1)\n    end in\n  doit 0\n\nlet () =\n  match List.map int_of_string (split (read_line ()) ' ') with\n  | [h; w] ->\n    begin\n      let a = input_array h w in\n      match List.map int_of_string (split (read_line ()) ' ') with\n      | [r; c] when h < r || w < c -> exit 0\n      | [r; c] ->\n        let b = input_array r c in\n        solve a (h, w) b (r, c)\n      | _ -> exit 1\n    end\n  | _ -> exit 1"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet pow x n =\n  let rec doit x n acc =\n    if n = 0 then acc\n    else if n mod 2 = 0 then doit (x * x mod p3) (n / 2) acc\n    else doit (x * x mod p3) (n / 2) (acc * x mod p3) in\n  doit x n 1\n\nlet make_hash v (x, y) (r, c) =\n  let h1 = Array.make_matrix x y 0 in\n  let c1 = pow p1 c in\n  for i = 0 to x - 1 do\n    let rec aux j acc =\n      if j = c then acc\n      else aux (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n    let rec doit j z =\n      if j = y - c then h1.(i).(j) <- z\n      else begin\n        h1.(i).(j) <- z;\n        let z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n        doit (j + 1) (if z < 0 then z + p3 else z)\n      end in\n    aux 0 0 |> doit 0;\n  done;\n  let h2 = Array.make_matrix x y 0 in\n  let c2 = pow p2 r in\n  for j = 0 to y - 1 do\n    let rec aux i acc =\n      if i = r then acc\n      else aux (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n    let rec doit i z =\n      if i = x - r then h2.(i).(j) <- z\n      else begin\n        h2.(i).(j) <- z;\n        let z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n        doit (i + 1) (if z < 0 then z + p3 else z)\n      end in\n    aux 0 0 |> doit 0;\n  done;\n  h2\n\nlet solve (h, w) (r, c) a b =\n  let s = make_hash a (h, w) (r, c) in\n  let t = make_hash b (r, c) (r, c) in\n  for i = 0 to h - r do\n    for j = 0 to w -c do\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n    done\n  done\n\nlet read_array x y =\n  let a = Array.make_matrix x y '\\000' in\n  for i = 0 to x - 1 do\n    let l = read_line () in\n    for j = 0 to y - 1 do\n      a.(i).(j) <- l.[j];\n    done\n  done;\n  a\n\nlet () =\n  match read_line () |> split_on_char ' ' |> List.map int_of_string with\n  | [h; w] ->\n    begin\n      let a = read_array h w in\n      match read_line () |> split_on_char ' ' |> List.map int_of_string with\n      | [r; c] ->\n        if h < r || w < c then ()\n        else read_array r c |> solve (h, w) (r, c) a\n      | _ -> assert false\n    end\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let (p1, p2, p3) = (257, 251, 1000000007)\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet pow x n =\n  let rec doit x n acc =\n    if n = 0 then acc\n    else if n mod 2 = 0 then doit (x * x mod p3) (n / 2) acc\n    else doit (x * x mod p3) (n / 2) (acc * x mod p3) in\n  doit x n 1\n\nlet make_hash v (x, y) (r, c) =\n  let h1 = Array.make_matrix x y 0 in\n  let c1 = pow p1 c in\n  for i = 0 to x - 1 do\n    let rec aux j acc =\n      if j = c then acc\n      else aux (j + 1) ((acc*p1 + Char.code v.(i).(j)) mod p3) in\n    let rec doit j z =\n      if j = y - c then h1.(i).(j) <- z\n      else begin\n        h1.(i).(j) <- z;\n        let z = (z*p1 - (Char.code v.(i).(j))*c1 + Char.code v.(i).(j+c)) mod p3 in\n        doit (j + 1) (if z < 0 then z + p3 else z)\n      end in\n    aux 0 0 |> doit 0;\n  done;\n  let h2 = Array.make_matrix x y 0 in\n  let c2 = pow p2 r in\n  for j = 0 to y - 1 do\n    let rec aux i acc =\n      if i = r then acc\n      else aux (i + 1) ((acc*p2 + h1.(i).(j)) mod p3) in\n    let rec doit i z =\n      if i = x - r then h2.(i).(j) <- z\n      else begin\n        h2.(i).(j) <- z;\n        let z = (z*p2 - h1.(i).(j)*c2 + h1.(i+r).(j)) mod p3 in\n        doit (i + 1) (if z < 0 then z + p3 else z)\n      end in\n    aux 0 0 |> doit 0;\n  done;\n  h2\n\nlet solve (h, w) (r, c) a b =\n  let s = make_hash a (h, w) (r, c) in\n  let t = make_hash b (r, c) (r, c) in\n  for i = 0 to h - r do\n    for j = 0 to w -c do\n      if s.(i).(j) = t.(0).(0) then Printf.printf \"%d %d\\n\" i j;\n    done\n  done\n\nlet read_array x y =\n  let a = Array.make_matrix x y '\\000' in\n  for i = 0 to x - 1 do\n    let l = read_line () in\n    for j = 0 to y - 1 do\n      a.(i).(j) <- l.[j];\n    done\n  done;\n  a\n\nlet () =\n  match read_line () |> split_on_char ' ' |> List.map int_of_string with\n  | [h; w] ->\n    begin\n      let a = read_array h w in\n      match read_line () |> split_on_char ' ' |> List.map int_of_string with\n      | [r; c] ->\n        if h < r || w < c then ()\n        else read_array r c |> solve (h, w) (r, c) a\n      | _ -> assert false\n    end\n  | _ -> assert false"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nprog = re.compile(p)\niter = prog.finditer(f)\nfor match in iter:\n    i = match.start()\n    print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "def get_common(string,len_string):\n    common_length=[0]*len_string\n    tmp=0\n    tmp_tmp=0\n    for i in range(1,len_string):\n        if(string[i]==string[tmp]):\n            tmp_tmp=tmp\n            while(string[i]==string[tmp_tmp] and tmp_tmp >0):\n                tmp_tmp=common_length[max([tmp_tmp-1,0])]\n            common_length[i-1]=tmp_tmp\n            tmp+=1\n        else:\n            common_length[i-1]=tmp\n            while(string[i]!=string[tmp] and tmp>0):\n                tmp=common_length[max([tmp-1,0])]\n            if(string[i]==string[tmp]):\n                tmp+=1\n\n    if(string[-1]==string[tmp-1]):\n        common_length[-1]=tmp\n    common_length[0]=0\n    return common_length\n\n\n\ndef find_str(field,field_row,pattern,common_length,H,W,h,w):\n    tmp=0\n    column_list=[]\n    len_pattern=len(pattern[0])\n    for i in range(len(field[field_row])):\n        if(field[field_row][i]!=pattern[0][tmp]):\n            while(field[field_row][i]!=pattern[0][tmp] and tmp>0):\n                tmp=common_length[0][max([tmp-1,0])]\n            if(field[field_row][i]==pattern[0][tmp]):\n                tmp+=1\n        else:\n            tmp+=1\n            if(tmp==len_pattern):\n                column_list.append(i-tmp+1)\n                tmp=common_length[0][-1]\n    \n    \n    \n    for j in range(1,h):\n        tmp=0\n        for loop in range(len(column_list)):\n            column=column_list[loop]\n            if(loop < len(column_list) -1):\n                next_column=column_list[loop+1]\n            else:\n                next_column=len(field[0])+len(pattern[0])+1\n            ini_tmp=tmp\n            for i in range(0,len_pattern+1):\n                if(field[field_row+j][column+ i+ini_tmp]!=pattern[j][tmp]):\n                    if(i < next_column - column):\n                        tmp=0\n                        column_list.pop(loop)\n                        break\n                    else:\n                        while(tmp>column+i-next_column+1):\n                            tmp=common_length[0][max([tmp-1,0])]\n                        if(tmp!=column+i-next_column+1):\n                            tmp=0\n                        column_list.pop(loop)\n                        break\n                else:\n                    tmp+=1\n                    if(tmp==len_pattern):\n                        if(i < next_column - column):\n                            tmp=0\n                            break\n                        else:\n                            while(tmp>column+i-next_column+1):\n                                tmp=common_length[0][max([tmp-1,0])]\n                            if(tmp!=column+i-next_column+1):\n                                tmp=0\n                            break\n    for column in column_list:\n        print(f\"{field_row} {column}\")\n\n\n\n\n\n\n\n\n\n\nH,W=map(int,input().split())\nfield=[]\nfor i in range(H):\n    field.append(input())\nh,w=map(int,input().split())\npattern=[]\nfor i in range(h):\n    pattern.append(input())\n\ncommon_length=[]\nfor i in range(h):\n    common_length.append(get_common(pattern[i],w))\n\nfor i in range(H-h+1):\n    find_str(field,i,pattern,common_length,H,W,h,w)\n"
  },
  {
    "language": "Python",
    "code": "CSIZE = 256\n\ndef make_bm_table(pattern,size):\n    bm_table = [size]*CSIZE\n    for i in range(size):\n        dist = size-i-1\n        charac = pattern[i]\n        bm_table[ord(charac)] = dist\n    return bm_table\n\ndef bm_search(pattern,buff): \n        size = C\n        bm_table = make_bm_table(pattern[0], size)    \n        buffsize = W\n        for j in range(H-C):\n            saikobi = size-1\n            while saikobi < buffsize:\n                for i in range(size):\n                    if pattern[0][size-i-1] != buff[j][saikobi-i]:\n                        saikobi += max(bm_table[ord(buff[j][saikobi-i])]-i,1)\n                        break\n                else:\n                    count = 1\n                    for k in range(1,R):\n                        for l in range(C)[::-1]: \n                            if pattern[k][size-1-l] != buff[j+k][saikobi-l]:\n                                count = 0\n                                break\n                        if count == 0:\n                            break\n                    else:\n                        print(j,saikobi-C+1)\n                    saikobi += 1  \n                    \n            \n\nH,W = map(int,input().split())\nbuff = [\"\"]*H\nfor i in range(H):\n    buff[i] = input()\n    \nR,C = map(int,input().split())\npattern = [\"\"]*R\nfor i in range(R):\n    pattern[i] = input()  \n\n\nbm_search(pattern, buff)                "
  },
  {
    "language": "Python",
    "code": "def rabin_karp(T, P, d):\n    n = len(T)\n    m = len(P)\n    if n < m:\n        return\n    h = 1\n    p = 0\n    t0 = 0\n    for _ in range(m - 1):\n        h *= d\n    for i in range(m):\n        p = d * p + P[i]\n        t0 = d * t0 + T[i]\n    # print(\"h = \", h)\n    # print(\"p = \", p)\n    for s in range(n - m + 1):\n        # print(\"t0 = \", t0)\n        if p == t0:\n            print(s)\n        if s < n - m:\n            # print(\"     \", t0 - T[s] * h)\n            # print(\"     \",  d)\n            # print(\"     \", T[s + m])\n            t0 = d * (t0 - T[s] * h) + T[s + m]\n\n\nd = 1009\nt = list(map(ord, input()))\np = list(map(ord, input()))\n\nrabin_karp(t, p, d)\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef make_KMP_table(pattern): # ????´¢????????????????§???°???????±????????????????????????????\n    l = len(pattern)\n    table = [0]*l \n    count = 0\n    j = 0\n    for i in range(1,l):     \n        if pattern[i] == pattern[j]:\n            table[i] = count\n            count += 1\n            j += 1\n        else:\n            table[i] = count\n            count = 0\n            j = 0       \n    return table\n\ndef bfs(pattern,buff,x,y):\n    count = 0\n    for j in range(1,R):\n        for i in range(C):\n            if pattern[j][i] != buff[y+j][i + x]:\n                count = 1\n                break\n        if count == 1:\n            break\n    else:\n        print(y,x) \n    \n    \n    \ndef KMP_search(pattern,buff):\n    bl = W\n    pl = C\n    table = make_KMP_table(pattern[0])\n    for y in range(H-R + 1):\n        buffplace = 0\n        j = 0\n        while buffplace < bl:\n\n            if pattern[0][j] != buff[y][buffplace]:\n                if j == 0:\n                    buffplace += 1\n                    \n                else:\n                     j = table[j]\n            elif pattern[0][j] == buff[y][buffplace]:\n                buffplace += 1\n                j += 1\n            if j == pl:\n                x = buffplace - j\n                bfs(pattern,buff,x,y)\n                buffplace -= j - 1\n                j = 0        \n            \n\nH,W = map(int,input().split())\nbuff = [0]*H\nfor i in range(H):\n    buff[i] = input()\nR,C = map(int,input().split())\n\npattern = [0] * R\nfor i in range(R):\n    pattern[i] = input()\n    \nKMP_search(pattern, buff)\n    \n    \n                \n                \n                \n                \n                "
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\n\nclass MatrixRKSearch:\n    shift = 40\n    size = 33554393\n\n    def __init__(self, m1, m2):\n        self.haystack = self._encode(m1)\n        self.needle = self._encode(m2)\n\n    def find(self):\n        i1, j1 = len(self.haystack), len(self.haystack[0])\n        i2, j2 = len(self.needle), len(self.needle[0])\n        if i1 < i2 or j1 < j2:\n            return\n\n        hs1 = [self._hash(s, j2) for s in self.haystack]\n        hs2 = [self._hash(s, j2) for s in self.needle]\n        dm = self.shift**(j2-1) % self.size\n\n        for j in range(j1-j2+1):\n            for i in range(i1-i2+1):\n                if hs1[i:i+i2] == hs2:\n                    yield (i, j)\n            if j+j2 < j1:\n                for i in range(i1):\n                    hs1[i] = self._shift(hs1[i], self.haystack[i][j+j2],\n                                         self.haystack[i][j], dm)\n\n    def _shift(self, h, add, remove, dm):\n        return ((h - remove*dm) * self.shift + add) % self.size\n\n    def _hash(self, s, length):\n        h = 0\n        for i in range(length):\n            h = (h * self.shift + s[i]) % self.size\n\n        return h\n\n    def _encode(cls, m):\n        basea = ord('a')\n        based = ord('0')\n        es = []\n        for s in m:\n            bs = []\n            for c in s:\n                if c.isdigit():\n                    bs.append(ord(c) - based + 27)\n                else:\n                    bs.append(ord(c) - basea)\n            es.append(bs)\n\n        return es\n\n\ndef search(matrix, pattern):\n    \"\"\"Search matrix for pattern\n    \"\"\"\n    def _check(y, x):\n        for m in range(py):\n            for n in range(px):\n                if matrix[y+m][x+n] != pattern[m][n]:\n                    return False\n        return True\n\n    mx = len(matrix[0])\n    my = len(matrix)\n    px = len(pattern[0])\n    py = len(pattern)\n    for i in range(my-py+1):\n        for j in range(mx-px+1):\n            if _check(i, j):\n                yield (i, j)\n\n\ndef run():\n    h, w = [int(x) for x in input().split()]\n    m = []\n\n    for _ in range(h):\n        m.append(input())\n\n    r, c = [int(x) for x in input().split()]\n    pt = []\n\n    for _ in range(r):\n        pt.append(input())\n\n    sch = MatrixRKSearch(m, pt)\n    result = []\n    for i, j in sch.find():\n        result.append((i, j))\n\n    result.sort()\n    for i, j in result:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    if R > C:\n        H, W = W, H\n        MAP = tuple(\"\".join(a) for a in zip(*MAP))\n        R, C = C, R\n        PTN = tuple(\"\".join(a) for a in zip(*PTN))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        if PTN[0] not in MAP[i]:\n            continue\n        for j in range(W - C + 1):\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n    if ans:\n        print(\"\\n\".join(a for a in ans))\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        j = MAP[i].find(PTN[0])\n        while j != -1:\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n            j = MAP[i].find(PTN[0], j + 1)\n    if ans:\n        print(\"\\n\".join(a for a in ans))\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\n\n\ndef calculate_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0 for _ in range(c)] for _ in range(r)]\n    dr, dc = r - ph, c - pw\n\n    t1 = 1\n    for _ in range(pw):\n        t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\n\n\nth, tw = map(int, input().split())\nt = [[ord(x) for x in input().strip()] for _ in range(th)]\nph, pw = map(int, input().split())\np = [[ord(x) for x in input().strip()] for _ in range(ph)]\n\nif th >= ph and tw >= pw:\n    h = [[0 for _ in range(tw)] for _ in range(th)]\n    calculate_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calculate_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                print(i, j)\n"
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n    t1 = 1\n    for _ in range(pw):\n        t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\nth, tw = map(int, input().split())\nt = tuple(tuple(ord(c) for c in input()) for _ in range(th))\nph, pw = map(int, input().split())\np = tuple(tuple(ord(c) for c in input()) for _ in range(ph))\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                print(i, j)\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nt = \"\"\n\nfor i in range(h):\n    inp = input()\n    t = t + inp\n\nr, c = map(int, input().split())\n\np = input()\np0 = p\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nprog = re.compile(p)\n\ni = 0\nwhile True:\n    f = t.find(p0)\n    if f == -1:\n        break\n    else:\n        t = t[f:]\n        m = prog.match(t)\n        i += f\n        if m and (i%w <= w - c or i//w == h - r):\n            print(i//w, i%w)\n        t = t[1:]\n        i += 1"
  },
  {
    "language": "Python",
    "code": "def ns_search(t, p):\n    global w, c\n    for i in range(w - c + 1):\n        if t[i:i + c] == p:\n            return i\n    return -1\n\n\ndef pattern_search(text, pat):\n    global h, r\n    for i in range(h):\n        if h - i < r:\n            break\n        tmp = ns_search(text[i], pat[0])\n        if tmp != -1:\n            for j in range(1, r):\n                if ns_search(text[i+j], pat[j]) == -1:\n                    break\n            else:\n                print(i, tmp)\n\nh, w = map(int, input().split())\ntext = [input() for _ in range(h)]\nr, c = map(int, input().split())\npat = [input() for _ in range(r)]\npattern_search(text, pat)"
  },
  {
    "language": "Python",
    "code": "def pattern_search(text, pat):\n    def ns_search(t, p, f=-1):\n        global w, c\n        if f != -1:\n            if t[f:f + c] == p:\n                return 1\n            else:\n                return -1\n        for i in range(w - c + 1):\n            if t[i:i + c] == p:\n                return i\n        return -1\n    global h, r\n    for i in range(h):\n        if h - i < r:\n            break\n        tmp = ns_search(text[i], pat[0])\n        if tmp != -1:\n            for j in range(1, r):\n                if ns_search(text[i+j], pat[j], tmp) == -1:\n                    break\n            else:\n                print(i, tmp)\n\nh, w = map(int, input().split())\ntext = [input() for _ in range(h)]\nr, c = map(int, input().split())\npat = [input() for _ in range(r)]\npattern_search(text, pat)"
  },
  {
    "language": "Python",
    "code": "def get_common(string,len_string):\n    common_length=[0]*len_string\n    tmp=0\n    tmp_tmp=0\n    for i in range(1,len_string):\n        if(string[i]==string[tmp]):\n            tmp_tmp=tmp\n            while(string[i]==string[tmp_tmp] and tmp_tmp >0):\n                tmp_tmp=common_length[max([tmp_tmp-1,0])]\n            common_length[i-1]=tmp_tmp\n            tmp+=1\n        else:\n            common_length[i-1]=tmp\n            while(string[i]!=string[tmp] and tmp>0):\n                tmp=common_length[max([tmp-1,0])]\n            if(string[i]==string[tmp]):\n                tmp+=1\n\n    if(string[-1]==string[tmp-1]):\n        common_length[-1]=tmp\n    common_length[0]=0\n    return common_length\n\n\n\ndef find_str(field,field_row,pattern,common_length,H,W,h,w):\n    tmp=0\n    column_list=[]\n    len_pattern=len(pattern[0])\n    for i in range(len(field[field_row])):\n        if(field[field_row][i]!=pattern[0][tmp]):\n            while(field[field_row][i]!=pattern[0][tmp] and tmp>0):\n                tmp=common_length[0][max([tmp-1,0])]\n            if(field[field_row][i]==pattern[0][tmp]):\n                tmp+=1\n        else:\n            tmp+=1\n            if(tmp==len_pattern):\n                column_list.append(i-tmp+1)\n                tmp=common_length[0][-1]\n    \n    \n    \n    for j in range(1,h):\n        tmp=0\n        loop=0\n        while( loop  <len(column_list)):\n            column=column_list[loop]\n            if(loop < len(column_list) -1):\n                next_column=column_list[loop+1]\n            else:\n                next_column=len(field[0])+len(pattern[0])+1#十分でかけりゃ何でも良い\n            for i in range(0,len_pattern+1):\n                if(field[field_row+j][column+ i]!=pattern[j][i]):\n                    tmp=0\n                    column_list.pop(loop)\n                    break\n                else:\n                    tmp+=1\n                    if(tmp==len_pattern):\n                        tmp=0\n                        loop+=1\n                        break\n\n    for column in column_list:\n        print(f\"{field_row} {column}\")\n\n\n\n\n\n\n\n\n\n\nH,W=map(int,input().split())\nfield=[]\nfor i in range(H):\n    field.append(input())\nh,w=map(int,input().split())\npattern=[]\nfor i in range(h):\n    pattern.append(input())\n\ncommon_length=[]\nfor i in range(1):\n    common_length.append(get_common(pattern[i],w))\n\nfor i in range(H-h+1):\n    find_str(field,i,pattern,common_length,H,W,h,w)\n"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        if PTN[0] not in MAP[i]:\n            continue\n        for j in range(W - C + 1):\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n    if ans:\n        print(\"\\n\".join(a for a in ans))\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    inp = input()\n    f = f + inp\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nprog = re.compile(p)\n\ni = 0\nl_f = len(f)\n\nwhile True:\n    m   = prog.search(f)\n    if m == None:\n        break\n    else:\n        idx = m.start()\n        i += idx\n        f = f[idx + 1:]\n        if i%w <= w - c or i//w == h - r:\n            print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nfor i in range(len(f) - len(p) + 1):\n    tmp = f[i:i + len(p)]\n    if re.match(p, tmp) and (i%w <= w - c or i//w == h - r):\n        print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        for j in range(W - C + 1):\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n    if ans:\n        print(*ans, sep=\"\\n\")\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nfor i in range(len(f) - len(p) + 1):\n    tmp = f[i:i + len(p)]\n    if re.match(p, tmp) and i <= w - c:\n        print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n    t1 = 1\n    for _ in range(pw):\n        t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\nth, tw = map(int, input().split())\nt = tuple(tuple(ord(c) for c in input()) for _ in range(th))\nph, pw = map(int, input().split())\np = tuple(tuple(ord(c) for c in input()) for _ in range(ph))\nans = []\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                ans.append(f\"{i} {j}\")\nif ans:\n    print(\"\\n\".join(a for a in ans))\n"
  },
  {
    "language": "Python",
    "code": "H,W=map(int,input().split())\nF=[input()for _ in[0]*H]\nR,C=map(int,input().split())\nP=[input()for _ in[0]*R]\nfor h in range(H-R+1):\n for w in range(W-C+1):\n  for i in range(R):\n   if F[h+i][w:w+C]!=P[i]:break\n  else:print(h,w)\n"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        for j in range(W - C + 1):\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n    if ans:\n        print(\"\\n\".join(a for a in ans))\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n    t1 = 1\n\tt1 = (t1 * (base1 ** pw)) & mask\n    # for _ in range(pw):\n        # t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\nth, tw = map(int, input().split())\nt = tuple(tuple(ord(c) for c in input()) for _ in range(th))\nph, pw = map(int, input().split())\np = tuple(tuple(ord(c) for c in input()) for _ in range(ph))\nans = []\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                ans.append(f\"{i} {j}\")\nif ans:\n    print(\"\\n\".join(a for a in ans))\n"
  },
  {
    "language": "Python",
    "code": "def get_common(string,len_string):\n    common_length=[0]*len_string\n    tmp=0\n    tmp_tmp=0\n    for i in range(1,len_string):\n        if(string[i]==string[tmp]):\n            tmp_tmp=tmp\n            while(string[i]==string[tmp_tmp] and tmp_tmp >0):\n                tmp_tmp=common_length[max([tmp_tmp-1,0])]\n            common_length[i-1]=tmp_tmp\n            tmp+=1\n        else:\n            common_length[i-1]=tmp\n            while(string[i]!=string[tmp] and tmp>0):\n                tmp=common_length[max([tmp-1,0])]\n            if(string[i]==string[tmp]):\n                tmp+=1\n\n    if(string[-1]==string[tmp-1]):\n        common_length[-1]=tmp\n    common_length[0]=0\n    return common_length\n\n\n\ndef find_str(field,field_row,pattern,common_length,H,W,h,w):\n    tmp=0\n    column_list=[]\n    len_pattern=len(pattern[0])\n    for i in range(len(field[field_row])):\n        if(field[field_row][i]!=pattern[0][tmp]):\n            while(field[field_row][i]!=pattern[0][tmp] and tmp>0):\n                tmp=common_length[0][max([tmp-1,0])]\n            if(field[field_row][i]==pattern[0][tmp]):\n                tmp+=1\n        else:\n            tmp+=1\n            if(tmp==len_pattern):\n                column_list.append(i-tmp+1)\n                tmp=common_length[0][-1]\n    \n    \n    \n    for j in range(1,h):\n        tmp=0\n        loop=0\n        while( loop  <len(column_list)):\n            column=column_list[loop]\n            if(loop < len(column_list) -1):\n                next_column=column_list[loop+1]\n            else:\n                next_column=len(field[0])+len(pattern[0])+1\n            ini_tmp=tmp\n            for i in range(0,len_pattern+1):\n                if(field[field_row+j][column+ i+ini_tmp]!=pattern[j][tmp]):\n                    if(i < next_column - column):\n                        tmp=0\n                        column_list.pop(loop)\n                        break\n                    else:\n                        while(tmp>column+i-next_column+1):\n                            tmp=common_length[0][max([tmp-1,0])]\n                        if(tmp!=column+i-next_column+1):\n                            tmp=0\n                        column_list.pop(loop)\n                        break\n                else:\n                    tmp+=1\n                    if(tmp==len_pattern):\n                        if(i < next_column - column):\n                            tmp=0\n                            loop+=1\n                            break\n                        else:\n                            while(tmp>column+i-next_column+1):\n                                tmp=common_length[0][max([tmp-1,0])]\n                            if(tmp!=column+i-next_column+1):\n                                tmp=0\n                            loop+=1\n                            break\n    for column in column_list:\n        print(f\"{field_row} {column}\")\n\n\n\n\n\n\n\n\n\n\nH,W=map(int,input().split())\nfield=[]\nfor i in range(H):\n    field.append(input())\nh,w=map(int,input().split())\npattern=[]\nfor i in range(h):\n    pattern.append(input())\n\ncommon_length=[]\nfor i in range(h):\n    common_length.append(get_common(pattern[i],w))\n\nfor i in range(H-h+1):\n    find_str(field,i,pattern,common_length,H,W,h,w)\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\n\nclass MatrixRKSearch:\n    shift = 40\n    size = 33554393\n\n    def __init__(self, m1, m2):\n        self.haystack = self._encode(m1)\n        self.needle = self._encode(m2)\n\n    def find(self):\n        i1, j1 = len(self.haystack), len(self.haystack[0])\n        i2, j2 = len(self.needle), len(self.needle[0])\n        if i1 < i2 or j1 < j2:\n            return\n\n        hs1 = [self._hash(s, j2) for s in self.haystack]\n        hs2 = [self._hash(s, j2) for s in self.needle]\n        dm = self.shift**(j2-1) % self.size\n\n        for j in range(j1-j2+1):\n            for i in range(i1-i2+1):\n                if hs1[i:i+i2] == hs2:\n                    yield (i, j)\n            if j+j2 < j1:\n                for i in range(i1):\n                    hs1[i] = self._shift(hs1[i], self.haystack[i][j+j2],\n                                         self.haystack[i][j], dm)\n\n    @lru_cache(maxsize=1000)\n    def _shift(self, h, add, remove, dm):\n        return ((h - remove*dm) * self.shift + add) % self.size\n\n    def _hash(self, s, length):\n        h = 0\n        for i in range(length):\n            h = (h * self.shift + s[i]) % self.size\n\n        return h\n\n    def _encode(cls, m):\n        basea = ord('a')\n        based = ord('0')\n        es = []\n        for s in m:\n            bs = []\n            for c in s:\n                if c.isdigit():\n                    bs.append(ord(c) - based + 27)\n                else:\n                    bs.append(ord(c) - basea)\n            es.append(bs)\n\n        return es\n\ndef run():\n    h, w = [int(x) for x in input().split()]\n    m = []\n\n    for _ in range(h):\n        m.append(input())\n\n    r, c = [int(x) for x in input().split()]\n    pt = []\n\n    for _ in range(r):\n        pt.append(input())\n\n    sch = MatrixRKSearch(m, pt)\n    result = []\n    for i, j in sch.find():\n        result.append((i, j))\n\n    result.sort()\n    for i, j in result:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    inp = input()\n    f = f + inp\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nprog = re.compile(p)\n\ni = 0\n\nwhile True:\n    m   = prog.search(f)\n    if m == None:\n        break\n    else:\n        idx = m.start()\n        i += idx\n        f = f[idx + 1:]\n        if i%w <= w - c or i//w == h - r:\n            print(i//w, i%w)\n        i += 1"
  },
  {
    "language": "Python",
    "code": "CSIZE = 256\n\ndef make_bm_table(pattern,size):\n    bm_table = [size]*CSIZE\n    for i in range(size):\n        dist = size-i-1\n        charac = pattern[i]\n        bm_table[ord(charac)] = dist\n    return bm_table\n\ndef bm_search(pattern,buff): \n        size = C\n        bm_table = make_bm_table(pattern[0], size)    \n        buffsize = W\n        for j in range(H-C):\n            saikobi = size-1\n            while saikobi < buffsize:\n                for i in range(size):\n                    if pattern[0][size-i-1] != buff[j][saikobi-i]:\n                        saikobi += max(bm_table[ord(buff[j][saikobi-i])]-i,1)\n                        break\n                else:\n                    count = 1\n                    for k in range(1,R):\n                        for l in range(C)[::-1]: \n                            if pattern[k][size-1-l] != buff[j+k][saikobi-l]:\n                                count = 0\n                                break\n                        if count == 0:\n                            break\n                    else:\n                        print(j,saikobi-C+1)\n                    saikobi += 1  \n                    \n            \n\nH,W = map(int,input().split())\nbuff = [\"\"]*H\nfor i in range(H):\n    buff[i] = input()\n    \nR,C = map(int,input().split())\npattern = [\"\"]*R\nfor i in range(R):\n    pattern[i] = input()  \n\n\nbm_search(pattern, buff)                "
  },
  {
    "language": "Python",
    "code": "CSIZE = 256\n\ndef make_bm_table(pattern,size):\n    bm_table = [size]*CSIZE\n    for i in range(size):\n        dist = size-i-1\n        charac = pattern[i]\n        bm_table[ord(charac)] = dist\n    return bm_table\n\ndef bm_search(pattern,buff): \n        size = R\n        bm_table = make_bm_table(pattern[0], size)    \n        buffsize = W\n        for j in range(H-C):\n            saikobi = size-1\n            while saikobi < buffsize:\n                for i in range(size):\n                    if pattern[0][size-i-1] != buff[j][saikobi-i]:\n                        saikobi += max(bm_table[ord(buff[j][saikobi-i])]-i,1)\n                        break\n                else:\n                    count = 1\n                    for k in range(1,R):\n                        for l in range(C)[::-1]: \n                            if pattern[k][size-1-l] != buff[j+k][saikobi-l]:\n                                count = 0\n                                break\n                        if count == 0:\n                            break\n                    else:\n                        print(j,saikobi-C+2)\n                    saikobi += 1  \n                    \n            \n\nH,W = map(int,input().split())\nbuff = [\"\"]*H\nfor i in range(H):\n    buff[i] = input()\n    \nR,C = map(int,input().split())\npattern = [\"\"]*R\nfor i in range(R):\n    pattern[i] = input()  \n\n\nbm_search(pattern, buff)                "
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\np_first = p\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nprog = re.compile(p)\nfor i in range(len(f) - len(p) + 1):\n    if f[i:i + c] == p_first and (i%w <= w - c or i//w == h - r) and prog.match(f[i:i + len(p)]):\n        print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    inp = input()\n    f = f + inp\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nprog = re.compile(p)\n\ni = 0\nwhile True:\n    m   = prog.search(f)\n    if m == None:\n        break\n    else:\n        idx = m.start()\n        i += idx\n        f = f[idx + 1:]\n        if i%w <= w - c or i//w == h - r:\n            print(i//w, i%w)\n        i += 1"
  },
  {
    "language": "Python",
    "code": "CSIZE = 256\n\ndef make_bm_table(pattern,size):\n    bm_table = [size]*CSIZE\n    for i in range(size):\n        dist = size-i-1\n        charac = pattern[i]\n        bm_table[ord(charac)] = dist\n    return bm_table\n\ndef bm_search(pattern,buff): \n        size = C\n        bm_table = make_bm_table(pattern[0], size)    \n        buffsize = W\n        for j in range(H-R+1):\n            saikobi = size-1\n            while saikobi < buffsize:\n                for i in range(size):\n                    if pattern[0][size-i-1] != buff[j][saikobi-i]:\n                        saikobi += max(bm_table[ord(buff[j][saikobi-i])]-i,1)\n                        break\n                else:\n                    count = 1\n                    for k in range(1,R):\n                        for l in range(C)[::-1]: \n                            if pattern[k][size-1-l] != buff[j+k][saikobi-l]:\n                                count = 0\n                                break\n                        if count == 0:\n                            break\n                    else:\n                        print(j,saikobi-C+1)\n                    saikobi += 1  \n                    \n            \n\nH,W = map(int,input().split())\nbuff = [\"\"]*H\nfor i in range(H):\n    buff[i] = input()\n    \nR,C = map(int,input().split())\npattern = [\"\"]*R\nfor i in range(R):\n    pattern[i] = input()  \n\n\nbm_search(pattern, buff)                "
  },
  {
    "language": "Python",
    "code": "import string\n\nchar_dict = {c: i for i, c in enumerate(string.digits + string.ascii_letters)}\n\nth, tw = map(int, input().split())\nt = [input().strip() for _ in range(th)]\nph, pw = map(int, input().split())\n\n\ndef conv_str(s):\n    result = 0\n    for c in s:\n        result <<= 6\n        result += char_dict[c]\n    return result\n\n\nt = [[conv_str(t[i][j:j + pw]) for j in range(tw - pw + 1)] for i in range(th)]\np = [conv_str(input().strip()) for _ in range(ph)]\n\nfor i in range(th - ph + 1):\n    for j in range(tw - pw + 1):\n        for k in range(ph):\n            if t[i + k][j] != p[k]:\n                break\n        else:\n            print(i, j)"
  },
  {
    "language": "Python",
    "code": "th, tw = map(int, input().split())\nt = [input().strip() for _ in range(th)]\nph, pw = map(int, input().split())\n\nt = [[t[i][j:j + pw] for j in range(tw - pw + 1)] for i in range(th)]\np = [input().strip() for _ in range(ph)]\n\nfor i in range(th - ph + 1):\n    for j in range(tw - pw + 1):\n        for k in range(ph):\n            if t[i + k][j] != p[k]:\n                break\n        else:\n            print(i, j)"
  },
  {
    "language": "Python",
    "code": "def check(r,c):\n    flag = True\n    for ri,rj in enumerate(B):\n        for ci,cj in enumerate(rj):\n            if not A[ri+r][ci+c] == cj:\n                flag = False\n                break\n    return flag\n\nH,W = [int(i) for i in input().split()]\nA = [input() for _ in range(H)]\nR,C = [int(i) for i in input().split()]\nB = [input() for _ in range(R)]\n\nfor r in range(H-R+1):\n    for c in range(W-C+1):\n        if check(r,c):\n            print(r,c)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport re\nimport sys\nsys.setrecursionlimit(100000)\n\nclass AC:\n    \n    def __init__(self,num,parent,char):\n        self.num = num\n        self.parent = parent\n        self.char = char\n        self.d = {}\n        self.failure = None\n        \n    def insert(self,string,num):\n        if not string[0] in self.d:\n            self.d[string[0]] = AC(num,self,string[0])\n            num+=1\n        if not string[1:] == \"\":\n            return self.d[string[0]].insert(string[1:],num)\n        else:\n            return num\n        \n    def setFailure(self):\n        tmp = self.parent.failure\n        while(True):\n            if self.char in tmp.d:\n                self.failure = tmp.d[self.char]\n                break\n            else:\n                if tmp.num == 0:\n                    self.failure = tmp\n                    break\n                else:\n                    tmp = tmp.failure\n    \n    def setFailureRoot(self):\n        self.failure = self\n    \n    def setFailureFirstLayer(self):\n        self.failure = self.parent\n       \n    def transition(self,string):\n        if string == \"\":\n            return []\n        elif string[0] in self.d:\n            tmp = self.d[string[0]]\n            num = \"{0:09d}\".format(tmp.num) \n            return [num]+tmp.transition(string[1:])\n        else:\n            if self.num == 0:\n                num = \"{0:09d}\".format(self.num)\n                return [num]+self.transition(string[1:])\n            else:\n                return self.failure.transition(string)\n    \nH,W = [int(i) for i in input().split()]\nA = [input() for _ in range(H)]\nR,C = [int(i) for i in input().split()]\nB = [input() for _ in range(R)]\n\nroot = AC(0,None,\"\")\nroot.setFailureRoot()\nnum=1\nfor i in B:\n    num = root.insert(i,num)\nd = deque()\nfor i in root.d.values():\n    i.setFailureFirstLayer()\n    for j in i.d.values():\n        d.appendleft(j)\nwhile(len(d)>0):\n    tmp = d.pop()\n    tmp.setFailure()\n    for i in tmp.d.values():\n        d.appendleft(i)\n        \ntrans = [\"\" for i in range(W)]\nfor i in A:\n    tmp = root.transition(i)\n    for j,k in enumerate(tmp):\n        trans[j] = trans[j]+k+\"#\"\n\nans=\"\"\nfor i in B:\n    ans = ans+root.transition(i)[-1]+\"#\"\n\nansd = deque()\nfor i,j in enumerate(trans):\n    obj = re.search(ans,j)\n    c = 0\n    while(obj):\n        s = obj.start()\n        if (i-C+1)<0:\n            print(i)\n        ansd.append(((c+s)//10,i-C+1))\n        obj = re.search(ans,j[c+s+10:])\n        c += s+10\n\nfor i in sorted(ansd):\n    print(i[0],i[1])\n"
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n\n    t1 = 1\n    for _ in range(pw):\n        t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\n\n\nth, tw = map(int, input().split())\nt = [[ord(c) for c in input().strip()] for _ in range(th)]\nph, pw = map(int, input().split())\np = [[ord(c) for c in input().strip()] for _ in range(ph)]\n\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                print(i, j)"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        if PTN[0] not in MAP[i]:\n            continue\n        j = MAP[i].find(PTN[0])\n        while j != -1:\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n            j = MAP[i].find(PTN[0], j + 1)\n    if ans:\n        print(\"\\n\".join(a for a in ans))\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int,input().split())\nA = []\nfor i in range(H):\n    A.append(input())\nR, C = map(int,input().split())\nB = []\nfor i in range(R):\n    B.append(input())\n    \nb = B[0]\nb_for_move = [0 for i in range(len(B))]\n\nfor i in range(len(b)):\n    for j in range(0,len(b)-i)[::-1]:   \n        if b[i:i+j] == b[len(b)-j-1:len(b)]:\n            b_for_move[i] = j\n            break\n    else: b_for_move[i] = 1\n    \nfor i in range(H-R + 1):\n    for k in range(W-C +1):\n        count = 0\n        for j in range(R):\n            if B[j] == A[i+j][k:k+C]:\n                count += 1\n            else:\n                i += b_for_move[j] -1\n                break\n        if count == R:\n            print(i,k)    "
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nT = [input() for i in range(H)]\nR, C = map(int, input().split())\nP = [input() for i in range(R)]\n\ndef match(ox, oy):\n\tfor y in range(R):\n\t\tfor x in range(C):\n\t\t\tif T[oy + y][ox + x] != P[y][x]:\n\t\t\t\treturn False\n\treturn True\n\nfor y in range(H - R + 1):\n\tfor x in range(W - C + 1):\n\t\tif T[y][x] == P[0][0]:\n\t\t\tif match(x, y):\n\t\t\t\tprint(\"{0} {1}\".format(y, x))"
  },
  {
    "language": "Python",
    "code": "from hashlib import md5\n\nth, tw = map(int, input().split())\nt = [input().strip() for _ in range(th)]\nph, pw = map(int, input().split())\n\nt = [[md5(t[i][j:j + pw].encode('utf-8')).digest() for j in range(tw - pw + 1)] for i in range(th)]\np = [md5(input().strip().encode('utf-8')).digest() for _ in range(ph)]\n\nfor i in range(th - ph + 1):\n    for j in range(tw - pw + 1):\n        for k in range(ph):\n            if t[i + k][j] != p[k]:\n                break\n        else:\n            print(i, j)"
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n    t1 = 1\n    for _ in range(pw):\n        t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\nth, tw = map(int, input().split())\nt = tuple(tuple(ord(c) for c in input()) for _ in range(th))\nph, pw = map(int, input().split())\np = tuple(tuple(ord(c) for c in input()) for _ in range(ph))\nans = []\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n\t\t\t    ans.append(f\"{i} {j}\")\nif ans:\n    print(\"\\n\".join(a for a in ans))\n"
  },
  {
    "language": "Python",
    "code": "\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nT = [input() for i in range(H)]\nR, C = map(int, input().split())\nP = [input() for i in range(R)]\n\ndef match(ox, oy):\n\tfor y in range(R):\n\t\tfor x in range(C):\n\t\t\tif T[oy + y][ox + x] != P[y][x]:\n\t\t\t\treturn False\n\treturn True\n\nfor y in range(H - R):\n\tfor x in range(W - C):\n\t\tif T[y][x] == P[0][0]:\n\t\t\tprint(\"a\")\n\t\t\tif match(x, y):\n\t\t\t\tprint(\"{0} {1}\".format(y, x))"
  },
  {
    "language": "Python",
    "code": "def get_common(string,len_string):\n    common_length=[0]*len_string\n    tmp=0\n    tmp_tmp=0\n    for i in range(1,len_string):\n        if(string[i]==string[tmp]):\n            tmp_tmp=tmp\n            while(string[i]==string[tmp_tmp] and tmp_tmp >0):\n                tmp_tmp=common_length[max([tmp_tmp-1,0])]\n            common_length[i-1]=tmp_tmp\n            tmp+=1\n        else:\n            common_length[i-1]=tmp\n            while(string[i]!=string[tmp] and tmp>0):\n                tmp=common_length[max([tmp-1,0])]\n            if(string[i]==string[tmp]):\n                tmp+=1\n\n    if(string[-1]==string[tmp-1]):\n        common_length[-1]=tmp\n    common_length[0]=0\n    return common_length\n\n\n\ndef find_str(field,field_row,pattern,common_length,H,W,h,w):\n    tmp=0\n    column_list=[]\n    len_pattern=len(pattern[0])\n    for i in range(len(field[field_row])):\n        if(field[field_row][i]!=pattern[0][tmp]):\n            while(field[field_row][i]!=pattern[0][tmp] and tmp>0):\n                tmp=common_length[0][max([tmp-1,0])]\n            if(field[field_row][i]==pattern[0][tmp]):\n                tmp+=1\n        else:\n            tmp+=1\n            if(tmp==len_pattern):\n                column_list.append(i-tmp+1)\n                tmp=common_length[0][-1]\n    \n    \n    \n    for j in range(1,h):\n        tmp=0\n        loop=0\n        while( loop  <len(column_list)):\n            column=column_list[loop]\n            if(loop < len(column_list) -1):\n                next_column=column_list[loop+1]\n            else:\n                next_column=len(field[0])+len(pattern[0])+1#十分でかけりゃ何でも良い\n            ini_tmp=tmp\n            for i in range(0,len_pattern+1):\n                if(field[field_row+j][column+ i+ini_tmp]!=pattern[j][tmp]):\n                    if(column + i + ini_tmp < next_column):\n                        tmp=0\n                        column_list.pop(loop)\n                        break\n                    else:\n                        while(tmp>column+i+ini_tmp-next_column):\n                            tmp=common_length[j][max([tmp-1,0])]\n                        if(tmp!=column+i+ini_tmp-next_column ):\n                            tmp=0\n                        column_list.pop(loop)\n                        break\n                else:\n                    tmp+=1\n                    if(tmp==len_pattern):\n                        if(column + i + ini_tmp < next_column ):\n                            tmp=0\n                            loop+=1\n                            break\n                        else:\n                            while(tmp>column+i+ini_tmp-next_column+1):\n                                tmp=common_length[j][max([tmp-1,0])]\n                            if(tmp!=column+i+ini_tmp-next_column+1):\n                                tmp=0\n                            loop+=1\n                            break\n    for column in column_list:\n        print(f\"{field_row} {column}\")\n\n\n\n\n\n\n\n\n\n\nH,W=map(int,input().split())\nfield=[]\nfor i in range(H):\n    field.append(input())\nh,w=map(int,input().split())\npattern=[]\nfor i in range(h):\n    pattern.append(input())\n\ncommon_length=[]\nfor i in range(h):\n    common_length.append(get_common(pattern[i],w))\n\nfor i in range(H-h+1):\n    find_str(field,i,pattern,common_length,H,W,h,w)\n"
  },
  {
    "language": "Python",
    "code": "base1 = 127\nbase2 = 1009\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n\n    t1 = 1\n    for _ in range(pw):\n        t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\n\n\nth, tw = map(int, input().split())\nt = [[ord(c) for c in input().strip()] for _ in range(th)]\nph, pw = map(int, input().split())\np = [[ord(c) for c in input().strip()] for _ in range(ph)]\n\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                print(i, j)"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    for i in range(H - R + 1):\n        for j in range(W - C + 1):\n            if solve(i, j):\n                ans.append(f\"{i} {j}\")\n    print(*ans, sep=\"\\n\")\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from typing import List\n\n\ndef calc_hash(tab: List[List[int]], row_num: int, col_num: int) -> None:\n    global hash_table, R, C, baes1, base2, mask\n    tmp_table = [[0] * col_num for _ in range(row_num)]\n    diff_row, diff_col = row_num - R, col_num - C\n\n    bit_mask = 1\n    for _ in range(C):\n        bit_mask = (bit_mask * base1) & mask\n    for r in range(row_num):\n        hash_v = 0\n        for c in range(C):\n            hash_v = hash_v * base1 + tab[r][c]\n        for dc in range(diff_col):\n            tmp_table[r][dc] = hash_v\n            hash_v = (hash_v * base1 - bit_mask * tab[r][dc] + tab[r][dc + C]) & mask\n        tmp_table[r][diff_col] = hash_v\n\n    bit_mask = 1\n    for _ in range(R):\n        bit_mask = (bit_mask * base2) & mask\n    for c in range(diff_col + 1):\n        hash_v = 0\n        for r in range(R):\n            hash_v = hash_v * base2 + tmp_table[r][c]\n        for dr in range(diff_row):\n            hash_table[dr][c] = hash_v\n            hash_v = (hash_v * base2 - bit_mask * tmp_table[dr][c]\n                      + tmp_table[dr + R][c]) & mask\n        hash_table[diff_row][c] = hash_v\n\n\nif __name__ == \"__main__\":\n    base1 = 1009  # The first prime number over 1000.\n    base2 = 1013  # The second prime number over 1000.\n    mask = (1 << 32) - 1  # Mask.\n\n    H, W = map(lambda x: int(x), input().split())\n    region = [[0] * W for _ in range(H)]\n    for row in range(H):\n        region[row] = [ord(s) for s in input()]\n\n    R, C = map(lambda x: int(x), input().split())\n    pattern = [[0] * C for _ in range(R)]\n    for row in range(R):\n        pattern[row] = [ord(s) for s in input()]\n\n    if H >= R and W >= C:\n        hash_table = [[0] * W for _ in range(H)]\n        calc_hash(pattern, R, C)  # Calc the target hash and save it into hash_table[0][0]\n        key = hash_table[0][0] & mask\n        calc_hash(region, H, W)\n        for r in range(H - R + 1):\n            for c in range(W - C + 1):\n                if key == hash_table[r][c] & mask:\n                    print(f\"{r} {c}\")\n\n"
  },
  {
    "language": "Python",
    "code": "def check(r,c):\n    return True if B == [i[c:c+C] for i in A[r:r+R]] else False\n\nH,W = [int(i) for i in input().split()]\nA = [input() for _ in range(H)]\nR,C = [int(i) for i in input().split()]\nB = [input() for _ in range(R)]\n\nfor r in range(H-R+1):\n    for c in range(W-C+1):\n        if check(r,c):\n            print(r,c)\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int,input().split())\nA = []\nfor i in range(H):\n    A.append(input())\nR, C = map(int,input().split())\nB = []\nfor i in range(R):\n    B.append(input())\n\nb = B[0]\nb_for_move = [0 for i in range(len(b))]\n\nfor i in range(len(b)):\n    for j in range(0,len(b)-i)[::-1]:   \n        if b[i:i+j] == b[len(b)-j-1:len(b)]:\n            b_for_move[i] = j\n            break\n    else: b_for_move[i] = 1\n    \n\n        \n         \nfor i in range(H-R + 1):\n    for k in range(W-C +1):\n        count = 0\n        for j in range(R):\n            if B[j] == A[i+j][k:k+C]:\n                count += 1\n            else:\n                i += b_for_move[j] -1\n                break\n        if count == R:\n            print(i,k)    "
  },
  {
    "language": "Python",
    "code": "base1 = 1009\nbase2 = 1013\nmask = (1 << 32) - 1\ndef calc_hash(f, r, c):\n    global ph, pw, h\n    tmp = [[0] * c for _ in range(r)]\n    dr, dc = r - ph, c - pw\n    # t1 = 1\n    t1 = (base1 ** pw) & mask\n    # for _ in range(pw):\n        # t1 = (t1 * base1) & mask\n    for i in range(r):\n        e = 0\n        for j in range(pw):\n            e = e * base1 + f[i][j]\n        for j in range(dc):\n            tmp[i][j] = e\n            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask\n        tmp[i][dc] = e\n    t2 = 1\n    for _ in range(ph):\n        t2 = (t2 * base2) & mask\n    for j in range(dc + 1):\n        e = 0\n        for i in range(ph):\n            e = e * base2 + tmp[i][j]\n        for i in range(dr):\n            h[i][j] = e\n            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask\n        h[dr][j] = e\nth, tw = map(int, input().split())\nt = tuple(tuple(ord(c) for c in input()) for _ in range(th))\nph, pw = map(int, input().split())\np = tuple(tuple(ord(c) for c in input()) for _ in range(ph))\nans = []\nif th >= ph and tw >= pw:\n    h = [[0] * tw for _ in range(th)]\n    calc_hash(p, ph, pw)\n    key = h[0][0] & mask\n    calc_hash(t, th, tw)\n    for i in range(th - ph + 1):\n        for j in range(tw - pw + 1):\n            if h[i][j] & mask == key:\n                ans.append(f\"{i} {j}\")\nif ans:\n    print(\"\\n\".join(a for a in ans))\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef make_KMP_table(pattern): # ????´¢????????????????§???°???????±????????????????????????????\n    l = len(pattern)\n    table = [0]*l \n    count = 0\n    j = 0\n    for i in range(1,l):     \n        if pattern[i] == pattern[j]:\n                table[i] = count\n                count += 1\n                j += 1\n        else:\n            table[i] = 0\n            count = 0\n            j = 0       \n    return table\n\ndef bfs(pattern,buff,x,y):\n    count = 0\n    for j in range(1,R):\n        for i in range(C):\n            if pattern[j][i] != buff[y+j][i + x]:\n                count = 1\n                break\n        if count == 1:\n            break\n    else:\n        print(y,x) \n    \n    \n    \ndef KMP_search(pattern,buff):\n    bl = W\n    pl = C\n    table = make_KMP_table(pattern[0])\n    for y in range(H-R + 1):\n        buffplace = 0\n        j = 0\n        while buffplace < bl:\n\n            if pattern[0][j] != buff[y][buffplace]:\n                if j == 0:\n                    buffplace += 1\n                    \n                else:\n                     j = table[j]\n            elif pattern[0][j] == buff[y][buffplace]:\n                buffplace += 1\n                j += 1\n            if j == pl:\n                x = buffplace - j\n                bfs(pattern,buff,x,y)\n                buffplace -= j - 1\n                j = 0        \n            \n            \nH,W = map(int,input().split())\nbuff = [0]*H\nfor i in range(H):\n    buff[i] = input()\nR,C = map(int,input().split())\n\npattern = [0] * R\nfor i in range(R):\n    pattern[i] = input()\n    \nKMP_search(pattern, buff)\n    \n    \n                \n                \n                \n                \n                "
  },
  {
    "language": "Python",
    "code": "H, W = map(int,input().split())\nA = []\nfor i in range(H):\n    A.append(input())\nR, C = map(int,input().split())\nB = []\nfor i in range(R):\n    B.append(input())\n    \nfor i in range(H-R + 1):\n    for k in range(W-C +1):\n        count = 0\n        for j in range(R):\n            if B[j] == A[i+j][k:k+C]:\n                count += 1\n            else:break\n        if count == R:\n            print(i,k)    "
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nfor i in range(len(f) - len(p) + 1):\n    tmp = f[i:i + len(p)]\n    if re.match(p, tmp) and (i <= w - c or i//w == h - r):\n        print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "CSIZE = 256\n\ndef make_bm_table(pattern,size):\n    bm_table = [size]*CSIZE\n    for i in range(size):\n        dist = size-i-1\n        charac = pattern[i]\n        bm_table[ord(charac)] = dist\n    return bm_table\n\ndef bm_search(pattern,buff): \n        size = len(pattern[0])\n        bm_table = make_bm_table(pattern[0], size)    \n        buffsize = W\n        for j in range(H-C):\n            saikobi = size\n            while saikobi < buffsize:\n                for i in range(size):\n                    if pattern[0][size-i-1] != buff[j][saikobi-i]:\n                        saikobi += max(bm_table[ord(buff[j][saikobi-i])]-i,1)\n                        break\n                else:\n                    count = 1\n                    for k in range(1,R):\n                        for l in range(C)[::-1]: \n                            if pattern[k][size-1-l] != buff[j+k][saikobi-l]:\n                                count = 0\n                                break\n                        if count == 0:\n                            break\n                    else:\n                        print(j,saikobi-C+1)\n                    saikobi += 1  \n                    \n            \n\nH,W = map(int,input().split())\nbuff = [\"\"]*H\nfor i in range(H):\n    buff[i] = input()\n    \nR,C = map(int,input().split())\npattern = [\"\"]*R\nfor i in range(R):\n    pattern[i] = input()  \n\n\nbm_search(pattern, buff)                "
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    for i in range(H - R + 1):\n        for j in range(W - C + 1):\n            if solve(i, j):\n                print(i, j)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef make_KMP_table(pattern): # ????´¢????????????????§???°???????±????????????????????????????\n    l = len(pattern)\n    table = [0]*l \n    count = 0\n    j = 0\n    for i in range(1,l):     \n        if pattern[i] == pattern[j]:\n                count += 1\n                table[i] = count\n                j += 1\n        else:\n            count = 0\n            j = 0\n            table[i] = 0\n    return table\n\ndef bfs(pattern,buff,x,y):\n    count = 0\n    for j in range(1,R):\n        for i in range(C):\n            if pattern[j][i] != buff[y+j][i + x]:\n                count = 1\n                break\n        if count == 1:\n            break\n    else:\n        print(y,x) \n    \n    \n    \ndef KMP_search(pattern,buff):\n    bl = W\n    pl = C\n    table = make_KMP_table(pattern[0])\n    for y in range(H-R + 1):\n        buffplace = 0\n        j = 0\n        while buffplace < bl:\n            if j == pl-1:\n                x = buffplace - j\n                bfs(pattern,buff,x,y)\n                buffplace -= j - 1\n                j = 0\n            if pattern[0][j] != buff[y][buffplace]:\n                buffplace += 1\n            elif pattern[0][j] == buff[y][buffplace]:\n                buffplace += 1\n                j += 1\n            else:\n                j = table[j] - 1\n            \nH,W = map(int,input().split())\nbuff = [0]*H\nfor i in range(H):\n    buff[i] = input()\nR,C = map(int,input().split())\n\npattern = [0] * R\nfor i in range(R):\n    pattern[i] = input()\n    \nKMP_search(pattern, buff)\n    \n    \n                \n                \n                \n                \n                "
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nT = [input() for i in range(H)]\nR, C = map(int, input().split())\nP = [input() for i in range(R)]\n\ndef match(ox, oy):\n\tfor y in range(R):\n\t\tfor x in range(C):\n\t\t\tif T[oy + y][ox + x] != P[y][x]:\n\t\t\t\treturn False\n\treturn True\n\nfor y in range(H - R + 1):\n\tfor x in range(W - C + 1):\n\t\tif T[y][x] == P[0][0]:\n\t\t\tif match(x, y):\n\t\t\t\tprint(\"{0} {1}\".format(y, x))"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef make_KMP_table(pattern): # ????´¢????????????????§???°???????±????????????????????????????\n    l = len(pattern)\n    table = [0]*l \n    count = 0\n    j = 0\n    for i in range(1,l):     \n        if pattern[i] == pattern[j]:\n                count += 1\n                table[i] = count\n                j += 1\n        else:\n            count = 0\n            j = 0\n            table[i] = 0\n    return table\n\ndef bfs(pattern,buff,x,y):\n    count = 0\n    for j in range(1,R):\n        for i in range(C):\n            if pattern[j][i] != buff[y+j][i + x]:\n                count = 1\n                break\n        if count == 1:\n            break\n    else:\n        print(y,x) \n    \n    \n    \ndef KMP_search(pattern,buff):\n    bl = W\n    pl = C\n    table = make_KMP_table(pattern[0])\n    for y in range(H-R + 1):\n        buffplace = 0\n        j = 0\n        while buffplace < bl:\n            if j == pl:\n                x = buffplace - j\n                bfs(pattern,buff,x,y)\n                buffplace -= j - 1\n                j = 0\n            if pattern[0][j] != buff[y][buffplace]:\n                if j == 0:\n                    buffplace += 1\n                else:\n                    j = table[j]\n            elif pattern[0][j] == buff[y][buffplace]:\n                buffplace += 1\n                j += 1 \n            \nH,W = map(int,input().split())\nbuff = [0]*H\nfor i in range(H):\n    buff[i] = input()\nR,C = map(int,input().split())\n\npattern = [0] * R\nfor i in range(R):\n    pattern[i] = input()\n    \nKMP_search(pattern, buff)\n    \n    \n                \n                \n                \n                \n                "
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\np_first = p\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nfor i in range(len(f) - len(p) + 1):\n    if f[i:i + c] == p_first and re.match(p, f[i:i + len(p)]) and (i%w <= w - c or i//w == h - r):\n        print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = tuple(input() for _ in range(H))\n    R, C = map(int, input().split())\n    PTN = tuple(input() for _ in range(R))\n    flg = True\n    if R > C:\n        flg = False\n        H, W = W, H\n        MAP = tuple(\"\".join(a) for a in zip(*MAP))\n        R, C = C, R\n        PTN = tuple(\"\".join(a) for a in zip(*PTN))\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    ans = []\n    if flg:\n        for i in range(H - R + 1):\n            if PTN[0] not in MAP[i]:\n                continue\n            for j in range(W - C + 1):\n                if solve(i, j):\n                    ans.append(f\"{i} {j}\")\n    else:\n        for j in range(H - R + 1):\n            if PTN[0] not in MAP[j]:\n                continue\n            for i in range(W - C + 1):\n                if solve(j, i):\n                    ans.append(f\"{i} {j}\")\n    if ans:\n        if flg:\n            print(\"\\n\".join(a for a in ans))\n        else:\n            print(\"\\n\".join(a for a in ans[::-1]))\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef PS(A,B,H,W,R,C):\n    for i in range(H):\n        for j in range(W):\n            if A[i][j]==B[0][0]:\n                ans=0\n                for k in range(R):\n                    for l in range(C):\n                        if i+k<H and j+l<W and A[i+k][j+l]==B[k][l]:\n                            ans+=1\n                if ans==R*C:\n                    print(i,j)\n\nif __name__==\"__main__\":\n    H,W=map(int,input().split(\" \"))\n    A=[]\n    for i in range(H):\n        A.append(list(input()))\n    R,C=map(int,input().split(\" \"))\n    B=[]\n    for i in range(R):\n        B.append(list(input()))\n    PS(A,B,H,W,R,C)\n        \n            "
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    H, W = map(int, input().split())\n    MAP = [input() for _ in range(H)]\n    R, C = map(int, input().split())\n    PTN = [input() for _ in range(R)]\n    def solve(a, b):\n        k = 0\n        for i in range(a, a + R):\n            if MAP[i][b:b + C] == PTN[k]:\n                k += 1\n            else:\n                return False\n        return True\n    for i in range(H - R + 1):\n        for j in range(W - C + 1):\n            if solve(i, j):\n                print(i, j)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nmod = 10**9 + 9; p = 13; q = 19\n\np_table = q_table = None\ndef prepare(L):\n    global p_table, q_table\n    p_table = [1]*(L+1); q_table = [1]*(L+1)\n    for i in range(L):\n        p_table[i+1] = p_table[i] * p % mod\n        q_table[i+1] = q_table[i] * q % mod\n\ndef rolling_hash(S, W, H):\n    D = [[0]*(W+1) for i in range(H+1)]\n    for i in range(H):\n        su = 0\n        dp = D[i]\n        di = D[i+1]\n        si = S[i]\n        for j in range(W):\n            v = si[j] # v = ord(si[j]) if si[j] is str\n            su = (su*p + v) % mod\n            di[j+1] = (su + dp[j+1]*q) % mod\n    return D\ndef get(S, x0, y0, x1, y1):\n    P = p_table[x1 - x0]; Q = q_table[y1 - y0]\n    return (S[y1][x1] - S[y1][x0] * P - S[y0][x1] * Q + S[y0][x0] * (P * Q) % mod) % mod\n\ndef solve():\n    prepare(1001)\n    H, W = map(int, readline().split())\n    M = [list(map(ord, readline().strip())) for i in range(H)]\n    R, C = map(int, readline().split())\n    M0 = [list(map(ord, readline().strip())) for i in range(R)]\n\n    rh = rolling_hash(M, W, H)\n    rh0 = rolling_hash(M0, C, R)\n    v = rh0[-1][-1]\n    for i in range(H-R+1):\n        for j in range(W-C+1):\n            if v == get(rh, j, i, j+C, i+R):\n                write(\"%d %d\\n\" % (i, j))\nsolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\np_first = p\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nfor i in range(len(f) - len(p) + 1):\n    if f[i:i + c] == p_first and (i%w <= w - c or i//w == h - r):\n        if re.match(p, f[i:i + len(p)]):\n            print(i//w, i%w)"
  },
  {
    "language": "Python",
    "code": "th, tw = map(int, input().split())\nt = [input().strip() for _ in range(th)]\nph, pw = map(int, input().split())\np = [input().strip() for _ in range(ph)]\n\nfor i in range(th - ph + 1):\n    for j in range(tw - pw + 1):\n        for k in range(ph):\n            if t[i + k][j:j + pw] != p[k]:\n                break\n        else:\n            print(i, j)"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\ntext = [input() for _ in range(h)]\nr, c = map(int, input().split())\npat = [input() for _ in range(r)]\ncur = 0\nfor i, line in enumerate(text):\n    for j in range(w - c + 1):\n        if line[j:j + c] == pat[cur]:\n            if cur == r - 1:\n                print(i - r + 1, j)\n                break\n            else:\n                cur += 1\n                break\n    else:\n        cur = 0"
  },
  {
    "language": "Python",
    "code": "import re\n\nh, w = map(int, input().split())\nf = \"\"\n\nfor i in range(h):\n    f += input()\n\nr, c = map(int, input().split())\n\np = input()\np_first = p\n\nfor i in range(r - 1):\n    line = input()\n    p += \".\"*(w - c) + line\n\nfor i in range(len(f) - len(p) + 1):\n    if f[i:i + c] == p_first and (i%w <= w - c or i//w == h - r):\n        if re.match(p, f[i:i + len(p)]):\n            print(i//w, i%w)"
  }
]