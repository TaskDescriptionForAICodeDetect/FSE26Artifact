[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nint H, W;\nchar grid[MAX_H][MAX_W];\n\ntypedef struct {\n    int top, bottom, front, back, left, right;\n} Die;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nbool is_valid_move(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] != '#';\n}\n\nDie roll_right(Die die) {\n    Die new_die = {\n        .top = die.left,\n        .bottom = die.right,\n        .front = die.front,\n        .back = die.back,\n        .left = die.bottom,\n        .right = die.top\n    };\n    return new_die;\n}\n\nDie roll_left(Die die) {\n    Die new_die = {\n        .top = die.right,\n        .bottom = die.left,\n        .front = die.front,\n        .back = die.back,\n        .left = die.top,\n        .right = die.bottom\n    };\n    return new_die;\n}\n\nDie roll_up(Die die) {\n    Die new_die = {\n        .top = die.back,\n        .bottom = die.front,\n        .front = die.top,\n        .back = die.bottom,\n        .left = die.left,\n        .right = die.right\n    };\n    return new_die;\n}\n\nDie roll_down(Die die) {\n    Die new_die = {\n        .top = die.front,\n        .bottom = die.back,\n        .front = die.bottom,\n        .back = die.top,\n        .left = die.left,\n        .right = die.right\n    };\n    return new_die;\n}\n\nbool dfs(int x, int y, Die die, bool visited[MAX_H][MAX_W]) {\n    if (x == H - 1 && y == W - 1) return true;\n    \n    visited[x][y] = true;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (!is_valid_move(nx, ny) || visited[nx][ny]) continue;\n        \n        Die new_die;\n        if (dx[i] == 1) new_die = roll_down(die);\n        else if (dx[i] == -1) new_die = roll_up(die);\n        else if (dy[i] == 1) new_die = roll_right(die);\n        else new_die = roll_left(die);\n        \n        if (new_die.bottom == (grid[nx][ny] - '0')) {\n            if (dfs(nx, ny, new_die, visited)) return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    Die initial_die = {.top = 1, .bottom = 6, .front = 2, .back = 5, .left = 4, .right = 3};\n    bool visited[MAX_H][MAX_W] = {false};\n    \n    if (grid[0][0] != '6') {\n        printf(\"No\\n\");\n        return 0;\n    }\n    \n    bool result = dfs(0, 0, initial_die, visited);\n    printf(\"%s\\n\", result ? \"Yes\" : \"No\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\ntypedef struct {\n    int i, j;\n    int top, front, right;\n} State;\n\nint H, W;\nchar grid[105][105];\nbool visited[105][105][7][7][7];\n\nconst int di[] = {-1, 1, 0, 0};\nconst int dj[] = {0, 0, -1, 1};\n\nbool isValid(int i, int j) {\n    return i >= 1 && i <= H && j >= 1 && j <= W && grid[i][j] != '#';\n}\n\nbool dfs(int i, int j, int top, int front, int right) {\n    if (i == H && j == W) {\n        return true;\n    }\n    if (visited[i][j][top][front][right]) {\n        return false;\n    }\n    visited[i][j][top][front][right] = true;\n\n    for (int d = 0; d < 4; d++) {\n        int ni = i + di[d];\n        int nj = j + dj[d];\n        if (!isValid(ni, nj)) continue;\n\n        int new_top, new_front, new_right;\n        if (di[d] == -1) { // up\n            new_top = front;\n            new_front = 7 - top;\n            new_right = right;\n        } else if (di[d] == 1) { // down\n            new_top = 7 - front;\n            new_front = top;\n            new_right = right;\n        } else if (dj[d] == -1) { // left\n            new_top = right;\n            new_front = front;\n            new_right = 7 - top;\n        } else { // right\n            new_top = 7 - right;\n            new_front = front;\n            new_right = top;\n        }\n\n        int bottom = 7 - new_top;\n        if (grid[ni][nj] != '#' && (grid[ni][nj] - '0') == bottom) {\n            if (dfs(ni, nj, new_top, new_front, new_right)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 1; i <= H; i++) {\n        scanf(\"%s\", grid[i] + 1);\n    }\n\n    memset(visited, false, sizeof(visited));\n    bool possible = dfs(1, 1, 1, 2, 3);\n    printf(possible ? \"Yes\\n\" : \"No\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nstruct State {\n    int i, j;\n    int bottom, front, right;\n};\n\nbool canReach(int H, int W, const vector<vector<char>>& grid) {\n    if (grid[0][0] != '6') return false;\n    if (grid[H-1][W-1] == '#') return false;\n\n    vector<vector<vector<vector<bool>>>> visited(H, vector<vector<vector<bool>>>(W, vector<vector<bool>>(7, vector<bool>(7, false))));\n    queue<State> q;\n    q.push({0, 0, 6, 2, 3});\n    visited[0][0][6][2] = true;\n\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.i == H-1 && current.j == W-1) {\n            return true;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            int ni = current.i + di[d];\n            int nj = current.j + dj[d];\n            if (ni < 0 || ni >= H || nj < 0 || nj >= W || grid[ni][nj] == '#') continue;\n\n            int newBottom, newFront, newRight;\n            if (di[d] == -1) { // up\n                newBottom = current.front;\n                newFront = 7 - current.bottom;\n                newRight = current.right;\n            } else if (di[d] == 1) { // down\n                newBottom = 7 - current.front;\n                newFront = current.bottom;\n                newRight = current.right;\n            } else if (dj[d] == -1) { // left\n                newBottom = current.right;\n                newFront = current.front;\n                newRight = 7 - current.bottom;\n            } else { // right\n                newBottom = 7 - current.right;\n                newFront = current.front;\n                newRight = current.bottom;\n            }\n\n            if (grid[ni][nj] != '#' && (grid[ni][nj] - '0') == newBottom) {\n                if (!visited[ni][nj][newBottom][newFront]) {\n                    visited[ni][nj][newBottom][newFront] = true;\n                    q.push({ni, nj, newBottom, newFront, newRight});\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    cout << (canReach(H, W, grid) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int i, j;\n        int top, front, right;\n        State(int i, int j, int top, int front, int right) {\n            this.i = i;\n            this.j = j;\n            this.top = top;\n            this.front = front;\n            this.right = right;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[][] grid = new int[H + 1][W + 1];\n        for (int i = 1; i <= H; i++) {\n            String line = sc.next();\n            for (int j = 1; j <= W; j++) {\n                if (line.charAt(j - 1) == '#') {\n                    grid[i][j] = -1;\n                } else {\n                    grid[i][j] = line.charAt(j - 1) - '0';\n                }\n            }\n        }\n\n        if (grid[1][1] != 6 || grid[H][W] == -1) {\n            System.out.println(\"No\");\n            return;\n        }\n\n        boolean[][][][] visited = new boolean[H + 1][W + 1][7][7];\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(1, 1, 1, 5, 4));\n        visited[1][1][1][5] = true;\n\n        int[] di = {-1, 1, 0, 0};\n        int[] dj = {0, 0, -1, 1};\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.i == H && current.j == W) {\n                System.out.println(\"Yes\");\n                return;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int ni = current.i + di[d];\n                int nj = current.j + dj[d];\n                if (ni < 1 || ni > H || nj < 1 || nj > W || grid[ni][nj] == -1) {\n                    continue;\n                }\n\n                int newTop, newFront, newRight;\n                if (di[d] == -1) { // up\n                    newTop = current.front;\n                    newFront = 7 - current.top;\n                    newRight = current.right;\n                } else if (di[d] == 1) { // down\n                    newTop = 7 - current.front;\n                    newFront = current.top;\n                    newRight = current.right;\n                } else if (dj[d] == -1) { // left\n                    newTop = current.right;\n                    newFront = current.front;\n                    newRight = 7 - current.top;\n                } else { // right\n                    newTop = 7 - current.right;\n                    newFront = current.front;\n                    newRight = current.top;\n                }\n\n                if (7 - newTop != grid[ni][nj]) {\n                    continue;\n                }\n\n                if (!visited[ni][nj][newTop][newFront]) {\n                    visited[ni][nj][newTop][newFront] = true;\n                    queue.add(new State(ni, nj, newTop, newFront, newRight));\n                }\n            }\n        }\n        System.out.println(\"No\");\n    }\n}",
    "timestamp": "2025-08-05 22:11:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[] dx = {0, 0, 1, -1};\n    private static final int[] dy = {1, -1, 0, 0};\n\n    public static boolean canReachDestination(int H, int W, String[] grid) {\n        int[][][] visited = new int[H][W][24];\n        Queue<int[]> queue = new LinkedList<>();\n        \n        queue.offer(new int[]{0, 0, 6, 2, 3, 1, 4, 5});\n        visited[0][0][getDieStateIndex(6, 2, 3, 1, 4, 5)] = 1;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1];\n            int bottom = current[2], front = current[3], right = current[4];\n            int top = current[7], back = current[5], left = current[6];\n            \n            if (x == H - 1 && y == W - 1) return true;\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                \n                if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx].charAt(ny) == '#') continue;\n                \n                int[] newDieState = rollDie(bottom, front, right, top, back, left, k);\n                int newBottom = newDieState[0], newFront = newDieState[1], newRight = newDieState[2];\n                int newTop = newDieState[3], newBack = newDieState[4], newLeft = newDieState[5];\n                \n                int stateIndex = getDieStateIndex(newBottom, newFront, newRight, newTop, newBack, newLeft);\n                \n                if (grid[nx].charAt(ny) - '0' == newBottom && visited[nx][ny][stateIndex] == 0) {\n                    queue.offer(new int[]{nx, ny, newBottom, newFront, newRight, newBack, newLeft, newTop});\n                    visited[nx][ny][stateIndex] = 1;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private static int[] rollDie(int bottom, int front, int right, int top, int back, int left, int direction) {\n        switch (direction) {\n            case 0: // Right\n                return new int[]{right, front, top, left, back, bottom};\n            case 1: // Left\n                return new int[]{left, front, bottom, right, back, top};\n            case 2: // Down\n                return new int[]{back, bottom, right, front, top, left};\n            case 3: // Up\n                return new int[]{front, top, right, back, bottom, left};\n        }\n        return null;\n    }\n    \n    private static int getDieStateIndex(int bottom, int front, int right, int top, int back, int left) {\n        return (bottom - 1) * 120 + (front - 1) * 24 + (right - 1) * 6 + (top - 1);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        String[] grid = new String[H];\n        \n        for (int i = 0; i < H; i++) {\n            grid[i] = scanner.next();\n        }\n        \n        boolean result = canReachDestination(H, W, grid);\n        System.out.println(result ? \"Yes\" : \"No\");\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:11:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvector<vector<int>> die_states = {\n    {6, 2, 3, 5, 1, 4},\n    {2, 1, 3, 6, 5, 4},\n    {4, 2, 6, 1, 5, 3},\n    {5, 2, 1, 6, 4, 3}\n};\n\nvector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nbool is_valid(int x, int y, int H, int W, vector<vector<char>>& grid) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] != '#';\n}\n\nbool bfs(vector<vector<char>>& grid) {\n    int H = grid.size(), W = grid[0].size();\n    vector<vector<vector<bool>>> visited(H, vector<vector<bool>>(W, vector<bool>(24, false)));\n    \n    queue<tuple<int, int, int, int>> q;\n    q.push({0, 0, 0, 6});\n    visited[0][0][0] = true;\n    \n    while (!q.empty()) {\n        auto [x, y, die_state, bottom] = q.front();\n        q.pop();\n        \n        if (x == H-1 && y == W-1) return true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + directions[i].first;\n            int ny = y + directions[i].second;\n            \n            if (is_valid(nx, ny, H, W, grid)) {\n                int new_bottom = die_states[i][die_state];\n                int target_val = grid[nx][ny] - '0';\n                \n                if (new_bottom == target_val) {\n                    int new_die_state = (die_state + i) % 4;\n                    if (!visited[nx][ny][new_die_state]) {\n                        q.push({nx, ny, new_die_state, new_bottom});\n                        visited[nx][ny][new_die_state] = true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<char>> grid(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    cout << (bfs(grid) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "# Directions: Down, Up, Right, Left\ndirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n# Die orientation mappings\ndef roll_die(die, direction):\n    # die = [bottom, front, right, back, left, top]\n    if direction == (1, 0):  # Down\n        return [die[1], die[5], die[2], die[0], die[4], die[3]]\n    elif direction == (-1, 0):  # Up\n        return [die[3], die[0], die[2], die[5], die[4], die[1]]\n    elif direction == (0, 1):  # Right\n        return [die[4], die[1], die[0], die[3], die[5], die[2]]\n    elif direction == (0, -1):  # Left\n        return [die[2], die[1], die[5], die[3], die[0], die[4]]\n\ndef can_move_to_target(H, W, grid):\n    from collections import deque\n    \n    initial_die = [6, 2, 3, 5, 4, 1]  # [bottom, front, right, back, left, top]\n    target_position = (H-1, W-1)\n    \n    queue = deque([((0, 0), initial_die)])\n    visited = set([((0, 0), tuple(initial_die))])\n    \n    while queue:\n        (x, y), current_die = queue.popleft()\n        \n        if (x, y) == target_position:\n            return True\n        \n        for direction in directions:\n            new_x, new_y = x + direction[0], y + direction[1]\n            if 0 <= new_x < H and 0 <= new_y < W and grid[new_x][new_y] != '#':\n                new_die = roll_die(current_die, direction)\n                if new_die[0] == int(grid[new_x][new_y]):\n                    new_state = ((new_x, new_y), tuple(new_die))\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        queue.append(new_state)\n    \n    return False\n\n# Example usage\nH = 3\nW = 3\ngrid = [\n    ['6', '#', '6'],\n    ['2', '3', '4'],\n    ['6', '1', '#']\n]\n\nprint(can_move_to_target(H, W, grid))  # Output: False",
    "timestamp": "2025-08-13 09:12:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class DiceRoller {\n    \n    static class State {\n        int x, y, bottom, front, right;\n        \n        State(int x, int y, int bottom, int front, int right) {\n            this.x = x;\n            this.y = y;\n            this.bottom = bottom;\n            this.front = front;\n            this.right = right;\n        }\n    }\n    \n    public static boolean canReachEnd(int H, int W, char[][] grid) {\n        int[][][] dirs = {\n            {{1, 0, 5, 2, 6, 1, 4}, {0, 1}},  // Roll right\n            {{2, 0, 6, 4, 1, 3, 5}, {0, -1}}, // Roll left\n            {{3, 6, 0, 1, 5, 2, 4}, {1, 0}},  // Roll down\n            {{4, 1, 3, 0, 5, 6, 2}, {-1, 0}}  // Roll up\n        };\n        \n        boolean[][][] visited = new boolean[H + 1][W + 1][7];\n        Queue<State> queue = new LinkedList<>();\n        \n        queue.offer(new State(1, 1, 6, 2, 3));\n        visited[1][1][6] = true;\n        \n        while (!queue.isEmpty()) {\n            State cur = queue.poll();\n            if (cur.x == H && cur.y == W) return true;\n            \n            for (int[][] dir : dirs) {\n                int nx = cur.x + dir[1][0];\n                int ny = cur.y + dir[1][1];\n                if (nx < 1 || ny < 1 || nx > H || ny > W) continue;\n\n                int nbottom = dir[0][cur.bottom];\n                int nfront = dir[0][cur.front];\n                int nright = dir[0][cur.right];\n                \n                if (grid[nx - 1][ny - 1] != '#' && nbottom == Character.getNumericValue(grid[nx - 1][ny - 1])) {\n                    if (!visited[nx][ny][nbottom]) {\n                        visited[nx][ny][nbottom] = true;\n                        queue.offer(new State(nx, ny, nbottom, nfront, nright));\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) {\n        int H = 4, W = 4;\n        char[][] grid = {\n            {'1', '1', '1', '1'},\n            {'1', '#', '3', '#'},\n            {'2', '1', '1', '2'},\n            {'1', '#', '2', '#'}\n        };\n        System.out.println(canReachEnd(H, W, grid)); // Output: true or false depending on grid input\n    }\n}",
    "timestamp": "2025-08-13 09:12:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\ntypedef struct {\n    int top, bottom, left, right, front, back;\n} Die;\n\nchar grid[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nint H, W;\n\n// Direction vectors for up, down, left, right\nint dR[] = {-1, 1, 0, 0};\nint dC[] = {0, 0, -1, 1};\n\n// Function to initialize the die to a standard orientation\nvoid initDie(Die *die) {\n    die->top = 1;\n    die->bottom = 6;\n    die->left = 4;\n    die->right = 3;\n    die->front = 2;\n    die->back = 5;\n}\n\n// Function to roll the die up\nvoid rollUp(Die *die) {\n    int temp = die->top;\n    die->top = die->front;\n    die->front = die->bottom;\n    die->bottom = die->back;\n    die->back = temp;\n}\n\n// Function to roll the die down\nvoid rollDown(Die *die) {\n    int temp = die->top;\n    die->top = die->back;\n    die->back = die->bottom;\n    die->bottom = die->front;\n    die->front = temp;\n}\n\n// Function to roll the die left\nvoid rollLeft(Die *die) {\n    int temp = die->top;\n    die->top = die->right;\n    die->right = die->bottom;\n    die->bottom = die->left;\n    die->left = temp;\n}\n\n// Function to roll the die right\nvoid rollRight(Die *die) {\n    int temp = die->top;\n    die->top = die->left;\n    die->left = die->bottom;\n    die->bottom = die->right;\n    die->right = temp;\n}\n\n// Depth-first search to explore grid\nbool dfs(int row, int col, Die die) {\n    if (row == H - 1 && col == W - 1) {\n        return true;\n    }\n    \n    visited[row][col] = true;\n    \n    for (int i = 0; i < 4; ++i) {\n        int newRow = row + dR[i];\n        int newCol = col + dC[i];\n        if (newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !visited[newRow][newCol] && grid[newRow][newCol] != '#') {\n            Die newDie = die;\n            if (i == 0) rollUp(&newDie);\n            if (i == 1) rollDown(&newDie);\n            if (i == 2) rollLeft(&newDie);\n            if (i == 3) rollRight(&newDie);\n            if (newDie.bottom + '0' == grid[newRow][newCol]) {\n                if (dfs(newRow, newCol, newDie)) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    Die die;\n    initDie(&die);\n    if (grid[0][0] == '6' && dfs(0, 0, die)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 09:12:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve(H, W, grid):\n    # Define die faces after rolling in different directions\n    def roll_up(bottom, front, right):\n        return front, 7 - bottom, right\n\n    def roll_down(bottom, front, right):\n        return 7 - front, bottom, right\n\n    def roll_left(bottom, front, right):\n        return right, front, 7 - bottom\n\n    def roll_left(bottom, front, right):\n        return 7 - right, front, bottom\n\n    # Directions: up, right, down, left\n    dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    roll_funcs = [roll_up, roll_right, roll_down, roll_left]\n\n    # Initial state: (row, col, bottom, front, right)\n    start = (0, 0, 6, 2, 3)\n    \n    visited = set()\n    queue = deque([start])\n\n    while queue:\n        row, col, bottom, front, right = queue.popleft()\n\n        # Reached target\n        if row == H - 1 and col == W - 1:\n            return \"Yes\"\n\n        # Avoid revisiting states\n        if (row, col, bottom, front, right) in visited:\n            continue\n        visited.add((row, col, bottom, front, right))\n\n        # Try rolling in each direction\n        for (dx, dy), roll_func in zip(dirs, roll_funcs):\n            new_row, new_col = row + dx, col + dy\n\n            # Check grid boundaries and '#' cells\n            if (0 <= new_row < H and 0 <= new_col < W and \n                grid[new_row][new_col] != '#'):\n                \n                # Compute new die orientation\n                new_bottom, new_front, new_right = roll_func(bottom, front, right)\n\n                # Check if bottom matches cell value\n                if grid[new_row][new_col] == str(new_bottom):\n                    queue.append((new_row, new_col, new_bottom, new_front, new_right))\n\n    return \"No\"\n\n# Read input\nH, W = map(int, input().split())\ngrid = [input().strip() for _ in range(H)]\n\n# Print solution\nprint(solve(H, W, grid))",
    "timestamp": "2025-08-13 09:12:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initial state: (i, j, bottom, front, right)\n    # Initially at (0, 0) in 0-based, bottom=6, front=2, right=3\n    initial = (0, 0, 6, 2, 3)\n    \n    visited = set()\n    visited.add((0, 0, 6, 2, 3))\n    \n    q = deque([initial])\n    \n    target_i = H - 1\n    target_j = W - 1\n    \n    while q:\n        i, j, bottom, front, right = q.popleft()\n        \n        if i == target_i and j == target_j:\n            print(\"Yes\")\n            return\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] != '#':\n                new_bottom, new_front, new_right = bottom, front, right\n                if di == -1:  # up\n                    new_bottom = front\n                    new_front = 7 - bottom\n                elif di == 1:  # down\n                    new_bottom = 7 - front\n                    new_front = bottom\n                elif dj == -1:  # left\n                    new_bottom = right\n                    new_right = 7 - bottom\n                elif dj == 1:  # right\n                    new_bottom = 7 - right\n                    new_right = bottom\n                \n                if int(grid[ni][nj]) == new_bottom:\n                    state = (ni, nj, new_bottom, new_front, new_right)\n                    if state not in visited:\n                        visited.add(state)\n                        q.append(state)\n    \n    print(\"No\")\n\nsolve()",
    "timestamp": "2025-08-13 09:13:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Die {\n    int top, bottom, left, right, front, back;\n    Die() : top(1), bottom(6), left(4), right(3), front(2), back(5) {}\n};\n\nstruct State {\n    int x, y;\n    Die die;\n    State(int px, int py, Die pdie) : x(px), y(py), die(pdie) {}\n};\n\nbool canMove(int H, int W, const vector<vector<char>> &grid) {\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    Die initialDie;\n    queue<State> toVisit;\n    toVisit.push(State(0, 0, initialDie));\n    visited[0][0] = true;\n\n    auto rollDown = [](Die die) {\n        Die newDie = die;\n        newDie.front = die.bottom;\n        newDie.bottom = die.back;\n        newDie.back = die.top;\n        newDie.top = die.front;\n        return newDie;\n    };\n\n    auto rollUp = [](Die die) {\n        Die newDie = die;\n        newDie.back = die.bottom;\n        newDie.bottom = die.front;\n        newDie.front = die.top;\n        newDie.top = die.back;\n        return newDie;\n    };\n\n    auto rollLeft = [](Die die) {\n        Die newDie = die;\n        newDie.right = die.bottom;\n        newDie.bottom = die.left;\n        newDie.left = die.top;\n        newDie.top = die.right;\n        return newDie;\n    };\n\n    auto rollRight = [](Die die) {\n        Die newDie = die;\n        newDie.left = die.bottom;\n        newDie.bottom = die.right;\n        newDie.right = die.top;\n        newDie.top = die.left;\n        return newDie;\n    };\n\n    while (!toVisit.empty()) {\n        State curr = toVisit.front();\n        toVisit.pop();\n\n        int x = curr.x, y = curr.y;\n        Die die = curr.die;\n\n        if (x == H - 1 && y == W - 1) return true;\n\n        // Try to roll in each direction\n        // Down\n        if (x + 1 < H && !visited[x + 1][y] && grid[x + 1][y] != '#' && die.bottom == (grid[x + 1][y] - '0')) {\n            visited[x + 1][y] = true;\n            toVisit.push(State(x + 1, y, rollDown(die)));\n        }\n        // Up\n        if (x - 1 >= 0 && !visited[x - 1][y] && grid[x - 1][y] != '#' && die.bottom == (grid[x - 1][y] - '0')) {\n            visited[x - 1][y] = true;\n            toVisit.push(State(x - 1, y, rollUp(die)));\n        }\n        // Left\n        if (y - 1 >= 0 && !visited[x][y - 1] && grid[x][y - 1] != '#' && die.bottom == (grid[x][y - 1] - '0')) {\n            visited[x][y - 1] = true;\n            toVisit.push(State(x, y - 1, rollLeft(die)));\n        }\n        // Right\n        if (y + 1 < W && !visited[x][y + 1] && grid[x][y + 1] != '#' && die.bottom == (grid[x][y + 1] - '0')) {\n            visited[x][y + 1] = true;\n            toVisit.push(State(x, y + 1, rollRight(die)));\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    if (canMove(H, W, grid))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:09"
  }
]